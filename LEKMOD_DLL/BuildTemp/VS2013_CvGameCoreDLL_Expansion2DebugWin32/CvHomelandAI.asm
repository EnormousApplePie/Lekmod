; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvHomelandAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?m_CurrentBestHighPriorityMoveUnit@@3PAVCvUnit@@A ; m_CurrentBestHighPriorityMoveUnit
PUBLIC	?m_iCurrentBestHighPriorityMoveUnitTurns@@3HA	; m_iCurrentBestHighPriorityMoveUnitTurns
PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
_BSS	SEGMENT
?m_CurrentBestHighPriorityMoveUnit@@3PAVCvUnit@@A DD 01H DUP (?) ; m_CurrentBestHighPriorityMoveUnit
?m_iCurrentBestHighPriorityMoveUnitTurns@@3HA DD 01H DUP (?) ; m_iCurrentBestHighPriorityMoveUnitTurns
_BSS	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??0CvHomelandUnit@@QAE@XZ			; CvHomelandUnit::CvHomelandUnit
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
;	COMDAT ??0CvHomelandUnit@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvHomelandUnit@@QAE@XZ PROC				; CvHomelandUnit::CvHomelandUnit, COMDAT
; _this$ = ecx

; 28   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 29   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvHomelandUnit@@QAE@XZ ENDP				; CvHomelandUnit::CvHomelandUnit
_TEXT	ENDS
PUBLIC	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
PUBLIC	??1?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandMove,35,1,297,0>::~FStaticVector<CvHomelandMove,35,1,297,0>
PUBLIC	??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandUnit,64,1,297,0>::~FStaticVector<CvHomelandUnit,64,1,297,0>
PUBLIC	??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ	; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >
PUBLIC	??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
PUBLIC	??0?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandMove,35,1,297,0>::FStaticVector<CvHomelandMove,35,1,297,0>
PUBLIC	??0?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandUnit,64,1,297,0>::FStaticVector<CvHomelandUnit,64,1,297,0>
PUBLIC	??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ	; std::list<int,std::allocator<int> >::list<int,std::allocator<int> >
PUBLIC	??0CvHomelandAI@@QAE@XZ				; CvHomelandAI::CvHomelandAI
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__ehfuncinfo$??0CvHomelandAI@@QAE@XZ DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$??0CvHomelandAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvHomelandAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvHomelandAI@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvHomelandAI@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvHomelandAI@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvHomelandAI@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvHomelandAI@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvHomelandAI@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvHomelandAI@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CvHomelandAI@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0CvHomelandAI@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0CvHomelandAI@@QAE@XZ$9
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ??0CvHomelandAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -92						; size = 4
__$EHRec$ = -12						; size = 12
??0CvHomelandAI@@QAE@XZ PROC				; CvHomelandAI::CvHomelandAI, COMDAT
; _this$ = ecx

; 37   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvHomelandAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ ; std::list<int,std::allocator<int> >::list<int,std::allocator<int> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandUnit,64,1,297,0>::FStaticVector<CvHomelandUnit,64,1,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1056				; 00000420H
	call	??0?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandUnit,64,1,297,0>::FStaticVector<CvHomelandUnit,64,1,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2096				; 00000830H
	call	??0?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandMove,35,1,297,0>::FStaticVector<CvHomelandMove,35,1,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2412				; 0000096cH
	call	??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2428				; 0000097cH
	call	??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2444				; 0000098cH
	call	??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2460				; 0000099cH
	call	??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2476				; 000009acH
	call	??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2492				; 000009bcH
	call	??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2508				; 000009ccH
	call	??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >

; 38   : #ifdef AUI_WARNING_FIXES
; 39   : 	m_pPlayer = NULL;
; 40   : 	Reset();
; 41   : 	m_iRandomRange = 0;
; 42   : 	m_iDefensiveMoveTurns = 0;
; 43   : 	m_iUpgradeMoveTurns = 0;
; 44   : 	m_fFlavorDampening = 0;
; 45   : #endif
; 46   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvHomelandAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ ; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >
__unwindfunclet$??0CvHomelandAI@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandUnit,64,1,297,0>::~FStaticVector<CvHomelandUnit,64,1,297,0>
__unwindfunclet$??0CvHomelandAI@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1056				; 00000420H
	jmp	??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandUnit,64,1,297,0>::~FStaticVector<CvHomelandUnit,64,1,297,0>
__unwindfunclet$??0CvHomelandAI@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2096				; 00000830H
	jmp	??1?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandMove,35,1,297,0>::~FStaticVector<CvHomelandMove,35,1,297,0>
__unwindfunclet$??0CvHomelandAI@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2412				; 0000096cH
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__unwindfunclet$??0CvHomelandAI@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2428				; 0000097cH
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__unwindfunclet$??0CvHomelandAI@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2444				; 0000098cH
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__unwindfunclet$??0CvHomelandAI@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2460				; 0000099cH
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__unwindfunclet$??0CvHomelandAI@@QAE@XZ$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2476				; 000009acH
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__unwindfunclet$??0CvHomelandAI@@QAE@XZ$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2492				; 000009bcH
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__ehhandler$??0CvHomelandAI@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvHomelandAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvHomelandAI@@QAE@XZ ENDP				; CvHomelandAI::CvHomelandAI
PUBLIC	??1?$_List_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_List_val<int,std::allocator<int> >::~_List_val<int,std::allocator<int> >
PUBLIC	??1?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~_Vector_val<CvHomelandTarget,std::allocator<CvHomelandTarget> >
PUBLIC	?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ	; std::list<int,std::allocator<int> >::clear
PUBLIC	?_Tidy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Tidy
PUBLIC	?Uninit@CvHomelandAI@@QAEXXZ			; CvHomelandAI::Uninit
PUBLIC	??1CvHomelandAI@@QAE@XZ				; CvHomelandAI::~CvHomelandAI
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__ehfuncinfo$??1CvHomelandAI@@QAE@XZ DD 019930522H
	DD	013H
	DD	FLAT:__unwindtable$??1CvHomelandAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvHomelandAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$10
	DD	09H
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$11
	DD	08H
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$13
	DD	07H
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$15
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$17
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$19
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$21
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$23
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$28
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ??1CvHomelandAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -272						; size = 4
$T238253 = -268						; size = 4
$T238183 = -264						; size = 4
$T238160 = -260						; size = 4
$T238117 = -232						; size = 4
$T238031 = -196						; size = 4
$T237945 = -160						; size = 4
$T237859 = -124						; size = 4
$T237773 = -88						; size = 4
$T237687 = -52						; size = 4
$T237601 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvHomelandAI@@QAE@XZ PROC				; CvHomelandAI::~CvHomelandAI, COMDAT
; _this$ = ecx

; 50   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvHomelandAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 260				; 00000104H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH

; 51   : 	Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninit@CvHomelandAI@@QAEXXZ		; CvHomelandAI::Uninit

; 52   : }

	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2508				; 000009ccH
	mov	DWORD PTR $T237601[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR $T237601[ebp]
	call	?_Tidy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2492				; 000009bcH
	mov	DWORD PTR $T237687[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ecx, DWORD PTR $T237687[ebp]
	call	?_Tidy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2476				; 000009acH
	mov	DWORD PTR $T237773[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	ecx, DWORD PTR $T237773[ebp]
	call	?_Tidy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2460				; 0000099cH
	mov	DWORD PTR $T237859[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	ecx, DWORD PTR $T237859[ebp]
	call	?_Tidy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2444				; 0000098cH
	mov	DWORD PTR $T237945[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	ecx, DWORD PTR $T237945[ebp]
	call	?_Tidy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2428				; 0000097cH
	mov	DWORD PTR $T238031[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	mov	ecx, DWORD PTR $T238031[ebp]
	call	?_Tidy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2412				; 0000096cH
	mov	DWORD PTR $T238117[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	mov	ecx, DWORD PTR $T238117[ebp]
	call	?_Tidy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2096				; 00000830H
	call	??1?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandMove,35,1,297,0>::~FStaticVector<CvHomelandMove,35,1,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1056				; 00000420H
	call	??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandUnit,64,1,297,0>::~FStaticVector<CvHomelandUnit,64,1,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandUnit,64,1,297,0>::~FStaticVector<CvHomelandUnit,64,1,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T238253[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 18		; 00000012H
	mov	ecx, DWORD PTR $T238253[ebp]
	call	?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ ; std::list<int,std::allocator<int> >::clear
	mov	edx, DWORD PTR $T238253[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238160[ebp], eax
	mov	ecx, DWORD PTR $T238253[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T238183[ebp], edx
	mov	eax, DWORD PTR $T238183[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	ecx, DWORD PTR $T238253[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ ; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandUnit,64,1,297,0>::~FStaticVector<CvHomelandUnit,64,1,297,0>
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1056				; 00000420H
	jmp	??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandUnit,64,1,297,0>::~FStaticVector<CvHomelandUnit,64,1,297,0>
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2096				; 00000830H
	jmp	??1?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandMove,35,1,297,0>::~FStaticVector<CvHomelandMove,35,1,297,0>
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2412				; 0000096cH
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2428				; 0000097cH
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2444				; 0000098cH
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2460				; 0000099cH
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2476				; 000009acH
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2492				; 000009bcH
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$10:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2508				; 000009ccH
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$11:
	mov	ecx, DWORD PTR $T237601[ebp]
	jmp	??1?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$13:
	mov	ecx, DWORD PTR $T237687[ebp]
	jmp	??1?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$15:
	mov	ecx, DWORD PTR $T237773[ebp]
	jmp	??1?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$17:
	mov	ecx, DWORD PTR $T237859[ebp]
	jmp	??1?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$19:
	mov	ecx, DWORD PTR $T237945[ebp]
	jmp	??1?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$21:
	mov	ecx, DWORD PTR $T238031[ebp]
	jmp	??1?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$23:
	mov	ecx, DWORD PTR $T238117[ebp]
	jmp	??1?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$28:
	mov	ecx, DWORD PTR $T238253[ebp]
	jmp	??1?$_List_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??1CvHomelandAI@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-264]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvHomelandAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvHomelandAI@@QAE@XZ ENDP				; CvHomelandAI::~CvHomelandAI
PUBLIC	?Reset@CvHomelandAI@@QAEXXZ			; CvHomelandAI::Reset
PUBLIC	?Init@CvHomelandAI@@QAEXPAVCvPlayer@@@Z		; CvHomelandAI::Init
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp
;	COMDAT ?Init@CvHomelandAI@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T238277 = -16						; size = 4
$T238273 = -12						; size = 4
$T238269 = -8						; size = 4
$T238265 = -4						; size = 4
_pPlayer$ = 8						; size = 4
?Init@CvHomelandAI@@QAEXPAVCvPlayer@@@Z PROC		; CvHomelandAI::Init, COMDAT
; _this$ = ecx

; 56   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 57   : 	// Store off the pointer to the objects we need elsewhere in the game engine
; 58   : 	m_pPlayer = pPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [eax], ecx

; 59   : 
; 60   : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvHomelandAI@@QAEXXZ		; CvHomelandAI::Reset

; 61   : 
; 62   : 	// Initialize AI constants from XML
; 63   : 	m_iRandomRange = GC.getAI_HOMELAND_MOVE_PRIORITY_RANDOMNESS();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2560
	mov	DWORD PTR $T238265[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T238265[ebp]
	mov	DWORD PTR [eax+2524], ecx

; 64   : 	m_iDefensiveMoveTurns = GC.getAI_HOMELAND_MAX_DEFENSIVE_MOVE_TURNS();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2568
	mov	DWORD PTR $T238269[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T238269[ebp]
	mov	DWORD PTR [eax+2528], ecx

; 65   : 	m_iUpgradeMoveTurns = GC.getAI_HOMELAND_MAX_UPGRADE_MOVE_TURNS();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2564
	mov	DWORD PTR $T238273[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T238273[ebp]
	mov	DWORD PTR [eax+2532], ecx

; 66   : 	m_fFlavorDampening = GC.getAI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION();

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8100
	movss	DWORD PTR $T238277[ebp], xmm0
	cvtss2sd xmm0, DWORD PTR $T238277[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [edx+2536], xmm0

; 67   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Init@CvHomelandAI@@QAEXPAVCvPlayer@@@Z ENDP		; CvHomelandAI::Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Uninit@CvHomelandAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Uninit@CvHomelandAI@@QAEXXZ PROC			; CvHomelandAI::Uninit, COMDAT
; _this$ = ecx

; 71   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@CvHomelandAI@@QAEXXZ ENDP			; CvHomelandAI::Uninit
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Reset@CvHomelandAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Reset@CvHomelandAI@@QAEXXZ PROC			; CvHomelandAI::Reset, COMDAT
; _this$ = ecx

; 76   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 77   : 	m_MovePriorityTurn = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2392], -1

; 78   : 	m_CurrentBestMoveUnit = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2396], 0

; 79   : 	m_CurrentBestMoveHighPriorityUnit = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2404], 0

; 80   : 	m_iCurrentBestMoveUnitTurns = MAX_INT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2400], 2147483647	; 7fffffffH

; 81   : 	m_iCurrentBestMoveHighPriorityUnitTurns = MAX_INT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2408], 2147483647	; 7fffffffH

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@CvHomelandAI@@QAEXXZ ENDP			; CvHomelandAI::Reset
_TEXT	ENDS
PUBLIC	?Read@CvHomelandAI@@QAEXAAVFDataStream@@@Z	; CvHomelandAI::Read
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvHomelandAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvHomelandAI@@QAEXAAVFDataStream@@@Z PROC		; CvHomelandAI::Read, COMDAT
; _this$ = ecx

; 86   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 87   : 	// Version number to maintain backwards compatibility
; 88   : 	uint uiVersion;
; 89   : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 90   : 
; 91   : 	kStream >> m_MovePriorityTurn;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2392				; 00000958H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 92   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvHomelandAI@@QAEXAAVFDataStream@@@Z ENDP		; CvHomelandAI::Read
_TEXT	ENDS
PUBLIC	?Write@CvHomelandAI@@QAEXAAVFDataStream@@@Z	; CvHomelandAI::Write
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvHomelandAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvHomelandAI@@QAEXAAVFDataStream@@@Z PROC	; CvHomelandAI::Write, COMDAT
; _this$ = ecx

; 96   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 97   : 	// Current version number
; 98   : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 99   : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 100  : 
; 101  : 	kStream << m_MovePriorityTurn;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2392				; 00000958H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 102  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvHomelandAI@@QAEXAAVFDataStream@@@Z ENDP	; CvHomelandAI::Write
_TEXT	ENDS
PUBLIC	?_Insert@?$list@HV?$allocator@H@std@@@std@@QAEXV?$_Const_iterator@$0A@@12@ABH@Z ; std::list<int,std::allocator<int> >::_Insert
PUBLIC	?RecruitUnits@CvHomelandAI@@QAEXXZ		; CvHomelandAI::RecruitUnits
EXTRN	?canMove@CvUnit@@QBE_NXZ:PROC			; CvUnit::canMove
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
EXTRN	?isDelayedDeath@CvUnit@@QBE_NXZ:PROC		; CvUnit::isDelayedDeath
EXTRN	?TurnProcessed@CvUnit@@QBE_NXZ:PROC		; CvUnit::TurnProcessed
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
EXTRN	__CxxThrowException@8:PROC
; Function compile flags: /Odtp
;	COMDAT ?RecruitUnits@CvHomelandAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -136						; size = 4
$T238408 = -132						; size = 4
$T238349 = -44						; size = 4
$T238401 = -40						; size = 4
$T238400 = -36						; size = 4
$T238336 = -32						; size = 4
$T238301 = -12						; size = 4
_pLoopUnit$ = -8					; size = 4
_iLoop$ = -4						; size = 4
?RecruitUnits@CvHomelandAI@@QAEXXZ PROC			; CvHomelandAI::RecruitUnits, COMDAT
; _this$ = ecx

; 106  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	DWORD PTR _this$[ebp], ecx

; 107  : 	CvUnit* pLoopUnit;
; 108  : 	int iLoop;
; 109  : 
; 110  : 	m_CurrentTurnUnits.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ ; std::list<int,std::allocator<int> >::clear

; 111  : 
; 112  : 	// Loop through our units
; 113  : 	for(pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN4@RecruitUni
$LN3@RecruitUni:
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN4@RecruitUni:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	$LN5@RecruitUni

; 114  : 	{
; 115  : 		// Never want immobile/dead units or ones that have already moved
; 116  : 		if(!pLoopUnit->TurnProcessed() && !pLoopUnit->isDelayedDeath() && pLoopUnit->AI_getUnitAIType() != UNITAI_UNKNOWN && pLoopUnit->canMove())

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?TurnProcessed@CvUnit@@QBE_NXZ		; CvUnit::TurnProcessed
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@RecruitUni
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?isDelayedDeath@CvUnit@@QBE_NXZ		; CvUnit::isDelayedDeath
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@RecruitUni
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	test	eax, eax
	je	SHORT $LN1@RecruitUni
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@RecruitUni

; 117  : 		{
; 118  : 			m_CurrentTurnUnits.push_back(pLoopUnit->GetID());

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T238336[ebp], edx
	mov	eax, DWORD PTR $T238336[ebp]
	mov	DWORD PTR $T238301[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T238408[ebp], ecx
	mov	edx, DWORD PTR $T238408[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238349[ebp], eax
	mov	ecx, DWORD PTR $T238349[ebp]
	mov	DWORD PTR $T238401[ebp], ecx
	mov	edx, DWORD PTR $T238401[ebp]
	mov	DWORD PTR $T238400[ebp], edx
	lea	eax, DWORD PTR $T238301[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238400[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T238408[ebp]
	call	?_Insert@?$list@HV?$allocator@H@std@@@std@@QAEXV?$_Const_iterator@$0A@@12@ABH@Z ; std::list<int,std::allocator<int> >::_Insert
$LN1@RecruitUni:

; 119  : 		}

	jmp	$LN3@RecruitUni
$LN5@RecruitUni:

; 120  : 	}
; 121  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RecruitUnits@CvHomelandAI@@QAEXXZ ENDP			; CvHomelandAI::RecruitUnits
_TEXT	ENDS
PUBLIC	?FindAutomatedUnits@CvHomelandAI@@QAEXXZ	; CvHomelandAI::FindAutomatedUnits
EXTRN	?IsAutomated@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsAutomated
; Function compile flags: /Odtp
;	COMDAT ?FindAutomatedUnits@CvHomelandAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -136						; size = 4
$T238517 = -132						; size = 4
$T238459 = -44						; size = 4
$T238510 = -40						; size = 4
$T238509 = -36						; size = 4
$T238446 = -32						; size = 4
$T238411 = -12						; size = 4
_pLoopUnit$ = -8					; size = 4
_iLoop$ = -4						; size = 4
?FindAutomatedUnits@CvHomelandAI@@QAEXXZ PROC		; CvHomelandAI::FindAutomatedUnits, COMDAT
; _this$ = ecx

; 125  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	DWORD PTR _this$[ebp], ecx

; 126  : 	CvUnit* pLoopUnit;
; 127  : 	int iLoop;
; 128  : 
; 129  : 	m_CurrentTurnUnits.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ ; std::list<int,std::allocator<int> >::clear

; 130  : 
; 131  : 	// Loop through our units
; 132  : 	for(pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN4@FindAutoma
$LN3@FindAutoma:
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN4@FindAutoma:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	$LN5@FindAutoma

; 133  : 	{
; 134  : 		if(pLoopUnit->IsAutomated() && !pLoopUnit->TurnProcessed() && pLoopUnit->AI_getUnitAIType() != UNITAI_UNKNOWN && pLoopUnit->canMove())

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@FindAutoma
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?TurnProcessed@CvUnit@@QBE_NXZ		; CvUnit::TurnProcessed
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@FindAutoma
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	test	eax, eax
	je	SHORT $LN1@FindAutoma
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@FindAutoma

; 135  : 		{
; 136  : 			m_CurrentTurnUnits.push_back(pLoopUnit->GetID());

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T238446[ebp], edx
	mov	eax, DWORD PTR $T238446[ebp]
	mov	DWORD PTR $T238411[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T238517[ebp], ecx
	mov	edx, DWORD PTR $T238517[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238459[ebp], eax
	mov	ecx, DWORD PTR $T238459[ebp]
	mov	DWORD PTR $T238510[ebp], ecx
	mov	edx, DWORD PTR $T238510[ebp]
	mov	DWORD PTR $T238509[ebp], edx
	lea	eax, DWORD PTR $T238411[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238509[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T238517[ebp]
	call	?_Insert@?$list@HV?$allocator@H@std@@@std@@QAEXV?$_Const_iterator@$0A@@12@ABH@Z ; std::list<int,std::allocator<int> >::_Insert
$LN1@FindAutoma:

; 137  : 		}

	jmp	$LN3@FindAutoma
$LN5@FindAutoma:

; 138  : 	}
; 139  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindAutomatedUnits@CvHomelandAI@@QAEXXZ ENDP		; CvHomelandAI::FindAutomatedUnits
_TEXT	ENDS
PUBLIC	?DoTurn@CvHomelandAI@@QAEXXZ			; CvHomelandAI::DoTurn
; Function compile flags: /Odtp
;	COMDAT ?DoTurn@CvHomelandAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DoTurn@CvHomelandAI@@QAEXXZ PROC			; CvHomelandAI::DoTurn, COMDAT
; _this$ = ecx

; 143  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 144  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoTurn@CvHomelandAI@@QAEXXZ ENDP			; CvHomelandAI::DoTurn
_TEXT	ENDS
PUBLIC	?AssignHomelandMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::AssignHomelandMoves
PUBLIC	?FindHomelandTargets@CvHomelandAI@@AAEXXZ	; CvHomelandAI::FindHomelandTargets
PUBLIC	?EstablishHomelandPriorities@CvHomelandAI@@AAEXXZ ; CvHomelandAI::EstablishHomelandPriorities
PUBLIC	?Update@CvHomelandAI@@QAEXXZ			; CvHomelandAI::Update
EXTRN	?UpdatePlots@CvEconomicAI@@QAEXXZ:PROC		; CvEconomicAI::UpdatePlots
EXTRN	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ:PROC ; CvPlayer::GetEconomicAI
; Function compile flags: /Odtp
;	COMDAT ?Update@CvHomelandAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pEconomicAI$224251 = -4				; size = 4
?Update@CvHomelandAI@@QAEXXZ PROC			; CvHomelandAI::Update, COMDAT
; _this$ = ecx

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 149  : 	AI_PERF_FORMAT("AI-perf.csv", ("Homeland AI, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()));
; 150  : 
; 151  : 	// Make sure we have a unit to handle
; 152  : 	if(!m_CurrentTurnUnits.empty())

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN2@Update

; 153  : 	{
; 154  : 		// Make sure the economic plots are up-to-date, it has a caching system in it.
; 155  : 		CvEconomicAI* pEconomicAI = m_pPlayer->GetEconomicAI();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR _pEconomicAI$224251[ebp], eax

; 156  : 		pEconomicAI->UpdatePlots();

	mov	ecx, DWORD PTR _pEconomicAI$224251[ebp]
	call	?UpdatePlots@CvEconomicAI@@QAEXXZ	; CvEconomicAI::UpdatePlots

; 157  : 
; 158  : 		// Start by establishing the priority order for moves this turn
; 159  : 		EstablishHomelandPriorities();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EstablishHomelandPriorities@CvHomelandAI@@AAEXXZ ; CvHomelandAI::EstablishHomelandPriorities

; 160  : 
; 161  : 		// Put together lists of places we may want to move toward
; 162  : 		FindHomelandTargets();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindHomelandTargets@CvHomelandAI@@AAEXXZ ; CvHomelandAI::FindHomelandTargets

; 163  : 
; 164  : 		// Loop through each move assigning units when available
; 165  : 		AssignHomelandMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AssignHomelandMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::AssignHomelandMoves
$LN2@Update:

; 166  : 	}
; 167  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Update@CvHomelandAI@@QAEXXZ ENDP			; CvHomelandAI::Update
_TEXT	ENDS
PUBLIC	??1?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QAE@XZ ; BaseVector<std::pair<int,CvPlot *>,0>::~BaseVector<std::pair<int,CvPlot *>,0>
PUBLIC	??1?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@XZ ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::~FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>
PUBLIC	?IsValidExplorerEndTurnPlot@CvHomelandAI@@ABE_NPBVCvUnit@@PAVCvPlot@@@Z ; CvHomelandAI::IsValidExplorerEndTurnPlot
PUBLIC	??$_Sort@PAU?$pair@HPAVCvPlot@@@std@@HP6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0HP6A_NABU10@1@Z@Z ; std::_Sort<std::pair<int,CvPlot *> *,int,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
PUBLIC	?push_back@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAEIABU?$pair@HPAVCvPlot@@@std@@@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::push_back
PUBLIC	?SetSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::SetSize
PUBLIC	?Alloc@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEPAU?$pair@HPAVCvPlot@@@std@@I@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::Alloc
PUBLIC	?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z ; CvHomelandAI::IsAnyValidExploreMoves
EXTRN	?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z:PROC ; CvTwoLayerPathFinder::GenerateUnitPath
EXTRN	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ:PROC ; CvGlobals::getPathFinder
EXTRN	?GetExplorationPlotRatings@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ:PROC ; CvEconomicAI::GetExplorationPlotRatings
EXTRN	?GetExplorationPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ:PROC ; CvEconomicAI::GetExplorationPlots
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z$0
__ehfuncinfo$?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z
_TEXT	SEGMENT
tv270 = -176						; size = 4
_this$ = -172						; size = 4
$T238647 = -144						; size = 4
$T238643 = -140						; size = 4
$T238633 = -136						; size = 4
$T238626 = -132						; size = 4
$T238622 = -128						; size = 4
$T238608 = -120						; size = 4
$T238604 = -116						; size = 4
$T238591 = -112						; size = 4
$T238584 = -108						; size = 4
$T238577 = -104						; size = 4
$T238563 = -100						; size = 4
$T238534 = -96						; size = 4
$T238529 = -89						; size = 1
$T238528 = -88						; size = 4
$T238527 = -84						; size = 8
_pEvalPlot$224496 = -76					; size = 4
_bCanFindPath$224498 = -69				; size = 1
_itr$224492 = -68					; size = 4
_iPlot$224473 = -64					; size = 4
_pEvalPlot$224475 = -60					; size = 4
_iDistX$224478 = -56					; size = 4
_iDistY$224479 = -52					; size = 4
_ui$224469 = -48					; size = 4
_aDistanceList$224468 = -44				; size = 12
_iUnitY$224401 = -32					; size = 4
_iUnitX$224400 = -28					; size = 4
_pEconomicAI$ = -24					; size = 4
_aiExplorationPlots$ = -20				; size = 4
_aiExplorationPlotRatings$ = -16			; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z PROC ; CvHomelandAI::IsAnyValidExploreMoves, COMDAT
; _this$ = ecx

; 179  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 180  : 	CvEconomicAI* pEconomicAI = m_pPlayer->GetEconomicAI();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR _pEconomicAI$[ebp], eax

; 181  : 	FFastVector<int>& aiExplorationPlots = pEconomicAI->GetExplorationPlots();

	mov	ecx, DWORD PTR _pEconomicAI$[ebp]
	call	?GetExplorationPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ ; CvEconomicAI::GetExplorationPlots
	mov	DWORD PTR _aiExplorationPlots$[ebp], eax

; 182  : 	FFastVector<int>& aiExplorationPlotRatings = pEconomicAI->GetExplorationPlotRatings();

	mov	ecx, DWORD PTR _pEconomicAI$[ebp]
	call	?GetExplorationPlotRatings@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ ; CvEconomicAI::GetExplorationPlotRatings
	mov	DWORD PTR _aiExplorationPlotRatings$[ebp], eax

; 183  : 
; 184  : 	if (aiExplorationPlots.size() > 0)

	mov	ecx, DWORD PTR _aiExplorationPlots$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T238534[ebp], edx
	cmp	DWORD PTR $T238534[ebp], 0
	jbe	$LN13@IsAnyValid

; 185  : 	{
; 186  : 		int iUnitX = pUnit->getX();

	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR _iUnitX$224400[ebp], ecx

; 187  : 		int iUnitY = pUnit->getY();

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR _iUnitY$224401[ebp], eax

; 188  : 
; 189  : 		// Filter the list with some quick checks, then add the rest to a list that we can sort by distance
; 190  : 		DistanceSortedPlotArray aDistanceList;

	mov	DWORD PTR _aDistanceList$224468[ebp], 0
	mov	DWORD PTR _aDistanceList$224468[ebp+4], 0
	mov	DWORD PTR _aDistanceList$224468[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	lea	ecx, DWORD PTR _aDistanceList$224468[ebp]
	call	?Alloc@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEPAU?$pair@HPAVCvPlot@@@std@@I@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _aDistanceList$224468[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 191  : 		aDistanceList.reserve( aiExplorationPlots.size() );

	mov	ecx, DWORD PTR _aiExplorationPlots$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T238563[ebp], edx
	mov	eax, DWORD PTR $T238563[ebp]
	cmp	eax, DWORD PTR _aDistanceList$224468[ebp+8]
	ja	SHORT $LN36@IsAnyValid
	jmp	SHORT $LN34@IsAnyValid
$LN36@IsAnyValid:
	mov	ecx, DWORD PTR $T238563[ebp]
	push	ecx
	lea	ecx, DWORD PTR _aDistanceList$224468[ebp]
	call	?SetSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::SetSize
$LN34@IsAnyValid:

; 192  : 
; 193  : 		for(uint ui = 0; ui < aiExplorationPlots.size(); ui++)

	mov	DWORD PTR _ui$224469[ebp], 0
	jmp	SHORT $LN12@IsAnyValid
$LN11@IsAnyValid:
	mov	edx, DWORD PTR _ui$224469[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$224469[ebp], edx
$LN12@IsAnyValid:
	mov	eax, DWORD PTR _aiExplorationPlots$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T238577[ebp], ecx
	mov	edx, DWORD PTR _ui$224469[ebp]
	cmp	edx, DWORD PTR $T238577[ebp]
	jae	$LN10@IsAnyValid

; 194  : 		{
; 195  : 			int iPlot = aiExplorationPlots[ui];

	mov	eax, DWORD PTR _aiExplorationPlots$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _ui$224469[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _iPlot$224473[ebp], eax

; 196  : 			if(iPlot < 0)

	cmp	DWORD PTR _iPlot$224473[ebp], 0
	jge	SHORT $LN9@IsAnyValid

; 197  : 			{
; 198  : 				continue;

	jmp	SHORT $LN11@IsAnyValid
$LN9@IsAnyValid:

; 199  : 			}
; 200  : 
; 201  : 			CvPlot* pEvalPlot = GC.getMap().plotByIndex(iPlot);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T238584[ebp], ecx
	cmp	DWORD PTR _iPlot$224473[ebp], 0
	jl	SHORT $LN47@IsAnyValid
	mov	edx, DWORD PTR $T238584[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T238591[ebp], eax
	mov	ecx, DWORD PTR _iPlot$224473[ebp]
	cmp	ecx, DWORD PTR $T238591[ebp]
	jge	SHORT $LN47@IsAnyValid
	mov	edx, DWORD PTR _iPlot$224473[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T238584[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv270[ebp], edx
	jmp	SHORT $LN45@IsAnyValid
$LN47@IsAnyValid:
	mov	DWORD PTR tv270[ebp], 0
$LN45@IsAnyValid:
	mov	ecx, DWORD PTR tv270[ebp]
	mov	DWORD PTR _pEvalPlot$224475[ebp], ecx

; 202  : 			if(!pEvalPlot)

	cmp	DWORD PTR _pEvalPlot$224475[ebp], 0
	jne	SHORT $LN51@IsAnyValid

; 203  : 			{
; 204  : 				continue;

	jmp	$LN11@IsAnyValid

; 205  : 			}
; 206  : 
; 207  : 			if(aiExplorationPlotRatings[ui] == 0)

$LN51@IsAnyValid:
	mov	edx, DWORD PTR _aiExplorationPlotRatings$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ui$224469[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	jne	SHORT $LN7@IsAnyValid

; 208  : 			{
; 209  : 				continue;

	jmp	$LN11@IsAnyValid
$LN7@IsAnyValid:

; 210  : 			}
; 211  : 
; 212  : 			int iDistX = abs( pEvalPlot->getX() - iUnitX );

	mov	edx, DWORD PTR _pEvalPlot$224475[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T238604[ebp], eax
	mov	eax, DWORD PTR $T238604[ebp]
	sub	eax, DWORD PTR _iUnitX$224400[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDistX$224478[ebp], eax

; 213  : 			int iDistY = abs( pEvalPlot->getY() - iUnitY );

	mov	ecx, DWORD PTR _pEvalPlot$224475[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T238608[ebp], edx
	mov	eax, DWORD PTR $T238608[ebp]
	sub	eax, DWORD PTR _iUnitY$224401[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDistY$224479[ebp], eax

; 214  : 
; 215  : 			aDistanceList.push_back(std::pair<int, CvPlot*>((iDistX*iDistX)+(iDistY*iDistY), pEvalPlot));

	mov	eax, DWORD PTR _iDistX$224478[ebp]
	imul	eax, DWORD PTR _iDistX$224478[ebp]
	mov	ecx, DWORD PTR _iDistY$224479[ebp]
	imul	ecx, DWORD PTR _iDistY$224479[ebp]
	add	eax, ecx
	mov	DWORD PTR $T238528[ebp], eax
	mov	edx, DWORD PTR $T238528[ebp]
	mov	DWORD PTR $T238527[ebp], edx
	mov	eax, DWORD PTR _pEvalPlot$224475[ebp]
	mov	DWORD PTR $T238527[ebp+4], eax
	lea	ecx, DWORD PTR $T238527[ebp]
	push	ecx
	lea	ecx, DWORD PTR _aDistanceList$224468[ebp]
	call	?push_back@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAEIABU?$pair@HPAVCvPlot@@@std@@@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::push_back

; 216  : 
; 217  : 		}

	jmp	$LN11@IsAnyValid
$LN10@IsAnyValid:

; 218  : 
; 219  : 		if (aDistanceList.size())

	mov	edx, DWORD PTR _aDistanceList$224468[ebp+4]
	mov	DWORD PTR $T238622[ebp], edx
	cmp	DWORD PTR $T238622[ebp], 0
	je	$LN6@IsAnyValid

; 220  : 		{
; 221  : 			std::sort(aDistanceList.begin(), aDistanceList.end(), SortUnitDistance);

	mov	eax, DWORD PTR _aDistanceList$224468[ebp+4]
	mov	ecx, DWORD PTR _aDistanceList$224468[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T238626[ebp], edx
	mov	eax, DWORD PTR _aDistanceList$224468[ebp]
	mov	DWORD PTR $T238633[ebp], eax
	push	OFFSET ?SortUnitDistance@@YA_NABU?$pair@HPAVCvPlot@@@std@@0@Z ; SortUnitDistance
	mov	ecx, DWORD PTR $T238626[ebp]
	sub	ecx, DWORD PTR $T238633[ebp]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR $T238626[ebp]
	push	edx
	mov	eax, DWORD PTR $T238633[ebp]
	push	eax
	call	??$_Sort@PAU?$pair@HPAVCvPlot@@@std@@HP6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0HP6A_NABU10@1@Z@Z ; std::_Sort<std::pair<int,CvPlot *> *,int,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 16					; 00000010H

; 222  : 
; 223  : 			for (DistanceSortedPlotArray::const_iterator itr = aDistanceList.begin(); itr != aDistanceList.end(); ++itr)

	mov	ecx, DWORD PTR _aDistanceList$224468[ebp]
	mov	DWORD PTR _itr$224492[ebp], ecx
	jmp	SHORT $LN76@IsAnyValid
$LN4@IsAnyValid:
	mov	edx, DWORD PTR _itr$224492[ebp]
	add	edx, 8
	mov	DWORD PTR _itr$224492[ebp], edx
$LN76@IsAnyValid:
	mov	eax, DWORD PTR _aDistanceList$224468[ebp+4]
	mov	ecx, DWORD PTR _aDistanceList$224468[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	cmp	DWORD PTR _itr$224492[ebp], edx
	je	$LN6@IsAnyValid

; 224  : 			{
; 225  : 				CvPlot* pEvalPlot = (*itr).second;

	mov	eax, DWORD PTR _itr$224492[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pEvalPlot$224496[ebp], ecx

; 226  : 				if(!IsValidExplorerEndTurnPlot(pUnit, pEvalPlot))

	mov	edx, DWORD PTR _pEvalPlot$224496[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidExplorerEndTurnPlot@CvHomelandAI@@ABE_NPBVCvUnit@@PAVCvPlot@@@Z ; CvHomelandAI::IsValidExplorerEndTurnPlot
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@IsAnyValid

; 227  : 				{
; 228  : 					continue;

	jmp	SHORT $LN4@IsAnyValid
$LN2@IsAnyValid:

; 229  : 				}
; 230  : 				// hitting the path finder, may not be the best idea. . .
; 231  : 				bool bCanFindPath = GC.getPathFinder().GenerateUnitPath(pUnit, iUnitX, iUnitY, pEvalPlot->getX(), pEvalPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER /*iFlags*/, true/*bReuse*/);

	mov	edx, DWORD PTR _pEvalPlot$224496[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T238643[ebp], eax
	mov	ecx, DWORD PTR _pEvalPlot$224496[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T238647[ebp], edx
	push	1
	push	138					; 0000008aH
	mov	eax, DWORD PTR $T238643[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238647[ebp]
	push	ecx
	mov	edx, DWORD PTR _iUnitY$224401[ebp]
	push	edx
	mov	eax, DWORD PTR _iUnitX$224400[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	ecx, eax
	call	?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z ; CvTwoLayerPathFinder::GenerateUnitPath
	mov	BYTE PTR _bCanFindPath$224498[ebp], al

; 232  : 				if(!bCanFindPath)

	movzx	edx, BYTE PTR _bCanFindPath$224498[ebp]
	test	edx, edx
	jne	SHORT $LN1@IsAnyValid

; 233  : 				{
; 234  : 					continue;

	jmp	$LN4@IsAnyValid
$LN1@IsAnyValid:

; 235  : 				}
; 236  : 
; 237  : 				return true;

	mov	BYTE PTR $T238529[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _aDistanceList$224468[ebp]
	call	??1?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@XZ ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::~FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>
	mov	al, BYTE PTR $T238529[ebp]
	jmp	SHORT $LN14@IsAnyValid

; 238  : 			}

	jmp	$LN4@IsAnyValid
$LN6@IsAnyValid:

; 239  : 		}
; 240  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _aDistanceList$224468[ebp]
	call	??1?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@XZ ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::~FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>
$LN13@IsAnyValid:

; 241  : 
; 242  : 
; 243  : 	return false;

	xor	al, al
$LN14@IsAnyValid:

; 244  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z$1:
	lea	ecx, DWORD PTR _aDistanceList$224468[ebp]
	jmp	??1?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QAE@XZ ; BaseVector<std::pair<int,CvPlot *>,0>::~BaseVector<std::pair<int,CvPlot *>,0>
__unwindfunclet$?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z$0:
	lea	ecx, DWORD PTR _aDistanceList$224468[ebp]
	jmp	??1?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@XZ ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::~FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>
__ehhandler$?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-168]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z ENDP ; CvHomelandAI::IsAnyValidExploreMoves
; Function compile flags: /Odtp
;	COMDAT ?SortUnitDistance@@YA_NABU?$pair@HPAVCvPlot@@@std@@0@Z
_TEXT	SEGMENT
_kEntry1$ = 8						; size = 4
_kEntry2$ = 12						; size = 4
?SortUnitDistance@@YA_NABU?$pair@HPAVCvPlot@@@std@@0@Z PROC ; SortUnitDistance, COMDAT

; 174  : {

	push	ebp
	mov	ebp, esp

; 175  : 	return kEntry1.first < kEntry2.first;

	mov	eax, DWORD PTR _kEntry1$[ebp]
	mov	ecx, DWORD PTR _kEntry2$[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	setl	al

; 176  : }

	pop	ebp
	ret	0
?SortUnitDistance@@YA_NABU?$pair@HPAVCvPlot@@@std@@0@Z ENDP ; SortUnitDistance
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>
PUBLIC	?push_back@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAEIABVCvHomelandMove@@@Z ; FStaticVector<CvHomelandMove,35,1,297,0>::push_back
PUBLIC	??_C@_0P@DAJFKJHO@FLAVOR_CULTURE?$AA@		; `string'
PUBLIC	??_C@_0BJ@NNFHMIPH@FLAVOR_MILITARY_TRAINING?$AA@ ; `string'
PUBLIC	??_C@_0O@CBMDBMFP@FLAVOR_WONDER?$AA@		; `string'
PUBLIC	??_C@_0P@NPJBAHPJ@FLAVOR_SCIENCE?$AA@		; `string'
PUBLIC	??_C@_0M@IKAIFEKA@FLAVOR_GOLD?$AA@		; `string'
PUBLIC	??_C@_0N@PFDLLNAJ@FLAVOR_RECON?$AA@		; `string'
PUBLIC	??_C@_0BB@PHIOLDJK@FLAVOR_EXPANSION?$AA@	; `string'
PUBLIC	??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@		; `string'
PUBLIC	??_C@_0P@CHEPBLFE@FLAVOR_DEFENSE?$AA@		; `string'
EXTRN	?HasPolicyEncouragingGarrisons@CvPlayerPolicies@@QBE_NXZ:PROC ; CvPlayerPolicies::HasPolicyEncouragingGarrisons
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
EXTRN	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z:PROC ; CvFlavorManager::GetIndividualFlavor
EXTRN	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ:PROC ; CvPlayer::GetFlavorManager
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
;	COMDAT ??_C@_0P@DAJFKJHO@FLAVOR_CULTURE?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
CONST	SEGMENT
??_C@_0P@DAJFKJHO@FLAVOR_CULTURE?$AA@ DB 'FLAVOR_CULTURE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NNFHMIPH@FLAVOR_MILITARY_TRAINING?$AA@
CONST	SEGMENT
??_C@_0BJ@NNFHMIPH@FLAVOR_MILITARY_TRAINING?$AA@ DB 'FLAVOR_MILITARY_TRAI'
	DB	'NING', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBMDBMFP@FLAVOR_WONDER?$AA@
CONST	SEGMENT
??_C@_0O@CBMDBMFP@FLAVOR_WONDER?$AA@ DB 'FLAVOR_WONDER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NPJBAHPJ@FLAVOR_SCIENCE?$AA@
CONST	SEGMENT
??_C@_0P@NPJBAHPJ@FLAVOR_SCIENCE?$AA@ DB 'FLAVOR_SCIENCE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IKAIFEKA@FLAVOR_GOLD?$AA@
CONST	SEGMENT
??_C@_0M@IKAIFEKA@FLAVOR_GOLD?$AA@ DB 'FLAVOR_GOLD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PFDLLNAJ@FLAVOR_RECON?$AA@
CONST	SEGMENT
??_C@_0N@PFDLLNAJ@FLAVOR_RECON?$AA@ DB 'FLAVOR_RECON', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PHIOLDJK@FLAVOR_EXPANSION?$AA@
CONST	SEGMENT
??_C@_0BB@PHIOLDJK@FLAVOR_EXPANSION?$AA@ DB 'FLAVOR_EXPANSION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@
CONST	SEGMENT
??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@ DB 'FLAVOR_OFFENSE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CHEPBLFE@FLAVOR_DEFENSE?$AA@
CONST	SEGMENT
??_C@_0P@CHEPBLFE@FLAVOR_DEFENSE?$AA@ DB 'FLAVOR_DEFENSE', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
CONST	ENDS
;	COMDAT ?EstablishHomelandPriorities@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv356 = -548						; size = 4
tv281 = -544						; size = 4
_this$ = -540						; size = 4
$T238912 = -160						; size = 4
$T238908 = -156						; size = 4
$T238907 = -152						; size = 4
$T238795 = -120						; size = 4
$T238782 = -116						; size = 4
$T238778 = -112						; size = 4
$T238774 = -108						; size = 4
$T238770 = -104						; size = 4
$T238766 = -100						; size = 4
$T238762 = -96						; size = 4
$T238758 = -92						; size = 4
$T238754 = -88						; size = 4
$T238750 = -84						; size = 4
$T238746 = -80						; size = 4
$T238742 = -76						; size = 4
$T238738 = -72						; size = 4
_i$238733 = -68						; size = 4
_move$224630 = -64					; size = 8
_iI$224569 = -56					; size = 4
_iFlavorLoop$224516 = -52				; size = 4
_iFlavorWonder$ = -48					; size = 4
_iFlavorMilitaryTraining$ = -44				; size = 4
_iPriority$ = -40					; size = 4
_iFlavorNavalImprove$ = -36				; size = 4
_iFlavorCulture$ = -32					; size = 4
_iFlavorOffense$ = -28					; size = 4
_iFlavorExplore$ = -24					; size = 4
_iFlavorExpand$ = -20					; size = 4
_iFlavorScience$ = -16					; size = 4
_iFlavorGold$ = -12					; size = 4
_iFlavorDefense$ = -8					; size = 4
_iFlavorImprove$ = -4					; size = 4
?EstablishHomelandPriorities@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::EstablishHomelandPriorities, COMDAT
; _this$ = ecx

; 250  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 548				; 00000224H
	mov	DWORD PTR _this$[ebp], ecx

; 251  : 	int iPriority = 0;

	mov	DWORD PTR _iPriority$[ebp], 0

; 252  : 	int iFlavorDefense = 0;

	mov	DWORD PTR _iFlavorDefense$[ebp], 0

; 253  : 	int iFlavorOffense = 0;

	mov	DWORD PTR _iFlavorOffense$[ebp], 0

; 254  : 	int iFlavorExpand = 0;

	mov	DWORD PTR _iFlavorExpand$[ebp], 0

; 255  : 	int iFlavorImprove = 0;

	mov	DWORD PTR _iFlavorImprove$[ebp], 0

; 256  : 	int iFlavorNavalImprove = 0;

	mov	DWORD PTR _iFlavorNavalImprove$[ebp], 0

; 257  : 	int iFlavorExplore = 0;

	mov	DWORD PTR _iFlavorExplore$[ebp], 0

; 258  : 	int iFlavorGold = 0;

	mov	DWORD PTR _iFlavorGold$[ebp], 0

; 259  : 	int iFlavorScience = 0;

	mov	DWORD PTR _iFlavorScience$[ebp], 0

; 260  : 	int iFlavorWonder = 0;

	mov	DWORD PTR _iFlavorWonder$[ebp], 0

; 261  : 	int iFlavorMilitaryTraining = 0;

	mov	DWORD PTR _iFlavorMilitaryTraining$[ebp], 0

; 262  : 	int iFlavorCulture = 0;

	mov	DWORD PTR _iFlavorCulture$[ebp], 0

; 263  : 
; 264  : 	m_MovePriorityList.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2096				; 00000830H
	mov	DWORD PTR $T238738[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN78@EstablishH
	mov	DWORD PTR _i$238733[ebp], 0
	jmp	SHORT $LN80@EstablishH
$LN79@EstablishH:
	mov	edx, DWORD PTR _i$238733[ebp]
	add	edx, 1
	mov	DWORD PTR _i$238733[ebp], edx
$LN80@EstablishH:
	mov	eax, DWORD PTR $T238738[ebp]
	mov	ecx, DWORD PTR _i$238733[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN78@EstablishH
	jmp	SHORT $LN79@EstablishH
$LN78@EstablishH:
	mov	edx, DWORD PTR $T238738[ebp]
	mov	DWORD PTR [edx+4], 0

; 265  : 	m_MovePriorityTurn = GC.getGame().getGameTurn();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238742[ebp], eax
	mov	ecx, DWORD PTR $T238742[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2392], eax

; 266  : 
; 267  : 	// Find required flavor values
; 268  : 	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$224516[ebp], 0
	jmp	SHORT $LN73@EstablishH
$LN72@EstablishH:
	mov	edx, DWORD PTR _iFlavorLoop$224516[ebp]
	add	edx, 1
	mov	DWORD PTR _iFlavorLoop$224516[ebp], edx
$LN73@EstablishH:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T238746[ebp], eax
	mov	ecx, DWORD PTR _iFlavorLoop$224516[ebp]
	cmp	ecx, DWORD PTR $T238746[ebp]
	jge	$LN71@EstablishH

; 269  : 	{
; 270  : 		if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_DEFENSE")

	mov	edx, DWORD PTR _iFlavorLoop$224516[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T238750[ebp], edx
	push	OFFSET ??_C@_0P@CHEPBLFE@FLAVOR_DEFENSE?$AA@
	mov	eax, DWORD PTR $T238750[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN70@EstablishH

; 271  : 		{
; 272  : 			iFlavorDefense = m_pPlayer->GetFlavorManager()->GetIndividualFlavor((FlavorTypes)iFlavorLoop);

	mov	edx, DWORD PTR _iFlavorLoop$224516[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetIndividualFlavor
	mov	DWORD PTR _iFlavorDefense$[ebp], eax

; 273  : 			iFlavorDefense = (int)((double)iFlavorDefense * m_fFlavorDampening);

	cvtsi2sd xmm0, DWORD PTR _iFlavorDefense$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mulsd	xmm0, QWORD PTR [ecx+2536]
	cvttsd2si edx, xmm0
	mov	DWORD PTR _iFlavorDefense$[ebp], edx
$LN70@EstablishH:

; 274  : 		}
; 275  : 		if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_OFFENSE")

	mov	eax, DWORD PTR _iFlavorLoop$224516[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T238754[ebp], eax
	push	OFFSET ??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@
	mov	ecx, DWORD PTR $T238754[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN69@EstablishH

; 276  : 		{
; 277  : 			iFlavorOffense = m_pPlayer->GetFlavorManager()->GetIndividualFlavor((FlavorTypes)iFlavorLoop);

	mov	eax, DWORD PTR _iFlavorLoop$224516[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetIndividualFlavor
	mov	DWORD PTR _iFlavorOffense$[ebp], eax

; 278  : 			iFlavorOffense = (int)((double)iFlavorOffense * m_fFlavorDampening);

	cvtsi2sd xmm0, DWORD PTR _iFlavorOffense$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mulsd	xmm0, QWORD PTR [edx+2536]
	cvttsd2si eax, xmm0
	mov	DWORD PTR _iFlavorOffense$[ebp], eax
	jmp	$LN55@EstablishH
$LN69@EstablishH:

; 279  : 		}
; 280  : 		else if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_EXPANSION")

	mov	ecx, DWORD PTR _iFlavorLoop$224516[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T238758[ebp], ecx
	push	OFFSET ??_C@_0BB@PHIOLDJK@FLAVOR_EXPANSION?$AA@
	mov	edx, DWORD PTR $T238758[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN67@EstablishH

; 281  : 		{
; 282  : 			iFlavorExpand = m_pPlayer->GetFlavorManager()->GetIndividualFlavor((FlavorTypes)iFlavorLoop);

	mov	ecx, DWORD PTR _iFlavorLoop$224516[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetIndividualFlavor
	mov	DWORD PTR _iFlavorExpand$[ebp], eax
	jmp	$LN55@EstablishH
$LN67@EstablishH:

; 283  : 		}
; 284  : 		else if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_RECON")

	mov	eax, DWORD PTR _iFlavorLoop$224516[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T238762[ebp], eax
	push	OFFSET ??_C@_0N@PFDLLNAJ@FLAVOR_RECON?$AA@
	mov	ecx, DWORD PTR $T238762[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN65@EstablishH

; 285  : 		{
; 286  : 			iFlavorExplore = m_pPlayer->GetFlavorManager()->GetIndividualFlavor((FlavorTypes)iFlavorLoop);

	mov	eax, DWORD PTR _iFlavorLoop$224516[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetIndividualFlavor
	mov	DWORD PTR _iFlavorExplore$[ebp], eax

; 287  : 			iFlavorExplore = (int)((double)iFlavorExplore * m_fFlavorDampening);

	cvtsi2sd xmm0, DWORD PTR _iFlavorExplore$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mulsd	xmm0, QWORD PTR [edx+2536]
	cvttsd2si eax, xmm0
	mov	DWORD PTR _iFlavorExplore$[ebp], eax
	jmp	$LN55@EstablishH
$LN65@EstablishH:

; 288  : 		}
; 289  : 		else if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_GOLD")

	mov	ecx, DWORD PTR _iFlavorLoop$224516[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T238766[ebp], ecx
	push	OFFSET ??_C@_0M@IKAIFEKA@FLAVOR_GOLD?$AA@
	mov	edx, DWORD PTR $T238766[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN63@EstablishH

; 290  : 		{
; 291  : 			iFlavorGold = m_pPlayer->GetFlavorManager()->GetIndividualFlavor((FlavorTypes)iFlavorLoop);

	mov	ecx, DWORD PTR _iFlavorLoop$224516[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetIndividualFlavor
	mov	DWORD PTR _iFlavorGold$[ebp], eax
	jmp	$LN55@EstablishH
$LN63@EstablishH:

; 292  : 		}
; 293  : 		else if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_SCIENCE")

	mov	eax, DWORD PTR _iFlavorLoop$224516[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T238770[ebp], eax
	push	OFFSET ??_C@_0P@NPJBAHPJ@FLAVOR_SCIENCE?$AA@
	mov	ecx, DWORD PTR $T238770[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN61@EstablishH

; 294  : 		{
; 295  : 			iFlavorScience = m_pPlayer->GetFlavorManager()->GetIndividualFlavor((FlavorTypes)iFlavorLoop);

	mov	eax, DWORD PTR _iFlavorLoop$224516[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetIndividualFlavor
	mov	DWORD PTR _iFlavorScience$[ebp], eax
	jmp	$LN55@EstablishH
$LN61@EstablishH:

; 296  : 		}
; 297  : 		else if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_WONDER")

	mov	edx, DWORD PTR _iFlavorLoop$224516[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T238774[ebp], edx
	push	OFFSET ??_C@_0O@CBMDBMFP@FLAVOR_WONDER?$AA@
	mov	eax, DWORD PTR $T238774[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN59@EstablishH

; 298  : 		{
; 299  : 			iFlavorWonder = m_pPlayer->GetFlavorManager()->GetIndividualFlavor((FlavorTypes)iFlavorLoop);

	mov	edx, DWORD PTR _iFlavorLoop$224516[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetIndividualFlavor
	mov	DWORD PTR _iFlavorWonder$[ebp], eax
	jmp	$LN55@EstablishH
$LN59@EstablishH:

; 300  : 		}
; 301  : 		else if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_MILITARY_TRAINING")

	mov	ecx, DWORD PTR _iFlavorLoop$224516[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T238778[ebp], ecx
	push	OFFSET ??_C@_0BJ@NNFHMIPH@FLAVOR_MILITARY_TRAINING?$AA@
	mov	edx, DWORD PTR $T238778[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN57@EstablishH

; 302  : 		{
; 303  : 			iFlavorMilitaryTraining = m_pPlayer->GetFlavorManager()->GetIndividualFlavor((FlavorTypes)iFlavorLoop);

	mov	ecx, DWORD PTR _iFlavorLoop$224516[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetIndividualFlavor
	mov	DWORD PTR _iFlavorMilitaryTraining$[ebp], eax
	jmp	SHORT $LN55@EstablishH
$LN57@EstablishH:

; 304  : 		}
; 305  : 		else if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_CULTURE")

	mov	eax, DWORD PTR _iFlavorLoop$224516[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T238782[ebp], eax
	push	OFFSET ??_C@_0P@DAJFKJHO@FLAVOR_CULTURE?$AA@
	mov	ecx, DWORD PTR $T238782[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN55@EstablishH

; 306  : 		{
; 307  : 			iFlavorCulture = m_pPlayer->GetFlavorManager()->GetIndividualFlavor((FlavorTypes)iFlavorLoop);

	mov	eax, DWORD PTR _iFlavorLoop$224516[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetIndividualFlavor
	mov	DWORD PTR _iFlavorCulture$[ebp], eax
$LN55@EstablishH:

; 308  : 		}
; 309  : 	}

	jmp	$LN72@EstablishH
$LN71@EstablishH:

; 310  : 
; 311  : 	// Loop through each possible homeland move (other than "none" or "unassigned")
; 312  : 	for(int iI = AI_HOMELAND_MOVE_UNASSIGNED + 1; iI < NUM_AI_HOMELAND_MOVES; iI++)

	mov	DWORD PTR _iI$224569[ebp], 1
	jmp	SHORT $LN54@EstablishH
$LN53@EstablishH:
	mov	edx, DWORD PTR _iI$224569[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$224569[ebp], edx
$LN54@EstablishH:
	cmp	DWORD PTR _iI$224569[ebp], 33		; 00000021H
	jge	$LN52@EstablishH

; 313  : 	{
; 314  : 		// Set base value
; 315  : 		switch((AIHomelandMove)iI)

	mov	eax, DWORD PTR _iI$224569[ebp]
	mov	DWORD PTR tv281[ebp], eax
	mov	ecx, DWORD PTR tv281[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv281[ebp], ecx
	cmp	DWORD PTR tv281[ebp], 31		; 0000001fH
	ja	$LN50@EstablishH
	mov	edx, DWORD PTR tv281[ebp]
	jmp	DWORD PTR $LN422@EstablishH[edx*4]
$LN49@EstablishH:

; 316  : 		{
; 317  : 		case AI_HOMELAND_MOVE_EXPLORE:
; 318  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_EXPLORE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2596
	mov	DWORD PTR _iPriority$[ebp], eax

; 319  : 			break;

	jmp	$LN50@EstablishH
$LN48@EstablishH:

; 320  : 		case AI_HOMELAND_MOVE_EXPLORE_SEA:
; 321  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_EXPLORE_SEA();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2600
	mov	DWORD PTR _iPriority$[ebp], ecx

; 322  : 			break;

	jmp	$LN50@EstablishH
$LN47@EstablishH:

; 323  : 		case AI_HOMELAND_MOVE_SETTLE:
; 324  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_SETTLE();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2576
	mov	DWORD PTR _iPriority$[ebp], edx

; 325  : 			break;

	jmp	$LN50@EstablishH
$LN46@EstablishH:

; 326  : 		case AI_HOMELAND_MOVE_GARRISON:
; 327  : 			// Garrisons must beat out sentries if policies encourage garrisoning
; 328  : 			if(m_pPlayer->GetPlayerPolicies()->HasPolicyEncouragingGarrisons())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?HasPolicyEncouragingGarrisons@CvPlayerPolicies@@QBE_NXZ ; CvPlayerPolicies::HasPolicyEncouragingGarrisons
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN45@EstablishH

; 329  : 			{
; 330  : 				iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_SENTRY() + 1;

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2604
	mov	DWORD PTR $T238795[ebp], edx
	mov	eax, DWORD PTR $T238795[ebp]
	add	eax, 1
	mov	DWORD PTR _iPriority$[ebp], eax

; 331  : 			}
; 332  : 			else

	jmp	SHORT $LN114@EstablishH
$LN45@EstablishH:

; 333  : 			{
; 334  : 				iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_GARRISON();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2612
	mov	DWORD PTR _iPriority$[ebp], ecx
$LN114@EstablishH:

; 335  : 			}
; 336  : 			break;

	jmp	$LN50@EstablishH
$LN43@EstablishH:

; 337  : 		case AI_HOMELAND_MOVE_HEAL:
; 338  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_HEAL();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2580
	mov	DWORD PTR _iPriority$[ebp], edx

; 339  : 			break;

	jmp	$LN50@EstablishH
$LN42@EstablishH:

; 340  : 		case AI_HOMELAND_MOVE_TO_SAFETY:
; 341  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_TO_SAFETY();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2584
	mov	DWORD PTR _iPriority$[ebp], eax

; 342  : 			break;

	jmp	$LN50@EstablishH
$LN41@EstablishH:

; 343  : 		case AI_HOMELAND_MOVE_MOBILE_RESERVE:
; 344  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_MOBILE_RESERVE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2608
	mov	DWORD PTR _iPriority$[ebp], ecx

; 345  : 			break;

	jmp	$LN50@EstablishH
$LN40@EstablishH:

; 346  : 		case AI_HOMELAND_MOVE_SENTRY:
; 347  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_SENTRY();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2604
	mov	DWORD PTR _iPriority$[ebp], edx

; 348  : 			break;

	jmp	$LN50@EstablishH
$LN39@EstablishH:

; 349  : 		case AI_HOMELAND_MOVE_WORKER:
; 350  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_WORKER();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2588
	mov	DWORD PTR _iPriority$[ebp], eax

; 351  : 			break;

	jmp	$LN50@EstablishH
$LN38@EstablishH:

; 352  : 		case AI_HOMELAND_MOVE_WORKER_SEA:
; 353  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_WORKER_SEA();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2592
	mov	DWORD PTR _iPriority$[ebp], ecx

; 354  : 			break;

	jmp	$LN50@EstablishH
$LN37@EstablishH:

; 355  : 		case AI_HOMELAND_MOVE_PATROL:
; 356  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_PATROL();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2616
	mov	DWORD PTR _iPriority$[ebp], edx

; 357  : 			break;

	jmp	$LN50@EstablishH
$LN36@EstablishH:

; 358  : 		case AI_HOMELAND_MOVE_UPGRADE:
; 359  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_UPGRADE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2620
	mov	DWORD PTR _iPriority$[ebp], eax

; 360  : 			break;

	jmp	$LN50@EstablishH
$LN35@EstablishH:

; 361  : 		case AI_HOMELAND_MOVE_ANCIENT_RUINS:
; 362  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_ANCIENT_RUINS();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2624
	mov	DWORD PTR _iPriority$[ebp], ecx

; 363  : 			break;

	jmp	$LN50@EstablishH
$LN34@EstablishH:

; 364  : 		case AI_HOMELAND_MOVE_GARRISON_CITY_STATE:
; 365  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_GARRISON_CITY_STATE();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2628
	mov	DWORD PTR _iPriority$[ebp], edx

; 366  : 			break;

	jmp	$LN50@EstablishH
$LN33@EstablishH:

; 367  : 		case AI_HOMELAND_MOVE_WRITER:
; 368  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_WRITER();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2632
	mov	DWORD PTR _iPriority$[ebp], eax

; 369  : 			break;

	jmp	$LN50@EstablishH
$LN32@EstablishH:

; 370  : 		case AI_HOMELAND_MOVE_ARTIST_GOLDEN_AGE:
; 371  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_ARTIST();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2636
	mov	DWORD PTR _iPriority$[ebp], ecx

; 372  : 			break;

	jmp	$LN50@EstablishH
$LN31@EstablishH:

; 373  : 		case AI_HOMELAND_MOVE_MUSICIAN:
; 374  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_MUSICIAN();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2640
	mov	DWORD PTR _iPriority$[ebp], edx

; 375  : 			break;

	jmp	$LN50@EstablishH
$LN30@EstablishH:

; 376  : 		case AI_HOMELAND_MOVE_SCIENTIST_FREE_TECH:
; 377  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_SCIENTIST_FREE_TECH();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2644
	mov	DWORD PTR _iPriority$[ebp], eax

; 378  : 			break;

	jmp	$LN50@EstablishH
$LN29@EstablishH:

; 379  : 		case AI_HOMELAND_MOVE_ENGINEER_HURRY:
; 380  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_ENGINEER_HURRY();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2648
	mov	DWORD PTR _iPriority$[ebp], ecx

; 381  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN28@EstablishH:

; 382  : 		case AI_HOMELAND_MOVE_GENERAL_GARRISON:
; 383  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_GENERAL_GARRISON();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2652
	mov	DWORD PTR _iPriority$[ebp], edx

; 384  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN27@EstablishH:

; 385  : 		case AI_HOMELAND_MOVE_ADMIRAL_GARRISON:
; 386  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_ADMIRAL_GARRISON();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2656
	mov	DWORD PTR _iPriority$[ebp], eax

; 387  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN26@EstablishH:

; 388  : 		case AI_HOMELAND_MOVE_PROPHET_RELIGION:
; 389  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_PROPHET_RELIGION();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2660
	mov	DWORD PTR _iPriority$[ebp], ecx

; 390  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN25@EstablishH:

; 391  : 		case AI_HOMELAND_MOVE_MISSIONARY:
; 392  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_MISSIONARY();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2664
	mov	DWORD PTR _iPriority$[ebp], edx

; 393  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN24@EstablishH:

; 394  : 		case AI_HOMELAND_MOVE_INQUISITOR:
; 395  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_INQUISITOR();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2668
	mov	DWORD PTR _iPriority$[ebp], eax

; 396  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN23@EstablishH:

; 397  : 		case AI_HOMELAND_MOVE_SPACESHIP_PART:
; 398  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_SPACESHIP_PART();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2672
	mov	DWORD PTR _iPriority$[ebp], ecx

; 399  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN22@EstablishH:

; 400  : 		case AI_HOMELAND_MOVE_ADD_SPACESHIP_PART:
; 401  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_ADD_SPACESHIP_PART();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2676
	mov	DWORD PTR _iPriority$[ebp], edx

; 402  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN21@EstablishH:

; 403  : 		case AI_HOMELAND_MOVE_AIRCRAFT_TO_THE_FRONT:
; 404  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_AIRCRAFT_TO_THE_FRONT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2680
	mov	DWORD PTR _iPriority$[ebp], eax

; 405  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN20@EstablishH:

; 406  : 		case AI_HOMELAND_MOVE_TREASURE:
; 407  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_TREASURE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2684
	mov	DWORD PTR _iPriority$[ebp], ecx

; 408  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN19@EstablishH:

; 409  : 		case AI_HOMELAND_MOVE_TRADE_UNIT:
; 410  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_TRADE_UNIT();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2688
	mov	DWORD PTR _iPriority$[ebp], edx

; 411  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN18@EstablishH:

; 412  : 		case AI_HOMELAND_MOVE_ARCHAEOLOGIST:
; 413  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_ARCHAEOLOGIST();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2692
	mov	DWORD PTR _iPriority$[ebp], eax

; 414  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN17@EstablishH:

; 415  : 		case AI_HOMELAND_MOVE_AIRLIFT:
; 416  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_AIRLIFT();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2696
	mov	DWORD PTR _iPriority$[ebp], ecx
$LN50@EstablishH:

; 417  : 			break;
; 418  : 		}
; 419  : 
; 420  : 		// Make sure base priority is not negative
; 421  : 		if(iPriority >= 0)

	cmp	DWORD PTR _iPriority$[ebp], 0
	jl	$LN16@EstablishH

; 422  : 		{
; 423  : 			// Now add in the appropriate flavor value
; 424  : 			switch((AIHomelandMove)iI)

	mov	edx, DWORD PTR _iI$224569[ebp]
	mov	DWORD PTR tv356[ebp], edx
	mov	eax, DWORD PTR tv356[ebp]
	sub	eax, 1
	mov	DWORD PTR tv356[ebp], eax
	cmp	DWORD PTR tv356[ebp], 30		; 0000001eH
	ja	$LN14@EstablishH
	mov	ecx, DWORD PTR tv356[ebp]
	movzx	edx, BYTE PTR $LN421@EstablishH[ecx]
	jmp	DWORD PTR $LN423@EstablishH[edx*4]
$LN13@EstablishH:

; 425  : 			{
; 426  : 				// Defensive moves
; 427  : 			case AI_HOMELAND_MOVE_GARRISON:
; 428  : 			case AI_HOMELAND_MOVE_HEAL:
; 429  : 			case AI_HOMELAND_MOVE_TO_SAFETY:
; 430  : 			case AI_HOMELAND_MOVE_MOBILE_RESERVE:
; 431  : 			case AI_HOMELAND_MOVE_SENTRY:
; 432  : 			case AI_HOMELAND_MOVE_GARRISON_CITY_STATE:
; 433  : 			case AI_HOMELAND_MOVE_GENERAL_GARRISON:
; 434  : 			case AI_HOMELAND_MOVE_ADMIRAL_GARRISON:
; 435  : 			case AI_HOMELAND_MOVE_AIRCRAFT_TO_THE_FRONT:
; 436  : 			case AI_HOMELAND_MOVE_TREASURE:
; 437  : 
; 438  : 				// Here so they remain same priority relative to AI_HOMELAND_MOVE_TO_SAFETY
; 439  : 			case AI_HOMELAND_MOVE_MISSIONARY:
; 440  : 			case AI_HOMELAND_MOVE_INQUISITOR:
; 441  : 			case AI_HOMELAND_MOVE_PROPHET_RELIGION:
; 442  : 			case AI_HOMELAND_MOVE_SPACESHIP_PART:
; 443  : 			case AI_HOMELAND_MOVE_ADD_SPACESHIP_PART:
; 444  : 				iPriority += iFlavorDefense;

	mov	eax, DWORD PTR _iPriority$[ebp]
	add	eax, DWORD PTR _iFlavorDefense$[ebp]
	mov	DWORD PTR _iPriority$[ebp], eax

; 445  : 				break;

	jmp	$LN14@EstablishH
$LN12@EstablishH:

; 446  : 
; 447  : 				// Other miscellaneous types
; 448  : 			case AI_HOMELAND_MOVE_EXPLORE:
; 449  : 			case AI_HOMELAND_MOVE_EXPLORE_SEA:
; 450  : 				iPriority += iFlavorExplore;

	mov	ecx, DWORD PTR _iPriority$[ebp]
	add	ecx, DWORD PTR _iFlavorExplore$[ebp]
	mov	DWORD PTR _iPriority$[ebp], ecx

; 451  : 				break;

	jmp	SHORT $LN14@EstablishH
$LN11@EstablishH:

; 452  : 
; 453  : 			case AI_HOMELAND_MOVE_SETTLE:
; 454  : 				iPriority += iFlavorExpand;

	mov	edx, DWORD PTR _iPriority$[ebp]
	add	edx, DWORD PTR _iFlavorExpand$[ebp]
	mov	DWORD PTR _iPriority$[ebp], edx

; 455  : 				break;

	jmp	SHORT $LN14@EstablishH
$LN10@EstablishH:

; 456  : 
; 457  : 			case AI_HOMELAND_MOVE_WORKER:
; 458  : 				iPriority += iFlavorImprove;

	mov	eax, DWORD PTR _iPriority$[ebp]
	add	eax, DWORD PTR _iFlavorImprove$[ebp]
	mov	DWORD PTR _iPriority$[ebp], eax

; 459  : 				break;

	jmp	SHORT $LN14@EstablishH
$LN9@EstablishH:

; 460  : 
; 461  : 			case AI_HOMELAND_MOVE_WORKER_SEA:
; 462  : 				iPriority += iFlavorNavalImprove;

	mov	ecx, DWORD PTR _iPriority$[ebp]
	add	ecx, DWORD PTR _iFlavorNavalImprove$[ebp]
	mov	DWORD PTR _iPriority$[ebp], ecx

; 463  : 				break;

	jmp	SHORT $LN14@EstablishH
$LN8@EstablishH:

; 464  : 
; 465  : 			case AI_HOMELAND_MOVE_UPGRADE:
; 466  : 				iPriority += iFlavorMilitaryTraining;

	mov	edx, DWORD PTR _iPriority$[ebp]
	add	edx, DWORD PTR _iFlavorMilitaryTraining$[ebp]
	mov	DWORD PTR _iPriority$[ebp], edx

; 467  : 				break;

	jmp	SHORT $LN14@EstablishH
$LN7@EstablishH:

; 468  : 
; 469  : 			case AI_HOMELAND_MOVE_WRITER:
; 470  : 				iPriority += iFlavorCulture;

	mov	eax, DWORD PTR _iPriority$[ebp]
	add	eax, DWORD PTR _iFlavorCulture$[ebp]
	mov	DWORD PTR _iPriority$[ebp], eax

; 471  : 				break;

	jmp	SHORT $LN14@EstablishH
$LN6@EstablishH:

; 472  : 
; 473  : 			case AI_HOMELAND_MOVE_ARTIST_GOLDEN_AGE:
; 474  : 				iPriority += iFlavorCulture;

	mov	ecx, DWORD PTR _iPriority$[ebp]
	add	ecx, DWORD PTR _iFlavorCulture$[ebp]
	mov	DWORD PTR _iPriority$[ebp], ecx

; 475  : 				break;

	jmp	SHORT $LN14@EstablishH
$LN5@EstablishH:

; 476  : 
; 477  : 			case AI_HOMELAND_MOVE_MUSICIAN:
; 478  : 				iPriority += iFlavorCulture;

	mov	edx, DWORD PTR _iPriority$[ebp]
	add	edx, DWORD PTR _iFlavorCulture$[ebp]
	mov	DWORD PTR _iPriority$[ebp], edx

; 479  : 				break;

	jmp	SHORT $LN14@EstablishH
$LN4@EstablishH:

; 480  : 
; 481  : 			case AI_HOMELAND_MOVE_ANCIENT_RUINS:
; 482  : 				iPriority += iFlavorExplore;

	mov	eax, DWORD PTR _iPriority$[ebp]
	add	eax, DWORD PTR _iFlavorExplore$[ebp]
	mov	DWORD PTR _iPriority$[ebp], eax

; 483  : 				break;

	jmp	SHORT $LN14@EstablishH
$LN3@EstablishH:

; 484  : 
; 485  : 			case AI_HOMELAND_MOVE_SCIENTIST_FREE_TECH:
; 486  : 				iPriority += iFlavorScience;

	mov	ecx, DWORD PTR _iPriority$[ebp]
	add	ecx, DWORD PTR _iFlavorScience$[ebp]
	mov	DWORD PTR _iPriority$[ebp], ecx

; 487  : 				break;

	jmp	SHORT $LN14@EstablishH
$LN2@EstablishH:

; 488  : 
; 489  : 			case AI_HOMELAND_MOVE_ENGINEER_HURRY:
; 490  : 				iPriority += iFlavorWonder;

	mov	edx, DWORD PTR _iPriority$[ebp]
	add	edx, DWORD PTR _iFlavorWonder$[ebp]
	mov	DWORD PTR _iPriority$[ebp], edx

; 491  : 				break;

	jmp	SHORT $LN14@EstablishH
$LN1@EstablishH:

; 492  : 
; 493  : 			case AI_HOMELAND_MOVE_TRADE_UNIT:
; 494  : 				iPriority += iFlavorGold;

	mov	eax, DWORD PTR _iPriority$[ebp]
	add	eax, DWORD PTR _iFlavorGold$[ebp]
	mov	DWORD PTR _iPriority$[ebp], eax
$LN14@EstablishH:

; 495  : 				break;
; 496  : 			}
; 497  : 
; 498  : 			// Store off this move and priority
; 499  : 			CvHomelandMove move;

	mov	DWORD PTR _move$224630[ebp], -1
	mov	DWORD PTR _move$224630[ebp+4], 0

; 500  : 			move.m_eMoveType = (AIHomelandMove)iI;

	mov	ecx, DWORD PTR _iI$224569[ebp]
	mov	DWORD PTR _move$224630[ebp], ecx

; 501  : 			move.m_iPriority = iPriority;

	mov	edx, DWORD PTR _iPriority$[ebp]
	mov	DWORD PTR _move$224630[ebp+4], edx

; 502  : 			m_MovePriorityList.push_back(move);

	lea	eax, DWORD PTR _move$224630[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2096				; 00000830H
	call	?push_back@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAEIABVCvHomelandMove@@@Z ; FStaticVector<CvHomelandMove,35,1,297,0>::push_back
$LN16@EstablishH:

; 503  : 		}
; 504  : 	}

	jmp	$LN53@EstablishH
$LN52@EstablishH:

; 505  : 
; 506  : 	// Now sort the moves in priority order
; 507  : 	std::stable_sort(m_MovePriorityList.begin(), m_MovePriorityList.end());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2096				; 00000830H
	mov	DWORD PTR $T238907[ebp], ecx
	mov	edx, DWORD PTR $T238907[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR $T238907[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T238908[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2096]
	mov	DWORD PTR $T238912[ebp], edx
	mov	eax, DWORD PTR $T238912[ebp]
	cmp	eax, DWORD PTR $T238908[ebp]
	je	SHORT $LN202@EstablishH
	push	0
	push	0
	mov	ecx, DWORD PTR $T238908[ebp]
	push	ecx
	mov	edx, DWORD PTR $T238912[ebp]
	push	edx
	call	??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>
	add	esp, 16					; 00000010H
$LN202@EstablishH:

; 508  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN422@EstablishH:
	DD	$LN49@EstablishH
	DD	$LN48@EstablishH
	DD	$LN47@EstablishH
	DD	$LN46@EstablishH
	DD	$LN43@EstablishH
	DD	$LN42@EstablishH
	DD	$LN41@EstablishH
	DD	$LN40@EstablishH
	DD	$LN39@EstablishH
	DD	$LN38@EstablishH
	DD	$LN37@EstablishH
	DD	$LN36@EstablishH
	DD	$LN35@EstablishH
	DD	$LN34@EstablishH
	DD	$LN33@EstablishH
	DD	$LN32@EstablishH
	DD	$LN31@EstablishH
	DD	$LN30@EstablishH
	DD	$LN50@EstablishH
	DD	$LN29@EstablishH
	DD	$LN28@EstablishH
	DD	$LN27@EstablishH
	DD	$LN23@EstablishH
	DD	$LN21@EstablishH
	DD	$LN20@EstablishH
	DD	$LN26@EstablishH
	DD	$LN25@EstablishH
	DD	$LN24@EstablishH
	DD	$LN19@EstablishH
	DD	$LN18@EstablishH
	DD	$LN22@EstablishH
	DD	$LN17@EstablishH
$LN423@EstablishH:
	DD	$LN12@EstablishH
	DD	$LN11@EstablishH
	DD	$LN13@EstablishH
	DD	$LN10@EstablishH
	DD	$LN9@EstablishH
	DD	$LN8@EstablishH
	DD	$LN4@EstablishH
	DD	$LN7@EstablishH
	DD	$LN6@EstablishH
	DD	$LN5@EstablishH
	DD	$LN3@EstablishH
	DD	$LN2@EstablishH
	DD	$LN1@EstablishH
	DD	$LN14@EstablishH
$LN421@EstablishH:
	DB	0
	DB	0
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	3
	DB	4
	DB	13					; 0000000dH
	DB	5
	DB	6
	DB	2
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	13					; 0000000dH
	DB	11					; 0000000bH
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	2
?EstablishHomelandPriorities@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::EstablishHomelandPriorities
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
PUBLIC	?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ ; CvHomelandAI::EliminateAdjacentHomelandRoads
PUBLIC	?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ ; CvHomelandAI::EliminateAdjacentSentryPoints
PUBLIC	?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
PUBLIC	?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase
EXTRN	?isRoute@CvPlot@@QBE_NXZ:PROC			; CvPlot::isRoute
EXTRN	?isCoastalLand@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isCoastalLand
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	?GetClosestFriendlyCity@CvPlayer@@QAEPAVCvCity@@AAVCvPlot@@H@Z:PROC ; CvPlayer::GetClosestFriendlyCity
EXTRN	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z:PROC	; CvPlayer::GetPlotDanger
EXTRN	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z:PROC ; CvPlot::defenseModifier
EXTRN	?GetNumAdjacentDifferentTeam@CvPlot@@QBEHW4TeamTypes@@_N@Z:PROC ; CvPlot::GetNumAdjacentDifferentTeam
EXTRN	?isAdjacentTeam@CvPlot@@QBE_NW4TeamTypes@@_N@Z:PROC ; CvPlot::isAdjacentTeam
EXTRN	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlot::getNumDefenders
EXTRN	?isUnit@CvPlot@@QBE_NXZ:PROC			; CvPlot::isUnit
EXTRN	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::IsCanDefend
EXTRN	?atWar@@YA_NW4TeamTypes@@0@Z:PROC		; atWar
EXTRN	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ:PROC	; CvUnit::getTeam
EXTRN	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z:PROC	; CvPlot::getUnitByIndex
EXTRN	?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::isVisibleOtherUnit
EXTRN	?IsPlayerMadeNoDiggingPromise@CvDiplomacyAI@@QAE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsPlayerMadeNoDiggingPromise
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC	; CvPlot::isGoody
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::IsImprovementResourceTrade
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?IsWater@CvBuildInfo@@QBE_NXZ:PROC		; CvBuildInfo::IsWater
EXTRN	?getImprovement@CvBuildInfo@@QBEHXZ:PROC	; CvBuildInfo::getImprovement
EXTRN	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z:PROC ; CvGlobals::getBuildInfo
EXTRN	?getNumBuildInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildInfos
EXTRN	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ:PROC	; CvPlot::getWorkingCity
EXTRN	?getNonObsoleteResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getNonObsoleteResourceType
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
EXTRN	?getThreatValue@CvCity@@QAEHXZ:PROC		; CvCity::getThreatValue
EXTRN	?isUnderTacticalControl@CvUnit@@QBE_NXZ:PROC	; CvUnit::isUnderTacticalControl
EXTRN	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z:PROC ; CvPlot::getBestDefender
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$?FindHomelandTargets@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindHomelandTargets@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?FindHomelandTargets@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindHomelandTargets@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?FindHomelandTargets@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -840						; size = 4
$T240675 = -836						; size = 4
$T240674 = -832						; size = 4
$T240400 = -680						; size = 4
$T240384 = -676						; size = 4
$T240255 = -616						; size = 4
$T240248 = -612						; size = 4
$T240238 = -608						; size = 4
_playerID$240230 = -604					; size = 4
$T240180 = -576						; size = 4
$T240176 = -572						; size = 4
$T240167 = -568						; size = 4
$T240155 = -564						; size = 4
$T240148 = -560						; size = 4
$T240135 = -556						; size = 4
$T240126 = -552						; size = 4
$T240122 = -548						; size = 4
$T240072 = -520						; size = 4
$T240065 = -516						; size = 4
$T240055 = -512						; size = 4
$T240008 = -484						; size = 4
$T240001 = -480						; size = 4
$T239991 = -476						; size = 4
$T239984 = -472						; size = 4
$T239980 = -468						; size = 4
$T239942 = -444						; size = 4
$T239935 = -440						; size = 4
$T239888 = -416						; size = 4
$T239881 = -412						; size = 4
$T239871 = -408						; size = 4
$T239862 = -404						; size = 4
$T239810 = -380						; size = 4
$T239803 = -376						; size = 4
$T239796 = -372						; size = 4
$T239786 = -368						; size = 4
$T239779 = -364						; size = 4
$T239770 = -360						; size = 4
$T239761 = -356						; size = 4
$T239747 = -345						; size = 1
$T239737 = -344						; size = 4
$T239736 = -340						; size = 4
$T239718 = -336						; size = 4
$T239709 = -332						; size = 4
$T239683 = -328						; size = 4
$T239667 = -324						; size = 4
$T239695 = -320						; size = 4
$T239694 = -316						; size = 4
$T239693 = -312						; size = 4
$T239692 = -308						; size = 4
$T239691 = -304						; size = 4
$T239651 = -300						; size = 4
$T239625 = -296						; size = 4
$T239609 = -292						; size = 4
$T239644 = -288						; size = 4
$T239643 = -284						; size = 4
$T239642 = -280						; size = 4
$T239641 = -276						; size = 4
$T239640 = -272						; size = 4
$T239593 = -268						; size = 4
$T239567 = -264						; size = 4
$T239551 = -260						; size = 4
$T239580 = -256						; size = 4
$T239579 = -252						; size = 4
$T239578 = -248						; size = 4
$T239577 = -244						; size = 4
$T239576 = -240						; size = 4
$T239535 = -236						; size = 4
$T239509 = -232						; size = 4
$T239493 = -228						; size = 4
$T239522 = -224						; size = 4
$T239521 = -220						; size = 4
$T239520 = -216						; size = 4
$T239519 = -212						; size = 4
$T239518 = -208						; size = 4
$T239477 = -204						; size = 4
$T239451 = -200						; size = 4
$T239435 = -196						; size = 4
$T239464 = -192						; size = 4
$T239463 = -188						; size = 4
$T239462 = -184						; size = 4
$T239461 = -180						; size = 4
$T239460 = -176						; size = 4
$T239419 = -172						; size = 4
$T239393 = -168						; size = 4
$T239377 = -164						; size = 4
$T239406 = -160						; size = 4
$T239405 = -156						; size = 4
$T239404 = -152						; size = 4
$T239403 = -148						; size = 4
$T239402 = -144						; size = 4
$T239361 = -140						; size = 4
$T239335 = -136						; size = 4
$T239319 = -132						; size = 4
$T239348 = -128						; size = 4
$T239347 = -124						; size = 4
$T239346 = -120						; size = 4
$T239345 = -116						; size = 4
$T239344 = -112						; size = 4
$T239299 = -108						; size = 4
$T239298 = -104						; size = 4
_iWeight$224692 = -100					; size = 4
_pFriendlyCity$224693 = -96				; size = 4
_iOutsidePlots$224690 = -92				; size = 4
_pTargetUnit$224683 = -88				; size = 4
_pkBuildInfo$224670 = -84				; size = 4
_iJ$224665 = -80					; size = 4
_eBuild$224664 = -76					; size = 4
_pWorkingCity$224662 = -72				; size = 4
_eNonObsoleteResource$224660 = -68			; size = 4
_pUnit$224653 = -64					; size = 8
_pCity$224650 = -56					; size = 4
_newTarget$ = -52					; size = 20
_theMap$ = -32						; size = 4
_iI$ = -28						; size = 4
_pLoopPlot$ = -24					; size = 4
_eTeam$ = -20						; size = 4
_iNumPlots$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?FindHomelandTargets@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::FindHomelandTargets, COMDAT
; _this$ = ecx

; 512  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FindHomelandTargets@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 828				; 0000033cH
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 513  : 	int iI;
; 514  : 	CvPlot* pLoopPlot;
; 515  : 	CvHomelandTarget newTarget;

	mov	DWORD PTR _newTarget$[ebp], 1
	mov	DWORD PTR _newTarget$[ebp+4], -1
	mov	DWORD PTR _newTarget$[ebp+8], -1
	mov	DWORD PTR _newTarget$[ebp+12], 0
	mov	DWORD PTR _newTarget$[ebp+16], 0

; 516  : 
; 517  : 	// Clear out target lists since we rebuild them each turn
; 518  : 	m_TargetedCities.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2412				; 0000096cH
	mov	DWORD PTR $T239361[ebp], eax
	mov	ecx, DWORD PTR $T239361[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T239319[ebp], edx
	mov	eax, DWORD PTR $T239319[ebp]
	mov	DWORD PTR $T239345[ebp], eax
	mov	ecx, DWORD PTR $T239345[ebp]
	mov	DWORD PTR $T239344[ebp], ecx
	mov	edx, DWORD PTR $T239361[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239335[ebp], eax
	mov	ecx, DWORD PTR $T239335[ebp]
	mov	DWORD PTR $T239347[ebp], ecx
	mov	edx, DWORD PTR $T239347[ebp]
	mov	DWORD PTR $T239346[ebp], edx
	mov	eax, DWORD PTR $T239344[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239346[ebp]
	push	ecx
	lea	edx, DWORD PTR $T239348[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239361[ebp]
	call	?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase

; 519  : 	m_TargetedSentryPoints.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2428				; 0000097cH
	mov	DWORD PTR $T239419[ebp], eax
	mov	ecx, DWORD PTR $T239419[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T239377[ebp], edx
	mov	eax, DWORD PTR $T239377[ebp]
	mov	DWORD PTR $T239403[ebp], eax
	mov	ecx, DWORD PTR $T239403[ebp]
	mov	DWORD PTR $T239402[ebp], ecx
	mov	edx, DWORD PTR $T239419[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239393[ebp], eax
	mov	ecx, DWORD PTR $T239393[ebp]
	mov	DWORD PTR $T239405[ebp], ecx
	mov	edx, DWORD PTR $T239405[ebp]
	mov	DWORD PTR $T239404[ebp], edx
	mov	eax, DWORD PTR $T239402[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239404[ebp]
	push	ecx
	lea	edx, DWORD PTR $T239406[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239419[ebp]
	call	?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase

; 520  : 	m_TargetedForts.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2444				; 0000098cH
	mov	DWORD PTR $T239477[ebp], eax
	mov	ecx, DWORD PTR $T239477[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T239435[ebp], edx
	mov	eax, DWORD PTR $T239435[ebp]
	mov	DWORD PTR $T239461[ebp], eax
	mov	ecx, DWORD PTR $T239461[ebp]
	mov	DWORD PTR $T239460[ebp], ecx
	mov	edx, DWORD PTR $T239477[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239451[ebp], eax
	mov	ecx, DWORD PTR $T239451[ebp]
	mov	DWORD PTR $T239463[ebp], ecx
	mov	edx, DWORD PTR $T239463[ebp]
	mov	DWORD PTR $T239462[ebp], edx
	mov	eax, DWORD PTR $T239460[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239462[ebp]
	push	ecx
	lea	edx, DWORD PTR $T239464[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239477[ebp]
	call	?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase

; 521  : 	m_TargetedNavalResources.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2460				; 0000099cH
	mov	DWORD PTR $T239535[ebp], eax
	mov	ecx, DWORD PTR $T239535[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T239493[ebp], edx
	mov	eax, DWORD PTR $T239493[ebp]
	mov	DWORD PTR $T239519[ebp], eax
	mov	ecx, DWORD PTR $T239519[ebp]
	mov	DWORD PTR $T239518[ebp], ecx
	mov	edx, DWORD PTR $T239535[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239509[ebp], eax
	mov	ecx, DWORD PTR $T239509[ebp]
	mov	DWORD PTR $T239521[ebp], ecx
	mov	edx, DWORD PTR $T239521[ebp]
	mov	DWORD PTR $T239520[ebp], edx
	mov	eax, DWORD PTR $T239518[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239520[ebp]
	push	ecx
	lea	edx, DWORD PTR $T239522[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239535[ebp]
	call	?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase

; 522  : 	m_TargetedHomelandRoads.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2476				; 000009acH
	mov	DWORD PTR $T239593[ebp], eax
	mov	ecx, DWORD PTR $T239593[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T239551[ebp], edx
	mov	eax, DWORD PTR $T239551[ebp]
	mov	DWORD PTR $T239577[ebp], eax
	mov	ecx, DWORD PTR $T239577[ebp]
	mov	DWORD PTR $T239576[ebp], ecx
	mov	edx, DWORD PTR $T239593[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239567[ebp], eax
	mov	ecx, DWORD PTR $T239567[ebp]
	mov	DWORD PTR $T239579[ebp], ecx
	mov	edx, DWORD PTR $T239579[ebp]
	mov	DWORD PTR $T239578[ebp], edx
	mov	eax, DWORD PTR $T239576[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239578[ebp]
	push	ecx
	lea	edx, DWORD PTR $T239580[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239593[ebp]
	call	?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase

; 523  : 	m_TargetedAncientRuins.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2492				; 000009bcH
	mov	DWORD PTR $T239651[ebp], eax
	mov	ecx, DWORD PTR $T239651[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T239609[ebp], edx
	mov	eax, DWORD PTR $T239609[ebp]
	mov	DWORD PTR $T239641[ebp], eax
	mov	ecx, DWORD PTR $T239641[ebp]
	mov	DWORD PTR $T239640[ebp], ecx
	mov	edx, DWORD PTR $T239651[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239625[ebp], eax
	mov	ecx, DWORD PTR $T239625[ebp]
	mov	DWORD PTR $T239643[ebp], ecx
	mov	edx, DWORD PTR $T239643[ebp]
	mov	DWORD PTR $T239642[ebp], edx
	mov	eax, DWORD PTR $T239640[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239642[ebp]
	push	ecx
	lea	edx, DWORD PTR $T239644[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239651[ebp]
	call	?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase

; 524  : 	m_TargetedAntiquitySites.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2508				; 000009ccH
	mov	DWORD PTR $T239709[ebp], eax
	mov	ecx, DWORD PTR $T239709[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T239667[ebp], edx
	mov	eax, DWORD PTR $T239667[ebp]
	mov	DWORD PTR $T239692[ebp], eax
	mov	ecx, DWORD PTR $T239692[ebp]
	mov	DWORD PTR $T239691[ebp], ecx
	mov	edx, DWORD PTR $T239709[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239683[ebp], eax
	mov	ecx, DWORD PTR $T239683[ebp]
	mov	DWORD PTR $T239694[ebp], ecx
	mov	edx, DWORD PTR $T239694[ebp]
	mov	DWORD PTR $T239693[ebp], edx
	mov	eax, DWORD PTR $T239691[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239693[ebp]
	push	ecx
	lea	edx, DWORD PTR $T239695[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239709[ebp]
	call	?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase

; 525  : 
; 526  : 	TeamTypes eTeam = m_pPlayer->getTeam();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T239718[ebp], ecx
	mov	edx, DWORD PTR $T239718[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 527  : 
; 528  : 	// Look at every tile on map
; 529  : 	CvMap& theMap = GC.getMap();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _theMap$[ebp], ecx

; 530  : 	int iNumPlots = theMap.numPlots();

	mov	edx, DWORD PTR _theMap$[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR _iNumPlots$[ebp], eax

; 531  : 	for(iI = 0; iI < iNumPlots; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN38@FindHomela
$LN37@FindHomela:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN38@FindHomela:
	mov	edx, DWORD PTR _iI$[ebp]
	cmp	edx, DWORD PTR _iNumPlots$[ebp]
	jge	$LN36@FindHomela

; 532  : 	{
; 533  : 		pLoopPlot = theMap.plotByIndexUnchecked(iI);

	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _theMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 534  : 
; 535  : 		if(pLoopPlot->isVisible(m_pPlayer->getTeam()))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T239736[ebp], eax
	mov	ecx, DWORD PTR $T239736[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T239737[ebp], eax
	cmp	DWORD PTR $T239737[ebp], -1
	jne	SHORT $LN159@FindHomela
	mov	BYTE PTR $T239747[ebp], 0
	jmp	SHORT $LN157@FindHomela
$LN159@FindHomela:
	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR $T239737[ebp]
	movsx	eax, WORD PTR [ecx+edx*2]
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	BYTE PTR $T239747[ebp], cl
$LN157@FindHomela:
	movzx	edx, BYTE PTR $T239747[ebp]
	test	edx, edx
	je	$LN35@FindHomela

; 536  : 		{
; 537  : 			// Have a ...
; 538  : 			// ... friendly city?
; 539  : 			CvCity* pCity = pLoopPlot->getPlotCity();

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$224650[ebp], eax

; 540  : 			if(pCity != NULL)

	cmp	DWORD PTR _pCity$224650[ebp], 0
	je	$LN217@FindHomela

; 541  : 			{
; 542  : 				if(m_pPlayer->GetID() == pCity->getOwner())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T239761[ebp], edx
	mov	eax, DWORD PTR _pCity$224650[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T239770[ebp], ecx
	mov	edx, DWORD PTR $T239761[ebp]
	cmp	edx, DWORD PTR $T239770[ebp]
	jne	$LN33@FindHomela

; 543  : 				{
; 544  : 					// Don't send another unit if the tactical AI already sent a garrison here
; 545  : 					UnitHandle pUnit = pLoopPlot->getBestDefender(m_pPlayer->GetID());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T239779[ebp], edx
	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	mov	eax, DWORD PTR $T239779[ebp]
	push	eax
	lea	ecx, DWORD PTR _pUnit$224653[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 546  : 					if(!pUnit || !pUnit->isUnderTacticalControl())

	xor	edx, edx
	cmp	DWORD PTR _pUnit$224653[ebp], 0
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN31@FindHomela
	mov	ecx, DWORD PTR _pUnit$224653[ebp]
	mov	DWORD PTR $T239786[ebp], ecx
	mov	ecx, DWORD PTR $T239786[ebp]
	call	?isUnderTacticalControl@CvUnit@@QBE_NXZ	; CvUnit::isUnderTacticalControl
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN32@FindHomela
$LN31@FindHomela:

; 547  : 					{
; 548  : 						newTarget.SetTargetType(AI_HOMELAND_TARGET_CITY);

	mov	DWORD PTR _newTarget$[ebp], 1

; 549  : 						newTarget.SetTargetX(pLoopPlot->getX());

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T239796[ebp], ecx
	mov	edx, DWORD PTR $T239796[ebp]
	mov	DWORD PTR _newTarget$[ebp+4], edx

; 550  : 						newTarget.SetTargetY(pLoopPlot->getY());

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T239803[ebp], ecx
	mov	edx, DWORD PTR $T239803[ebp]
	mov	DWORD PTR _newTarget$[ebp+8], edx

; 551  : 						newTarget.SetAuxData((void*)pCity);

	mov	eax, DWORD PTR _pCity$224650[ebp]
	mov	DWORD PTR _newTarget$[ebp+12], eax

; 552  : 						newTarget.SetAuxIntData(pCity->getThreatValue());

	mov	ecx, DWORD PTR _pCity$224650[ebp]
	call	?getThreatValue@CvCity@@QAEHXZ		; CvCity::getThreatValue
	mov	DWORD PTR $T239810[ebp], eax
	mov	ecx, DWORD PTR $T239810[ebp]
	mov	DWORD PTR _newTarget$[ebp+16], ecx

; 553  : 						m_TargetedCities.push_back(newTarget);

	lea	edx, DWORD PTR _newTarget$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2412				; 0000096cH
	call	?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back
$LN32@FindHomela:

; 554  : 					}
; 555  : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$224653[ebp], 0
	je	SHORT $LN33@FindHomela
	mov	ecx, DWORD PTR _pUnit$224653[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN33@FindHomela:

; 556  : 			}
; 557  : 
; 558  : 			// ... naval resource?
; 559  : 			else if(pLoopPlot->isWater() &&

	jmp	$LN35@FindHomela

; 560  : 			        pLoopPlot->getImprovementType() == NO_IMPROVEMENT)

$LN217@FindHomela:
	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN29@FindHomela
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	jne	$LN29@FindHomela

; 561  : 			{
; 562  : 				ResourceTypes eNonObsoleteResource = pLoopPlot->getNonObsoleteResourceType(eTeam);

	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getNonObsoleteResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getNonObsoleteResourceType
	mov	DWORD PTR _eNonObsoleteResource$224660[ebp], eax

; 563  : 				if(eNonObsoleteResource != NO_RESOURCE)

	cmp	DWORD PTR _eNonObsoleteResource$224660[ebp], -1
	je	$LN28@FindHomela

; 564  : 				{
; 565  : 					CvCity* pWorkingCity = pLoopPlot->getWorkingCity();

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	mov	DWORD PTR _pWorkingCity$224662[ebp], eax

; 566  : 					if(NULL != pWorkingCity && pWorkingCity->getOwner() == m_pPlayer->GetID())

	cmp	DWORD PTR _pWorkingCity$224662[ebp], 0
	je	$LN28@FindHomela
	mov	edx, DWORD PTR _pWorkingCity$224662[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T239862[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T239871[ebp], eax
	mov	ecx, DWORD PTR $T239862[ebp]
	cmp	ecx, DWORD PTR $T239871[ebp]
	jne	$LN28@FindHomela

; 567  : 					{
; 568  : 						// Find proper improvement
; 569  : 						BuildTypes eBuild;
; 570  : #ifdef AUI_WARNING_FIXES
; 571  : 						for (uint iJ = 0; iJ < GC.getNumBuildInfos(); iJ++)
; 572  : #else
; 573  : 						for(int iJ = 0; iJ < GC.getNumBuildInfos(); iJ++)

	mov	DWORD PTR _iJ$224665[ebp], 0
	jmp	SHORT $LN26@FindHomela
$LN25@FindHomela:
	mov	edx, DWORD PTR _iJ$224665[ebp]
	add	edx, 1
	mov	DWORD PTR _iJ$224665[ebp], edx
$LN26@FindHomela:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _iJ$224665[ebp], eax
	jge	$LN28@FindHomela

; 574  : #endif
; 575  : 						{
; 576  : 							eBuild = ((BuildTypes)iJ);

	mov	eax, DWORD PTR _iJ$224665[ebp]
	mov	DWORD PTR _eBuild$224664[ebp], eax

; 577  : 							CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);

	mov	ecx, DWORD PTR _eBuild$224664[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuildInfo$224670[ebp], eax

; 578  : 							if(pkBuildInfo && pkBuildInfo->getImprovement() != NO_IMPROVEMENT && pkBuildInfo->IsWater())

	cmp	DWORD PTR _pkBuildInfo$224670[ebp], 0
	je	$LN23@FindHomela
	mov	ecx, DWORD PTR _pkBuildInfo$224670[ebp]
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	cmp	eax, -1
	je	$LN23@FindHomela
	mov	ecx, DWORD PTR _pkBuildInfo$224670[ebp]
	call	?IsWater@CvBuildInfo@@QBE_NXZ		; CvBuildInfo::IsWater
	movzx	edx, al
	test	edx, edx
	je	$LN23@FindHomela

; 579  : 							{
; 580  : 								if(GC.getImprovementInfo((ImprovementTypes) GC.getBuildInfo(eBuild)->getImprovement())->IsImprovementResourceTrade(eNonObsoleteResource))

	mov	eax, DWORD PTR _eNonObsoleteResource$224660[ebp]
	push	eax
	mov	ecx, DWORD PTR _eBuild$224664[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN23@FindHomela

; 581  : 								{
; 582  : 									newTarget.SetTargetType(AI_HOMELAND_TARGET_NAVAL_RESOURCE);

	mov	DWORD PTR _newTarget$[ebp], 4

; 583  : 									newTarget.SetTargetX(pLoopPlot->getX());

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T239881[ebp], ecx
	mov	edx, DWORD PTR $T239881[ebp]
	mov	DWORD PTR _newTarget$[ebp+4], edx

; 584  : 									newTarget.SetTargetY(pLoopPlot->getY());

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T239888[ebp], ecx
	mov	edx, DWORD PTR $T239888[ebp]
	mov	DWORD PTR _newTarget$[ebp+8], edx

; 585  : 									newTarget.SetAuxData(pLoopPlot);

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	mov	DWORD PTR _newTarget$[ebp+12], eax

; 586  : 									newTarget.SetAuxIntData((int)eBuild);

	mov	ecx, DWORD PTR _eBuild$224664[ebp]
	mov	DWORD PTR _newTarget$[ebp+16], ecx

; 587  : 									m_TargetedNavalResources.push_back(newTarget);

	lea	edx, DWORD PTR _newTarget$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2460				; 0000099cH
	call	?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back

; 588  : 									break;

	jmp	SHORT $LN28@FindHomela
$LN23@FindHomela:

; 589  : 								}
; 590  : 							}
; 591  : 						}

	jmp	$LN25@FindHomela
$LN28@FindHomela:

; 592  : 					}
; 593  : 				}
; 594  : 			}

	jmp	$LN35@FindHomela
$LN29@FindHomela:

; 595  : 
; 596  : 			// ... unpopped goody hut?
; 597  : 			else if(!m_pPlayer->isMinorCiv() && pLoopPlot->isGoody())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN20@FindHomela
	push	-1
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isGoody
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN20@FindHomela

; 598  : 			{
; 599  : 				newTarget.SetTargetType(AI_HOMELAND_TARGET_ANCIENT_RUIN);

	mov	DWORD PTR _newTarget$[ebp], 6

; 600  : 				newTarget.SetTargetX(pLoopPlot->getX());

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T239935[ebp], ecx
	mov	edx, DWORD PTR $T239935[ebp]
	mov	DWORD PTR _newTarget$[ebp+4], edx

; 601  : 				newTarget.SetTargetY(pLoopPlot->getY());

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T239942[ebp], ecx
	mov	edx, DWORD PTR $T239942[ebp]
	mov	DWORD PTR _newTarget$[ebp+8], edx

; 602  : 				newTarget.SetAuxData(pLoopPlot);

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	mov	DWORD PTR _newTarget$[ebp+12], eax

; 603  : 				m_TargetedAncientRuins.push_back(newTarget);

	lea	ecx, DWORD PTR _newTarget$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2492				; 000009bcH
	call	?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back

; 604  : 			}
; 605  : 
; 606  : 			// ... antiquity site?
; 607  : 			else if((pLoopPlot->getResourceType(eTeam) == GC.getARTIFACT_RESOURCE() || pLoopPlot->getResourceType(eTeam) == GC.getHIDDEN_ARTIFACT_RESOURCE()) && 

	jmp	$LN35@FindHomela
$LN20@FindHomela:

; 608  : 				!(pLoopPlot->getOwner() != NO_PLAYER && m_pPlayer->GetDiplomacyAI()->IsPlayerMadeNoDiggingPromise(pLoopPlot->getOwner())))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8408
	mov	DWORD PTR $T239980[ebp], edx
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, DWORD PTR $T239980[ebp]
	je	SHORT $LN289@FindHomela
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8412
	mov	DWORD PTR $T239984[ebp], ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, DWORD PTR $T239984[ebp]
	jne	$LN325@FindHomela
$LN289@FindHomela:
	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	ecx, -1
	je	SHORT $LN16@FindHomela
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T239991[ebp], eax
	mov	ecx, DWORD PTR $T239991[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerMadeNoDiggingPromise@CvDiplomacyAI@@QAE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsPlayerMadeNoDiggingPromise
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN325@FindHomela
$LN16@FindHomela:

; 609  : 			{
; 610  : 				newTarget.SetTargetType(AI_HOMELAND_TARGET_ANTIQUITY_SITE);

	mov	DWORD PTR _newTarget$[ebp], 7

; 611  : 				newTarget.SetTargetX(pLoopPlot->getX());

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T240001[ebp], edx
	mov	eax, DWORD PTR $T240001[ebp]
	mov	DWORD PTR _newTarget$[ebp+4], eax

; 612  : 				newTarget.SetTargetY(pLoopPlot->getY());

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T240008[ebp], edx
	mov	eax, DWORD PTR $T240008[ebp]
	mov	DWORD PTR _newTarget$[ebp+8], eax

; 613  : 				newTarget.SetAuxData(pLoopPlot);

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	mov	DWORD PTR _newTarget$[ebp+12], ecx

; 614  : 				m_TargetedAntiquitySites.push_back(newTarget);

	lea	edx, DWORD PTR _newTarget$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2508				; 000009ccH
	call	?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back
	jmp	$LN35@FindHomela

; 615  : 			}
; 616  : 
; 617  : 			// ... enemy civilian (or embarked) unit?
; 618  : 			else if(pLoopPlot->isVisibleOtherUnit(m_pPlayer->GetID()))

$LN325@FindHomela:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T240055[ebp], edx
	mov	eax, DWORD PTR $T240055[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isVisibleOtherUnit
	movzx	ecx, al
	test	ecx, ecx
	je	$LN357@FindHomela

; 619  : 			{
; 620  : 				CvUnit* pTargetUnit = pLoopPlot->getUnitByIndex(0);

	push	0
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	DWORD PTR _pTargetUnit$224683[ebp], eax

; 621  : 				if(!pTargetUnit->isDelayedDeath() && atWar(eTeam, pTargetUnit->getTeam()) && !pTargetUnit->IsCanDefend())

	mov	ecx, DWORD PTR _pTargetUnit$224683[ebp]
	call	?isDelayedDeath@CvUnit@@QBE_NXZ		; CvUnit::isDelayedDeath
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN13@FindHomela
	mov	ecx, DWORD PTR _pTargetUnit$224683[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@FindHomela
	push	0
	mov	ecx, DWORD PTR _pTargetUnit$224683[ebp]
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN13@FindHomela

; 622  : 				{
; 623  : 					newTarget.SetTargetType(AI_HOMELAND_TARGET_ANCIENT_RUIN);

	mov	DWORD PTR _newTarget$[ebp], 6

; 624  : 					newTarget.SetTargetX(pLoopPlot->getX());

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T240065[ebp], ecx
	mov	edx, DWORD PTR $T240065[ebp]
	mov	DWORD PTR _newTarget$[ebp+4], edx

; 625  : 					newTarget.SetTargetY(pLoopPlot->getY());

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T240072[ebp], ecx
	mov	edx, DWORD PTR $T240072[ebp]
	mov	DWORD PTR _newTarget$[ebp+8], edx

; 626  : 					newTarget.SetAuxData(pLoopPlot);

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	mov	DWORD PTR _newTarget$[ebp+12], eax

; 627  : 					m_TargetedAncientRuins.push_back(newTarget);

	lea	ecx, DWORD PTR _newTarget$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2492				; 000009bcH
	call	?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back
$LN13@FindHomela:

; 628  : 				}
; 629  : 			}

	jmp	$LN35@FindHomela

; 630  : 
; 631  : 			// ... possible sentry point? (must be empty or only have friendly units)
; 632  : 			else if(!pLoopPlot->isWater() && (!pLoopPlot->isUnit() || pLoopPlot->getNumDefenders(m_pPlayer->GetID()) > 0))

$LN357@FindHomela:
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	$LN419@FindHomela
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isUnit@CvPlot@@QBE_NXZ			; CvPlot::isUnit
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@FindHomela
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T240122[ebp], eax
	mov	ecx, DWORD PTR $T240122[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumDefenders
	test	eax, eax
	jle	$LN419@FindHomela
$LN10@FindHomela:

; 633  : 			{
; 634  : 				// Must be at least adjacent to our land
; 635  : 				if(pLoopPlot->getOwner() == m_pPlayer->GetID() ||
; 636  : 				        (pLoopPlot->isAdjacentTeam(eTeam, true /*bLandOnly*/) && pLoopPlot->getOwner() == NO_PLAYER))

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T240126[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T240135[ebp], eax
	mov	ecx, DWORD PTR $T240126[ebp]
	cmp	ecx, DWORD PTR $T240135[ebp]
	je	SHORT $LN8@FindHomela
	push	1
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isAdjacentTeam@CvPlot@@QBE_NW4TeamTypes@@_N@Z ; CvPlot::isAdjacentTeam
	movzx	eax, al
	test	eax, eax
	je	$LN9@FindHomela
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	edx, -1
	jne	$LN9@FindHomela
$LN8@FindHomela:

; 637  : 				{
; 638  : 					// See how many outside plots are nearby to monitor
; 639  : 					int iOutsidePlots = pLoopPlot->GetNumAdjacentDifferentTeam(eTeam, true /*bIgnoreWater*/);

	push	1
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?GetNumAdjacentDifferentTeam@CvPlot@@QBEHW4TeamTypes@@_N@Z ; CvPlot::GetNumAdjacentDifferentTeam
	mov	DWORD PTR _iOutsidePlots$224690[ebp], eax

; 640  : 
; 641  : 					if(iOutsidePlots > 0)

	cmp	DWORD PTR _iOutsidePlots$224690[ebp], 0
	jle	$LN9@FindHomela

; 642  : 					{
; 643  : 						newTarget.SetTargetType(AI_HOMELAND_TARGET_SENTRY_POINT);

	mov	DWORD PTR _newTarget$[ebp], 2

; 644  : 						newTarget.SetTargetX(pLoopPlot->getX());

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T240148[ebp], edx
	mov	eax, DWORD PTR $T240148[ebp]
	mov	DWORD PTR _newTarget$[ebp+4], eax

; 645  : 						newTarget.SetTargetY(pLoopPlot->getY());

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T240155[ebp], edx
	mov	eax, DWORD PTR $T240155[ebp]
	mov	DWORD PTR _newTarget$[ebp+8], eax

; 646  : 						newTarget.SetAuxData(pLoopPlot);

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	mov	DWORD PTR _newTarget$[ebp+12], ecx

; 647  : 
; 648  : 						// Get weight for this sentry point
; 649  : 						int iWeight = iOutsidePlots * 100;

	mov	edx, DWORD PTR _iOutsidePlots$224690[ebp]
	imul	edx, 100				; 00000064H
	mov	DWORD PTR _iWeight$224692[ebp], edx

; 650  : 						iWeight += pLoopPlot->defenseModifier(eTeam, true);

	push	0
	push	1
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z ; CvPlot::defenseModifier
	add	eax, DWORD PTR _iWeight$224692[ebp]
	mov	DWORD PTR _iWeight$224692[ebp], eax

; 651  : 						iWeight += m_pPlayer->GetPlotDanger(*pLoopPlot);

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	add	eax, DWORD PTR _iWeight$224692[ebp]
	mov	DWORD PTR _iWeight$224692[ebp], eax

; 652  : 
; 653  : 						CvCity* pFriendlyCity = m_pPlayer->GetClosestFriendlyCity(*pLoopPlot, 5 /*i SearchRadius */);

	push	5
	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetClosestFriendlyCity@CvPlayer@@QAEPAVCvCity@@AAVCvPlot@@H@Z ; CvPlayer::GetClosestFriendlyCity
	mov	DWORD PTR _pFriendlyCity$224693[ebp], eax

; 654  : 						if(pFriendlyCity && pFriendlyCity->getOwner() == m_pPlayer->GetID())

	cmp	DWORD PTR _pFriendlyCity$224693[ebp], 0
	je	SHORT $LN393@FindHomela
	mov	edx, DWORD PTR _pFriendlyCity$224693[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T240167[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T240176[ebp], eax
	mov	ecx, DWORD PTR $T240167[ebp]
	cmp	ecx, DWORD PTR $T240176[ebp]
	jne	SHORT $LN393@FindHomela

; 655  : 						{
; 656  : 							iWeight += pFriendlyCity->getThreatValue() * pFriendlyCity->getPopulation() / 50;

	mov	ecx, DWORD PTR _pFriendlyCity$224693[ebp]
	call	?getThreatValue@CvCity@@QAEHXZ		; CvCity::getThreatValue
	mov	esi, eax
	mov	ecx, DWORD PTR _pFriendlyCity$224693[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	imul	eax, esi
	cdq
	mov	ecx, 50					; 00000032H
	idiv	ecx
	add	eax, DWORD PTR _iWeight$224692[ebp]
	mov	DWORD PTR _iWeight$224692[ebp], eax

; 657  : 							if(pFriendlyCity->isCapital())

	mov	ecx, DWORD PTR _pFriendlyCity$224693[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN393@FindHomela

; 658  : 							{
; 659  : 								iWeight = (iWeight * GC.getAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL()) / 100;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2188
	mov	DWORD PTR $T240180[ebp], eax
	mov	eax, DWORD PTR _iWeight$224692[ebp]
	imul	eax, DWORD PTR $T240180[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iWeight$224692[ebp], eax

; 660  : 							}
; 661  : 						}
; 662  : 
; 663  : 						if(pLoopPlot->isHills())

$LN393@FindHomela:
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@FindHomela

; 664  : 						{
; 665  : 							iWeight *= 2;

	mov	edx, DWORD PTR _iWeight$224692[ebp]
	shl	edx, 1
	mov	DWORD PTR _iWeight$224692[ebp], edx
$LN4@FindHomela:

; 666  : 						}
; 667  : 						if(pLoopPlot->isCoastalLand())

	push	-1
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@FindHomela

; 668  : 						{
; 669  : 							iWeight /= 2;

	mov	eax, DWORD PTR _iWeight$224692[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iWeight$224692[ebp], eax
$LN3@FindHomela:

; 670  : 						}
; 671  : 
; 672  : 						newTarget.SetAuxIntData(iWeight);

	mov	ecx, DWORD PTR _iWeight$224692[ebp]
	mov	DWORD PTR _newTarget$[ebp+16], ecx

; 673  : 						m_TargetedSentryPoints.push_back(newTarget);

	lea	edx, DWORD PTR _newTarget$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2428				; 0000097cH
	call	?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back
$LN9@FindHomela:

; 674  : 					}
; 675  : 				}
; 676  : 			}

	jmp	$LN35@FindHomela

; 677  : 
; 678  : 			// ... road segment in friendly territory?
; 679  : 			else if(pLoopPlot->getTeam() == eTeam && pLoopPlot->isRoute())

$LN419@FindHomela:
	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$240230[ebp], ecx
	cmp	DWORD PTR _playerID$240230[ebp], -1
	je	SHORT $LN416@FindHomela
	mov	edx, DWORD PTR _playerID$240230[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T240238[ebp], eax
	jmp	SHORT $LN417@FindHomela
	jmp	SHORT $LN417@FindHomela
$LN416@FindHomela:
	mov	DWORD PTR $T240238[ebp], -1
$LN417@FindHomela:
	mov	eax, DWORD PTR $T240238[ebp]
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN35@FindHomela
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isRoute@CvPlot@@QBE_NXZ		; CvPlot::isRoute
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN35@FindHomela

; 680  : 			{
; 681  : 				newTarget.SetTargetType(AI_HOMELAND_TARGET_HOME_ROAD);

	mov	DWORD PTR _newTarget$[ebp], 5

; 682  : 				newTarget.SetTargetX(pLoopPlot->getX());

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T240248[ebp], eax
	mov	ecx, DWORD PTR $T240248[ebp]
	mov	DWORD PTR _newTarget$[ebp+4], ecx

; 683  : 				newTarget.SetTargetY(pLoopPlot->getY());

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T240255[ebp], eax
	mov	ecx, DWORD PTR $T240255[ebp]
	mov	DWORD PTR _newTarget$[ebp+8], ecx

; 684  : 				newTarget.SetAuxData(pLoopPlot);

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	mov	DWORD PTR _newTarget$[ebp+12], edx

; 685  : 				m_TargetedHomelandRoads.push_back(newTarget);

	lea	eax, DWORD PTR _newTarget$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2476				; 000009acH
	call	?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back
$LN35@FindHomela:

; 686  : 			}
; 687  : 		}
; 688  : 	}

	jmp	$LN37@FindHomela
$LN36@FindHomela:

; 689  : 
; 690  : 	// Post-processing on targets
; 691  : 	EliminateAdjacentSentryPoints();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ ; CvHomelandAI::EliminateAdjacentSentryPoints

; 692  : 	EliminateAdjacentHomelandRoads();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ ; CvHomelandAI::EliminateAdjacentHomelandRoads

; 693  : 	std::stable_sort(m_TargetedCities.begin(), m_TargetedCities.end());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2420]
	mov	DWORD PTR $T240384[ebp], edx
	mov	eax, DWORD PTR $T240384[ebp]
	mov	DWORD PTR $T239298[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2416]
	mov	DWORD PTR $T240400[ebp], edx
	mov	eax, DWORD PTR $T240400[ebp]
	mov	DWORD PTR $T239299[ebp], eax
	mov	ecx, DWORD PTR $T239298[ebp]
	mov	DWORD PTR $T240675[ebp], ecx
	mov	edx, DWORD PTR $T239299[ebp]
	mov	DWORD PTR $T240674[ebp], edx
	mov	eax, DWORD PTR $T240674[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T240675[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN39@FindHomela
	push	0
	push	0
	mov	ecx, DWORD PTR $T240675[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240674[ebp]
	push	edx
	call	??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
	add	esp, 16					; 00000010H
$LN39@FindHomela:

; 694  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindHomelandTargets@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$224653[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?FindHomelandTargets@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-836]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindHomelandTargets@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindHomelandTargets@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::FindHomelandTargets
PUBLIC	?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ReviewUnassignedUnits
PUBLIC	?PlotAirliftMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotAirliftMoves
PUBLIC	?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotArchaeologistMoves
PUBLIC	?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotTradeUnitMoves
PUBLIC	?PlotTreasureMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotTreasureMoves
PUBLIC	?PlotSSPartMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotSSPartMoves
PUBLIC	?PlotSSPartAdds@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotSSPartAdds
PUBLIC	?PlotAircraftMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotAircraftMoves
PUBLIC	?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotInquisitorMoves
PUBLIC	?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotMissionaryMoves
PUBLIC	?PlotProphetMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotProphetMoves
PUBLIC	?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotAdmiralMoves
PUBLIC	?PlotGeneralMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotGeneralMoves
PUBLIC	?PlotMerchantMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotMerchantMoves
PUBLIC	?PlotEngineerMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotEngineerMoves
PUBLIC	?PlotScientistMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotScientistMoves
PUBLIC	?PlotMusicianMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotMusicianMoves
PUBLIC	?PlotArtistMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotArtistMoves
PUBLIC	?PlotWriterMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotWriterMoves
PUBLIC	?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotAncientRuinMoves
PUBLIC	?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotUpgradeMoves
PUBLIC	?PlotPatrolMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotPatrolMoves
PUBLIC	?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotWorkerSeaMoves
PUBLIC	?PlotWorkerMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotWorkerMoves
PUBLIC	?PlotSentryMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotSentryMoves
PUBLIC	?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotMobileReserveMoves
PUBLIC	?PlotMovesToSafety@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotMovesToSafety
PUBLIC	?PlotHealMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotHealMoves
PUBLIC	?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z	; CvHomelandAI::PlotGarrisonMoves
PUBLIC	?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotFirstTurnSettlerMoves
PUBLIC	?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotExplorerSeaMoves
PUBLIC	?PlotExplorerMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotExplorerMoves
; Function compile flags: /Odtp
;	COMDAT ?AssignHomelandMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv86 = -24						; size = 4
_this$ = -20						; size = 4
$T240690 = -16						; size = 4
_move$224931 = -12					; size = 8
_it$ = -4						; size = 4
?AssignHomelandMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::AssignHomelandMoves, COMDAT
; _this$ = ecx

; 698  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 699  : 	FStaticVector< CvHomelandMove, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 700  : 
; 701  : 	// Proceed in priority order
; 702  : 	for(it = m_MovePriorityList.begin(); it != m_MovePriorityList.end() && !m_CurrentTurnUnits.empty(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2096]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN37@AssignHome
$LN36@AssignHome:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 8
	mov	DWORD PTR _it$[ebp], edx
$LN37@AssignHome:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2096				; 00000830H
	mov	DWORD PTR $T240690[ebp], eax
	mov	ecx, DWORD PTR $T240690[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR $T240690[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx*8]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN35@AssignHome
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	$LN35@AssignHome

; 703  : 	{
; 704  : 		CvHomelandMove move = *it;

	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _move$224931[ebp], ecx
	mov	DWORD PTR _move$224931[ebp+4], edx

; 705  : 
; 706  : #if defined(AUI_PERF_LOGGING_FORMATTING_TWEAKS) && !defined(FINAL_RELEASE)
; 707  : 		static const char* aHomelandMoves[] = { "AI_HOMELAND_MOVE_UNASSIGNED",
; 708  : 			"AI_HOMELAND_MOVE_EXPLORE",
; 709  : 			"AI_HOMELAND_MOVE_EXPLORE_SEA",
; 710  : 			"AI_HOMELAND_MOVE_SETTLE",
; 711  : 			"AI_HOMELAND_MOVE_GARRISON",
; 712  : 			"AI_HOMELAND_MOVE_HEAL",
; 713  : 			"AI_HOMELAND_MOVE_TO_SAFETY",
; 714  : 			"AI_HOMELAND_MOVE_MOBILE_RESERVE",
; 715  : 			"AI_HOMELAND_MOVE_SENTRY",
; 716  : 			"AI_HOMELAND_MOVE_WORKER",
; 717  : 			"AI_HOMELAND_MOVE_WORKER_SEA",
; 718  : 			"AI_HOMELAND_MOVE_PATROL",
; 719  : 			"AI_HOMELAND_MOVE_UPGRADE",
; 720  : 			"AI_HOMELAND_MOVE_ANCIENT_RUINS",
; 721  : 			"AI_HOMELAND_MOVE_GARRISON_CITY_STATE",
; 722  : 			"AI_HOMELAND_MOVE_WRITER",
; 723  : 			"AI_HOMELAND_MOVE_ARTIST_GOLDEN_AGE",
; 724  : 			"AI_HOMELAND_MOVE_MUSICIAN",
; 725  : 			"AI_HOMELAND_MOVE_SCIENTIST_FREE_TECH",
; 726  : 			"AI_HOMELAND_MOVE_MERCHANT_TRADE",
; 727  : 			"AI_HOMELAND_MOVE_ENGINEER_HURRY",
; 728  : 			"AI_HOMELAND_MOVE_GENERAL_GARRISON",
; 729  : 			"AI_HOMELAND_MOVE_ADMIRAL_GARRISON",
; 730  : 			"AI_HOMELAND_MOVE_SPACESHIP_PART",
; 731  : 			"AI_HOMELAND_MOVE_AIRCRAFT_TO_THE_FRONT",
; 732  : 			"AI_HOMELAND_MOVE_TREASURE",
; 733  : 			"AI_HOMELAND_MOVE_PROPHET_RELIGION",
; 734  : 			"AI_HOMELAND_MOVE_MISSIONARY",
; 735  : 			"AI_HOMELAND_MOVE_INQUISITOR",
; 736  : 			"AI_HOMELAND_MOVE_TRADE_UNIT",
; 737  : 			"AI_HOMELAND_MOVE_ARCHAEOLOGIST",
; 738  : 			"AI_HOMELAND_MOVE_ADD_SPACESHIP_PART",
; 739  : 			"AI_HOMELAND_MOVE_AIRLIFT" };
; 740  : 		AI_PERF_FORMAT("AI-perf-home.csv", ("Move Type: %s (%d), Turn %03d, %s", (move.m_eMoveType > 0 && move.m_eMoveType < 33 ? aHomelandMoves[move.m_eMoveType] : "AI_HOMELAND_MOVE_NONE"), (int)move.m_eMoveType, GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()));
; 741  : #else
; 742  : 		AI_PERF_FORMAT("AI-perf-tact.csv", ("Homeland Move: %d, Turn %03d, %s", (int)move.m_eMoveType, GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 743  : #endif
; 744  : 
; 745  : 		switch(move.m_eMoveType)

	mov	eax, DWORD PTR _move$224931[ebp]
	mov	DWORD PTR tv86[ebp], eax
	mov	ecx, DWORD PTR tv86[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv86[ebp], ecx
	cmp	DWORD PTR tv86[ebp], 31			; 0000001fH
	ja	$LN33@AssignHome
	mov	edx, DWORD PTR tv86[ebp]
	jmp	DWORD PTR $LN46@AssignHome[edx*4]
$LN32@AssignHome:

; 746  : 		{
; 747  : 		case AI_HOMELAND_MOVE_EXPLORE:
; 748  : 			PlotExplorerMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotExplorerMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotExplorerMoves

; 749  : 			break;

	jmp	$LN33@AssignHome
$LN31@AssignHome:

; 750  : 		case AI_HOMELAND_MOVE_EXPLORE_SEA:
; 751  : 			PlotExplorerSeaMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::PlotExplorerSeaMoves

; 752  : 			break;

	jmp	$LN33@AssignHome
$LN30@AssignHome:

; 753  : 		case AI_HOMELAND_MOVE_SETTLE:
; 754  : 			PlotFirstTurnSettlerMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::PlotFirstTurnSettlerMoves

; 755  : 			break;

	jmp	$LN33@AssignHome
$LN29@AssignHome:

; 756  : 		case AI_HOMELAND_MOVE_GARRISON:
; 757  : 			PlotGarrisonMoves();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z ; CvHomelandAI::PlotGarrisonMoves

; 758  : 			break;

	jmp	$LN33@AssignHome
$LN28@AssignHome:

; 759  : 		case AI_HOMELAND_MOVE_HEAL:
; 760  : 			PlotHealMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotHealMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotHealMoves

; 761  : 			break;

	jmp	$LN33@AssignHome
$LN27@AssignHome:

; 762  : 		case AI_HOMELAND_MOVE_TO_SAFETY:
; 763  : 			PlotMovesToSafety();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotMovesToSafety@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotMovesToSafety

; 764  : 			break;

	jmp	$LN33@AssignHome
$LN26@AssignHome:

; 765  : 		case AI_HOMELAND_MOVE_MOBILE_RESERVE:
; 766  : 			PlotMobileReserveMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::PlotMobileReserveMoves

; 767  : 			break;

	jmp	$LN33@AssignHome
$LN25@AssignHome:

; 768  : 		case AI_HOMELAND_MOVE_SENTRY:
; 769  : 			PlotSentryMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotSentryMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotSentryMoves

; 770  : 			break;

	jmp	$LN33@AssignHome
$LN24@AssignHome:

; 771  : 		case AI_HOMELAND_MOVE_WORKER:
; 772  : 			PlotWorkerMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotWorkerMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotWorkerMoves

; 773  : 			break;

	jmp	$LN33@AssignHome
$LN23@AssignHome:

; 774  : 		case AI_HOMELAND_MOVE_WORKER_SEA:
; 775  : 			PlotWorkerSeaMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::PlotWorkerSeaMoves

; 776  : 			break;

	jmp	$LN33@AssignHome
$LN22@AssignHome:

; 777  : 		case AI_HOMELAND_MOVE_PATROL:
; 778  : 			PlotPatrolMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotPatrolMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotPatrolMoves

; 779  : 			break;

	jmp	$LN33@AssignHome
$LN21@AssignHome:

; 780  : 		case AI_HOMELAND_MOVE_UPGRADE:
; 781  : 			PlotUpgradeMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotUpgradeMoves

; 782  : 			break;

	jmp	$LN33@AssignHome
$LN20@AssignHome:

; 783  : 		case AI_HOMELAND_MOVE_ANCIENT_RUINS:
; 784  : 			PlotAncientRuinMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::PlotAncientRuinMoves

; 785  : 			break;

	jmp	$LN33@AssignHome
$LN19@AssignHome:

; 786  : 		case AI_HOMELAND_MOVE_GARRISON_CITY_STATE:
; 787  : 			PlotGarrisonMoves(true /*bCityStateOnly*/);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z ; CvHomelandAI::PlotGarrisonMoves

; 788  : 			break;

	jmp	$LN33@AssignHome
$LN18@AssignHome:

; 789  : 		case AI_HOMELAND_MOVE_WRITER:
; 790  : 			PlotWriterMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotWriterMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotWriterMoves

; 791  : 			break;

	jmp	$LN33@AssignHome
$LN17@AssignHome:

; 792  : 		case AI_HOMELAND_MOVE_ARTIST_GOLDEN_AGE:
; 793  : 			PlotArtistMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotArtistMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotArtistMoves

; 794  : 			break;

	jmp	$LN33@AssignHome
$LN16@AssignHome:

; 795  : 		case AI_HOMELAND_MOVE_MUSICIAN:
; 796  : 			PlotMusicianMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotMusicianMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotMusicianMoves

; 797  : 			break;

	jmp	$LN33@AssignHome
$LN15@AssignHome:

; 798  : 		case AI_HOMELAND_MOVE_SCIENTIST_FREE_TECH:
; 799  : 			PlotScientistMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotScientistMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::PlotScientistMoves

; 800  : 			break;

	jmp	$LN33@AssignHome
$LN14@AssignHome:

; 801  : 		case AI_HOMELAND_MOVE_ENGINEER_HURRY:
; 802  : 			PlotEngineerMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotEngineerMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotEngineerMoves

; 803  : 			break;

	jmp	$LN33@AssignHome
$LN13@AssignHome:

; 804  : 		case AI_HOMELAND_MOVE_MERCHANT_TRADE:
; 805  : 			PlotMerchantMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotMerchantMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotMerchantMoves

; 806  : 			break;

	jmp	SHORT $LN33@AssignHome
$LN12@AssignHome:

; 807  : 		case AI_HOMELAND_MOVE_GENERAL_GARRISON:
; 808  : 			PlotGeneralMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotGeneralMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotGeneralMoves

; 809  : 			break;

	jmp	SHORT $LN33@AssignHome
$LN11@AssignHome:

; 810  : 		case AI_HOMELAND_MOVE_ADMIRAL_GARRISON:
; 811  : 			PlotAdmiralMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotAdmiralMoves

; 812  : 			break;

	jmp	SHORT $LN33@AssignHome
$LN10@AssignHome:

; 813  : 		case AI_HOMELAND_MOVE_PROPHET_RELIGION:
; 814  : 			PlotProphetMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotProphetMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotProphetMoves

; 815  : 			break;

	jmp	SHORT $LN33@AssignHome
$LN9@AssignHome:

; 816  : 		case AI_HOMELAND_MOVE_MISSIONARY:
; 817  : 			PlotMissionaryMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::PlotMissionaryMoves

; 818  : 			break;

	jmp	SHORT $LN33@AssignHome
$LN8@AssignHome:

; 819  : 		case AI_HOMELAND_MOVE_INQUISITOR:
; 820  : 			PlotInquisitorMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::PlotInquisitorMoves

; 821  : 			break;

	jmp	SHORT $LN33@AssignHome
$LN7@AssignHome:

; 822  : 		case AI_HOMELAND_MOVE_AIRCRAFT_TO_THE_FRONT:
; 823  : 			PlotAircraftMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotAircraftMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotAircraftMoves

; 824  : 			break;

	jmp	SHORT $LN33@AssignHome
$LN6@AssignHome:

; 825  : 		case AI_HOMELAND_MOVE_ADD_SPACESHIP_PART:
; 826  : 			PlotSSPartAdds();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotSSPartAdds@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotSSPartAdds

; 827  : 			break;

	jmp	SHORT $LN33@AssignHome
$LN5@AssignHome:

; 828  : 		case AI_HOMELAND_MOVE_SPACESHIP_PART:
; 829  : 			PlotSSPartMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotSSPartMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotSSPartMoves

; 830  : 			break;

	jmp	SHORT $LN33@AssignHome
$LN4@AssignHome:

; 831  : 		case AI_HOMELAND_MOVE_TREASURE:
; 832  : 			PlotTreasureMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotTreasureMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotTreasureMoves

; 833  : 			break;

	jmp	SHORT $LN33@AssignHome
$LN3@AssignHome:

; 834  : 		case AI_HOMELAND_MOVE_TRADE_UNIT:
; 835  : 			PlotTradeUnitMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::PlotTradeUnitMoves

; 836  : 			break;

	jmp	SHORT $LN33@AssignHome
$LN2@AssignHome:

; 837  : 		case AI_HOMELAND_MOVE_ARCHAEOLOGIST:
; 838  : 			PlotArchaeologistMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::PlotArchaeologistMoves

; 839  : 			break;

	jmp	SHORT $LN33@AssignHome
$LN1@AssignHome:

; 840  : 		case AI_HOMELAND_MOVE_AIRLIFT:
; 841  : 			PlotAirliftMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotAirliftMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotAirliftMoves
$LN33@AssignHome:

; 842  : 			break;
; 843  : 		}
; 844  : 	}

	jmp	$LN36@AssignHome
$LN35@AssignHome:

; 845  : 
; 846  : 	ReviewUnassignedUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ReviewUnassignedUnits

; 847  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN46@AssignHome:
	DD	$LN32@AssignHome
	DD	$LN31@AssignHome
	DD	$LN30@AssignHome
	DD	$LN29@AssignHome
	DD	$LN28@AssignHome
	DD	$LN27@AssignHome
	DD	$LN26@AssignHome
	DD	$LN25@AssignHome
	DD	$LN24@AssignHome
	DD	$LN23@AssignHome
	DD	$LN22@AssignHome
	DD	$LN21@AssignHome
	DD	$LN20@AssignHome
	DD	$LN19@AssignHome
	DD	$LN18@AssignHome
	DD	$LN17@AssignHome
	DD	$LN16@AssignHome
	DD	$LN15@AssignHome
	DD	$LN13@AssignHome
	DD	$LN14@AssignHome
	DD	$LN12@AssignHome
	DD	$LN11@AssignHome
	DD	$LN5@AssignHome
	DD	$LN7@AssignHome
	DD	$LN4@AssignHome
	DD	$LN10@AssignHome
	DD	$LN9@AssignHome
	DD	$LN8@AssignHome
	DD	$LN3@AssignHome
	DD	$LN2@AssignHome
	DD	$LN6@AssignHome
	DD	$LN1@AssignHome
?AssignHomelandMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::AssignHomelandMoves
_TEXT	ENDS
PUBLIC	?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteExplorerMoves
PUBLIC	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
PUBLIC	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ClearCurrentMoveUnits
EXTRN	?GetAutomateType@CvUnit@@QBE?AW4AutomateTypes@@XZ:PROC ; CvUnit::GetAutomateType
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
EXTRN	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z:PROC	; CvPlayer::getUnit
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotExplorerMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotExplorerMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotExplorerMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotExplorerMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotExplorerMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -100						; size = 4
$T240840 = -96						; size = 4
$T240817 = -88						; size = 4
$T240808 = -84						; size = 4
$T240804 = -80						; size = 4
$T240800 = -76						; size = 4
$T240796 = -72						; size = 4
$T240792 = -68						; size = 4
$T240785 = -64						; size = 4
$T240775 = -60						; size = 4
$T240745 = -56						; size = 4
$T240712 = -52						; size = 4
$T240703 = -48						; size = 4
$T240697 = -44						; size = 4
_unit$225086 = -40					; size = 16
_pUnit$225082 = -24					; size = 8
_it$225076 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotExplorerMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotExplorerMoves, COMDAT
; _this$ = ecx

; 851  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotExplorerMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 852  : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 853  : 
; 854  : 	// Loop through all recruited units
; 855  : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T240703[ebp], ecx
	mov	edx, DWORD PTR $T240703[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T240712[ebp], eax
	mov	ecx, DWORD PTR $T240712[ebp]
	mov	DWORD PTR _it$225076[ebp], ecx
	jmp	SHORT $LN7@PlotExplor
$LN23@PlotExplor:
	mov	edx, DWORD PTR _it$225076[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225076[ebp], eax
$LN7@PlotExplor:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T240745[ebp], edx
	mov	eax, DWORD PTR $T240745[ebp]
	mov	DWORD PTR $T240697[ebp], eax
	mov	ecx, DWORD PTR _it$225076[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T240697[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@PlotExplor

; 856  : 	{
; 857  : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225076[ebp]
	add	edx, 8
	mov	DWORD PTR $T240775[ebp], edx
	mov	eax, DWORD PTR $T240775[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T240785[ebp], eax
	mov	eax, DWORD PTR $T240785[ebp]
	mov	DWORD PTR _pUnit$225082[ebp], eax
	mov	BYTE PTR _pUnit$225082[ebp+4], 0
	cmp	DWORD PTR _pUnit$225082[ebp], 0
	je	SHORT $LN42@PlotExplor
	mov	ecx, DWORD PTR _pUnit$225082[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN42@PlotExplor:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 858  : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225082[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@PlotExplor

; 859  : 		{
; 860  : 			if(pUnit->AI_getUnitAIType() == UNITAI_EXPLORE ||
; 861  : #ifdef AUI_WARNING_FIXES
; 862  : 					(pUnit->IsAutomated() && pUnit->getDomainType() == DOMAIN_LAND && pUnit->GetAutomateType() == AUTOMATE_EXPLORE))
; 863  : #else
; 864  : 			        pUnit->IsAutomated() && pUnit->getDomainType() == DOMAIN_LAND && pUnit->GetAutomateType() == AUTOMATE_EXPLORE)

	mov	eax, DWORD PTR _pUnit$225082[ebp]
	mov	DWORD PTR $T240792[ebp], eax
	mov	ecx, DWORD PTR $T240792[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN2@PlotExplor
	mov	ecx, DWORD PTR _pUnit$225082[ebp]
	mov	DWORD PTR $T240796[ebp], ecx
	mov	ecx, DWORD PTR $T240796[ebp]
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@PlotExplor
	mov	eax, DWORD PTR _pUnit$225082[ebp]
	mov	DWORD PTR $T240800[ebp], eax
	mov	ecx, DWORD PTR $T240800[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN4@PlotExplor
	mov	ecx, DWORD PTR _pUnit$225082[ebp]
	mov	DWORD PTR $T240804[ebp], ecx
	mov	ecx, DWORD PTR $T240804[ebp]
	call	?GetAutomateType@CvUnit@@QBE?AW4AutomateTypes@@XZ ; CvUnit::GetAutomateType
	cmp	eax, 1
	jne	SHORT $LN4@PlotExplor
$LN2@PlotExplor:

; 865  : #endif
; 866  : 			{
; 867  : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225086[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 868  : 				unit.SetID(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$225082[ebp]
	mov	DWORD PTR $T240808[ebp], edx
	mov	eax, DWORD PTR $T240808[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T240817[ebp], ecx
	mov	edx, DWORD PTR $T240817[ebp]
	mov	DWORD PTR _unit$225086[ebp], edx

; 869  : 				m_CurrentMoveUnits.push_back(unit);

	lea	eax, DWORD PTR _unit$225086[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN4@PlotExplor:

; 870  : 			}
; 871  : 		}
; 872  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225082[ebp], 0
	je	SHORT $LN72@PlotExplor
	mov	ecx, DWORD PTR _pUnit$225082[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN72@PlotExplor:
	jmp	$LN23@PlotExplor
$LN5@PlotExplor:

; 873  : 
; 874  : 	if(m_CurrentMoveUnits.size() > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T240840[ebp], edx
	cmp	DWORD PTR $T240840[ebp], 0
	jbe	SHORT $LN8@PlotExplor

; 875  : 	{
; 876  : 		// Execute twice so explorers who can reach the end of their sight can move again
; 877  : 		ExecuteExplorerMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteExplorerMoves

; 878  : 		ExecuteExplorerMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteExplorerMoves
$LN8@PlotExplor:

; 879  : 	}
; 880  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotExplorerMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225082[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotExplorerMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotExplorerMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotExplorerMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotExplorerMoves
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -100						; size = 4
$T240992 = -96						; size = 4
$T240969 = -88						; size = 4
$T240960 = -84						; size = 4
$T240956 = -80						; size = 4
$T240952 = -76						; size = 4
$T240948 = -72						; size = 4
$T240944 = -68						; size = 4
$T240937 = -64						; size = 4
$T240927 = -60						; size = 4
$T240897 = -56						; size = 4
$T240864 = -52						; size = 4
$T240855 = -48						; size = 4
$T240849 = -44						; size = 4
_unit$225105 = -40					; size = 16
_pUnit$225101 = -24					; size = 8
_it$225095 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotExplorerSeaMoves, COMDAT
; _this$ = ecx

; 884  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 885  : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 886  : 
; 887  : 	// Loop through all recruited units
; 888  : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T240855[ebp], ecx
	mov	edx, DWORD PTR $T240855[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T240864[ebp], eax
	mov	ecx, DWORD PTR $T240864[ebp]
	mov	DWORD PTR _it$225095[ebp], ecx
	jmp	SHORT $LN7@PlotExplor@2
$LN23@PlotExplor@2:
	mov	edx, DWORD PTR _it$225095[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225095[ebp], eax
$LN7@PlotExplor@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T240897[ebp], edx
	mov	eax, DWORD PTR $T240897[ebp]
	mov	DWORD PTR $T240849[ebp], eax
	mov	ecx, DWORD PTR _it$225095[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T240849[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@PlotExplor@2

; 889  : 	{
; 890  : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225095[ebp]
	add	edx, 8
	mov	DWORD PTR $T240927[ebp], edx
	mov	eax, DWORD PTR $T240927[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T240937[ebp], eax
	mov	eax, DWORD PTR $T240937[ebp]
	mov	DWORD PTR _pUnit$225101[ebp], eax
	mov	BYTE PTR _pUnit$225101[ebp+4], 0
	cmp	DWORD PTR _pUnit$225101[ebp], 0
	je	SHORT $LN42@PlotExplor@2
	mov	ecx, DWORD PTR _pUnit$225101[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN42@PlotExplor@2:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 891  : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225101[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@PlotExplor@2

; 892  : 		{
; 893  : 			if(pUnit->AI_getUnitAIType() == UNITAI_EXPLORE_SEA ||
; 894  : #ifdef AUI_WARNING_FIXES
; 895  : 					(pUnit->IsAutomated() && pUnit->getDomainType() == DOMAIN_SEA && pUnit->GetAutomateType() == AUTOMATE_EXPLORE))
; 896  : #else
; 897  : 			        pUnit->IsAutomated() && pUnit->getDomainType() == DOMAIN_SEA && pUnit->GetAutomateType() == AUTOMATE_EXPLORE)

	mov	eax, DWORD PTR _pUnit$225101[ebp]
	mov	DWORD PTR $T240944[ebp], eax
	mov	ecx, DWORD PTR $T240944[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	je	SHORT $LN2@PlotExplor@2
	mov	ecx, DWORD PTR _pUnit$225101[ebp]
	mov	DWORD PTR $T240948[ebp], ecx
	mov	ecx, DWORD PTR $T240948[ebp]
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@PlotExplor@2
	mov	eax, DWORD PTR _pUnit$225101[ebp]
	mov	DWORD PTR $T240952[ebp], eax
	mov	ecx, DWORD PTR $T240952[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN4@PlotExplor@2
	mov	ecx, DWORD PTR _pUnit$225101[ebp]
	mov	DWORD PTR $T240956[ebp], ecx
	mov	ecx, DWORD PTR $T240956[ebp]
	call	?GetAutomateType@CvUnit@@QBE?AW4AutomateTypes@@XZ ; CvUnit::GetAutomateType
	cmp	eax, 1
	jne	SHORT $LN4@PlotExplor@2
$LN2@PlotExplor@2:

; 898  : #endif
; 899  : 			{
; 900  : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225105[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 901  : 				unit.SetID(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$225101[ebp]
	mov	DWORD PTR $T240960[ebp], edx
	mov	eax, DWORD PTR $T240960[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T240969[ebp], ecx
	mov	edx, DWORD PTR $T240969[ebp]
	mov	DWORD PTR _unit$225105[ebp], edx

; 902  : 				m_CurrentMoveUnits.push_back(unit);

	lea	eax, DWORD PTR _unit$225105[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN4@PlotExplor@2:

; 903  : 			}
; 904  : 		}
; 905  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225101[ebp], 0
	je	SHORT $LN72@PlotExplor@2
	mov	ecx, DWORD PTR _pUnit$225101[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN72@PlotExplor@2:
	jmp	$LN23@PlotExplor@2
$LN5@PlotExplor@2:

; 906  : 
; 907  : 	if(m_CurrentMoveUnits.size() > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T240992[ebp], edx
	cmp	DWORD PTR $T240992[ebp], 0
	jbe	SHORT $LN8@PlotExplor@2

; 908  : 	{
; 909  : 		// Execute twice so explorers who can reach the end of their sight can move again
; 910  : 		ExecuteExplorerMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteExplorerMoves

; 911  : 		ExecuteExplorerMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteExplorerMoves
$LN8@PlotExplor@2:

; 912  : 	}
; 913  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225101[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotExplorerSeaMoves
PUBLIC	?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteFirstTurnSettlerMoves
EXTRN	?finishMoves@CvUnit@@QAEXXZ:PROC		; CvUnit::finishMoves
EXTRN	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z:PROC ; CvUnit::PushMission
EXTRN	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_SKIP
EXTRN	?getArmyID@CvUnit@@QBEHXZ:PROC			; CvUnit::getArmyID
EXTRN	?isFound@CvUnit@@QBE_NXZ:PROC			; CvUnit::isFound
EXTRN	?canFound@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC	; CvUnit::canFound
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
EXTRN	?isHuman@CvUnit@@QBE_NXZ:PROC			; CvUnit::isHuman
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -116						; size = 4
$T241160 = -112						; size = 4
$T241143 = -108						; size = 4
$T241139 = -104						; size = 4
$T241135 = -100						; size = 4
$T241121 = -92						; size = 4
$T241112 = -88						; size = 4
$T241108 = -84						; size = 4
$T241104 = -80						; size = 4
$T241100 = -76						; size = 4
$T241096 = -72						; size = 4
$T241089 = -68						; size = 4
$T241079 = -64						; size = 4
$T241049 = -60						; size = 4
$T241016 = -56						; size = 4
$T241007 = -52						; size = 4
$T241001 = -48						; size = 4
_unit$225125 = -44					; size = 16
_pUnit$225121 = -28					; size = 8
_bGoingToSettle$225120 = -17				; size = 1
_it$225114 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::PlotFirstTurnSettlerMoves, COMDAT
; _this$ = ecx

; 917  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 918  : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 919  : 
; 920  : 	// Loop through all recruited units
; 921  : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241007[ebp], ecx
	mov	edx, DWORD PTR $T241007[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T241016[ebp], eax
	mov	ecx, DWORD PTR $T241016[ebp]
	mov	DWORD PTR _it$225114[ebp], ecx
	jmp	SHORT $LN8@PlotFirstT
$LN24@PlotFirstT:
	mov	edx, DWORD PTR _it$225114[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225114[ebp], eax
$LN8@PlotFirstT:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T241049[ebp], edx
	mov	eax, DWORD PTR $T241049[ebp]
	mov	DWORD PTR $T241001[ebp], eax
	mov	ecx, DWORD PTR _it$225114[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T241001[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@PlotFirstT

; 922  : 	{
; 923  : 		bool bGoingToSettle = false;

	mov	BYTE PTR _bGoingToSettle$225120[ebp], 0

; 924  : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225114[ebp]
	add	edx, 8
	mov	DWORD PTR $T241079[ebp], edx
	mov	eax, DWORD PTR $T241079[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T241089[ebp], eax
	mov	eax, DWORD PTR $T241089[ebp]
	mov	DWORD PTR _pUnit$225121[ebp], eax
	mov	BYTE PTR _pUnit$225121[ebp+4], 0
	cmp	DWORD PTR _pUnit$225121[ebp], 0
	je	SHORT $LN43@PlotFirstT
	mov	ecx, DWORD PTR _pUnit$225121[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN43@PlotFirstT:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 925  : 		if(pUnit && !pUnit->isHuman())

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225121[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN5@PlotFirstT
	mov	eax, DWORD PTR _pUnit$225121[ebp]
	mov	DWORD PTR $T241096[ebp], eax
	mov	ecx, DWORD PTR $T241096[ebp]
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@PlotFirstT

; 926  : 		{
; 927  : 			if(m_pPlayer->getNumCities() == 0 && m_CurrentMoveUnits.size() == 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	test	eax, eax
	jne	SHORT $LN5@PlotFirstT
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T241100[ebp], ecx
	cmp	DWORD PTR $T241100[ebp], 0
	jne	SHORT $LN5@PlotFirstT

; 928  : 			{
; 929  : 				if(pUnit->canFound(pUnit->plot()))

	mov	edx, DWORD PTR _pUnit$225121[ebp]
	mov	DWORD PTR $T241104[ebp], edx
	mov	eax, DWORD PTR _pUnit$225121[ebp]
	mov	DWORD PTR $T241108[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T241104[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR $T241108[ebp]
	call	?canFound@CvUnit@@QBE_NPBVCvPlot@@_N@Z	; CvUnit::canFound
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@PlotFirstT

; 930  : 				{
; 931  : 					CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225125[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 932  : 					unit.SetID(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$225121[ebp]
	mov	DWORD PTR $T241112[ebp], edx
	mov	eax, DWORD PTR $T241112[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T241121[ebp], ecx
	mov	edx, DWORD PTR $T241121[ebp]
	mov	DWORD PTR _unit$225125[ebp], edx

; 933  : 					m_CurrentMoveUnits.push_back(unit);

	lea	eax, DWORD PTR _unit$225125[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back

; 934  : 					bGoingToSettle = true;

	mov	BYTE PTR _bGoingToSettle$225120[ebp], 1
$LN5@PlotFirstT:

; 935  : 				}
; 936  : 			}
; 937  : 		}
; 938  : 
; 939  : 		// If we find a settler that isn't in an operation, let's keep him in place
; 940  : 		if(!bGoingToSettle && pUnit->isFound() && pUnit->getArmyID() == FFreeList::INVALID_INDEX)

	movzx	ecx, BYTE PTR _bGoingToSettle$225120[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@PlotFirstT
	mov	edx, DWORD PTR _pUnit$225121[ebp]
	mov	DWORD PTR $T241135[ebp], edx
	mov	ecx, DWORD PTR $T241135[ebp]
	call	?isFound@CvUnit@@QBE_NXZ		; CvUnit::isFound
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@PlotFirstT
	mov	ecx, DWORD PTR _pUnit$225121[ebp]
	mov	DWORD PTR $T241139[ebp], ecx
	mov	ecx, DWORD PTR $T241139[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	SHORT $LN2@PlotFirstT

; 941  : 		{
; 942  : 			pUnit->PushMission(CvTypes::getMISSION_SKIP());

	mov	edx, DWORD PTR _pUnit$225121[ebp]
	mov	DWORD PTR $T241143[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SKIP
	push	eax
	mov	ecx, DWORD PTR $T241143[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 943  : 			pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$225121[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN2@PlotFirstT:

; 944  : 		}
; 945  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225121[ebp], 0
	je	SHORT $LN81@PlotFirstT
	mov	ecx, DWORD PTR _pUnit$225121[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN81@PlotFirstT:
	jmp	$LN24@PlotFirstT
$LN6@PlotFirstT:

; 946  : 
; 947  : 	if(!m_CurrentMoveUnits.empty())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T241160[ebp], ecx
	xor	edx, edx
	cmp	DWORD PTR $T241160[ebp], 0
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN9@PlotFirstT

; 948  : 	{
; 949  : 		ExecuteFirstTurnSettlerMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteFirstTurnSettlerMoves
$LN9@PlotFirstT:

; 950  : 	}
; 951  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225121[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::PlotFirstTurnSettlerMoves
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
PUBLIC	??_C@_0CP@NKBIGDJJ@Moving?5to?5garrison?0?5X?3?5?$CFd?0?5Y?3?5?$CFd@ ; `string'
PUBLIC	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget
PUBLIC	?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z ; CvHomelandAI::GetBestUnitToReachTarget
PUBLIC	?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z ; CvHomelandAI::FindUnitsForThisMove
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
PUBLIC	__$ArrayPad$
EXTRN	?SetLastTurnGarrisonAssigned@CvCity@@QAEXH@Z:PROC ; CvCity::SetLastTurnGarrisonAssigned
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
EXTRN	?GetLastTurnGarrisonAssigned@CvCity@@QBEHXZ:PROC ; CvCity::GetLastTurnGarrisonAssigned
;	COMDAT ??_C@_0CP@NKBIGDJJ@Moving?5to?5garrison?0?5X?3?5?$CFd?0?5Y?3?5?$CFd@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0CP@NKBIGDJJ@Moving?5to?5garrison?0?5X?3?5?$CFd?0?5Y?3?5?$CFd@ DB 'M'
	DB	'oving to garrison, X: %d, Y: %d, Priority: %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z$0
__ehfuncinfo$?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z
_TEXT	SEGMENT
tv249 = -164						; size = 4
_this$ = -160						; size = 4
$T241316 = -156						; size = 4
$T241308 = -152						; size = 4
$T241304 = -148						; size = 4
$T241300 = -144						; size = 4
$T241296 = -140						; size = 4
$T241292 = -136						; size = 4
$T241288 = -132						; size = 4
$T241280 = -128						; size = 4
$T241276 = -124						; size = 4
$T241272 = -120						; size = 4
$T241233 = -112						; size = 4
$T241228 = -108						; size = 4
$T241224 = -101						; size = 1
$T241213 = -100						; size = 4
$T241209 = -93						; size = 1
_iMapY$241263 = -92					; size = 4
_iMapX$241262 = -88					; size = 4
$T241202 = -84						; size = 4
$T241198 = -80						; size = 4
$T241194 = -76						; size = 4
$T241190 = -72						; size = 4
$T241186 = -68						; size = 4
$T241182 = -64						; size = 4
$T241178 = -60						; size = 4
_strLogString$225144 = -56				; size = 28
__$ArrayPad$ = -28					; size = 4
_pTarget$225138 = -24					; size = 4
_pCity$225139 = -20					; size = 4
_iI$225134 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_bCityStateOnly$ = 8					; size = 1
?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z PROC		; CvHomelandAI::PlotGarrisonMoves, COMDAT
; _this$ = ecx

; 955  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 956  : 	// City state garrisoning has a separate priority, so only do it when the flag is on
; 957  : 	if(bCityStateOnly != m_pPlayer->isMinorCiv())

	movzx	esi, BYTE PTR _bCityStateOnly$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	cmp	esi, ecx
	je	SHORT $LN9@PlotGarris

; 958  : 	{
; 959  : 		return;

	jmp	$LN10@PlotGarris
$LN9@PlotGarris:

; 960  : 	}
; 961  : 
; 962  : 	// Do we have any targets of this type?
; 963  : 	if(m_TargetedCities.size() > 0)

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2412				; 0000096cH
	mov	DWORD PTR $T241178[ebp], edx
	mov	eax, DWORD PTR $T241178[ebp]
	mov	ecx, DWORD PTR $T241178[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	test	eax, eax
	jbe	$LN10@PlotGarris

; 964  : 	{
; 965  : 		for(unsigned int iI = 0; iI < m_TargetedCities.size(); iI++)

	mov	DWORD PTR _iI$225134[ebp], 0
	jmp	SHORT $LN7@PlotGarris
$LN6@PlotGarris:
	mov	edx, DWORD PTR _iI$225134[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$225134[ebp], edx
$LN7@PlotGarris:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2412				; 0000096cH
	mov	DWORD PTR $T241182[ebp], eax
	mov	ecx, DWORD PTR $T241182[ebp]
	mov	edx, DWORD PTR $T241182[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	cmp	DWORD PTR _iI$225134[ebp], eax
	jae	$LN10@PlotGarris

; 966  : 		{
; 967  : 			CvPlot* pTarget = GC.getMap().plot(m_TargetedCities[iI].GetTargetX(), m_TargetedCities[iI].GetTargetY());

	mov	edx, DWORD PTR _iI$225134[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+2416]
	mov	DWORD PTR $T241186[ebp], edx
	mov	ecx, DWORD PTR $T241186[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T241190[ebp], edx
	mov	eax, DWORD PTR _iI$225134[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+2416]
	mov	DWORD PTR $T241194[ebp], eax
	mov	edx, DWORD PTR $T241194[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241198[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T241202[ebp], ecx
	cmp	DWORD PTR $T241198[ebp], -2147483647	; 80000001H
	je	SHORT $LN27@PlotGarris
	cmp	DWORD PTR $T241190[ebp], -2147483647	; 80000001H
	jne	SHORT $LN28@PlotGarris
$LN27@PlotGarris:
	mov	DWORD PTR _pTarget$225138[ebp], 0
	jmp	$LN29@PlotGarris
$LN28@PlotGarris:
	mov	edx, DWORD PTR $T241202[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T241209[ebp], al
	mov	ecx, DWORD PTR $T241202[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T241213[ebp], edx
	movzx	eax, BYTE PTR $T241209[ebp]
	test	eax, eax
	je	SHORT $LN40@PlotGarris
	cmp	DWORD PTR $T241198[ebp], 0
	jge	SHORT $LN39@PlotGarris
	mov	eax, DWORD PTR $T241198[ebp]
	cdq
	idiv	DWORD PTR $T241213[ebp]
	add	edx, DWORD PTR $T241213[ebp]
	mov	DWORD PTR _iMapX$241262[ebp], edx
	jmp	SHORT $LN41@PlotGarris
	jmp	SHORT $LN40@PlotGarris
$LN39@PlotGarris:
	mov	ecx, DWORD PTR $T241198[ebp]
	cmp	ecx, DWORD PTR $T241213[ebp]
	jl	SHORT $LN40@PlotGarris
	mov	eax, DWORD PTR $T241198[ebp]
	cdq
	idiv	DWORD PTR $T241213[ebp]
	mov	DWORD PTR _iMapX$241262[ebp], edx
	jmp	SHORT $LN41@PlotGarris
$LN40@PlotGarris:
	mov	edx, DWORD PTR $T241198[ebp]
	mov	DWORD PTR _iMapX$241262[ebp], edx
$LN41@PlotGarris:
	mov	eax, DWORD PTR $T241202[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T241224[ebp], cl
	mov	edx, DWORD PTR $T241202[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T241228[ebp], eax
	movzx	ecx, BYTE PTR $T241224[ebp]
	push	ecx
	mov	edx, DWORD PTR $T241228[ebp]
	push	edx
	mov	eax, DWORD PTR $T241190[ebp]
	push	eax
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$241263[ebp], eax
	mov	ecx, DWORD PTR _iMapY$241263[ebp]
	push	ecx
	mov	edx, DWORD PTR _iMapX$241262[ebp]
	push	edx
	mov	ecx, DWORD PTR $T241202[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN31@PlotGarris
	mov	eax, DWORD PTR $T241202[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T241233[ebp], ecx
	mov	edx, DWORD PTR _iMapY$241263[ebp]
	imul	edx, DWORD PTR $T241233[ebp]
	add	edx, DWORD PTR _iMapX$241262[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T241202[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv249[ebp], edx
	jmp	SHORT $LN32@PlotGarris
$LN31@PlotGarris:
	mov	DWORD PTR tv249[ebp], 0
$LN32@PlotGarris:
	mov	ecx, DWORD PTR tv249[ebp]
	mov	DWORD PTR _pTarget$225138[ebp], ecx
$LN29@PlotGarris:

; 968  : 			CvCity* pCity = pTarget->getPlotCity();

	mov	ecx, DWORD PTR _pTarget$225138[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$225139[ebp], eax

; 969  : 
; 970  : 			if(pCity && pCity->GetLastTurnGarrisonAssigned() < GC.getGame().getGameTurn())

	cmp	DWORD PTR _pCity$225139[ebp], 0
	je	$LN4@PlotGarris
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T241272[ebp], edx
	mov	ecx, DWORD PTR _pCity$225139[ebp]
	call	?GetLastTurnGarrisonAssigned@CvCity@@QBEHXZ ; CvCity::GetLastTurnGarrisonAssigned
	mov	esi, eax
	mov	ecx, DWORD PTR $T241272[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	esi, eax
	jge	$LN4@PlotGarris

; 971  : 			{
; 972  : 				// Grab units that make sense for this move type
; 973  : 				FindUnitsForThisMove(AI_HOMELAND_MOVE_GARRISON, (iI == 0)/*bFirstTime*/);

	cmp	DWORD PTR _iI$225134[ebp], 0
	sete	al
	movzx	ecx, al
	push	ecx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z ; CvHomelandAI::FindUnitsForThisMove

; 974  : 
; 975  : 				if(m_CurrentMoveHighPriorityUnits.size() + m_CurrentMoveUnits.size() > 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1060]
	mov	DWORD PTR $T241276[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T241280[ebp], edx
	mov	eax, DWORD PTR $T241276[ebp]
	add	eax, DWORD PTR $T241280[ebp]
	je	$LN4@PlotGarris

; 976  : 				{
; 977  : 					if(GetBestUnitToReachTarget(pTarget, m_iDefensiveMoveTurns))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2528]
	push	edx
	mov	eax, DWORD PTR _pTarget$225138[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z ; CvHomelandAI::GetBestUnitToReachTarget
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@PlotGarris

; 978  : 					{
; 979  : 						ExecuteMoveToTarget(pTarget);

	mov	edx, DWORD PTR _pTarget$225138[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget

; 980  : 
; 981  : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN1@PlotGarris
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN1@PlotGarris

; 982  : 						{
; 983  : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225144[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 984  : 							strLogString.Format("Moving to garrison, X: %d, Y: %d, Priority: %d", m_TargetedCities[iI].GetTargetX(), m_TargetedCities[iI].GetTargetY(), m_TargetedCities[iI].GetAuxIntData());

	mov	edx, DWORD PTR _iI$225134[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+2416]
	mov	DWORD PTR $T241288[ebp], edx
	mov	ecx, DWORD PTR $T241288[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T241292[ebp], edx
	mov	eax, DWORD PTR _iI$225134[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+2416]
	mov	DWORD PTR $T241296[ebp], eax
	mov	edx, DWORD PTR $T241296[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T241300[ebp], eax
	mov	ecx, DWORD PTR _iI$225134[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+2416]
	mov	DWORD PTR $T241304[ebp], ecx
	mov	eax, DWORD PTR $T241304[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241308[ebp], ecx
	mov	edx, DWORD PTR $T241292[ebp]
	push	edx
	mov	eax, DWORD PTR $T241300[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241308[ebp]
	push	ecx
	push	OFFSET ??_C@_0CP@NKBIGDJJ@Moving?5to?5garrison?0?5X?3?5?$CFd?0?5Y?3?5?$CFd@
	lea	edx, DWORD PTR _strLogString$225144[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 985  : 							LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$225144[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 986  : 						}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$225144[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@PlotGarris:

; 987  : 
; 988  : 						pCity->SetLastTurnGarrisonAssigned(GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T241316[ebp], ecx
	mov	ecx, DWORD PTR $T241316[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	mov	ecx, DWORD PTR _pCity$225139[ebp]
	call	?SetLastTurnGarrisonAssigned@CvCity@@QAEXH@Z ; CvCity::SetLastTurnGarrisonAssigned
$LN4@PlotGarris:

; 989  : 					}
; 990  : 				}
; 991  : 			}
; 992  : 		}

	jmp	$LN6@PlotGarris
$LN10@PlotGarris:

; 993  : 	}
; 994  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z$0:
	lea	ecx, DWORD PTR _strLogString$225144[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-160]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z ENDP		; CvHomelandAI::PlotGarrisonMoves
PUBLIC	?ExecuteHeals@CvHomelandAI@@AAEXXZ		; CvHomelandAI::ExecuteHeals
PUBLIC	??_C@_0BM@MPILEIAO@?$CFs?5healing?5at?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?$AA@ ; `string'
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
PUBLIC	__$ArrayPad$
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ:PROC	; CvUnit::getUnitInfo
EXTRN	?IsUnderEnemyRangedAttack@CvUnit@@QBE_NXZ:PROC	; CvUnit::IsUnderEnemyRangedAttack
EXTRN	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::IsFriendlyTerritory
EXTRN	?GetMaxHitPoints@CvUnit@@QBEHXZ:PROC		; CvUnit::GetMaxHitPoints
EXTRN	?GetCurrHitPoints@CvUnit@@QBEHXZ:PROC		; CvUnit::GetCurrHitPoints
;	COMDAT ??_C@_0BM@MPILEIAO@?$CFs?5healing?5at?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0BM@MPILEIAO@?$CFs?5healing?5at?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?$AA@ DB '%'
	DB	's healing at, X: %d, Y: %d', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?PlotHealMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotHealMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PlotHealMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotHealMoves@CvHomelandAI@@AAEXXZ$2
__ehfuncinfo$?PlotHealMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?PlotHealMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotHealMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -216						; size = 4
$T241569 = -212						; size = 4
$T241545 = -208						; size = 4
$T241536 = -204						; size = 4
$T241532 = -200						; size = 4
$T241523 = -196						; size = 4
$T241519 = -192						; size = 4
$T241513 = -188						; size = 4
$T241509 = -184						; size = 4
$T241487 = -176						; size = 4
$T241478 = -172						; size = 4
$T241474 = -168						; size = 4
$T241470 = -164						; size = 4
$T241466 = -160						; size = 4
$T241457 = -156						; size = 4
$T241448 = -148						; size = 4
$T241444 = -141						; size = 1
$T241435 = -140						; size = 4
$T241431 = -136						; size = 4
$T241427 = -132						; size = 4
$T241423 = -128						; size = 4
$T241416 = -124						; size = 4
$T241406 = -120						; size = 4
$T241376 = -116						; size = 4
$T241343 = -112						; size = 4
$T241334 = -108						; size = 4
$T241326 = -104						; size = 4
_strLogString$225167 = -100				; size = 28
_strTemp$225168 = -72					; size = 28
__$ArrayPad$ = -44					; size = 4
_unit$225165 = -40					; size = 16
_pUnit$225159 = -24					; size = 8
_it$225153 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotHealMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotHealMoves, COMDAT
; _this$ = ecx

; 998  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotHealMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 999  : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 1000 : 
; 1001 : 	// Loop through all recruited units
; 1002 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241334[ebp], ecx
	mov	edx, DWORD PTR $T241334[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T241343[ebp], eax
	mov	ecx, DWORD PTR $T241343[ebp]
	mov	DWORD PTR _it$225153[ebp], ecx
	jmp	SHORT $LN10@PlotHealMo
$LN28@PlotHealMo:
	mov	edx, DWORD PTR _it$225153[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225153[ebp], eax
$LN10@PlotHealMo:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T241376[ebp], edx
	mov	eax, DWORD PTR $T241376[ebp]
	mov	DWORD PTR $T241326[ebp], eax
	mov	ecx, DWORD PTR _it$225153[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T241326[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN8@PlotHealMo

; 1003 : 	{
; 1004 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225153[ebp]
	add	edx, 8
	mov	DWORD PTR $T241406[ebp], edx
	mov	eax, DWORD PTR $T241406[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T241416[ebp], eax
	mov	eax, DWORD PTR $T241416[ebp]
	mov	DWORD PTR _pUnit$225159[ebp], eax
	mov	BYTE PTR _pUnit$225159[ebp+4], 0
	cmp	DWORD PTR _pUnit$225159[ebp], 0
	je	SHORT $LN47@PlotHealMo
	mov	ecx, DWORD PTR _pUnit$225159[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN47@PlotHealMo:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1005 : 		if(pUnit && !pUnit->isHuman())

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225159[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN7@PlotHealMo
	mov	eax, DWORD PTR _pUnit$225159[ebp]
	mov	DWORD PTR $T241423[ebp], eax
	mov	ecx, DWORD PTR $T241423[ebp]
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN7@PlotHealMo

; 1006 : 		{
; 1007 : 			// Am I under 100% health and not at sea or already in a city?
; 1008 : #ifdef AUI_HOMELAND_TWEAKED_HEAL_MOVES
; 1009 : 			if (pUnit->healRate(pUnit->plot()) <= 0 || pUnit->isAlwaysHeal() || pUnit->isEmbarked())
; 1010 : 				continue;
; 1011 : 			if (((m_pPlayer->GetPlotDanger(*(pUnit->plot())) <= 0 && pUnit->GetCurrHitPoints() < pUnit->GetMaxHitPoints()) ||
; 1012 : 				(m_pPlayer->GetPlotDanger(*(pUnit->plot())) > 0 && pUnit->GetCurrHitPoints() + pUnit->healRate(pUnit->plot()) < pUnit->GetMaxHitPoints())))
; 1013 : #else
; 1014 : 			if(pUnit->GetCurrHitPoints() < pUnit->GetMaxHitPoints() && !pUnit->isEmbarked() && !pUnit->plot()->isCity())

	mov	edx, DWORD PTR _pUnit$225159[ebp]
	mov	DWORD PTR $T241427[ebp], edx
	mov	eax, DWORD PTR _pUnit$225159[ebp]
	mov	DWORD PTR $T241431[ebp], eax
	mov	ecx, DWORD PTR $T241427[ebp]
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	mov	esi, eax
	mov	ecx, DWORD PTR $T241431[ebp]
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	cmp	esi, eax
	jge	$LN7@PlotHealMo
	mov	ecx, DWORD PTR _pUnit$225159[ebp]
	mov	DWORD PTR $T241435[ebp], ecx
	mov	edx, DWORD PTR $T241435[ebp]
	mov	al, BYTE PTR [edx+1652]
	mov	BYTE PTR $T241444[ebp], al
	movzx	ecx, BYTE PTR $T241444[ebp]
	test	ecx, ecx
	jne	$LN7@PlotHealMo
	mov	edx, DWORD PTR _pUnit$225159[ebp]
	mov	DWORD PTR $T241448[ebp], edx
	mov	ecx, DWORD PTR $T241448[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	eax, al
	test	eax, eax
	jne	$LN7@PlotHealMo

; 1015 : #endif
; 1016 : 			{
; 1017 : 				// If I'm a naval unit I need to be in friendly territory
; 1018 : 				if(pUnit->getDomainType() != DOMAIN_SEA || pUnit->plot()->IsFriendlyTerritory(m_pPlayer->GetID()))

	mov	ecx, DWORD PTR _pUnit$225159[ebp]
	mov	DWORD PTR $T241457[ebp], ecx
	mov	ecx, DWORD PTR $T241457[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN4@PlotHealMo
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T241466[ebp], ecx
	mov	edx, DWORD PTR _pUnit$225159[ebp]
	mov	DWORD PTR $T241470[ebp], edx
	mov	eax, DWORD PTR $T241466[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241470[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsFriendlyTerritory
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@PlotHealMo
$LN4@PlotHealMo:

; 1019 : 				{
; 1020 : 					if (!pUnit->IsUnderEnemyRangedAttack())

	mov	edx, DWORD PTR _pUnit$225159[ebp]
	mov	DWORD PTR $T241474[ebp], edx
	mov	ecx, DWORD PTR $T241474[ebp]
	call	?IsUnderEnemyRangedAttack@CvUnit@@QBE_NXZ ; CvUnit::IsUnderEnemyRangedAttack
	movzx	eax, al
	test	eax, eax
	jne	$LN7@PlotHealMo

; 1021 : 					{
; 1022 : 						CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225165[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 1023 : 						unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225159[ebp]
	mov	DWORD PTR $T241478[ebp], ecx
	mov	edx, DWORD PTR $T241478[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T241487[ebp], eax
	mov	ecx, DWORD PTR $T241487[ebp]
	mov	DWORD PTR _unit$225165[ebp], ecx

; 1024 : 						m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225165[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back

; 1025 : 
; 1026 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN7@PlotHealMo
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@PlotHealMo

; 1027 : 						{
; 1028 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225167[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1029 : 							CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$225168[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1030 : 
; 1031 : 							strTemp = pUnit->getUnitInfo().GetDescription();

	mov	edx, DWORD PTR _pUnit$225159[ebp]
	mov	DWORD PTR $T241509[ebp], edx
	mov	ecx, DWORD PTR $T241509[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	DWORD PTR $T241513[ebp], eax
	mov	ecx, DWORD PTR $T241513[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T241519[ebp], eax
	cmp	DWORD PTR $T241519[ebp], 0
	je	SHORT $LN108@PlotHealMo
	mov	eax, DWORD PTR $T241519[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTemp$225168[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN109@PlotHealMo
$LN108@PlotHealMo:
	lea	ecx, DWORD PTR _strTemp$225168[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN109@PlotHealMo:

; 1032 : 							strLogString.Format("%s healing at, X: %d, Y: %d", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

	mov	ecx, DWORD PTR _pUnit$225159[ebp]
	mov	DWORD PTR $T241523[ebp], ecx
	mov	edx, DWORD PTR $T241523[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T241532[ebp], eax
	mov	ecx, DWORD PTR _pUnit$225159[ebp]
	mov	DWORD PTR $T241536[ebp], ecx
	mov	edx, DWORD PTR $T241536[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T241545[ebp], eax
	mov	ecx, DWORD PTR $T241532[ebp]
	push	ecx
	mov	edx, DWORD PTR $T241545[ebp]
	push	edx
	lea	ecx, DWORD PTR _strTemp$225168[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0BM@MPILEIAO@?$CFs?5healing?5at?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?$AA@
	lea	eax, DWORD PTR _strLogString$225167[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 1033 : 							LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$225167[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1034 : 						}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$225168[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$225167[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@PlotHealMo:

; 1035 : 					}
; 1036 : 				}
; 1037 : 			}
; 1038 : 		}
; 1039 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225159[ebp], 0
	je	SHORT $LN132@PlotHealMo
	mov	ecx, DWORD PTR _pUnit$225159[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN132@PlotHealMo:
	jmp	$LN28@PlotHealMo
$LN8@PlotHealMo:

; 1040 : 
; 1041 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR $T241569[ebp], eax
	cmp	DWORD PTR $T241569[ebp], 0
	jbe	SHORT $LN11@PlotHealMo

; 1042 : 	{
; 1043 : 		ExecuteHeals();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteHeals@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteHeals
$LN11@PlotHealMo:

; 1044 : 	}
; 1045 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotHealMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225159[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotHealMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$225167[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotHealMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$225168[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotHealMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-212]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotHealMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotHealMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotHealMoves
PUBLIC	?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteMovesToSafestPlot
EXTRN	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ:PROC ; CvUnit::GetBaseCombatStrengthConsideringDamage
EXTRN	?isBarbarian@CvUnit@@QBE_NXZ:PROC		; CvUnit::isBarbarian
EXTRN	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z:PROC	; CvUnit::GetBaseCombatStrength
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotMovesToSafety@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotMovesToSafety@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotMovesToSafety@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotMovesToSafety@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotMovesToSafety@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -152						; size = 4
$T241757 = -148						; size = 4
$T241734 = -140						; size = 4
$T241725 = -136						; size = 4
$T241721 = -132						; size = 4
$T241717 = -128						; size = 4
$T241713 = -124						; size = 4
$T241709 = -120						; size = 4
$T241705 = -116						; size = 4
$T241701 = -112						; size = 4
$T241697 = -108						; size = 4
$T241693 = -104						; size = 4
$T241689 = -100						; size = 4
$T241685 = -96						; size = 4
$T241681 = -92						; size = 4
$T241677 = -88						; size = 4
$T241673 = -84						; size = 4
$T241666 = -80						; size = 4
$T241656 = -76						; size = 4
$T241626 = -72						; size = 4
$T241593 = -68						; size = 4
$T241584 = -64						; size = 4
$T241578 = -60						; size = 4
_unit$225205 = -56					; size = 16
_iAcceptableDanger$225202 = -40				; size = 4
_bAddUnit$225189 = -33					; size = 1
_pPlot$225186 = -32					; size = 4
_iDangerLevel$225187 = -28				; size = 4
_pUnit$225184 = -24					; size = 8
_it$225178 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotMovesToSafety@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotMovesToSafety, COMDAT
; _this$ = ecx

; 1049 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotMovesToSafety@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1050 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 1051 : 
; 1052 : 	// Loop through all recruited units
; 1053 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241584[ebp], ecx
	mov	edx, DWORD PTR $T241584[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T241593[ebp], eax
	mov	ecx, DWORD PTR $T241593[ebp]
	mov	DWORD PTR _it$225178[ebp], ecx
	jmp	SHORT $LN20@PlotMovesT
$LN36@PlotMovesT:
	mov	edx, DWORD PTR _it$225178[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225178[ebp], eax
$LN20@PlotMovesT:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T241626[ebp], edx
	mov	eax, DWORD PTR $T241626[ebp]
	mov	DWORD PTR $T241578[ebp], eax
	mov	ecx, DWORD PTR _it$225178[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T241578[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN18@PlotMovesT

; 1054 : 	{
; 1055 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225178[ebp]
	add	edx, 8
	mov	DWORD PTR $T241656[ebp], edx
	mov	eax, DWORD PTR $T241656[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T241666[ebp], eax
	mov	eax, DWORD PTR $T241666[ebp]
	mov	DWORD PTR _pUnit$225184[ebp], eax
	mov	BYTE PTR _pUnit$225184[ebp+4], 0
	cmp	DWORD PTR _pUnit$225184[ebp], 0
	je	SHORT $LN55@PlotMovesT
	mov	ecx, DWORD PTR _pUnit$225184[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN55@PlotMovesT:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1056 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225184[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN17@PlotMovesT

; 1057 : 		{
; 1058 : 			// Danger value of plot must be greater than 0
; 1059 : 			CvPlot* pPlot = pUnit->plot();

	mov	eax, DWORD PTR _pUnit$225184[ebp]
	mov	DWORD PTR $T241673[ebp], eax
	mov	ecx, DWORD PTR $T241673[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pPlot$225186[ebp], eax

; 1060 : 
; 1061 : 			int iDangerLevel = m_pPlayer->GetPlotDanger(*pPlot);

	mov	ecx, DWORD PTR _pPlot$225186[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	mov	DWORD PTR _iDangerLevel$225187[ebp], eax

; 1062 : 			if(iDangerLevel > 0)

	cmp	DWORD PTR _iDangerLevel$225187[ebp], 0
	jle	$LN17@PlotMovesT

; 1063 : 			{
; 1064 : 				bool bAddUnit = false;

	mov	BYTE PTR _bAddUnit$225189[ebp], 0

; 1065 : 
; 1066 : 				// If civilian (or embarked unit) always ready to flee
; 1067 : 				// slewis - 4.18.2013 - Problem here is that a combat unit that is a boat can get stuck in a city hiding from barbarians on the land
; 1068 : 				if(!pUnit->IsCanDefend())

	mov	eax, DWORD PTR _pUnit$225184[ebp]
	mov	DWORD PTR $T241677[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T241677[ebp]
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN15@PlotMovesT

; 1069 : 				{
; 1070 : 					if (pUnit->IsAutomated() && pUnit->GetBaseCombatStrength() > 0)

	mov	edx, DWORD PTR _pUnit$225184[ebp]
	mov	DWORD PTR $T241681[ebp], edx
	mov	ecx, DWORD PTR $T241681[ebp]
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@PlotMovesT
	mov	ecx, DWORD PTR _pUnit$225184[ebp]
	mov	DWORD PTR $T241685[ebp], ecx
	push	0
	mov	ecx, DWORD PTR $T241685[ebp]
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength
	test	eax, eax
	jle	SHORT $LN14@PlotMovesT

; 1071 : 					{
; 1072 : 						// then this is our special case
; 1073 : 					}
; 1074 : 					else

	jmp	SHORT $LN13@PlotMovesT
$LN14@PlotMovesT:

; 1075 : 					{
; 1076 : 						bAddUnit = true;

	mov	BYTE PTR _bAddUnit$225189[ebp], 1
$LN13@PlotMovesT:

; 1077 : 					}

	jmp	$LN12@PlotMovesT
$LN15@PlotMovesT:

; 1078 : 				}
; 1079 : 
; 1080 : 				// Also may be true if a damaged combat unit
; 1081 : 				else if(pUnit->GetCurrHitPoints() < pUnit->GetMaxHitPoints())

	mov	edx, DWORD PTR _pUnit$225184[ebp]
	mov	DWORD PTR $T241689[ebp], edx
	mov	eax, DWORD PTR _pUnit$225184[ebp]
	mov	DWORD PTR $T241693[ebp], eax
	mov	ecx, DWORD PTR $T241689[ebp]
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	mov	esi, eax
	mov	ecx, DWORD PTR $T241693[ebp]
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	cmp	esi, eax
	jge	SHORT $LN11@PlotMovesT

; 1082 : 				{
; 1083 : 					if(pUnit->isBarbarian())

	mov	ecx, DWORD PTR _pUnit$225184[ebp]
	mov	DWORD PTR $T241697[ebp], ecx
	mov	ecx, DWORD PTR $T241697[ebp]
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@PlotMovesT

; 1084 : 					{
; 1085 : 						// Barbarian combat units - only naval units flee (but they flee if have taken ANY damage)
; 1086 : 						if(pUnit->getDomainType() == DOMAIN_SEA)

	mov	eax, DWORD PTR _pUnit$225184[ebp]
	mov	DWORD PTR $T241701[ebp], eax
	mov	ecx, DWORD PTR $T241701[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN9@PlotMovesT

; 1087 : 						{
; 1088 : 							bAddUnit = true;

	mov	BYTE PTR _bAddUnit$225189[ebp], 1
$LN9@PlotMovesT:

; 1089 : 						}
; 1090 : 					}

	jmp	SHORT $LN8@PlotMovesT
$LN10@PlotMovesT:

; 1091 : 
; 1092 : 					// Everyone else flees at less than or equal to 50% combat strength
; 1093 : 					else if(pUnit->IsUnderEnemyRangedAttack() || pUnit->GetBaseCombatStrengthConsideringDamage() * 2 <= pUnit->GetBaseCombatStrength())

	mov	ecx, DWORD PTR _pUnit$225184[ebp]
	mov	DWORD PTR $T241705[ebp], ecx
	mov	ecx, DWORD PTR $T241705[ebp]
	call	?IsUnderEnemyRangedAttack@CvUnit@@QBE_NXZ ; CvUnit::IsUnderEnemyRangedAttack
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN6@PlotMovesT
	mov	eax, DWORD PTR _pUnit$225184[ebp]
	mov	DWORD PTR $T241709[ebp], eax
	mov	ecx, DWORD PTR _pUnit$225184[ebp]
	mov	DWORD PTR $T241713[ebp], ecx
	mov	ecx, DWORD PTR $T241709[ebp]
	call	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ ; CvUnit::GetBaseCombatStrengthConsideringDamage
	mov	esi, eax
	shl	esi, 1
	push	0
	mov	ecx, DWORD PTR $T241713[ebp]
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength
	cmp	esi, eax
	jg	SHORT $LN8@PlotMovesT
$LN6@PlotMovesT:

; 1094 : 					{
; 1095 : 						bAddUnit = true;

	mov	BYTE PTR _bAddUnit$225189[ebp], 1
$LN8@PlotMovesT:

; 1096 : 					}
; 1097 : 				}

	jmp	SHORT $LN12@PlotMovesT
$LN11@PlotMovesT:

; 1098 : 
; 1099 : 				// Also flee if danger is really high in current plot (but not if we're barbarian)
; 1100 : 				else if(!pUnit->isBarbarian())

	mov	edx, DWORD PTR _pUnit$225184[ebp]
	mov	DWORD PTR $T241717[ebp], edx
	mov	ecx, DWORD PTR $T241717[ebp]
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN12@PlotMovesT

; 1101 : 				{
; 1102 : 					int iAcceptableDanger;
; 1103 : #ifdef AUI_HOMELAND_TWEAKED_ACCEPTABLE_DANGER
; 1104 : 					iAcceptableDanger = pUnit->GetBaseCombatStrengthConsideringDamage() * (int)(AUI_HOMELAND_TWEAKED_ACCEPTABLE_DANGER + 0.5 +
; 1105 : 						(100.0 - AUI_HOMELAND_TWEAKED_ACCEPTABLE_DANGER) * pow((double)pUnit->GetCurrHitPoints() / (double)pUnit->GetMaxHitPoints(), 2.0));
; 1106 : #else
; 1107 : 					iAcceptableDanger = pUnit->GetBaseCombatStrengthConsideringDamage() * 100;

	mov	ecx, DWORD PTR _pUnit$225184[ebp]
	mov	DWORD PTR $T241721[ebp], ecx
	mov	ecx, DWORD PTR $T241721[ebp]
	call	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ ; CvUnit::GetBaseCombatStrengthConsideringDamage
	imul	eax, 100				; 00000064H
	mov	DWORD PTR _iAcceptableDanger$225202[ebp], eax

; 1108 : #endif
; 1109 : 					if(iDangerLevel > iAcceptableDanger)

	mov	edx, DWORD PTR _iDangerLevel$225187[ebp]
	cmp	edx, DWORD PTR _iAcceptableDanger$225202[ebp]
	jle	SHORT $LN12@PlotMovesT

; 1110 : 					{
; 1111 : 						bAddUnit = true;

	mov	BYTE PTR _bAddUnit$225189[ebp], 1
$LN12@PlotMovesT:

; 1112 : 					}
; 1113 : 				}
; 1114 : 
; 1115 : 				if(bAddUnit)

	movzx	eax, BYTE PTR _bAddUnit$225189[ebp]
	test	eax, eax
	je	SHORT $LN17@PlotMovesT

; 1116 : 				{
; 1117 : 					// Just one unit involved in this move to execute
; 1118 : 					CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225205[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 1119 : 					unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225184[ebp]
	mov	DWORD PTR $T241725[ebp], ecx
	mov	edx, DWORD PTR $T241725[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T241734[ebp], eax
	mov	ecx, DWORD PTR $T241734[ebp]
	mov	DWORD PTR _unit$225205[ebp], ecx

; 1120 : 					m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225205[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN17@PlotMovesT:

; 1121 : 				}
; 1122 : 			}
; 1123 : 		}
; 1124 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225184[ebp], 0
	je	SHORT $LN103@PlotMovesT
	mov	ecx, DWORD PTR _pUnit$225184[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN103@PlotMovesT:
	jmp	$LN36@PlotMovesT
$LN18@PlotMovesT:

; 1125 : 
; 1126 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T241757[ebp], ecx
	cmp	DWORD PTR $T241757[ebp], 0
	jbe	SHORT $LN21@PlotMovesT

; 1127 : 	{
; 1128 : 		ExecuteMovesToSafestPlot();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteMovesToSafestPlot
$LN21@PlotMovesT:

; 1129 : 	}
; 1130 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotMovesToSafety@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225184[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotMovesToSafety@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-148]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotMovesToSafety@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotMovesToSafety@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotMovesToSafety
PUBLIC	??_C@_0DB@MEEFACDO@Moving?5to?5mobile?5reserve?5muster?5@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0DB@MEEFACDO@Moving?5to?5mobile?5reserve?5muster?5@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0DB@MEEFACDO@Moving?5to?5mobile?5reserve?5muster?5@ DB 'Moving to m'
	DB	'obile reserve muster pt, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv225 = -152						; size = 4
tv237 = -148						; size = 4
_this$ = -144						; size = 4
$T241916 = -140						; size = 4
$T241912 = -136						; size = 4
$T241908 = -132						; size = 4
$T241904 = -128						; size = 4
$T241896 = -124						; size = 4
$T241892 = -120						; size = 4
$T241850 = -116						; size = 4
$T241837 = -112						; size = 4
$T241833 = -108						; size = 4
$T241826 = -104						; size = 4
$T241822 = -97						; size = 1
$T241811 = -96						; size = 4
$T241807 = -89						; size = 1
_iMapY$241888 = -88					; size = 4
_iMapX$241887 = -84					; size = 4
$T241800 = -80						; size = 4
$T241796 = -76						; size = 4
$T241792 = -72						; size = 4
$T241788 = -68						; size = 4
$T241784 = -64						; size = 4
$T241780 = -60						; size = 4
$T241776 = -56						; size = 4
_strLogString$225219 = -52				; size = 28
__$ArrayPad$ = -24					; size = 4
_pTarget$225215 = -20					; size = 4
_iI$225211 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::PlotMobileReserveMoves, COMDAT
; _this$ = ecx

; 1134 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1135 : 	// Do we have any targets of this type?
; 1136 : 	if(!m_TargetedHomelandRoads.empty())

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2476				; 000009acH
	mov	DWORD PTR $T241776[ebp], eax
	mov	ecx, DWORD PTR $T241776[ebp]
	mov	edx, DWORD PTR $T241776[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	edx, al
	test	edx, edx
	jne	$LN8@PlotMobile

; 1137 : 	{
; 1138 : 		// Prioritize them (LATER)
; 1139 : 
; 1140 : 		// See how many moves of this type we can execute
; 1141 : 		for(unsigned int iI = 0; iI < m_TargetedHomelandRoads.size(); iI++)

	mov	DWORD PTR _iI$225211[ebp], 0
	jmp	SHORT $LN6@PlotMobile
$LN5@PlotMobile:
	mov	eax, DWORD PTR _iI$225211[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$225211[ebp], eax
$LN6@PlotMobile:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2476				; 000009acH
	mov	DWORD PTR $T241780[ebp], ecx
	mov	edx, DWORD PTR $T241780[ebp]
	mov	eax, DWORD PTR $T241780[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	cmp	DWORD PTR _iI$225211[ebp], eax
	jae	$LN8@PlotMobile

; 1142 : 		{
; 1143 : 			CvPlot* pTarget = GC.getMap().plot(m_TargetedHomelandRoads[iI].GetTargetX(), m_TargetedHomelandRoads[iI].GetTargetY());

	mov	edx, DWORD PTR _iI$225211[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+2480]
	mov	DWORD PTR $T241784[ebp], edx
	mov	ecx, DWORD PTR $T241784[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T241788[ebp], edx
	mov	eax, DWORD PTR _iI$225211[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+2480]
	mov	DWORD PTR $T241792[ebp], eax
	mov	edx, DWORD PTR $T241792[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241796[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T241800[ebp], ecx
	cmp	DWORD PTR $T241796[ebp], -2147483647	; 80000001H
	je	SHORT $LN27@PlotMobile
	cmp	DWORD PTR $T241788[ebp], -2147483647	; 80000001H
	jne	SHORT $LN28@PlotMobile
$LN27@PlotMobile:
	mov	DWORD PTR _pTarget$225215[ebp], 0
	jmp	$LN29@PlotMobile
$LN28@PlotMobile:
	mov	edx, DWORD PTR $T241800[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T241807[ebp], al
	mov	ecx, DWORD PTR $T241800[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T241811[ebp], edx
	movzx	eax, BYTE PTR $T241807[ebp]
	test	eax, eax
	je	SHORT $LN40@PlotMobile
	cmp	DWORD PTR $T241796[ebp], 0
	jge	SHORT $LN39@PlotMobile
	mov	eax, DWORD PTR $T241796[ebp]
	cdq
	idiv	DWORD PTR $T241811[ebp]
	add	edx, DWORD PTR $T241811[ebp]
	mov	DWORD PTR _iMapX$241887[ebp], edx
	jmp	SHORT $LN41@PlotMobile
	jmp	SHORT $LN40@PlotMobile
$LN39@PlotMobile:
	mov	ecx, DWORD PTR $T241796[ebp]
	cmp	ecx, DWORD PTR $T241811[ebp]
	jl	SHORT $LN40@PlotMobile
	mov	eax, DWORD PTR $T241796[ebp]
	cdq
	idiv	DWORD PTR $T241811[ebp]
	mov	DWORD PTR _iMapX$241887[ebp], edx
	jmp	SHORT $LN41@PlotMobile
$LN40@PlotMobile:
	mov	edx, DWORD PTR $T241796[ebp]
	mov	DWORD PTR _iMapX$241887[ebp], edx
$LN41@PlotMobile:
	mov	eax, DWORD PTR $T241800[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T241822[ebp], cl
	mov	edx, DWORD PTR $T241800[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T241826[ebp], eax
	movzx	ecx, BYTE PTR $T241822[ebp]
	push	ecx
	mov	edx, DWORD PTR $T241826[ebp]
	push	edx
	mov	eax, DWORD PTR $T241788[ebp]
	push	eax
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$241888[ebp], eax
	cmp	DWORD PTR _iMapX$241887[ebp], 0
	jl	SHORT $LN49@PlotMobile
	mov	ecx, DWORD PTR $T241800[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T241833[ebp], edx
	mov	eax, DWORD PTR _iMapX$241887[ebp]
	cmp	eax, DWORD PTR $T241833[ebp]
	jge	SHORT $LN49@PlotMobile
	cmp	DWORD PTR _iMapY$241888[ebp], 0
	jl	SHORT $LN49@PlotMobile
	mov	ecx, DWORD PTR $T241800[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T241837[ebp], edx
	mov	eax, DWORD PTR _iMapY$241888[ebp]
	cmp	eax, DWORD PTR $T241837[ebp]
	jge	SHORT $LN49@PlotMobile
	mov	DWORD PTR tv237[ebp], 1
	jmp	SHORT $LN47@PlotMobile
$LN49@PlotMobile:
	mov	DWORD PTR tv237[ebp], 0
$LN47@PlotMobile:
	cmp	DWORD PTR tv237[ebp], 0
	je	SHORT $LN31@PlotMobile
	mov	ecx, DWORD PTR $T241800[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T241850[ebp], edx
	mov	eax, DWORD PTR _iMapY$241888[ebp]
	imul	eax, DWORD PTR $T241850[ebp]
	add	eax, DWORD PTR _iMapX$241887[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T241800[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv225[ebp], eax
	jmp	SHORT $LN32@PlotMobile
$LN31@PlotMobile:
	mov	DWORD PTR tv225[ebp], 0
$LN32@PlotMobile:
	mov	edx, DWORD PTR tv225[ebp]
	mov	DWORD PTR _pTarget$225215[ebp], edx
$LN29@PlotMobile:

; 1144 : 
; 1145 : 			FindUnitsForThisMove(AI_HOMELAND_MOVE_MOBILE_RESERVE, (iI == 0)/*bFirstTime*/);

	cmp	DWORD PTR _iI$225211[ebp], 0
	sete	al
	movzx	ecx, al
	push	ecx
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z ; CvHomelandAI::FindUnitsForThisMove

; 1146 : 
; 1147 : 			if(m_CurrentMoveHighPriorityUnits.size() + m_CurrentMoveUnits.size() > 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1060]
	mov	DWORD PTR $T241892[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T241896[ebp], edx
	mov	eax, DWORD PTR $T241892[ebp]
	add	eax, DWORD PTR $T241896[ebp]
	je	$LN3@PlotMobile

; 1148 : 			{
; 1149 : 				if(GetBestUnitToReachTarget(pTarget, MAX_INT))

	push	2147483647				; 7fffffffH
	mov	ecx, DWORD PTR _pTarget$225215[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z ; CvHomelandAI::GetBestUnitToReachTarget
	movzx	edx, al
	test	edx, edx
	je	$LN3@PlotMobile

; 1150 : 				{
; 1151 : 					ExecuteMoveToTarget(pTarget);

	mov	eax, DWORD PTR _pTarget$225215[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget

; 1152 : 
; 1153 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@PlotMobile
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN3@PlotMobile

; 1154 : 					{
; 1155 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225219[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1156 : 						strLogString.Format("Moving to mobile reserve muster pt, X: %d, Y: %d", m_TargetedHomelandRoads[iI].GetTargetX(), m_TargetedHomelandRoads[iI].GetTargetY());

	mov	eax, DWORD PTR _iI$225211[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+2480]
	mov	DWORD PTR $T241904[ebp], eax
	mov	edx, DWORD PTR $T241904[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T241908[ebp], eax
	mov	ecx, DWORD PTR _iI$225211[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+2480]
	mov	DWORD PTR $T241912[ebp], ecx
	mov	eax, DWORD PTR $T241912[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241916[ebp], ecx
	mov	edx, DWORD PTR $T241908[ebp]
	push	edx
	mov	eax, DWORD PTR $T241916[ebp]
	push	eax
	push	OFFSET ??_C@_0DB@MEEFACDO@Moving?5to?5mobile?5reserve?5muster?5@
	lea	ecx, DWORD PTR _strLogString$225219[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 1157 : 						LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$225219[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1158 : 					}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$225219[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@PlotMobile:

; 1159 : 				}
; 1160 : 			}
; 1161 : 		}

	jmp	$LN5@PlotMobile
$LN8@PlotMobile:

; 1162 : 	}
; 1163 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strLogString$225219[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-144]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::PlotMobileReserveMoves
PUBLIC	??_C@_0DD@CCJEOMJA@Moving?5to?5sentry?5point?0?5X?3?5?$CFd?0?5Y@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0DD@CCJEOMJA@Moving?5to?5sentry?5point?0?5X?3?5?$CFd?0?5Y@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0DD@CCJEOMJA@Moving?5to?5sentry?5point?0?5X?3?5?$CFd?0?5Y@ DB 'Movi'
	DB	'ng to sentry point, X: %d, Y: %d, Priority: %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?PlotSentryMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotSentryMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotSentryMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotSentryMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotSentryMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv232 = -148						; size = 4
_this$ = -144						; size = 4
$T242060 = -140						; size = 4
$T242056 = -136						; size = 4
$T242052 = -132						; size = 4
$T242048 = -128						; size = 4
$T242044 = -124						; size = 4
$T242040 = -120						; size = 4
$T242032 = -116						; size = 4
$T242028 = -112						; size = 4
$T241994 = -108						; size = 4
$T241989 = -104						; size = 4
$T241985 = -97						; size = 1
$T241974 = -96						; size = 4
$T241970 = -89						; size = 1
_iMapY$242024 = -88					; size = 4
_iMapX$242023 = -84					; size = 4
$T241963 = -80						; size = 4
$T241959 = -76						; size = 4
$T241955 = -72						; size = 4
$T241951 = -68						; size = 4
$T241947 = -64						; size = 4
$T241943 = -60						; size = 4
$T241939 = -56						; size = 4
_strLogString$225234 = -52				; size = 28
__$ArrayPad$ = -24					; size = 4
_pTarget$225230 = -20					; size = 4
_iI$225225 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotSentryMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotSentryMoves, COMDAT
; _this$ = ecx

; 1167 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotSentryMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1168 : 	// Do we have any targets of this type?
; 1169 : 	if(!m_TargetedSentryPoints.empty())

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2428				; 0000097cH
	mov	DWORD PTR $T241939[ebp], eax
	mov	ecx, DWORD PTR $T241939[ebp]
	mov	edx, DWORD PTR $T241939[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	edx, al
	test	edx, edx
	jne	$LN8@PlotSentry

; 1170 : 	{
; 1171 : 		// Prioritize them (LATER)
; 1172 : 
; 1173 : 		// See how many moves of this type we can execute
; 1174 : 		for(unsigned int iI = 0; iI < m_TargetedSentryPoints.size(); iI++)

	mov	DWORD PTR _iI$225225[ebp], 0
	jmp	SHORT $LN6@PlotSentry
$LN5@PlotSentry:
	mov	eax, DWORD PTR _iI$225225[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$225225[ebp], eax
$LN6@PlotSentry:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2428				; 0000097cH
	mov	DWORD PTR $T241943[ebp], ecx
	mov	edx, DWORD PTR $T241943[ebp]
	mov	eax, DWORD PTR $T241943[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	cmp	DWORD PTR _iI$225225[ebp], eax
	jae	$LN8@PlotSentry

; 1175 : 		{
; 1176 : #ifndef AUI_PERF_LOGGING_FORMATTING_TWEAKS // Not needed because it's already covered by the general move performance log
; 1177 : 			AI_PERF_FORMAT("Homeland-perf.csv", ("PlotSentryMoves, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 1178 : #endif
; 1179 : 
; 1180 : 			CvPlot* pTarget = GC.getMap().plot(m_TargetedSentryPoints[iI].GetTargetX(), m_TargetedSentryPoints[iI].GetTargetY());

	mov	edx, DWORD PTR _iI$225225[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+2432]
	mov	DWORD PTR $T241947[ebp], edx
	mov	ecx, DWORD PTR $T241947[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T241951[ebp], edx
	mov	eax, DWORD PTR _iI$225225[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+2432]
	mov	DWORD PTR $T241955[ebp], eax
	mov	edx, DWORD PTR $T241955[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241959[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T241963[ebp], ecx
	cmp	DWORD PTR $T241959[ebp], -2147483647	; 80000001H
	je	SHORT $LN27@PlotSentry
	cmp	DWORD PTR $T241951[ebp], -2147483647	; 80000001H
	jne	SHORT $LN28@PlotSentry
$LN27@PlotSentry:
	mov	DWORD PTR _pTarget$225230[ebp], 0
	jmp	$LN29@PlotSentry
$LN28@PlotSentry:
	mov	edx, DWORD PTR $T241963[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T241970[ebp], al
	mov	ecx, DWORD PTR $T241963[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T241974[ebp], edx
	movzx	eax, BYTE PTR $T241970[ebp]
	test	eax, eax
	je	SHORT $LN40@PlotSentry
	cmp	DWORD PTR $T241959[ebp], 0
	jge	SHORT $LN39@PlotSentry
	mov	eax, DWORD PTR $T241959[ebp]
	cdq
	idiv	DWORD PTR $T241974[ebp]
	add	edx, DWORD PTR $T241974[ebp]
	mov	DWORD PTR _iMapX$242023[ebp], edx
	jmp	SHORT $LN41@PlotSentry
	jmp	SHORT $LN40@PlotSentry
$LN39@PlotSentry:
	mov	ecx, DWORD PTR $T241959[ebp]
	cmp	ecx, DWORD PTR $T241974[ebp]
	jl	SHORT $LN40@PlotSentry
	mov	eax, DWORD PTR $T241959[ebp]
	cdq
	idiv	DWORD PTR $T241974[ebp]
	mov	DWORD PTR _iMapX$242023[ebp], edx
	jmp	SHORT $LN41@PlotSentry
$LN40@PlotSentry:
	mov	edx, DWORD PTR $T241959[ebp]
	mov	DWORD PTR _iMapX$242023[ebp], edx
$LN41@PlotSentry:
	mov	eax, DWORD PTR $T241963[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T241985[ebp], cl
	mov	edx, DWORD PTR $T241963[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T241989[ebp], eax
	movzx	ecx, BYTE PTR $T241985[ebp]
	push	ecx
	mov	edx, DWORD PTR $T241989[ebp]
	push	edx
	mov	eax, DWORD PTR $T241951[ebp]
	push	eax
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$242024[ebp], eax
	mov	ecx, DWORD PTR _iMapY$242024[ebp]
	push	ecx
	mov	edx, DWORD PTR _iMapX$242023[ebp]
	push	edx
	mov	ecx, DWORD PTR $T241963[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN31@PlotSentry
	mov	eax, DWORD PTR $T241963[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T241994[ebp], ecx
	mov	edx, DWORD PTR _iMapY$242024[ebp]
	imul	edx, DWORD PTR $T241994[ebp]
	add	edx, DWORD PTR _iMapX$242023[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T241963[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv232[ebp], edx
	jmp	SHORT $LN32@PlotSentry
$LN31@PlotSentry:
	mov	DWORD PTR tv232[ebp], 0
$LN32@PlotSentry:
	mov	ecx, DWORD PTR tv232[ebp]
	mov	DWORD PTR _pTarget$225230[ebp], ecx
$LN29@PlotSentry:

; 1181 : 
; 1182 : 			FindUnitsForThisMove(AI_HOMELAND_MOVE_SENTRY, (iI == 0)/*bFirstTime*/);

	cmp	DWORD PTR _iI$225225[ebp], 0
	sete	dl
	movzx	eax, dl
	push	eax
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z ; CvHomelandAI::FindUnitsForThisMove

; 1183 : 
; 1184 : 			if(m_CurrentMoveHighPriorityUnits.size() + m_CurrentMoveUnits.size() > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1060]
	mov	DWORD PTR $T242028[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T242032[ebp], ecx
	mov	edx, DWORD PTR $T242028[ebp]
	add	edx, DWORD PTR $T242032[ebp]
	je	$LN3@PlotSentry

; 1185 : 			{
; 1186 : 				if(GetBestUnitToReachTarget(pTarget, MAX_INT))

	push	2147483647				; 7fffffffH
	mov	eax, DWORD PTR _pTarget$225230[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z ; CvHomelandAI::GetBestUnitToReachTarget
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@PlotSentry

; 1187 : 				{
; 1188 : 					ExecuteMoveToTarget(pTarget);

	mov	edx, DWORD PTR _pTarget$225230[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget

; 1189 : 
; 1190 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN3@PlotSentry
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@PlotSentry

; 1191 : 					{
; 1192 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225234[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1193 : 						strLogString.Format("Moving to sentry point, X: %d, Y: %d, Priority: %d", m_TargetedSentryPoints[iI].GetTargetX(), m_TargetedSentryPoints[iI].GetTargetY(), m_TargetedSentryPoints[iI].GetAuxIntData());

	mov	edx, DWORD PTR _iI$225225[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+2432]
	mov	DWORD PTR $T242040[ebp], edx
	mov	ecx, DWORD PTR $T242040[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T242044[ebp], edx
	mov	eax, DWORD PTR _iI$225225[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+2432]
	mov	DWORD PTR $T242048[ebp], eax
	mov	edx, DWORD PTR $T242048[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T242052[ebp], eax
	mov	ecx, DWORD PTR _iI$225225[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+2432]
	mov	DWORD PTR $T242056[ebp], ecx
	mov	eax, DWORD PTR $T242056[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T242060[ebp], ecx
	mov	edx, DWORD PTR $T242044[ebp]
	push	edx
	mov	eax, DWORD PTR $T242052[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242060[ebp]
	push	ecx
	push	OFFSET ??_C@_0DD@CCJEOMJA@Moving?5to?5sentry?5point?0?5X?3?5?$CFd?0?5Y@
	lea	edx, DWORD PTR _strLogString$225234[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 1194 : 						LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$225234[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1195 : 					}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$225234[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@PlotSentry:

; 1196 : 				}
; 1197 : 			}
; 1198 : 		}

	jmp	$LN5@PlotSentry
$LN8@PlotSentry:

; 1199 : 	}
; 1200 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotSentryMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strLogString$225234[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotSentryMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-140]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotSentryMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotSentryMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotSentryMoves
PUBLIC	?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteWorkerMoves
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotWorkerMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotWorkerMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotWorkerMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotWorkerMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotWorkerMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -100						; size = 4
$T242216 = -96						; size = 4
$T242193 = -88						; size = 4
$T242184 = -84						; size = 4
$T242180 = -80						; size = 4
$T242176 = -76						; size = 4
$T242172 = -72						; size = 4
$T242168 = -68						; size = 4
$T242161 = -64						; size = 4
$T242151 = -60						; size = 4
$T242121 = -56						; size = 4
$T242088 = -52						; size = 4
$T242079 = -48						; size = 4
$T242073 = -44						; size = 4
_unit$225253 = -40					; size = 16
_pUnit$225249 = -24					; size = 8
_it$225243 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotWorkerMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotWorkerMoves, COMDAT
; _this$ = ecx

; 1204 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotWorkerMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1205 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 1206 : 
; 1207 : 	// Loop through all recruited units
; 1208 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T242079[ebp], ecx
	mov	edx, DWORD PTR $T242079[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T242088[ebp], eax
	mov	ecx, DWORD PTR $T242088[ebp]
	mov	DWORD PTR _it$225243[ebp], ecx
	jmp	SHORT $LN7@PlotWorker
$LN23@PlotWorker:
	mov	edx, DWORD PTR _it$225243[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225243[ebp], eax
$LN7@PlotWorker:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T242121[ebp], edx
	mov	eax, DWORD PTR $T242121[ebp]
	mov	DWORD PTR $T242073[ebp], eax
	mov	ecx, DWORD PTR _it$225243[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T242073[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@PlotWorker

; 1209 : 	{
; 1210 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225243[ebp]
	add	edx, 8
	mov	DWORD PTR $T242151[ebp], edx
	mov	eax, DWORD PTR $T242151[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T242161[ebp], eax
	mov	eax, DWORD PTR $T242161[ebp]
	mov	DWORD PTR _pUnit$225249[ebp], eax
	mov	BYTE PTR _pUnit$225249[ebp+4], 0
	cmp	DWORD PTR _pUnit$225249[ebp], 0
	je	SHORT $LN42@PlotWorker
	mov	ecx, DWORD PTR _pUnit$225249[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN42@PlotWorker:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1211 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225249[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@PlotWorker

; 1212 : 		{
; 1213 : 			if(pUnit->AI_getUnitAIType() == UNITAI_WORKER  ||
; 1214 : #ifdef AI_WORKER_EMBARKED_FIX
; 1215 : 				(pUnit->IsAutomated() && (pUnit->getDomainType() == DOMAIN_LAND && (pUnit->getUnitInfo().GetUnitAIType(UNITAI_WORKER) || pUnit->getUnitInfo().GetUnitAIType(UNITAI_WORKER_SEA)) && pUnit->GetAutomateType() == AUTOMATE_BUILD)))
; 1216 : #else
; 1217 : 			        pUnit->IsAutomated() && pUnit->getDomainType() == DOMAIN_LAND && pUnit->GetAutomateType() == AUTOMATE_BUILD)

	mov	eax, DWORD PTR _pUnit$225249[ebp]
	mov	DWORD PTR $T242168[ebp], eax
	mov	ecx, DWORD PTR $T242168[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 2
	je	SHORT $LN2@PlotWorker
	mov	ecx, DWORD PTR _pUnit$225249[ebp]
	mov	DWORD PTR $T242172[ebp], ecx
	mov	ecx, DWORD PTR $T242172[ebp]
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@PlotWorker
	mov	eax, DWORD PTR _pUnit$225249[ebp]
	mov	DWORD PTR $T242176[ebp], eax
	mov	ecx, DWORD PTR $T242176[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN4@PlotWorker
	mov	ecx, DWORD PTR _pUnit$225249[ebp]
	mov	DWORD PTR $T242180[ebp], ecx
	mov	ecx, DWORD PTR $T242180[ebp]
	call	?GetAutomateType@CvUnit@@QBE?AW4AutomateTypes@@XZ ; CvUnit::GetAutomateType
	test	eax, eax
	jne	SHORT $LN4@PlotWorker
$LN2@PlotWorker:

; 1218 : #endif
; 1219 : 			{
; 1220 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225253[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 1221 : 				unit.SetID(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$225249[ebp]
	mov	DWORD PTR $T242184[ebp], edx
	mov	eax, DWORD PTR $T242184[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T242193[ebp], ecx
	mov	edx, DWORD PTR $T242193[ebp]
	mov	DWORD PTR _unit$225253[ebp], edx

; 1222 : 				m_CurrentMoveUnits.push_back(unit);

	lea	eax, DWORD PTR _unit$225253[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN4@PlotWorker:

; 1223 : 			}
; 1224 : 		}
; 1225 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225249[ebp], 0
	je	SHORT $LN72@PlotWorker
	mov	ecx, DWORD PTR _pUnit$225249[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN72@PlotWorker:
	jmp	$LN23@PlotWorker
$LN5@PlotWorker:

; 1226 : 
; 1227 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T242216[ebp], edx
	cmp	DWORD PTR $T242216[ebp], 0
	jbe	SHORT $LN8@PlotWorker

; 1228 : 	{
; 1229 : 		ExecuteWorkerMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteWorkerMoves
$LN8@PlotWorker:

; 1230 : #ifdef AUI_HOMELAND_PLOT_WORKER_MOVES_ALSO_PLOTS_WORKER_DEFENSE
; 1231 : 		FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL > tempList = m_CurrentMoveUnits;
; 1232 : 		for (FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it = tempList.begin(); it != tempList.end(); ++it)
; 1233 : 		{
; 1234 : 			CvUnit* pTargetWorker = m_pPlayer->getUnit(it->GetID());
; 1235 : 
; 1236 : 			if (pTargetWorker && !pTargetWorker->IsCombatUnit() && !pTargetWorker->isDelayedDeath() && !pTargetWorker->IsDead())
; 1237 : 			{
; 1238 : 				CvPlot* pTargetPlot = pTargetWorker->plot();
; 1239 : 				// Grab units that make sense for this move type
; 1240 : 				FindUnitsForThisMove(AI_HOMELAND_MOVE_UNASSIGNED /*Special override for selecting combat units*/, (it == tempList.begin())/*bFirstTime*/);
; 1241 : 
; 1242 : 				if (m_CurrentMoveHighPriorityUnits.size() + m_CurrentMoveUnits.size() > 0)
; 1243 : 				{
; 1244 : 					if (GetBestUnitToReachTarget(pTargetPlot, 1))
; 1245 : 					{
; 1246 : 						ExecuteMoveToTarget(pTargetPlot);
; 1247 : 
; 1248 : 						if (GC.getLogging() && GC.getAILogging())
; 1249 : 						{
; 1250 : 							CvString strLogString;
; 1251 : 							strLogString.Format("Moving to protect worker, X: %d, Y: %d", pTargetPlot->getX(), pTargetPlot->getY());
; 1252 : 							LogHomelandMessage(strLogString);
; 1253 : 						}
; 1254 : 					}
; 1255 : 				}
; 1256 : 			}
; 1257 : 		}
; 1258 : #endif
; 1259 : 	}
; 1260 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotWorkerMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225249[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotWorkerMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotWorkerMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotWorkerMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotWorkerMoves
PUBLIC	??_C@_0CO@FLEDAGPK@Moving?5toward?5naval?5resource?5at?0@ ; `string'
PUBLIC	??_C@_0CL@CNDMMAEB@Harvesting?5naval?5resource?5at?0?5X?3@ ; `string'
PUBLIC	?UnitProcessed@CvHomelandAI@@AAEXH@Z		; CvHomelandAI::UnitProcessed
PUBLIC	__$ArrayPad$
EXTRN	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_BUILD
EXTRN	?GetLengthMissionQueue@CvUnit@@QBEHXZ:PROC	; CvUnit::GetLengthMissionQueue
EXTRN	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_MOVE_TO
EXTRN	?UnitPathTo@CvUnit@@QAEHHHHH_N@Z:PROC		; CvUnit::UnitPathTo
EXTRN	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z:PROC ; TurnsToReachTarget
EXTRN	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z:PROC ; CvUnit::canBuild
;	COMDAT ??_C@_0CO@FLEDAGPK@Moving?5toward?5naval?5resource?5at?0@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0CO@FLEDAGPK@Moving?5toward?5naval?5resource?5at?0@ DB 'Moving towa'
	DB	'rd naval resource at, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@CNDMMAEB@Harvesting?5naval?5resource?5at?0?5X?3@
CONST	SEGMENT
??_C@_0CL@CNDMMAEB@Harvesting?5naval?5resource?5at?0?5X?3@ DB 'Harvesting'
	DB	' naval resource at, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ$4
__ehfuncinfo$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv616 = -460						; size = 4
tv625 = -456						; size = 4
tv432 = -452						; size = 4
tv431 = -448						; size = 4
tv550 = -444						; size = 4
tv559 = -440						; size = 4
_this$ = -436						; size = 4
$T242712 = -432						; size = 4
$T242708 = -428						; size = 4
$T242704 = -424						; size = 4
$T242700 = -420						; size = 4
$T242688 = -416						; size = 4
$T242684 = -412						; size = 4
$T242680 = -408						; size = 4
$T242676 = -404						; size = 4
$T242668 = -400						; size = 4
$T242664 = -396						; size = 4
$T242660 = -392						; size = 4
$T242656 = -388						; size = 4
$T242652 = -384						; size = 4
$T242648 = -380						; size = 4
$T242644 = -376						; size = 4
$T242637 = -372						; size = 4
$T242633 = -368						; size = 4
$T242629 = -364						; size = 4
$T242625 = -360						; size = 4
$T242621 = -356						; size = 4
$T242617 = -352						; size = 4
$T242613 = -348						; size = 4
$T242577 = -344						; size = 4
$T242564 = -340						; size = 4
$T242560 = -336						; size = 4
$T242553 = -332						; size = 4
$T242549 = -325						; size = 1
$T242545 = -324						; size = 4
$T242541 = -317						; size = 1
_iMapY$242586 = -316					; size = 4
_iMapX$242585 = -312					; size = 4
$T242534 = -308						; size = 4
$T242527 = -304						; size = 4
$T242520 = -300						; size = 4
$T242516 = -296						; size = 4
$T242506 = -292						; size = 4
$T242502 = -288						; size = 4
$T242498 = -284						; size = 4
$T242494 = -280						; size = 4
$T242458 = -276						; size = 4
$T242445 = -272						; size = 4
$T242441 = -268						; size = 4
$T242434 = -264						; size = 4
$T242430 = -257						; size = 1
$T242426 = -256						; size = 4
$T242422 = -249						; size = 1
_iMapY$242467 = -248					; size = 4
_iMapX$242466 = -244					; size = 4
$T242415 = -240						; size = 4
$T242411 = -236						; size = 4
$T242407 = -232						; size = 4
$T242403 = -228						; size = 4
$T242399 = -224						; size = 4
$T242395 = -220						; size = 4
$T242391 = -216						; size = 4
$T242381 = -212						; size = 4
$T242377 = -208						; size = 4
$T242351 = -200						; size = 4
$T242342 = -196						; size = 4
$T242338 = -192						; size = 4
$T242334 = -188						; size = 4
$T242330 = -184						; size = 4
$T242326 = -180						; size = 4
$T242319 = -176						; size = 4
$T242309 = -172						; size = 4
$T242279 = -168						; size = 4
$T242246 = -164						; size = 4
$T242237 = -160						; size = 4
$T242227 = -156						; size = 4
$T242226 = -152						; size = 4
_strLogString$225307 = -148				; size = 28
_strLogString$225303 = -120				; size = 28
__$ArrayPad$ = -92					; size = 4
_iTargetX$225292 = -88					; size = 4
_pTarget$225294 = -84					; size = 4
_bResult$225295 = -77					; size = 1
_iTargetY$225293 = -76					; size = 4
_pTarget$225285 = -72					; size = 4
_iMoves$225288 = -68					; size = 4
_iI$225281 = -64					; size = 4
_pUnit$225278 = -60					; size = 8
_iTargetMoves$225280 = -52				; size = 4
_iTargetIndex$225279 = -48				; size = 4
_unit$225272 = -44					; size = 16
_pUnit$225268 = -28					; size = 8
_it$225262 = -20					; size = 4
_moveUnitIt$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotWorkerSeaMoves, COMDAT
; _this$ = ecx

; 1264 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 448				; 000001c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1265 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 1266 : 	// Loop through all recruited units
; 1267 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T242237[ebp], ecx
	mov	edx, DWORD PTR $T242237[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T242246[ebp], eax
	mov	ecx, DWORD PTR $T242246[ebp]
	mov	DWORD PTR _it$225262[ebp], ecx
	jmp	SHORT $LN24@PlotWorker@2
$LN44@PlotWorker@2:
	mov	edx, DWORD PTR _it$225262[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225262[ebp], eax
$LN24@PlotWorker@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T242279[ebp], edx
	mov	eax, DWORD PTR $T242279[ebp]
	mov	DWORD PTR $T242226[ebp], eax
	mov	ecx, DWORD PTR _it$225262[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T242226[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN22@PlotWorker@2

; 1268 : 	{
; 1269 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225262[ebp]
	add	edx, 8
	mov	DWORD PTR $T242309[ebp], edx
	mov	eax, DWORD PTR $T242309[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T242319[ebp], eax
	mov	eax, DWORD PTR $T242319[ebp]
	mov	DWORD PTR _pUnit$225268[ebp], eax
	mov	BYTE PTR _pUnit$225268[ebp+4], 0
	cmp	DWORD PTR _pUnit$225268[ebp], 0
	je	SHORT $LN63@PlotWorker@2
	mov	ecx, DWORD PTR _pUnit$225268[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN63@PlotWorker@2:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1270 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225268[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN21@PlotWorker@2

; 1271 : 		{
; 1272 : 			if(pUnit->AI_getUnitAIType() == UNITAI_WORKER_SEA  ||
; 1273 : #ifdef AUI_WARNING_FIXES
; 1274 : 				(pUnit->IsAutomated() && pUnit->getDomainType() == DOMAIN_SEA && pUnit->GetAutomateType() == AUTOMATE_BUILD))
; 1275 : #else
; 1276 : #ifdef AI_WORKER_EMBARKED_FIX
; 1277 : 				(pUnit->IsAutomated() && pUnit->getDomainType() == DOMAIN_SEA && pUnit->GetAutomateType() == AUTOMATE_BUILD))
; 1278 : 				
; 1279 : #else
; 1280 : 				(pUnit->IsAutomated() && pUnit->getDomainType() == DOMAIN_SEA && pUnit->GetAutomateType() == AUTOMATE_BUILD))

	mov	eax, DWORD PTR _pUnit$225268[ebp]
	mov	DWORD PTR $T242326[ebp], eax
	mov	ecx, DWORD PTR $T242326[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 17					; 00000011H
	je	SHORT $LN19@PlotWorker@2
	mov	ecx, DWORD PTR _pUnit$225268[ebp]
	mov	DWORD PTR $T242330[ebp], ecx
	mov	ecx, DWORD PTR $T242330[ebp]
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN21@PlotWorker@2
	mov	eax, DWORD PTR _pUnit$225268[ebp]
	mov	DWORD PTR $T242334[ebp], eax
	mov	ecx, DWORD PTR $T242334[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN21@PlotWorker@2
	mov	ecx, DWORD PTR _pUnit$225268[ebp]
	mov	DWORD PTR $T242338[ebp], ecx
	mov	ecx, DWORD PTR $T242338[ebp]
	call	?GetAutomateType@CvUnit@@QBE?AW4AutomateTypes@@XZ ; CvUnit::GetAutomateType
	test	eax, eax
	jne	SHORT $LN21@PlotWorker@2
$LN19@PlotWorker@2:

; 1281 : #endif
; 1282 : #endif
; 1283 : 			{
; 1284 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225272[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 1285 : 				unit.SetID(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$225268[ebp]
	mov	DWORD PTR $T242342[ebp], edx
	mov	eax, DWORD PTR $T242342[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T242351[ebp], ecx
	mov	edx, DWORD PTR $T242351[ebp]
	mov	DWORD PTR _unit$225272[ebp], edx

; 1286 : 				m_CurrentMoveUnits.push_back(unit);

	lea	eax, DWORD PTR _unit$225272[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN21@PlotWorker@2:

; 1287 : 			}
; 1288 : 		}
; 1289 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225268[ebp], 0
	je	SHORT $LN93@PlotWorker@2
	mov	ecx, DWORD PTR _pUnit$225268[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN93@PlotWorker@2:
	jmp	$LN44@PlotWorker@2
$LN22@PlotWorker@2:

; 1290 : 
; 1291 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator moveUnitIt;
; 1292 : 	for(moveUnitIt = m_CurrentMoveUnits.begin(); moveUnitIt != m_CurrentMoveUnits.end(); ++moveUnitIt)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _moveUnitIt$[ebp], edx
	jmp	SHORT $LN18@PlotWorker@2
$LN17@PlotWorker@2:
	mov	eax, DWORD PTR _moveUnitIt$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _moveUnitIt$[ebp], eax
$LN18@PlotWorker@2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T242377[ebp], ecx
	mov	edx, DWORD PTR $T242377[ebp]
	mov	eax, DWORD PTR [edx+4]
	shl	eax, 4
	mov	ecx, DWORD PTR $T242377[ebp]
	add	eax, DWORD PTR [ecx]
	cmp	DWORD PTR _moveUnitIt$[ebp], eax
	je	$LN25@PlotWorker@2

; 1293 : 	{
; 1294 : 		UnitHandle pUnit = m_pPlayer->getUnit(moveUnitIt->GetID());

	mov	edx, DWORD PTR _moveUnitIt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T242381[ebp], eax
	mov	ecx, DWORD PTR $T242381[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T242391[ebp], eax
	mov	eax, DWORD PTR $T242391[ebp]
	mov	DWORD PTR _pUnit$225278[ebp], eax
	mov	BYTE PTR _pUnit$225278[ebp+4], 0
	cmp	DWORD PTR _pUnit$225278[ebp], 0
	je	SHORT $LN104@PlotWorker@2
	mov	ecx, DWORD PTR _pUnit$225278[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN104@PlotWorker@2:
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1295 : 		int iTargetIndex = -1;

	mov	DWORD PTR _iTargetIndex$225279[ebp], -1

; 1296 : 		int iTargetMoves = MAX_INT;

	mov	DWORD PTR _iTargetMoves$225280[ebp], 2147483647 ; 7fffffffH

; 1297 : 
; 1298 : 		// See how many moves of this type we can execute
; 1299 : 		for (unsigned int iI = 0; iI < m_TargetedNavalResources.size(); iI++)

	mov	DWORD PTR _iI$225281[ebp], 0
	jmp	SHORT $LN15@PlotWorker@2
$LN14@PlotWorker@2:
	mov	ecx, DWORD PTR _iI$225281[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$225281[ebp], ecx
$LN15@PlotWorker@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2460				; 0000099cH
	mov	DWORD PTR $T242395[ebp], edx
	mov	eax, DWORD PTR $T242395[ebp]
	mov	ecx, DWORD PTR $T242395[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	cmp	DWORD PTR _iI$225281[ebp], eax
	jae	$LN13@PlotWorker@2

; 1300 : 		{
; 1301 : 			// See what units we have who can reach target this turn
; 1302 : 			CvPlot* pTarget = GC.getMap().plot(m_TargetedNavalResources[iI].GetTargetX(), m_TargetedNavalResources[iI].GetTargetY());

	mov	edx, DWORD PTR _iI$225281[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+2464]
	mov	DWORD PTR $T242399[ebp], edx
	mov	ecx, DWORD PTR $T242399[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T242403[ebp], edx
	mov	eax, DWORD PTR _iI$225281[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+2464]
	mov	DWORD PTR $T242407[ebp], eax
	mov	edx, DWORD PTR $T242407[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T242411[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T242415[ebp], ecx
	cmp	DWORD PTR $T242411[ebp], -2147483647	; 80000001H
	je	SHORT $LN120@PlotWorker@2
	cmp	DWORD PTR $T242403[ebp], -2147483647	; 80000001H
	jne	SHORT $LN121@PlotWorker@2
$LN120@PlotWorker@2:
	mov	DWORD PTR _pTarget$225285[ebp], 0
	jmp	$LN122@PlotWorker@2
$LN121@PlotWorker@2:
	mov	edx, DWORD PTR $T242415[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T242422[ebp], al
	mov	ecx, DWORD PTR $T242415[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T242426[ebp], edx
	movzx	eax, BYTE PTR $T242422[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242426[ebp]
	push	ecx
	mov	edx, DWORD PTR $T242411[ebp]
	push	edx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapX$242466[ebp], eax
	mov	eax, DWORD PTR $T242415[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T242430[ebp], cl
	mov	edx, DWORD PTR $T242415[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T242434[ebp], eax
	movzx	ecx, BYTE PTR $T242430[ebp]
	push	ecx
	mov	edx, DWORD PTR $T242434[ebp]
	push	edx
	mov	eax, DWORD PTR $T242403[ebp]
	push	eax
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$242467[ebp], eax
	cmp	DWORD PTR _iMapX$242466[ebp], 0
	jl	SHORT $LN136@PlotWorker@2
	mov	ecx, DWORD PTR $T242415[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T242441[ebp], edx
	mov	eax, DWORD PTR _iMapX$242466[ebp]
	cmp	eax, DWORD PTR $T242441[ebp]
	jge	SHORT $LN136@PlotWorker@2
	cmp	DWORD PTR _iMapY$242467[ebp], 0
	jl	SHORT $LN136@PlotWorker@2
	mov	ecx, DWORD PTR $T242415[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T242445[ebp], edx
	mov	eax, DWORD PTR _iMapY$242467[ebp]
	cmp	eax, DWORD PTR $T242445[ebp]
	jge	SHORT $LN136@PlotWorker@2
	mov	DWORD PTR tv559[ebp], 1
	jmp	SHORT $LN134@PlotWorker@2
$LN136@PlotWorker@2:
	mov	DWORD PTR tv559[ebp], 0
$LN134@PlotWorker@2:
	cmp	DWORD PTR tv559[ebp], 0
	je	SHORT $LN124@PlotWorker@2
	mov	ecx, DWORD PTR $T242415[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T242458[ebp], edx
	mov	eax, DWORD PTR _iMapY$242467[ebp]
	imul	eax, DWORD PTR $T242458[ebp]
	add	eax, DWORD PTR _iMapX$242466[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T242415[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv550[ebp], eax
	jmp	SHORT $LN125@PlotWorker@2
$LN124@PlotWorker@2:
	mov	DWORD PTR tv550[ebp], 0
$LN125@PlotWorker@2:
	mov	edx, DWORD PTR tv550[ebp]
	mov	DWORD PTR _pTarget$225285[ebp], edx
$LN122@PlotWorker@2:

; 1303 : 
; 1304 : 			if (!pUnit->canBuild(pTarget, (BuildTypes)m_TargetedNavalResources[iI].GetAuxIntData()))

	mov	eax, DWORD PTR _iI$225281[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+2464]
	mov	DWORD PTR $T242494[ebp], eax
	mov	edx, DWORD PTR $T242494[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR $T242498[ebp], eax
	mov	ecx, DWORD PTR _pUnit$225278[ebp]
	mov	DWORD PTR $T242502[ebp], ecx
	push	1
	push	0
	mov	edx, DWORD PTR $T242498[ebp]
	push	edx
	mov	eax, DWORD PTR _pTarget$225285[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242502[ebp]
	call	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z ; CvUnit::canBuild
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN12@PlotWorker@2

; 1305 : 			{
; 1306 : 				continue;

	jmp	$LN14@PlotWorker@2
$LN12@PlotWorker@2:

; 1307 : 			}
; 1308 : 
; 1309 : 			int iMoves = TurnsToReachTarget(pUnit.pointer(), pTarget);

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _pTarget$225285[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$225278[ebp]
	mov	DWORD PTR $T242506[ebp], eax
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T242227[ebp], esp
	mov	DWORD PTR $T242516[ebp], ecx
	mov	edx, DWORD PTR $T242516[ebp]
	mov	eax, DWORD PTR $T242506[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T242516[ebp]
	mov	BYTE PTR [ecx+4], 0
	mov	edx, DWORD PTR $T242516[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN155@PlotWorker@2
	mov	eax, DWORD PTR $T242516[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN155@PlotWorker@2:
	mov	ecx, DWORD PTR $T242516[ebp]
	mov	DWORD PTR tv431[ebp], ecx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv432[ebp], eax
	mov	edx, DWORD PTR tv432[ebp]
	mov	DWORD PTR _iMoves$225288[ebp], edx

; 1310 : 			if (iMoves < iTargetMoves)

	mov	eax, DWORD PTR _iMoves$225288[ebp]
	cmp	eax, DWORD PTR _iTargetMoves$225280[ebp]
	jge	SHORT $LN11@PlotWorker@2

; 1311 : 			{
; 1312 : 				iTargetMoves = iMoves;

	mov	ecx, DWORD PTR _iMoves$225288[ebp]
	mov	DWORD PTR _iTargetMoves$225280[ebp], ecx

; 1313 : 				iTargetIndex = iI;

	mov	edx, DWORD PTR _iI$225281[ebp]
	mov	DWORD PTR _iTargetIndex$225279[ebp], edx
$LN11@PlotWorker@2:

; 1314 : 			}
; 1315 : 		}

	jmp	$LN14@PlotWorker@2
$LN13@PlotWorker@2:

; 1316 : 
; 1317 : 		if (iTargetIndex != -1)

	cmp	DWORD PTR _iTargetIndex$225279[ebp], -1
	je	$LN10@PlotWorker@2

; 1318 : 		{
; 1319 : 			// Queue best one up to capture it
; 1320 : 			int iTargetX = m_TargetedNavalResources[iTargetIndex].GetTargetX();

	mov	eax, DWORD PTR _iTargetIndex$225279[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+2464]
	mov	DWORD PTR $T242520[ebp], eax
	mov	edx, DWORD PTR $T242520[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _iTargetX$225292[ebp], eax

; 1321 : 			int iTargetY = m_TargetedNavalResources[iTargetIndex].GetTargetY();

	mov	ecx, DWORD PTR _iTargetIndex$225279[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+2464]
	mov	DWORD PTR $T242527[ebp], ecx
	mov	eax, DWORD PTR $T242527[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _iTargetY$225293[ebp], ecx

; 1322 : 			CvPlot* pTarget = GC.getMap().plot(iTargetX, iTargetY);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T242534[ebp], edx
	cmp	DWORD PTR _iTargetX$225292[ebp], -2147483647 ; 80000001H
	je	SHORT $LN169@PlotWorker@2
	cmp	DWORD PTR _iTargetY$225293[ebp], -2147483647 ; 80000001H
	jne	SHORT $LN170@PlotWorker@2
$LN169@PlotWorker@2:
	mov	DWORD PTR _pTarget$225294[ebp], 0
	jmp	$LN171@PlotWorker@2
$LN170@PlotWorker@2:
	mov	eax, DWORD PTR $T242534[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T242541[ebp], cl
	mov	edx, DWORD PTR $T242534[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T242545[ebp], eax
	movzx	ecx, BYTE PTR $T242541[ebp]
	push	ecx
	mov	edx, DWORD PTR $T242545[ebp]
	push	edx
	mov	eax, DWORD PTR _iTargetX$225292[ebp]
	push	eax
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapX$242585[ebp], eax
	mov	ecx, DWORD PTR $T242534[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T242549[ebp], dl
	mov	eax, DWORD PTR $T242534[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T242553[ebp], ecx
	movzx	edx, BYTE PTR $T242549[ebp]
	push	edx
	mov	eax, DWORD PTR $T242553[ebp]
	push	eax
	mov	ecx, DWORD PTR _iTargetY$225293[ebp]
	push	ecx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$242586[ebp], eax
	cmp	DWORD PTR _iMapX$242585[ebp], 0
	jl	SHORT $LN185@PlotWorker@2
	mov	edx, DWORD PTR $T242534[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T242560[ebp], eax
	mov	ecx, DWORD PTR _iMapX$242585[ebp]
	cmp	ecx, DWORD PTR $T242560[ebp]
	jge	SHORT $LN185@PlotWorker@2
	cmp	DWORD PTR _iMapY$242586[ebp], 0
	jl	SHORT $LN185@PlotWorker@2
	mov	edx, DWORD PTR $T242534[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T242564[ebp], eax
	mov	ecx, DWORD PTR _iMapY$242586[ebp]
	cmp	ecx, DWORD PTR $T242564[ebp]
	jge	SHORT $LN185@PlotWorker@2
	mov	DWORD PTR tv625[ebp], 1
	jmp	SHORT $LN183@PlotWorker@2
$LN185@PlotWorker@2:
	mov	DWORD PTR tv625[ebp], 0
$LN183@PlotWorker@2:
	cmp	DWORD PTR tv625[ebp], 0
	je	SHORT $LN173@PlotWorker@2
	mov	edx, DWORD PTR $T242534[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T242577[ebp], eax
	mov	ecx, DWORD PTR _iMapY$242586[ebp]
	imul	ecx, DWORD PTR $T242577[ebp]
	add	ecx, DWORD PTR _iMapX$242585[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T242534[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv616[ebp], ecx
	jmp	SHORT $LN174@PlotWorker@2
$LN173@PlotWorker@2:
	mov	DWORD PTR tv616[ebp], 0
$LN174@PlotWorker@2:
	mov	eax, DWORD PTR tv616[ebp]
	mov	DWORD PTR _pTarget$225294[ebp], eax
$LN171@PlotWorker@2:

; 1323 : 
; 1324 : 			bool bResult = false;

	mov	BYTE PTR _bResult$225295[ebp], 0

; 1325 : 			if(pUnit->UnitPathTo(iTargetX, iTargetY, 0) > 0)

	mov	ecx, DWORD PTR _pUnit$225278[ebp]
	mov	DWORD PTR $T242613[ebp], ecx
	push	0
	push	-1
	push	0
	mov	edx, DWORD PTR _iTargetY$225293[ebp]
	push	edx
	mov	eax, DWORD PTR _iTargetX$225292[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242613[ebp]
	call	?UnitPathTo@CvUnit@@QAEHHHHH_N@Z	; CvUnit::UnitPathTo
	test	eax, eax
	jle	$LN9@PlotWorker@2

; 1326 : 			{
; 1327 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), iTargetX, iTargetY);

	mov	ecx, DWORD PTR _pUnit$225278[ebp]
	mov	DWORD PTR $T242617[ebp], ecx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _iTargetY$225293[ebp]
	push	edx
	mov	eax, DWORD PTR _iTargetX$225292[ebp]
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T242617[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 1328 : 				if(pUnit->plot() == pTarget)

	mov	ecx, DWORD PTR _pUnit$225278[ebp]
	mov	DWORD PTR $T242621[ebp], ecx
	mov	ecx, DWORD PTR $T242621[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pTarget$225294[ebp]
	jne	SHORT $LN209@PlotWorker@2

; 1329 : 				{
; 1330 : 					pUnit->PushMission(CvTypes::getMISSION_BUILD(), m_TargetedNavalResources[iTargetIndex].GetAuxIntData(), -1, 0, (pUnit->GetLengthMissionQueue() > 0), false, MISSIONAI_BUILD, pTarget);

	mov	edx, DWORD PTR _pUnit$225278[ebp]
	mov	DWORD PTR $T242625[ebp], edx
	mov	eax, DWORD PTR _iTargetIndex$225279[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+2464]
	mov	DWORD PTR $T242629[ebp], eax
	mov	edx, DWORD PTR $T242629[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR $T242633[ebp], eax
	mov	ecx, DWORD PTR _pUnit$225278[ebp]
	mov	DWORD PTR $T242637[ebp], ecx
	push	0
	mov	edx, DWORD PTR _pTarget$225294[ebp]
	push	edx
	push	18					; 00000012H
	push	0
	mov	ecx, DWORD PTR $T242625[ebp]
	call	?GetLengthMissionQueue@CvUnit@@QBEHXZ	; CvUnit::GetLengthMissionQueue
	test	eax, eax
	setg	al
	movzx	ecx, al
	push	ecx
	push	0
	push	-1
	mov	edx, DWORD PTR $T242633[ebp]
	push	edx
	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	push	eax
	mov	ecx, DWORD PTR $T242637[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 1331 : 					bResult = true;

	mov	BYTE PTR _bResult$225295[ebp], 1

; 1332 : 				}
; 1333 : 				else

	jmp	SHORT $LN7@PlotWorker@2

; 1334 : 				{
; 1335 : 					pUnit->finishMoves();

$LN209@PlotWorker@2:
	mov	ecx, DWORD PTR _pUnit$225278[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN7@PlotWorker@2:

; 1336 : 				}
; 1337 : 
; 1338 : 				// Delete this unit from those we have to move
; 1339 : 				UnitProcessed(m_CurrentMoveUnits.begin()->GetID());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T242644[ebp], ecx
	mov	edx, DWORD PTR $T242644[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T242648[ebp], eax
	mov	ecx, DWORD PTR $T242648[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 1340 : 			}
; 1341 : 			else

	jmp	$LN6@PlotWorker@2
$LN9@PlotWorker@2:

; 1342 : 			{
; 1343 : 				if(pUnit->plot() == pTarget)

	mov	edx, DWORD PTR _pUnit$225278[ebp]
	mov	DWORD PTR $T242652[ebp], edx
	mov	ecx, DWORD PTR $T242652[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pTarget$225294[ebp]
	jne	SHORT $LN6@PlotWorker@2

; 1344 : 				{
; 1345 : 					pUnit->PushMission(CvTypes::getMISSION_BUILD(), m_TargetedNavalResources[iTargetIndex].GetAuxIntData(), -1, 0, (pUnit->GetLengthMissionQueue() > 0), false, MISSIONAI_BUILD, pTarget);

	mov	eax, DWORD PTR _pUnit$225278[ebp]
	mov	DWORD PTR $T242656[ebp], eax
	mov	ecx, DWORD PTR _iTargetIndex$225279[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+2464]
	mov	DWORD PTR $T242660[ebp], ecx
	mov	eax, DWORD PTR $T242660[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T242664[ebp], ecx
	mov	edx, DWORD PTR _pUnit$225278[ebp]
	mov	DWORD PTR $T242668[ebp], edx
	push	0
	mov	eax, DWORD PTR _pTarget$225294[ebp]
	push	eax
	push	18					; 00000012H
	push	0
	mov	ecx, DWORD PTR $T242656[ebp]
	call	?GetLengthMissionQueue@CvUnit@@QBEHXZ	; CvUnit::GetLengthMissionQueue
	test	eax, eax
	setg	cl
	movzx	edx, cl
	push	edx
	push	0
	push	-1
	mov	eax, DWORD PTR $T242664[ebp]
	push	eax
	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	push	eax
	mov	ecx, DWORD PTR $T242668[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 1346 : 					bResult = true;

	mov	BYTE PTR _bResult$225295[ebp], 1
$LN6@PlotWorker@2:

; 1347 : 				}
; 1348 : 			}
; 1349 : 		
; 1350 : 			if (bResult)

	movzx	ecx, BYTE PTR _bResult$225295[ebp]
	test	ecx, ecx
	je	$LN4@PlotWorker@2

; 1351 : 			{
; 1352 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN3@PlotWorker@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	$LN3@PlotWorker@2

; 1353 : 				{
; 1354 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225303[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1355 : 					strLogString.Format("Harvesting naval resource at, X: %d, Y: %d", m_TargetedNavalResources[iTargetIndex].GetTargetX(), m_TargetedNavalResources[iTargetIndex].GetTargetY());

	mov	ecx, DWORD PTR _iTargetIndex$225279[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+2464]
	mov	DWORD PTR $T242676[ebp], ecx
	mov	eax, DWORD PTR $T242676[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T242680[ebp], ecx
	mov	edx, DWORD PTR _iTargetIndex$225279[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+2464]
	mov	DWORD PTR $T242684[ebp], edx
	mov	ecx, DWORD PTR $T242684[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T242688[ebp], edx
	mov	eax, DWORD PTR $T242680[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242688[ebp]
	push	ecx
	push	OFFSET ??_C@_0CL@CNDMMAEB@Harvesting?5naval?5resource?5at?0?5X?3@
	lea	edx, DWORD PTR _strLogString$225303[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 1356 : 					LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$225303[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1357 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLogString$225303[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@PlotWorker@2:

; 1358 : 			}
; 1359 : 			else

	jmp	$LN10@PlotWorker@2
$LN4@PlotWorker@2:

; 1360 : 			{
; 1361 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN10@PlotWorker@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN10@PlotWorker@2

; 1362 : 				{
; 1363 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225307[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1364 : 					strLogString.Format("Moving toward naval resource at, X: %d, Y: %d", m_TargetedNavalResources[iTargetIndex].GetTargetX(), m_TargetedNavalResources[iTargetIndex].GetTargetY());

	mov	eax, DWORD PTR _iTargetIndex$225279[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+2464]
	mov	DWORD PTR $T242700[ebp], eax
	mov	edx, DWORD PTR $T242700[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T242704[ebp], eax
	mov	ecx, DWORD PTR _iTargetIndex$225279[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+2464]
	mov	DWORD PTR $T242708[ebp], ecx
	mov	eax, DWORD PTR $T242708[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T242712[ebp], ecx
	mov	edx, DWORD PTR $T242704[ebp]
	push	edx
	mov	eax, DWORD PTR $T242712[ebp]
	push	eax
	push	OFFSET ??_C@_0CO@FLEDAGPK@Moving?5toward?5naval?5resource?5at?0@
	lea	ecx, DWORD PTR _strLogString$225307[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 1365 : 					LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$225307[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1366 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLogString$225307[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN10@PlotWorker@2:

; 1367 : 			}
; 1368 : 		}
; 1369 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225278[ebp], 0
	je	SHORT $LN254@PlotWorker@2
	mov	ecx, DWORD PTR _pUnit$225278[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN254@PlotWorker@2:
	jmp	$LN17@PlotWorker@2
$LN25@PlotWorker@2:

; 1370 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225268[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _pUnit$225278[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strLogString$225303[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLogString$225307[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-452]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotWorkerSeaMoves
PUBLIC	?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecutePatrolMoves
PUBLIC	??_C@_0EC@CNCBKJIE@?$CFs?5?$CI?$CFd?$CJ?5patrolling?5to?0?5X?3?5?$CFd?0?5Y?3@ ; `string'
PUBLIC	?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z ; CvHomelandAI::FindPatrolTarget
PUBLIC	__$ArrayPad$
EXTRN	?isTrade@CvUnit@@QBE_NXZ:PROC			; CvUnit::isTrade
;	COMDAT ??_C@_0EC@CNCBKJIE@?$CFs?5?$CI?$CFd?$CJ?5patrolling?5to?0?5X?3?5?$CFd?0?5Y?3@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0EC@CNCBKJIE@?$CFs?5?$CI?$CFd?$CJ?5patrolling?5to?0?5X?3?5?$CFd?0?5Y?3@ DB '%'
	DB	's (%d) patrolling to, X: %d, Y: %d, Current X: %d, Current Y:'
	DB	' %d', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ$2
__ehfuncinfo$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotPatrolMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -208						; size = 4
$T242963 = -204						; size = 4
$T242939 = -200						; size = 4
$T242930 = -196						; size = 4
$T242926 = -192						; size = 4
$T242922 = -188						; size = 4
$T242918 = -184						; size = 4
$T242909 = -180						; size = 4
$T242905 = -176						; size = 4
$T242896 = -172						; size = 4
$T242892 = -168						; size = 4
$T242886 = -164						; size = 4
$T242882 = -160						; size = 4
$T242857 = -152						; size = 4
$T242848 = -148						; size = 4
$T242844 = -144						; size = 4
$T242840 = -140						; size = 4
$T242836 = -136						; size = 4
$T242832 = -132						; size = 4
$T242825 = -128						; size = 4
$T242815 = -124						; size = 4
$T242785 = -120						; size = 4
$T242752 = -116						; size = 4
$T242743 = -112						; size = 4
$T242735 = -108						; size = 4
_strLogString$225328 = -104				; size = 28
_strTemp$225329 = -76					; size = 28
__$ArrayPad$ = -48					; size = 4
_unit$225326 = -44					; size = 16
_pTarget$225324 = -28					; size = 4
_pUnit$225322 = -24					; size = 8
_it$225316 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotPatrolMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotPatrolMoves, COMDAT
; _this$ = ecx

; 1374 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 196				; 000000c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1375 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 1376 : 
; 1377 : 	// Loop through all remaining units
; 1378 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T242743[ebp], ecx
	mov	edx, DWORD PTR $T242743[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T242752[ebp], eax
	mov	ecx, DWORD PTR $T242752[ebp]
	mov	DWORD PTR _it$225316[ebp], ecx
	jmp	SHORT $LN7@PlotPatrol
$LN25@PlotPatrol:
	mov	edx, DWORD PTR _it$225316[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225316[ebp], eax
$LN7@PlotPatrol:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T242785[ebp], edx
	mov	eax, DWORD PTR $T242785[ebp]
	mov	DWORD PTR $T242735[ebp], eax
	mov	ecx, DWORD PTR _it$225316[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T242735[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@PlotPatrol

; 1379 : 	{
; 1380 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225316[ebp]
	add	edx, 8
	mov	DWORD PTR $T242815[ebp], edx
	mov	eax, DWORD PTR $T242815[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T242825[ebp], eax
	mov	eax, DWORD PTR $T242825[ebp]
	mov	DWORD PTR _pUnit$225322[ebp], eax
	mov	BYTE PTR _pUnit$225322[ebp+4], 0
	cmp	DWORD PTR _pUnit$225322[ebp], 0
	je	SHORT $LN44@PlotPatrol
	mov	ecx, DWORD PTR _pUnit$225322[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN44@PlotPatrol:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1381 : 		if(pUnit && !pUnit->isHuman() && pUnit->getDomainType() != DOMAIN_AIR && !pUnit->isTrade())

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225322[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN4@PlotPatrol
	mov	eax, DWORD PTR _pUnit$225322[ebp]
	mov	DWORD PTR $T242832[ebp], eax
	mov	ecx, DWORD PTR $T242832[ebp]
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN4@PlotPatrol
	mov	edx, DWORD PTR _pUnit$225322[ebp]
	mov	DWORD PTR $T242836[ebp], edx
	mov	ecx, DWORD PTR $T242836[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	je	$LN4@PlotPatrol
	mov	eax, DWORD PTR _pUnit$225322[ebp]
	mov	DWORD PTR $T242840[ebp], eax
	mov	ecx, DWORD PTR $T242840[ebp]
	call	?isTrade@CvUnit@@QBE_NXZ		; CvUnit::isTrade
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN4@PlotPatrol

; 1382 : 		{
; 1383 : #ifdef AUI_HOMELAND_FIND_PATROL_MOVES_CIVILIANS_PATROL_TO_SAFETY
; 1384 : 			if (!pUnit->IsCombatUnit())
; 1385 : 			{
; 1386 : 				MoveCivilianToSafety(pUnit.pointer());
; 1387 : 				continue;
; 1388 : 			}
; 1389 : #endif
; 1390 : 			CvPlot* pTarget = FindPatrolTarget(pUnit.pointer());

	mov	edx, DWORD PTR _pUnit$225322[ebp]
	mov	DWORD PTR $T242844[ebp], edx
	mov	eax, DWORD PTR $T242844[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z ; CvHomelandAI::FindPatrolTarget
	mov	DWORD PTR _pTarget$225324[ebp], eax

; 1391 : 			if(pTarget)

	cmp	DWORD PTR _pTarget$225324[ebp], 0
	je	$LN4@PlotPatrol

; 1392 : 			{
; 1393 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225326[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 1394 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225322[ebp]
	mov	DWORD PTR $T242848[ebp], ecx
	mov	edx, DWORD PTR $T242848[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T242857[ebp], eax
	mov	ecx, DWORD PTR $T242857[ebp]
	mov	DWORD PTR _unit$225326[ebp], ecx

; 1395 : 				unit.SetTarget(pTarget);

	mov	edx, DWORD PTR _pTarget$225324[ebp]
	mov	DWORD PTR _unit$225326[ebp+12], edx

; 1396 : 				m_CurrentMoveUnits.push_back(unit);

	lea	eax, DWORD PTR _unit$225326[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back

; 1397 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@PlotPatrol
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN4@PlotPatrol

; 1398 : 				{
; 1399 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225328[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1400 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$225329[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1401 : 
; 1402 : 					strTemp = pUnit->getUnitInfo().GetDescription();

	mov	eax, DWORD PTR _pUnit$225322[ebp]
	mov	DWORD PTR $T242882[ebp], eax
	mov	ecx, DWORD PTR $T242882[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	DWORD PTR $T242886[ebp], eax
	mov	ecx, DWORD PTR $T242886[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T242892[ebp], eax
	cmp	DWORD PTR $T242892[ebp], 0
	je	SHORT $LN86@PlotPatrol
	mov	ecx, DWORD PTR $T242892[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$225329[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN87@PlotPatrol
$LN86@PlotPatrol:
	lea	ecx, DWORD PTR _strTemp$225329[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN87@PlotPatrol:

; 1403 : 					strLogString.Format("%s (%d) patrolling to, X: %d, Y: %d, Current X: %d, Current Y: %d", strTemp.GetCString(), pUnit->GetID(), pTarget->getX(), pTarget->getY(), pUnit->getX(), pUnit->getY());

	mov	edx, DWORD PTR _pUnit$225322[ebp]
	mov	DWORD PTR $T242896[ebp], edx
	mov	eax, DWORD PTR $T242896[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T242905[ebp], ecx
	mov	edx, DWORD PTR _pUnit$225322[ebp]
	mov	DWORD PTR $T242909[ebp], edx
	mov	eax, DWORD PTR $T242909[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T242918[ebp], ecx
	mov	edx, DWORD PTR _pTarget$225324[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T242922[ebp], eax
	mov	ecx, DWORD PTR _pTarget$225324[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T242926[ebp], edx
	mov	eax, DWORD PTR _pUnit$225322[ebp]
	mov	DWORD PTR $T242930[ebp], eax
	mov	ecx, DWORD PTR $T242930[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T242939[ebp], edx
	mov	eax, DWORD PTR $T242905[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242918[ebp]
	push	ecx
	mov	edx, DWORD PTR $T242922[ebp]
	push	edx
	mov	eax, DWORD PTR $T242926[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242939[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$225329[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0EC@CNCBKJIE@?$CFs?5?$CI?$CFd?$CJ?5patrolling?5to?0?5X?3?5?$CFd?0?5Y?3@
	lea	edx, DWORD PTR _strLogString$225328[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 32					; 00000020H

; 1404 : 					LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$225328[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1405 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$225329[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$225328[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@PlotPatrol:

; 1406 : 			}
; 1407 : 		}
; 1408 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225322[ebp], 0
	je	SHORT $LN120@PlotPatrol
	mov	ecx, DWORD PTR _pUnit$225322[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN120@PlotPatrol:
	jmp	$LN25@PlotPatrol
$LN5@PlotPatrol:

; 1409 : 
; 1410 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T242963[ebp], edx
	cmp	DWORD PTR $T242963[ebp], 0
	jbe	SHORT $LN8@PlotPatrol

; 1411 : 	{
; 1412 : 		ExecutePatrolMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecutePatrolMoves
$LN8@PlotPatrol:

; 1413 : 	}
; 1414 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225322[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$225328[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$225329[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-200]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotPatrolMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotPatrolMoves
PUBLIC	??_C@_0FJ@HBHBDFBG@Moving?5?$CFs?5for?5upgrade?5at?5?$CFs?0?5GOL@ ; `string'
PUBLIC	?MoveToEmptySpaceNearTarget@CvHomelandAI@@AAE_NPAVCvUnit@@PAVCvPlot@@_N@Z ; CvHomelandAI::MoveToEmptySpaceNearTarget
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
PUBLIC	??_C@_0EL@HAFEABFE@Need?5gold?5for?5?$CFs?5upgrade?0?5GOLD?3?5@ ; `string'
PUBLIC	??_C@_0DF@DIBHONCC@Upgrading?5unit?5from?5type?5?$CFs?5to?5t@ ; `string'
PUBLIC	??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
PUBLIC	?CvHomelandUnitAuxIntReverseSort@HomelandAIHelpers@@YA_NVCvHomelandUnit@@0@Z ; HomelandAIHelpers::CvHomelandUnitAuxIntReverseSort
PUBLIC	__$ArrayPad$
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
EXTRN	?GetGold@CvTreasury@@QBEHXZ:PROC		; CvTreasury::GetGold
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?StartSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@HH@Z:PROC ; CvEconomicAI::StartSaveForPurchase
EXTRN	?upgradePrice@CvUnit@@QBEHW4UnitTypes@@@Z:PROC	; CvUnit::upgradePrice
EXTRN	?DoUpgrade@CvUnit@@QAEPAV1@XZ:PROC		; CvUnit::DoUpgrade
EXTRN	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvGame::getHandicapInfo
EXTRN	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z:PROC ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?CancelSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@@Z:PROC ; CvEconomicAI::CancelSaveForPurchase
EXTRN	?IsSavingForThisPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@@Z:PROC ; CvEconomicAI::IsSavingForThisPurchase
EXTRN	?CanUpgradeRightNow@CvUnit@@QBE_N_N@Z:PROC	; CvUnit::CanUpgradeRightNow
EXTRN	?GetPower@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetPower
EXTRN	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ:PROC	; CvUnit::getUnitType
EXTRN	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z:PROC ; CvPlayer::getNumResourceAvailable
EXTRN	?GetResourceQuantityRequirement@CvUnitEntry@@QBEHH@Z:PROC ; CvUnitEntry::GetResourceQuantityRequirement
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
EXTRN	?GetPrereqAndTech@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetPrereqAndTech
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?GetUpgradeUnitType@CvUnit@@QBE?AW4UnitTypes@@XZ:PROC ; CvUnit::GetUpgradeUnitType
;	COMDAT ??_C@_0FJ@HBHBDFBG@Moving?5?$CFs?5for?5upgrade?5at?5?$CFs?0?5GOL@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0FJ@HBHBDFBG@Moving?5?$CFs?5for?5upgrade?5at?5?$CFs?0?5GOL@ DB 'Mov'
	DB	'ing %s for upgrade at %s, GOLD: Available = %d, Needed = %d, '
	DB	'Priority = %d, Dist = %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@HAFEABFE@Need?5gold?5for?5?$CFs?5upgrade?0?5GOLD?3?5@
CONST	SEGMENT
??_C@_0EL@HAFEABFE@Need?5gold?5for?5?$CFs?5upgrade?0?5GOLD?3?5@ DB 'Need '
	DB	'gold for %s upgrade, GOLD: Available = %d, Needed = %d, Prior'
	DB	'ity = %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@DIBHONCC@Upgrading?5unit?5from?5type?5?$CFs?5to?5t@
CONST	SEGMENT
??_C@_0DF@DIBHONCC@Upgrading?5unit?5from?5type?5?$CFs?5to?5t@ DB 'Upgradi'
	DB	'ng unit from type %s to type %s, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$7
	DD	05H
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$10
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv1076 = -880						; size = 4
tv1008 = -876						; size = 4
tv1020 = -872						; size = 4
tv295 = -868						; size = 4
tv280 = -864						; size = 4
_this$ = -860						; size = 4
$T243747 = -856						; size = 4
$T243743 = -852						; size = 4
$T243742 = -848						; size = 4
$T243738 = -844						; size = 4
$T243732 = -840						; size = 4
$T243728 = -836						; size = 4
$T243716 = -832						; size = 4
$T243707 = -828						; size = 4
$T243700 = -824						; size = 4
$T243635 = -752						; size = 4
$T243626 = -748						; size = 4
$T243617 = -744						; size = 4
$T243608 = -740						; size = 4
$T243604 = -736						; size = 4
$T243595 = -732						; size = 4
$T243548 = -724						; size = 4
$T243535 = -720						; size = 4
$T243531 = -716						; size = 4
$T243524 = -712						; size = 4
$T243520 = -705						; size = 1
$T243509 = -704						; size = 4
$T243505 = -697						; size = 1
_iMapY$243557 = -696					; size = 4
_iMapX$243556 = -692					; size = 4
$T243498 = -688						; size = 4
$T243494 = -684						; size = 4
$T243490 = -680						; size = 4
$T243486 = -676						; size = 4
$T243482 = -672						; size = 4
$T243478 = -668						; size = 4
$T243466 = -664						; size = 4
$T243462 = -660						; size = 4
$T243456 = -656						; size = 4
$T243452 = -652						; size = 4
$T243440 = -648						; size = 4
$T243431 = -644						; size = 4
$T243427 = -640						; size = 4
$T243426 = -636						; size = 4
$T243422 = -632						; size = 4
$T243418 = -628						; size = 4
$T243411 = -624						; size = 4
$T243407 = -620						; size = 4
$T243403 = -616						; size = 4
$T243399 = -612						; size = 4
$T243395 = -608						; size = 4
$T243385 = -604						; size = 4
$T243381 = -600						; size = 4
$T243344 = -596						; size = 4
$T243340 = -592						; size = 4
$T243331 = -588						; size = 4
$T243322 = -584						; size = 4
$T243316 = -580						; size = 4
$T243312 = -576						; size = 4
$T243306 = -572						; size = 4
$T243302 = -568						; size = 4
$T243286 = -564						; size = 4
$T243277 = -560						; size = 4
$T243268 = -556						; size = 4
$T243264 = -552						; size = 4
$T243260 = -548						; size = 4
$T243256 = -544						; size = 4
$T243246 = -540						; size = 4
$T243242 = -536						; size = 4
$T243232 = -532						; size = 4
$T243226 = -528						; size = 4
$T243225 = -524						; size = 4
$T243221 = -520						; size = 4
$T243214 = -516						; size = 4
$T243208 = -512						; size = 4
$T243204 = -508						; size = 4
$T243186 = -504						; size = 4
$T243182 = -500						; size = 4
$T243181 = -496						; size = 4
$T243177 = -492						; size = 4
$T243154 = -484						; size = 4
$T243150 = -480						; size = 4
$T243146 = -476						; size = 4
$T243137 = -472						; size = 4
$T243133 = -468						; size = 4
$T243129 = -464						; size = 4
$T243122 = -460						; size = 4
$T243113 = -456						; size = 4
$T243109 = -452						; size = 4
$T243105 = -448						; size = 4
$T243101 = -444						; size = 4
$T243100 = -440						; size = 4
$T243091 = -436						; size = 4
$T243087 = -432						; size = 4
$T243083 = -428						; size = 4
$T243076 = -424						; size = 4
$T243066 = -420						; size = 4
$T243036 = -416						; size = 4
$T243003 = -412						; size = 4
$T242994 = -408						; size = 4
$T242978 = -404						; size = 28
$T242977 = -376						; size = 4
$T242976 = -372						; size = 4
$T242975 = -368						; size = 4
$T242974 = -364						; size = 4
$T242973 = -360						; size = 4
_strLogString$225442 = -356				; size = 28
_strTemp$225443 = -328					; size = 28
_iDistance$225437 = -300				; size = 4
_pTarget$225435 = -296					; size = 4
_pCity$225436 = -292					; size = 4
_iI$225431 = -288					; size = 4
_iBestDistance$225430 = -284				; size = 4
_pUpgradeCity$225429 = -280				; size = 4
_strLogString$225425 = -276				; size = 28
_strTemp$225426 = -248					; size = 28
_iFlavorLoop$225415 = -220				; size = 4
_iCurrentFlavorMilitaryTraining$225414 = -216		; size = 4
_strTemp2$225405 = -212					; size = 28
_strLogString$225403 = -184				; size = 28
_strTemp1$225404 = -156					; size = 28
__$ArrayPad$ = -128					; size = 4
_pNewUnit$225401 = -124					; size = 4
_pUnit$225399 = -120					; size = 8
_iFlavorLoop$225383 = -112				; size = 4
_iFlavorMilitaryTraining$225382 = -108			; size = 4
_pUnit$225409 = -104					; size = 8
_iBonusUpgrades$225392 = -96				; size = 4
_iAmountRequired$225410 = -92				; size = 4
_iGoldPriority$225412 = -88				; size = 4
_iNumUpgraded$225395 = -84				; size = 4
_bRequiresGold$225411 = -77				; size = 1
_unit$225367 = -76					; size = 16
_iPriority$225368 = -60					; size = 4
_iResourceLoop$225359 = -56				; size = 4
_ePrereqTech$225355 = -52				; size = 4
_eUpgradeUnitType$225353 = -48				; size = 4
_pUnit$225351 = -44					; size = 8
_it$225345 = -36					; size = 4
_bMissingResource$ = -29				; size = 1
_iNumResource$ = -28					; size = 4
_moveUnitIt$ = -24					; size = 4
_iNumResourceInUnit$ = -20				; size = 4
_eResource$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotUpgradeMoves, COMDAT
; _this$ = ecx

; 1418 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 868				; 00000364H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1419 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator moveUnitIt;
; 1420 : 	ResourceTypes eResource;
; 1421 : 	int iNumResource;
; 1422 : 	int iNumResourceInUnit;
; 1423 : 	bool bMissingResource;
; 1424 : 
; 1425 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 1426 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T242994[ebp], ecx
	mov	edx, DWORD PTR $T242994[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T243003[ebp], eax
	mov	ecx, DWORD PTR $T243003[ebp]
	mov	DWORD PTR _it$225345[ebp], ecx
	jmp	SHORT $LN46@PlotUpgrad
$LN72@PlotUpgrad:
	mov	edx, DWORD PTR _it$225345[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225345[ebp], eax
$LN46@PlotUpgrad:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T243036[ebp], edx
	mov	eax, DWORD PTR $T243036[ebp]
	mov	DWORD PTR $T242973[ebp], eax
	mov	ecx, DWORD PTR _it$225345[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T242973[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN44@PlotUpgrad

; 1427 : 	{
; 1428 : 		// Don't try and upgrade a human player's unit or one already recruited for an operation
; 1429 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225345[ebp]
	add	edx, 8
	mov	DWORD PTR $T243066[ebp], edx
	mov	eax, DWORD PTR $T243066[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T243076[ebp], eax
	mov	eax, DWORD PTR $T243076[ebp]
	mov	DWORD PTR _pUnit$225351[ebp], eax
	mov	BYTE PTR _pUnit$225351[ebp+4], 0
	cmp	DWORD PTR _pUnit$225351[ebp], 0
	je	SHORT $LN91@PlotUpgrad
	mov	ecx, DWORD PTR _pUnit$225351[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN91@PlotUpgrad:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1430 : 		if(pUnit && !pUnit->isHuman() && pUnit->getArmyID() == -1)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225351[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN43@PlotUpgrad
	mov	eax, DWORD PTR _pUnit$225351[ebp]
	mov	DWORD PTR $T243083[ebp], eax
	mov	ecx, DWORD PTR $T243083[ebp]
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN43@PlotUpgrad
	mov	edx, DWORD PTR _pUnit$225351[ebp]
	mov	DWORD PTR $T243087[ebp], edx
	mov	ecx, DWORD PTR $T243087[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	$LN43@PlotUpgrad

; 1431 : 		{
; 1432 : 			// Can this unit be upgraded?
; 1433 : 			UnitTypes eUpgradeUnitType = pUnit->GetUpgradeUnitType();

	mov	eax, DWORD PTR _pUnit$225351[ebp]
	mov	DWORD PTR $T243091[ebp], eax
	mov	ecx, DWORD PTR $T243091[ebp]
	call	?GetUpgradeUnitType@CvUnit@@QBE?AW4UnitTypes@@XZ ; CvUnit::GetUpgradeUnitType
	mov	DWORD PTR _eUpgradeUnitType$225353[ebp], eax

; 1434 : 			if(eUpgradeUnitType != NO_UNIT)

	cmp	DWORD PTR _eUpgradeUnitType$225353[ebp], -1
	je	$LN43@PlotUpgrad

; 1435 : 			{
; 1436 : 				// Tech requirement
; 1437 : 				TechTypes ePrereqTech = (TechTypes) GC.getUnitInfo(eUpgradeUnitType)->GetPrereqAndTech();

	mov	ecx, DWORD PTR _eUpgradeUnitType$225353[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	ecx, eax
	call	?GetPrereqAndTech@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetPrereqAndTech
	mov	DWORD PTR _ePrereqTech$225355[ebp], eax

; 1438 : 				if(ePrereqTech == NO_TECH || GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->HasTech(ePrereqTech))

	cmp	DWORD PTR _ePrereqTech$225355[ebp], -1
	je	SHORT $LN40@PlotUpgrad
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T243100[ebp], eax
	mov	ecx, DWORD PTR $T243100[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T243101[ebp], eax
	mov	eax, DWORD PTR $T243101[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T243105[ebp], eax
	mov	ecx, DWORD PTR _ePrereqTech$225355[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T243105[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	test	edx, edx
	je	$LN43@PlotUpgrad
$LN40@PlotUpgrad:

; 1439 : 				{
; 1440 : 					// Resource requirement
; 1441 : 					bMissingResource = false;

	mov	BYTE PTR _bMissingResource$[ebp], 0

; 1442 : #ifdef AUI_WARNING_FIXES
; 1443 : 					for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos() && !bMissingResource; iResourceLoop++)
; 1444 : #else
; 1445 : 					for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos() && !bMissingResource; iResourceLoop++)

	mov	DWORD PTR _iResourceLoop$225359[ebp], 0
	jmp	SHORT $LN39@PlotUpgrad
$LN38@PlotUpgrad:
	mov	eax, DWORD PTR _iResourceLoop$225359[ebp]
	add	eax, 1
	mov	DWORD PTR _iResourceLoop$225359[ebp], eax
$LN39@PlotUpgrad:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	DWORD PTR _iResourceLoop$225359[ebp], eax
	jge	SHORT $LN37@PlotUpgrad
	movzx	ecx, BYTE PTR _bMissingResource$[ebp]
	test	ecx, ecx
	jne	SHORT $LN37@PlotUpgrad

; 1446 : #endif
; 1447 : 					{
; 1448 : 						eResource = (ResourceTypes) iResourceLoop;

	mov	edx, DWORD PTR _iResourceLoop$225359[ebp]
	mov	DWORD PTR _eResource$[ebp], edx

; 1449 : 						iNumResource = GC.getUnitInfo(eUpgradeUnitType)->GetResourceQuantityRequirement(eResource);

	mov	eax, DWORD PTR _eResource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eUpgradeUnitType$225353[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	ecx, eax
	call	?GetResourceQuantityRequirement@CvUnitEntry@@QBEHH@Z ; CvUnitEntry::GetResourceQuantityRequirement
	mov	DWORD PTR _iNumResource$[ebp], eax

; 1450 : 						if (iNumResource > 0)

	cmp	DWORD PTR _iNumResource$[ebp], 0
	jle	SHORT $LN36@PlotUpgrad

; 1451 : 						{
; 1452 : 							iNumResourceInUnit = pUnit->getUnitInfo().GetResourceQuantityRequirement(eResource);

	mov	edx, DWORD PTR _pUnit$225351[ebp]
	mov	DWORD PTR $T243109[ebp], edx
	mov	eax, DWORD PTR _eResource$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T243109[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetResourceQuantityRequirement@CvUnitEntry@@QBEHH@Z ; CvUnitEntry::GetResourceQuantityRequirement
	mov	DWORD PTR _iNumResourceInUnit$[ebp], eax

; 1453 : 							if (m_pPlayer->getNumResourceAvailable(eResource) + iNumResourceInUnit < iNumResource)

	push	1
	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	add	eax, DWORD PTR _iNumResourceInUnit$[ebp]
	cmp	eax, DWORD PTR _iNumResource$[ebp]
	jge	SHORT $LN36@PlotUpgrad

; 1454 : 							{
; 1455 : 								bMissingResource = true;

	mov	BYTE PTR _bMissingResource$[ebp], 1
$LN36@PlotUpgrad:

; 1456 : 							}
; 1457 : 						}
; 1458 : 					}

	jmp	$LN38@PlotUpgrad
$LN37@PlotUpgrad:

; 1459 : 
; 1460 : 					if(!bMissingResource)

	movzx	eax, BYTE PTR _bMissingResource$[ebp]
	test	eax, eax
	jne	$LN43@PlotUpgrad

; 1461 : 					{
; 1462 : 						CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225367[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 1463 : 						unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225351[ebp]
	mov	DWORD PTR $T243113[ebp], ecx
	mov	edx, DWORD PTR $T243113[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T243122[ebp], eax
	mov	ecx, DWORD PTR $T243122[ebp]
	mov	DWORD PTR _unit$225367[ebp], ecx

; 1464 : 
; 1465 : 						// Initial priority: units with lowest power first
; 1466 : 						int iPriority = UPGRADE_THIS_TURN_PRIORITY_BOOST - GC.getUnitInfo(pUnit->getUnitType())->GetPower();

	mov	edx, DWORD PTR _pUnit$225351[ebp]
	mov	DWORD PTR $T243129[ebp], edx
	mov	ecx, DWORD PTR $T243129[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	ecx, eax
	call	?GetPower@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetPower
	mov	ecx, 1000				; 000003e8H
	sub	ecx, eax
	mov	DWORD PTR _iPriority$225368[ebp], ecx

; 1467 : 
; 1468 : 						// Priority is boosted if can upgrade immediately
; 1469 : 						if(pUnit->CanUpgradeRightNow(false))

	mov	edx, DWORD PTR _pUnit$225351[ebp]
	mov	DWORD PTR $T243133[ebp], edx
	push	0
	mov	ecx, DWORD PTR $T243133[ebp]
	call	?CanUpgradeRightNow@CvUnit@@QBE_N_N@Z	; CvUnit::CanUpgradeRightNow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN33@PlotUpgrad

; 1470 : 						{
; 1471 : 							iPriority += UPGRADE_THIS_TURN_PRIORITY_BOOST;

	mov	ecx, DWORD PTR _iPriority$225368[ebp]
	add	ecx, 1000				; 000003e8H
	mov	DWORD PTR _iPriority$225368[ebp], ecx
	jmp	SHORT $LN32@PlotUpgrad
$LN33@PlotUpgrad:

; 1472 : 						}
; 1473 : 
; 1474 : 						// Alternatively, priority boosted a lesser amount if in friendly territory
; 1475 : 						else if(pUnit->getOwner() == pUnit->plot()->getOwner())

	mov	edx, DWORD PTR _pUnit$225351[ebp]
	mov	DWORD PTR $T243137[ebp], edx
	mov	eax, DWORD PTR $T243137[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T243146[ebp], ecx
	mov	edx, DWORD PTR _pUnit$225351[ebp]
	mov	DWORD PTR $T243150[ebp], edx
	mov	ecx, DWORD PTR $T243150[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR $T243154[ebp], eax
	mov	eax, DWORD PTR $T243154[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	DWORD PTR $T243146[ebp], ecx
	jne	SHORT $LN32@PlotUpgrad

; 1476 : 						{
; 1477 : 							iPriority += UPGRADE_IN_TERRITORY_PRIORITY_BOOST;

	mov	edx, DWORD PTR _iPriority$225368[ebp]
	add	edx, 500				; 000001f4H
	mov	DWORD PTR _iPriority$225368[ebp], edx
$LN32@PlotUpgrad:

; 1478 : 						}
; 1479 : 
; 1480 : 						unit.SetAuxIntData(iPriority);

	mov	eax, DWORD PTR _iPriority$225368[ebp]
	mov	DWORD PTR _unit$225367[ebp+4], eax

; 1481 : 						m_CurrentMoveUnits.push_back(unit);

	lea	ecx, DWORD PTR _unit$225367[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN43@PlotUpgrad:

; 1482 : 					}
; 1483 : 				}
; 1484 : 			}
; 1485 : 		}
; 1486 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225351[ebp], 0
	je	SHORT $LN143@PlotUpgrad
	mov	ecx, DWORD PTR _pUnit$225351[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN143@PlotUpgrad:
	jmp	$LN72@PlotUpgrad
$LN44@PlotUpgrad:

; 1487 : 
; 1488 : 	// No units found, cancel request for money if we have one in
; 1489 : 	if(m_CurrentMoveUnits.size() == 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR $T243177[ebp], eax
	cmp	DWORD PTR $T243177[ebp], 0
	jne	SHORT $LN30@PlotUpgrad

; 1490 : 	{
; 1491 : 		if(!m_pPlayer->GetEconomicAI()->IsSavingForThisPurchase(PURCHASE_TYPE_UNIT_UPGRADE))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsSavingForThisPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@@Z ; CvEconomicAI::IsSavingForThisPurchase
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN29@PlotUpgrad

; 1492 : 		{
; 1493 : 			m_pPlayer->GetEconomicAI()->CancelSaveForPurchase(PURCHASE_TYPE_UNIT_UPGRADE);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?CancelSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@@Z ; CvEconomicAI::CancelSaveForPurchase
$LN29@PlotUpgrad:

; 1494 : 		}
; 1495 : 	}
; 1496 : 
; 1497 : 	else

	jmp	$LN47@PlotUpgrad
$LN30@PlotUpgrad:

; 1498 : 	{
; 1499 : 		// Sort results so highest priority is first
; 1500 : 		std::stable_sort(m_CurrentMoveUnits.begin(), m_CurrentMoveUnits.end(), HomelandAIHelpers::CvHomelandUnitAuxIntReverseSort);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T243181[ebp], ecx
	mov	edx, DWORD PTR $T243181[ebp]
	mov	eax, DWORD PTR [edx+4]
	shl	eax, 4
	mov	ecx, DWORD PTR $T243181[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T243182[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR $T243186[ebp], eax
	mov	ecx, DWORD PTR $T243186[ebp]
	cmp	ecx, DWORD PTR $T243182[ebp]
	je	SHORT $LN154@PlotUpgrad
	push	OFFSET ?CvHomelandUnitAuxIntReverseSort@HomelandAIHelpers@@YA_NVCvHomelandUnit@@0@Z ; HomelandAIHelpers::CvHomelandUnitAuxIntReverseSort
	push	0
	push	0
	mov	edx, DWORD PTR $T243182[ebp]
	push	edx
	mov	eax, DWORD PTR $T243186[ebp]
	push	eax
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 20					; 00000014H
$LN154@PlotUpgrad:

; 1501 : 
; 1502 : 		int iFlavorMilitaryTraining = 0;

	mov	DWORD PTR _iFlavorMilitaryTraining$225382[ebp], 0

; 1503 : 		for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes() && iFlavorMilitaryTraining == 0; iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$225383[ebp], 0
	jmp	SHORT $LN27@PlotUpgrad
$LN26@PlotUpgrad:
	mov	ecx, DWORD PTR _iFlavorLoop$225383[ebp]
	add	ecx, 1
	mov	DWORD PTR _iFlavorLoop$225383[ebp], ecx
$LN27@PlotUpgrad:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T243204[ebp], edx
	mov	eax, DWORD PTR _iFlavorLoop$225383[ebp]
	cmp	eax, DWORD PTR $T243204[ebp]
	jge	SHORT $LN25@PlotUpgrad
	cmp	DWORD PTR _iFlavorMilitaryTraining$225382[ebp], 0
	jne	SHORT $LN25@PlotUpgrad

; 1504 : 		{
; 1505 : 			if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_MILITARY_TRAINING")

	mov	ecx, DWORD PTR _iFlavorLoop$225383[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T243208[ebp], ecx
	push	OFFSET ??_C@_0BJ@NNFHMIPH@FLAVOR_MILITARY_TRAINING?$AA@
	mov	edx, DWORD PTR $T243208[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN24@PlotUpgrad

; 1506 : 			{
; 1507 : 				iFlavorMilitaryTraining = m_pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)iFlavorLoop);

	mov	ecx, DWORD PTR _iFlavorLoop$225383[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorMilitaryTraining$225382[ebp], eax
$LN24@PlotUpgrad:

; 1508 : 			}
; 1509 : 		}

	jmp	SHORT $LN26@PlotUpgrad
$LN25@PlotUpgrad:

; 1510 : 
; 1511 : 		iFlavorMilitaryTraining = max(1,iFlavorMilitaryTraining/3);

	mov	eax, DWORD PTR _iFlavorMilitaryTraining$225382[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	DWORD PTR $T242974[ebp], eax
	mov	DWORD PTR $T242975[ebp], 1
	mov	edx, DWORD PTR $T242975[ebp]
	cmp	edx, DWORD PTR $T242974[ebp]
	jge	SHORT $LN166@PlotUpgrad
	lea	eax, DWORD PTR $T242974[ebp]
	mov	DWORD PTR tv280[ebp], eax
	jmp	SHORT $LN167@PlotUpgrad
$LN166@PlotUpgrad:
	lea	ecx, DWORD PTR $T242975[ebp]
	mov	DWORD PTR tv280[ebp], ecx
$LN167@PlotUpgrad:
	mov	edx, DWORD PTR tv280[ebp]
	mov	DWORD PTR $T243214[ebp], edx
	mov	eax, DWORD PTR $T243214[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iFlavorMilitaryTraining$225382[ebp], ecx

; 1512 : 		int iBonusUpgrades = max(0,GC.getGame().getHandicapInfo().GetID() - 5); // more at the higher difficulties (the AI should have more money to spend)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T243221[ebp], edx
	mov	ecx, DWORD PTR $T243221[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	DWORD PTR $T243225[ebp], eax
	mov	eax, DWORD PTR $T243225[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T243226[ebp], ecx
	mov	edx, DWORD PTR $T243226[ebp]
	sub	edx, 5
	mov	DWORD PTR $T242976[ebp], edx
	mov	DWORD PTR $T242977[ebp], 0
	mov	eax, DWORD PTR $T242977[ebp]
	cmp	eax, DWORD PTR $T242976[ebp]
	jge	SHORT $LN174@PlotUpgrad
	lea	ecx, DWORD PTR $T242976[ebp]
	mov	DWORD PTR tv295[ebp], ecx
	jmp	SHORT $LN175@PlotUpgrad
$LN174@PlotUpgrad:
	lea	edx, DWORD PTR $T242977[ebp]
	mov	DWORD PTR tv295[ebp], edx
$LN175@PlotUpgrad:
	mov	eax, DWORD PTR tv295[ebp]
	mov	DWORD PTR $T243232[ebp], eax
	mov	ecx, DWORD PTR $T243232[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iBonusUpgrades$225392[ebp], edx

; 1513 : 		iFlavorMilitaryTraining += iBonusUpgrades;

	mov	eax, DWORD PTR _iFlavorMilitaryTraining$225382[ebp]
	add	eax, DWORD PTR _iBonusUpgrades$225392[ebp]
	mov	DWORD PTR _iFlavorMilitaryTraining$225382[ebp], eax

; 1514 : 
; 1515 : 		// Try to find a unit that can upgrade immediately
; 1516 : 		int iNumUpgraded = 0;

	mov	DWORD PTR _iNumUpgraded$225395[ebp], 0

; 1517 : 		for(moveUnitIt = m_CurrentMoveUnits.begin(); moveUnitIt != m_CurrentMoveUnits.end(); ++moveUnitIt)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _moveUnitIt$[ebp], edx
	jmp	SHORT $LN23@PlotUpgrad
$LN22@PlotUpgrad:
	mov	eax, DWORD PTR _moveUnitIt$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _moveUnitIt$[ebp], eax
$LN23@PlotUpgrad:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T243242[ebp], ecx
	mov	edx, DWORD PTR $T243242[ebp]
	mov	eax, DWORD PTR [edx+4]
	shl	eax, 4
	mov	ecx, DWORD PTR $T243242[ebp]
	add	eax, DWORD PTR [ecx]
	cmp	DWORD PTR _moveUnitIt$[ebp], eax
	je	$LN21@PlotUpgrad

; 1518 : 		{
; 1519 : 			UnitHandle pUnit = m_pPlayer->getUnit(moveUnitIt->GetID());

	mov	edx, DWORD PTR _moveUnitIt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T243246[ebp], eax
	mov	ecx, DWORD PTR $T243246[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T243256[ebp], eax
	mov	eax, DWORD PTR $T243256[ebp]
	mov	DWORD PTR _pUnit$225399[ebp], eax
	mov	BYTE PTR _pUnit$225399[ebp+4], 0
	cmp	DWORD PTR _pUnit$225399[ebp], 0
	je	SHORT $LN183@PlotUpgrad
	mov	ecx, DWORD PTR _pUnit$225399[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN183@PlotUpgrad:
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1520 : 			if(pUnit->CanUpgradeRightNow(false))

	mov	ecx, DWORD PTR _pUnit$225399[ebp]
	mov	DWORD PTR $T243260[ebp], ecx
	push	0
	mov	ecx, DWORD PTR $T243260[ebp]
	call	?CanUpgradeRightNow@CvUnit@@QBE_N_N@Z	; CvUnit::CanUpgradeRightNow
	movzx	edx, al
	test	edx, edx
	je	$LN20@PlotUpgrad

; 1521 : 			{
; 1522 : 				CvUnit* pNewUnit = pUnit->DoUpgrade();

	mov	eax, DWORD PTR _pUnit$225399[ebp]
	mov	DWORD PTR $T243264[ebp], eax
	mov	ecx, DWORD PTR $T243264[ebp]
	call	?DoUpgrade@CvUnit@@QAEPAV1@XZ		; CvUnit::DoUpgrade
	mov	DWORD PTR _pNewUnit$225401[ebp], eax

; 1523 : 				UnitProcessed(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225399[ebp]
	mov	DWORD PTR $T243268[ebp], ecx
	mov	edx, DWORD PTR $T243268[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T243277[ebp], eax
	mov	ecx, DWORD PTR $T243277[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 1524 : 				UnitProcessed(pNewUnit->GetID());

	mov	edx, DWORD PTR _pNewUnit$225401[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T243286[ebp], eax
	mov	ecx, DWORD PTR $T243286[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 1525 : 
; 1526 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN19@PlotUpgrad
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	$LN19@PlotUpgrad

; 1527 : 				{
; 1528 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225403[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1529 : #ifdef AUI_WARNING_FIXES
; 1530 : 					CvString strTemp1 = pUnit->getUnitInfo().GetDescription();
; 1531 : 					CvString strTemp2 = pNewUnit->getUnitInfo().GetDescription();
; 1532 : #else
; 1533 : 					CvString strTemp1, strTemp2;

	lea	ecx, DWORD PTR _strTemp1$225404[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strTemp2$225405[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 1534 : 					strTemp1 = GC.getUnitInfo(pUnit->getUnitType())->GetDescription();

	mov	ecx, DWORD PTR _pUnit$225399[ebp]
	mov	DWORD PTR $T243302[ebp], ecx
	mov	ecx, DWORD PTR $T243302[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR $T243306[ebp], eax
	mov	ecx, DWORD PTR $T243306[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T243312[ebp], eax
	cmp	DWORD PTR $T243312[ebp], 0
	je	SHORT $LN215@PlotUpgrad
	mov	edx, DWORD PTR $T243312[ebp]
	push	edx
	lea	ecx, DWORD PTR _strTemp1$225404[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN216@PlotUpgrad
$LN215@PlotUpgrad:
	lea	ecx, DWORD PTR _strTemp1$225404[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN216@PlotUpgrad:

; 1535 : 					strTemp2 = GC.getUnitInfo(pNewUnit->getUnitType())->GetDescription();

	mov	ecx, DWORD PTR _pNewUnit$225401[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR $T243316[ebp], eax
	mov	ecx, DWORD PTR $T243316[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T243322[ebp], eax
	cmp	DWORD PTR $T243322[ebp], 0
	je	SHORT $LN221@PlotUpgrad
	mov	eax, DWORD PTR $T243322[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTemp2$225405[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN226@PlotUpgrad
$LN221@PlotUpgrad:
	lea	ecx, DWORD PTR _strTemp2$225405[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 1536 : #endif
; 1537 : 					strLogString.Format("Upgrading unit from type %s to type %s, X: %d, Y: %d", strTemp1.GetCString(), strTemp2.GetCString(), pNewUnit->getX(), pNewUnit->getY());

$LN226@PlotUpgrad:
	mov	ecx, DWORD PTR _pNewUnit$225401[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T243331[ebp], edx
	mov	eax, DWORD PTR _pNewUnit$225401[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T243340[ebp], ecx
	lea	ecx, DWORD PTR _strTemp2$225405[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T243344[ebp], eax
	mov	edx, DWORD PTR $T243331[ebp]
	push	edx
	mov	eax, DWORD PTR $T243340[ebp]
	push	eax
	mov	ecx, DWORD PTR $T243344[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp1$225404[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0DF@DIBHONCC@Upgrading?5unit?5from?5type?5?$CFs?5to?5t@
	lea	edx, DWORD PTR _strLogString$225403[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 1538 : 					LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$225403[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1539 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strTemp2$225405[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strTemp1$225404[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLogString$225403[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN19@PlotUpgrad:

; 1540 : 
; 1541 : 				iNumUpgraded++;

	mov	ecx, DWORD PTR _iNumUpgraded$225395[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumUpgraded$225395[ebp], ecx

; 1542 : 				if(iNumUpgraded >= iFlavorMilitaryTraining)

	mov	edx, DWORD PTR _iNumUpgraded$225395[ebp]
	cmp	edx, DWORD PTR _iFlavorMilitaryTraining$225382[ebp]
	jl	SHORT $LN20@PlotUpgrad

; 1543 : 				{
; 1544 : 					return; // Only upgrade iFlavorMilitaryTraining units per turn

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225399[ebp], 0
	je	SHORT $LN246@PlotUpgrad
	mov	ecx, DWORD PTR _pUnit$225399[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN246@PlotUpgrad:
	jmp	$LN47@PlotUpgrad
$LN20@PlotUpgrad:

; 1545 : 				}
; 1546 : 			}
; 1547 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225399[ebp], 0
	je	SHORT $LN251@PlotUpgrad
	mov	ecx, DWORD PTR _pUnit$225399[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN251@PlotUpgrad:
	jmp	$LN22@PlotUpgrad
$LN21@PlotUpgrad:

; 1548 : 
; 1549 : 		if(iNumUpgraded > 0)

	cmp	DWORD PTR _iNumUpgraded$225395[ebp], 0
	jle	SHORT $LN17@PlotUpgrad

; 1550 : 		{
; 1551 : 			return;

	jmp	$LN47@PlotUpgrad
$LN17@PlotUpgrad:

; 1552 : 		}
; 1553 : 
; 1554 : 		// Couldn't do all upgrades this turn, get ready for highest priority unit to upgrade
; 1555 : 		UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[0].GetID());

	xor	eax, eax
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR $T243381[ebp], eax
	mov	edx, DWORD PTR $T243381[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T243385[ebp], eax
	mov	ecx, DWORD PTR $T243385[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T243395[ebp], eax
	mov	eax, DWORD PTR $T243395[ebp]
	mov	DWORD PTR _pUnit$225409[ebp], eax
	mov	BYTE PTR _pUnit$225409[ebp+4], 0
	cmp	DWORD PTR _pUnit$225409[ebp], 0
	je	SHORT $LN260@PlotUpgrad
	mov	ecx, DWORD PTR _pUnit$225409[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN260@PlotUpgrad:
	mov	DWORD PTR __$EHRec$[ebp+8], 5

; 1556 : 
; 1557 : 		int iAmountRequired = pUnit->upgradePrice(pUnit->GetUpgradeUnitType());

	mov	ecx, DWORD PTR _pUnit$225409[ebp]
	mov	DWORD PTR $T243399[ebp], ecx
	mov	edx, DWORD PTR _pUnit$225409[ebp]
	mov	DWORD PTR $T243403[ebp], edx
	mov	ecx, DWORD PTR $T243399[ebp]
	call	?GetUpgradeUnitType@CvUnit@@QBE?AW4UnitTypes@@XZ ; CvUnit::GetUpgradeUnitType
	push	eax
	mov	ecx, DWORD PTR $T243403[ebp]
	call	?upgradePrice@CvUnit@@QBEHW4UnitTypes@@@Z ; CvUnit::upgradePrice
	mov	DWORD PTR _iAmountRequired$225410[ebp], eax

; 1558 : 		bool bRequiresGold = (iAmountRequired > 0);

	xor	eax, eax
	cmp	DWORD PTR _iAmountRequired$225410[ebp], 0
	setg	al
	mov	BYTE PTR _bRequiresGold$225411[ebp], al

; 1559 : 		int iGoldPriority = 0;

	mov	DWORD PTR _iGoldPriority$225412[ebp], 0

; 1560 : 
; 1561 : 		if(bRequiresGold)

	movzx	ecx, BYTE PTR _bRequiresGold$225411[ebp]
	test	ecx, ecx
	je	$LN16@PlotUpgrad

; 1562 : 		{
; 1563 : 			// Find priority of this financial request
; 1564 : 			int iCurrentFlavorMilitaryTraining = 0;

	mov	DWORD PTR _iCurrentFlavorMilitaryTraining$225414[ebp], 0

; 1565 : 			for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes() && iCurrentFlavorMilitaryTraining == 0; iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$225415[ebp], 0
	jmp	SHORT $LN15@PlotUpgrad
$LN14@PlotUpgrad:
	mov	edx, DWORD PTR _iFlavorLoop$225415[ebp]
	add	edx, 1
	mov	DWORD PTR _iFlavorLoop$225415[ebp], edx
$LN15@PlotUpgrad:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T243407[ebp], eax
	mov	ecx, DWORD PTR _iFlavorLoop$225415[ebp]
	cmp	ecx, DWORD PTR $T243407[ebp]
	jge	SHORT $LN13@PlotUpgrad
	cmp	DWORD PTR _iCurrentFlavorMilitaryTraining$225414[ebp], 0
	jne	SHORT $LN13@PlotUpgrad

; 1566 : 			{
; 1567 : 				if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_MILITARY_TRAINING")

	mov	edx, DWORD PTR _iFlavorLoop$225415[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T243411[ebp], edx
	push	OFFSET ??_C@_0BJ@NNFHMIPH@FLAVOR_MILITARY_TRAINING?$AA@
	mov	eax, DWORD PTR $T243411[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@PlotUpgrad

; 1568 : 				{
; 1569 : 					iCurrentFlavorMilitaryTraining = m_pPlayer->GetFlavorManager()->GetIndividualFlavor((FlavorTypes)iFlavorLoop);

	mov	edx, DWORD PTR _iFlavorLoop$225415[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetIndividualFlavor
	mov	DWORD PTR _iCurrentFlavorMilitaryTraining$225414[ebp], eax
$LN12@PlotUpgrad:

; 1570 : 				}
; 1571 : 			}

	jmp	$LN14@PlotUpgrad
$LN13@PlotUpgrad:

; 1572 : 			iGoldPriority = GC.getAI_GOLD_PRIORITY_UPGRADE_BASE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2076
	mov	DWORD PTR _iGoldPriority$225412[ebp], ecx

; 1573 : 			iGoldPriority += GC.getAI_GOLD_PRIORITY_UPGRADE_PER_FLAVOR_POINT() * iCurrentFlavorMilitaryTraining;

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2080
	mov	DWORD PTR $T243418[ebp], edx
	mov	eax, DWORD PTR $T243418[ebp]
	imul	eax, DWORD PTR _iCurrentFlavorMilitaryTraining$225414[ebp]
	add	eax, DWORD PTR _iGoldPriority$225412[ebp]
	mov	DWORD PTR _iGoldPriority$225412[ebp], eax
$LN16@PlotUpgrad:

; 1574 : #ifndef AUI_WARNING_FIXES
; 1575 : 		}
; 1576 : 
; 1577 : 		// Start saving
; 1578 : 		if(bRequiresGold)

	movzx	ecx, BYTE PTR _bRequiresGold$225411[ebp]
	test	ecx, ecx
	je	SHORT $LN11@PlotUpgrad

; 1579 : 		{
; 1580 : #endif
; 1581 : 			m_pPlayer->GetEconomicAI()->CancelSaveForPurchase(PURCHASE_TYPE_UNIT_UPGRADE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?CancelSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@@Z ; CvEconomicAI::CancelSaveForPurchase

; 1582 : 			m_pPlayer->GetEconomicAI()->StartSaveForPurchase(PURCHASE_TYPE_UNIT_UPGRADE, iAmountRequired, iGoldPriority);

	mov	eax, DWORD PTR _iGoldPriority$225412[ebp]
	push	eax
	mov	ecx, DWORD PTR _iAmountRequired$225410[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?StartSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@HH@Z ; CvEconomicAI::StartSaveForPurchase
$LN11@PlotUpgrad:

; 1583 : 		}
; 1584 : 
; 1585 : 		// Already in friendly territory
; 1586 : 		if(pUnit->plot()->getOwner() == pUnit->getOwner())

	mov	eax, DWORD PTR _pUnit$225409[ebp]
	mov	DWORD PTR $T243422[ebp], eax
	mov	ecx, DWORD PTR $T243422[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR $T243426[ebp], eax
	mov	ecx, DWORD PTR $T243426[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T243427[ebp], edx
	mov	eax, DWORD PTR _pUnit$225409[ebp]
	mov	DWORD PTR $T243431[ebp], eax
	mov	ecx, DWORD PTR $T243431[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T243440[ebp], edx
	mov	eax, DWORD PTR $T243427[ebp]
	cmp	eax, DWORD PTR $T243440[ebp]
	jne	$LN10@PlotUpgrad

; 1587 : 		{
; 1588 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN9@PlotUpgrad
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN9@PlotUpgrad

; 1589 : 			{
; 1590 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225425[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 1591 : #ifdef AUI_WARNING_FIXES
; 1592 : 				CvString strTemp = pUnit->getUnitInfo().GetDescription();
; 1593 : #else
; 1594 : 				CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$225426[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 1595 : 
; 1596 : 				strTemp = pUnit->getUnitInfo().GetDescription();

	mov	eax, DWORD PTR _pUnit$225409[ebp]
	mov	DWORD PTR $T243452[ebp], eax
	mov	ecx, DWORD PTR $T243452[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	DWORD PTR $T243456[ebp], eax
	mov	ecx, DWORD PTR $T243456[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T243462[ebp], eax
	cmp	DWORD PTR $T243462[ebp], 0
	je	SHORT $LN297@PlotUpgrad
	mov	ecx, DWORD PTR $T243462[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$225426[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN298@PlotUpgrad
$LN297@PlotUpgrad:
	lea	ecx, DWORD PTR _strTemp$225426[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN298@PlotUpgrad:

; 1597 : #endif
; 1598 : 				strLogString.Format("Need gold for %s upgrade, GOLD: Available = %d, Needed = %d, Priority = %d",
; 1599 : 				                    strTemp.GetCString(), m_pPlayer->GetTreasury()->GetGold(), iAmountRequired, iGoldPriority);

	lea	ecx, DWORD PTR _strTemp$225426[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T243466[ebp], eax
	mov	edx, DWORD PTR _iGoldPriority$225412[ebp]
	push	edx
	mov	eax, DWORD PTR _iAmountRequired$225410[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	push	eax
	mov	edx, DWORD PTR $T243466[ebp]
	push	edx
	push	OFFSET ??_C@_0EL@HAFEABFE@Need?5gold?5for?5?$CFs?5upgrade?0?5GOLD?3?5@
	lea	eax, DWORD PTR _strLogString$225425[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 1600 : 				LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$225425[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1601 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR _strTemp$225426[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR _strLogString$225425[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN9@PlotUpgrad:

; 1602 : 		}
; 1603 : 
; 1604 : 		else

	jmp	$LN8@PlotUpgrad
$LN10@PlotUpgrad:

; 1605 : 		{
; 1606 : 			// Move top priority unit toward closest city
; 1607 : 			CvCity* pUpgradeCity = NULL;

	mov	DWORD PTR _pUpgradeCity$225429[ebp], 0

; 1608 : 			int iBestDistance = MAX_INT;

	mov	DWORD PTR _iBestDistance$225430[ebp], 2147483647 ; 7fffffffH

; 1609 : 			for(unsigned int iI = 0; iI < m_TargetedCities.size(); iI++)

	mov	DWORD PTR _iI$225431[ebp], 0
	jmp	SHORT $LN7@PlotUpgrad
$LN6@PlotUpgrad:
	mov	edx, DWORD PTR _iI$225431[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$225431[ebp], edx
$LN7@PlotUpgrad:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2412				; 0000096cH
	mov	DWORD PTR $T243478[ebp], eax
	mov	ecx, DWORD PTR $T243478[ebp]
	mov	edx, DWORD PTR $T243478[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	cmp	DWORD PTR _iI$225431[ebp], eax
	jae	$LN5@PlotUpgrad

; 1610 : 			{
; 1611 : 				CvPlot* pTarget = GC.getMap().plot(m_TargetedCities[iI].GetTargetX(), m_TargetedCities[iI].GetTargetY());

	mov	edx, DWORD PTR _iI$225431[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+2416]
	mov	DWORD PTR $T243482[ebp], edx
	mov	ecx, DWORD PTR $T243482[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T243486[ebp], edx
	mov	eax, DWORD PTR _iI$225431[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+2416]
	mov	DWORD PTR $T243490[ebp], eax
	mov	edx, DWORD PTR $T243490[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243494[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T243498[ebp], ecx
	cmp	DWORD PTR $T243494[ebp], -2147483647	; 80000001H
	je	SHORT $LN320@PlotUpgrad
	cmp	DWORD PTR $T243486[ebp], -2147483647	; 80000001H
	jne	SHORT $LN321@PlotUpgrad
$LN320@PlotUpgrad:
	mov	DWORD PTR _pTarget$225435[ebp], 0
	jmp	$LN322@PlotUpgrad
$LN321@PlotUpgrad:
	mov	edx, DWORD PTR $T243498[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T243505[ebp], al
	mov	ecx, DWORD PTR $T243498[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T243509[ebp], edx
	movzx	eax, BYTE PTR $T243505[ebp]
	test	eax, eax
	je	SHORT $LN333@PlotUpgrad
	cmp	DWORD PTR $T243494[ebp], 0
	jge	SHORT $LN332@PlotUpgrad
	mov	eax, DWORD PTR $T243494[ebp]
	cdq
	idiv	DWORD PTR $T243509[ebp]
	add	edx, DWORD PTR $T243509[ebp]
	mov	DWORD PTR _iMapX$243556[ebp], edx
	jmp	SHORT $LN334@PlotUpgrad
	jmp	SHORT $LN333@PlotUpgrad
$LN332@PlotUpgrad:
	mov	ecx, DWORD PTR $T243494[ebp]
	cmp	ecx, DWORD PTR $T243509[ebp]
	jl	SHORT $LN333@PlotUpgrad
	mov	eax, DWORD PTR $T243494[ebp]
	cdq
	idiv	DWORD PTR $T243509[ebp]
	mov	DWORD PTR _iMapX$243556[ebp], edx
	jmp	SHORT $LN334@PlotUpgrad
$LN333@PlotUpgrad:
	mov	edx, DWORD PTR $T243494[ebp]
	mov	DWORD PTR _iMapX$243556[ebp], edx
$LN334@PlotUpgrad:
	mov	eax, DWORD PTR $T243498[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T243520[ebp], cl
	mov	edx, DWORD PTR $T243498[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T243524[ebp], eax
	movzx	ecx, BYTE PTR $T243520[ebp]
	push	ecx
	mov	edx, DWORD PTR $T243524[ebp]
	push	edx
	mov	eax, DWORD PTR $T243486[ebp]
	push	eax
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$243557[ebp], eax
	cmp	DWORD PTR _iMapX$243556[ebp], 0
	jl	SHORT $LN342@PlotUpgrad
	mov	ecx, DWORD PTR $T243498[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T243531[ebp], edx
	mov	eax, DWORD PTR _iMapX$243556[ebp]
	cmp	eax, DWORD PTR $T243531[ebp]
	jge	SHORT $LN342@PlotUpgrad
	cmp	DWORD PTR _iMapY$243557[ebp], 0
	jl	SHORT $LN342@PlotUpgrad
	mov	ecx, DWORD PTR $T243498[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T243535[ebp], edx
	mov	eax, DWORD PTR _iMapY$243557[ebp]
	cmp	eax, DWORD PTR $T243535[ebp]
	jge	SHORT $LN342@PlotUpgrad
	mov	DWORD PTR tv1020[ebp], 1
	jmp	SHORT $LN340@PlotUpgrad
$LN342@PlotUpgrad:
	mov	DWORD PTR tv1020[ebp], 0
$LN340@PlotUpgrad:
	cmp	DWORD PTR tv1020[ebp], 0
	je	SHORT $LN324@PlotUpgrad
	mov	ecx, DWORD PTR $T243498[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T243548[ebp], edx
	mov	eax, DWORD PTR _iMapY$243557[ebp]
	imul	eax, DWORD PTR $T243548[ebp]
	add	eax, DWORD PTR _iMapX$243556[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T243498[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv1008[ebp], eax
	jmp	SHORT $LN325@PlotUpgrad
$LN324@PlotUpgrad:
	mov	DWORD PTR tv1008[ebp], 0
$LN325@PlotUpgrad:
	mov	edx, DWORD PTR tv1008[ebp]
	mov	DWORD PTR _pTarget$225435[ebp], edx
$LN322@PlotUpgrad:

; 1612 : 				CvCity* pCity = pTarget->getPlotCity();

	mov	ecx, DWORD PTR _pTarget$225435[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$225436[ebp], eax

; 1613 : 
; 1614 : 				int iDistance = plotDistance(pCity->getX(), pCity->getY(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR _pUnit$225409[ebp]
	mov	DWORD PTR $T243595[ebp], eax
	mov	ecx, DWORD PTR $T243595[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T243604[ebp], edx
	mov	eax, DWORD PTR _pUnit$225409[ebp]
	mov	DWORD PTR $T243608[ebp], eax
	mov	ecx, DWORD PTR $T243608[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T243617[ebp], edx
	mov	eax, DWORD PTR _pCity$225436[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T243626[ebp], ecx
	mov	edx, DWORD PTR _pCity$225436[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T243635[ebp], eax
	mov	ecx, DWORD PTR $T243604[ebp]
	push	ecx
	mov	edx, DWORD PTR $T243617[ebp]
	push	edx
	mov	eax, DWORD PTR $T243626[ebp]
	push	eax
	mov	ecx, DWORD PTR $T243635[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$225437[ebp], eax

; 1615 : 
; 1616 : 				if(iDistance < iBestDistance)

	mov	edx, DWORD PTR _iDistance$225437[ebp]
	cmp	edx, DWORD PTR _iBestDistance$225430[ebp]
	jge	SHORT $LN4@PlotUpgrad

; 1617 : 				{
; 1618 : 					iBestDistance = iDistance;

	mov	eax, DWORD PTR _iDistance$225437[ebp]
	mov	DWORD PTR _iBestDistance$225430[ebp], eax

; 1619 : 					pUpgradeCity = pCity;

	mov	ecx, DWORD PTR _pCity$225436[ebp]
	mov	DWORD PTR _pUpgradeCity$225429[ebp], ecx
$LN4@PlotUpgrad:

; 1620 : 				}
; 1621 : 			}

	jmp	$LN6@PlotUpgrad
$LN5@PlotUpgrad:

; 1622 : 
; 1623 : 			if(pUpgradeCity)

	cmp	DWORD PTR _pUpgradeCity$225429[ebp], 0
	je	$LN8@PlotUpgrad

; 1624 : 			{
; 1625 : 				if(MoveToEmptySpaceNearTarget(pUnit.pointer(), pUpgradeCity->plot()))

	mov	edx, DWORD PTR _pUnit$225409[ebp]
	mov	DWORD PTR $T243700[ebp], edx
	push	1
	mov	ecx, DWORD PTR _pUpgradeCity$225429[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	eax, DWORD PTR $T243700[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveToEmptySpaceNearTarget@CvHomelandAI@@AAE_NPAVCvUnit@@PAVCvPlot@@_N@Z ; CvHomelandAI::MoveToEmptySpaceNearTarget
	movzx	ecx, al
	test	ecx, ecx
	je	$LN8@PlotUpgrad

; 1626 : 				{
; 1627 : 					pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$225409[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 1628 : 					UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$225409[ebp]
	mov	DWORD PTR $T243707[ebp], edx
	mov	eax, DWORD PTR $T243707[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T243716[ebp], ecx
	mov	edx, DWORD PTR $T243716[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 1629 : 
; 1630 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN8@PlotUpgrad
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN8@PlotUpgrad

; 1631 : 					{
; 1632 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225442[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 1633 : 						CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$225443[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 9

; 1634 : #ifdef AUI_WARNING_FIXES
; 1635 : 						CvUnitEntry* pTempUnitInfo = GC.getUnitInfo(pUnit->getUnitType());
; 1636 : 						if (pTempUnitInfo)
; 1637 : 							strTemp = pTempUnitInfo->GetDescription();
; 1638 : #else
; 1639 : 						strTemp = GC.getUnitInfo(pUnit->getUnitType())->GetDescription();

	mov	edx, DWORD PTR _pUnit$225409[ebp]
	mov	DWORD PTR $T243728[ebp], edx
	mov	ecx, DWORD PTR $T243728[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR $T243732[ebp], eax
	mov	ecx, DWORD PTR $T243732[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T243738[ebp], eax
	cmp	DWORD PTR $T243738[ebp], 0
	je	SHORT $LN438@PlotUpgrad
	mov	eax, DWORD PTR $T243738[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTemp$225443[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN439@PlotUpgrad
$LN438@PlotUpgrad:
	lea	ecx, DWORD PTR _strTemp$225443[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN439@PlotUpgrad:

; 1640 : #endif
; 1641 : 						strLogString.Format("Moving %s for upgrade at %s, GOLD: Available = %d, Needed = %d, Priority = %d, Dist = %d",
; 1642 : 						                    strTemp.GetCString(), pUpgradeCity->getName().GetCString(),
; 1643 : 						                    m_pPlayer->GetTreasury()->GetGold(), iAmountRequired, iGoldPriority, iBestDistance);

	lea	ecx, DWORD PTR $T242978[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pUpgradeCity$225429[ebp]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv1076[ebp], eax
	mov	edx, DWORD PTR tv1076[ebp]
	mov	DWORD PTR $T243742[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T243742[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T243743[ebp], eax
	lea	ecx, DWORD PTR _strTemp$225443[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T243747[ebp], eax
	mov	eax, DWORD PTR _iBestDistance$225430[ebp]
	push	eax
	mov	ecx, DWORD PTR _iGoldPriority$225412[ebp]
	push	ecx
	mov	edx, DWORD PTR _iAmountRequired$225410[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	push	eax
	mov	ecx, DWORD PTR $T243743[ebp]
	push	ecx
	mov	edx, DWORD PTR $T243747[ebp]
	push	edx
	push	OFFSET ??_C@_0FJ@HBHBDFBG@Moving?5?$CFs?5for?5upgrade?5at?5?$CFs?0?5GOL@
	lea	eax, DWORD PTR _strLogString$225442[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 32					; 00000020H
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T242978[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1644 : 						LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$225442[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1645 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR _strTemp$225443[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR _strLogString$225442[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN8@PlotUpgrad:

; 1646 : 				}
; 1647 : 			}
; 1648 : 		}
; 1649 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225409[ebp], 0
	je	SHORT $LN47@PlotUpgrad
	mov	ecx, DWORD PTR _pUnit$225409[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN47@PlotUpgrad:

; 1650 : 
; 1651 : 	return;
; 1652 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225351[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _pUnit$225399[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$225403[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strTemp1$225404[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strTemp2$225405[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _pUnit$225409[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR _strLogString$225425[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _strTemp$225426[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$8:
	lea	ecx, DWORD PTR _strLogString$225442[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$9:
	lea	ecx, DWORD PTR _strTemp$225443[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$10:
	lea	ecx, DWORD PTR $T242978[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-872]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotUpgradeMoves
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
tv157 = -92						; size = 4
tv138 = -88						; size = 4
tv135 = -84						; size = 4
$T243857 = -80						; size = 4
$T243831 = -60						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_iWrappedDX$ = -16					; size = 4
_iHX1$ = -12						; size = 4
_iHX2$ = -8						; size = 4
_iWrappedDY$ = -4					; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[ebp]
	sub	eax, DWORD PTR _iX1$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDX$[ebp], eax

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ecx, DWORD PTR _iY2$[ebp]
	sub	ecx, DWORD PTR _iY1$[ebp]
	push	ecx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDY$[ebp], eax

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, DWORD PTR _iWrappedDY$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[ebp], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	cmp	DWORD PTR _iY1$[ebp], 0
	jl	SHORT $LN35@plotDistan
	mov	edx, DWORD PTR _iY1$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN33@plotDistan
$LN35@plotDistan:
	mov	eax, DWORD PTR _iY1$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv135[ebp], eax
$LN33@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	sub	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _iHX1$[ebp], eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	ecx, DWORD PTR _iY1$[ebp]
	add	ecx, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR $T243831[ebp], ecx
	js	SHORT $LN39@plotDistan
	mov	edx, DWORD PTR $T243831[ebp]
	sar	edx, 1
	mov	DWORD PTR tv138[ebp], edx
	jmp	SHORT $LN37@plotDistan
$LN39@plotDistan:
	mov	eax, DWORD PTR $T243831[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv138[ebp], eax
$LN37@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	add	eax, DWORD PTR _iWrappedDX$[ebp]
	sub	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _iHX2$[ebp], eax

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	ecx, DWORD PTR _iHX2$[ebp]
	sub	ecx, DWORD PTR _iHX1$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDX$[ebp], eax

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iHX2$[ebp]
	sub	edx, DWORD PTR _iHX1$[ebp]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iWrappedDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	jmp	SHORT $LN3@plotDistan

; 163  : 	}
; 164  : 	else

	jmp	SHORT $LN3@plotDistan
$LN2@plotDistan:

; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iDY$[ebp]
	jge	SHORT $LN57@plotDistan
	lea	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN58@plotDistan
$LN57@plotDistan:
	lea	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv157[ebp], ecx
$LN58@plotDistan:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T243857[ebp], edx
	mov	eax, DWORD PTR $T243857[ebp]
	mov	eax, DWORD PTR [eax]
$LN3@plotDistan:

; 170  : #endif
; 171  : 	}
; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T243881 = -16						; size = 4
$T243873 = -12						; size = 4
$T243869 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T243869[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T243873[ebp], ecx
	movzx	edx, BYTE PTR $T243869[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T243873[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T243873[ebp]
	mov	DWORD PTR $T243881[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T243873[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T243873[ebp]
	mov	DWORD PTR $T243881[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T243881[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T243881[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T243902 = -16						; size = 4
$T243894 = -12						; size = 4
$T243890 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T243890[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T243894[ebp], ecx
	movzx	edx, BYTE PTR $T243890[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T243894[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T243894[ebp]
	mov	DWORD PTR $T243902[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T243894[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T243894[ebp]
	mov	DWORD PTR $T243902[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T243902[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T243902[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	??_C@_0DB@JHKNLANA@Moving?5to?5goody?5hut?5?$CInon?9explore@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0DB@JHKNLANA@Moving?5to?5goody?5hut?5?$CInon?9explore@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0DB@JHKNLANA@Moving?5to?5goody?5hut?5?$CInon?9explore@ DB 'Moving t'
	DB	'o goody hut (non-explorer), X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv226 = -152						; size = 4
tv238 = -148						; size = 4
_this$ = -144						; size = 4
$T244055 = -140						; size = 4
$T244051 = -136						; size = 4
$T244047 = -132						; size = 4
$T244043 = -128						; size = 4
$T244035 = -124						; size = 4
$T244031 = -120						; size = 4
$T243989 = -116						; size = 4
$T243976 = -112						; size = 4
$T243972 = -108						; size = 4
$T243965 = -104						; size = 4
$T243961 = -97						; size = 1
$T243950 = -96						; size = 4
$T243946 = -89						; size = 1
_iMapY$244027 = -88					; size = 4
_iMapX$244026 = -84					; size = 4
$T243939 = -80						; size = 4
$T243935 = -76						; size = 4
$T243931 = -72						; size = 4
$T243927 = -68						; size = 4
$T243923 = -64						; size = 4
$T243919 = -60						; size = 4
$T243915 = -56						; size = 4
_strLogString$225458 = -52				; size = 28
__$ArrayPad$ = -24					; size = 4
_pTarget$225454 = -20					; size = 4
_iI$225450 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotAncientRuinMoves, COMDAT
; _this$ = ecx

; 1656 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1657 : 	// Do we have any targets of this type?
; 1658 : 	if(!m_TargetedAncientRuins.empty())

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2492				; 000009bcH
	mov	DWORD PTR $T243915[ebp], eax
	mov	ecx, DWORD PTR $T243915[ebp]
	mov	edx, DWORD PTR $T243915[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	edx, al
	test	edx, edx
	jne	$LN8@PlotAncien

; 1659 : 	{
; 1660 : 		// Prioritize them (LATER)
; 1661 : 
; 1662 : 		// See how many moves of this type we can execute
; 1663 : 		for(unsigned int iI = 0; iI < m_TargetedAncientRuins.size(); iI++)

	mov	DWORD PTR _iI$225450[ebp], 0
	jmp	SHORT $LN6@PlotAncien
$LN5@PlotAncien:
	mov	eax, DWORD PTR _iI$225450[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$225450[ebp], eax
$LN6@PlotAncien:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2492				; 000009bcH
	mov	DWORD PTR $T243919[ebp], ecx
	mov	edx, DWORD PTR $T243919[ebp]
	mov	eax, DWORD PTR $T243919[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	cmp	DWORD PTR _iI$225450[ebp], eax
	jae	$LN8@PlotAncien

; 1664 : 		{
; 1665 : 			CvPlot* pTarget = GC.getMap().plot(m_TargetedAncientRuins[iI].GetTargetX(), m_TargetedAncientRuins[iI].GetTargetY());

	mov	edx, DWORD PTR _iI$225450[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+2496]
	mov	DWORD PTR $T243923[ebp], edx
	mov	ecx, DWORD PTR $T243923[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T243927[ebp], edx
	mov	eax, DWORD PTR _iI$225450[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+2496]
	mov	DWORD PTR $T243931[ebp], eax
	mov	edx, DWORD PTR $T243931[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243935[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T243939[ebp], ecx
	cmp	DWORD PTR $T243935[ebp], -2147483647	; 80000001H
	je	SHORT $LN27@PlotAncien
	cmp	DWORD PTR $T243927[ebp], -2147483647	; 80000001H
	jne	SHORT $LN28@PlotAncien
$LN27@PlotAncien:
	mov	DWORD PTR _pTarget$225454[ebp], 0
	jmp	$LN29@PlotAncien
$LN28@PlotAncien:
	mov	edx, DWORD PTR $T243939[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T243946[ebp], al
	mov	ecx, DWORD PTR $T243939[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T243950[ebp], edx
	movzx	eax, BYTE PTR $T243946[ebp]
	test	eax, eax
	je	SHORT $LN40@PlotAncien
	cmp	DWORD PTR $T243935[ebp], 0
	jge	SHORT $LN39@PlotAncien
	mov	eax, DWORD PTR $T243935[ebp]
	cdq
	idiv	DWORD PTR $T243950[ebp]
	add	edx, DWORD PTR $T243950[ebp]
	mov	DWORD PTR _iMapX$244026[ebp], edx
	jmp	SHORT $LN41@PlotAncien
	jmp	SHORT $LN40@PlotAncien
$LN39@PlotAncien:
	mov	ecx, DWORD PTR $T243935[ebp]
	cmp	ecx, DWORD PTR $T243950[ebp]
	jl	SHORT $LN40@PlotAncien
	mov	eax, DWORD PTR $T243935[ebp]
	cdq
	idiv	DWORD PTR $T243950[ebp]
	mov	DWORD PTR _iMapX$244026[ebp], edx
	jmp	SHORT $LN41@PlotAncien
$LN40@PlotAncien:
	mov	edx, DWORD PTR $T243935[ebp]
	mov	DWORD PTR _iMapX$244026[ebp], edx
$LN41@PlotAncien:
	mov	eax, DWORD PTR $T243939[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T243961[ebp], cl
	mov	edx, DWORD PTR $T243939[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T243965[ebp], eax
	movzx	ecx, BYTE PTR $T243961[ebp]
	push	ecx
	mov	edx, DWORD PTR $T243965[ebp]
	push	edx
	mov	eax, DWORD PTR $T243927[ebp]
	push	eax
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$244027[ebp], eax
	cmp	DWORD PTR _iMapX$244026[ebp], 0
	jl	SHORT $LN49@PlotAncien
	mov	ecx, DWORD PTR $T243939[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T243972[ebp], edx
	mov	eax, DWORD PTR _iMapX$244026[ebp]
	cmp	eax, DWORD PTR $T243972[ebp]
	jge	SHORT $LN49@PlotAncien
	cmp	DWORD PTR _iMapY$244027[ebp], 0
	jl	SHORT $LN49@PlotAncien
	mov	ecx, DWORD PTR $T243939[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T243976[ebp], edx
	mov	eax, DWORD PTR _iMapY$244027[ebp]
	cmp	eax, DWORD PTR $T243976[ebp]
	jge	SHORT $LN49@PlotAncien
	mov	DWORD PTR tv238[ebp], 1
	jmp	SHORT $LN47@PlotAncien
$LN49@PlotAncien:
	mov	DWORD PTR tv238[ebp], 0
$LN47@PlotAncien:
	cmp	DWORD PTR tv238[ebp], 0
	je	SHORT $LN31@PlotAncien
	mov	ecx, DWORD PTR $T243939[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T243989[ebp], edx
	mov	eax, DWORD PTR _iMapY$244027[ebp]
	imul	eax, DWORD PTR $T243989[ebp]
	add	eax, DWORD PTR _iMapX$244026[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T243939[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv226[ebp], eax
	jmp	SHORT $LN32@PlotAncien
$LN31@PlotAncien:
	mov	DWORD PTR tv226[ebp], 0
$LN32@PlotAncien:
	mov	edx, DWORD PTR tv226[ebp]
	mov	DWORD PTR _pTarget$225454[ebp], edx
$LN29@PlotAncien:

; 1666 : 
; 1667 : 			FindUnitsForThisMove(AI_HOMELAND_MOVE_ANCIENT_RUINS, (iI == 0)/*bFirstTime*/);

	cmp	DWORD PTR _iI$225450[ebp], 0
	sete	al
	movzx	ecx, al
	push	ecx
	push	13					; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z ; CvHomelandAI::FindUnitsForThisMove

; 1668 : 
; 1669 : 			if(m_CurrentMoveHighPriorityUnits.size() + m_CurrentMoveUnits.size() > 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1060]
	mov	DWORD PTR $T244031[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T244035[ebp], edx
	mov	eax, DWORD PTR $T244031[ebp]
	add	eax, DWORD PTR $T244035[ebp]
	je	$LN3@PlotAncien

; 1670 : 			{
; 1671 : 				if(GetBestUnitToReachTarget(pTarget, m_iDefensiveMoveTurns))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2528]
	push	edx
	mov	eax, DWORD PTR _pTarget$225454[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z ; CvHomelandAI::GetBestUnitToReachTarget
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@PlotAncien

; 1672 : 				{
; 1673 : 					ExecuteMoveToTarget(pTarget);

	mov	edx, DWORD PTR _pTarget$225454[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget

; 1674 : 
; 1675 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN3@PlotAncien
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@PlotAncien

; 1676 : 					{
; 1677 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225458[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1678 : 						strLogString.Format("Moving to goody hut (non-explorer), X: %d, Y: %d", m_TargetedAncientRuins[iI].GetTargetX(), m_TargetedAncientRuins[iI].GetTargetY());

	mov	edx, DWORD PTR _iI$225450[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+2496]
	mov	DWORD PTR $T244043[ebp], edx
	mov	ecx, DWORD PTR $T244043[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244047[ebp], edx
	mov	eax, DWORD PTR _iI$225450[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+2496]
	mov	DWORD PTR $T244051[ebp], eax
	mov	edx, DWORD PTR $T244051[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244055[ebp], eax
	mov	ecx, DWORD PTR $T244047[ebp]
	push	ecx
	mov	edx, DWORD PTR $T244055[ebp]
	push	edx
	push	OFFSET ??_C@_0DB@JHKNLANA@Moving?5to?5goody?5hut?5?$CInon?9explore@
	lea	eax, DWORD PTR _strLogString$225458[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 1679 : 						LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$225458[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1680 : 					}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$225458[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@PlotAncien:

; 1681 : 				}
; 1682 : 			}
; 1683 : 		}

	jmp	$LN5@PlotAncien
$LN8@PlotAncien:

; 1684 : 	}
; 1685 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strLogString$225458[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-144]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotAncientRuinMoves
PUBLIC	?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteWriterMoves
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotWriterMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotWriterMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotWriterMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotWriterMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotWriterMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T244199 = -84						; size = 4
$T244176 = -76						; size = 4
$T244167 = -72						; size = 4
$T244163 = -68						; size = 4
$T244156 = -64						; size = 4
$T244146 = -60						; size = 4
$T244116 = -56						; size = 4
$T244083 = -52						; size = 4
$T244074 = -48						; size = 4
$T244068 = -44						; size = 4
_unit$225476 = -40					; size = 16
_pUnit$225473 = -24					; size = 8
_it$225467 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotWriterMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotWriterMoves, COMDAT
; _this$ = ecx

; 1689 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotWriterMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1690 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 1691 : 
; 1692 : 	// Loop through all recruited units
; 1693 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T244074[ebp], ecx
	mov	edx, DWORD PTR $T244074[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T244083[ebp], eax
	mov	ecx, DWORD PTR $T244083[ebp]
	mov	DWORD PTR _it$225467[ebp], ecx
	jmp	SHORT $LN6@PlotWriter
$LN22@PlotWriter:
	mov	edx, DWORD PTR _it$225467[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225467[ebp], eax
$LN6@PlotWriter:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244116[ebp], edx
	mov	eax, DWORD PTR $T244116[ebp]
	mov	DWORD PTR $T244068[ebp], eax
	mov	ecx, DWORD PTR _it$225467[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T244068[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@PlotWriter

; 1694 : 	{
; 1695 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225467[ebp]
	add	edx, 8
	mov	DWORD PTR $T244146[ebp], edx
	mov	eax, DWORD PTR $T244146[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T244156[ebp], eax
	mov	eax, DWORD PTR $T244156[ebp]
	mov	DWORD PTR _pUnit$225473[ebp], eax
	mov	BYTE PTR _pUnit$225473[ebp+4], 0
	cmp	DWORD PTR _pUnit$225473[ebp], 0
	je	SHORT $LN41@PlotWriter
	mov	ecx, DWORD PTR _pUnit$225473[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@PlotWriter:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1696 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225473[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@PlotWriter

; 1697 : 		{
; 1698 : 			if (pUnit->AI_getUnitAIType() == UNITAI_WRITER)

	mov	eax, DWORD PTR _pUnit$225473[ebp]
	mov	DWORD PTR $T244163[ebp], eax
	mov	ecx, DWORD PTR $T244163[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN3@PlotWriter

; 1699 : 			{
; 1700 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225476[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 1701 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225473[ebp]
	mov	DWORD PTR $T244167[ebp], ecx
	mov	edx, DWORD PTR $T244167[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T244176[ebp], eax
	mov	ecx, DWORD PTR $T244176[ebp]
	mov	DWORD PTR _unit$225476[ebp], ecx

; 1702 : 				m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225476[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN3@PlotWriter:

; 1703 : 			}
; 1704 : 		}
; 1705 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225473[ebp], 0
	je	SHORT $LN65@PlotWriter
	mov	ecx, DWORD PTR _pUnit$225473[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN65@PlotWriter:
	jmp	$LN22@PlotWriter
$LN4@PlotWriter:

; 1706 : 
; 1707 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T244199[ebp], ecx
	cmp	DWORD PTR $T244199[ebp], 0
	jbe	SHORT $LN7@PlotWriter

; 1708 : 	{
; 1709 : 		ExecuteWriterMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteWriterMoves
$LN7@PlotWriter:

; 1710 : 	}
; 1711 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotWriterMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225473[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotWriterMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotWriterMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotWriterMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotWriterMoves
PUBLIC	?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteArtistMoves
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotArtistMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotArtistMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotArtistMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotArtistMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotArtistMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T244339 = -84						; size = 4
$T244316 = -76						; size = 4
$T244307 = -72						; size = 4
$T244303 = -68						; size = 4
$T244296 = -64						; size = 4
$T244286 = -60						; size = 4
$T244256 = -56						; size = 4
$T244223 = -52						; size = 4
$T244214 = -48						; size = 4
$T244208 = -44						; size = 4
_unit$225494 = -40					; size = 16
_pUnit$225491 = -24					; size = 8
_it$225485 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotArtistMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotArtistMoves, COMDAT
; _this$ = ecx

; 1715 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotArtistMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1716 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 1717 : 
; 1718 : 	// Loop through all recruited units
; 1719 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T244214[ebp], ecx
	mov	edx, DWORD PTR $T244214[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T244223[ebp], eax
	mov	ecx, DWORD PTR $T244223[ebp]
	mov	DWORD PTR _it$225485[ebp], ecx
	jmp	SHORT $LN6@PlotArtist
$LN22@PlotArtist:
	mov	edx, DWORD PTR _it$225485[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225485[ebp], eax
$LN6@PlotArtist:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244256[ebp], edx
	mov	eax, DWORD PTR $T244256[ebp]
	mov	DWORD PTR $T244208[ebp], eax
	mov	ecx, DWORD PTR _it$225485[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T244208[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@PlotArtist

; 1720 : 	{
; 1721 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225485[ebp]
	add	edx, 8
	mov	DWORD PTR $T244286[ebp], edx
	mov	eax, DWORD PTR $T244286[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T244296[ebp], eax
	mov	eax, DWORD PTR $T244296[ebp]
	mov	DWORD PTR _pUnit$225491[ebp], eax
	mov	BYTE PTR _pUnit$225491[ebp+4], 0
	cmp	DWORD PTR _pUnit$225491[ebp], 0
	je	SHORT $LN41@PlotArtist
	mov	ecx, DWORD PTR _pUnit$225491[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@PlotArtist:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1722 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225491[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@PlotArtist

; 1723 : 		{
; 1724 : 			if (pUnit->AI_getUnitAIType() == UNITAI_ARTIST)

	mov	eax, DWORD PTR _pUnit$225491[ebp]
	mov	DWORD PTR $T244303[ebp], eax
	mov	ecx, DWORD PTR $T244303[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 11					; 0000000bH
	jne	SHORT $LN3@PlotArtist

; 1725 : 			{
; 1726 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225494[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 1727 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225491[ebp]
	mov	DWORD PTR $T244307[ebp], ecx
	mov	edx, DWORD PTR $T244307[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T244316[ebp], eax
	mov	ecx, DWORD PTR $T244316[ebp]
	mov	DWORD PTR _unit$225494[ebp], ecx

; 1728 : 				m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225494[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN3@PlotArtist:

; 1729 : 			}
; 1730 : 		}
; 1731 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225491[ebp], 0
	je	SHORT $LN65@PlotArtist
	mov	ecx, DWORD PTR _pUnit$225491[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN65@PlotArtist:
	jmp	$LN22@PlotArtist
$LN4@PlotArtist:

; 1732 : 
; 1733 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T244339[ebp], ecx
	cmp	DWORD PTR $T244339[ebp], 0
	jbe	SHORT $LN7@PlotArtist

; 1734 : 	{
; 1735 : 		ExecuteArtistMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteArtistMoves
$LN7@PlotArtist:

; 1736 : 	}
; 1737 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotArtistMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225491[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotArtistMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotArtistMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotArtistMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotArtistMoves
PUBLIC	?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteMusicianMoves
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotMusicianMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotMusicianMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotMusicianMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotMusicianMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotMusicianMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T244479 = -84						; size = 4
$T244456 = -76						; size = 4
$T244447 = -72						; size = 4
$T244443 = -68						; size = 4
$T244436 = -64						; size = 4
$T244426 = -60						; size = 4
$T244396 = -56						; size = 4
$T244363 = -52						; size = 4
$T244354 = -48						; size = 4
$T244348 = -44						; size = 4
_unit$225512 = -40					; size = 16
_pUnit$225509 = -24					; size = 8
_it$225503 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotMusicianMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotMusicianMoves, COMDAT
; _this$ = ecx

; 1741 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotMusicianMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1742 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 1743 : 
; 1744 : 	// Loop through all recruited units
; 1745 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T244354[ebp], ecx
	mov	edx, DWORD PTR $T244354[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T244363[ebp], eax
	mov	ecx, DWORD PTR $T244363[ebp]
	mov	DWORD PTR _it$225503[ebp], ecx
	jmp	SHORT $LN6@PlotMusici
$LN22@PlotMusici:
	mov	edx, DWORD PTR _it$225503[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225503[ebp], eax
$LN6@PlotMusici:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244396[ebp], edx
	mov	eax, DWORD PTR $T244396[ebp]
	mov	DWORD PTR $T244348[ebp], eax
	mov	ecx, DWORD PTR _it$225503[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T244348[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@PlotMusici

; 1746 : 	{
; 1747 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225503[ebp]
	add	edx, 8
	mov	DWORD PTR $T244426[ebp], edx
	mov	eax, DWORD PTR $T244426[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T244436[ebp], eax
	mov	eax, DWORD PTR $T244436[ebp]
	mov	DWORD PTR _pUnit$225509[ebp], eax
	mov	BYTE PTR _pUnit$225509[ebp+4], 0
	cmp	DWORD PTR _pUnit$225509[ebp], 0
	je	SHORT $LN41@PlotMusici
	mov	ecx, DWORD PTR _pUnit$225509[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@PlotMusici:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1748 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225509[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@PlotMusici

; 1749 : 		{
; 1750 : 			if (pUnit->AI_getUnitAIType() == UNITAI_MUSICIAN)

	mov	eax, DWORD PTR _pUnit$225509[ebp]
	mov	DWORD PTR $T244443[ebp], eax
	mov	ecx, DWORD PTR $T244443[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN3@PlotMusici

; 1751 : 			{
; 1752 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225512[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 1753 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225509[ebp]
	mov	DWORD PTR $T244447[ebp], ecx
	mov	edx, DWORD PTR $T244447[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T244456[ebp], eax
	mov	ecx, DWORD PTR $T244456[ebp]
	mov	DWORD PTR _unit$225512[ebp], ecx

; 1754 : 				m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225512[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN3@PlotMusici:

; 1755 : 			}
; 1756 : 		}
; 1757 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225509[ebp], 0
	je	SHORT $LN65@PlotMusici
	mov	ecx, DWORD PTR _pUnit$225509[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN65@PlotMusici:
	jmp	$LN22@PlotMusici
$LN4@PlotMusici:

; 1758 : 
; 1759 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T244479[ebp], ecx
	cmp	DWORD PTR $T244479[ebp], 0
	jbe	SHORT $LN7@PlotMusici

; 1760 : 	{
; 1761 : 		ExecuteMusicianMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteMusicianMoves
$LN7@PlotMusici:

; 1762 : 	}
; 1763 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotMusicianMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225509[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotMusicianMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotMusicianMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotMusicianMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotMusicianMoves
PUBLIC	?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteScientistMoves
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotScientistMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotScientistMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotScientistMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotScientistMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotScientistMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T244619 = -84						; size = 4
$T244596 = -76						; size = 4
$T244587 = -72						; size = 4
$T244583 = -68						; size = 4
$T244576 = -64						; size = 4
$T244566 = -60						; size = 4
$T244536 = -56						; size = 4
$T244503 = -52						; size = 4
$T244494 = -48						; size = 4
$T244488 = -44						; size = 4
_unit$225530 = -40					; size = 16
_pUnit$225527 = -24					; size = 8
_it$225521 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotScientistMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotScientistMoves, COMDAT
; _this$ = ecx

; 1767 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotScientistMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1768 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 1769 : 
; 1770 : 	// Loop through all recruited units
; 1771 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T244494[ebp], ecx
	mov	edx, DWORD PTR $T244494[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T244503[ebp], eax
	mov	ecx, DWORD PTR $T244503[ebp]
	mov	DWORD PTR _it$225521[ebp], ecx
	jmp	SHORT $LN6@PlotScient
$LN22@PlotScient:
	mov	edx, DWORD PTR _it$225521[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225521[ebp], eax
$LN6@PlotScient:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244536[ebp], edx
	mov	eax, DWORD PTR $T244536[ebp]
	mov	DWORD PTR $T244488[ebp], eax
	mov	ecx, DWORD PTR _it$225521[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T244488[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@PlotScient

; 1772 : 	{
; 1773 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225521[ebp]
	add	edx, 8
	mov	DWORD PTR $T244566[ebp], edx
	mov	eax, DWORD PTR $T244566[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T244576[ebp], eax
	mov	eax, DWORD PTR $T244576[ebp]
	mov	DWORD PTR _pUnit$225527[ebp], eax
	mov	BYTE PTR _pUnit$225527[ebp+4], 0
	cmp	DWORD PTR _pUnit$225527[ebp], 0
	je	SHORT $LN41@PlotScient
	mov	ecx, DWORD PTR _pUnit$225527[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@PlotScient:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1774 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225527[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@PlotScient

; 1775 : 		{
; 1776 : 			if(pUnit->AI_getUnitAIType() == UNITAI_SCIENTIST)

	mov	eax, DWORD PTR _pUnit$225527[ebp]
	mov	DWORD PTR $T244583[ebp], eax
	mov	ecx, DWORD PTR $T244583[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN3@PlotScient

; 1777 : 			{
; 1778 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225530[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 1779 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225527[ebp]
	mov	DWORD PTR $T244587[ebp], ecx
	mov	edx, DWORD PTR $T244587[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T244596[ebp], eax
	mov	ecx, DWORD PTR $T244596[ebp]
	mov	DWORD PTR _unit$225530[ebp], ecx

; 1780 : 				m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225530[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN3@PlotScient:

; 1781 : 			}
; 1782 : 		}
; 1783 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225527[ebp], 0
	je	SHORT $LN65@PlotScient
	mov	ecx, DWORD PTR _pUnit$225527[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN65@PlotScient:
	jmp	$LN22@PlotScient
$LN4@PlotScient:

; 1784 : 
; 1785 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T244619[ebp], ecx
	cmp	DWORD PTR $T244619[ebp], 0
	jbe	SHORT $LN7@PlotScient

; 1786 : 	{
; 1787 : 		ExecuteScientistMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteScientistMoves
$LN7@PlotScient:

; 1788 : 	}
; 1789 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotScientistMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225527[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotScientistMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotScientistMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotScientistMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotScientistMoves
PUBLIC	?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteEngineerMoves
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotEngineerMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotEngineerMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotEngineerMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotEngineerMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotEngineerMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T244759 = -84						; size = 4
$T244736 = -76						; size = 4
$T244727 = -72						; size = 4
$T244723 = -68						; size = 4
$T244716 = -64						; size = 4
$T244706 = -60						; size = 4
$T244676 = -56						; size = 4
$T244643 = -52						; size = 4
$T244634 = -48						; size = 4
$T244628 = -44						; size = 4
_unit$225548 = -40					; size = 16
_pUnit$225545 = -24					; size = 8
_it$225539 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotEngineerMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotEngineerMoves, COMDAT
; _this$ = ecx

; 1793 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotEngineerMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1794 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 1795 : 
; 1796 : 	// Loop through all recruited units
; 1797 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T244634[ebp], ecx
	mov	edx, DWORD PTR $T244634[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T244643[ebp], eax
	mov	ecx, DWORD PTR $T244643[ebp]
	mov	DWORD PTR _it$225539[ebp], ecx
	jmp	SHORT $LN6@PlotEngine
$LN22@PlotEngine:
	mov	edx, DWORD PTR _it$225539[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225539[ebp], eax
$LN6@PlotEngine:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244676[ebp], edx
	mov	eax, DWORD PTR $T244676[ebp]
	mov	DWORD PTR $T244628[ebp], eax
	mov	ecx, DWORD PTR _it$225539[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T244628[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@PlotEngine

; 1798 : 	{
; 1799 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225539[ebp]
	add	edx, 8
	mov	DWORD PTR $T244706[ebp], edx
	mov	eax, DWORD PTR $T244706[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T244716[ebp], eax
	mov	eax, DWORD PTR $T244716[ebp]
	mov	DWORD PTR _pUnit$225545[ebp], eax
	mov	BYTE PTR _pUnit$225545[ebp+4], 0
	cmp	DWORD PTR _pUnit$225545[ebp], 0
	je	SHORT $LN41@PlotEngine
	mov	ecx, DWORD PTR _pUnit$225545[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@PlotEngine:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1800 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225545[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@PlotEngine

; 1801 : 		{
; 1802 : 			if(pUnit->AI_getUnitAIType() == UNITAI_ENGINEER)

	mov	eax, DWORD PTR _pUnit$225545[ebp]
	mov	DWORD PTR $T244723[ebp], eax
	mov	ecx, DWORD PTR $T244723[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 15					; 0000000fH
	jne	SHORT $LN3@PlotEngine

; 1803 : 			{
; 1804 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225548[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 1805 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225545[ebp]
	mov	DWORD PTR $T244727[ebp], ecx
	mov	edx, DWORD PTR $T244727[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T244736[ebp], eax
	mov	ecx, DWORD PTR $T244736[ebp]
	mov	DWORD PTR _unit$225548[ebp], ecx

; 1806 : 				m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225548[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN3@PlotEngine:

; 1807 : 			}
; 1808 : 		}
; 1809 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225545[ebp], 0
	je	SHORT $LN65@PlotEngine
	mov	ecx, DWORD PTR _pUnit$225545[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN65@PlotEngine:
	jmp	$LN22@PlotEngine
$LN4@PlotEngine:

; 1810 : 
; 1811 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T244759[ebp], ecx
	cmp	DWORD PTR $T244759[ebp], 0
	jbe	SHORT $LN7@PlotEngine

; 1812 : 	{
; 1813 : 		ExecuteEngineerMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteEngineerMoves
$LN7@PlotEngine:

; 1814 : 	}
; 1815 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotEngineerMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225545[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotEngineerMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotEngineerMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotEngineerMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotEngineerMoves
PUBLIC	?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteMerchantMoves
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotMerchantMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotMerchantMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotMerchantMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotMerchantMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotMerchantMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T244899 = -84						; size = 4
$T244876 = -76						; size = 4
$T244867 = -72						; size = 4
$T244863 = -68						; size = 4
$T244856 = -64						; size = 4
$T244846 = -60						; size = 4
$T244816 = -56						; size = 4
$T244783 = -52						; size = 4
$T244774 = -48						; size = 4
$T244768 = -44						; size = 4
_unit$225566 = -40					; size = 16
_pUnit$225563 = -24					; size = 8
_it$225557 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotMerchantMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotMerchantMoves, COMDAT
; _this$ = ecx

; 1819 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotMerchantMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1820 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 1821 : 
; 1822 : 	// Loop through all recruited units
; 1823 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T244774[ebp], ecx
	mov	edx, DWORD PTR $T244774[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T244783[ebp], eax
	mov	ecx, DWORD PTR $T244783[ebp]
	mov	DWORD PTR _it$225557[ebp], ecx
	jmp	SHORT $LN6@PlotMercha
$LN22@PlotMercha:
	mov	edx, DWORD PTR _it$225557[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225557[ebp], eax
$LN6@PlotMercha:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244816[ebp], edx
	mov	eax, DWORD PTR $T244816[ebp]
	mov	DWORD PTR $T244768[ebp], eax
	mov	ecx, DWORD PTR _it$225557[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T244768[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@PlotMercha

; 1824 : 	{
; 1825 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225557[ebp]
	add	edx, 8
	mov	DWORD PTR $T244846[ebp], edx
	mov	eax, DWORD PTR $T244846[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T244856[ebp], eax
	mov	eax, DWORD PTR $T244856[ebp]
	mov	DWORD PTR _pUnit$225563[ebp], eax
	mov	BYTE PTR _pUnit$225563[ebp+4], 0
	cmp	DWORD PTR _pUnit$225563[ebp], 0
	je	SHORT $LN41@PlotMercha
	mov	ecx, DWORD PTR _pUnit$225563[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@PlotMercha:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1826 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225563[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@PlotMercha

; 1827 : 		{
; 1828 : 			if(pUnit->AI_getUnitAIType() == UNITAI_MERCHANT)

	mov	eax, DWORD PTR _pUnit$225563[ebp]
	mov	DWORD PTR $T244863[ebp], eax
	mov	ecx, DWORD PTR $T244863[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 14					; 0000000eH
	jne	SHORT $LN3@PlotMercha

; 1829 : 			{
; 1830 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225566[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 1831 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225563[ebp]
	mov	DWORD PTR $T244867[ebp], ecx
	mov	edx, DWORD PTR $T244867[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T244876[ebp], eax
	mov	ecx, DWORD PTR $T244876[ebp]
	mov	DWORD PTR _unit$225566[ebp], ecx

; 1832 : 				m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225566[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN3@PlotMercha:

; 1833 : 			}
; 1834 : 		}
; 1835 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225563[ebp], 0
	je	SHORT $LN65@PlotMercha
	mov	ecx, DWORD PTR _pUnit$225563[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN65@PlotMercha:
	jmp	$LN22@PlotMercha
$LN4@PlotMercha:

; 1836 : 
; 1837 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T244899[ebp], ecx
	cmp	DWORD PTR $T244899[ebp], 0
	jbe	SHORT $LN7@PlotMercha

; 1838 : 	{
; 1839 : 		ExecuteMerchantMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteMerchantMoves
$LN7@PlotMercha:

; 1840 : 	}
; 1841 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotMerchantMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225563[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotMerchantMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotMerchantMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotMerchantMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotMerchantMoves
PUBLIC	?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteProphetMoves
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotProphetMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotProphetMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotProphetMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotProphetMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotProphetMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T245039 = -84						; size = 4
$T245016 = -76						; size = 4
$T245007 = -72						; size = 4
$T245003 = -68						; size = 4
$T244996 = -64						; size = 4
$T244986 = -60						; size = 4
$T244956 = -56						; size = 4
$T244923 = -52						; size = 4
$T244914 = -48						; size = 4
$T244908 = -44						; size = 4
_unit$225584 = -40					; size = 16
_pUnit$225581 = -24					; size = 8
_it$225575 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotProphetMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotProphetMoves, COMDAT
; _this$ = ecx

; 1845 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotProphetMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1846 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 1847 : 
; 1848 : 	// Loop through all recruited units
; 1849 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T244914[ebp], ecx
	mov	edx, DWORD PTR $T244914[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T244923[ebp], eax
	mov	ecx, DWORD PTR $T244923[ebp]
	mov	DWORD PTR _it$225575[ebp], ecx
	jmp	SHORT $LN6@PlotProphe
$LN22@PlotProphe:
	mov	edx, DWORD PTR _it$225575[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225575[ebp], eax
$LN6@PlotProphe:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244956[ebp], edx
	mov	eax, DWORD PTR $T244956[ebp]
	mov	DWORD PTR $T244908[ebp], eax
	mov	ecx, DWORD PTR _it$225575[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T244908[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@PlotProphe

; 1850 : 	{
; 1851 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225575[ebp]
	add	edx, 8
	mov	DWORD PTR $T244986[ebp], edx
	mov	eax, DWORD PTR $T244986[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T244996[ebp], eax
	mov	eax, DWORD PTR $T244996[ebp]
	mov	DWORD PTR _pUnit$225581[ebp], eax
	mov	BYTE PTR _pUnit$225581[ebp+4], 0
	cmp	DWORD PTR _pUnit$225581[ebp], 0
	je	SHORT $LN41@PlotProphe
	mov	ecx, DWORD PTR _pUnit$225581[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@PlotProphe:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1852 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225581[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@PlotProphe

; 1853 : 		{
; 1854 : 			if(pUnit->AI_getUnitAIType() == UNITAI_PROPHET)

	mov	eax, DWORD PTR _pUnit$225581[ebp]
	mov	DWORD PTR $T245003[ebp], eax
	mov	ecx, DWORD PTR $T245003[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN3@PlotProphe

; 1855 : 			{
; 1856 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225584[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 1857 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225581[ebp]
	mov	DWORD PTR $T245007[ebp], ecx
	mov	edx, DWORD PTR $T245007[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T245016[ebp], eax
	mov	ecx, DWORD PTR $T245016[ebp]
	mov	DWORD PTR _unit$225584[ebp], ecx

; 1858 : 				m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225584[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN3@PlotProphe:

; 1859 : 			}
; 1860 : 		}
; 1861 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225581[ebp], 0
	je	SHORT $LN65@PlotProphe
	mov	ecx, DWORD PTR _pUnit$225581[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN65@PlotProphe:
	jmp	$LN22@PlotProphe
$LN4@PlotProphe:

; 1862 : 
; 1863 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T245039[ebp], ecx
	cmp	DWORD PTR $T245039[ebp], 0
	jbe	SHORT $LN7@PlotProphe

; 1864 : 	{
; 1865 : 		ExecuteProphetMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteProphetMoves
$LN7@PlotProphe:

; 1866 : 	}
; 1867 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotProphetMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225581[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotProphetMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotProphetMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotProphetMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotProphetMoves
PUBLIC	?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteMissionaryMoves
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T245179 = -84						; size = 4
$T245156 = -76						; size = 4
$T245147 = -72						; size = 4
$T245143 = -68						; size = 4
$T245136 = -64						; size = 4
$T245126 = -60						; size = 4
$T245096 = -56						; size = 4
$T245063 = -52						; size = 4
$T245054 = -48						; size = 4
$T245048 = -44						; size = 4
_unit$225602 = -40					; size = 16
_pUnit$225599 = -24					; size = 8
_it$225593 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotMissionaryMoves, COMDAT
; _this$ = ecx

; 1871 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1872 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 1873 : 
; 1874 : 	// Loop through all recruited units
; 1875 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245054[ebp], ecx
	mov	edx, DWORD PTR $T245054[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T245063[ebp], eax
	mov	ecx, DWORD PTR $T245063[ebp]
	mov	DWORD PTR _it$225593[ebp], ecx
	jmp	SHORT $LN6@PlotMissio
$LN22@PlotMissio:
	mov	edx, DWORD PTR _it$225593[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225593[ebp], eax
$LN6@PlotMissio:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245096[ebp], edx
	mov	eax, DWORD PTR $T245096[ebp]
	mov	DWORD PTR $T245048[ebp], eax
	mov	ecx, DWORD PTR _it$225593[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T245048[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@PlotMissio

; 1876 : 	{
; 1877 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225593[ebp]
	add	edx, 8
	mov	DWORD PTR $T245126[ebp], edx
	mov	eax, DWORD PTR $T245126[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T245136[ebp], eax
	mov	eax, DWORD PTR $T245136[ebp]
	mov	DWORD PTR _pUnit$225599[ebp], eax
	mov	BYTE PTR _pUnit$225599[ebp+4], 0
	cmp	DWORD PTR _pUnit$225599[ebp], 0
	je	SHORT $LN41@PlotMissio
	mov	ecx, DWORD PTR _pUnit$225599[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@PlotMissio:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1878 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225599[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@PlotMissio

; 1879 : 		{
; 1880 : 			if(pUnit->AI_getUnitAIType() == UNITAI_MISSIONARY)

	mov	eax, DWORD PTR _pUnit$225599[ebp]
	mov	DWORD PTR $T245143[ebp], eax
	mov	ecx, DWORD PTR $T245143[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN3@PlotMissio

; 1881 : 			{
; 1882 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225602[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 1883 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225599[ebp]
	mov	DWORD PTR $T245147[ebp], ecx
	mov	edx, DWORD PTR $T245147[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T245156[ebp], eax
	mov	ecx, DWORD PTR $T245156[ebp]
	mov	DWORD PTR _unit$225602[ebp], ecx

; 1884 : 				m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225602[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN3@PlotMissio:

; 1885 : 			}
; 1886 : 		}
; 1887 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225599[ebp], 0
	je	SHORT $LN65@PlotMissio
	mov	ecx, DWORD PTR _pUnit$225599[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN65@PlotMissio:
	jmp	$LN22@PlotMissio
$LN4@PlotMissio:

; 1888 : 
; 1889 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T245179[ebp], ecx
	cmp	DWORD PTR $T245179[ebp], 0
	jbe	SHORT $LN7@PlotMissio

; 1890 : 	{
; 1891 : 		ExecuteMissionaryMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteMissionaryMoves
$LN7@PlotMissio:

; 1892 : 	}
; 1893 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225599[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotMissionaryMoves
PUBLIC	?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteInquisitorMoves
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T245319 = -84						; size = 4
$T245296 = -76						; size = 4
$T245287 = -72						; size = 4
$T245283 = -68						; size = 4
$T245276 = -64						; size = 4
$T245266 = -60						; size = 4
$T245236 = -56						; size = 4
$T245203 = -52						; size = 4
$T245194 = -48						; size = 4
$T245188 = -44						; size = 4
_unit$225620 = -40					; size = 16
_pUnit$225617 = -24					; size = 8
_it$225611 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotInquisitorMoves, COMDAT
; _this$ = ecx

; 1897 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1898 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 1899 : 
; 1900 : 	// Loop through all recruited units
; 1901 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245194[ebp], ecx
	mov	edx, DWORD PTR $T245194[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T245203[ebp], eax
	mov	ecx, DWORD PTR $T245203[ebp]
	mov	DWORD PTR _it$225611[ebp], ecx
	jmp	SHORT $LN6@PlotInquis
$LN22@PlotInquis:
	mov	edx, DWORD PTR _it$225611[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225611[ebp], eax
$LN6@PlotInquis:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245236[ebp], edx
	mov	eax, DWORD PTR $T245236[ebp]
	mov	DWORD PTR $T245188[ebp], eax
	mov	ecx, DWORD PTR _it$225611[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T245188[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@PlotInquis

; 1902 : 	{
; 1903 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225611[ebp]
	add	edx, 8
	mov	DWORD PTR $T245266[ebp], edx
	mov	eax, DWORD PTR $T245266[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T245276[ebp], eax
	mov	eax, DWORD PTR $T245276[ebp]
	mov	DWORD PTR _pUnit$225617[ebp], eax
	mov	BYTE PTR _pUnit$225617[ebp+4], 0
	cmp	DWORD PTR _pUnit$225617[ebp], 0
	je	SHORT $LN41@PlotInquis
	mov	ecx, DWORD PTR _pUnit$225617[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@PlotInquis:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1904 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225617[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@PlotInquis

; 1905 : 		{
; 1906 : 			if(pUnit->AI_getUnitAIType() == UNITAI_INQUISITOR)

	mov	eax, DWORD PTR _pUnit$225617[ebp]
	mov	DWORD PTR $T245283[ebp], eax
	mov	ecx, DWORD PTR $T245283[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 36					; 00000024H
	jne	SHORT $LN3@PlotInquis

; 1907 : 			{
; 1908 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225620[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 1909 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225617[ebp]
	mov	DWORD PTR $T245287[ebp], ecx
	mov	edx, DWORD PTR $T245287[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T245296[ebp], eax
	mov	ecx, DWORD PTR $T245296[ebp]
	mov	DWORD PTR _unit$225620[ebp], ecx

; 1910 : 				m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225620[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN3@PlotInquis:

; 1911 : 			}
; 1912 : 		}
; 1913 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225617[ebp], 0
	je	SHORT $LN65@PlotInquis
	mov	ecx, DWORD PTR _pUnit$225617[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN65@PlotInquis:
	jmp	$LN22@PlotInquis
$LN4@PlotInquis:

; 1914 : 
; 1915 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T245319[ebp], ecx
	cmp	DWORD PTR $T245319[ebp], 0
	jbe	SHORT $LN7@PlotInquis

; 1916 : 	{
; 1917 : 		ExecuteInquisitorMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteInquisitorMoves
$LN7@PlotInquis:

; 1918 : 	}
; 1919 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225617[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotInquisitorMoves
PUBLIC	?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteSSPartMoves
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotSSPartMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotSSPartMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotSSPartMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotSSPartMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotSSPartMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T245459 = -84						; size = 4
$T245436 = -76						; size = 4
$T245427 = -72						; size = 4
$T245423 = -68						; size = 4
$T245416 = -64						; size = 4
$T245406 = -60						; size = 4
$T245376 = -56						; size = 4
$T245343 = -52						; size = 4
$T245334 = -48						; size = 4
$T245328 = -44						; size = 4
_unit$225638 = -40					; size = 16
_pUnit$225635 = -24					; size = 8
_it$225629 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotSSPartMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotSSPartMoves, COMDAT
; _this$ = ecx

; 1923 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotSSPartMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1924 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 1925 : 
; 1926 : 	// Loop through all recruited units
; 1927 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245334[ebp], ecx
	mov	edx, DWORD PTR $T245334[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T245343[ebp], eax
	mov	ecx, DWORD PTR $T245343[ebp]
	mov	DWORD PTR _it$225629[ebp], ecx
	jmp	SHORT $LN6@PlotSSPart
$LN22@PlotSSPart:
	mov	edx, DWORD PTR _it$225629[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225629[ebp], eax
$LN6@PlotSSPart:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245376[ebp], edx
	mov	eax, DWORD PTR $T245376[ebp]
	mov	DWORD PTR $T245328[ebp], eax
	mov	ecx, DWORD PTR _it$225629[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T245328[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@PlotSSPart

; 1928 : 	{
; 1929 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225629[ebp]
	add	edx, 8
	mov	DWORD PTR $T245406[ebp], edx
	mov	eax, DWORD PTR $T245406[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T245416[ebp], eax
	mov	eax, DWORD PTR $T245416[ebp]
	mov	DWORD PTR _pUnit$225635[ebp], eax
	mov	BYTE PTR _pUnit$225635[ebp+4], 0
	cmp	DWORD PTR _pUnit$225635[ebp], 0
	je	SHORT $LN41@PlotSSPart
	mov	ecx, DWORD PTR _pUnit$225635[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@PlotSSPart:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1930 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225635[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@PlotSSPart

; 1931 : 		{
; 1932 : 			if(pUnit->AI_getUnitAIType() == UNITAI_SPACESHIP_PART)

	mov	eax, DWORD PTR _pUnit$225635[ebp]
	mov	DWORD PTR $T245423[ebp], eax
	mov	ecx, DWORD PTR $T245423[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN3@PlotSSPart

; 1933 : 			{
; 1934 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225638[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 1935 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225635[ebp]
	mov	DWORD PTR $T245427[ebp], ecx
	mov	edx, DWORD PTR $T245427[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T245436[ebp], eax
	mov	ecx, DWORD PTR $T245436[ebp]
	mov	DWORD PTR _unit$225638[ebp], ecx

; 1936 : 				m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225638[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN3@PlotSSPart:

; 1937 : 			}
; 1938 : 		}
; 1939 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225635[ebp], 0
	je	SHORT $LN65@PlotSSPart
	mov	ecx, DWORD PTR _pUnit$225635[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN65@PlotSSPart:
	jmp	$LN22@PlotSSPart
$LN4@PlotSSPart:

; 1940 : 
; 1941 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T245459[ebp], ecx
	cmp	DWORD PTR $T245459[ebp], 0
	jbe	SHORT $LN7@PlotSSPart

; 1942 : 	{
; 1943 : 		ExecuteSSPartMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteSSPartMoves
$LN7@PlotSSPart:

; 1944 : 	}
; 1945 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotSSPartMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225635[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotSSPartMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotSSPartMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotSSPartMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotSSPartMoves
PUBLIC	?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ		; CvHomelandAI::ExecuteSSPartAdds
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotSSPartAdds@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotSSPartAdds@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotSSPartAdds@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotSSPartAdds@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotSSPartAdds@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T245599 = -84						; size = 4
$T245576 = -76						; size = 4
$T245567 = -72						; size = 4
$T245563 = -68						; size = 4
$T245556 = -64						; size = 4
$T245546 = -60						; size = 4
$T245516 = -56						; size = 4
$T245483 = -52						; size = 4
$T245474 = -48						; size = 4
$T245468 = -44						; size = 4
_unit$225656 = -40					; size = 16
_pUnit$225653 = -24					; size = 8
_it$225647 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotSSPartAdds@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotSSPartAdds, COMDAT
; _this$ = ecx

; 1949 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotSSPartAdds@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1950 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 1951 : 
; 1952 : 	// Loop through all recruited units
; 1953 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245474[ebp], ecx
	mov	edx, DWORD PTR $T245474[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T245483[ebp], eax
	mov	ecx, DWORD PTR $T245483[ebp]
	mov	DWORD PTR _it$225647[ebp], ecx
	jmp	SHORT $LN6@PlotSSPart@2
$LN22@PlotSSPart@2:
	mov	edx, DWORD PTR _it$225647[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225647[ebp], eax
$LN6@PlotSSPart@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245516[ebp], edx
	mov	eax, DWORD PTR $T245516[ebp]
	mov	DWORD PTR $T245468[ebp], eax
	mov	ecx, DWORD PTR _it$225647[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T245468[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@PlotSSPart@2

; 1954 : 	{
; 1955 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225647[ebp]
	add	edx, 8
	mov	DWORD PTR $T245546[ebp], edx
	mov	eax, DWORD PTR $T245546[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T245556[ebp], eax
	mov	eax, DWORD PTR $T245556[ebp]
	mov	DWORD PTR _pUnit$225653[ebp], eax
	mov	BYTE PTR _pUnit$225653[ebp+4], 0
	cmp	DWORD PTR _pUnit$225653[ebp], 0
	je	SHORT $LN41@PlotSSPart@2
	mov	ecx, DWORD PTR _pUnit$225653[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@PlotSSPart@2:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1956 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225653[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@PlotSSPart@2

; 1957 : 		{
; 1958 : 			if(pUnit->AI_getUnitAIType() == UNITAI_SPACESHIP_PART)

	mov	eax, DWORD PTR _pUnit$225653[ebp]
	mov	DWORD PTR $T245563[ebp], eax
	mov	ecx, DWORD PTR $T245563[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN3@PlotSSPart@2

; 1959 : 			{
; 1960 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225656[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 1961 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225653[ebp]
	mov	DWORD PTR $T245567[ebp], ecx
	mov	edx, DWORD PTR $T245567[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T245576[ebp], eax
	mov	ecx, DWORD PTR $T245576[ebp]
	mov	DWORD PTR _unit$225656[ebp], ecx

; 1962 : 				m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225656[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN3@PlotSSPart@2:

; 1963 : 			}
; 1964 : 		}
; 1965 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225653[ebp], 0
	je	SHORT $LN65@PlotSSPart@2
	mov	ecx, DWORD PTR _pUnit$225653[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN65@PlotSSPart@2:
	jmp	$LN22@PlotSSPart@2
$LN4@PlotSSPart@2:

; 1966 : 
; 1967 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T245599[ebp], ecx
	cmp	DWORD PTR $T245599[ebp], 0
	jbe	SHORT $LN7@PlotSSPart@2

; 1968 : 	{
; 1969 : 		ExecuteSSPartAdds();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteSSPartAdds
$LN7@PlotSSPart@2:

; 1970 : 	}
; 1971 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotSSPartAdds@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225653[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotSSPartAdds@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotSSPartAdds@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotSSPartAdds@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotSSPartAdds
PUBLIC	?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteTreasureMoves
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotTreasureMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotTreasureMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotTreasureMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotTreasureMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotTreasureMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T245739 = -84						; size = 4
$T245716 = -76						; size = 4
$T245707 = -72						; size = 4
$T245703 = -68						; size = 4
$T245696 = -64						; size = 4
$T245686 = -60						; size = 4
$T245656 = -56						; size = 4
$T245623 = -52						; size = 4
$T245614 = -48						; size = 4
$T245608 = -44						; size = 4
_unit$225674 = -40					; size = 16
_pUnit$225671 = -24					; size = 8
_it$225665 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotTreasureMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotTreasureMoves, COMDAT
; _this$ = ecx

; 1975 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotTreasureMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1976 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 1977 : 
; 1978 : 	// Loop through all recruited units
; 1979 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245614[ebp], ecx
	mov	edx, DWORD PTR $T245614[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T245623[ebp], eax
	mov	ecx, DWORD PTR $T245623[ebp]
	mov	DWORD PTR _it$225665[ebp], ecx
	jmp	SHORT $LN6@PlotTreasu
$LN22@PlotTreasu:
	mov	edx, DWORD PTR _it$225665[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225665[ebp], eax
$LN6@PlotTreasu:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245656[ebp], edx
	mov	eax, DWORD PTR $T245656[ebp]
	mov	DWORD PTR $T245608[ebp], eax
	mov	ecx, DWORD PTR _it$225665[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T245608[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@PlotTreasu

; 1980 : 	{
; 1981 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225665[ebp]
	add	edx, 8
	mov	DWORD PTR $T245686[ebp], edx
	mov	eax, DWORD PTR $T245686[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T245696[ebp], eax
	mov	eax, DWORD PTR $T245696[ebp]
	mov	DWORD PTR _pUnit$225671[ebp], eax
	mov	BYTE PTR _pUnit$225671[ebp+4], 0
	cmp	DWORD PTR _pUnit$225671[ebp], 0
	je	SHORT $LN41@PlotTreasu
	mov	ecx, DWORD PTR _pUnit$225671[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@PlotTreasu:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1982 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225671[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@PlotTreasu

; 1983 : 		{
; 1984 : 			if(pUnit->AI_getUnitAIType() == UNITAI_TREASURE)

	mov	eax, DWORD PTR _pUnit$225671[ebp]
	mov	DWORD PTR $T245703[ebp], eax
	mov	ecx, DWORD PTR $T245703[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN3@PlotTreasu

; 1985 : 			{
; 1986 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225674[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 1987 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225671[ebp]
	mov	DWORD PTR $T245707[ebp], ecx
	mov	edx, DWORD PTR $T245707[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T245716[ebp], eax
	mov	ecx, DWORD PTR $T245716[ebp]
	mov	DWORD PTR _unit$225674[ebp], ecx

; 1988 : 				m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225674[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN3@PlotTreasu:

; 1989 : 			}
; 1990 : 		}
; 1991 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225671[ebp], 0
	je	SHORT $LN65@PlotTreasu
	mov	ecx, DWORD PTR _pUnit$225671[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN65@PlotTreasu:
	jmp	$LN22@PlotTreasu
$LN4@PlotTreasu:

; 1992 : 
; 1993 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T245739[ebp], ecx
	cmp	DWORD PTR $T245739[ebp], 0
	jbe	SHORT $LN7@PlotTreasu

; 1994 : 	{
; 1995 : 		ExecuteTreasureMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteTreasureMoves
$LN7@PlotTreasu:

; 1996 : 	}
; 1997 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotTreasureMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225671[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotTreasureMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotTreasureMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotTreasureMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotTreasureMoves
PUBLIC	?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteGeneralMoves
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotGeneralMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotGeneralMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotGeneralMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotGeneralMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotGeneralMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T245879 = -84						; size = 4
$T245856 = -76						; size = 4
$T245847 = -72						; size = 4
$T245843 = -68						; size = 4
$T245836 = -64						; size = 4
$T245826 = -60						; size = 4
$T245796 = -56						; size = 4
$T245763 = -52						; size = 4
$T245754 = -48						; size = 4
$T245748 = -44						; size = 4
_unit$225692 = -40					; size = 16
_pUnit$225689 = -24					; size = 8
_it$225683 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotGeneralMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotGeneralMoves, COMDAT
; _this$ = ecx

; 2001 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotGeneralMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2002 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 2003 : 
; 2004 : 	// Loop through all recruited units
; 2005 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245754[ebp], ecx
	mov	edx, DWORD PTR $T245754[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T245763[ebp], eax
	mov	ecx, DWORD PTR $T245763[ebp]
	mov	DWORD PTR _it$225683[ebp], ecx
	jmp	SHORT $LN6@PlotGenera
$LN22@PlotGenera:
	mov	edx, DWORD PTR _it$225683[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225683[ebp], eax
$LN6@PlotGenera:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245796[ebp], edx
	mov	eax, DWORD PTR $T245796[ebp]
	mov	DWORD PTR $T245748[ebp], eax
	mov	ecx, DWORD PTR _it$225683[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T245748[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@PlotGenera

; 2006 : 	{
; 2007 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225683[ebp]
	add	edx, 8
	mov	DWORD PTR $T245826[ebp], edx
	mov	eax, DWORD PTR $T245826[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T245836[ebp], eax
	mov	eax, DWORD PTR $T245836[ebp]
	mov	DWORD PTR _pUnit$225689[ebp], eax
	mov	BYTE PTR _pUnit$225689[ebp+4], 0
	cmp	DWORD PTR _pUnit$225689[ebp], 0
	je	SHORT $LN41@PlotGenera
	mov	ecx, DWORD PTR _pUnit$225689[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@PlotGenera:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2008 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225689[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@PlotGenera

; 2009 : 		{
; 2010 : 			if(pUnit->AI_getUnitAIType() == UNITAI_GENERAL)

	mov	eax, DWORD PTR _pUnit$225689[ebp]
	mov	DWORD PTR $T245843[ebp], eax
	mov	ecx, DWORD PTR $T245843[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN3@PlotGenera

; 2011 : 			{
; 2012 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225692[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 2013 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225689[ebp]
	mov	DWORD PTR $T245847[ebp], ecx
	mov	edx, DWORD PTR $T245847[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T245856[ebp], eax
	mov	ecx, DWORD PTR $T245856[ebp]
	mov	DWORD PTR _unit$225692[ebp], ecx

; 2014 : 				m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225692[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN3@PlotGenera:

; 2015 : 			}
; 2016 : 		}
; 2017 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225689[ebp], 0
	je	SHORT $LN65@PlotGenera
	mov	ecx, DWORD PTR _pUnit$225689[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN65@PlotGenera:
	jmp	$LN22@PlotGenera
$LN4@PlotGenera:

; 2018 : 
; 2019 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T245879[ebp], ecx
	cmp	DWORD PTR $T245879[ebp], 0
	jbe	SHORT $LN7@PlotGenera

; 2020 : 	{
; 2021 : 		ExecuteGeneralMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteGeneralMoves
$LN7@PlotGenera:

; 2022 : 	}
; 2023 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotGeneralMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225689[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotGeneralMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotGeneralMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotGeneralMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotGeneralMoves
PUBLIC	?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteAdmiralMoves
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T246019 = -84						; size = 4
$T245996 = -76						; size = 4
$T245987 = -72						; size = 4
$T245983 = -68						; size = 4
$T245976 = -64						; size = 4
$T245966 = -60						; size = 4
$T245936 = -56						; size = 4
$T245903 = -52						; size = 4
$T245894 = -48						; size = 4
$T245888 = -44						; size = 4
_unit$225710 = -40					; size = 16
_pUnit$225707 = -24					; size = 8
_it$225701 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotAdmiralMoves, COMDAT
; _this$ = ecx

; 2027 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2028 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 2029 : 
; 2030 : 	// Loop through all recruited units
; 2031 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245894[ebp], ecx
	mov	edx, DWORD PTR $T245894[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T245903[ebp], eax
	mov	ecx, DWORD PTR $T245903[ebp]
	mov	DWORD PTR _it$225701[ebp], ecx
	jmp	SHORT $LN6@PlotAdmira
$LN22@PlotAdmira:
	mov	edx, DWORD PTR _it$225701[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225701[ebp], eax
$LN6@PlotAdmira:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245936[ebp], edx
	mov	eax, DWORD PTR $T245936[ebp]
	mov	DWORD PTR $T245888[ebp], eax
	mov	ecx, DWORD PTR _it$225701[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T245888[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@PlotAdmira

; 2032 : 	{
; 2033 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225701[ebp]
	add	edx, 8
	mov	DWORD PTR $T245966[ebp], edx
	mov	eax, DWORD PTR $T245966[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T245976[ebp], eax
	mov	eax, DWORD PTR $T245976[ebp]
	mov	DWORD PTR _pUnit$225707[ebp], eax
	mov	BYTE PTR _pUnit$225707[ebp+4], 0
	cmp	DWORD PTR _pUnit$225707[ebp], 0
	je	SHORT $LN41@PlotAdmira
	mov	ecx, DWORD PTR _pUnit$225707[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@PlotAdmira:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2034 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225707[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@PlotAdmira

; 2035 : 		{
; 2036 : 			if(pUnit->AI_getUnitAIType() == UNITAI_ADMIRAL)

	mov	eax, DWORD PTR _pUnit$225707[ebp]
	mov	DWORD PTR $T245983[ebp], eax
	mov	ecx, DWORD PTR $T245983[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN3@PlotAdmira

; 2037 : 			{
; 2038 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225710[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 2039 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225707[ebp]
	mov	DWORD PTR $T245987[ebp], ecx
	mov	edx, DWORD PTR $T245987[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T245996[ebp], eax
	mov	ecx, DWORD PTR $T245996[ebp]
	mov	DWORD PTR _unit$225710[ebp], ecx

; 2040 : 				m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225710[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN3@PlotAdmira:

; 2041 : 			}
; 2042 : 		}
; 2043 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225707[ebp], 0
	je	SHORT $LN65@PlotAdmira
	mov	ecx, DWORD PTR _pUnit$225707[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN65@PlotAdmira:
	jmp	$LN22@PlotAdmira
$LN4@PlotAdmira:

; 2044 : 
; 2045 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T246019[ebp], ecx
	cmp	DWORD PTR $T246019[ebp], 0
	jbe	SHORT $LN7@PlotAdmira

; 2046 : 	{
; 2047 : 		ExecuteAdmiralMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteAdmiralMoves
$LN7@PlotAdmira:

; 2048 : 	}
; 2049 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225707[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotAdmiralMoves
PUBLIC	?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteAircraftMoves
EXTRN	?getDamage@CvUnit@@QBEHXZ:PROC			; CvUnit::getDamage
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotAircraftMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotAircraftMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotAircraftMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotAircraftMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotAircraftMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T246163 = -88						; size = 4
$T246140 = -80						; size = 4
$T246131 = -76						; size = 4
$T246127 = -72						; size = 4
$T246123 = -68						; size = 4
$T246116 = -64						; size = 4
$T246106 = -60						; size = 4
$T246076 = -56						; size = 4
$T246043 = -52						; size = 4
$T246034 = -48						; size = 4
$T246028 = -44						; size = 4
_unit$225728 = -40					; size = 16
_pUnit$225725 = -24					; size = 8
_it$225719 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotAircraftMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotAircraftMoves, COMDAT
; _this$ = ecx

; 2053 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotAircraftMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2054 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 2055 : 
; 2056 : 	// Loop through all recruited units
; 2057 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T246034[ebp], ecx
	mov	edx, DWORD PTR $T246034[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T246043[ebp], eax
	mov	ecx, DWORD PTR $T246043[ebp]
	mov	DWORD PTR _it$225719[ebp], ecx
	jmp	SHORT $LN6@PlotAircra
$LN22@PlotAircra:
	mov	edx, DWORD PTR _it$225719[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225719[ebp], eax
$LN6@PlotAircra:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T246076[ebp], edx
	mov	eax, DWORD PTR $T246076[ebp]
	mov	DWORD PTR $T246028[ebp], eax
	mov	ecx, DWORD PTR _it$225719[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T246028[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@PlotAircra

; 2058 : 	{
; 2059 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225719[ebp]
	add	edx, 8
	mov	DWORD PTR $T246106[ebp], edx
	mov	eax, DWORD PTR $T246106[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T246116[ebp], eax
	mov	eax, DWORD PTR $T246116[ebp]
	mov	DWORD PTR _pUnit$225725[ebp], eax
	mov	BYTE PTR _pUnit$225725[ebp+4], 0
	cmp	DWORD PTR _pUnit$225725[ebp], 0
	je	SHORT $LN41@PlotAircra
	mov	ecx, DWORD PTR _pUnit$225725[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@PlotAircra:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2060 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225725[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@PlotAircra

; 2061 : 		{
; 2062 : 			if(pUnit->getDomainType() == DOMAIN_AIR && pUnit->getDamage() < 50)

	mov	eax, DWORD PTR _pUnit$225725[ebp]
	mov	DWORD PTR $T246123[ebp], eax
	mov	ecx, DWORD PTR $T246123[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN3@PlotAircra
	mov	ecx, DWORD PTR _pUnit$225725[ebp]
	mov	DWORD PTR $T246127[ebp], ecx
	mov	ecx, DWORD PTR $T246127[ebp]
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	cmp	eax, 50					; 00000032H
	jge	SHORT $LN3@PlotAircra

; 2063 : 			{
; 2064 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225728[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 2065 : 				unit.SetID(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$225725[ebp]
	mov	DWORD PTR $T246131[ebp], edx
	mov	eax, DWORD PTR $T246131[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T246140[ebp], ecx
	mov	edx, DWORD PTR $T246140[ebp]
	mov	DWORD PTR _unit$225728[ebp], edx

; 2066 : 				m_CurrentMoveUnits.push_back(unit);

	lea	eax, DWORD PTR _unit$225728[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN3@PlotAircra:

; 2067 : 			}
; 2068 : 		}
; 2069 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225725[ebp], 0
	je	SHORT $LN67@PlotAircra
	mov	ecx, DWORD PTR _pUnit$225725[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN67@PlotAircra:
	jmp	$LN22@PlotAircra
$LN4@PlotAircra:

; 2070 : 
; 2071 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T246163[ebp], edx
	cmp	DWORD PTR $T246163[ebp], 0
	jbe	SHORT $LN7@PlotAircra

; 2072 : 	{
; 2073 : 		ExecuteAircraftMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteAircraftMoves
$LN7@PlotAircra:

; 2074 : 	}
; 2075 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotAircraftMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225725[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotAircraftMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotAircraftMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotAircraftMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotAircraftMoves
PUBLIC	?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteTradeUnitMoves
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T246303 = -84						; size = 4
$T246280 = -76						; size = 4
$T246271 = -72						; size = 4
$T246267 = -68						; size = 4
$T246260 = -64						; size = 4
$T246250 = -60						; size = 4
$T246220 = -56						; size = 4
$T246187 = -52						; size = 4
$T246178 = -48						; size = 4
$T246172 = -44						; size = 4
_unit$225746 = -40					; size = 16
_pUnit$225743 = -24					; size = 8
_it$225737 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotTradeUnitMoves, COMDAT
; _this$ = ecx

; 2079 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2080 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 2081 : 
; 2082 : 	// Loop through all recruited units
; 2083 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T246178[ebp], ecx
	mov	edx, DWORD PTR $T246178[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T246187[ebp], eax
	mov	ecx, DWORD PTR $T246187[ebp]
	mov	DWORD PTR _it$225737[ebp], ecx
	jmp	SHORT $LN6@PlotTradeU
$LN22@PlotTradeU:
	mov	edx, DWORD PTR _it$225737[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225737[ebp], eax
$LN6@PlotTradeU:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T246220[ebp], edx
	mov	eax, DWORD PTR $T246220[ebp]
	mov	DWORD PTR $T246172[ebp], eax
	mov	ecx, DWORD PTR _it$225737[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T246172[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@PlotTradeU

; 2084 : 	{
; 2085 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225737[ebp]
	add	edx, 8
	mov	DWORD PTR $T246250[ebp], edx
	mov	eax, DWORD PTR $T246250[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T246260[ebp], eax
	mov	eax, DWORD PTR $T246260[ebp]
	mov	DWORD PTR _pUnit$225743[ebp], eax
	mov	BYTE PTR _pUnit$225743[ebp+4], 0
	cmp	DWORD PTR _pUnit$225743[ebp], 0
	je	SHORT $LN41@PlotTradeU
	mov	ecx, DWORD PTR _pUnit$225743[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@PlotTradeU:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2086 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225743[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@PlotTradeU

; 2087 : 		{
; 2088 : 			if(pUnit->AI_getUnitAIType() == UNITAI_TRADE_UNIT)

	mov	eax, DWORD PTR _pUnit$225743[ebp]
	mov	DWORD PTR $T246267[ebp], eax
	mov	ecx, DWORD PTR $T246267[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 38					; 00000026H
	jne	SHORT $LN3@PlotTradeU

; 2089 : 			{
; 2090 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225746[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 2091 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225743[ebp]
	mov	DWORD PTR $T246271[ebp], ecx
	mov	edx, DWORD PTR $T246271[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T246280[ebp], eax
	mov	ecx, DWORD PTR $T246280[ebp]
	mov	DWORD PTR _unit$225746[ebp], ecx

; 2092 : 				m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225746[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN3@PlotTradeU:

; 2093 : 			}
; 2094 : 		}
; 2095 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225743[ebp], 0
	je	SHORT $LN65@PlotTradeU
	mov	ecx, DWORD PTR _pUnit$225743[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN65@PlotTradeU:
	jmp	$LN22@PlotTradeU
$LN4@PlotTradeU:

; 2096 : 
; 2097 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T246303[ebp], ecx
	cmp	DWORD PTR $T246303[ebp], 0
	jbe	SHORT $LN7@PlotTradeU

; 2098 : 	{
; 2099 : 		ExecuteTradeUnitMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteTradeUnitMoves
$LN7@PlotTradeU:

; 2100 : 	}
; 2101 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225743[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotTradeUnitMoves
PUBLIC	?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteArchaeologistMoves
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T246443 = -84						; size = 4
$T246420 = -76						; size = 4
$T246411 = -72						; size = 4
$T246407 = -68						; size = 4
$T246400 = -64						; size = 4
$T246390 = -60						; size = 4
$T246360 = -56						; size = 4
$T246327 = -52						; size = 4
$T246318 = -48						; size = 4
$T246312 = -44						; size = 4
_unit$225764 = -40					; size = 16
_pUnit$225761 = -24					; size = 8
_it$225755 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::PlotArchaeologistMoves, COMDAT
; _this$ = ecx

; 2105 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2106 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 2107 : 
; 2108 : 	// Loop through all recruited units
; 2109 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T246318[ebp], ecx
	mov	edx, DWORD PTR $T246318[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T246327[ebp], eax
	mov	ecx, DWORD PTR $T246327[ebp]
	mov	DWORD PTR _it$225755[ebp], ecx
	jmp	SHORT $LN6@PlotArchae
$LN22@PlotArchae:
	mov	edx, DWORD PTR _it$225755[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225755[ebp], eax
$LN6@PlotArchae:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T246360[ebp], edx
	mov	eax, DWORD PTR $T246360[ebp]
	mov	DWORD PTR $T246312[ebp], eax
	mov	ecx, DWORD PTR _it$225755[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T246312[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@PlotArchae

; 2110 : 	{
; 2111 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$225755[ebp]
	add	edx, 8
	mov	DWORD PTR $T246390[ebp], edx
	mov	eax, DWORD PTR $T246390[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T246400[ebp], eax
	mov	eax, DWORD PTR $T246400[ebp]
	mov	DWORD PTR _pUnit$225761[ebp], eax
	mov	BYTE PTR _pUnit$225761[ebp+4], 0
	cmp	DWORD PTR _pUnit$225761[ebp], 0
	je	SHORT $LN41@PlotArchae
	mov	ecx, DWORD PTR _pUnit$225761[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@PlotArchae:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2112 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$225761[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@PlotArchae

; 2113 : 		{
; 2114 : 			if(pUnit->AI_getUnitAIType() == UNITAI_ARCHAEOLOGIST)

	mov	eax, DWORD PTR _pUnit$225761[ebp]
	mov	DWORD PTR $T246407[ebp], eax
	mov	ecx, DWORD PTR $T246407[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN3@PlotArchae

; 2115 : 			{
; 2116 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$225764[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 2117 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$225761[ebp]
	mov	DWORD PTR $T246411[ebp], ecx
	mov	edx, DWORD PTR $T246411[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T246420[ebp], eax
	mov	ecx, DWORD PTR $T246420[ebp]
	mov	DWORD PTR _unit$225764[ebp], ecx

; 2118 : 				m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225764[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN3@PlotArchae:

; 2119 : 			}
; 2120 : 		}
; 2121 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$225761[ebp], 0
	je	SHORT $LN65@PlotArchae
	mov	ecx, DWORD PTR _pUnit$225761[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN65@PlotArchae:
	jmp	$LN22@PlotArchae
$LN4@PlotArchae:

; 2122 : 
; 2123 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T246443[ebp], ecx
	cmp	DWORD PTR $T246443[ebp], 0
	jbe	SHORT $LN7@PlotArchae

; 2124 : 	{
; 2125 : 		ExecuteArchaeologistMoves();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteArchaeologistMoves
$LN7@PlotArchae:

; 2126 : 	}
; 2127 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225761[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::PlotArchaeologistMoves
PUBLIC	??1?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::~_Vector_val<CvPlot *,std::allocator<CvPlot *> >
PUBLIC	??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::~vector<CvPlot *,std::allocator<CvPlot *> >
PUBLIC	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >
PUBLIC	??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
PUBLIC	?_Tidy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Tidy
PUBLIC	??_C@_0CM@EMCOHALM@Moving?5to?5airlift?5origin?5plot?0?5X@ ; `string'
PUBLIC	?push_back@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::push_back
PUBLIC	??_C@_0DJ@NHADHCHH@Remaining?5in?5place?5for?5future?5ai@ ; `string'
PUBLIC	??$_Find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z ; std::_Find<std::list<int,std::allocator<int> >::_Iterator<0>,int>
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
PUBLIC	??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::vector<CvPlot *,std::allocator<CvPlot *> >
PUBLIC	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
PUBLIC	?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back
PUBLIC	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
PUBLIC	__$ArrayPad$
EXTRN	?getName@CvUnit@@QBE?BVCvString@@XZ:PROC	; CvUnit::getName
EXTRN	?GetZoneByCity@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@PAVCvCity@@_N@Z:PROC ; CvTacticalAnalysisMap::GetZoneByCity
EXTRN	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ:PROC ; CvGame::GetTacticalAnalysisMap
EXTRN	?CanAirlift@CvCity@@QBE_NXZ:PROC		; CvCity::CanAirlift
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
;	COMDAT ??_C@_0CM@EMCOHALM@Moving?5to?5airlift?5origin?5plot?0?5X@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
??_C@_0CM@EMCOHALM@Moving?5to?5airlift?5origin?5plot?0?5X@ DB 'Moving to '
	DB	'airlift origin plot, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@NHADHCHH@Remaining?5in?5place?5for?5future?5ai@
CONST	SEGMENT
??_C@_0DJ@NHADHCHH@Remaining?5in?5place?5for?5future?5ai@ DB 'Remaining i'
	DB	'n place for future airlift - %s, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$7
	DD	00H
	DD	FLAT:__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$1
	DD	02H
	DD	FLAT:__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$2
	DD	03H
	DD	FLAT:__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$3
	DD	04H
	DD	FLAT:__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$4
	DD	02H
	DD	FLAT:__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$5
	DD	00H
	DD	FLAT:__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$17
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotAirliftMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv194 = -564						; size = 4
_this$ = -560						; size = 4
$T247046 = -500						; size = 4
$T247035 = -496						; size = 4
$T247031 = -492						; size = 4
$T247013 = -488						; size = 4
__Tmp$247003 = -484					; size = 4
$T246988 = -480						; size = 4
$T246923 = -452						; size = 4
$T246919 = -448						; size = 4
$T246915 = -444						; size = 4
$T246906 = -440						; size = 4
$T246902 = -436						; size = 4
$T246893 = -432						; size = 4
$T246885 = -428						; size = 4
$T246876 = -424						; size = 4
$T246861 = -420						; size = 4
$T246860 = -416						; size = 4
$T246858 = -412						; size = 4
$T246846 = -408						; size = 4
$T246837 = -404						; size = 4
$T246826 = -400						; size = 4
$T246810 = -396						; size = 4
$T246800 = -392						; size = 4
$T246791 = -388						; size = 4
$T246784 = -384						; size = 4
$T246775 = -380						; size = 4
$T246766 = -376						; size = 4
$T246629 = -300						; size = 4
$T246620 = -296						; size = 4
$T246616 = -292						; size = 4
$T246607 = -288						; size = 4
$T246603 = -284						; size = 4
$T246599 = -280						; size = 4
$T246595 = -276						; size = 4
$T246577 = -272						; size = 4
__Tmp$246564 = -268					; size = 4
$T246552 = -264						; size = 4
$T246539 = -260						; size = 4
$T246464 = -220						; size = 4
$T246463 = -216						; size = 4
$T246462 = -212						; size = 4
$T246461 = -208						; size = 28
$T246460 = -180						; size = 4
$T246459 = -176						; size = 4
$T246458 = -172						; size = 4
$T246457 = -168						; size = 4
$T246456 = -164						; size = 4
$T246455 = -160						; size = 4
$T246454 = -156						; size = 4
$T246453 = -152						; size = 4
_strLogString$226434 = -148				; size = 28
_pTarget$226431 = -120					; size = 4
_strLogString$226268 = -116				; size = 28
__$ArrayPad$ = -88					; size = 4
_pBestDefender$226251 = -84				; size = 8
_pLoopPlot$226248 = -76					; size = 4
_iI$226244 = -72					; size = 4
_pZone$ = -68						; size = 4
_iCityLoop$ = -64					; size = 4
_plotIt$ = -60						; size = 4
_aAirliftPlots$ = -56					; size = 16
_aAirliftCities$ = -40					; size = 16
_pMap$ = -24						; size = 4
_pLoopCity$ = -20					; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?PlotAirliftMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotAirliftMoves, COMDAT
; _this$ = ecx

; 2131 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 552				; 00000228H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2132 : 	if (m_pPlayer->isHuman())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN25@PlotAirlif

; 2133 : 	{
; 2134 : 		return;

	jmp	$LN26@PlotAirlif
$LN25@PlotAirlif:

; 2135 : 	}
; 2136 : 
; 2137 : 	// Need at least 2 cities with airports
; 2138 : 	vector<CvCity *> aAirliftCities;

	lea	ecx, DWORD PTR _aAirliftCities$[ebp]
	call	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2139 : 	CvCity *pLoopCity;
; 2140 : 	int iCityLoop;
; 2141 : 	for (pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iCityLoop))

	push	0
	lea	edx, DWORD PTR _iCityLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN24@PlotAirlif
$LN23@PlotAirlif:
	push	0
	lea	ecx, DWORD PTR _iCityLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN24@PlotAirlif:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN55@PlotAirlif

; 2142 : 	{
; 2143 : 		if (pLoopCity->CanAirlift())

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?CanAirlift@CvCity@@QBE_NXZ		; CvCity::CanAirlift
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN21@PlotAirlif

; 2144 : 		{
; 2145 : 			aAirliftCities.push_back(pLoopCity);

	lea	ecx, DWORD PTR _pLoopCity$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _aAirliftCities$[ebp]
	call	?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back
$LN21@PlotAirlif:

; 2146 : 		}
; 2147 : 	}

	jmp	SHORT $LN23@PlotAirlif

; 2148 : 	if (aAirliftCities.size() < 2)

$LN55@PlotAirlif:
	mov	edx, DWORD PTR _aAirliftCities$[ebp+8]
	sub	edx, DWORD PTR _aAirliftCities$[ebp+4]
	sar	edx, 2
	cmp	edx, 2
	jae	SHORT $LN20@PlotAirlif

; 2149 : 	{
; 2150 : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _aAirliftCities$[ebp]
	call	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	jmp	$LN26@PlotAirlif
$LN20@PlotAirlif:

; 2151 : 	}
; 2152 : 
; 2153 : 	// Create list of empty land plots we own adjacent to airlift cities that are not endangered
; 2154 : 	vector<CvPlot *> aAirliftPlots;

	lea	ecx, DWORD PTR _aAirliftPlots$[ebp]
	call	??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::vector<CvPlot *,std::allocator<CvPlot *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 2155 : 	CvTacticalAnalysisMap* pMap = GC.getGame().GetTacticalAnalysisMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T246539[ebp], eax
	mov	ecx, DWORD PTR $T246539[ebp]
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap
	mov	DWORD PTR _pMap$[ebp], eax

; 2156 : 	CvTacticalDominanceZone *pZone;
; 2157 : 	vector<CvCity *>::const_iterator it;

	mov	DWORD PTR _it$[ebp], 0

; 2158 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 2159 : 	for (it = aAirliftCities.begin(); it != aAirliftCities.end(); ++it)
; 2160 : #else
; 2161 : 	for (it = aAirliftCities.begin(); it != aAirliftCities.end(); it++)

	mov	ecx, DWORD PTR _aAirliftCities$[ebp+4]
	mov	DWORD PTR $T246552[ebp], ecx
	mov	edx, DWORD PTR $T246552[ebp]
	mov	DWORD PTR $T246453[ebp], edx
	mov	eax, DWORD PTR $T246453[ebp]
	mov	DWORD PTR _it$[ebp], eax
	jmp	SHORT $LN19@PlotAirlif
$LN18@PlotAirlif:
	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR __Tmp$246564[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 4
	mov	DWORD PTR _it$[ebp], edx
	mov	eax, DWORD PTR __Tmp$246564[ebp]
	mov	DWORD PTR $T246454[ebp], eax
$LN19@PlotAirlif:
	mov	ecx, DWORD PTR _aAirliftCities$[ebp+8]
	mov	DWORD PTR $T246577[ebp], ecx
	mov	edx, DWORD PTR $T246577[ebp]
	mov	DWORD PTR $T246455[ebp], edx
	mov	eax, DWORD PTR _it$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T246455[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN17@PlotAirlif

; 2162 : #endif
; 2163 : 	{
; 2164 : 		pZone = pMap->GetZoneByCity(*it, false);

	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T246595[ebp], ecx
	push	0
	mov	edx, DWORD PTR $T246595[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pMap$[ebp]
	call	?GetZoneByCity@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@PAVCvCity@@_N@Z ; CvTacticalAnalysisMap::GetZoneByCity
	mov	DWORD PTR _pZone$[ebp], eax

; 2165 : 		if (pZone && (pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_FRIENDLY || pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_NO_UNITS_VISIBLE))

	cmp	DWORD PTR _pZone$[ebp], 0
	je	$LN16@PlotAirlif
	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T246599[ebp], edx
	cmp	DWORD PTR $T246599[ebp], 1
	je	SHORT $LN15@PlotAirlif
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T246603[ebp], ecx
	cmp	DWORD PTR $T246603[ebp], 0
	jne	$LN16@PlotAirlif
$LN15@PlotAirlif:

; 2166 : 		{
; 2167 : 			for (int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	DWORD PTR _iI$226244[ebp], 0
	jmp	SHORT $LN14@PlotAirlif
$LN13@PlotAirlif:
	mov	edx, DWORD PTR _iI$226244[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$226244[ebp], edx
$LN14@PlotAirlif:
	cmp	DWORD PTR _iI$226244[ebp], 6
	jge	$LN16@PlotAirlif

; 2168 : 			{
; 2169 : 				CvPlot *pLoopPlot = plotDirection((*it)->getX(), (*it)->getY(), ((DirectionTypes)iI));

	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T246607[ebp], eax
	mov	ecx, DWORD PTR $T246607[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T246616[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T246620[ebp], ecx
	mov	edx, DWORD PTR $T246620[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T246629[ebp], ecx
	mov	edx, DWORD PTR _iI$226244[ebp]
	push	edx
	mov	eax, DWORD PTR $T246616[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246629[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$226248[ebp], eax

; 2170 : 				if (pLoopPlot != NULL && !pLoopPlot->isWater() && !pLoopPlot->isMountain() && pLoopPlot->getOwner() == m_pPlayer->GetID())

	cmp	DWORD PTR _pLoopPlot$226248[ebp], 0
	je	$LN11@PlotAirlif
	mov	edx, DWORD PTR _pLoopPlot$226248[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	$LN11@PlotAirlif
	mov	eax, DWORD PTR _pLoopPlot$226248[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	jne	$LN11@PlotAirlif
	mov	eax, DWORD PTR _pLoopPlot$226248[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T246766[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T246775[ebp], ecx
	mov	edx, DWORD PTR $T246766[ebp]
	cmp	edx, DWORD PTR $T246775[ebp]
	jne	$LN11@PlotAirlif

; 2171 : 				{
; 2172 : 					UnitHandle pBestDefender = pLoopPlot->getBestDefender(m_pPlayer->GetID());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T246784[ebp], edx
	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	mov	eax, DWORD PTR $T246784[ebp]
	push	eax
	lea	ecx, DWORD PTR _pBestDefender$226251[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopPlot$226248[ebp]
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 2173 : 					if (pBestDefender)

	xor	edx, edx
	cmp	DWORD PTR _pBestDefender$226251[ebp], 0
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN10@PlotAirlif

; 2174 : 					{
; 2175 : 						if (std::find(m_CurrentTurnUnits.begin(), m_CurrentTurnUnits.end(), pBestDefender->GetID()) != m_CurrentTurnUnits.end())

	mov	ecx, DWORD PTR _pBestDefender$226251[ebp]
	mov	DWORD PTR $T246791[ebp], ecx
	mov	edx, DWORD PTR $T246791[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T246800[ebp], eax
	mov	ecx, DWORD PTR $T246800[ebp]
	mov	DWORD PTR $T246456[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T246810[ebp], eax
	mov	ecx, DWORD PTR $T246810[ebp]
	mov	DWORD PTR $T246460[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T246826[ebp], eax
	mov	ecx, DWORD PTR $T246826[ebp]
	mov	DWORD PTR $T246457[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T246837[ebp], eax
	mov	ecx, DWORD PTR $T246837[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T246846[ebp], edx
	mov	eax, DWORD PTR $T246846[ebp]
	mov	DWORD PTR $T246458[ebp], eax
	mov	ecx, DWORD PTR $T246457[ebp]
	mov	DWORD PTR $T246861[ebp], ecx
	mov	edx, DWORD PTR $T246458[ebp]
	mov	DWORD PTR $T246860[ebp], edx
	lea	eax, DWORD PTR $T246456[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246861[ebp]
	push	ecx
	mov	edx, DWORD PTR $T246860[ebp]
	push	edx
	lea	eax, DWORD PTR $T246858[ebp]
	push	eax
	call	??$_Find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z ; std::_Find<std::list<int,std::allocator<int> >::_Iterator<0>,int>
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T246860[ebp], ecx
	mov	edx, DWORD PTR $T246860[ebp]
	mov	DWORD PTR $T246459[ebp], edx
	mov	eax, DWORD PTR $T246459[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T246460[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN9@PlotAirlif

; 2176 : 						{
; 2177 : 							pBestDefender->finishMoves();

	mov	ecx, DWORD PTR _pBestDefender$226251[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 2178 : 							UnitProcessed(pBestDefender->GetID());

	mov	ecx, DWORD PTR _pBestDefender$226251[ebp]
	mov	DWORD PTR $T246876[ebp], ecx
	mov	edx, DWORD PTR $T246876[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T246885[ebp], eax
	mov	ecx, DWORD PTR $T246885[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 2179 : 							if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN9@PlotAirlif
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	$LN9@PlotAirlif

; 2180 : 							{
; 2181 : 								CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226268[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 2182 : 								strLogString.Format("Remaining in place for future airlift - %s, X: %d, Y: %d", pBestDefender->getName().GetCString(), pBestDefender->getX(), pBestDefender->getY());

	mov	ecx, DWORD PTR _pBestDefender$226251[ebp]
	mov	DWORD PTR $T246919[ebp], ecx
	lea	edx, DWORD PTR $T246461[ebp]
	push	edx
	mov	ecx, DWORD PTR $T246919[ebp]
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	DWORD PTR tv194[ebp], eax
	mov	eax, DWORD PTR tv194[ebp]
	mov	DWORD PTR $T246923[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _pBestDefender$226251[ebp]
	mov	DWORD PTR $T246893[ebp], ecx
	mov	edx, DWORD PTR $T246893[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T246902[ebp], eax
	mov	ecx, DWORD PTR _pBestDefender$226251[ebp]
	mov	DWORD PTR $T246906[ebp], ecx
	mov	edx, DWORD PTR $T246906[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T246915[ebp], eax
	mov	ecx, DWORD PTR $T246902[ebp]
	push	ecx
	mov	edx, DWORD PTR $T246915[ebp]
	push	edx
	mov	ecx, DWORD PTR $T246923[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0DJ@NHADHCHH@Remaining?5in?5place?5for?5future?5ai@
	lea	eax, DWORD PTR _strLogString$226268[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T246461[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2183 : 								LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$226268[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2184 : 							}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strLogString$226268[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN9@PlotAirlif:

; 2185 : 						}
; 2186 : 					}
; 2187 : 					else

	jmp	SHORT $LN7@PlotAirlif
$LN10@PlotAirlif:

; 2188 : 					{
; 2189 : 						aAirliftPlots.push_back(pLoopPlot);

	lea	edx, DWORD PTR _pLoopPlot$226248[ebp]
	push	edx
	lea	ecx, DWORD PTR _aAirliftPlots$[ebp]
	call	?push_back@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::push_back
$LN7@PlotAirlif:

; 2190 : 					}
; 2191 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR _pBestDefender$226251[ebp], 0
	je	SHORT $LN11@PlotAirlif
	mov	ecx, DWORD PTR _pBestDefender$226251[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN11@PlotAirlif:

; 2192 : 			}

	jmp	$LN13@PlotAirlif
$LN16@PlotAirlif:

; 2193 : 		}
; 2194 : 	}

	jmp	$LN18@PlotAirlif
$LN17@PlotAirlif:

; 2195 : 
; 2196 : 	vector<CvPlot *>::const_iterator plotIt;

	mov	DWORD PTR _plotIt$[ebp], 0

; 2197 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 2198 : 	for (plotIt = aAirliftPlots.begin(); plotIt != aAirliftPlots.end(); ++plotIt)
; 2199 : #else
; 2200 : 	for (plotIt = aAirliftPlots.begin(); plotIt != aAirliftPlots.end(); plotIt++)

	mov	eax, DWORD PTR _aAirliftPlots$[ebp+4]
	mov	DWORD PTR $T246988[ebp], eax
	mov	ecx, DWORD PTR $T246988[ebp]
	mov	DWORD PTR $T246462[ebp], ecx
	mov	edx, DWORD PTR $T246462[ebp]
	mov	DWORD PTR _plotIt$[ebp], edx
	jmp	SHORT $LN6@PlotAirlif
$LN5@PlotAirlif:
	mov	eax, DWORD PTR _plotIt$[ebp]
	mov	DWORD PTR __Tmp$247003[ebp], eax
	mov	ecx, DWORD PTR _plotIt$[ebp]
	add	ecx, 4
	mov	DWORD PTR _plotIt$[ebp], ecx
	mov	edx, DWORD PTR __Tmp$247003[ebp]
	mov	DWORD PTR $T246463[ebp], edx
$LN6@PlotAirlif:
	mov	eax, DWORD PTR _aAirliftPlots$[ebp+8]
	mov	DWORD PTR $T247013[ebp], eax
	mov	ecx, DWORD PTR $T247013[ebp]
	mov	DWORD PTR $T246464[ebp], ecx
	mov	edx, DWORD PTR _plotIt$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T246464[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN4@PlotAirlif

; 2201 : #endif
; 2202 : 	{
; 2203 : 		FindUnitsForThisMove(AI_HOMELAND_MOVE_MOBILE_RESERVE, true);

	push	1
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z ; CvHomelandAI::FindUnitsForThisMove

; 2204 : 
; 2205 : 		if(m_CurrentMoveHighPriorityUnits.size() + m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1060]
	mov	DWORD PTR $T247031[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR $T247035[ebp], eax
	mov	ecx, DWORD PTR $T247031[ebp]
	add	ecx, DWORD PTR $T247035[ebp]
	je	$LN3@PlotAirlif

; 2206 : 		{
; 2207 : 			CvPlot *pTarget = *plotIt;

	mov	edx, DWORD PTR _plotIt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pTarget$226431[ebp], eax

; 2208 : 
; 2209 : 			if (GetBestUnitToReachTarget(pTarget, MAX_INT))

	push	2147483647				; 7fffffffH
	mov	ecx, DWORD PTR _pTarget$226431[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z ; CvHomelandAI::GetBestUnitToReachTarget
	movzx	edx, al
	test	edx, edx
	je	$LN3@PlotAirlif

; 2210 : 			{
; 2211 : 				ExecuteMoveToTarget(pTarget);

	mov	eax, DWORD PTR _pTarget$226431[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget

; 2212 : 
; 2213 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@PlotAirlif
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@PlotAirlif

; 2214 : 				{
; 2215 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226434[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 2216 : 					strLogString.Format("Moving to airlift origin plot, X: %d, Y: %d", pTarget->getX(), pTarget->getY());

	mov	eax, DWORD PTR _pTarget$226431[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T247046[ebp], ecx
	mov	edx, DWORD PTR $T247046[ebp]
	push	edx
	mov	eax, DWORD PTR _pTarget$226431[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0CM@EMCOHALM@Moving?5to?5airlift?5origin?5plot?0?5X@
	lea	edx, DWORD PTR _strLogString$226434[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2217 : 					LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$226434[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2218 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strLogString$226434[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@PlotAirlif:

; 2219 : 			}
; 2220 : 		}
; 2221 : 	}

	jmp	$LN5@PlotAirlif
$LN4@PlotAirlif:

; 2222 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _aAirliftPlots$[ebp]
	call	?_Tidy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR _aAirliftCities$[ebp]
	call	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN26@PlotAirlif:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _aAirliftCities$[ebp]
	jmp	??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _aAirliftCities$[ebp]
	jmp	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _aAirliftPlots$[ebp]
	jmp	??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::~vector<CvPlot *,std::allocator<CvPlot *> >
__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _pBestDefender$226251[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strLogString$226268[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR $T246461[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strLogString$226434[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$15:
	lea	ecx, DWORD PTR _aAirliftPlots$[ebp]
	jmp	??1?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$17:
	lea	ecx, DWORD PTR _aAirliftCities$[ebp]
	jmp	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
__ehhandler$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-556]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotAirliftMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotAirliftMoves
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv198 = -100						; size = 4
tv213 = -96						; size = 4
tv168 = -92						; size = 4
tv151 = -88						; size = 4
tv155 = -84						; size = 4
$T247376 = -80						; size = 4
$T247331 = -76						; size = 4
$T247318 = -72						; size = 4
$T247314 = -68						; size = 4
$T247300 = -64						; size = 4
$T247296 = -57						; size = 1
$T247285 = -56						; size = 4
$T247281 = -49						; size = 1
_iMapY$247375 = -48					; size = 4
_iMapX$247374 = -44					; size = 4
$T247274 = -40						; size = 4
$T247250 = -36						; size = 4
$T247213 = -32						; size = 4
$T247201 = -28						; size = 4
$T247197 = -21						; size = 1
$T247186 = -20						; size = 4
$T247182 = -13						; size = 1
_iMapY$247249 = -12					; size = 4
_iMapX$247248 = -8					; size = 4
$T247175 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 194  : 	if(eDirection == NO_DIRECTION)

	cmp	DWORD PTR _eDirection$[ebp], -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T247175[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@plotDirect
$LN7@plotDirect:
	mov	DWORD PTR $T247250[ebp], 0
	jmp	$LN9@plotDirect
$LN8@plotDirect:
	mov	ecx, DWORD PTR $T247175[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T247182[ebp], dl
	mov	eax, DWORD PTR $T247175[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T247186[ebp], ecx
	movzx	edx, BYTE PTR $T247182[ebp]
	test	edx, edx
	je	SHORT $LN20@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN19@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T247186[ebp]
	add	edx, DWORD PTR $T247186[ebp]
	mov	DWORD PTR _iMapX$247248[ebp], edx
	jmp	SHORT $LN21@plotDirect
	jmp	SHORT $LN20@plotDirect
$LN19@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T247186[ebp]
	jl	SHORT $LN20@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T247186[ebp]
	mov	DWORD PTR _iMapX$247248[ebp], edx
	jmp	SHORT $LN21@plotDirect
$LN20@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$247248[ebp], ecx
$LN21@plotDirect:
	mov	edx, DWORD PTR $T247175[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T247197[ebp], al
	mov	ecx, DWORD PTR $T247175[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T247201[ebp], edx
	movzx	eax, BYTE PTR $T247197[ebp]
	test	eax, eax
	je	SHORT $LN30@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN29@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T247201[ebp]
	add	edx, DWORD PTR $T247201[ebp]
	mov	DWORD PTR _iMapY$247249[ebp], edx
	jmp	SHORT $LN31@plotDirect
	jmp	SHORT $LN30@plotDirect
$LN29@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T247201[ebp]
	jl	SHORT $LN30@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T247201[ebp]
	mov	DWORD PTR _iMapY$247249[ebp], edx
	jmp	SHORT $LN31@plotDirect
$LN30@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$247249[ebp], edx
$LN31@plotDirect:
	mov	eax, DWORD PTR _iMapY$247249[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$247248[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T247175[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN11@plotDirect
	mov	edx, DWORD PTR $T247175[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T247213[ebp], eax
	mov	ecx, DWORD PTR _iMapY$247249[ebp]
	imul	ecx, DWORD PTR $T247213[ebp]
	add	ecx, DWORD PTR _iMapX$247248[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T247175[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv155[ebp], ecx
	jmp	SHORT $LN12@plotDirect
$LN11@plotDirect:
	mov	DWORD PTR tv155[ebp], 0
$LN12@plotDirect:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T247250[ebp], eax
$LN9@plotDirect:
	mov	eax, DWORD PTR $T247250[ebp]
	jmp	$LN3@plotDirect

; 197  : 	}
; 198  : 	else

	jmp	$LN3@plotDirect
$LN2@plotDirect:

; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN39@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv151[ebp], ecx
	jmp	SHORT $LN37@plotDirect
$LN39@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv151[ebp], eax
$LN37@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	sub	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	eax, DWORD PTR _eDirection$[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+112]
	mov	DWORD PTR _iX$[ebp], ecx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	mov	edx, DWORD PTR _eDirection$[ebp]
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+136]
	mov	DWORD PTR _iY$[ebp], eax

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN47@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv168[ebp], ecx
	jmp	SHORT $LN45@plotDirect
$LN47@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv168[ebp], eax
$LN45@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T247274[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN51@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN52@plotDirect
$LN51@plotDirect:
	mov	DWORD PTR $T247376[ebp], 0
	jmp	$LN53@plotDirect
$LN52@plotDirect:
	mov	ecx, DWORD PTR $T247274[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T247281[ebp], dl
	mov	eax, DWORD PTR $T247274[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T247285[ebp], ecx
	movzx	edx, BYTE PTR $T247281[ebp]
	test	edx, edx
	je	SHORT $LN64@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN63@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T247285[ebp]
	add	edx, DWORD PTR $T247285[ebp]
	mov	DWORD PTR _iMapX$247374[ebp], edx
	jmp	SHORT $LN65@plotDirect
	jmp	SHORT $LN64@plotDirect
$LN63@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T247285[ebp]
	jl	SHORT $LN64@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T247285[ebp]
	mov	DWORD PTR _iMapX$247374[ebp], edx
	jmp	SHORT $LN65@plotDirect
$LN64@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$247374[ebp], ecx
$LN65@plotDirect:
	mov	edx, DWORD PTR $T247274[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T247296[ebp], al
	mov	ecx, DWORD PTR $T247274[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T247300[ebp], edx
	movzx	eax, BYTE PTR $T247296[ebp]
	test	eax, eax
	je	SHORT $LN74@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN73@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T247300[ebp]
	add	edx, DWORD PTR $T247300[ebp]
	mov	DWORD PTR _iMapY$247375[ebp], edx
	jmp	SHORT $LN75@plotDirect
	jmp	SHORT $LN74@plotDirect
$LN73@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T247300[ebp]
	jl	SHORT $LN74@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T247300[ebp]
	mov	DWORD PTR _iMapY$247375[ebp], edx
	jmp	SHORT $LN75@plotDirect
$LN74@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$247375[ebp], edx
$LN75@plotDirect:
	cmp	DWORD PTR _iMapX$247374[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T247274[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T247314[ebp], ecx
	mov	edx, DWORD PTR _iMapX$247374[ebp]
	cmp	edx, DWORD PTR $T247314[ebp]
	jge	SHORT $LN79@plotDirect
	cmp	DWORD PTR _iMapY$247375[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T247274[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T247318[ebp], ecx
	mov	edx, DWORD PTR _iMapY$247375[ebp]
	cmp	edx, DWORD PTR $T247318[ebp]
	jge	SHORT $LN79@plotDirect
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN77@plotDirect
$LN79@plotDirect:
	mov	DWORD PTR tv213[ebp], 0
$LN77@plotDirect:
	cmp	DWORD PTR tv213[ebp], 0
	je	SHORT $LN55@plotDirect
	mov	eax, DWORD PTR $T247274[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T247331[ebp], ecx
	mov	edx, DWORD PTR _iMapY$247375[ebp]
	imul	edx, DWORD PTR $T247331[ebp]
	add	edx, DWORD PTR _iMapX$247374[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T247274[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv198[ebp], edx
	jmp	SHORT $LN56@plotDirect
$LN55@plotDirect:
	mov	DWORD PTR tv198[ebp], 0
$LN56@plotDirect:
	mov	ecx, DWORD PTR tv198[ebp]
	mov	DWORD PTR $T247376[ebp], ecx
$LN53@plotDirect:
	mov	eax, DWORD PTR $T247376[ebp]
$LN3@plotDirect:

; 209  : 	}
; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	??_C@_0BP@BONLIPIH@Unassigned?5?$CFs?5at?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?$AA@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?SetTurnProcessed@CvUnit@@QAEX_N@Z:PROC		; CvUnit::SetTurnProcessed
;	COMDAT ??_C@_0BP@BONLIPIH@Unassigned?5?$CFs?5at?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0BP@BONLIPIH@Unassigned?5?$CFs?5at?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?$AA@ DB 'U'
	DB	'nassigned %s at, X: %d, Y: %d', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ$2
__ehfuncinfo$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -144						; size = 4
$T247527 = -140						; size = 4
$T247518 = -136						; size = 4
$T247514 = -132						; size = 4
$T247505 = -128						; size = 4
$T247497 = -124						; size = 4
$T247488 = -120						; size = 4
$T247477 = -116						; size = 4
$T247470 = -112						; size = 4
$T247460 = -108						; size = 4
$T247430 = -104						; size = 4
$T247397 = -100						; size = 4
$T247388 = -96						; size = 4
$T247380 = -92						; size = 4
_strLogString$226454 = -88				; size = 28
_pkUnitInfo$226452 = -60				; size = 4
_strTemp$226451 = -56					; size = 28
__$ArrayPad$ = -28					; size = 4
_pUnit$226449 = -24					; size = 8
_it$226443 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::ReviewUnassignedUnits, COMDAT
; _this$ = ecx

; 2226 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2227 : 	// Loop through all remaining units
; 2228 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T247388[ebp], ecx
	mov	edx, DWORD PTR $T247388[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T247397[ebp], eax
	mov	ecx, DWORD PTR $T247397[ebp]
	mov	DWORD PTR _it$226443[ebp], ecx
	jmp	SHORT $LN5@ReviewUnas
$LN23@ReviewUnas:
	mov	edx, DWORD PTR _it$226443[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$226443[ebp], eax
$LN5@ReviewUnas:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T247430[ebp], edx
	mov	eax, DWORD PTR $T247430[ebp]
	mov	DWORD PTR $T247380[ebp], eax
	mov	ecx, DWORD PTR _it$226443[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T247380[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@ReviewUnas

; 2229 : 	{
; 2230 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$226443[ebp]
	add	edx, 8
	mov	DWORD PTR $T247460[ebp], edx
	mov	eax, DWORD PTR $T247460[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T247470[ebp], eax
	mov	eax, DWORD PTR $T247470[ebp]
	mov	DWORD PTR _pUnit$226449[ebp], eax
	mov	BYTE PTR _pUnit$226449[ebp+4], 0
	cmp	DWORD PTR _pUnit$226449[ebp], 0
	je	SHORT $LN42@ReviewUnas
	mov	ecx, DWORD PTR _pUnit$226449[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN42@ReviewUnas:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2231 : 		if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$226449[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN2@ReviewUnas

; 2232 : 		{
; 2233 : 			pUnit->PushMission(CvTypes::getMISSION_SKIP());

	mov	eax, DWORD PTR _pUnit$226449[ebp]
	mov	DWORD PTR $T247477[ebp], eax
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SKIP
	push	eax
	mov	ecx, DWORD PTR $T247477[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2234 : 			pUnit->SetTurnProcessed(true);

	push	1
	mov	ecx, DWORD PTR _pUnit$226449[ebp]
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed

; 2235 : 
; 2236 : 			CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226451[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2237 : 			CvUnitEntry* pkUnitInfo = GC.getUnitInfo(pUnit->getUnitType());

	mov	ecx, DWORD PTR _pUnit$226449[ebp]
	mov	DWORD PTR $T247488[ebp], ecx
	mov	ecx, DWORD PTR $T247488[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pkUnitInfo$226452[ebp], eax

; 2238 : 			if(pkUnitInfo)

	cmp	DWORD PTR _pkUnitInfo$226452[ebp], 0
	je	$LN1@ReviewUnas

; 2239 : 			{
; 2240 : 				strTemp = pkUnitInfo->GetDescription();

	mov	ecx, DWORD PTR _pkUnitInfo$226452[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T247497[ebp], eax
	cmp	DWORD PTR $T247497[ebp], 0
	je	SHORT $LN60@ReviewUnas
	mov	edx, DWORD PTR $T247497[ebp]
	push	edx
	lea	ecx, DWORD PTR _strTemp$226451[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN61@ReviewUnas
$LN60@ReviewUnas:
	lea	ecx, DWORD PTR _strTemp$226451[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN61@ReviewUnas:

; 2241 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226454[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 2242 : 				strLogString.Format("Unassigned %s at, X: %d, Y: %d", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR _pUnit$226449[ebp]
	mov	DWORD PTR $T247505[ebp], eax
	mov	ecx, DWORD PTR $T247505[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T247514[ebp], edx
	mov	eax, DWORD PTR _pUnit$226449[ebp]
	mov	DWORD PTR $T247518[ebp], eax
	mov	ecx, DWORD PTR $T247518[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T247527[ebp], edx
	mov	eax, DWORD PTR $T247514[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247527[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$226451[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0BP@BONLIPIH@Unassigned?5?$CFs?5at?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?$AA@
	lea	edx, DWORD PTR _strLogString$226454[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2243 : 				LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$226454[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2244 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLogString$226454[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ReviewUnas:

; 2245 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strTemp$226451[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@ReviewUnas:

; 2246 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$226449[ebp], 0
	je	SHORT $LN87@ReviewUnas
	mov	ecx, DWORD PTR _pUnit$226449[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN87@ReviewUnas:
	jmp	$LN23@ReviewUnas
$LN6@ReviewUnas:

; 2247 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$226449[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strTemp$226451[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$226454[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-136]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::ReviewUnassignedUnits
PUBLIC	??_C@_0BO@KIBFNIFI@Founded?5city?5at?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?$AA@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getMISSION_FOUND@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_FOUND
;	COMDAT ??_C@_0BO@KIBFNIFI@Founded?5city?5at?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0BO@KIBFNIFI@Founded?5city?5at?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?$AA@ DB 'F'
	DB	'ounded city at, X: %d, Y: %d', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ$1
__ehfuncinfo$?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -100						; size = 4
$T247629 = -96						; size = 4
$T247620 = -92						; size = 4
$T247616 = -88						; size = 4
$T247607 = -84						; size = 4
$T247599 = -80						; size = 4
$T247590 = -76						; size = 4
$T247586 = -72						; size = 4
$T247579 = -68						; size = 4
$T247569 = -64						; size = 4
$T247565 = -60						; size = 4
_strLogString$226467 = -56				; size = 28
__$ArrayPad$ = -28					; size = 4
_pUnit$226464 = -24					; size = 8
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::ExecuteFirstTurnSettlerMoves, COMDAT
; _this$ = ecx

; 2251 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2252 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 2253 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN5@ExecuteFir
$LN4@ExecuteFir:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], edx
$LN5@ExecuteFir:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T247565[ebp], eax
	mov	ecx, DWORD PTR $T247565[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T247565[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN6@ExecuteFir

; 2254 : 	{
; 2255 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T247569[ebp], edx
	mov	eax, DWORD PTR $T247569[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T247579[ebp], eax
	mov	edx, DWORD PTR $T247579[ebp]
	mov	DWORD PTR _pUnit$226464[ebp], edx
	mov	BYTE PTR _pUnit$226464[ebp+4], 0
	cmp	DWORD PTR _pUnit$226464[ebp], 0
	je	SHORT $LN17@ExecuteFir
	mov	ecx, DWORD PTR _pUnit$226464[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN17@ExecuteFir:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2256 : 		if(pUnit)

	xor	eax, eax
	cmp	DWORD PTR _pUnit$226464[ebp], 0
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@ExecuteFir

; 2257 : 		{
; 2258 : 			pUnit->PushMission(CvTypes::getMISSION_FOUND());

	mov	edx, DWORD PTR _pUnit$226464[ebp]
	mov	DWORD PTR $T247586[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_FOUND@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FOUND
	push	eax
	mov	ecx, DWORD PTR $T247586[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2259 : 			UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR _pUnit$226464[ebp]
	mov	DWORD PTR $T247590[ebp], eax
	mov	ecx, DWORD PTR $T247590[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T247599[ebp], edx
	mov	eax, DWORD PTR $T247599[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 2260 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@ExecuteFir
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@ExecuteFir

; 2261 : 			{
; 2262 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226467[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2263 : 				strLogString.Format("Founded city at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR _pUnit$226464[ebp]
	mov	DWORD PTR $T247607[ebp], eax
	mov	ecx, DWORD PTR $T247607[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T247616[ebp], edx
	mov	eax, DWORD PTR _pUnit$226464[ebp]
	mov	DWORD PTR $T247620[ebp], eax
	mov	ecx, DWORD PTR $T247620[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T247629[ebp], edx
	mov	eax, DWORD PTR $T247616[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247629[ebp]
	push	ecx
	push	OFFSET ??_C@_0BO@KIBFNIFI@Founded?5city?5at?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?$AA@
	lea	edx, DWORD PTR _strLogString$226467[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2264 : 				LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$226467[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2265 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$226467[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@ExecuteFir:

; 2266 : 		}
; 2267 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$226464[ebp], 0
	je	SHORT $LN50@ExecuteFir
	mov	ecx, DWORD PTR _pUnit$226464[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN50@ExecuteFir:
	jmp	$LN4@ExecuteFir
$LN6@ExecuteFir:

; 2268 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$226464[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$226467[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::ExecuteFirstTurnSettlerMoves
PUBLIC	??1?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ ; CvWeightedVector<CvPlot *,100,1>::~CvWeightedVector<CvPlot *,100,1>
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>
PUBLIC	??_C@_0DL@ICDBNDME@UnitID?3?5?$CFd?5Sea?5explorer?5?$CIAI?$CJ?5fou@ ; `string'
PUBLIC	??_C@_0CN@ILCLKMBJ@UnitID?3?5?$CFd?5Disbanding?5explorer?0?5@ ; `string'
PUBLIC	??_C@_0DH@MCLBCMKC@UnitID?3?5?$CFd?5Explorer?5?$CIAI?$CJ?5found?5n@ ; `string'
PUBLIC	??_C@_0DK@CAGIJFE@UnitID?3?5?$CFd?5Explorer?5?$CIhuman?$CJ?5foun@ ; `string'
PUBLIC	??_C@_0EK@ILPEBCHH@UnitID?3?5?$CFd?5Explored?5to?5distant?5t@ ; `string'
PUBLIC	??_C@_0EJ@BBDMCOFD@UnitID?3?5?$CFd?5Explored?5to?5nearby?5ta@ ; `string'
PUBLIC	?SortItems@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXXZ ; CvWeightedVector<CvPlot *,100,1>::SortItems
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::push_back
PUBLIC	__real@3f400000
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
PUBLIC	??_C@_0DH@DEKLKIPA@UnitID?3?5?$CFd?5Can?8t?5find?5path?5to?5go@ ; `string'
PUBLIC	??_C@_0DI@GOPJGKCB@UnitID?3?5?$CFd?5No?5end?5turn?5plot?5to?5g@ ; `string'
PUBLIC	??_C@_0DP@LDCOFHBK@UnitID?3?5?$CFd?5Moving?5to?5goody?5hut?0?5@ ; `string'
PUBLIC	??_C@_0CK@DMAFMAIF@UnitID?3?5?$CFd?5has?5goody?5target?0?5X?3?5@ ; `string'
PUBLIC	??_C@_0DA@PBEFPCNC@UnitID?3?5?$CFd?5used?5Sell?5Exotic?5Good@ ; `string'
PUBLIC	__real@3f000000
PUBLIC	??_C@_0BM@NLOLKILE@UnitGetSpecialExploreTarget?$AA@ ; `string'
PUBLIC	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSizeToFit
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>
PUBLIC	__$ArrayPad$
EXTRN	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z:PROC	; CvUnit::kill
EXTRN	?DoesPathExist@CvIgnoreUnitsPathFinder@@QAE_NAAVCvUnit@@PAVCvPlot@@1@Z:PROC ; CvIgnoreUnitsPathFinder::DoesPathExist
EXTRN	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ:PROC ; CvGlobals::getIgnoreUnitsPathFinder
EXTRN	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z:PROC ; CvUnit::SetAutomateType
EXTRN	?getMoves@CvUnit@@QBEHXZ:PROC			; CvUnit::getMoves
EXTRN	?isAdjacentToLand@CvPlot@@QBE_NXZ:PROC		; CvPlot::isAdjacentToLand
EXTRN	?canSellExoticGoods@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC ; CvUnit::canSellExoticGoods
EXTRN	?isShallowWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::isShallowWater
EXTRN	?IsEmbarkAllWater@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsEmbarkAllWater
EXTRN	?ScoreExplorePlot@CvEconomicAI@@SAHPAVCvPlot@@W4TeamTypes@@HW4DomainTypes@@@Z:PROC ; CvEconomicAI::ScoreExplorePlot
EXTRN	?movesLeft@CvUnit@@QBEHXZ:PROC			; CvUnit::movesLeft
EXTRN	?GetBaseSightRange@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetBaseSightRange
EXTRN	?GetPathEndTurnPlot@CvTwoLayerPathFinder@@QBEPAVCvPlot@@XZ:PROC ; CvTwoLayerPathFinder::GetPathEndTurnPlot
EXTRN	?ClearUnitTargetGoodyStepPlot@CvEconomicAI@@QAEXPAVCvUnit@@@Z:PROC ; CvEconomicAI::ClearUnitTargetGoodyStepPlot
EXTRN	?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z:PROC ; CvPlot::isVisibleEnemyDefender
EXTRN	?HasBarbarianCamp@CvPlot@@QAE_NXZ:PROC		; CvPlot::HasBarbarianCamp
EXTRN	?GetUnitTargetGoodyPlot@CvEconomicAI@@QAEPAVCvPlot@@PAVCvUnit@@PAPAV2@@Z:PROC ; CvEconomicAI::GetUnitTargetGoodyPlot
EXTRN	?calculateExoticGoodsDistanceFactor@CvUnit@@QAEMPBVCvPlot@@@Z:PROC ; CvUnit::calculateExoticGoodsDistanceFactor
EXTRN	?CanStartMission@CvUnit@@QAE_NHHHPAVCvPlot@@_N@Z:PROC ; CvUnit::CanStartMission
EXTRN	?getMISSION_SELL_EXOTIC_GOODS@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_SELL_EXOTIC_GOODS
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallHook
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
;	COMDAT ??_C@_0DL@ICDBNDME@UnitID?3?5?$CFd?5Sea?5explorer?5?$CIAI?$CJ?5fou@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0DL@ICDBNDME@UnitID?3?5?$CFd?5Sea?5explorer?5?$CIAI?$CJ?5fou@ DB 'U'
	DB	'nitID: %d Sea explorer (AI) found no target, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@ILCLKMBJ@UnitID?3?5?$CFd?5Disbanding?5explorer?0?5@
CONST	SEGMENT
??_C@_0CN@ILCLKMBJ@UnitID?3?5?$CFd?5Disbanding?5explorer?0?5@ DB 'UnitID:'
	DB	' %d Disbanding explorer, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@MCLBCMKC@UnitID?3?5?$CFd?5Explorer?5?$CIAI?$CJ?5found?5n@
CONST	SEGMENT
??_C@_0DH@MCLBCMKC@UnitID?3?5?$CFd?5Explorer?5?$CIAI?$CJ?5found?5n@ DB 'U'
	DB	'nitID: %d Explorer (AI) found no target, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@CAGIJFE@UnitID?3?5?$CFd?5Explorer?5?$CIhuman?$CJ?5foun@
CONST	SEGMENT
??_C@_0DK@CAGIJFE@UnitID?3?5?$CFd?5Explorer?5?$CIhuman?$CJ?5foun@ DB 'Uni'
	DB	'tID: %d Explorer (human) found no target, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@ILPEBCHH@UnitID?3?5?$CFd?5Explored?5to?5distant?5t@
CONST	SEGMENT
??_C@_0EK@ILPEBCHH@UnitID?3?5?$CFd?5Explored?5to?5distant?5t@ DB 'UnitID:'
	DB	' %d Explored to distant target, To X: %d, Y: %d, From X: %d, '
	DB	'Y: %d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@BBDMCOFD@UnitID?3?5?$CFd?5Explored?5to?5nearby?5ta@
CONST	SEGMENT
??_C@_0EJ@BBDMCOFD@UnitID?3?5?$CFd?5Explored?5to?5nearby?5ta@ DB 'UnitID:'
	DB	' %d Explored to nearby target, To X: %d, Y: %d, From X: %d, Y'
	DB	': %d', 00H					; `string'
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT ??_C@_0DH@DEKLKIPA@UnitID?3?5?$CFd?5Can?8t?5find?5path?5to?5go@
CONST	SEGMENT
??_C@_0DH@DEKLKIPA@UnitID?3?5?$CFd?5Can?8t?5find?5path?5to?5go@ DB 'UnitI'
	DB	'D: %d Can''t find path to goody from, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@GOPJGKCB@UnitID?3?5?$CFd?5No?5end?5turn?5plot?5to?5g@
CONST	SEGMENT
??_C@_0DI@GOPJGKCB@UnitID?3?5?$CFd?5No?5end?5turn?5plot?5to?5g@ DB 'UnitI'
	DB	'D: %d No end turn plot to goody from, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@LDCOFHBK@UnitID?3?5?$CFd?5Moving?5to?5goody?5hut?0?5@
CONST	SEGMENT
??_C@_0DP@LDCOFHBK@UnitID?3?5?$CFd?5Moving?5to?5goody?5hut?0?5@ DB 'UnitI'
	DB	'D: %d Moving to goody hut, X: %d, Y: %d, from X: %d Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@DMAFMAIF@UnitID?3?5?$CFd?5has?5goody?5target?0?5X?3?5@
CONST	SEGMENT
??_C@_0CK@DMAFMAIF@UnitID?3?5?$CFd?5has?5goody?5target?0?5X?3?5@ DB 'Unit'
	DB	'ID: %d has goody target, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@PBEFPCNC@UnitID?3?5?$CFd?5used?5Sell?5Exotic?5Good@
CONST	SEGMENT
??_C@_0DA@PBEFPCNC@UnitID?3?5?$CFd?5used?5Sell?5Exotic?5Good@ DB 'UnitID:'
	DB	' %d used Sell Exotic Goods, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT ??_C@_0BM@NLOLKILE@UnitGetSpecialExploreTarget?$AA@
CONST	SEGMENT
??_C@_0BM@NLOLKILE@UnitGetSpecialExploreTarget?$AA@ DB 'UnitGetSpecialExp'
	DB	'loreTarget', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$4
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$5
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$6
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$7
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$8
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$9
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$10
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$11
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$12
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv1270 = -2000						; size = 4
tv170 = -1996						; size = 4
tv159 = -1992						; size = 4
tv148 = -1988						; size = 4
_this$ = -1984						; size = 4
$T248773 = -1968					; size = 4
$T248764 = -1964					; size = 4
$T248760 = -1960					; size = 4
$T248751 = -1956					; size = 4
$T248747 = -1952					; size = 4
$T248738 = -1948					; size = 4
$T248730 = -1944					; size = 4
$T248722 = -1940					; size = 4
$T248715 = -1936					; size = 4
$T248706 = -1932					; size = 4
$T248702 = -1928					; size = 4
$T248693 = -1924					; size = 4
$T248689 = -1920					; size = 4
$T248680 = -1916					; size = 4
$T248676 = -1912					; size = 4
$T248667 = -1908					; size = 4
$T248659 = -1904					; size = 4
$T248655 = -1900					; size = 4
$T248647 = -1896					; size = 4
$T248638 = -1892					; size = 4
$T248634 = -1888					; size = 4
$T248625 = -1884					; size = 4
$T248621 = -1880					; size = 4
$T248612 = -1876					; size = 4
$T248604 = -1872					; size = 4
$T248600 = -1868					; size = 4
$T248591 = -1864					; size = 4
$T248580 = -1860					; size = 4
$T248571 = -1856					; size = 4
$T248567 = -1852					; size = 4
$T248558 = -1848					; size = 4
$T248554 = -1844					; size = 4
$T248545 = -1840					; size = 4
$T248537 = -1836					; size = 4
$T248529 = -1832					; size = 4
$T248520 = -1828					; size = 4
$T248516 = -1824					; size = 4
$T248507 = -1820					; size = 4
$T248503 = -1816					; size = 4
$T248494 = -1812					; size = 4
$T248490 = -1808					; size = 4
$T248481 = -1804					; size = 4
$T248477 = -1800					; size = 4
$T248468 = -1796					; size = 4
$T248464 = -1792					; size = 4
$T248455 = -1788					; size = 4
$T248447 = -1784					; size = 4
$T248438 = -1780					; size = 4
$T248434 = -1776					; size = 4
$T248430 = -1772					; size = 4
$T248426 = -1768					; size = 4
$T248422 = -1764					; size = 4
$T248418 = -1760					; size = 4
$T248414 = -1756					; size = 4
$T248410 = -1752					; size = 4
$T248406 = -1748					; size = 4
$T248402 = -1744					; size = 4
$T248374 = -1732					; size = 4
_weightedElem$248369 = -1728				; size = 8
$T248323 = -1676					; size = 4
$T248319 = -1672					; size = 4
$T248312 = -1668					; size = 4
$T248302 = -1664					; size = 4
$T248295 = -1660					; size = 4
$T248288 = -1656					; size = 4
$T248276 = -1652					; size = 4
_i$248268 = -1648					; size = 4
$T248242 = -1644					; size = 4
$T248238 = -1640					; size = 4
$T248234 = -1636					; size = 4
$T248230 = -1632					; size = 4
$T248226 = -1628					; size = 4
$T248198 = -1616					; size = 4
_weightedElem$248193 = -1612				; size = 8
$T248184 = -1604					; size = 4
$T248180 = -1600					; size = 4
$T248176 = -1596					; size = 4
$T248169 = -1592					; size = 4
$T248165 = -1588					; size = 4
$T248150 = -1564					; size = 4
$T248146 = -1560					; size = 4
$T248142 = -1556					; size = 4
$T248138 = -1552					; size = 4
$T248134 = -1548					; size = 4
_i$248126 = -1544					; size = 4
$T248096 = -1540					; size = 4
$T248087 = -1536					; size = 4
$T248083 = -1532					; size = 4
$T248074 = -1528					; size = 4
$T248070 = -1524					; size = 4
$T248061 = -1520					; size = 4
$T248040 = -1516					; size = 4
$T248031 = -1512					; size = 4
$T248027 = -1508					; size = 4
$T248018 = -1504					; size = 4
$T248014 = -1500					; size = 4
$T248005 = -1496					; size = 4
$T247997 = -1492					; size = 4
$T247988 = -1488					; size = 4
$T247981 = -1484					; size = 4
$T247977 = -1480					; size = 4
$T247973 = -1476					; size = 4
$T247965 = -1472					; size = 4
$T247956 = -1468					; size = 4
$T247952 = -1464					; size = 4
$T247948 = -1460					; size = 4
$T247944 = -1456					; size = 4
$T247935 = -1452					; size = 4
$T247931 = -1448					; size = 4
$T247922 = -1444					; size = 4
$T247914 = -1440					; size = 4
$T247910 = -1436					; size = 4
$T247906 = -1432					; size = 4
$T247899 = -1428					; size = 4
$T247895 = -1424					; size = 4
$T247891 = -1420					; size = 4
$T247890 = -1416					; size = 4
$T247877 = -1412					; size = 4
$T247868 = -1408					; size = 4
$T247864 = -1404					; size = 4
$T247860 = -1400					; size = 4
$T247852 = -1396					; size = 4
$T247840 = -1392					; size = 4
$T247828 = -1388					; size = 4
$T247820 = -1384					; size = 4
$T247811 = -1380					; size = 4
$T247807 = -1376					; size = 4
$T247798 = -1372					; size = 4
$T247794 = -1368					; size = 4
$T247785 = -1364					; size = 4
$T247777 = -1360					; size = 4
$T247773 = -1356					; size = 4
$T247769 = -1352					; size = 4
$T247765 = -1348					; size = 4
$T247749 = -1344					; size = 4
$T247740 = -1340					; size = 4
$T247733 = -1336					; size = 4
$T247724 = -1332					; size = 4
$T247717 = -1328					; size = 4
$T247704 = -1324					; size = 4
$T247697 = -1320					; size = 4
$T247687 = -1316					; size = 4
$T247683 = -1312					; size = 4
_strLogString$226865 = -1308				; size = 28
_strLogString$226860 = -1280				; size = 28
_strLogString$226850 = -1252				; size = 28
_pLoopCity$226852 = -1224				; size = 4
_bFoundPath$226854 = -1217				; size = 1
_iLoop$226853 = -1216					; size = 4
_strLogString$226845 = -1212				; size = 28
_strLogString$226837 = -1184				; size = 28
_pPlot$226826 = -1156					; size = 4
_pEndTurnPlot$226829 = -1152				; size = 4
_bCanFindPath$226827 = -1145				; size = 1
_i$226822 = -1144					; size = 4
_iDistance$226817 = -1140				; size = 4
_iPlot$226810 = -1136					; size = 4
_iRating$226816 = -1132					; size = 4
_pEvalPlot$226812 = -1128				; size = 4
_iEstimateTurns$226818 = -1124				; size = 4
_iPlotScore$226814 = -1120				; size = 4
_ui$226806 = -1116					; size = 4
_aiExplorationPlotRatings$226805 = -1112		; size = 4
_aiExplorationPlots$226794 = -1108			; size = 4
_iDistance$226782 = -1104				; size = 4
_pPlot$226778 = -1100					; size = 4
_pNode$226781 = -1096					; size = 4
_bCanFindPath$226779 = -1089				; size = 1
_i$226774 = -1088					; size = 4
_fRewardFactor$226767 = -1084				; size = 4
_eDomain$226758 = -1080					; size = 4
_pEvalPlot$226755 = -1076				; size = 4
_iScore$226759 = -1072					; size = 4
_iY$226751 = -1068					; size = 4
_iX$226747 = -1064					; size = 4
_strLogString$226739 = -1060				; size = 28
_strLogString$226735 = -1032				; size = 28
_strLogString$226731 = -1004				; size = 28
_bCanFindPath$226722 = -973				; size = 1
_strLogString$226718 = -972				; size = 28
_strLogString$226710 = -944				; size = 28
_fRewardFactor$226707 = -916				; size = 4
_bResult$226703 = -909					; size = 1
_args$226702 = -908					; size = 4
_pUnit$226697 = -904					; size = 8
_iBaseSightRange$226744 = -896				; size = 4
_uiListSize$226772 = -892				; size = 4
_pGoodyPlot$226715 = -888				; size = 4
_pBestPlot$226741 = -884				; size = 4
_iUnitY$226713 = -880					; size = 4
_iUnitX$226712 = -876					; size = 4
_iBestPlotScore$226742 = -872				; size = 4
_pkStepPlot$226714 = -868				; size = 4
_eTeam$226743 = -864					; size = 4
_pkScriptSystem$226700 = -860				; size = 4
_iMovementRange$226745 = -856				; size = 4
_pEconomicAI$ = -852					; size = 4
_kPathFinder$ = -848					; size = 4
_aBestPlotList$ = -844					; size = 816
__$ArrayPad$ = -24					; size = 4
_bFoundNearbyExplorePlot$ = -17				; size = 1
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteExplorerMoves, COMDAT
; _this$ = ecx

; 2275 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1988				; 000007c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 	bool bFoundNearbyExplorePlot = false;

	mov	BYTE PTR _bFoundNearbyExplorePlot$[ebp], 0

; 2277 : 	CvEconomicAI* pEconomicAI = m_pPlayer->GetEconomicAI();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR _pEconomicAI$[ebp], eax

; 2278 : 
; 2279 : 	pEconomicAI->UpdatePlots();

	mov	ecx, DWORD PTR _pEconomicAI$[ebp]
	call	?UpdatePlots@CvEconomicAI@@QAEXXZ	; CvEconomicAI::UpdatePlots

; 2280 : 
; 2281 : #if defined(PATH_PLAN_LAST)
; 2282 : 	WeightedPlotVector aBestPlotList;

	lea	ecx, DWORD PTR _aBestPlotList$[ebp]
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2283 : 	aBestPlotList.reserve(100);

	push	100					; 00000064H
	lea	ecx, DWORD PTR _aBestPlotList$[ebp]
	call	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSizeToFit

; 2284 : #endif
; 2285 : 
; 2286 : 	CvTwoLayerPathFinder& kPathFinder = GC.getPathFinder();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	DWORD PTR _kPathFinder$[ebp], eax

; 2287 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 2288 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _it$[ebp], edx
	jmp	SHORT $LN90@ExecuteExp
$LN89@ExecuteExp:
	mov	eax, DWORD PTR _it$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], eax
$LN90@ExecuteExp:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T247683[ebp], ecx
	mov	edx, DWORD PTR $T247683[ebp]
	mov	eax, DWORD PTR [edx+4]
	shl	eax, 4
	mov	ecx, DWORD PTR $T247683[ebp]
	add	eax, DWORD PTR [ecx]
	cmp	DWORD PTR _it$[ebp], eax
	je	$LN88@ExecuteExp

; 2289 : 	{
; 2290 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	edx, DWORD PTR _it$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T247687[ebp], eax
	mov	ecx, DWORD PTR $T247687[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T247697[ebp], eax
	mov	eax, DWORD PTR $T247697[ebp]
	mov	DWORD PTR _pUnit$226697[ebp], eax
	mov	BYTE PTR _pUnit$226697[ebp+4], 0
	cmp	DWORD PTR _pUnit$226697[ebp], 0
	je	SHORT $LN122@ExecuteExp
	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN122@ExecuteExp:
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2291 : 		if(!pUnit || pUnit->TurnProcessed())

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$226697[ebp], 0
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN86@ExecuteExp
	mov	eax, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247704[ebp], eax
	mov	ecx, DWORD PTR $T247704[ebp]
	call	?TurnProcessed@CvUnit@@QBE_NXZ		; CvUnit::TurnProcessed
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN87@ExecuteExp
$LN86@ExecuteExp:

; 2292 : 		{
; 2293 : 			continue;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pUnit$226697[ebp], 0
	je	SHORT $LN131@ExecuteExp
	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN131@ExecuteExp:
	jmp	$LN89@ExecuteExp
$LN87@ExecuteExp:

; 2294 : 		}
; 2295 : 
; 2296 : 		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	edx, DWORD PTR $T247717[ebp]
	mov	DWORD PTR tv148[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv148[ebp], eax
	mov	ecx, DWORD PTR tv148[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv148[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$226700[ebp], eax

; 2297 : 		if(pkScriptSystem)

	cmp	DWORD PTR _pkScriptSystem$226700[ebp], 0
	je	$LN85@ExecuteExp

; 2298 : 		{
; 2299 : 			CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$226702[ebp]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 2300 : 			args->Push(pUnit->getOwner());

	mov	ecx, DWORD PTR _args$226702[ebp]
	mov	DWORD PTR tv159[ebp], ecx
	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247724[ebp], edx
	mov	eax, DWORD PTR $T247724[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T247733[ebp], ecx
	mov	edx, DWORD PTR $T247733[ebp]
	push	edx
	mov	eax, DWORD PTR tv159[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv159[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 2301 : 			args->Push(pUnit->GetID());

	mov	ecx, DWORD PTR _args$226702[ebp]
	mov	DWORD PTR tv170[ebp], ecx
	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247740[ebp], edx
	mov	eax, DWORD PTR $T247740[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T247749[ebp], ecx
	mov	edx, DWORD PTR $T247749[ebp]
	push	edx
	mov	eax, DWORD PTR tv170[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv170[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 2302 : 
; 2303 : 			bool bResult;
; 2304 : 			LuaSupport::CallHook(pkScriptSystem, "UnitGetSpecialExploreTarget", args.get(), bResult);

	lea	ecx, DWORD PTR _bResult$226703[ebp]
	push	ecx
	mov	edx, DWORD PTR _args$226702[ebp]
	push	edx
	push	OFFSET ??_C@_0BM@NLOLKILE@UnitGetSpecialExploreTarget?$AA@
	mov	eax, DWORD PTR _pkScriptSystem$226700[ebp]
	push	eax
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 2305 : 
; 2306 : 			if(bResult)

	movzx	ecx, BYTE PTR _bResult$226703[ebp]
	test	ecx, ecx
	je	SHORT $LN84@ExecuteExp

; 2307 : 			{
; 2308 : 				continue;

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _args$226702[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pUnit$226697[ebp], 0
	je	SHORT $LN156@ExecuteExp
	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN156@ExecuteExp:
	jmp	$LN89@ExecuteExp
$LN84@ExecuteExp:

; 2309 : 			}
; 2310 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _args$226702[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN85@ExecuteExp:

; 2311 : 
; 2312 : 		if (!m_pPlayer->isHuman() && pUnit->CanStartMission(CvTypes::getMISSION_SELL_EXOTIC_GOODS(), -1, -1))

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	jne	$LN81@ExecuteExp
	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247765[ebp], ecx
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SELL_EXOTIC_GOODS@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SELL_EXOTIC_GOODS
	push	eax
	mov	ecx, DWORD PTR $T247765[ebp]
	call	?CanStartMission@CvUnit@@QAE_NHHHPAVCvPlot@@_N@Z ; CvUnit::CanStartMission
	movzx	edx, al
	test	edx, edx
	je	$LN81@ExecuteExp

; 2313 : 		{
; 2314 : 			// Far enough from home to get a good reward?
; 2315 : 			float fRewardFactor = pUnit->calculateExoticGoodsDistanceFactor(pUnit->plot());

	mov	eax, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247769[ebp], eax
	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247773[ebp], ecx
	mov	ecx, DWORD PTR $T247769[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR $T247773[ebp]
	call	?calculateExoticGoodsDistanceFactor@CvUnit@@QAEMPBVCvPlot@@@Z ; CvUnit::calculateExoticGoodsDistanceFactor
	fstp	DWORD PTR _fRewardFactor$226707[ebp]

; 2316 : 			if (fRewardFactor >= 0.5f)

	movss	xmm0, DWORD PTR _fRewardFactor$226707[ebp]
	comiss	xmm0, DWORD PTR __real@3f000000
	jb	$LN81@ExecuteExp

; 2317 : 			{
; 2318 : 				pUnit->PushMission(CvTypes::getMISSION_SELL_EXOTIC_GOODS());

	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247777[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SELL_EXOTIC_GOODS@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SELL_EXOTIC_GOODS
	push	eax
	mov	ecx, DWORD PTR $T247777[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2319 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN81@ExecuteExp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN81@ExecuteExp

; 2320 : 				{
; 2321 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226710[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 2322 : 					strLogString.Format("UnitID: %d used Sell Exotic Goods, X: %d, Y: %d", pUnit->GetID(), pUnit->getX(), pUnit->getY());

	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247785[ebp], edx
	mov	eax, DWORD PTR $T247785[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T247794[ebp], ecx
	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247798[ebp], edx
	mov	eax, DWORD PTR $T247798[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T247807[ebp], ecx
	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247811[ebp], edx
	mov	eax, DWORD PTR $T247811[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T247820[ebp], ecx
	mov	edx, DWORD PTR $T247794[ebp]
	push	edx
	mov	eax, DWORD PTR $T247807[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247820[ebp]
	push	ecx
	push	OFFSET ??_C@_0DA@PBEFPCNC@UnitID?3?5?$CFd?5used?5Sell?5Exotic?5Good@
	lea	edx, DWORD PTR _strLogString$226710[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2323 : 					LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$226710[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2324 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLogString$226710[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN81@ExecuteExp:

; 2325 : 			}
; 2326 : 		}
; 2327 : 
; 2328 : 		int iUnitX = pUnit->getX();

	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247828[ebp], ecx
	mov	edx, DWORD PTR $T247828[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR _iUnitX$226712[ebp], eax

; 2329 : 		int iUnitY = pUnit->getY();

	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247840[ebp], ecx
	mov	edx, DWORD PTR $T247840[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR _iUnitY$226713[ebp], eax

; 2330 : 
; 2331 : 		CvPlot* pkStepPlot = NULL;

	mov	DWORD PTR _pkStepPlot$226714[ebp], 0

; 2332 : 		CvPlot* pGoodyPlot = pEconomicAI->GetUnitTargetGoodyPlot(pUnit.pointer(), &pkStepPlot);

	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247852[ebp], ecx
	lea	edx, DWORD PTR _pkStepPlot$226714[ebp]
	push	edx
	mov	eax, DWORD PTR $T247852[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEconomicAI$[ebp]
	call	?GetUnitTargetGoodyPlot@CvEconomicAI@@QAEPAVCvPlot@@PAVCvUnit@@PAPAV2@@Z ; CvEconomicAI::GetUnitTargetGoodyPlot
	mov	DWORD PTR _pGoodyPlot$226715[ebp], eax

; 2333 : 		if (pGoodyPlot)

	cmp	DWORD PTR _pGoodyPlot$226715[ebp], 0
	je	$LN79@ExecuteExp

; 2334 : 		{
; 2335 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN79@ExecuteExp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN79@ExecuteExp

; 2336 : 			{
; 2337 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226718[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 2338 : 				strLogString.Format("UnitID: %d has goody target, X: %d, Y: %d", pUnit->GetID(), pGoodyPlot->getX(), pGoodyPlot->getY());

	mov	eax, DWORD PTR _pGoodyPlot$226715[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T247860[ebp], ecx
	mov	edx, DWORD PTR _pGoodyPlot$226715[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T247864[ebp], eax
	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247868[ebp], ecx
	mov	edx, DWORD PTR $T247868[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T247877[ebp], eax
	mov	ecx, DWORD PTR $T247860[ebp]
	push	ecx
	mov	edx, DWORD PTR $T247864[ebp]
	push	edx
	mov	eax, DWORD PTR $T247877[ebp]
	push	eax
	push	OFFSET ??_C@_0CK@DMAFMAIF@UnitID?3?5?$CFd?5has?5goody?5target?0?5X?3?5@
	lea	ecx, DWORD PTR _strLogString$226718[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2339 : 				LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$226718[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2340 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLogString$226718[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN79@ExecuteExp:

; 2341 : 		}
; 2342 : 
; 2343 : #ifdef AUI_WARNING_FIXES
; 2344 : 		if (pGoodyPlot && (pGoodyPlot->isGoody(m_pPlayer->getTeam()) || (pGoodyPlot->HasBarbarianCamp() && !pGoodyPlot->isVisibleEnemyDefender(pUnit.pointer()))))
; 2345 : #else
; 2346 : 		if(pGoodyPlot && (pGoodyPlot->isGoody(m_pPlayer->getTeam()) || (pGoodyPlot->HasBarbarianCamp()) && !pGoodyPlot->isVisibleEnemyDefender(pUnit.pointer())))

	cmp	DWORD PTR _pGoodyPlot$226715[ebp], 0
	je	$LN65@ExecuteExp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T247890[ebp], ecx
	mov	edx, DWORD PTR $T247890[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T247891[ebp], eax
	mov	ecx, DWORD PTR $T247891[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pGoodyPlot$226715[ebp]
	call	?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isGoody
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN77@ExecuteExp
	mov	ecx, DWORD PTR _pGoodyPlot$226715[ebp]
	call	?HasBarbarianCamp@CvPlot@@QAE_NXZ	; CvPlot::HasBarbarianCamp
	movzx	eax, al
	test	eax, eax
	je	$LN65@ExecuteExp
	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247895[ebp], ecx
	mov	edx, DWORD PTR $T247895[ebp]
	push	edx
	mov	ecx, DWORD PTR _pGoodyPlot$226715[ebp]
	call	?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyDefender
	movzx	eax, al
	test	eax, eax
	jne	$LN65@ExecuteExp
$LN77@ExecuteExp:

; 2347 : #endif
; 2348 : 		{
; 2349 : 			bool bCanFindPath = false;

	mov	BYTE PTR _bCanFindPath$226722[ebp], 0

; 2350 : 			if (pkStepPlot)	// Do we already have our first step point?

	cmp	DWORD PTR _pkStepPlot$226714[ebp], 0
	je	SHORT $LN76@ExecuteExp

; 2351 : 			{
; 2352 : 				if (IsValidExplorerEndTurnPlot(pUnit.pointer(), pkStepPlot))

	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247899[ebp], ecx
	mov	edx, DWORD PTR _pkStepPlot$226714[ebp]
	push	edx
	mov	eax, DWORD PTR $T247899[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidExplorerEndTurnPlot@CvHomelandAI@@ABE_NPBVCvUnit@@PAVCvPlot@@@Z ; CvHomelandAI::IsValidExplorerEndTurnPlot
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN75@ExecuteExp

; 2353 : 					bCanFindPath = true;

	mov	BYTE PTR _bCanFindPath$226722[ebp], 1
$LN75@ExecuteExp:

; 2354 : 
; 2355 : 				// The economic AI should recalculate next time through, but just in case, let's say that we've used the step plot
; 2356 : 				pEconomicAI->ClearUnitTargetGoodyStepPlot(pUnit.pointer());

	mov	edx, DWORD PTR _pUnit$226697[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEconomicAI$[ebp]
	call	?ClearUnitTargetGoodyStepPlot@CvEconomicAI@@QAEXPAVCvUnit@@@Z ; CvEconomicAI::ClearUnitTargetGoodyStepPlot
$LN76@ExecuteExp:

; 2357 : 			}
; 2358 : 
; 2359 : 			if (!pkStepPlot || !bCanFindPath)

	cmp	DWORD PTR _pkStepPlot$226714[ebp], 0
	je	SHORT $LN73@ExecuteExp
	movzx	eax, BYTE PTR _bCanFindPath$226722[ebp]
	test	eax, eax
	jne	$LN72@ExecuteExp
$LN73@ExecuteExp:

; 2360 : 			{
; 2361 : 				bCanFindPath = kPathFinder.GenerateUnitPath(pUnit.pointer(), iUnitX, iUnitY, pGoodyPlot->getX(), pGoodyPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER /*iFlags*/, true/*bReuse*/);

	mov	ecx, DWORD PTR _pGoodyPlot$226715[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T247906[ebp], edx
	mov	eax, DWORD PTR _pGoodyPlot$226715[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T247910[ebp], ecx
	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247914[ebp], edx
	push	1
	push	138					; 0000008aH
	mov	eax, DWORD PTR $T247906[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247910[ebp]
	push	ecx
	mov	edx, DWORD PTR _iUnitY$226713[ebp]
	push	edx
	mov	eax, DWORD PTR _iUnitX$226712[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247914[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPathFinder$[ebp]
	call	?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z ; CvTwoLayerPathFinder::GenerateUnitPath
	mov	BYTE PTR _bCanFindPath$226722[ebp], al

; 2362 : 				if(bCanFindPath)

	movzx	edx, BYTE PTR _bCanFindPath$226722[ebp]
	test	edx, edx
	je	SHORT $LN72@ExecuteExp

; 2363 : 				{
; 2364 : 					pkStepPlot = kPathFinder.GetPathEndTurnPlot();

	mov	ecx, DWORD PTR _kPathFinder$[ebp]
	call	?GetPathEndTurnPlot@CvTwoLayerPathFinder@@QBEPAVCvPlot@@XZ ; CvTwoLayerPathFinder::GetPathEndTurnPlot
	mov	DWORD PTR _pkStepPlot$226714[ebp], eax
$LN72@ExecuteExp:

; 2365 : 				}
; 2366 : 			}
; 2367 : 
; 2368 : 			if (bCanFindPath)

	movzx	eax, BYTE PTR _bCanFindPath$226722[ebp]
	test	eax, eax
	je	$LN71@ExecuteExp

; 2369 : 			{
; 2370 : 				if(pkStepPlot)

	cmp	DWORD PTR _pkStepPlot$226714[ebp], 0
	je	$LN70@ExecuteExp

; 2371 : 				{
; 2372 : 					CvAssert(!pUnit->atPlot(*pkStepPlot));
; 2373 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN69@ExecuteExp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN69@ExecuteExp

; 2374 : 					{
; 2375 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226731[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 2376 : 						strLogString.Format("UnitID: %d Moving to goody hut, X: %d, Y: %d, from X: %d Y: %d", pUnit->GetID(), pkStepPlot->getX(), pkStepPlot->getY(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247922[ebp], eax
	mov	ecx, DWORD PTR $T247922[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T247931[ebp], edx
	mov	eax, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247935[ebp], eax
	mov	ecx, DWORD PTR $T247935[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T247944[ebp], edx
	mov	eax, DWORD PTR _pkStepPlot$226714[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T247948[ebp], ecx
	mov	edx, DWORD PTR _pkStepPlot$226714[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T247952[ebp], eax
	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247956[ebp], ecx
	mov	edx, DWORD PTR $T247956[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T247965[ebp], eax
	mov	ecx, DWORD PTR $T247931[ebp]
	push	ecx
	mov	edx, DWORD PTR $T247944[ebp]
	push	edx
	mov	eax, DWORD PTR $T247948[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247952[ebp]
	push	ecx
	mov	edx, DWORD PTR $T247965[ebp]
	push	edx
	push	OFFSET ??_C@_0DP@LDCOFHBK@UnitID?3?5?$CFd?5Moving?5to?5goody?5hut?0?5@
	lea	eax, DWORD PTR _strLogString$226731[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH

; 2377 : 						LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$226731[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2378 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLogString$226731[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN69@ExecuteExp:

; 2379 : 					pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pkStepPlot->getX(), pkStepPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER, false, false, MISSIONAI_EXPLORE, pkStepPlot);

	mov	edx, DWORD PTR _pkStepPlot$226714[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T247973[ebp], eax
	mov	ecx, DWORD PTR _pkStepPlot$226714[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T247977[ebp], edx
	mov	eax, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247981[ebp], eax
	push	0
	mov	ecx, DWORD PTR _pkStepPlot$226714[ebp]
	push	ecx
	push	14					; 0000000eH
	push	0
	push	0
	push	138					; 0000008aH
	mov	edx, DWORD PTR $T247973[ebp]
	push	edx
	mov	eax, DWORD PTR $T247977[ebp]
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T247981[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2380 : #ifndef AUI_HOMELAND_FIX_EXECUTE_EXPLORER_MOVES_MOVE_AFTER_GOODY
; 2381 : 					pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 2382 : 					UnitProcessed(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T247988[ebp], ecx
	mov	edx, DWORD PTR $T247988[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T247997[ebp], eax
	mov	ecx, DWORD PTR $T247997[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 2383 : #endif
; 2384 : 				}
; 2385 : 				else

	jmp	$LN67@ExecuteExp
$LN70@ExecuteExp:

; 2386 : 				{
; 2387 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN67@ExecuteExp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	$LN67@ExecuteExp

; 2388 : 					{
; 2389 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226735[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 2390 : 						strLogString.Format("UnitID: %d No end turn plot to goody from, X: %d, Y: %d", pUnit->GetID(), pUnit->getX(), pUnit->getY());

	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248005[ebp], ecx
	mov	edx, DWORD PTR $T248005[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T248014[ebp], eax
	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248018[ebp], ecx
	mov	edx, DWORD PTR $T248018[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T248027[ebp], eax
	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248031[ebp], ecx
	mov	edx, DWORD PTR $T248031[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T248040[ebp], eax
	mov	ecx, DWORD PTR $T248014[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248027[ebp]
	push	edx
	mov	eax, DWORD PTR $T248040[ebp]
	push	eax
	push	OFFSET ??_C@_0DI@GOPJGKCB@UnitID?3?5?$CFd?5No?5end?5turn?5plot?5to?5g@
	lea	ecx, DWORD PTR _strLogString$226735[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2391 : 						LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$226735[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2392 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLogString$226735[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN67@ExecuteExp:

; 2393 : 				}
; 2394 : 
; 2395 : 				continue;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pUnit$226697[ebp], 0
	je	SHORT $LN305@ExecuteExp
	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN305@ExecuteExp:
	jmp	$LN89@ExecuteExp

; 2396 : 
; 2397 : 			}
; 2398 : 			else

	jmp	$LN65@ExecuteExp
$LN71@ExecuteExp:

; 2399 : 			{
; 2400 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN65@ExecuteExp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN65@ExecuteExp

; 2401 : 				{
; 2402 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226739[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 2403 : 					strLogString.Format("UnitID: %d Can't find path to goody from, X: %d, Y: %d", pUnit->GetID(), pUnit->getX(), pUnit->getY());

	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248061[ebp], edx
	mov	eax, DWORD PTR $T248061[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T248070[ebp], ecx
	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248074[ebp], edx
	mov	eax, DWORD PTR $T248074[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T248083[ebp], ecx
	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248087[ebp], edx
	mov	eax, DWORD PTR $T248087[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T248096[ebp], ecx
	mov	edx, DWORD PTR $T248070[ebp]
	push	edx
	mov	eax, DWORD PTR $T248083[ebp]
	push	eax
	mov	ecx, DWORD PTR $T248096[ebp]
	push	ecx
	push	OFFSET ??_C@_0DH@DEKLKIPA@UnitID?3?5?$CFd?5Can?8t?5find?5path?5to?5go@
	lea	edx, DWORD PTR _strLogString$226739[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2404 : 					LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$226739[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2405 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLogString$226739[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN65@ExecuteExp:

; 2406 : 			}
; 2407 : 		}
; 2408 : 
; 2409 : 		CvPlot* pBestPlot = NULL;

	mov	DWORD PTR _pBestPlot$226741[ebp], 0

; 2410 : 		int iBestPlotScore = 0;

	mov	DWORD PTR _iBestPlotScore$226742[ebp], 0

; 2411 : 
; 2412 : #if defined(PATH_PLAN_LAST)
; 2413 : 		aBestPlotList.clear();

	xor	ecx, ecx
	je	SHORT $LN335@ExecuteExp
	mov	DWORD PTR _i$248126[ebp], 0
	jmp	SHORT $LN337@ExecuteExp
$LN336@ExecuteExp:
	mov	edx, DWORD PTR _i$248126[ebp]
	add	edx, 1
	mov	DWORD PTR _i$248126[ebp], edx
$LN337@ExecuteExp:
	mov	eax, DWORD PTR _i$248126[ebp]
	cmp	eax, DWORD PTR _aBestPlotList$[ebp+4]
	jae	SHORT $LN335@ExecuteExp
	jmp	SHORT $LN336@ExecuteExp
$LN335@ExecuteExp:
	mov	DWORD PTR _aBestPlotList$[ebp+4], 0

; 2414 : #endif
; 2415 : 		TeamTypes eTeam = pUnit->getTeam();

	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248134[ebp], ecx
	mov	ecx, DWORD PTR $T248134[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	DWORD PTR _eTeam$226743[ebp], eax

; 2416 : 		int iBaseSightRange = pUnit->getUnitInfo().GetBaseSightRange();

	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248138[ebp], edx
	mov	ecx, DWORD PTR $T248138[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetBaseSightRange@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetBaseSightRange
	mov	DWORD PTR _iBaseSightRange$226744[ebp], eax

; 2417 : 
; 2418 : 		int iMovementRange = pUnit->movesLeft() / GC.getMOVE_DENOMINATOR();

	mov	eax, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248142[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	mov	DWORD PTR $T248146[ebp], ecx
	mov	ecx, DWORD PTR $T248142[ebp]
	call	?movesLeft@CvUnit@@QBEHXZ		; CvUnit::movesLeft
	cdq
	idiv	DWORD PTR $T248146[ebp]
	mov	DWORD PTR _iMovementRange$226745[ebp], eax

; 2419 : 
; 2420 : 		// if iMovesLeft value is greater than zero but not enough to be a positive integer when divided by move_denominator
; 2421 : 		// then just give them an extra movement. Who could it hurt, right?
; 2422 : 		if (pUnit->movesLeft() > 0 && iMovementRange == 0)

	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248150[ebp], edx
	mov	ecx, DWORD PTR $T248150[ebp]
	call	?movesLeft@CvUnit@@QBEHXZ		; CvUnit::movesLeft
	test	eax, eax
	jle	SHORT $LN64@ExecuteExp
	cmp	DWORD PTR _iMovementRange$226745[ebp], 0
	jne	SHORT $LN64@ExecuteExp

; 2423 : 		{
; 2424 : 			iMovementRange = 1;

	mov	DWORD PTR _iMovementRange$226745[ebp], 1
$LN64@ExecuteExp:

; 2425 : 		}
; 2426 : 
; 2427 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2428 : 		int iMaxDX, iDX;
; 2429 : 		CvPlot* pEvalPlot;
; 2430 : 		for (int iDY = -iMovementRange; iDY <= iMovementRange; iDY++)
; 2431 : 		{
; 2432 : 			iMaxDX = iMovementRange - MAX(0, iDY);
; 2433 : 			for (iDX = -iMovementRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 2434 : 			{
; 2435 : 				// No need for range check because loops are set up properly
; 2436 : 				pEvalPlot = plotXY(iUnitX, iUnitY, iDX, iDY);
; 2437 : #else
; 2438 : 		for(int iX = -iMovementRange; iX <= iMovementRange; iX++)

	mov	eax, DWORD PTR _iMovementRange$226745[ebp]
	neg	eax
	mov	DWORD PTR _iX$226747[ebp], eax
	jmp	SHORT $LN63@ExecuteExp
$LN62@ExecuteExp:
	mov	ecx, DWORD PTR _iX$226747[ebp]
	add	ecx, 1
	mov	DWORD PTR _iX$226747[ebp], ecx
$LN63@ExecuteExp:
	mov	edx, DWORD PTR _iX$226747[ebp]
	cmp	edx, DWORD PTR _iMovementRange$226745[ebp]
	jg	$LN61@ExecuteExp

; 2439 : 		{
; 2440 : 			for(int iY = -iMovementRange; iY <= iMovementRange; iY++)

	mov	eax, DWORD PTR _iMovementRange$226745[ebp]
	neg	eax
	mov	DWORD PTR _iY$226751[ebp], eax
	jmp	SHORT $LN60@ExecuteExp
$LN59@ExecuteExp:
	mov	ecx, DWORD PTR _iY$226751[ebp]
	add	ecx, 1
	mov	DWORD PTR _iY$226751[ebp], ecx
$LN60@ExecuteExp:
	mov	edx, DWORD PTR _iY$226751[ebp]
	cmp	edx, DWORD PTR _iMovementRange$226745[ebp]
	jg	$LN58@ExecuteExp

; 2441 : 			{
; 2442 : 				CvPlot* pEvalPlot = plotXYWithRangeCheck(iUnitX, iUnitY, iX, iY, iMovementRange);

	mov	eax, DWORD PTR _iMovementRange$226745[ebp]
	push	eax
	mov	ecx, DWORD PTR _iY$226751[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$226747[ebp]
	push	edx
	mov	eax, DWORD PTR _iUnitY$226713[ebp]
	push	eax
	mov	ecx, DWORD PTR _iUnitX$226712[ebp]
	push	ecx
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pEvalPlot$226755[ebp], eax

; 2443 : #endif
; 2444 : 				if(!pEvalPlot)

	cmp	DWORD PTR _pEvalPlot$226755[ebp], 0
	jne	SHORT $LN57@ExecuteExp

; 2445 : 				{
; 2446 : 					continue;

	jmp	SHORT $LN59@ExecuteExp
$LN57@ExecuteExp:

; 2447 : 				}
; 2448 : 
; 2449 : 				if(!IsValidExplorerEndTurnPlot(pUnit.pointer(), pEvalPlot))

	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248165[ebp], edx
	mov	eax, DWORD PTR _pEvalPlot$226755[ebp]
	push	eax
	mov	ecx, DWORD PTR $T248165[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidExplorerEndTurnPlot@CvHomelandAI@@ABE_NPBVCvUnit@@PAVCvPlot@@@Z ; CvHomelandAI::IsValidExplorerEndTurnPlot
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN56@ExecuteExp

; 2450 : 				{
; 2451 : 					continue;

	jmp	$LN59@ExecuteExp
$LN56@ExecuteExp:

; 2452 : 				}
; 2453 : 
; 2454 : #if !defined(PATH_PLAN_LAST)
; 2455 : 				bool bCanFindPath = kPathFinder.GenerateUnitPath(pUnit.pointer(), pUnit->getX(), pUnit->getY(), pEvalPlot->getX(), pEvalPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER /*iFlags*/, true/*bReuse*/);
; 2456 : 				if(!bCanFindPath)
; 2457 : 				{
; 2458 : 					continue;
; 2459 : 				}
; 2460 : 
; 2461 : 				CvAStarNode* pNode = kPathFinder.GetLastNode();
; 2462 : 				int iDistance = pNode->m_iData2;
; 2463 : 				if(iDistance > 1)
; 2464 : 				{
; 2465 : 					continue;
; 2466 : 				}
; 2467 : #endif
; 2468 : 
; 2469 : 				DomainTypes eDomain = pUnit->getDomainType();

	mov	eax, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248169[ebp], eax
	mov	ecx, DWORD PTR $T248169[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	mov	DWORD PTR _eDomain$226758[ebp], eax

; 2470 : 				int iScore = CvEconomicAI::ScoreExplorePlot(pEvalPlot, eTeam, iBaseSightRange, eDomain);

	mov	ecx, DWORD PTR _eDomain$226758[ebp]
	push	ecx
	mov	edx, DWORD PTR _iBaseSightRange$226744[ebp]
	push	edx
	mov	eax, DWORD PTR _eTeam$226743[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEvalPlot$226755[ebp]
	push	ecx
	call	?ScoreExplorePlot@CvEconomicAI@@SAHPAVCvPlot@@W4TeamTypes@@HW4DomainTypes@@@Z ; CvEconomicAI::ScoreExplorePlot
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iScore$226759[ebp], eax

; 2471 : 				if(iScore > 0)

	cmp	DWORD PTR _iScore$226759[ebp], 0
	jle	$LN378@ExecuteExp

; 2472 : 				{
; 2473 : 					if (eDomain == DOMAIN_LAND)

	cmp	DWORD PTR _eDomain$226758[ebp], 2
	jne	SHORT $LN54@ExecuteExp

; 2474 : 					{
; 2475 : 						if (pEvalPlot->isHills())

	mov	edx, DWORD PTR _pEvalPlot$226755[ebp]
	movsx	eax, BYTE PTR [edx+5]
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN53@ExecuteExp

; 2476 : 						{
; 2477 : 							iScore += 50;

	mov	edx, DWORD PTR _iScore$226759[ebp]
	add	edx, 50					; 00000032H
	mov	DWORD PTR _iScore$226759[ebp], edx
$LN53@ExecuteExp:

; 2478 : 						}
; 2479 : 						if (pUnit->IsEmbarkAllWater() && !pEvalPlot->isShallowWater())

	mov	eax, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248176[ebp], eax
	mov	ecx, DWORD PTR $T248176[ebp]
	call	?IsEmbarkAllWater@CvUnit@@QBE_NXZ	; CvUnit::IsEmbarkAllWater
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN52@ExecuteExp
	mov	ecx, DWORD PTR _pEvalPlot$226755[ebp]
	call	?isShallowWater@CvPlot@@QBE_NXZ		; CvPlot::isShallowWater
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN52@ExecuteExp

; 2480 : 						{
; 2481 : 							iScore += 200;

	mov	eax, DWORD PTR _iScore$226759[ebp]
	add	eax, 200				; 000000c8H
	mov	DWORD PTR _iScore$226759[ebp], eax
$LN52@ExecuteExp:

; 2482 : 						}
; 2483 : 					}

	jmp	$LN45@ExecuteExp
$LN54@ExecuteExp:

; 2484 : 					else if (eDomain == DOMAIN_SEA)

	cmp	DWORD PTR _eDomain$226758[ebp], 0
	jne	$LN45@ExecuteExp

; 2485 : 					{
; 2486 : 						if(pUnit->canSellExoticGoods(pEvalPlot))

	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248180[ebp], ecx
	push	0
	mov	edx, DWORD PTR _pEvalPlot$226755[ebp]
	push	edx
	mov	ecx, DWORD PTR $T248180[ebp]
	call	?canSellExoticGoods@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canSellExoticGoods
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN46@ExecuteExp

; 2487 : 						{
; 2488 : 							float fRewardFactor = pUnit->calculateExoticGoodsDistanceFactor(pEvalPlot);

	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248184[ebp], ecx
	mov	edx, DWORD PTR _pEvalPlot$226755[ebp]
	push	edx
	mov	ecx, DWORD PTR $T248184[ebp]
	call	?calculateExoticGoodsDistanceFactor@CvUnit@@QAEMPBVCvPlot@@@Z ; CvUnit::calculateExoticGoodsDistanceFactor
	fstp	DWORD PTR _fRewardFactor$226767[ebp]

; 2489 : 							if (fRewardFactor >= 0.75f)

	movss	xmm0, DWORD PTR _fRewardFactor$226767[ebp]
	comiss	xmm0, DWORD PTR __real@3f400000
	jb	SHORT $LN48@ExecuteExp

; 2490 : 							{
; 2491 : 								iScore += 150;

	mov	eax, DWORD PTR _iScore$226759[ebp]
	add	eax, 150				; 00000096H
	mov	DWORD PTR _iScore$226759[ebp], eax
	jmp	SHORT $LN46@ExecuteExp
$LN48@ExecuteExp:

; 2492 : 							}
; 2493 : 							else if (fRewardFactor >= 0.5f)

	movss	xmm0, DWORD PTR _fRewardFactor$226767[ebp]
	comiss	xmm0, DWORD PTR __real@3f000000
	jb	SHORT $LN46@ExecuteExp

; 2494 : 							{
; 2495 : 								iScore += 75;

	mov	ecx, DWORD PTR _iScore$226759[ebp]
	add	ecx, 75					; 0000004bH
	mov	DWORD PTR _iScore$226759[ebp], ecx
$LN46@ExecuteExp:

; 2496 : 							}
; 2497 : 						}
; 2498 : 
; 2499 : 						if(pEvalPlot->isAdjacentToLand())

	mov	ecx, DWORD PTR _pEvalPlot$226755[ebp]
	call	?isAdjacentToLand@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentToLand
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN45@ExecuteExp

; 2500 : 						{
; 2501 : 							iScore += 200;

	mov	eax, DWORD PTR _iScore$226759[ebp]
	add	eax, 200				; 000000c8H
	mov	DWORD PTR _iScore$226759[ebp], eax
$LN45@ExecuteExp:

; 2502 : 						}
; 2503 : 					}
; 2504 : 
; 2505 : #if defined(PATH_PLAN_LAST)
; 2506 : 					aBestPlotList.push_back(pEvalPlot, iScore);

	mov	DWORD PTR _weightedElem$248193[ebp], 0
	mov	DWORD PTR _weightedElem$248193[ebp+4], 0
	mov	ecx, DWORD PTR _pEvalPlot$226755[ebp]
	mov	DWORD PTR _weightedElem$248193[ebp], ecx
	mov	edx, DWORD PTR _iScore$226759[ebp]
	mov	DWORD PTR _weightedElem$248193[ebp+4], edx
	lea	eax, DWORD PTR _weightedElem$248193[ebp]
	push	eax
	lea	ecx, DWORD PTR _aBestPlotList$[ebp]
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::push_back
$LN378@ExecuteExp:

; 2507 : #endif
; 2508 : 				}
; 2509 : 
; 2510 : #if !defined(PATH_PLAN_LAST)
; 2511 : 				if(iScore > iBestPlotScore)
; 2512 : 				{
; 2513 : 					pBestPlot = pEvalPlot;
; 2514 : 					iBestPlotScore = iScore;
; 2515 : 					bFoundNearbyExplorePlot = true;
; 2516 : 				}
; 2517 : #endif
; 2518 : 			}

	jmp	$LN59@ExecuteExp
$LN58@ExecuteExp:

; 2519 : 		}

	jmp	$LN62@ExecuteExp
$LN61@ExecuteExp:

; 2520 : 
; 2521 : #if defined(PATH_PLAN_LAST)
; 2522 : 		uint uiListSize;
; 2523 : 		if ((uiListSize = aBestPlotList.size()) > 0)

	mov	ecx, DWORD PTR _aBestPlotList$[ebp+4]
	mov	DWORD PTR $T248198[ebp], ecx
	mov	edx, DWORD PTR $T248198[ebp]
	mov	DWORD PTR _uiListSize$226772[ebp], edx
	cmp	DWORD PTR _uiListSize$226772[ebp], 0
	jbe	$LN41@ExecuteExp

; 2524 : 		{
; 2525 : 			aBestPlotList.SortItems();	// highest score will be first.

	lea	ecx, DWORD PTR _aBestPlotList$[ebp]
	call	?SortItems@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXXZ ; CvWeightedVector<CvPlot *,100,1>::SortItems

; 2526 : 			for (uint i = 0; i < uiListSize; ++i )	

	mov	DWORD PTR _i$226774[ebp], 0
	jmp	SHORT $LN43@ExecuteExp
$LN42@ExecuteExp:
	mov	eax, DWORD PTR _i$226774[ebp]
	add	eax, 1
	mov	DWORD PTR _i$226774[ebp], eax
$LN43@ExecuteExp:
	mov	ecx, DWORD PTR _i$226774[ebp]
	cmp	ecx, DWORD PTR _uiListSize$226772[ebp]
	jae	$LN41@ExecuteExp

; 2527 : 			{
; 2528 : 				CvPlot* pPlot = aBestPlotList.GetElement(i);

	mov	edx, DWORD PTR _i$226774[ebp]
	mov	eax, DWORD PTR _aBestPlotList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _pPlot$226778[ebp], ecx

; 2529 : 				bool bCanFindPath = kPathFinder.GenerateUnitPath(pUnit.pointer(), iUnitX, iUnitY, pPlot->getX(), pPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER /*iFlags*/, true/*bReuse*/);

	mov	edx, DWORD PTR _pPlot$226778[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T248226[ebp], eax
	mov	ecx, DWORD PTR _pPlot$226778[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T248230[ebp], edx
	mov	eax, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248234[ebp], eax
	push	1
	push	138					; 0000008aH
	mov	ecx, DWORD PTR $T248226[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248230[ebp]
	push	edx
	mov	eax, DWORD PTR _iUnitY$226713[ebp]
	push	eax
	mov	ecx, DWORD PTR _iUnitX$226712[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248234[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPathFinder$[ebp]
	call	?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z ; CvTwoLayerPathFinder::GenerateUnitPath
	mov	BYTE PTR _bCanFindPath$226779[ebp], al

; 2530 : 				if(!bCanFindPath)

	movzx	eax, BYTE PTR _bCanFindPath$226779[ebp]
	test	eax, eax
	jne	SHORT $LN40@ExecuteExp

; 2531 : 				{
; 2532 : 					continue;

	jmp	$LN42@ExecuteExp
$LN40@ExecuteExp:

; 2533 : 				}
; 2534 : 
; 2535 : 				CvAStarNode* pNode = GC.getPathFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	DWORD PTR $T248238[ebp], eax
	mov	ecx, DWORD PTR $T248238[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _pNode$226781[ebp], edx

; 2536 : 				int iDistance = pNode->m_iData2;

	mov	eax, DWORD PTR _pNode$226781[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _iDistance$226782[ebp], ecx

; 2537 : 				if(iDistance <= 1)

	cmp	DWORD PTR _iDistance$226782[ebp], 1
	jg	SHORT $LN39@ExecuteExp

; 2538 : 				{
; 2539 : 					pBestPlot = pPlot;

	mov	edx, DWORD PTR _pPlot$226778[ebp]
	mov	DWORD PTR _pBestPlot$226741[ebp], edx

; 2540 : 					break;

	jmp	SHORT $LN41@ExecuteExp
$LN39@ExecuteExp:

; 2541 : 				}
; 2542 : 			}

	jmp	$LN42@ExecuteExp
$LN41@ExecuteExp:

; 2543 : 		}
; 2544 : #endif
; 2545 : 
; 2546 : 		if(!pBestPlot && iMovementRange > 0)

	cmp	DWORD PTR _pBestPlot$226741[ebp], 0
	jne	$LN25@ExecuteExp
	cmp	DWORD PTR _iMovementRange$226745[ebp], 0
	jle	$LN25@ExecuteExp

; 2547 : 		{
; 2548 : 			FFastVector<int>& aiExplorationPlots = pEconomicAI->GetExplorationPlots();

	mov	ecx, DWORD PTR _pEconomicAI$[ebp]
	call	?GetExplorationPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ ; CvEconomicAI::GetExplorationPlots
	mov	DWORD PTR _aiExplorationPlots$226794[ebp], eax

; 2549 : 			if (aiExplorationPlots.size() > 0)

	mov	eax, DWORD PTR _aiExplorationPlots$226794[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T248242[ebp], ecx
	cmp	DWORD PTR $T248242[ebp], 0
	jbe	$LN25@ExecuteExp

; 2550 : 			{
; 2551 : 				FFastVector<int>& aiExplorationPlotRatings = pEconomicAI->GetExplorationPlotRatings();

	mov	ecx, DWORD PTR _pEconomicAI$[ebp]
	call	?GetExplorationPlotRatings@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ ; CvEconomicAI::GetExplorationPlotRatings
	mov	DWORD PTR _aiExplorationPlotRatings$226805[ebp], eax

; 2552 : 
; 2553 : 				aBestPlotList.clear();

	xor	edx, edx
	je	SHORT $LN412@ExecuteExp
	mov	DWORD PTR _i$248268[ebp], 0
	jmp	SHORT $LN414@ExecuteExp
$LN413@ExecuteExp:
	mov	eax, DWORD PTR _i$248268[ebp]
	add	eax, 1
	mov	DWORD PTR _i$248268[ebp], eax
$LN414@ExecuteExp:
	mov	ecx, DWORD PTR _i$248268[ebp]
	cmp	ecx, DWORD PTR _aBestPlotList$[ebp+4]
	jae	SHORT $LN412@ExecuteExp
	jmp	SHORT $LN413@ExecuteExp
$LN412@ExecuteExp:
	mov	DWORD PTR _aBestPlotList$[ebp+4], 0

; 2554 : 				aBestPlotList.reserve(aiExplorationPlots.size());

	mov	edx, DWORD PTR _aiExplorationPlots$226794[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T248276[ebp], eax
	mov	ecx, DWORD PTR $T248276[ebp]
	push	ecx
	lea	ecx, DWORD PTR _aBestPlotList$[ebp]
	call	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSizeToFit

; 2555 : 
; 2556 : 				iBestPlotScore = 0;

	mov	DWORD PTR _iBestPlotScore$226742[ebp], 0

; 2557 : 
; 2558 : 				for(uint ui = 0; ui < aiExplorationPlots.size(); ui++)

	mov	DWORD PTR _ui$226806[ebp], 0
	jmp	SHORT $LN36@ExecuteExp
$LN35@ExecuteExp:
	mov	edx, DWORD PTR _ui$226806[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$226806[ebp], edx
$LN36@ExecuteExp:
	mov	eax, DWORD PTR _aiExplorationPlots$226794[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T248288[ebp], ecx
	mov	edx, DWORD PTR _ui$226806[ebp]
	cmp	edx, DWORD PTR $T248288[ebp]
	jae	$LN34@ExecuteExp

; 2559 : 				{
; 2560 : 					int iPlot = aiExplorationPlots[ui];

	mov	eax, DWORD PTR _aiExplorationPlots$226794[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _ui$226806[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _iPlot$226810[ebp], eax

; 2561 : 					if(iPlot < 0)

	cmp	DWORD PTR _iPlot$226810[ebp], 0
	jge	SHORT $LN33@ExecuteExp

; 2562 : 					{
; 2563 : 						continue;

	jmp	SHORT $LN35@ExecuteExp
$LN33@ExecuteExp:

; 2564 : 					}
; 2565 : 
; 2566 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2567 : 					pEvalPlot = GC.getMap().plotByIndex(iPlot);
; 2568 : #else
; 2569 : 					CvPlot* pEvalPlot = GC.getMap().plotByIndex(iPlot);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T248295[ebp], ecx
	cmp	DWORD PTR _iPlot$226810[ebp], 0
	jl	SHORT $LN432@ExecuteExp
	mov	edx, DWORD PTR $T248295[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T248302[ebp], eax
	mov	ecx, DWORD PTR _iPlot$226810[ebp]
	cmp	ecx, DWORD PTR $T248302[ebp]
	jge	SHORT $LN432@ExecuteExp
	mov	edx, DWORD PTR _iPlot$226810[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T248295[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv1270[ebp], edx
	jmp	SHORT $LN433@ExecuteExp
$LN432@ExecuteExp:
	mov	DWORD PTR tv1270[ebp], 0
$LN433@ExecuteExp:
	mov	ecx, DWORD PTR tv1270[ebp]
	mov	DWORD PTR _pEvalPlot$226812[ebp], ecx

; 2570 : #endif
; 2571 : 					if(!pEvalPlot)

	cmp	DWORD PTR _pEvalPlot$226812[ebp], 0
	jne	SHORT $LN32@ExecuteExp

; 2572 : 					{
; 2573 : 						continue;

	jmp	$LN35@ExecuteExp
$LN32@ExecuteExp:

; 2574 : 					}
; 2575 : 
; 2576 : 					int iPlotScore = 0;

	mov	DWORD PTR _iPlotScore$226814[ebp], 0

; 2577 : 
; 2578 : 					if(!IsValidExplorerEndTurnPlot(pUnit.pointer(), pEvalPlot))

	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248312[ebp], edx
	mov	eax, DWORD PTR _pEvalPlot$226812[ebp]
	push	eax
	mov	ecx, DWORD PTR $T248312[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidExplorerEndTurnPlot@CvHomelandAI@@ABE_NPBVCvUnit@@PAVCvPlot@@@Z ; CvHomelandAI::IsValidExplorerEndTurnPlot
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN31@ExecuteExp

; 2579 : 					{
; 2580 : 						continue;

	jmp	$LN35@ExecuteExp
$LN31@ExecuteExp:

; 2581 : 					}
; 2582 : 
; 2583 : 					int iRating = aiExplorationPlotRatings[ui];

	mov	eax, DWORD PTR _aiExplorationPlotRatings$226805[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _ui$226806[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _iRating$226816[ebp], eax

; 2584 : 
; 2585 : #if defined(PATH_PLAN_LAST)
; 2586 : 					int iDistance = plotDistance(iUnitX, iUnitY, pEvalPlot->getX(), pEvalPlot->getY());

	mov	ecx, DWORD PTR _pEvalPlot$226812[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T248319[ebp], edx
	mov	eax, DWORD PTR _pEvalPlot$226812[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T248323[ebp], ecx
	mov	edx, DWORD PTR $T248319[ebp]
	push	edx
	mov	eax, DWORD PTR $T248323[ebp]
	push	eax
	mov	ecx, DWORD PTR _iUnitY$226713[ebp]
	push	ecx
	mov	edx, DWORD PTR _iUnitX$226712[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$226817[ebp], eax

; 2587 : 					int iEstimateTurns = iDistance / iMovementRange;

	mov	eax, DWORD PTR _iDistance$226817[ebp]
	cdq
	idiv	DWORD PTR _iMovementRange$226745[ebp]
	mov	DWORD PTR _iEstimateTurns$226818[ebp], eax

; 2588 : 					if(iEstimateTurns == 0)

	cmp	DWORD PTR _iEstimateTurns$226818[ebp], 0
	jne	SHORT $LN30@ExecuteExp

; 2589 : 					{
; 2590 : 						iPlotScore = 1000 * iRating;

	mov	eax, DWORD PTR _iRating$226816[ebp]
	imul	eax, 1000				; 000003e8H
	mov	DWORD PTR _iPlotScore$226814[ebp], eax

; 2591 : 					}
; 2592 : 					else

	jmp	SHORT $LN29@ExecuteExp
$LN30@ExecuteExp:

; 2593 : 					{
; 2594 : 						iPlotScore = (1000 * iRating) / iEstimateTurns;

	mov	eax, DWORD PTR _iRating$226816[ebp]
	imul	eax, 1000				; 000003e8H
	cdq
	idiv	DWORD PTR _iEstimateTurns$226818[ebp]
	mov	DWORD PTR _iPlotScore$226814[ebp], eax
$LN29@ExecuteExp:

; 2595 : 					}
; 2596 : 
; 2597 : 					aBestPlotList.push_back(pEvalPlot, iPlotScore);

	mov	DWORD PTR _weightedElem$248369[ebp], 0
	mov	DWORD PTR _weightedElem$248369[ebp+4], 0
	mov	ecx, DWORD PTR _pEvalPlot$226812[ebp]
	mov	DWORD PTR _weightedElem$248369[ebp], ecx
	mov	edx, DWORD PTR _iPlotScore$226814[ebp]
	mov	DWORD PTR _weightedElem$248369[ebp+4], edx
	lea	eax, DWORD PTR _weightedElem$248369[ebp]
	push	eax
	lea	ecx, DWORD PTR _aBestPlotList$[ebp]
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::push_back

; 2598 : #else
; 2599 : 					// hitting the path finder, may not be the best idea. . .
; 2600 : 					bool bCanFindPath = GC.getPathFinder().GenerateUnitPath(pUnit.pointer(), iUnitX, iUnitY, pEvalPlot->getX(), pEvalPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER /*iFlags*/, true/*bReuse*/);
; 2601 : 					if(!bCanFindPath)
; 2602 : 					{
; 2603 : 						continue;
; 2604 : 					}
; 2605 : 
; 2606 : 					CvAStarNode* pNode = GC.getPathFinder().GetLastNode();
; 2607 : 					int iDistance = pNode->m_iData2;
; 2608 : 					if(iDistance == 0)
; 2609 : 					{
; 2610 : 						iPlotScore = 1000 * iRating;
; 2611 : 					}
; 2612 : 					else
; 2613 : 					{
; 2614 : 						iPlotScore = (1000 * iRating) / iDistance;
; 2615 : 					}
; 2616 : 
; 2617 : 					if(iPlotScore > iBestPlotScore)
; 2618 : 					{
; 2619 : 						CvPlot* pEndTurnPlot = GC.getPathFinder().GetPathEndTurnPlot();
; 2620 : 						if(pEndTurnPlot == pUnit->plot())
; 2621 : 						{
; 2622 : 							pBestPlot = NULL;
; 2623 : 							iBestPlotScore = iPlotScore;
; 2624 : 						}
; 2625 : 						else if(IsValidExplorerEndTurnPlot(pUnit.pointer(), pEndTurnPlot))
; 2626 : 						{
; 2627 : 							pBestPlot = pEndTurnPlot;
; 2628 : 							iBestPlotScore = iPlotScore;
; 2629 : 						}
; 2630 : 						else
; 2631 : 						{
; 2632 : 							// not a valid destination
; 2633 : 							continue;
; 2634 : 						}
; 2635 : 					}
; 2636 : #endif
; 2637 : 				}

	jmp	$LN35@ExecuteExp
$LN34@ExecuteExp:

; 2638 : 
; 2639 : #if defined(PATH_PLAN_LAST)
; 2640 : 				if ((uiListSize = aBestPlotList.size()) > 0)

	mov	ecx, DWORD PTR _aBestPlotList$[ebp+4]
	mov	DWORD PTR $T248374[ebp], ecx
	mov	edx, DWORD PTR $T248374[ebp]
	mov	DWORD PTR _uiListSize$226772[ebp], edx
	cmp	DWORD PTR _uiListSize$226772[ebp], 0
	jbe	$LN25@ExecuteExp

; 2641 : 				{
; 2642 : 					aBestPlotList.SortItems();		// Highest score will be first.

	lea	ecx, DWORD PTR _aBestPlotList$[ebp]
	call	?SortItems@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXXZ ; CvWeightedVector<CvPlot *,100,1>::SortItems

; 2643 : 					for (uint i = 0; i < uiListSize ; ++i )	

	mov	DWORD PTR _i$226822[ebp], 0
	jmp	SHORT $LN27@ExecuteExp
$LN26@ExecuteExp:
	mov	eax, DWORD PTR _i$226822[ebp]
	add	eax, 1
	mov	DWORD PTR _i$226822[ebp], eax
$LN27@ExecuteExp:
	mov	ecx, DWORD PTR _i$226822[ebp]
	cmp	ecx, DWORD PTR _uiListSize$226772[ebp]
	jae	$LN25@ExecuteExp

; 2644 : 					{
; 2645 : 						CvPlot* pPlot = aBestPlotList.GetElement(i);

	mov	edx, DWORD PTR _i$226822[ebp]
	mov	eax, DWORD PTR _aBestPlotList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _pPlot$226826[ebp], ecx

; 2646 : 						bool bCanFindPath = GC.getPathFinder().GenerateUnitPath(pUnit.pointer(), iUnitX, iUnitY, pPlot->getX(), pPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER /*iFlags*/, true/*bReuse*/);

	mov	edx, DWORD PTR _pPlot$226826[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T248402[ebp], eax
	mov	ecx, DWORD PTR _pPlot$226826[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T248406[ebp], edx
	mov	eax, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248410[ebp], eax
	push	1
	push	138					; 0000008aH
	mov	ecx, DWORD PTR $T248402[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248406[ebp]
	push	edx
	mov	eax, DWORD PTR _iUnitY$226713[ebp]
	push	eax
	mov	ecx, DWORD PTR _iUnitX$226712[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248410[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	ecx, eax
	call	?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z ; CvTwoLayerPathFinder::GenerateUnitPath
	mov	BYTE PTR _bCanFindPath$226827[ebp], al

; 2647 : 						if(!bCanFindPath)

	movzx	eax, BYTE PTR _bCanFindPath$226827[ebp]
	test	eax, eax
	jne	SHORT $LN24@ExecuteExp

; 2648 : 						{
; 2649 : 							continue;

	jmp	$LN26@ExecuteExp
$LN24@ExecuteExp:

; 2650 : 						}
; 2651 : 
; 2652 : 						CvPlot* pEndTurnPlot = GC.getPathFinder().GetPathEndTurnPlot();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	ecx, eax
	call	?GetPathEndTurnPlot@CvTwoLayerPathFinder@@QBEPAVCvPlot@@XZ ; CvTwoLayerPathFinder::GetPathEndTurnPlot
	mov	DWORD PTR _pEndTurnPlot$226829[ebp], eax

; 2653 : 						if(pEndTurnPlot == pUnit->plot())

	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248414[ebp], ecx
	mov	ecx, DWORD PTR $T248414[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	DWORD PTR _pEndTurnPlot$226829[ebp], eax
	jne	SHORT $LN23@ExecuteExp
	jmp	$LN26@ExecuteExp

; 2654 : 						{
; 2655 : 							continue;

	jmp	SHORT $LN20@ExecuteExp
$LN23@ExecuteExp:

; 2656 : 						}
; 2657 : 						else if(IsValidExplorerEndTurnPlot(pUnit.pointer(), pEndTurnPlot))

	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248418[ebp], edx
	mov	eax, DWORD PTR _pEndTurnPlot$226829[ebp]
	push	eax
	mov	ecx, DWORD PTR $T248418[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidExplorerEndTurnPlot@CvHomelandAI@@ABE_NPBVCvUnit@@PAVCvPlot@@@Z ; CvHomelandAI::IsValidExplorerEndTurnPlot
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN21@ExecuteExp

; 2658 : 						{
; 2659 : 							pBestPlot = pEndTurnPlot;

	mov	eax, DWORD PTR _pEndTurnPlot$226829[ebp]
	mov	DWORD PTR _pBestPlot$226741[ebp], eax

; 2660 : 							break;

	jmp	SHORT $LN25@ExecuteExp

; 2661 : 						}
; 2662 : 						else

	jmp	SHORT $LN20@ExecuteExp
$LN21@ExecuteExp:

; 2663 : 						{
; 2664 : 							// not a valid destination
; 2665 : 							continue;

	jmp	$LN26@ExecuteExp
$LN20@ExecuteExp:

; 2666 : 						}
; 2667 : 					}

	jmp	$LN26@ExecuteExp
$LN25@ExecuteExp:

; 2668 : 				}
; 2669 : #endif
; 2670 : 			}
; 2671 : 		}
; 2672 : 
; 2673 : 		if(pBestPlot)

	cmp	DWORD PTR _pBestPlot$226741[ebp], 0
	je	$LN19@ExecuteExp

; 2674 : 		{
; 2675 : 			CvAssertMsg(!pUnit->atPlot(*pBestPlot), "Exploring unit is already at the best place to explore");
; 2676 : 			pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestPlot->getX(), pBestPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER, false, false, MISSIONAI_EXPLORE, pBestPlot);

	mov	ecx, DWORD PTR _pBestPlot$226741[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T248422[ebp], edx
	mov	eax, DWORD PTR _pBestPlot$226741[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T248426[ebp], ecx
	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248430[ebp], edx
	push	0
	mov	eax, DWORD PTR _pBestPlot$226741[ebp]
	push	eax
	push	14					; 0000000eH
	push	0
	push	0
	push	138					; 0000008aH
	mov	ecx, DWORD PTR $T248422[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248426[ebp]
	push	edx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T248430[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2677 : 
; 2678 : 			// Only mark as done if out of movement
; 2679 : 			if(pUnit->getMoves() <= 0)

	mov	eax, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248434[ebp], eax
	mov	ecx, DWORD PTR $T248434[ebp]
	call	?getMoves@CvUnit@@QBEHXZ		; CvUnit::getMoves
	test	eax, eax
	jg	SHORT $LN18@ExecuteExp

; 2680 : 			{
; 2681 : 				UnitProcessed(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248438[ebp], ecx
	mov	edx, DWORD PTR $T248438[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T248447[ebp], eax
	mov	ecx, DWORD PTR $T248447[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed
$LN18@ExecuteExp:

; 2682 : 			}
; 2683 : 
; 2684 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN17@ExecuteExp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	$LN17@ExecuteExp

; 2685 : 			{
; 2686 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226837[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 2687 : 				if(bFoundNearbyExplorePlot)

	movzx	ecx, BYTE PTR _bFoundNearbyExplorePlot$[ebp]
	test	ecx, ecx
	je	$LN16@ExecuteExp

; 2688 : 				{
; 2689 : 					strLogString.Format("UnitID: %d Explored to nearby target, To X: %d, Y: %d, From X: %d, Y: %d", pUnit->GetID(), pUnit->getX(), pUnit->getY(), iUnitX, iUnitY);

	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248455[ebp], edx
	mov	eax, DWORD PTR $T248455[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T248464[ebp], ecx
	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248468[ebp], edx
	mov	eax, DWORD PTR $T248468[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T248477[ebp], ecx
	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248481[ebp], edx
	mov	eax, DWORD PTR $T248481[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T248490[ebp], ecx
	mov	edx, DWORD PTR _iUnitY$226713[ebp]
	push	edx
	mov	eax, DWORD PTR _iUnitX$226712[ebp]
	push	eax
	mov	ecx, DWORD PTR $T248464[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248477[ebp]
	push	edx
	mov	eax, DWORD PTR $T248490[ebp]
	push	eax
	push	OFFSET ??_C@_0EJ@BBDMCOFD@UnitID?3?5?$CFd?5Explored?5to?5nearby?5ta@
	lea	ecx, DWORD PTR _strLogString$226837[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH

; 2690 : 				}
; 2691 : 				else

	jmp	$LN15@ExecuteExp
$LN16@ExecuteExp:

; 2692 : 				{
; 2693 : 					strLogString.Format("UnitID: %d Explored to distant target, To X: %d, Y: %d, From X: %d, Y: %d", pUnit->GetID(), pUnit->getX(), pUnit->getY(), iUnitX, iUnitY);

	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248494[ebp], edx
	mov	eax, DWORD PTR $T248494[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T248503[ebp], ecx
	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248507[ebp], edx
	mov	eax, DWORD PTR $T248507[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T248516[ebp], ecx
	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248520[ebp], edx
	mov	eax, DWORD PTR $T248520[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T248529[ebp], ecx
	mov	edx, DWORD PTR _iUnitY$226713[ebp]
	push	edx
	mov	eax, DWORD PTR _iUnitX$226712[ebp]
	push	eax
	mov	ecx, DWORD PTR $T248503[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248516[ebp]
	push	edx
	mov	eax, DWORD PTR $T248529[ebp]
	push	eax
	push	OFFSET ??_C@_0EK@ILPEBCHH@UnitID?3?5?$CFd?5Explored?5to?5distant?5t@
	lea	ecx, DWORD PTR _strLogString$226837[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH
$LN15@ExecuteExp:

; 2694 : 				}
; 2695 : 				LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$226837[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2696 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLogString$226837[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@ExecuteExp:

; 2697 : 		}
; 2698 : 		else

	jmp	$LN1@ExecuteExp
$LN19@ExecuteExp:

; 2699 : 		{
; 2700 : 			if(pUnit->isHuman())

	mov	eax, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248537[ebp], eax
	mov	ecx, DWORD PTR $T248537[ebp]
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	movzx	ecx, al
	test	ecx, ecx
	je	$LN13@ExecuteExp

; 2701 : 			{
; 2702 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN12@ExecuteExp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	$LN12@ExecuteExp

; 2703 : 				{
; 2704 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226845[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 9

; 2705 : 					strLogString.Format("UnitID: %d Explorer (human) found no target, X: %d, Y: %d", pUnit->GetID(), pUnit->getX(), pUnit->getY());

	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248545[ebp], ecx
	mov	edx, DWORD PTR $T248545[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T248554[ebp], eax
	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248558[ebp], ecx
	mov	edx, DWORD PTR $T248558[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T248567[ebp], eax
	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248571[ebp], ecx
	mov	edx, DWORD PTR $T248571[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T248580[ebp], eax
	mov	ecx, DWORD PTR $T248554[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248567[ebp]
	push	edx
	mov	eax, DWORD PTR $T248580[ebp]
	push	eax
	push	OFFSET ??_C@_0DK@CAGIJFE@UnitID?3?5?$CFd?5Explorer?5?$CIhuman?$CJ?5foun@
	lea	ecx, DWORD PTR _strLogString$226845[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2706 : 					LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$226845[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2707 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLogString$226845[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN12@ExecuteExp:

; 2708 : 				pUnit->SetAutomateType(NO_AUTOMATE);

	push	-1
	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	call	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z ; CvUnit::SetAutomateType

; 2709 : 				UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248591[ebp], eax
	mov	ecx, DWORD PTR $T248591[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T248600[ebp], edx
	mov	eax, DWORD PTR $T248600[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 2710 : 			}
; 2711 : 			else

	jmp	$LN1@ExecuteExp
$LN13@ExecuteExp:

; 2712 : 			{
; 2713 : 				// If this is a land explorer and there is no ignore unit path to a friendly city, then disband him
; 2714 : 				if(pUnit->AI_getUnitAIType() == UNITAI_EXPLORE)

	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248604[ebp], ecx
	mov	ecx, DWORD PTR $T248604[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	jne	$LN10@ExecuteExp

; 2715 : 				{
; 2716 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN9@ExecuteExp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	$LN9@ExecuteExp

; 2717 : 					{
; 2718 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226850[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH

; 2719 : 						strLogString.Format("UnitID: %d Explorer (AI) found no target, X: %d, Y: %d", pUnit->GetID(), pUnit->getX(), pUnit->getY());

	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248612[ebp], ecx
	mov	edx, DWORD PTR $T248612[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T248621[ebp], eax
	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248625[ebp], ecx
	mov	edx, DWORD PTR $T248625[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T248634[ebp], eax
	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248638[ebp], ecx
	mov	edx, DWORD PTR $T248638[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T248647[ebp], eax
	mov	ecx, DWORD PTR $T248621[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248634[ebp]
	push	edx
	mov	eax, DWORD PTR $T248647[ebp]
	push	eax
	push	OFFSET ??_C@_0DH@MCLBCMKC@UnitID?3?5?$CFd?5Explorer?5?$CIAI?$CJ?5found?5n@
	lea	ecx, DWORD PTR _strLogString$226850[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2720 : 						LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$226850[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2721 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLogString$226850[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN9@ExecuteExp:

; 2722 : 
; 2723 : 					CvCity* pLoopCity;
; 2724 : 					int iLoop;
; 2725 : 					bool bFoundPath = false;

	mov	BYTE PTR _bFoundPath$226854[ebp], 0

; 2726 : 					for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$226853[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$226852[ebp], eax
	jmp	SHORT $LN8@ExecuteExp
$LN7@ExecuteExp:
	push	0
	lea	edx, DWORD PTR _iLoop$226853[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$226852[ebp], eax
$LN8@ExecuteExp:
	cmp	DWORD PTR _pLoopCity$226852[ebp], 0
	je	SHORT $LN6@ExecuteExp

; 2727 : 					{
; 2728 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2729 : 						if (GC.getIgnoreUnitsPathFinder().DoesPathExist(pUnit.pointer(), pUnit->plot(), pLoopCity->plot()))
; 2730 : #else
; 2731 : 						if(GC.getIgnoreUnitsPathFinder().DoesPathExist(*(pUnit), pUnit->plot(), pLoopCity->plot()))

	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248655[ebp], ecx
	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248659[ebp], edx
	mov	ecx, DWORD PTR _pLoopCity$226852[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, DWORD PTR $T248655[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	eax, DWORD PTR $T248659[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	ecx, eax
	call	?DoesPathExist@CvIgnoreUnitsPathFinder@@QAE_NAAVCvUnit@@PAVCvPlot@@1@Z ; CvIgnoreUnitsPathFinder::DoesPathExist
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@ExecuteExp

; 2732 : #endif
; 2733 : 						{
; 2734 : 							bFoundPath = true;

	mov	BYTE PTR _bFoundPath$226854[ebp], 1

; 2735 : 							break;

	jmp	SHORT $LN6@ExecuteExp
$LN5@ExecuteExp:

; 2736 : 						}
; 2737 : 					}

	jmp	SHORT $LN7@ExecuteExp
$LN6@ExecuteExp:

; 2738 : 					if(!bFoundPath)

	movzx	edx, BYTE PTR _bFoundPath$226854[ebp]
	test	edx, edx
	jne	$LN4@ExecuteExp

; 2739 : 					{
; 2740 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226860[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH

; 2741 : 						strLogString.Format("UnitID: %d Disbanding explorer, X: %d, Y: %d", pUnit->GetID(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248667[ebp], eax
	mov	ecx, DWORD PTR $T248667[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T248676[ebp], edx
	mov	eax, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248680[ebp], eax
	mov	ecx, DWORD PTR $T248680[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T248689[ebp], edx
	mov	eax, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248693[ebp], eax
	mov	ecx, DWORD PTR $T248693[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T248702[ebp], edx
	mov	eax, DWORD PTR $T248676[ebp]
	push	eax
	mov	ecx, DWORD PTR $T248689[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248702[ebp]
	push	edx
	push	OFFSET ??_C@_0CN@ILCLKMBJ@UnitID?3?5?$CFd?5Disbanding?5explorer?0?5@
	lea	eax, DWORD PTR _strLogString$226860[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2742 : 						LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$226860[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2743 : 
; 2744 : 						UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248706[ebp], edx
	mov	eax, DWORD PTR $T248706[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T248715[ebp], ecx
	mov	edx, DWORD PTR $T248715[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 2745 : #ifdef AUI_HOMELAND_FIX_EXECUTE_EXPLORER_MOVES_DISBAND
; 2746 : 						pUnit->scrap();
; 2747 : #else
; 2748 : 						pUnit->kill(true);

	push	-1
	push	1
	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill

; 2749 : #endif
; 2750 : 						m_pPlayer->GetEconomicAI()->IncrementExplorersDisbanded();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR $T248722[ebp], eax
	mov	ecx, DWORD PTR $T248722[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, 1
	mov	eax, DWORD PTR $T248722[ebp]
	mov	DWORD PTR [eax+36], edx

; 2751 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLogString$226860[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@ExecuteExp:

; 2752 : 				}

	jmp	$LN1@ExecuteExp
$LN10@ExecuteExp:

; 2753 : 				else if(pUnit->AI_getUnitAIType() == UNITAI_EXPLORE_SEA)

	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248730[ebp], ecx
	mov	ecx, DWORD PTR $T248730[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	jne	$LN1@ExecuteExp

; 2754 : 				{
; 2755 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN1@ExecuteExp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	$LN1@ExecuteExp

; 2756 : 					{
; 2757 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226865[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH

; 2758 : 						strLogString.Format("UnitID: %d Sea explorer (AI) found no target, X: %d, Y: %d", pUnit->GetID(), pUnit->getX(), pUnit->getY());

	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248738[ebp], ecx
	mov	edx, DWORD PTR $T248738[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T248747[ebp], eax
	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248751[ebp], ecx
	mov	edx, DWORD PTR $T248751[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T248760[ebp], eax
	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	mov	DWORD PTR $T248764[ebp], ecx
	mov	edx, DWORD PTR $T248764[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T248773[ebp], eax
	mov	ecx, DWORD PTR $T248747[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248760[ebp]
	push	edx
	mov	eax, DWORD PTR $T248773[ebp]
	push	eax
	push	OFFSET ??_C@_0DL@ICDBNDME@UnitID?3?5?$CFd?5Sea?5explorer?5?$CIAI?$CJ?5fou@
	lea	ecx, DWORD PTR _strLogString$226865[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2759 : 						LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$226865[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2760 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLogString$226865[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteExp:

; 2761 : 				}
; 2762 : 			}
; 2763 : 		}
; 2764 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pUnit$226697[ebp], 0
	je	SHORT $LN681@ExecuteExp
	mov	ecx, DWORD PTR _pUnit$226697[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN681@ExecuteExp:
	jmp	$LN89@ExecuteExp
$LN88@ExecuteExp:

; 2765 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _aBestPlotList$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _aBestPlotList$[ebp]
	jmp	??1?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ ; CvWeightedVector<CvPlot *,100,1>::~CvWeightedVector<CvPlot *,100,1>
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _pUnit$226697[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _args$226702[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strLogString$226710[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLogString$226718[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strLogString$226731[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR _strLogString$226735[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _strLogString$226739[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$8:
	lea	ecx, DWORD PTR _strLogString$226837[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$9:
	lea	ecx, DWORD PTR _strLogString$226845[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$10:
	lea	ecx, DWORD PTR _strLogString$226850[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$11:
	lea	ecx, DWORD PTR _strLogString$226860[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$12:
	lea	ecx, DWORD PTR _strLogString$226865[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1992]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteExplorerMoves
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
tv83 = -96						; size = 4
tv81 = -92						; size = 4
tv78 = -88						; size = 4
tv74 = -84						; size = 4
tv71 = -80						; size = 4
_iAbsDY$216767 = -20					; size = 4
_iAbsDX$216766 = -16					; size = 4
_iAbsDY$216764 = -12					; size = 4
_iAbsDX$216763 = -8					; size = 4
_hexRange$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	xor	eax, eax
	cmp	DWORD PTR _iDX$[ebp], 0
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN3@plotXYWith

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN6@plotXYWith
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN7@plotXYWith
$LN6@plotXYWith:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv71[ebp], eax
$LN7@plotXYWith:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _iAbsDX$216763[ebp], ecx

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN8@plotXYWith
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN9@plotXYWith
$LN8@plotXYWith:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv74[ebp], eax
$LN9@plotXYWith:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _iAbsDY$216764[ebp], ecx

; 245  : 		hexRange = iAbsDX + iAbsDY;

	mov	edx, DWORD PTR _iAbsDX$216763[ebp]
	add	edx, DWORD PTR _iAbsDY$216764[ebp]
	mov	DWORD PTR _hexRange$[ebp], edx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN2@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN10@plotXYWith
	mov	eax, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN11@plotXYWith
$LN10@plotXYWith:
	mov	ecx, DWORD PTR _iDX$[ebp]
	neg	ecx
	mov	DWORD PTR tv78[ebp], ecx
$LN11@plotXYWith:
	mov	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _iAbsDX$216766[ebp], edx

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN12@plotXYWith
	mov	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN13@plotXYWith
$LN12@plotXYWith:
	mov	ecx, DWORD PTR _iDY$[ebp]
	neg	ecx
	mov	DWORD PTR tv81[ebp], ecx
$LN13@plotXYWith:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _iAbsDY$216767[ebp], edx

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	mov	eax, DWORD PTR _iAbsDX$216766[ebp]
	cmp	eax, DWORD PTR _iAbsDY$216767[ebp]
	jl	SHORT $LN14@plotXYWith
	mov	ecx, DWORD PTR _iAbsDX$216766[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN15@plotXYWith
$LN14@plotXYWith:
	mov	edx, DWORD PTR _iAbsDY$216767[ebp]
	mov	DWORD PTR tv83[ebp], edx
$LN15@plotXYWith:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR _hexRange$[ebp], eax
$LN2@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	mov	ecx, DWORD PTR _hexRange$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@plotXYWith
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	edx, DWORD PTR _iDY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$[ebp]
	push	edx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
$LN4@plotXYWith:

; 261  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
tv148 = -72						; size = 4
tv163 = -68						; size = 4
tv86 = -64						; size = 4
tv82 = -60						; size = 4
$T249082 = -56						; size = 4
$T249037 = -52						; size = 4
$T249024 = -48						; size = 4
$T249020 = -44						; size = 4
$T249006 = -40						; size = 4
$T249002 = -33						; size = 1
$T248991 = -32						; size = 4
$T248987 = -25						; size = 1
_iMapY$249081 = -24					; size = 4
_iMapX$249080 = -20					; size = 4
$T248980 = -16						; size = 4
_iPlotHexX$ = -12					; size = 4
_iPlotY$ = -8						; size = 4
_iStartHexX$ = -4					; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN5@plotXY
	mov	eax, DWORD PTR _iY$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN3@plotXY
$LN5@plotXY:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
$LN3@plotXY:
	mov	ecx, DWORD PTR _iX$[ebp]
	sub	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR _iStartHexX$[ebp], ecx

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	edx, DWORD PTR _iStartHexX$[ebp]
	add	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR _iPlotY$[ebp], eax

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	js	SHORT $LN9@plotXY
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN7@plotXY
$LN9@plotXY:
	mov	eax, DWORD PTR _iPlotY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv86[ebp], eax
$LN7@plotXY:
	mov	edx, DWORD PTR _iPlotHexX$[ebp]
	add	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T248980[ebp], eax
	cmp	DWORD PTR _iPlotHexX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN13@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN14@plotXY
$LN13@plotXY:
	mov	DWORD PTR $T249082[ebp], 0
	jmp	$LN15@plotXY
$LN14@plotXY:
	mov	ecx, DWORD PTR $T248980[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T248987[ebp], dl
	mov	eax, DWORD PTR $T248980[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T248991[ebp], ecx
	movzx	edx, BYTE PTR $T248987[ebp]
	test	edx, edx
	je	SHORT $LN26@plotXY
	cmp	DWORD PTR _iPlotHexX$[ebp], 0
	jge	SHORT $LN25@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T248991[ebp]
	add	edx, DWORD PTR $T248991[ebp]
	mov	DWORD PTR _iMapX$249080[ebp], edx
	jmp	SHORT $LN27@plotXY
	jmp	SHORT $LN26@plotXY
$LN25@plotXY:
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cmp	eax, DWORD PTR $T248991[ebp]
	jl	SHORT $LN26@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T248991[ebp]
	mov	DWORD PTR _iMapX$249080[ebp], edx
	jmp	SHORT $LN27@plotXY
$LN26@plotXY:
	mov	ecx, DWORD PTR _iPlotHexX$[ebp]
	mov	DWORD PTR _iMapX$249080[ebp], ecx
$LN27@plotXY:
	mov	edx, DWORD PTR $T248980[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T249002[ebp], al
	mov	ecx, DWORD PTR $T248980[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T249006[ebp], edx
	movzx	eax, BYTE PTR $T249002[ebp]
	test	eax, eax
	je	SHORT $LN36@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], 0
	jge	SHORT $LN35@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T249006[ebp]
	add	edx, DWORD PTR $T249006[ebp]
	mov	DWORD PTR _iMapY$249081[ebp], edx
	jmp	SHORT $LN37@plotXY
	jmp	SHORT $LN36@plotXY
$LN35@plotXY:
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	cmp	ecx, DWORD PTR $T249006[ebp]
	jl	SHORT $LN36@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T249006[ebp]
	mov	DWORD PTR _iMapY$249081[ebp], edx
	jmp	SHORT $LN37@plotXY
$LN36@plotXY:
	mov	edx, DWORD PTR _iPlotY$[ebp]
	mov	DWORD PTR _iMapY$249081[ebp], edx
$LN37@plotXY:
	cmp	DWORD PTR _iMapX$249080[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T248980[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T249020[ebp], ecx
	mov	edx, DWORD PTR _iMapX$249080[ebp]
	cmp	edx, DWORD PTR $T249020[ebp]
	jge	SHORT $LN41@plotXY
	cmp	DWORD PTR _iMapY$249081[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T248980[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T249024[ebp], ecx
	mov	edx, DWORD PTR _iMapY$249081[ebp]
	cmp	edx, DWORD PTR $T249024[ebp]
	jge	SHORT $LN41@plotXY
	mov	DWORD PTR tv163[ebp], 1
	jmp	SHORT $LN39@plotXY
$LN41@plotXY:
	mov	DWORD PTR tv163[ebp], 0
$LN39@plotXY:
	cmp	DWORD PTR tv163[ebp], 0
	je	SHORT $LN17@plotXY
	mov	eax, DWORD PTR $T248980[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T249037[ebp], ecx
	mov	edx, DWORD PTR _iMapY$249081[ebp]
	imul	edx, DWORD PTR $T249037[ebp]
	add	edx, DWORD PTR _iMapX$249080[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T248980[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv148[ebp], edx
	jmp	SHORT $LN18@plotXY
$LN17@plotXY:
	mov	DWORD PTR tv148[ebp], 0
$LN18@plotXY:
	mov	ecx, DWORD PTR tv148[ebp]
	mov	DWORD PTR $T249082[ebp], ecx
$LN15@plotXY:
	mov	eax, DWORD PTR $T249082[ebp]

; 224  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	??_C@_0M@NLDMKCCI@2nd?5Safety?0?$AA@		; `string'
PUBLIC	?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteWorkerMove
PUBLIC	??_C@_0M@OOGOHIPM@1st?5Safety?0?$AA@		; `string'
PUBLIC	??_C@_03DPLIHHLN@?$CFd?0?$AA@			; `string'
PUBLIC	??_C@_01IHBHIGKO@?0?$AA@			; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BG@IAMEKOEI@BuilderTaskingLog?4csv?$AA@	; `string'
PUBLIC	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
PUBLIC	__$ArrayPad$
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	?GetBuilderAILogging@CvGlobals@@QAE_NXZ:PROC	; CvGlobals::GetBuilderAILogging
EXTRN	?IsPlotUnderImmediateThreat@CvPlayer@@QBE_NAAVCvPlot@@@Z:PROC ; CvPlayer::IsPlotUnderImmediateThreat
;	COMDAT ??_C@_0M@NLDMKCCI@2nd?5Safety?0?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0M@NLDMKCCI@2nd?5Safety?0?$AA@ DB '2nd Safety,', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OOGOHIPM@1st?5Safety?0?$AA@
CONST	SEGMENT
??_C@_0M@OOGOHIPM@1st?5Safety?0?$AA@ DB '1st Safety,', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03DPLIHHLN@?$CFd?0?$AA@
CONST	SEGMENT
??_C@_03DPLIHHLN@?$CFd?0?$AA@ DB '%d,', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01IHBHIGKO@?0?$AA@
CONST	SEGMENT
??_C@_01IHBHIGKO@?0?$AA@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IAMEKOEI@BuilderTaskingLog?4csv?$AA@
CONST	SEGMENT
??_C@_0BG@IAMEKOEI@BuilderTaskingLog?4csv?$AA@ DB 'BuilderTaskingLog.csv', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$3
	DD	02H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$5
	DD	04H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$6
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$7
	DD	06H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$8
	DD	07H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$9
	DD	08H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$10
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv304 = -452						; size = 4
tv598 = -448						; size = 4
tv182 = -444						; size = 4
tv479 = -440						; size = 4
tv156 = -436						; size = 4
_this$ = -432						; size = 4
$T249386 = -428						; size = 4
$T249377 = -424						; size = 4
$T249370 = -420						; size = 4
$T249357 = -416						; size = 4
$T249348 = -412						; size = 4
$T249341 = -408						; size = 4
$T249321 = -404						; size = 4
$T249317 = -400						; size = 4
$T249308 = -396						; size = 4
$T249304 = -392						; size = 4
$T249300 = -388						; size = 4
$T249282 = -384						; size = 4
$T249270 = -380						; size = 4
$T249257 = -376						; size = 4
$T249244 = -372						; size = 4
$T249235 = -368						; size = 4
$T249212 = -364						; size = 4
$T249208 = -360						; size = 4
$T249199 = -356						; size = 4
$T249195 = -352						; size = 4
$T249191 = -348						; size = 4
$T249173 = -344						; size = 4
$T249161 = -340						; size = 4
$T249148 = -336						; size = 4
$T249144 = -332						; size = 4
$T249135 = -328						; size = 4
$T249128 = -324						; size = 4
$T249118 = -320						; size = 4
$T249114 = -316						; size = 4
$T249092 = -312						; size = 4
$T249088 = -308						; size = 8
$T249086 = -297						; size = 1
_strFileName$226897 = -296				; size = 28
_strLog$226899 = -268					; size = 28
_strPlayerName$226901 = -240				; size = 28
_pLog$226898 = -212					; size = 4
_strTemp$226900 = -208					; size = 28
_strFileName$226885 = -180				; size = 28
_strLog$226888 = -152					; size = 28
_strPlayerName$226890 = -124				; size = 28
_pLog$226887 = -96					; size = 4
_strTemp$226889 = -92					; size = 28
_pPlot$226878 = -64					; size = 4
_bActionPerformed$226893 = -57				; size = 1
_pUnit$226876 = -56					; size = 8
_strLogString$ = -48					; size = 28
__$ArrayPad$ = -20					; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteWorkerMoves, COMDAT
; _this$ = ecx

; 2769 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 440				; 000001b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T249092[ebp], 0

; 2770 : 	CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2771 : 
; 2772 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 2773 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN11@ExecuteWor
$LN10@ExecuteWor:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], edx
$LN11@ExecuteWor:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T249114[ebp], eax
	mov	ecx, DWORD PTR $T249114[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T249114[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN9@ExecuteWor

; 2774 : 	{
; 2775 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T249118[ebp], edx
	mov	eax, DWORD PTR $T249118[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T249128[ebp], eax
	mov	edx, DWORD PTR $T249128[ebp]
	mov	DWORD PTR _pUnit$226876[ebp], edx
	mov	BYTE PTR _pUnit$226876[ebp+4], 0
	cmp	DWORD PTR _pUnit$226876[ebp], 0
	je	SHORT $LN39@ExecuteWor
	mov	ecx, DWORD PTR _pUnit$226876[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN39@ExecuteWor:
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2776 : 		if(pUnit)

	xor	eax, eax
	cmp	DWORD PTR _pUnit$226876[ebp], 0
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN8@ExecuteWor

; 2777 : 		{
; 2778 : 			CvPlot* pPlot = pUnit->plot();

	mov	edx, DWORD PTR _pUnit$226876[ebp]
	mov	DWORD PTR $T249135[ebp], edx
	mov	ecx, DWORD PTR $T249135[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pPlot$226878[ebp], eax

; 2779 : 
; 2780 : 			AI_PERF_FORMAT("Homeland-ExecuteWorkerMoves-perf.csv", ("ExecuteWorkerMoves, Turn %03d, %s, Unit %d, at x=%d, y=%d", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription(), pUnit->GetID(), pUnit->getX(), pUnit->getY()) );
; 2781 : 
; 2782 : 			if(pPlot && m_pPlayer->IsPlotUnderImmediateThreat(*pPlot) && !pPlot->getBestDefender(m_pPlayer->GetID()))

	cmp	DWORD PTR _pPlot$226878[ebp], 0
	je	$LN14@ExecuteWor
	mov	eax, DWORD PTR _pPlot$226878[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?IsPlotUnderImmediateThreat@CvPlayer@@QBE_NAAVCvPlot@@@Z ; CvPlayer::IsPlotUnderImmediateThreat
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN14@ExecuteWor
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T249144[ebp], edx
	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	mov	eax, DWORD PTR $T249144[ebp]
	push	eax
	lea	ecx, DWORD PTR $T249088[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$226878[ebp]
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	mov	DWORD PTR $T249148[ebp], eax
	mov	edx, DWORD PTR $T249092[ebp]
	or	edx, 1
	mov	DWORD PTR $T249092[ebp], edx
	mov	eax, DWORD PTR $T249148[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN14@ExecuteWor
	mov	DWORD PTR tv156[ebp], 1
	jmp	SHORT $LN15@ExecuteWor
$LN14@ExecuteWor:
	mov	DWORD PTR tv156[ebp], 0
$LN15@ExecuteWor:
	mov	al, BYTE PTR tv156[ebp]
	mov	BYTE PTR $T249086[ebp], al
	mov	ecx, DWORD PTR $T249092[ebp]
	and	ecx, 1
	je	SHORT $LN20@ExecuteWor
	and	DWORD PTR $T249092[ebp], -2		; fffffffeH
	cmp	DWORD PTR $T249088[ebp], 0
	je	SHORT $LN20@ExecuteWor
	mov	ecx, DWORD PTR $T249088[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN20@ExecuteWor:
	movzx	edx, BYTE PTR $T249086[ebp]
	test	edx, edx
	je	$LN7@ExecuteWor

; 2783 : 			{
; 2784 : 				if(MoveCivilianToSafety(pUnit.pointer()))

	mov	eax, DWORD PTR _pUnit$226876[ebp]
	mov	DWORD PTR $T249161[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T249161[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
	movzx	edx, al
	test	edx, edx
	je	$LN7@ExecuteWor

; 2785 : 				{
; 2786 : 					if(GC.getLogging() && GC.GetBuilderAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN102@ExecuteWor
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuilderAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::GetBuilderAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN102@ExecuteWor

; 2787 : 					{
; 2788 : 						// Open the log file
; 2789 : 						CvString strFileName = "BuilderTaskingLog.csv";

	mov	edx, OFFSET ??_C@_0BG@IAMEKOEI@BuilderTaskingLog?4csv?$AA@
	test	edx, edx
	je	SHORT $LN62@ExecuteWor
	mov	DWORD PTR tv479[ebp], OFFSET ??_C@_0BG@IAMEKOEI@BuilderTaskingLog?4csv?$AA@
	jmp	SHORT $LN63@ExecuteWor
$LN62@ExecuteWor:
	mov	DWORD PTR tv479[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN63@ExecuteWor:
	mov	eax, DWORD PTR tv479[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFileName$226885[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 2790 : 						FILogFile* pLog;
; 2791 : 						pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv182[ebp], eax
	lea	ecx, DWORD PTR _strFileName$226885[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T249173[ebp], eax
	push	0
	push	1
	mov	ecx, DWORD PTR $T249173[ebp]
	push	ecx
	mov	edx, DWORD PTR tv182[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv182[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pLog$226887[ebp], eax

; 2792 : 
; 2793 : 						// write in data
; 2794 : 						CvString strLog;

	lea	ecx, DWORD PTR _strLog$226888[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 2795 : 						CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226889[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 2796 : 
; 2797 : 						CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$226890[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 2798 : 						strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T249191[ebp], eax
	cmp	DWORD PTR $T249191[ebp], 0
	je	SHORT $LN77@ExecuteWor
	mov	ecx, DWORD PTR $T249191[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strPlayerName$226890[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN78@ExecuteWor
$LN77@ExecuteWor:
	lea	ecx, DWORD PTR _strPlayerName$226890[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN78@ExecuteWor:

; 2799 : 						strLog += strPlayerName;

	lea	edx, DWORD PTR _strPlayerName$226890[ebp]
	push	edx
	lea	ecx, DWORD PTR _strLog$226888[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2800 : 						strLog += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	lea	ecx, DWORD PTR _strLog$226888[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 2801 : 
; 2802 : 						strTemp.Format("%d,", GC.getGame().getGameTurn()); // turn

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T249195[ebp], eax
	mov	ecx, DWORD PTR $T249195[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	push	OFFSET ??_C@_03DPLIHHLN@?$CFd?0?$AA@
	lea	ecx, DWORD PTR _strTemp$226889[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 2803 : 						strLog += strTemp;

	lea	edx, DWORD PTR _strTemp$226889[ebp]
	push	edx
	lea	ecx, DWORD PTR _strLog$226888[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2804 : 
; 2805 : 						strTemp.Format("%d,", pUnit->GetID()); // unit id

	mov	eax, DWORD PTR _pUnit$226876[ebp]
	mov	DWORD PTR $T249199[ebp], eax
	mov	ecx, DWORD PTR $T249199[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T249208[ebp], edx
	mov	eax, DWORD PTR $T249208[ebp]
	push	eax
	push	OFFSET ??_C@_03DPLIHHLN@?$CFd?0?$AA@
	lea	ecx, DWORD PTR _strTemp$226889[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 2806 : 						strLog += strTemp;

	lea	edx, DWORD PTR _strTemp$226889[ebp]
	push	edx
	lea	ecx, DWORD PTR _strLog$226888[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2807 : 
; 2808 : 						strLog += "1st Safety,";

	push	OFFSET ??_C@_0M@OOGOHIPM@1st?5Safety?0?$AA@
	lea	ecx, DWORD PTR _strLog$226888[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 2809 : 
; 2810 : 						pLog->Msg(strLog);

	lea	ecx, DWORD PTR _strLog$226888[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T249212[ebp], eax
	mov	eax, DWORD PTR $T249212[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$226887[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$226887[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8

; 2811 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _strPlayerName$226890[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strTemp$226889[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strLog$226888[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strFileName$226885[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2812 : 
; 2813 : 					pUnit->finishMoves();

$LN102@ExecuteWor:
	mov	ecx, DWORD PTR _pUnit$226876[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 2814 : 					UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$226876[ebp]
	mov	DWORD PTR $T249235[ebp], edx
	mov	eax, DWORD PTR $T249235[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T249244[ebp], ecx
	mov	edx, DWORD PTR $T249244[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 2815 : 					continue;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pUnit$226876[ebp], 0
	je	SHORT $LN111@ExecuteWor
	mov	ecx, DWORD PTR _pUnit$226876[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN111@ExecuteWor:
	jmp	$LN10@ExecuteWor
$LN7@ExecuteWor:

; 2816 : 				}
; 2817 : 			}
; 2818 : 
; 2819 : 			bool bActionPerformed = ExecuteWorkerMove(pUnit.pointer());

	mov	eax, DWORD PTR _pUnit$226876[ebp]
	mov	DWORD PTR $T249257[ebp], eax
	mov	ecx, DWORD PTR $T249257[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteWorkerMove
	mov	BYTE PTR _bActionPerformed$226893[ebp], al

; 2820 : 			if(bActionPerformed)

	movzx	edx, BYTE PTR _bActionPerformed$226893[ebp]
	test	edx, edx
	je	SHORT $LN4@ExecuteWor

; 2821 : 			{
; 2822 : 				continue;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pUnit$226876[ebp], 0
	je	SHORT $LN118@ExecuteWor
	mov	ecx, DWORD PTR _pUnit$226876[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN118@ExecuteWor:
	jmp	$LN10@ExecuteWor
$LN4@ExecuteWor:

; 2823 : 			}
; 2824 : 
; 2825 : 			// if there's nothing else to do, move to the safest spot nearby
; 2826 : 			if(MoveCivilianToSafety(pUnit.pointer(), true /*bIgnoreUnits*/))

	mov	eax, DWORD PTR _pUnit$226876[ebp]
	mov	DWORD PTR $T249270[ebp], eax
	push	1
	mov	ecx, DWORD PTR $T249270[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
	movzx	edx, al
	test	edx, edx
	je	$LN3@ExecuteWor

; 2827 : 			{
; 2828 : 				if(GC.getLogging() && GC.GetBuilderAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN2@ExecuteWor
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuilderAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::GetBuilderAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@ExecuteWor

; 2829 : 				{
; 2830 : 					// Open the log file
; 2831 : 					CvString strFileName = "BuilderTaskingLog.csv";

	mov	edx, OFFSET ??_C@_0BG@IAMEKOEI@BuilderTaskingLog?4csv?$AA@
	test	edx, edx
	je	SHORT $LN126@ExecuteWor
	mov	DWORD PTR tv598[ebp], OFFSET ??_C@_0BG@IAMEKOEI@BuilderTaskingLog?4csv?$AA@
	jmp	SHORT $LN127@ExecuteWor
$LN126@ExecuteWor:
	mov	DWORD PTR tv598[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN127@ExecuteWor:
	mov	eax, DWORD PTR tv598[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFileName$226897[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 2832 : 					FILogFile* pLog;
; 2833 : 					pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv304[ebp], eax
	lea	ecx, DWORD PTR _strFileName$226897[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T249282[ebp], eax
	push	0
	push	1
	mov	ecx, DWORD PTR $T249282[ebp]
	push	ecx
	mov	edx, DWORD PTR tv304[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv304[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pLog$226898[ebp], eax

; 2834 : 
; 2835 : 					// write in data
; 2836 : 					CvString strLog;

	lea	ecx, DWORD PTR _strLog$226899[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 2837 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226900[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 2838 : 
; 2839 : 					CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$226901[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 9

; 2840 : 					strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T249300[ebp], eax
	cmp	DWORD PTR $T249300[ebp], 0
	je	SHORT $LN141@ExecuteWor
	mov	ecx, DWORD PTR $T249300[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strPlayerName$226901[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN142@ExecuteWor
$LN141@ExecuteWor:
	lea	ecx, DWORD PTR _strPlayerName$226901[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN142@ExecuteWor:

; 2841 : 					strLog += strPlayerName;

	lea	edx, DWORD PTR _strPlayerName$226901[ebp]
	push	edx
	lea	ecx, DWORD PTR _strLog$226899[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2842 : 					strLog += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	lea	ecx, DWORD PTR _strLog$226899[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 2843 : 
; 2844 : 					strTemp.Format("%d,", GC.getGame().getGameTurn()); // turn

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T249304[ebp], eax
	mov	ecx, DWORD PTR $T249304[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	push	OFFSET ??_C@_03DPLIHHLN@?$CFd?0?$AA@
	lea	ecx, DWORD PTR _strTemp$226900[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 2845 : 					strLog += strTemp;

	lea	edx, DWORD PTR _strTemp$226900[ebp]
	push	edx
	lea	ecx, DWORD PTR _strLog$226899[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2846 : 
; 2847 : 					strTemp.Format("%d,", pUnit->GetID()); // unit id

	mov	eax, DWORD PTR _pUnit$226876[ebp]
	mov	DWORD PTR $T249308[ebp], eax
	mov	ecx, DWORD PTR $T249308[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T249317[ebp], edx
	mov	eax, DWORD PTR $T249317[ebp]
	push	eax
	push	OFFSET ??_C@_03DPLIHHLN@?$CFd?0?$AA@
	lea	ecx, DWORD PTR _strTemp$226900[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 2848 : 					strLog += strTemp;

	lea	edx, DWORD PTR _strTemp$226900[ebp]
	push	edx
	lea	ecx, DWORD PTR _strLog$226899[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2849 : 
; 2850 : 					strLog += "2nd Safety,";

	push	OFFSET ??_C@_0M@NLDMKCCI@2nd?5Safety?0?$AA@
	lea	ecx, DWORD PTR _strLog$226899[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 2851 : 
; 2852 : 					pLog->Msg(strLog);

	lea	ecx, DWORD PTR _strLog$226899[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T249321[ebp], eax
	mov	eax, DWORD PTR $T249321[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$226898[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$226898[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8

; 2853 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR _strPlayerName$226901[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _strTemp$226900[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR _strLog$226899[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strFileName$226897[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@ExecuteWor:

; 2854 : 
; 2855 : 				// slewis - this was removed because a unit would eat all its moves. So if it didn't do anything this turn, it wouldn't be able to work 
; 2856 : 				pUnit->PushMission(CvTypes::getMISSION_SKIP());

	mov	edx, DWORD PTR _pUnit$226876[ebp]
	mov	DWORD PTR $T249341[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SKIP
	push	eax
	mov	ecx, DWORD PTR $T249341[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2857 : 				if (!m_pPlayer->isHuman())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@ExecuteWor

; 2858 : 				{
; 2859 : 					pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$226876[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN1@ExecuteWor:

; 2860 : 				}
; 2861 : 				UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$226876[ebp]
	mov	DWORD PTR $T249348[ebp], edx
	mov	eax, DWORD PTR $T249348[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T249357[ebp], ecx
	mov	edx, DWORD PTR $T249357[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 2862 : 				continue;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pUnit$226876[ebp], 0
	je	SHORT $LN177@ExecuteWor
	mov	ecx, DWORD PTR _pUnit$226876[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN177@ExecuteWor:
	jmp	$LN10@ExecuteWor
$LN3@ExecuteWor:

; 2863 : 			}
; 2864 : 
; 2865 : 			pUnit->PushMission(CvTypes::getMISSION_SKIP());

	mov	eax, DWORD PTR _pUnit$226876[ebp]
	mov	DWORD PTR $T249370[ebp], eax
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SKIP
	push	eax
	mov	ecx, DWORD PTR $T249370[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2866 : 			pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$226876[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 2867 : 			UnitProcessed(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$226876[ebp]
	mov	DWORD PTR $T249377[ebp], ecx
	mov	edx, DWORD PTR $T249377[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T249386[ebp], eax
	mov	ecx, DWORD PTR $T249386[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed
$LN8@ExecuteWor:

; 2868 : 		}
; 2869 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pUnit$226876[ebp], 0
	je	SHORT $LN192@ExecuteWor
	mov	ecx, DWORD PTR _pUnit$226876[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN192@ExecuteWor:
	jmp	$LN10@ExecuteWor
$LN9@ExecuteWor:

; 2870 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strLogString$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _pUnit$226876[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strFileName$226885[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLog$226888[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strTemp$226889[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR _strPlayerName$226890[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _strFileName$226897[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$8:
	lea	ecx, DWORD PTR _strLog$226899[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$9:
	lea	ecx, DWORD PTR _strTemp$226900[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$10:
	lea	ecx, DWORD PTR _strPlayerName$226901[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-444]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteWorkerMoves
PUBLIC	?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z ; CvHomelandAI::ExecuteWorkerSeaMoves
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z$0
__ehfuncinfo$?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T249481 = -88						; size = 4
$T249477 = -84						; size = 4
$T249470 = -80						; size = 4
$T249466 = -76						; size = 4
$T249462 = -72						; size = 4
$T249458 = -68						; size = 4
$T249454 = -64						; size = 4
$T249450 = -60						; size = 4
$T249446 = -56						; size = 4
$T249442 = -52						; size = 4
$T249438 = -48						; size = 4
$T249434 = -44						; size = 4
$T249427 = -40						; size = 4
$T249417 = -36						; size = 4
$T249413 = -32						; size = 4
$T249408 = -25						; size = 1
_pUnit$ = -24						; size = 8
_bRtnValue$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_target$ = 8						; size = 20
_pTarget$ = 28						; size = 4
?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z PROC ; CvHomelandAI::ExecuteWorkerSeaMoves, COMDAT
; _this$ = ecx

; 2874 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2875 : 	bool bRtnValue = false;

	mov	BYTE PTR _bRtnValue$[ebp], 0

; 2876 : 
; 2877 : 	// Move first one to target
; 2878 : 	UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits.begin()->GetID());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T249413[ebp], ecx
	mov	edx, DWORD PTR $T249413[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T249417[ebp], eax
	mov	ecx, DWORD PTR $T249417[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T249427[ebp], eax
	mov	eax, DWORD PTR $T249427[ebp]
	mov	DWORD PTR _pUnit$[ebp], eax
	mov	BYTE PTR _pUnit$[ebp+4], 0
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN13@ExecuteWor@2
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN13@ExecuteWor@2:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2879 : 	if(pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN4@ExecuteWor@2

; 2880 : 	{
; 2881 : 		if(pUnit->UnitPathTo(pTarget->getX(), pTarget->getY(), 0) > 0)

	mov	eax, DWORD PTR _pTarget$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T249434[ebp], ecx
	mov	edx, DWORD PTR _pTarget$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T249438[ebp], eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T249442[ebp], ecx
	push	0
	push	-1
	push	0
	mov	edx, DWORD PTR $T249434[ebp]
	push	edx
	mov	eax, DWORD PTR $T249438[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249442[ebp]
	call	?UnitPathTo@CvUnit@@QAEHHHHH_N@Z	; CvUnit::UnitPathTo
	test	eax, eax
	jle	$LN4@ExecuteWor@2

; 2882 : 		{
; 2883 : 			pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());

	mov	ecx, DWORD PTR _pTarget$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T249446[ebp], edx
	mov	eax, DWORD PTR _pTarget$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T249450[ebp], ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T249454[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR $T249446[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249450[ebp]
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T249454[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2884 : 			if(pUnit->plot() == pTarget)

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T249458[ebp], edx
	mov	ecx, DWORD PTR $T249458[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pTarget$[ebp]
	jne	SHORT $LN39@ExecuteWor@2

; 2885 : 			{
; 2886 : 				pUnit->PushMission(CvTypes::getMISSION_BUILD(), (int)target.GetAuxIntData(), -1, 0, (pUnit->GetLengthMissionQueue() > 0), false, MISSIONAI_BUILD, pTarget);

	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T249462[ebp], eax
	mov	ecx, DWORD PTR _target$[ebp+16]
	mov	DWORD PTR $T249466[ebp], ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T249470[ebp], edx
	push	0
	mov	eax, DWORD PTR _pTarget$[ebp]
	push	eax
	push	18					; 00000012H
	push	0
	mov	ecx, DWORD PTR $T249462[ebp]
	call	?GetLengthMissionQueue@CvUnit@@QBEHXZ	; CvUnit::GetLengthMissionQueue
	test	eax, eax
	setg	cl
	movzx	edx, cl
	push	edx
	push	0
	push	-1
	mov	eax, DWORD PTR $T249466[ebp]
	push	eax
	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	push	eax
	mov	ecx, DWORD PTR $T249470[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2887 : 				bRtnValue = true;

	mov	BYTE PTR _bRtnValue$[ebp], 1

; 2888 : 			}
; 2889 : 			else

	jmp	SHORT $LN1@ExecuteWor@2

; 2890 : 			{
; 2891 : 				pUnit->finishMoves();

$LN39@ExecuteWor@2:
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN1@ExecuteWor@2:

; 2892 : 			}
; 2893 : 
; 2894 : 			// Delete this unit from those we have to move
; 2895 : 			UnitProcessed(m_CurrentMoveUnits.begin()->GetID());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T249477[ebp], edx
	mov	eax, DWORD PTR $T249477[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T249481[ebp], ecx
	mov	edx, DWORD PTR $T249481[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed
$LN4@ExecuteWor@2:

; 2896 : 		}
; 2897 : 	}
; 2898 : 	return bRtnValue;

	mov	al, BYTE PTR _bRtnValue$[ebp]
	mov	BYTE PTR $T249408[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN46@ExecuteWor@2
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN46@ExecuteWor@2:
	mov	al, BYTE PTR $T249408[ebp]

; 2899 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z ENDP ; CvHomelandAI::ExecuteWorkerSeaMoves
EXTRN	?SetFortifiedThisTurn@CvUnit@@QAEX_N@Z:PROC	; CvUnit::SetFortifiedThisTurn
EXTRN	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_FORTIFY
EXTRN	?isFortifyable@CvUnit@@QBE_N_N@Z:PROC		; CvUnit::isFortifyable
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteHeals@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteHeals@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?ExecuteHeals@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecuteHeals@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteHeals@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T249542 = -52						; size = 4
$T249538 = -48						; size = 4
$T249531 = -44						; size = 4
$T249527 = -40						; size = 4
$T249520 = -36						; size = 4
$T249510 = -32						; size = 4
$T249506 = -28						; size = 4
_pUnit$226925 = -24					; size = 8
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteHeals@CvHomelandAI@@AAEXXZ PROC			; CvHomelandAI::ExecuteHeals, COMDAT
; _this$ = ecx

; 2903 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteHeals@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2904 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 2905 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN6@ExecuteHea
$LN5@ExecuteHea:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], edx
$LN6@ExecuteHea:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T249506[ebp], eax
	mov	ecx, DWORD PTR $T249506[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T249506[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN7@ExecuteHea

; 2906 : 	{
; 2907 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T249510[ebp], edx
	mov	eax, DWORD PTR $T249510[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T249520[ebp], eax
	mov	edx, DWORD PTR $T249520[ebp]
	mov	DWORD PTR _pUnit$226925[ebp], edx
	mov	BYTE PTR _pUnit$226925[ebp+4], 0
	cmp	DWORD PTR _pUnit$226925[ebp], 0
	je	SHORT $LN17@ExecuteHea
	mov	ecx, DWORD PTR _pUnit$226925[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN17@ExecuteHea:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2908 : 		if(pUnit)

	xor	eax, eax
	cmp	DWORD PTR _pUnit$226925[ebp], 0
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@ExecuteHea

; 2909 : 		{
; 2910 : 			if(pUnit->isFortifyable())

	mov	edx, DWORD PTR _pUnit$226925[ebp]
	mov	DWORD PTR $T249527[ebp], edx
	push	0
	mov	ecx, DWORD PTR $T249527[ebp]
	call	?isFortifyable@CvUnit@@QBE_N_N@Z	; CvUnit::isFortifyable
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@ExecuteHea

; 2911 : 			{
; 2912 : 				pUnit->PushMission(CvTypes::getMISSION_FORTIFY());

	mov	ecx, DWORD PTR _pUnit$226925[ebp]
	mov	DWORD PTR $T249531[ebp], ecx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FORTIFY
	push	eax
	mov	ecx, DWORD PTR $T249531[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2913 : 				pUnit->SetFortifiedThisTurn(true);

	push	1
	mov	ecx, DWORD PTR _pUnit$226925[ebp]
	call	?SetFortifiedThisTurn@CvUnit@@QAEX_N@Z	; CvUnit::SetFortifiedThisTurn

; 2914 : 			}
; 2915 : 			else

	jmp	SHORT $LN1@ExecuteHea
$LN2@ExecuteHea:

; 2916 : 			{
; 2917 : 				pUnit->PushMission(CvTypes::getMISSION_SKIP());

	mov	edx, DWORD PTR _pUnit$226925[ebp]
	mov	DWORD PTR $T249538[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SKIP
	push	eax
	mov	ecx, DWORD PTR $T249538[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission
$LN1@ExecuteHea:

; 2918 : 			}
; 2919 : 			UnitProcessed(it->GetID());

	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T249542[ebp], ecx
	mov	edx, DWORD PTR $T249542[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed
$LN3@ExecuteHea:

; 2920 : 		}
; 2921 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$226925[ebp], 0
	je	SHORT $LN34@ExecuteHea
	mov	ecx, DWORD PTR _pUnit$226925[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN34@ExecuteHea:
	jmp	$LN5@ExecuteHea
$LN7@ExecuteHea:

; 2922 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteHeals@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$226925[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteHeals@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteHeals@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteHeals@CvHomelandAI@@AAEXXZ ENDP			; CvHomelandAI::ExecuteHeals
PUBLIC	??_C@_0CC@BBNFEHAF@Moving?5?$CFs?5to?5safety?0?5X?3?5?$CFd?0?5Y?3?5?$CF@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z:PROC ; CanReachInXTurns
EXTRN	?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z:PROC ; CvPlot::isFriendlyCity
EXTRN	?GetMoves@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetMoves
;	COMDAT ??_C@_0CC@BBNFEHAF@Moving?5?$CFs?5to?5safety?0?5X?3?5?$CFd?0?5Y?3?5?$CF@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0CC@BBNFEHAF@Moving?5?$CFs?5to?5safety?0?5X?3?5?$CFd?0?5Y?3?5?$CF@ DB 'M'
	DB	'oving %s to safety, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ$3
	DD	02H
	DD	FLAT:__unwindfunclet$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ$4
__ehfuncinfo$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv344 = -1241						; size = 1
tv343 = -1240						; size = 4
tv203 = -1236						; size = 4
tv383 = -1232						; size = 4
tv424 = -1228						; size = 4
_this$ = -1224						; size = 4
$T249950 = -1208					; size = 4
$T249946 = -1204					; size = 4
$T249942 = -1200					; size = 4
$T249936 = -1196					; size = 4
$T249932 = -1192					; size = 4
$T249920 = -1188					; size = 4
$T249911 = -1184					; size = 4
$T249904 = -1180					; size = 4
$T249900 = -1176					; size = 4
$T249896 = -1172					; size = 4
$T249892 = -1168					; size = 4
$T249858 = -1156					; size = 4
_weightedElem$249838 = -1144				; size = 8
$T249832 = -1136					; size = 4
$T249823 = -1132					; size = 4
$T249822 = -1128					; size = 4
_playerID$249814 = -1124				; size = 4
$T249805 = -1120					; size = 4
$T249801 = -1116					; size = 4
$T249792 = -1112					; size = 4
$T249751 = -1064					; size = 4
$T249747 = -1060					; size = 4
$T249743 = -1056					; size = 4
$T249734 = -1052					; size = 4
$T249730 = -1048					; size = 4
$T249721 = -1044					; size = 4
$T249717 = -1040					; size = 4
$T249716 = -1036					; size = 4
$T249715 = -1032					; size = 4
$T249682 = -1028					; size = 4
$T249669 = -1024					; size = 4
$T249665 = -1020					; size = 4
$T249658 = -1016					; size = 4
$T249654 = -1009					; size = 1
$T249650 = -1008					; size = 4
$T249646 = -1001					; size = 1
_iMapY$249691 = -1000					; size = 4
_iMapX$249690 = -996					; size = 4
$T249639 = -992						; size = 4
$T249635 = -988						; size = 4
$T249626 = -984						; size = 4
$T249622 = -980						; size = 4
$T249613 = -976						; size = 4
$T249609 = -972						; size = 4
$T249602 = -968						; size = 4
$T249592 = -964						; size = 4
$T249588 = -960						; size = 4
$T249572 = -956						; size = 4
$T249563 = -952						; size = 4
_strLogString$226979 = -948				; size = 28
_strTemp$226980 = -920					; size = 28
_pPlot$226974 = -892					; size = 4
_i$226970 = -888					; size = 4
_pPlot$226950 = -884					; size = 4
_bIsInCity$226954 = -880				; size = 1
_bIsInTerritory$226956 = -879				; size = 1
_bIsZeroDanger$226953 = -878				; size = 1
_bIsInCover$226955 = -877				; size = 1
_iScore$226957 = -876					; size = 4
_iY$226946 = -872					; size = 4
_iX$226942 = -868					; size = 4
_uiListSize$226968 = -864				; size = 4
_iRange$226941 = -860					; size = 4
_pBestPlot$226940 = -856				; size = 4
_pUnit$226938 = -852					; size = 8
_aBestPlotList$226937 = -844				; size = 816
__$ArrayPad$ = -24					; size = 4
_iI$226933 = -20					; size = 4
_iDanger$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::ExecuteMovesToSafestPlot, COMDAT
; _this$ = ecx

; 2926 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1232				; 000004d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2927 : 	int iDanger;
; 2928 : 
; 2929 : 	for(unsigned int iI = 0; iI < m_CurrentMoveUnits.size(); iI++)

	mov	DWORD PTR _iI$226933[ebp], 0
	jmp	SHORT $LN29@ExecuteMov
$LN28@ExecuteMov:
	mov	eax, DWORD PTR _iI$226933[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$226933[ebp], eax
$LN29@ExecuteMov:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T249572[ebp], edx
	mov	eax, DWORD PTR _iI$226933[ebp]
	cmp	eax, DWORD PTR $T249572[ebp]
	jae	$LN30@ExecuteMov

; 2930 : 	{
; 2931 : 		WeightedPlotVector aBestPlotList;

	lea	ecx, DWORD PTR _aBestPlotList$226937[ebp]
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2932 : 		aBestPlotList.reserve(100);

	push	100					; 00000064H
	lea	ecx, DWORD PTR _aBestPlotList$226937[ebp]
	call	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSizeToFit

; 2933 : 
; 2934 : 		UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[iI].GetID());

	mov	ecx, DWORD PTR _iI$226933[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR $T249588[ebp], ecx
	mov	eax, DWORD PTR $T249588[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T249592[ebp], ecx
	mov	edx, DWORD PTR $T249592[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T249602[ebp], eax
	mov	ecx, DWORD PTR $T249602[ebp]
	mov	DWORD PTR _pUnit$226938[ebp], ecx
	mov	BYTE PTR _pUnit$226938[ebp+4], 0
	cmp	DWORD PTR _pUnit$226938[ebp], 0
	je	SHORT $LN53@ExecuteMov
	mov	ecx, DWORD PTR _pUnit$226938[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@ExecuteMov:
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2935 : 		if(pUnit)

	xor	edx, edx
	cmp	DWORD PTR _pUnit$226938[ebp], 0
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN26@ExecuteMov

; 2936 : 		{
; 2937 : 			CvPlot* pBestPlot = NULL;

	mov	DWORD PTR _pBestPlot$226940[ebp], 0

; 2938 : 
; 2939 : #ifdef AUI_HOMELAND_FIX_EXECUTE_MOVES_TO_SAFEST_PLOT_USE_GAME_MOVEMENT_RANGE
; 2940 : 			int iRange = pUnit->baseMoves();
; 2941 : #else
; 2942 : 			int iRange = pUnit->getUnitInfo().GetMoves();

	mov	ecx, DWORD PTR _pUnit$226938[ebp]
	mov	DWORD PTR $T249609[ebp], ecx
	mov	ecx, DWORD PTR $T249609[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetMoves@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetMoves
	mov	DWORD PTR _iRange$226941[ebp], eax

; 2943 : #endif
; 2944 : #ifdef AUI_ASTAR_TWEAKED_OPTIMIZED_BUT_CAN_STILL_USE_ROADS
; 2945 : 			IncreaseMoveRangeForRoads(pUnit.pointer(), iRange);
; 2946 : #endif
; 2947 : 
; 2948 : 			// For each plot within movement range of the fleeing unit
; 2949 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2950 : 			int iMaxDX, iX;
; 2951 : 			CvPlot* pPlot;
; 2952 : 			for (int iY = -iRange; iY <= iRange; iY++)
; 2953 : 			{
; 2954 : 				iMaxDX = iRange - MAX(0, iY);
; 2955 : 				for (iX = -iRange - MIN(0, iY); iX <= iMaxDX; iX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 2956 : 				{
; 2957 : 					// No need for range check because loops are set up properly
; 2958 : 					pPlot = plotXY(pUnit->getX(), pUnit->getY(), iX, iY);
; 2959 : #else
; 2960 : 			for(int iX = -iRange; iX <= iRange; iX++)

	mov	edx, DWORD PTR _iRange$226941[ebp]
	neg	edx
	mov	DWORD PTR _iX$226942[ebp], edx
	jmp	SHORT $LN25@ExecuteMov
$LN24@ExecuteMov:
	mov	eax, DWORD PTR _iX$226942[ebp]
	add	eax, 1
	mov	DWORD PTR _iX$226942[ebp], eax
$LN25@ExecuteMov:
	mov	ecx, DWORD PTR _iX$226942[ebp]
	cmp	ecx, DWORD PTR _iRange$226941[ebp]
	jg	$LN23@ExecuteMov

; 2961 : 			{
; 2962 : 				for(int iY = -iRange; iY <= iRange; iY++)

	mov	edx, DWORD PTR _iRange$226941[ebp]
	neg	edx
	mov	DWORD PTR _iY$226946[ebp], edx
	jmp	SHORT $LN22@ExecuteMov
$LN21@ExecuteMov:
	mov	eax, DWORD PTR _iY$226946[ebp]
	add	eax, 1
	mov	DWORD PTR _iY$226946[ebp], eax
$LN22@ExecuteMov:
	mov	ecx, DWORD PTR _iY$226946[ebp]
	cmp	ecx, DWORD PTR _iRange$226941[ebp]
	jg	$LN20@ExecuteMov

; 2963 : 				{
; 2964 : 					CvPlot* pPlot = GC.getMap().plot(pUnit->getX() + iX, pUnit->getY() + iY);

	mov	edx, DWORD PTR _pUnit$226938[ebp]
	mov	DWORD PTR $T249613[ebp], edx
	mov	eax, DWORD PTR $T249613[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T249622[ebp], ecx
	mov	edx, DWORD PTR _pUnit$226938[ebp]
	mov	DWORD PTR $T249626[ebp], edx
	mov	eax, DWORD PTR $T249626[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T249635[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T249639[ebp], edx
	mov	eax, DWORD PTR $T249622[ebp]
	add	eax, DWORD PTR _iY$226946[ebp]
	mov	DWORD PTR $T249716[ebp], eax
	mov	ecx, DWORD PTR $T249635[ebp]
	add	ecx, DWORD PTR _iX$226942[ebp]
	mov	DWORD PTR $T249715[ebp], ecx
	cmp	DWORD PTR $T249715[ebp], -2147483647	; 80000001H
	je	SHORT $LN75@ExecuteMov
	cmp	DWORD PTR $T249716[ebp], -2147483647	; 80000001H
	jne	SHORT $LN76@ExecuteMov
$LN75@ExecuteMov:
	mov	DWORD PTR $T249717[ebp], 0
	jmp	$LN77@ExecuteMov
$LN76@ExecuteMov:
	mov	edx, DWORD PTR $T249639[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T249646[ebp], al
	mov	ecx, DWORD PTR $T249639[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T249650[ebp], edx
	movzx	eax, BYTE PTR $T249646[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249650[ebp]
	push	ecx
	mov	edx, DWORD PTR $T249715[ebp]
	push	edx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapX$249690[ebp], eax
	mov	eax, DWORD PTR $T249639[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T249654[ebp], cl
	mov	edx, DWORD PTR $T249639[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T249658[ebp], eax
	movzx	ecx, BYTE PTR $T249654[ebp]
	push	ecx
	mov	edx, DWORD PTR $T249658[ebp]
	push	edx
	mov	eax, DWORD PTR $T249716[ebp]
	push	eax
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$249691[ebp], eax
	cmp	DWORD PTR _iMapX$249690[ebp], 0
	jl	SHORT $LN91@ExecuteMov
	mov	ecx, DWORD PTR $T249639[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T249665[ebp], edx
	mov	eax, DWORD PTR _iMapX$249690[ebp]
	cmp	eax, DWORD PTR $T249665[ebp]
	jge	SHORT $LN91@ExecuteMov
	cmp	DWORD PTR _iMapY$249691[ebp], 0
	jl	SHORT $LN91@ExecuteMov
	mov	ecx, DWORD PTR $T249639[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T249669[ebp], edx
	mov	eax, DWORD PTR _iMapY$249691[ebp]
	cmp	eax, DWORD PTR $T249669[ebp]
	jge	SHORT $LN91@ExecuteMov
	mov	DWORD PTR tv424[ebp], 1
	jmp	SHORT $LN89@ExecuteMov
$LN91@ExecuteMov:
	mov	DWORD PTR tv424[ebp], 0
$LN89@ExecuteMov:
	cmp	DWORD PTR tv424[ebp], 0
	je	SHORT $LN79@ExecuteMov
	mov	ecx, DWORD PTR $T249639[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T249682[ebp], edx
	mov	eax, DWORD PTR _iMapY$249691[ebp]
	imul	eax, DWORD PTR $T249682[ebp]
	add	eax, DWORD PTR _iMapX$249690[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T249639[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv383[ebp], eax
	jmp	SHORT $LN80@ExecuteMov
$LN79@ExecuteMov:
	mov	DWORD PTR tv383[ebp], 0
$LN80@ExecuteMov:
	mov	edx, DWORD PTR tv383[ebp]
	mov	DWORD PTR $T249717[ebp], edx
$LN77@ExecuteMov:
	mov	eax, DWORD PTR $T249717[ebp]
	mov	DWORD PTR _pPlot$226950[ebp], eax

; 2965 : #endif
; 2966 : 					if(pPlot == NULL)

	cmp	DWORD PTR _pPlot$226950[ebp], 0
	jne	SHORT $LN19@ExecuteMov

; 2967 : 					{
; 2968 : 						continue;

	jmp	$LN21@ExecuteMov
$LN19@ExecuteMov:

; 2969 : 					}
; 2970 : 
; 2971 : #ifndef AUI_HEXSPACE_DX_LOOPS
; 2972 : 					if (plotDistance(pPlot->getX(), pPlot->getY(), pUnit->getX(), pUnit->getY()) > iRange)

	mov	ecx, DWORD PTR _pUnit$226938[ebp]
	mov	DWORD PTR $T249721[ebp], ecx
	mov	edx, DWORD PTR $T249721[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T249730[ebp], eax
	mov	ecx, DWORD PTR _pUnit$226938[ebp]
	mov	DWORD PTR $T249734[ebp], ecx
	mov	edx, DWORD PTR $T249734[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T249743[ebp], eax
	mov	ecx, DWORD PTR _pPlot$226950[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T249747[ebp], edx
	mov	eax, DWORD PTR _pPlot$226950[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T249751[ebp], ecx
	mov	edx, DWORD PTR $T249730[ebp]
	push	edx
	mov	eax, DWORD PTR $T249743[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249747[ebp]
	push	ecx
	mov	edx, DWORD PTR $T249751[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _iRange$226941[ebp]
	jle	SHORT $LN18@ExecuteMov

; 2973 : 					{
; 2974 : 						continue;

	jmp	$LN21@ExecuteMov
$LN18@ExecuteMov:

; 2975 : 					}
; 2976 : #endif
; 2977 : 
; 2978 : 					//   prefer being in a city with the lowest danger value
; 2979 : 					//   prefer being in a plot with no danger value
; 2980 : 					//   prefer being under a unit with the lowest danger value
; 2981 : 					//   prefer being in your own territory with the lowest danger value
; 2982 : 					//   prefer the lowest danger value
; 2983 : 
; 2984 : 					iDanger = m_pPlayer->GetPlotDanger(*pPlot);

	mov	eax, DWORD PTR _pPlot$226950[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	mov	DWORD PTR _iDanger$[ebp], eax

; 2985 : 					bool bIsZeroDanger = (iDanger <= 0);

	xor	edx, edx
	cmp	DWORD PTR _iDanger$[ebp], 0
	setle	dl
	mov	BYTE PTR _bIsZeroDanger$226953[ebp], dl

; 2986 : 					bool bIsInCity = pPlot->isFriendlyCity(*pUnit, false);

	mov	eax, DWORD PTR _pUnit$226938[ebp]
	mov	DWORD PTR $T249792[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T249792[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$226950[ebp]
	call	?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z ; CvPlot::isFriendlyCity
	mov	BYTE PTR _bIsInCity$226954[ebp], al

; 2987 : 					bool bIsInCover = (pPlot->getNumDefenders(m_pPlayer->GetID()) > 0) && !pUnit->IsCanDefend();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T249801[ebp], ecx
	mov	edx, DWORD PTR $T249801[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$226950[ebp]
	call	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumDefenders
	test	eax, eax
	jle	SHORT $LN32@ExecuteMov
	mov	eax, DWORD PTR _pUnit$226938[ebp]
	mov	DWORD PTR $T249805[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T249805[ebp]
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN32@ExecuteMov
	mov	DWORD PTR tv203[ebp], 1
	jmp	SHORT $LN33@ExecuteMov
$LN32@ExecuteMov:
	mov	DWORD PTR tv203[ebp], 0
$LN33@ExecuteMov:
	mov	dl, BYTE PTR tv203[ebp]
	mov	BYTE PTR _bIsInCover$226955[ebp], dl

; 2988 : 					bool bIsInTerritory = (pPlot->getTeam() == m_pPlayer->getTeam());

	mov	eax, DWORD PTR _pPlot$226950[ebp]
	mov	DWORD PTR $T249822[ebp], eax
	mov	ecx, DWORD PTR $T249822[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _playerID$249814[ebp], edx
	cmp	DWORD PTR _playerID$249814[ebp], -1
	je	SHORT $LN150@ExecuteMov
	mov	eax, DWORD PTR _playerID$249814[ebp]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T249823[ebp], eax
	jmp	SHORT $LN151@ExecuteMov
	jmp	SHORT $LN151@ExecuteMov
$LN150@ExecuteMov:
	mov	DWORD PTR $T249823[ebp], -1
$LN151@ExecuteMov:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T249832[ebp], edx
	mov	eax, DWORD PTR $T249832[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	xor	edx, edx
	cmp	DWORD PTR $T249823[ebp], eax
	sete	dl
	mov	BYTE PTR _bIsInTerritory$226956[ebp], dl

; 2989 : #ifdef AUI_HOMELAND_FIX_EXECUTE_MOVES_TO_SAFEST_PLOT_NO_EMBARK_SUICIDE
; 2990 : 					bool bNeedEmbark = ((pUnit->getDomainType() == DOMAIN_LAND) && (!pUnit->plot()->isWater()) && (pPlot->isWater()));
; 2991 : #endif
; 2992 : 
; 2993 : 					#define MAX_DANGER_VALUE	100000
; 2994 : 					#define PREFERENCE_LEVEL(x, y) (x * MAX_DANGER_VALUE) + ((MAX_DANGER_VALUE - 1) - y)
; 2995 : 
; 2996 : 					CvAssert(iDanger < MAX_DANGER_VALUE);
; 2997 : 
; 2998 : 					int iScore;
; 2999 : 					if(bIsInCity)

	movzx	eax, BYTE PTR _bIsInCity$226954[ebp]
	test	eax, eax
	je	SHORT $LN17@ExecuteMov

; 3000 : 					{
; 3001 : 						iScore = PREFERENCE_LEVEL(5, iDanger);

	mov	ecx, 99999				; 0001869fH
	sub	ecx, DWORD PTR _iDanger$[ebp]
	add	ecx, 500000				; 0007a120H
	mov	DWORD PTR _iScore$226957[ebp], ecx
	jmp	$LN16@ExecuteMov
$LN17@ExecuteMov:

; 3002 : 					}
; 3003 : 					else if(bIsZeroDanger)

	movzx	edx, BYTE PTR _bIsZeroDanger$226953[ebp]
	test	edx, edx
	je	SHORT $LN15@ExecuteMov

; 3004 : 					{
; 3005 : 						if (bIsInTerritory)

	movzx	eax, BYTE PTR _bIsInTerritory$226956[ebp]
	test	eax, eax
	je	SHORT $LN14@ExecuteMov

; 3006 : 							iScore = PREFERENCE_LEVEL(4, iDanger);

	mov	ecx, 99999				; 0001869fH
	sub	ecx, DWORD PTR _iDanger$[ebp]
	add	ecx, 400000				; 00061a80H
	mov	DWORD PTR _iScore$226957[ebp], ecx

; 3007 : 						else

	jmp	SHORT $LN13@ExecuteMov
$LN14@ExecuteMov:

; 3008 : 							iScore = PREFERENCE_LEVEL(3, iDanger);

	mov	edx, 99999				; 0001869fH
	sub	edx, DWORD PTR _iDanger$[ebp]
	add	edx, 300000				; 000493e0H
	mov	DWORD PTR _iScore$226957[ebp], edx
$LN13@ExecuteMov:
	jmp	SHORT $LN16@ExecuteMov
$LN15@ExecuteMov:

; 3009 : 					}
; 3010 : 					else if(bIsInCover)

	movzx	eax, BYTE PTR _bIsInCover$226955[ebp]
	test	eax, eax
	je	SHORT $LN11@ExecuteMov

; 3011 : 					{
; 3012 : 						iScore = PREFERENCE_LEVEL(2, iDanger);

	mov	ecx, 99999				; 0001869fH
	sub	ecx, DWORD PTR _iDanger$[ebp]
	add	ecx, 200000				; 00030d40H
	mov	DWORD PTR _iScore$226957[ebp], ecx
	jmp	SHORT $LN16@ExecuteMov
$LN11@ExecuteMov:

; 3013 : 					}
; 3014 : 					else if(bIsInTerritory)

	movzx	edx, BYTE PTR _bIsInTerritory$226956[ebp]
	test	edx, edx
	je	SHORT $LN9@ExecuteMov

; 3015 : 					{
; 3016 : 						iScore = PREFERENCE_LEVEL(1, iDanger);

	mov	eax, 99999				; 0001869fH
	sub	eax, DWORD PTR _iDanger$[ebp]
	add	eax, 100000				; 000186a0H
	mov	DWORD PTR _iScore$226957[ebp], eax

; 3017 : 					}
; 3018 : 					// if we have no good home, head to the lowest danger value
; 3019 : 					else 

	jmp	SHORT $LN16@ExecuteMov
$LN9@ExecuteMov:

; 3020 : 					{
; 3021 : 						iScore = PREFERENCE_LEVEL(0, iDanger);

	mov	ecx, 99999				; 0001869fH
	sub	ecx, DWORD PTR _iDanger$[ebp]
	mov	DWORD PTR _iScore$226957[ebp], ecx
$LN16@ExecuteMov:

; 3022 : 					}
; 3023 : 
; 3024 : #ifdef AUI_HOMELAND_FIX_EXECUTE_MOVES_TO_SAFEST_PLOT_NO_EMBARK_SUICIDE
; 3025 : 					// makes sure the AI doesn't suicide units via embarking onto a tile that can be attacked
; 3026 : 					if (bNeedEmbark && !bIsInCover)
; 3027 : 					{
; 3028 : 						iScore = PREFERENCE_LEVEL(0, iDanger);
; 3029 : 					}
; 3030 : #endif
; 3031 : 
; 3032 : 					aBestPlotList.push_back(pPlot, iScore);

	mov	DWORD PTR _weightedElem$249838[ebp], 0
	mov	DWORD PTR _weightedElem$249838[ebp+4], 0
	mov	edx, DWORD PTR _pPlot$226950[ebp]
	mov	DWORD PTR _weightedElem$249838[ebp], edx
	mov	eax, DWORD PTR _iScore$226957[ebp]
	mov	DWORD PTR _weightedElem$249838[ebp+4], eax
	lea	ecx, DWORD PTR _weightedElem$249838[ebp]
	push	ecx
	lea	ecx, DWORD PTR _aBestPlotList$226937[ebp]
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::push_back

; 3033 : 				}

	jmp	$LN21@ExecuteMov
$LN20@ExecuteMov:

; 3034 : 			}

	jmp	$LN24@ExecuteMov
$LN23@ExecuteMov:

; 3035 : 
; 3036 : 			aBestPlotList.SortItems();

	lea	ecx, DWORD PTR _aBestPlotList$226937[ebp]
	call	?SortItems@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXXZ ; CvWeightedVector<CvPlot *,100,1>::SortItems

; 3037 : 
; 3038 : 			// Now loop through the sorted score list and go to the best one we can reach in one turn.
; 3039 : 			// #define EXECUTEMOVESTOSAFESTPLOT_FAILURE_LIMIT
; 3040 : 			#ifdef EXECUTEMOVESTOSAFESTPLOT_FAILURE_LIMIT
; 3041 : 			int iFailureLimit = 10;
; 3042 : 			#endif
; 3043 : 			uint uiListSize;
; 3044 : 			if ((uiListSize = aBestPlotList.size()) > 0)

	mov	edx, DWORD PTR _aBestPlotList$226937[ebp+4]
	mov	DWORD PTR $T249858[ebp], edx
	mov	eax, DWORD PTR $T249858[ebp]
	mov	DWORD PTR _uiListSize$226968[ebp], eax
	cmp	DWORD PTR _uiListSize$226968[ebp], 0
	jbe	$LN7@ExecuteMov

; 3045 : 			{
; 3046 : 				aBestPlotList.SortItems();	// highest score will be first.

	lea	ecx, DWORD PTR _aBestPlotList$226937[ebp]
	call	?SortItems@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXXZ ; CvWeightedVector<CvPlot *,100,1>::SortItems

; 3047 : 				for (uint i = 0; i < uiListSize; ++i )	

	mov	DWORD PTR _i$226970[ebp], 0
	jmp	SHORT $LN6@ExecuteMov
$LN5@ExecuteMov:
	mov	ecx, DWORD PTR _i$226970[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$226970[ebp], ecx
$LN6@ExecuteMov:
	mov	edx, DWORD PTR _i$226970[ebp]
	cmp	edx, DWORD PTR _uiListSize$226968[ebp]
	jae	$LN7@ExecuteMov

; 3048 : 				{
; 3049 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 3050 : 					pPlot = aBestPlotList.GetElement(i);
; 3051 : #else
; 3052 : 					CvPlot* pPlot = aBestPlotList.GetElement(i);

	mov	eax, DWORD PTR _i$226970[ebp]
	mov	ecx, DWORD PTR _aBestPlotList$226937[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _pPlot$226974[ebp], edx

; 3053 : #endif
; 3054 : 
; 3055 : 					if(CanReachInXTurns(pUnit, pPlot, 1))

	push	0
	push	0
	push	1
	mov	eax, DWORD PTR _pPlot$226974[ebp]
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T249563[ebp], esp
	mov	DWORD PTR $T249892[ebp], ecx
	mov	edx, DWORD PTR $T249892[ebp]
	mov	eax, DWORD PTR _pUnit$226938[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T249892[ebp]
	mov	dl, BYTE PTR _pUnit$226938[ebp+4]
	mov	BYTE PTR [ecx+4], dl
	mov	eax, DWORD PTR $T249892[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN190@ExecuteMov
	mov	ecx, DWORD PTR $T249892[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN190@ExecuteMov:
	mov	edx, DWORD PTR $T249892[ebp]
	mov	DWORD PTR tv343[ebp], edx
	call	?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z ; CanReachInXTurns
	add	esp, 24					; 00000018H
	mov	BYTE PTR tv344[ebp], al
	movzx	eax, BYTE PTR tv344[ebp]
	test	eax, eax
	je	SHORT $LN3@ExecuteMov

; 3056 : 					{
; 3057 : 						pBestPlot = pPlot;

	mov	ecx, DWORD PTR _pPlot$226974[ebp]
	mov	DWORD PTR _pBestPlot$226940[ebp], ecx

; 3058 : 						break;

	jmp	SHORT $LN7@ExecuteMov
$LN3@ExecuteMov:

; 3059 : 					}
; 3060 : 					#ifdef EXECUTEMOVESTOSAFESTPLOT_FAILURE_LIMIT
; 3061 : 					else
; 3062 : 					{
; 3063 : 						if (iFailureLimit-- == 0)
; 3064 : 							break;
; 3065 : 					}
; 3066 : 					#endif
; 3067 : 				}

	jmp	$LN5@ExecuteMov
$LN7@ExecuteMov:

; 3068 : 			}
; 3069 : 
; 3070 : 			if(pBestPlot != NULL)

	cmp	DWORD PTR _pBestPlot$226940[ebp], 0
	je	$LN26@ExecuteMov

; 3071 : 			{
; 3072 : 				// Move to the lowest danger value found
; 3073 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestPlot->getX(), pBestPlot->getY(), MOVE_UNITS_IGNORE_DANGER);

	mov	edx, DWORD PTR _pBestPlot$226940[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T249896[ebp], eax
	mov	ecx, DWORD PTR _pBestPlot$226940[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T249900[ebp], edx
	mov	eax, DWORD PTR _pUnit$226938[ebp]
	mov	DWORD PTR $T249904[ebp], eax
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	8
	mov	ecx, DWORD PTR $T249896[ebp]
	push	ecx
	mov	edx, DWORD PTR $T249900[ebp]
	push	edx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T249904[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3074 : 				pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$226938[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3075 : 				UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR _pUnit$226938[ebp]
	mov	DWORD PTR $T249911[ebp], eax
	mov	ecx, DWORD PTR $T249911[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T249920[ebp], edx
	mov	eax, DWORD PTR $T249920[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3076 : 
; 3077 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN26@ExecuteMov
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN26@ExecuteMov

; 3078 : 				{
; 3079 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226979[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 3080 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226980[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 3081 : #ifdef AUI_WARNING_FIXES
; 3082 : 					CvUnitEntry* pTempUnitInfo = GC.getUnitInfo(pUnit->getUnitType());
; 3083 : 					if (pTempUnitInfo)
; 3084 : 						strTemp = pTempUnitInfo->GetDescription();
; 3085 : #else
; 3086 : 					strTemp = GC.getUnitInfo(pUnit->getUnitType())->GetDescription();

	mov	eax, DWORD PTR _pUnit$226938[ebp]
	mov	DWORD PTR $T249932[ebp], eax
	mov	ecx, DWORD PTR $T249932[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR $T249936[ebp], eax
	mov	ecx, DWORD PTR $T249936[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T249942[ebp], eax
	cmp	DWORD PTR $T249942[ebp], 0
	je	SHORT $LN219@ExecuteMov
	mov	ecx, DWORD PTR $T249942[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$226980[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN220@ExecuteMov
$LN219@ExecuteMov:
	lea	ecx, DWORD PTR _strTemp$226980[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN220@ExecuteMov:

; 3087 : #endif
; 3088 : 					strLogString.Format("Moving %s to safety, X: %d, Y: %d", strTemp.GetCString(), pBestPlot->getX(), pBestPlot->getY());

	mov	edx, DWORD PTR _pBestPlot$226940[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T249946[ebp], eax
	mov	ecx, DWORD PTR _pBestPlot$226940[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T249950[ebp], edx
	mov	eax, DWORD PTR $T249946[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249950[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$226980[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CC@BBNFEHAF@Moving?5?$CFs?5to?5safety?0?5X?3?5?$CFd?0?5Y?3?5?$CF@
	lea	edx, DWORD PTR _strLogString$226979[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 3089 : 					LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$226979[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3090 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strTemp$226980[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLogString$226979[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN26@ExecuteMov:

; 3091 : 			}
; 3092 : 		}
; 3093 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pUnit$226938[ebp], 0
	je	SHORT $LN235@ExecuteMov
	mov	ecx, DWORD PTR _pUnit$226938[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN235@ExecuteMov:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _aBestPlotList$226937[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>
	jmp	$LN28@ExecuteMov
$LN30@ExecuteMov:

; 3094 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _aBestPlotList$226937[ebp]
	jmp	??1?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ ; CvWeightedVector<CvPlot *,100,1>::~CvWeightedVector<CvPlot *,100,1>
__unwindfunclet$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _pUnit$226938[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strLogString$226979[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strTemp$226980[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::ExecuteMovesToSafestPlot
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -64						; size = 4
$T250065 = -60						; size = 4
$T250056 = -56						; size = 4
$T250049 = -52						; size = 4
$T250045 = -48						; size = 4
$T250041 = -44						; size = 4
$T250031 = -40						; size = 4
$T250021 = -36						; size = 4
$T250017 = -32						; size = 4
_pUnit$226990 = -28					; size = 8
_pTarget$226991 = -20					; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecutePatrolMoves, COMDAT
; _this$ = ecx

; 3098 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3099 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 3100 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN4@ExecutePat
$LN3@ExecutePat:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], edx
$LN4@ExecutePat:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T250017[ebp], eax
	mov	ecx, DWORD PTR $T250017[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T250017[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN5@ExecutePat

; 3101 : 	{
; 3102 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T250021[ebp], edx
	mov	eax, DWORD PTR $T250021[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T250031[ebp], eax
	mov	edx, DWORD PTR $T250031[ebp]
	mov	DWORD PTR _pUnit$226990[ebp], edx
	mov	BYTE PTR _pUnit$226990[ebp+4], 0
	cmp	DWORD PTR _pUnit$226990[ebp], 0
	je	SHORT $LN15@ExecutePat
	mov	ecx, DWORD PTR _pUnit$226990[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN15@ExecutePat:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3103 : 		CvPlot* pTarget = it->GetTarget();

	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _pTarget$226991[ebp], ecx

; 3104 : 		if(pUnit && pTarget)

	xor	edx, edx
	cmp	DWORD PTR _pUnit$226990[ebp], 0
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@ExecutePat
	cmp	DWORD PTR _pTarget$226991[ebp], 0
	je	SHORT $LN1@ExecutePat

; 3105 : 		{
; 3106 : 			pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());

	mov	ecx, DWORD PTR _pTarget$226991[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T250041[ebp], edx
	mov	eax, DWORD PTR _pTarget$226991[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T250045[ebp], ecx
	mov	edx, DWORD PTR _pUnit$226990[ebp]
	mov	DWORD PTR $T250049[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR $T250041[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250045[ebp]
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T250049[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3107 : 			pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$226990[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3108 : 			UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$226990[ebp]
	mov	DWORD PTR $T250056[ebp], edx
	mov	eax, DWORD PTR $T250056[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T250065[ebp], ecx
	mov	edx, DWORD PTR $T250065[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed
$LN1@ExecutePat:

; 3109 : 		}
; 3110 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$226990[ebp], 0
	je	SHORT $LN38@ExecutePat
	mov	ecx, DWORD PTR _pUnit$226990[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN38@ExecutePat:
	jmp	$LN3@ExecutePat
$LN5@ExecutePat:

; 3111 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$226990[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecutePatrolMoves
EXTRN	?canFortify@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canFortify
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z$2
__ehfuncinfo$?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
tv423 = -216						; size = 4
tv422 = -212						; size = 4
tv413 = -208						; size = 4
tv412 = -204						; size = 4
_this$ = -200						; size = 4
$T250343 = -196						; size = 4
$T250336 = -192						; size = 4
$T250332 = -188						; size = 4
$T250328 = -184						; size = 4
$T250324 = -180						; size = 4
$T250314 = -176						; size = 4
$T250310 = -172						; size = 4
$T250297 = -168						; size = 4
$T250290 = -164						; size = 4
$T250286 = -160						; size = 4
$T250282 = -156						; size = 4
$T250278 = -152						; size = 4
$T250271 = -148						; size = 4
$T250261 = -144						; size = 4
$T250257 = -140						; size = 4
$T250232 = -136						; size = 4
$T250225 = -132						; size = 4
$T250221 = -128						; size = 4
$T250217 = -124						; size = 4
$T250213 = -120						; size = 4
$T250203 = -116						; size = 4
$T250199 = -112						; size = 4
$T250186 = -108						; size = 4
$T250179 = -104						; size = 4
$T250175 = -100						; size = 4
$T250171 = -96						; size = 4
$T250167 = -92						; size = 4
$T250151 = -88						; size = 4
$T250147 = -84						; size = 4
$T250143 = -80						; size = 4
$T250139 = -76						; size = 4
$T250135 = -72						; size = 4
$T250125 = -68						; size = 4
$T250121 = -64						; size = 4
$T250114 = -60						; size = 4
$T250105 = -56						; size = 4
$T250101 = -52						; size = 4
$T250097 = -48						; size = 4
$T250084 = -44						; size = 4
$T250083 = -40						; size = 4
_pUnit$227021 = -36					; size = 8
_pUnit$227010 = -28					; size = 8
_pBestUnit$ = -20					; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pTarget$ = 8						; size = 4
?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z PROC ; CvHomelandAI::ExecuteMoveToTarget, COMDAT
; _this$ = ecx

; 3116 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3117 : 	AI_PERF_FORMAT("Homeland-ExecuteMove-perf.csv", ("ExecuteMoveToTarget, %d, %d, Turn %03d, %s", pTarget->getX(), pTarget->getY(), GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 3118 : 
; 3119 : 	// Do we have a pre-calcuated 'best' unit?
; 3120 : 	CvUnit *pBestUnit = NULL;

	mov	DWORD PTR _pBestUnit$[ebp], 0

; 3121 : 	if (m_CurrentBestMoveHighPriorityUnit)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2404], 0
	je	SHORT $LN24@ExecuteMov@2

; 3122 : 	{
; 3123 : 		// Don't move high priority unit if regular priority unit is closer
; 3124 : 		if (m_CurrentBestMoveUnit && m_iCurrentBestMoveUnitTurns < m_iCurrentBestMoveHighPriorityUnitTurns)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2396], 0
	je	SHORT $LN23@ExecuteMov@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+2400]
	cmp	ecx, DWORD PTR [eax+2408]
	jge	SHORT $LN23@ExecuteMov@2

; 3125 : 			pBestUnit = m_CurrentBestMoveUnit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2396]
	mov	DWORD PTR _pBestUnit$[ebp], eax

; 3126 : 		else

	jmp	SHORT $LN22@ExecuteMov@2
$LN23@ExecuteMov@2:

; 3127 : 			pBestUnit = m_CurrentBestMoveHighPriorityUnit;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2404]
	mov	DWORD PTR _pBestUnit$[ebp], edx
$LN22@ExecuteMov@2:

; 3128 : 	}
; 3129 : 	else

	jmp	SHORT $LN21@ExecuteMov@2
$LN24@ExecuteMov@2:

; 3130 : 		pBestUnit = m_CurrentBestMoveUnit;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2396]
	mov	DWORD PTR _pBestUnit$[ebp], ecx
$LN21@ExecuteMov@2:

; 3131 : 
; 3132 : 	if (pBestUnit)

	cmp	DWORD PTR _pBestUnit$[ebp], 0
	je	$LN20@ExecuteMov@2

; 3133 : 	{
; 3134 : 		if(pBestUnit->plot() == pTarget && pBestUnit->canFortify(pBestUnit->plot()))

	mov	ecx, DWORD PTR _pBestUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pTarget$[ebp]
	jne	SHORT $LN19@ExecuteMov@2
	mov	ecx, DWORD PTR _pBestUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR _pBestUnit$[ebp]
	call	?canFortify@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canFortify
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN19@ExecuteMov@2

; 3135 : 		{
; 3136 : 			pBestUnit->PushMission(CvTypes::getMISSION_FORTIFY());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FORTIFY
	push	eax
	mov	ecx, DWORD PTR _pBestUnit$[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3137 : 			pBestUnit->SetFortifiedThisTurn(true);

	push	1
	mov	ecx, DWORD PTR _pBestUnit$[ebp]
	call	?SetFortifiedThisTurn@CvUnit@@QAEX_N@Z	; CvUnit::SetFortifiedThisTurn

; 3138 : 			UnitProcessed(pBestUnit->GetID());

	mov	eax, DWORD PTR _pBestUnit$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T250097[ebp], ecx
	mov	edx, DWORD PTR $T250097[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3139 : 			return;

	jmp	$LN25@ExecuteMov@2

; 3140 : 		}
; 3141 : 		else

	jmp	SHORT $LN20@ExecuteMov@2
$LN19@ExecuteMov@2:

; 3142 : 		{
; 3143 : 			// Best units have already had a full path check to the target, so just add the move
; 3144 : 			pBestUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());

	mov	eax, DWORD PTR _pTarget$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T250101[ebp], ecx
	mov	edx, DWORD PTR _pTarget$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T250105[ebp], eax
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR $T250101[ebp]
	push	ecx
	mov	edx, DWORD PTR $T250105[ebp]
	push	edx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR _pBestUnit$[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3145 : 			pBestUnit->finishMoves();

	mov	ecx, DWORD PTR _pBestUnit$[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3146 : 			UnitProcessed(pBestUnit->GetID());

	mov	eax, DWORD PTR _pBestUnit$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T250114[ebp], ecx
	mov	edx, DWORD PTR $T250114[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3147 : 			return;

	jmp	$LN25@ExecuteMov@2
$LN20@ExecuteMov@2:

; 3148 : 		}
; 3149 : 	}
; 3150 : 
; 3151 : 	MoveUnitsArray::iterator it;
; 3152 : 
; 3153 : 	// Start with high priority list
; 3154 : 	for(it = m_CurrentMoveHighPriorityUnits.begin(); it != m_CurrentMoveHighPriorityUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1056]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN17@ExecuteMov@2
$LN16@ExecuteMov@2:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], edx
$LN17@ExecuteMov@2:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1056				; 00000420H
	mov	DWORD PTR $T250121[ebp], eax
	mov	ecx, DWORD PTR $T250121[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T250121[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN15@ExecuteMov@2

; 3155 : 	{
; 3156 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T250125[ebp], edx
	mov	eax, DWORD PTR $T250125[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T250135[ebp], eax
	mov	edx, DWORD PTR $T250135[ebp]
	mov	DWORD PTR _pUnit$227010[ebp], edx
	mov	BYTE PTR _pUnit$227010[ebp+4], 0
	cmp	DWORD PTR _pUnit$227010[ebp], 0
	je	SHORT $LN50@ExecuteMov@2
	mov	ecx, DWORD PTR _pUnit$227010[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN50@ExecuteMov@2:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3157 : 
; 3158 : 		// Don't move high priority unit if regular priority unit is closer
; 3159 : 		if(m_CurrentMoveUnits.size() > 0 && m_CurrentMoveUnits.begin()->GetMovesToTarget() < it->GetMovesToTarget())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T250139[ebp], ecx
	cmp	DWORD PTR $T250139[ebp], 0
	jbe	SHORT $LN67@ExecuteMov@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR $T250143[ebp], eax
	mov	ecx, DWORD PTR $T250143[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T250147[ebp], edx
	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T250151[ebp], ecx
	mov	edx, DWORD PTR $T250147[ebp]
	cmp	edx, DWORD PTR $T250151[ebp]
	jge	SHORT $LN67@ExecuteMov@2

; 3160 : 		{
; 3161 : 			break;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227010[ebp], 0
	je	SHORT $LN63@ExecuteMov@2
	mov	ecx, DWORD PTR _pUnit$227010[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN63@ExecuteMov@2:
	jmp	$LN15@ExecuteMov@2

; 3162 : 		}
; 3163 : 
; 3164 : 		if(pUnit)

$LN67@ExecuteMov@2:
	xor	eax, eax
	cmp	DWORD PTR _pUnit$227010[ebp], 0
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN13@ExecuteMov@2

; 3165 : 		{
; 3166 : 			if(pUnit->plot() == pTarget && pUnit->canFortify(pUnit->plot()))

	mov	edx, DWORD PTR _pUnit$227010[ebp]
	mov	DWORD PTR $T250167[ebp], edx
	mov	ecx, DWORD PTR $T250167[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pTarget$[ebp]
	jne	$LN12@ExecuteMov@2
	mov	eax, DWORD PTR _pUnit$227010[ebp]
	mov	DWORD PTR $T250171[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227010[ebp]
	mov	DWORD PTR $T250175[ebp], ecx
	mov	ecx, DWORD PTR $T250171[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR $T250175[ebp]
	call	?canFortify@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canFortify
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN12@ExecuteMov@2

; 3167 : 			{
; 3168 : 				pUnit->PushMission(CvTypes::getMISSION_FORTIFY());

	mov	eax, DWORD PTR _pUnit$227010[ebp]
	mov	DWORD PTR $T250179[ebp], eax
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FORTIFY
	push	eax
	mov	ecx, DWORD PTR $T250179[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3169 : 				pUnit->SetFortifiedThisTurn(true);

	push	1
	mov	ecx, DWORD PTR _pUnit$227010[ebp]
	call	?SetFortifiedThisTurn@CvUnit@@QAEX_N@Z	; CvUnit::SetFortifiedThisTurn

; 3170 : 				UnitProcessed(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T250186[ebp], edx
	mov	eax, DWORD PTR $T250186[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3171 : 				return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227010[ebp], 0
	je	SHORT $LN82@ExecuteMov@2
	mov	ecx, DWORD PTR _pUnit$227010[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN82@ExecuteMov@2:
	jmp	$LN25@ExecuteMov@2
	jmp	$LN13@ExecuteMov@2
$LN12@ExecuteMov@2:

; 3172 : 			}
; 3173 : 
; 3174 : 			else if(it->GetMovesToTarget() < GC.getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE() || TurnsToReachTarget(pUnit, pTarget) != MAX_INT)

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T250199[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2572
	mov	DWORD PTR $T250203[ebp], eax
	mov	ecx, DWORD PTR $T250199[ebp]
	cmp	ecx, DWORD PTR $T250203[ebp]
	jl	SHORT $LN9@ExecuteMov@2
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _pTarget$[ebp]
	push	edx
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T250083[ebp], esp
	mov	DWORD PTR $T250213[ebp], eax
	mov	ecx, DWORD PTR $T250213[ebp]
	mov	edx, DWORD PTR _pUnit$227010[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T250213[ebp]
	mov	cl, BYTE PTR _pUnit$227010[ebp+4]
	mov	BYTE PTR [eax+4], cl
	mov	edx, DWORD PTR $T250213[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN91@ExecuteMov@2
	mov	eax, DWORD PTR $T250213[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN91@ExecuteMov@2:
	mov	ecx, DWORD PTR $T250213[ebp]
	mov	DWORD PTR tv412[ebp], ecx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv413[ebp], eax
	cmp	DWORD PTR tv413[ebp], 2147483647	; 7fffffffH
	je	$LN13@ExecuteMov@2
$LN9@ExecuteMov@2:

; 3175 : 			{
; 3176 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());

	mov	edx, DWORD PTR _pTarget$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T250217[ebp], eax
	mov	ecx, DWORD PTR _pTarget$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T250221[ebp], edx
	mov	eax, DWORD PTR _pUnit$227010[ebp]
	mov	DWORD PTR $T250225[ebp], eax
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR $T250217[ebp]
	push	ecx
	mov	edx, DWORD PTR $T250221[ebp]
	push	edx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T250225[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3177 : 				pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$227010[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3178 : 				UnitProcessed(it->GetID());

	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T250232[ebp], ecx
	mov	edx, DWORD PTR $T250232[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3179 : 				return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227010[ebp], 0
	je	SHORT $LN106@ExecuteMov@2
	mov	ecx, DWORD PTR _pUnit$227010[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN106@ExecuteMov@2:
	jmp	$LN25@ExecuteMov@2
$LN13@ExecuteMov@2:

; 3180 : 			}
; 3181 : 		}
; 3182 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227010[ebp], 0
	je	SHORT $LN111@ExecuteMov@2
	mov	ecx, DWORD PTR _pUnit$227010[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN111@ExecuteMov@2:
	jmp	$LN16@ExecuteMov@2
$LN15@ExecuteMov@2:

; 3183 : 
; 3184 : 	// Then regular priority
; 3185 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN8@ExecuteMov@2
$LN7@ExecuteMov@2:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], edx
$LN8@ExecuteMov@2:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T250257[ebp], eax
	mov	ecx, DWORD PTR $T250257[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T250257[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN25@ExecuteMov@2

; 3186 : 	{
; 3187 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T250261[ebp], edx
	mov	eax, DWORD PTR $T250261[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T250271[ebp], eax
	mov	edx, DWORD PTR $T250271[ebp]
	mov	DWORD PTR _pUnit$227021[ebp], edx
	mov	BYTE PTR _pUnit$227021[ebp+4], 0
	cmp	DWORD PTR _pUnit$227021[ebp], 0
	je	SHORT $LN122@ExecuteMov@2
	mov	ecx, DWORD PTR _pUnit$227021[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN122@ExecuteMov@2:
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 3188 : 		if(pUnit)

	xor	eax, eax
	cmp	DWORD PTR _pUnit$227021[ebp], 0
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@ExecuteMov@2

; 3189 : 		{
; 3190 : 			if(pUnit->plot() == pTarget && pUnit->canFortify(pUnit->plot()))

	mov	edx, DWORD PTR _pUnit$227021[ebp]
	mov	DWORD PTR $T250278[ebp], edx
	mov	ecx, DWORD PTR $T250278[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pTarget$[ebp]
	jne	$LN4@ExecuteMov@2
	mov	eax, DWORD PTR _pUnit$227021[ebp]
	mov	DWORD PTR $T250282[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227021[ebp]
	mov	DWORD PTR $T250286[ebp], ecx
	mov	ecx, DWORD PTR $T250282[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR $T250286[ebp]
	call	?canFortify@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canFortify
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@ExecuteMov@2

; 3191 : 			{
; 3192 : 				pUnit->PushMission(CvTypes::getMISSION_FORTIFY());

	mov	eax, DWORD PTR _pUnit$227021[ebp]
	mov	DWORD PTR $T250290[ebp], eax
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FORTIFY
	push	eax
	mov	ecx, DWORD PTR $T250290[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3193 : 				pUnit->SetFortifiedThisTurn(true);

	push	1
	mov	ecx, DWORD PTR _pUnit$227021[ebp]
	call	?SetFortifiedThisTurn@CvUnit@@QAEX_N@Z	; CvUnit::SetFortifiedThisTurn

; 3194 : 				UnitProcessed(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T250297[ebp], edx
	mov	eax, DWORD PTR $T250297[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3195 : 				return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227021[ebp], 0
	je	SHORT $LN141@ExecuteMov@2
	mov	ecx, DWORD PTR _pUnit$227021[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN141@ExecuteMov@2:
	jmp	$LN25@ExecuteMov@2
	jmp	$LN5@ExecuteMov@2
$LN4@ExecuteMov@2:

; 3196 : 			}
; 3197 : 
; 3198 : 			else if(it->GetMovesToTarget() < GC.getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE() || TurnsToReachTarget(pUnit, pTarget) != MAX_INT)

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T250310[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2572
	mov	DWORD PTR $T250314[ebp], eax
	mov	ecx, DWORD PTR $T250310[ebp]
	cmp	ecx, DWORD PTR $T250314[ebp]
	jl	SHORT $LN1@ExecuteMov@2
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _pTarget$[ebp]
	push	edx
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T250084[ebp], esp
	mov	DWORD PTR $T250324[ebp], eax
	mov	ecx, DWORD PTR $T250324[ebp]
	mov	edx, DWORD PTR _pUnit$227021[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T250324[ebp]
	mov	cl, BYTE PTR _pUnit$227021[ebp+4]
	mov	BYTE PTR [eax+4], cl
	mov	edx, DWORD PTR $T250324[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN150@ExecuteMov@2
	mov	eax, DWORD PTR $T250324[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN150@ExecuteMov@2:
	mov	ecx, DWORD PTR $T250324[ebp]
	mov	DWORD PTR tv422[ebp], ecx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv423[ebp], eax
	cmp	DWORD PTR tv423[ebp], 2147483647	; 7fffffffH
	je	$LN5@ExecuteMov@2
$LN1@ExecuteMov@2:

; 3199 : 			{
; 3200 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());

	mov	edx, DWORD PTR _pTarget$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T250328[ebp], eax
	mov	ecx, DWORD PTR _pTarget$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T250332[ebp], edx
	mov	eax, DWORD PTR _pUnit$227021[ebp]
	mov	DWORD PTR $T250336[ebp], eax
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR $T250328[ebp]
	push	ecx
	mov	edx, DWORD PTR $T250332[ebp]
	push	edx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T250336[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3201 : 				pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$227021[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3202 : 				UnitProcessed(it->GetID());

	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T250343[ebp], ecx
	mov	edx, DWORD PTR $T250343[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3203 : 				return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227021[ebp], 0
	je	SHORT $LN165@ExecuteMov@2
	mov	ecx, DWORD PTR _pUnit$227021[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN165@ExecuteMov@2:
	jmp	SHORT $LN25@ExecuteMov@2
$LN5@ExecuteMov@2:

; 3204 : 			}
; 3205 : 		}
; 3206 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227021[ebp], 0
	je	SHORT $LN170@ExecuteMov@2
	mov	ecx, DWORD PTR _pUnit$227021[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN170@ExecuteMov@2:
	jmp	$LN7@ExecuteMov@2
$LN25@ExecuteMov@2:

; 3207 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$227010[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z$2:
	lea	ecx, DWORD PTR _pUnit$227021[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ENDP ; CvHomelandAI::ExecuteMoveToTarget
PUBLIC	??_C@_0DK@BNOOEPLC@Could?5not?5find?5a?5target?5for?5Grea@ ; `string'
PUBLIC	??_C@_0DM@NCOAMJID@Moving?5Great?5Writer?5toward?5Great@ ; `string'
PUBLIC	??_C@_0DA@JBCEOIDB@Moving?5and?5creating?5Great?5Work?5a@ ; `string'
PUBLIC	??_C@_0CF@OKBFAJHG@Creating?5Great?5Work?5at?0?5X?3?5?$CFd?0?5Y@ ; `string'
PUBLIC	??_C@_0DN@IFMJNBP@Great?5writer?5can?8t?5find?5a?5Great?5@ ; `string'
PUBLIC	?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteCultureBlast
PUBLIC	__$ArrayPad$
EXTRN	?getMISSION_GREAT_WORK@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_GREAT_WORK
EXTRN	?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z:PROC ; CvEconomicAI::GetBestGreatWorkCity
EXTRN	?GetGreatWork@CvUnit@@QBE?AW4GreatWorkType@@XZ:PROC ; CvUnit::GetGreatWork
EXTRN	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ:PROC ; CvUnit::GetGreatPeopleDirective
;	COMDAT ??_C@_0DK@BNOOEPLC@Could?5not?5find?5a?5target?5for?5Grea@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0DK@BNOOEPLC@Could?5not?5find?5a?5target?5for?5Grea@ DB 'Could not '
	DB	'find a target for Great Writer at, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@NCOAMJID@Moving?5Great?5Writer?5toward?5Great@
CONST	SEGMENT
??_C@_0DM@NCOAMJID@Moving?5Great?5Writer?5toward?5Great@ DB 'Moving Great'
	DB	' Writer toward Great Work city at, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@JBCEOIDB@Moving?5and?5creating?5Great?5Work?5a@
CONST	SEGMENT
??_C@_0DA@JBCEOIDB@Moving?5and?5creating?5Great?5Work?5a@ DB 'Moving and '
	DB	'creating Great Work at, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OKBFAJHG@Creating?5Great?5Work?5at?0?5X?3?5?$CFd?0?5Y@
CONST	SEGMENT
??_C@_0CF@OKBFAJHG@Creating?5Great?5Work?5at?0?5X?3?5?$CFd?0?5Y@ DB 'Crea'
	DB	'ting Great Work at, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@IFMJNBP@Great?5writer?5can?8t?5find?5a?5Great?5@
CONST	SEGMENT
??_C@_0DN@IFMJNBP@Great?5writer?5can?8t?5find?5a?5Great?5@ DB 'Great writ'
	DB	'er can''t find a Great Work slot. Running to safety', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$5
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$6
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv446 = -512						; size = 4
tv445 = -508						; size = 4
tv439 = -504						; size = 4
tv438 = -500						; size = 4
tv129 = -496						; size = 4
_this$ = -492						; size = 4
$T250896 = -488						; size = 4
$T250887 = -484						; size = 4
$T250883 = -480						; size = 4
$T250874 = -476						; size = 4
$T250859 = -472						; size = 4
$T250851 = -468						; size = 4
$T250844 = -464						; size = 4
$T250840 = -460						; size = 4
$T250836 = -456						; size = 4
$T250819 = -452						; size = 4
$T250810 = -448						; size = 4
$T250806 = -444						; size = 4
$T250797 = -440						; size = 4
$T250789 = -436						; size = 4
$T250780 = -432						; size = 4
$T250776 = -428						; size = 4
$T250772 = -424						; size = 4
$T250768 = -420						; size = 4
$T250764 = -416						; size = 4
$T250760 = -412						; size = 4
$T250596 = -328						; size = 4
$T250587 = -324						; size = 4
$T250578 = -320						; size = 4
$T250555 = -316						; size = 4
$T250546 = -312						; size = 4
$T250542 = -308						; size = 4
$T250533 = -304						; size = 4
$T250525 = -300						; size = 4
$T250516 = -296						; size = 4
$T250512 = -292						; size = 4
$T250483 = -256						; size = 4
$T250474 = -252						; size = 4
$T250470 = -248						; size = 4
$T250461 = -244						; size = 4
$T250457 = -240						; size = 4
$T250448 = -236						; size = 4
$T250428 = -232						; size = 4
$T250424 = -228						; size = 4
$T250417 = -224						; size = 4
$T250401 = -220						; size = 4
$T250391 = -216						; size = 4
$T250387 = -212						; size = 4
$T250372 = -208						; size = 4
$T250371 = -204						; size = 4
_strLogString$227082 = -200				; size = 28
_strLogString$227078 = -172				; size = 28
_strLogString$227074 = -144				; size = 28
_pAdjacentPlot$227066 = -116				; size = 4
_iI$227062 = -112					; size = 4
_iBestTurns$227058 = -108				; size = 4
_pBestTarget$227057 = -104				; size = 4
_iTurns$227059 = -100					; size = 4
_strLogString$227054 = -96				; size = 28
_strLogString$227049 = -68				; size = 28
__$ArrayPad$ = -40					; size = 4
_pTargetCity$227046 = -36				; size = 4
_eGreatWorkType$227045 = -32				; size = 4
_pUnit$227036 = -28					; size = 8
_eDirective$227038 = -20				; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteWriterMoves, COMDAT
; _this$ = ecx

; 3211 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 500				; 000001f4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3212 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 3213 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN28@ExecuteWri
$LN27@ExecuteWri:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], edx
$LN28@ExecuteWri:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T250387[ebp], eax
	mov	ecx, DWORD PTR $T250387[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T250387[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN29@ExecuteWri

; 3214 : 	{
; 3215 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T250391[ebp], edx
	mov	eax, DWORD PTR $T250391[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T250401[ebp], eax
	mov	edx, DWORD PTR $T250401[ebp]
	mov	DWORD PTR _pUnit$227036[ebp], edx
	mov	BYTE PTR _pUnit$227036[ebp+4], 0
	cmp	DWORD PTR _pUnit$227036[ebp], 0
	je	SHORT $LN46@ExecuteWri
	mov	ecx, DWORD PTR _pUnit$227036[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN46@ExecuteWri:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3216 : 		if(!pUnit)

	xor	eax, eax
	cmp	DWORD PTR _pUnit$227036[ebp], 0
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN25@ExecuteWri

; 3217 : 		{
; 3218 : 			continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227036[ebp], 0
	je	SHORT $LN53@ExecuteWri
	mov	ecx, DWORD PTR _pUnit$227036[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@ExecuteWri:
	jmp	$LN27@ExecuteWri
$LN25@ExecuteWri:

; 3219 : 		}
; 3220 : 
; 3221 : 		GreatPeopleDirectiveTypes eDirective = pUnit->GetGreatPeopleDirective();

	mov	edx, DWORD PTR _pUnit$227036[ebp]
	mov	DWORD PTR $T250417[ebp], edx
	mov	ecx, DWORD PTR $T250417[ebp]
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective
	mov	DWORD PTR _eDirective$227038[ebp], eax

; 3222 : 		switch(eDirective)

	mov	eax, DWORD PTR _eDirective$227038[ebp]
	mov	DWORD PTR tv129[ebp], eax
	cmp	DWORD PTR tv129[ebp], -1
	je	$LN297@ExecuteWri
	cmp	DWORD PTR tv129[ebp], 1
	je	SHORT $LN21@ExecuteWri
	cmp	DWORD PTR tv129[ebp], 4
	je	SHORT $LN59@ExecuteWri
	jmp	$LN23@ExecuteWri

; 3223 : 		{
; 3224 : 		case GREAT_PEOPLE_DIRECTIVE_CULTURE_BLAST:
; 3225 : 			ExecuteCultureBlast(pUnit.pointer());

$LN59@ExecuteWri:
	mov	ecx, DWORD PTR _pUnit$227036[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteCultureBlast

; 3226 : 			break;

	jmp	$LN23@ExecuteWri
$LN21@ExecuteWri:

; 3227 : 
; 3228 : 		case GREAT_PEOPLE_DIRECTIVE_USE_POWER:
; 3229 : 			{
; 3230 : 				// Do we want to create a Great Work?
; 3231 : 				GreatWorkType eGreatWorkType = pUnit->GetGreatWork();

	mov	edx, DWORD PTR _pUnit$227036[ebp]
	mov	DWORD PTR $T250424[ebp], edx
	mov	ecx, DWORD PTR $T250424[ebp]
	call	?GetGreatWork@CvUnit@@QBE?AW4GreatWorkType@@XZ ; CvUnit::GetGreatWork
	mov	DWORD PTR _eGreatWorkType$227045[ebp], eax

; 3232 : 				CvCity* pTargetCity = m_pPlayer->GetEconomicAI()->GetBestGreatWorkCity(pUnit->plot(), eGreatWorkType);

	mov	eax, DWORD PTR _pUnit$227036[ebp]
	mov	DWORD PTR $T250428[ebp], eax
	mov	ecx, DWORD PTR _eGreatWorkType$227045[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T250428[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z ; CvEconomicAI::GetBestGreatWorkCity
	mov	DWORD PTR _pTargetCity$227046[ebp], eax

; 3233 : 
; 3234 : 				// No?  Just move to safety...
; 3235 : 				if (pTargetCity == NULL)

	cmp	DWORD PTR _pTargetCity$227046[ebp], 0
	jne	SHORT $LN75@ExecuteWri

; 3236 : 				{
; 3237 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN71@ExecuteWri
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN71@ExecuteWri

; 3238 : 					{
; 3239 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227049[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3240 : 						strLogString.Format("Great writer can't find a Great Work slot. Running to safety");

	push	OFFSET ??_C@_0DN@IFMJNBP@Great?5writer?5can?8t?5find?5a?5Great?5@
	lea	edx, DWORD PTR _strLogString$227049[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3241 : 						LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227049[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3242 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227049[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3243 : 
; 3244 : 					MoveCivilianToSafety(pUnit.pointer());

$LN71@ExecuteWri:
	push	0
	mov	ecx, DWORD PTR _pUnit$227036[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety

; 3245 : 				}
; 3246 : 				else

	jmp	$LN18@ExecuteWri

; 3247 : 				{
; 3248 : 					// Already at (or adjacent to) target?
; 3249 : 					if (plotDistance(pUnit->getX(), pUnit->getY(), pTargetCity->getX(), pTargetCity->getY()) <= 1)

$LN75@ExecuteWri:
	mov	edx, DWORD PTR _pTargetCity$227046[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T250448[ebp], eax
	mov	ecx, DWORD PTR _pTargetCity$227046[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T250457[ebp], edx
	mov	eax, DWORD PTR _pUnit$227036[ebp]
	mov	DWORD PTR $T250461[ebp], eax
	mov	ecx, DWORD PTR $T250461[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T250470[ebp], edx
	mov	eax, DWORD PTR _pUnit$227036[ebp]
	mov	DWORD PTR $T250474[ebp], eax
	mov	ecx, DWORD PTR $T250474[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T250483[ebp], edx
	mov	eax, DWORD PTR $T250448[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250457[ebp]
	push	ecx
	mov	edx, DWORD PTR $T250470[ebp]
	push	edx
	mov	eax, DWORD PTR $T250483[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jg	$LN17@ExecuteWri

; 3250 : 					{
; 3251 : 						pUnit->PushMission(CvTypes::getMISSION_GREAT_WORK());

	mov	ecx, DWORD PTR _pUnit$227036[ebp]
	mov	DWORD PTR $T250512[ebp], ecx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_GREAT_WORK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GREAT_WORK
	push	eax
	mov	ecx, DWORD PTR $T250512[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3252 : 						UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$227036[ebp]
	mov	DWORD PTR $T250516[ebp], edx
	mov	eax, DWORD PTR $T250516[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T250525[ebp], ecx
	mov	edx, DWORD PTR $T250525[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3253 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN16@ExecuteWri
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN16@ExecuteWri

; 3254 : 						{
; 3255 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227054[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 3256 : 							strLogString.Format("Creating Great Work at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	edx, DWORD PTR _pUnit$227036[ebp]
	mov	DWORD PTR $T250533[ebp], edx
	mov	eax, DWORD PTR $T250533[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T250542[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227036[ebp]
	mov	DWORD PTR $T250546[ebp], edx
	mov	eax, DWORD PTR $T250546[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T250555[ebp], ecx
	mov	edx, DWORD PTR $T250542[ebp]
	push	edx
	mov	eax, DWORD PTR $T250555[ebp]
	push	eax
	push	OFFSET ??_C@_0CF@OKBFAJHG@Creating?5Great?5Work?5at?0?5X?3?5?$CFd?0?5Y@
	lea	ecx, DWORD PTR _strLogString$227054[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3257 : 							LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227054[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3258 : 							continue;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227054[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227036[ebp], 0
	je	SHORT $LN136@ExecuteWri
	mov	ecx, DWORD PTR _pUnit$227036[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN136@ExecuteWri:
	jmp	$LN27@ExecuteWri
$LN16@ExecuteWri:

; 3259 : 						}
; 3260 : 					}
; 3261 : 
; 3262 : 					// No, then move there
; 3263 : 					else

	jmp	$LN18@ExecuteWri
$LN17@ExecuteWri:

; 3264 : 					{
; 3265 : 						// Find which plot (in or adjacent), we can reach in the fewest turns
; 3266 : 						CvPlot *pBestTarget = NULL;

	mov	DWORD PTR _pBestTarget$227057[ebp], 0

; 3267 : 						int iBestTurns = MAX_INT;

	mov	DWORD PTR _iBestTurns$227058[ebp], 2147483647 ; 7fffffffH

; 3268 : 						int iTurns;
; 3269 : 						iTurns = TurnsToReachTarget(pUnit, pTargetCity->plot());

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _pTargetCity$227046[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T250371[ebp], esp
	mov	DWORD PTR $T250578[ebp], eax
	mov	ecx, DWORD PTR $T250578[ebp]
	mov	edx, DWORD PTR _pUnit$227036[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T250578[ebp]
	mov	cl, BYTE PTR _pUnit$227036[ebp+4]
	mov	BYTE PTR [eax+4], cl
	mov	edx, DWORD PTR $T250578[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN141@ExecuteWri
	mov	eax, DWORD PTR $T250578[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN141@ExecuteWri:
	mov	ecx, DWORD PTR $T250578[ebp]
	mov	DWORD PTR tv438[ebp], ecx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv439[ebp], eax
	mov	edx, DWORD PTR tv439[ebp]
	mov	DWORD PTR _iTurns$227059[ebp], edx

; 3270 : 						if (iTurns < iBestTurns)

	mov	eax, DWORD PTR _iTurns$227059[ebp]
	cmp	eax, DWORD PTR _iBestTurns$227058[ebp]
	jge	SHORT $LN14@ExecuteWri

; 3271 : 						{
; 3272 : 							pBestTarget = pTargetCity->plot();

	mov	ecx, DWORD PTR _pTargetCity$227046[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pBestTarget$227057[ebp], eax
$LN14@ExecuteWri:

; 3273 : 						}
; 3274 : 						for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	DWORD PTR _iI$227062[ebp], 0
	jmp	SHORT $LN13@ExecuteWri
$LN12@ExecuteWri:
	mov	ecx, DWORD PTR _iI$227062[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$227062[ebp], ecx
$LN13@ExecuteWri:
	cmp	DWORD PTR _iI$227062[ebp], 6
	jge	$LN11@ExecuteWri

; 3275 : 						{
; 3276 : 							CvPlot* pAdjacentPlot = plotDirection(pTargetCity->getX(), pTargetCity->getY(), ((DirectionTypes)iI));

	mov	edx, DWORD PTR _pTargetCity$227046[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T250587[ebp], eax
	mov	ecx, DWORD PTR _pTargetCity$227046[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T250596[ebp], edx
	mov	eax, DWORD PTR _iI$227062[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250587[ebp]
	push	ecx
	mov	edx, DWORD PTR $T250596[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$227066[ebp], eax

; 3277 : 							if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$227066[ebp], 0
	je	$LN10@ExecuteWri

; 3278 : 							{
; 3279 : 								iTurns = TurnsToReachTarget(pUnit, pAdjacentPlot);

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _pAdjacentPlot$227066[ebp]
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T250372[ebp], esp
	mov	DWORD PTR $T250760[ebp], ecx
	mov	edx, DWORD PTR $T250760[ebp]
	mov	eax, DWORD PTR _pUnit$227036[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T250760[ebp]
	mov	dl, BYTE PTR _pUnit$227036[ebp+4]
	mov	BYTE PTR [ecx+4], dl
	mov	eax, DWORD PTR $T250760[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN218@ExecuteWri
	mov	ecx, DWORD PTR $T250760[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN218@ExecuteWri:
	mov	edx, DWORD PTR $T250760[ebp]
	mov	DWORD PTR tv445[ebp], edx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv446[ebp], eax
	mov	eax, DWORD PTR tv446[ebp]
	mov	DWORD PTR _iTurns$227059[ebp], eax

; 3280 : 								if (iTurns < iBestTurns)

	mov	ecx, DWORD PTR _iTurns$227059[ebp]
	cmp	ecx, DWORD PTR _iBestTurns$227058[ebp]
	jge	SHORT $LN10@ExecuteWri

; 3281 : 								{
; 3282 : 									pBestTarget = pAdjacentPlot;

	mov	edx, DWORD PTR _pAdjacentPlot$227066[ebp]
	mov	DWORD PTR _pBestTarget$227057[ebp], edx

; 3283 : 									iBestTurns = iTurns;

	mov	eax, DWORD PTR _iTurns$227059[ebp]
	mov	DWORD PTR _iBestTurns$227058[ebp], eax
$LN10@ExecuteWri:

; 3284 : 								}
; 3285 : 							}
; 3286 : 						}

	jmp	$LN12@ExecuteWri
$LN11@ExecuteWri:

; 3287 : 
; 3288 : 						if (pBestTarget)

	cmp	DWORD PTR _pBestTarget$227057[ebp], 0
	je	$LN8@ExecuteWri

; 3289 : 						{
; 3290 : 							// In less than one turn?
; 3291 : 							if (iBestTurns == 0)

	cmp	DWORD PTR _iBestTurns$227058[ebp], 0
	jne	$LN7@ExecuteWri

; 3292 : 							{
; 3293 : 								pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestTarget->getX(), pBestTarget->getY());

	mov	ecx, DWORD PTR _pBestTarget$227057[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T250764[ebp], edx
	mov	eax, DWORD PTR _pBestTarget$227057[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T250768[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227036[ebp]
	mov	DWORD PTR $T250772[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR $T250764[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250768[ebp]
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T250772[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3294 : 								pUnit->PushMission(CvTypes::getMISSION_GREAT_WORK());

	mov	edx, DWORD PTR _pUnit$227036[ebp]
	mov	DWORD PTR $T250776[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_GREAT_WORK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GREAT_WORK
	push	eax
	mov	ecx, DWORD PTR $T250776[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3295 : 								UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR _pUnit$227036[ebp]
	mov	DWORD PTR $T250780[ebp], eax
	mov	ecx, DWORD PTR $T250780[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T250789[ebp], edx
	mov	eax, DWORD PTR $T250789[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3296 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@ExecuteWri
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN6@ExecuteWri

; 3297 : 								{
; 3298 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227074[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 3299 : 									strLogString.Format("Moving and creating Great Work at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR _pUnit$227036[ebp]
	mov	DWORD PTR $T250797[ebp], eax
	mov	ecx, DWORD PTR $T250797[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T250806[ebp], edx
	mov	eax, DWORD PTR _pUnit$227036[ebp]
	mov	DWORD PTR $T250810[ebp], eax
	mov	ecx, DWORD PTR $T250810[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T250819[ebp], edx
	mov	eax, DWORD PTR $T250806[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250819[ebp]
	push	ecx
	push	OFFSET ??_C@_0DA@JBCEOIDB@Moving?5and?5creating?5Great?5Work?5a@
	lea	edx, DWORD PTR _strLogString$227074[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3300 : 									LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227074[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3301 : 									continue;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227074[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227036[ebp], 0
	je	SHORT $LN255@ExecuteWri
	mov	ecx, DWORD PTR _pUnit$227036[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN255@ExecuteWri:
	jmp	$LN27@ExecuteWri
$LN6@ExecuteWri:

; 3302 : 								}
; 3303 : 							}
; 3304 : 
; 3305 : 							// In multiple moves
; 3306 : 							else

	jmp	$LN5@ExecuteWri
$LN7@ExecuteWri:

; 3307 : 							{
; 3308 : 								pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestTarget->getX(), pBestTarget->getY());

	mov	ecx, DWORD PTR _pBestTarget$227057[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T250836[ebp], edx
	mov	eax, DWORD PTR _pBestTarget$227057[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T250840[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227036[ebp]
	mov	DWORD PTR $T250844[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR $T250836[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250840[ebp]
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T250844[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3309 : 								pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$227036[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3310 : 								UnitProcessed(it->GetID());

	mov	edx, DWORD PTR _it$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T250851[ebp], eax
	mov	ecx, DWORD PTR $T250851[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3311 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@ExecuteWri
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@ExecuteWri

; 3312 : 								{
; 3313 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227078[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 3314 : 									strLogString.Format("Moving Great Writer toward Great Work city at, X: %d, Y: %d", pBestTarget->getX(),  pBestTarget->getY());

	mov	ecx, DWORD PTR _pBestTarget$227057[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T250859[ebp], edx
	mov	eax, DWORD PTR $T250859[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBestTarget$227057[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0DM@NCOAMJID@Moving?5Great?5Writer?5toward?5Great@
	lea	eax, DWORD PTR _strLogString$227078[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3315 : 									LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227078[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3316 : 								}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227078[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@ExecuteWri:

; 3317 : 							}
; 3318 : 						}
; 3319 : 						else

	jmp	$LN18@ExecuteWri
$LN8@ExecuteWri:

; 3320 : 						{
; 3321 : 							if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN18@ExecuteWri
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	$LN18@ExecuteWri

; 3322 : 							{
; 3323 : 								CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227082[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 3324 : 								strLogString.Format("Could not find a target for Great Writer at, X: %d, Y: %d", pUnit->getX(),  pUnit->getY());

	mov	ecx, DWORD PTR _pUnit$227036[ebp]
	mov	DWORD PTR $T250874[ebp], ecx
	mov	edx, DWORD PTR $T250874[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T250883[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227036[ebp]
	mov	DWORD PTR $T250887[ebp], ecx
	mov	edx, DWORD PTR $T250887[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T250896[ebp], eax
	mov	ecx, DWORD PTR $T250883[ebp]
	push	ecx
	mov	edx, DWORD PTR $T250896[ebp]
	push	edx
	push	OFFSET ??_C@_0DK@BNOOEPLC@Could?5not?5find?5a?5target?5for?5Grea@
	lea	eax, DWORD PTR _strLogString$227082[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3325 : 								LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227082[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3326 : 							}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227082[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN18@ExecuteWri:

; 3327 : 						}
; 3328 : 					}
; 3329 : 				}
; 3330 : 			}	
; 3331 : 			break;

	jmp	SHORT $LN23@ExecuteWri

; 3332 : 
; 3333 : 		case NO_GREAT_PEOPLE_DIRECTIVE_TYPE:
; 3334 : 			MoveCivilianToSafety(pUnit.pointer());

$LN297@ExecuteWri:
	push	0
	mov	edx, DWORD PTR _pUnit$227036[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
$LN23@ExecuteWri:

; 3335 : 			break;
; 3336 : 		}
; 3337 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227036[ebp], 0
	je	SHORT $LN300@ExecuteWri
	mov	ecx, DWORD PTR _pUnit$227036[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN300@ExecuteWri:
	jmp	$LN27@ExecuteWri
$LN29@ExecuteWri:

; 3338 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227036[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$227049[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$227054[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strLogString$227074[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR _strLogString$227078[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _strLogString$227082[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-504]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteWriterMoves
PUBLIC	??_C@_0DK@JDIJFIAC@Could?5not?5find?5a?5target?5for?5Grea@ ; `string'
PUBLIC	??_C@_0DM@GOAKOAAM@Moving?5Great?5Artist?5toward?5Great@ ; `string'
PUBLIC	??_C@_0DN@LKIKKLNH@Great?5artist?5can?8t?5find?5a?5Great?5@ ; `string'
PUBLIC	?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteGoldenAgeMove
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0DK@JDIJFIAC@Could?5not?5find?5a?5target?5for?5Grea@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0DK@JDIJFIAC@Could?5not?5find?5a?5target?5for?5Grea@ DB 'Could not '
	DB	'find a target for Great Artist at, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@GOAKOAAM@Moving?5Great?5Artist?5toward?5Great@
CONST	SEGMENT
??_C@_0DM@GOAKOAAM@Moving?5Great?5Artist?5toward?5Great@ DB 'Moving Great'
	DB	' Artist toward Great Work city at, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@LKIKKLNH@Great?5artist?5can?8t?5find?5a?5Great?5@
CONST	SEGMENT
??_C@_0DN@LKIKKLNH@Great?5artist?5can?8t?5find?5a?5Great?5@ DB 'Great art'
	DB	'ist can''t find a Great Work slot. Running to safety', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$5
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$6
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv446 = -512						; size = 4
tv445 = -508						; size = 4
tv439 = -504						; size = 4
tv438 = -500						; size = 4
tv129 = -496						; size = 4
_this$ = -492						; size = 4
$T251447 = -488						; size = 4
$T251438 = -484						; size = 4
$T251434 = -480						; size = 4
$T251425 = -476						; size = 4
$T251410 = -472						; size = 4
$T251402 = -468						; size = 4
$T251395 = -464						; size = 4
$T251391 = -460						; size = 4
$T251387 = -456						; size = 4
$T251370 = -452						; size = 4
$T251361 = -448						; size = 4
$T251357 = -444						; size = 4
$T251348 = -440						; size = 4
$T251340 = -436						; size = 4
$T251331 = -432						; size = 4
$T251327 = -428						; size = 4
$T251323 = -424						; size = 4
$T251319 = -420						; size = 4
$T251315 = -416						; size = 4
$T251311 = -412						; size = 4
$T251147 = -328						; size = 4
$T251138 = -324						; size = 4
$T251129 = -320						; size = 4
$T251106 = -316						; size = 4
$T251097 = -312						; size = 4
$T251093 = -308						; size = 4
$T251084 = -304						; size = 4
$T251076 = -300						; size = 4
$T251067 = -296						; size = 4
$T251063 = -292						; size = 4
$T251034 = -256						; size = 4
$T251025 = -252						; size = 4
$T251021 = -248						; size = 4
$T251012 = -244						; size = 4
$T251008 = -240						; size = 4
$T250999 = -236						; size = 4
$T250979 = -232						; size = 4
$T250975 = -228						; size = 4
$T250968 = -224						; size = 4
$T250952 = -220						; size = 4
$T250942 = -216						; size = 4
$T250938 = -212						; size = 4
$T250923 = -208						; size = 4
$T250922 = -204						; size = 4
_strLogString$227137 = -200				; size = 28
_strLogString$227133 = -172				; size = 28
_strLogString$227130 = -144				; size = 28
_pAdjacentPlot$227122 = -116				; size = 4
_iI$227118 = -112					; size = 4
_iBestTurns$227114 = -108				; size = 4
_pBestTarget$227113 = -104				; size = 4
_iTurns$227115 = -100					; size = 4
_strLogString$227111 = -96				; size = 28
_strLogString$227106 = -68				; size = 28
__$ArrayPad$ = -40					; size = 4
_pTargetCity$227103 = -36				; size = 4
_eGreatWorkType$227102 = -32				; size = 4
_pUnit$227093 = -28					; size = 8
_eDirective$227095 = -20				; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteArtistMoves, COMDAT
; _this$ = ecx

; 3342 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 500				; 000001f4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3343 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 3344 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN28@ExecuteArt
$LN27@ExecuteArt:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], edx
$LN28@ExecuteArt:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T250938[ebp], eax
	mov	ecx, DWORD PTR $T250938[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T250938[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN29@ExecuteArt

; 3345 : 	{
; 3346 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T250942[ebp], edx
	mov	eax, DWORD PTR $T250942[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T250952[ebp], eax
	mov	edx, DWORD PTR $T250952[ebp]
	mov	DWORD PTR _pUnit$227093[ebp], edx
	mov	BYTE PTR _pUnit$227093[ebp+4], 0
	cmp	DWORD PTR _pUnit$227093[ebp], 0
	je	SHORT $LN46@ExecuteArt
	mov	ecx, DWORD PTR _pUnit$227093[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN46@ExecuteArt:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3347 : 		if(!pUnit)

	xor	eax, eax
	cmp	DWORD PTR _pUnit$227093[ebp], 0
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN25@ExecuteArt

; 3348 : 		{
; 3349 : 			continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227093[ebp], 0
	je	SHORT $LN53@ExecuteArt
	mov	ecx, DWORD PTR _pUnit$227093[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@ExecuteArt:
	jmp	$LN27@ExecuteArt
$LN25@ExecuteArt:

; 3350 : 		}
; 3351 : 
; 3352 : 		GreatPeopleDirectiveTypes eDirective = pUnit->GetGreatPeopleDirective();

	mov	edx, DWORD PTR _pUnit$227093[ebp]
	mov	DWORD PTR $T250968[ebp], edx
	mov	ecx, DWORD PTR $T250968[ebp]
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective
	mov	DWORD PTR _eDirective$227095[ebp], eax

; 3353 : 		switch(eDirective)

	mov	eax, DWORD PTR _eDirective$227095[ebp]
	mov	DWORD PTR tv129[ebp], eax
	cmp	DWORD PTR tv129[ebp], -1
	je	$LN297@ExecuteArt
	cmp	DWORD PTR tv129[ebp], 0
	je	SHORT $LN59@ExecuteArt
	cmp	DWORD PTR tv129[ebp], 1
	je	SHORT $LN21@ExecuteArt
	jmp	$LN23@ExecuteArt

; 3354 : 		{
; 3355 : 		case GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE:
; 3356 : 			ExecuteGoldenAgeMove(pUnit.pointer());

$LN59@ExecuteArt:
	mov	ecx, DWORD PTR _pUnit$227093[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteGoldenAgeMove

; 3357 : 			break;

	jmp	$LN23@ExecuteArt
$LN21@ExecuteArt:

; 3358 : 
; 3359 : 		case GREAT_PEOPLE_DIRECTIVE_USE_POWER:
; 3360 : 			{
; 3361 : 				// Do we want to create a Great Work?
; 3362 : 				GreatWorkType eGreatWorkType = pUnit->GetGreatWork();

	mov	edx, DWORD PTR _pUnit$227093[ebp]
	mov	DWORD PTR $T250975[ebp], edx
	mov	ecx, DWORD PTR $T250975[ebp]
	call	?GetGreatWork@CvUnit@@QBE?AW4GreatWorkType@@XZ ; CvUnit::GetGreatWork
	mov	DWORD PTR _eGreatWorkType$227102[ebp], eax

; 3363 : 				CvCity* pTargetCity = m_pPlayer->GetEconomicAI()->GetBestGreatWorkCity(pUnit->plot(), eGreatWorkType);

	mov	eax, DWORD PTR _pUnit$227093[ebp]
	mov	DWORD PTR $T250979[ebp], eax
	mov	ecx, DWORD PTR _eGreatWorkType$227102[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T250979[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z ; CvEconomicAI::GetBestGreatWorkCity
	mov	DWORD PTR _pTargetCity$227103[ebp], eax

; 3364 : 
; 3365 : 				// No?  Just move to safety...
; 3366 : 				if (pTargetCity == NULL)

	cmp	DWORD PTR _pTargetCity$227103[ebp], 0
	jne	SHORT $LN75@ExecuteArt

; 3367 : 				{
; 3368 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN71@ExecuteArt
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN71@ExecuteArt

; 3369 : 					{
; 3370 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227106[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3371 : 						strLogString.Format("Great artist can't find a Great Work slot. Running to safety");

	push	OFFSET ??_C@_0DN@LKIKKLNH@Great?5artist?5can?8t?5find?5a?5Great?5@
	lea	edx, DWORD PTR _strLogString$227106[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3372 : 						LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227106[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3373 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227106[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3374 : 
; 3375 : 					MoveCivilianToSafety(pUnit.pointer());

$LN71@ExecuteArt:
	push	0
	mov	ecx, DWORD PTR _pUnit$227093[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety

; 3376 : 				}
; 3377 : 				else

	jmp	$LN18@ExecuteArt

; 3378 : 				{
; 3379 : 					// Already at (or adjacent to) target?
; 3380 : 					if (plotDistance(pUnit->getX(), pUnit->getY(), pTargetCity->getX(), pTargetCity->getY()) <= 1)

$LN75@ExecuteArt:
	mov	edx, DWORD PTR _pTargetCity$227103[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T250999[ebp], eax
	mov	ecx, DWORD PTR _pTargetCity$227103[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T251008[ebp], edx
	mov	eax, DWORD PTR _pUnit$227093[ebp]
	mov	DWORD PTR $T251012[ebp], eax
	mov	ecx, DWORD PTR $T251012[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T251021[ebp], edx
	mov	eax, DWORD PTR _pUnit$227093[ebp]
	mov	DWORD PTR $T251025[ebp], eax
	mov	ecx, DWORD PTR $T251025[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T251034[ebp], edx
	mov	eax, DWORD PTR $T250999[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251008[ebp]
	push	ecx
	mov	edx, DWORD PTR $T251021[ebp]
	push	edx
	mov	eax, DWORD PTR $T251034[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jg	$LN17@ExecuteArt

; 3381 : 					{
; 3382 : 						pUnit->PushMission(CvTypes::getMISSION_GREAT_WORK());

	mov	ecx, DWORD PTR _pUnit$227093[ebp]
	mov	DWORD PTR $T251063[ebp], ecx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_GREAT_WORK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GREAT_WORK
	push	eax
	mov	ecx, DWORD PTR $T251063[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3383 : 						UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$227093[ebp]
	mov	DWORD PTR $T251067[ebp], edx
	mov	eax, DWORD PTR $T251067[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T251076[ebp], ecx
	mov	edx, DWORD PTR $T251076[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3384 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN16@ExecuteArt
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN16@ExecuteArt

; 3385 : 						{
; 3386 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227111[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 3387 : 							strLogString.Format("Creating Great Work at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	edx, DWORD PTR _pUnit$227093[ebp]
	mov	DWORD PTR $T251084[ebp], edx
	mov	eax, DWORD PTR $T251084[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T251093[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227093[ebp]
	mov	DWORD PTR $T251097[ebp], edx
	mov	eax, DWORD PTR $T251097[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T251106[ebp], ecx
	mov	edx, DWORD PTR $T251093[ebp]
	push	edx
	mov	eax, DWORD PTR $T251106[ebp]
	push	eax
	push	OFFSET ??_C@_0CF@OKBFAJHG@Creating?5Great?5Work?5at?0?5X?3?5?$CFd?0?5Y@
	lea	ecx, DWORD PTR _strLogString$227111[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3388 : 							LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227111[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3389 : 							continue;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227111[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227093[ebp], 0
	je	SHORT $LN136@ExecuteArt
	mov	ecx, DWORD PTR _pUnit$227093[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN136@ExecuteArt:
	jmp	$LN27@ExecuteArt
$LN16@ExecuteArt:

; 3390 : 						}
; 3391 : 					}
; 3392 : 
; 3393 : 					// No, then move there
; 3394 : 					else

	jmp	$LN18@ExecuteArt
$LN17@ExecuteArt:

; 3395 : 					{
; 3396 : 						// Find which plot (in or adjacent), we can reach in the fewest turns
; 3397 : 						CvPlot *pBestTarget = NULL;

	mov	DWORD PTR _pBestTarget$227113[ebp], 0

; 3398 : 						int iBestTurns = MAX_INT;

	mov	DWORD PTR _iBestTurns$227114[ebp], 2147483647 ; 7fffffffH

; 3399 : 						int iTurns;
; 3400 : 						iTurns = TurnsToReachTarget(pUnit, pTargetCity->plot());

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _pTargetCity$227103[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T250922[ebp], esp
	mov	DWORD PTR $T251129[ebp], eax
	mov	ecx, DWORD PTR $T251129[ebp]
	mov	edx, DWORD PTR _pUnit$227093[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T251129[ebp]
	mov	cl, BYTE PTR _pUnit$227093[ebp+4]
	mov	BYTE PTR [eax+4], cl
	mov	edx, DWORD PTR $T251129[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN141@ExecuteArt
	mov	eax, DWORD PTR $T251129[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN141@ExecuteArt:
	mov	ecx, DWORD PTR $T251129[ebp]
	mov	DWORD PTR tv438[ebp], ecx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv439[ebp], eax
	mov	edx, DWORD PTR tv439[ebp]
	mov	DWORD PTR _iTurns$227115[ebp], edx

; 3401 : 						if (iTurns < iBestTurns)

	mov	eax, DWORD PTR _iTurns$227115[ebp]
	cmp	eax, DWORD PTR _iBestTurns$227114[ebp]
	jge	SHORT $LN14@ExecuteArt

; 3402 : 						{
; 3403 : 							pBestTarget = pTargetCity->plot();

	mov	ecx, DWORD PTR _pTargetCity$227103[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pBestTarget$227113[ebp], eax
$LN14@ExecuteArt:

; 3404 : 						}
; 3405 : 						for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	DWORD PTR _iI$227118[ebp], 0
	jmp	SHORT $LN13@ExecuteArt
$LN12@ExecuteArt:
	mov	ecx, DWORD PTR _iI$227118[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$227118[ebp], ecx
$LN13@ExecuteArt:
	cmp	DWORD PTR _iI$227118[ebp], 6
	jge	$LN11@ExecuteArt

; 3406 : 						{
; 3407 : 							CvPlot* pAdjacentPlot = plotDirection(pTargetCity->getX(), pTargetCity->getY(), ((DirectionTypes)iI));

	mov	edx, DWORD PTR _pTargetCity$227103[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T251138[ebp], eax
	mov	ecx, DWORD PTR _pTargetCity$227103[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T251147[ebp], edx
	mov	eax, DWORD PTR _iI$227118[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251138[ebp]
	push	ecx
	mov	edx, DWORD PTR $T251147[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$227122[ebp], eax

; 3408 : 							if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$227122[ebp], 0
	je	$LN10@ExecuteArt

; 3409 : 							{
; 3410 : 								iTurns = TurnsToReachTarget(pUnit, pAdjacentPlot);

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _pAdjacentPlot$227122[ebp]
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T250923[ebp], esp
	mov	DWORD PTR $T251311[ebp], ecx
	mov	edx, DWORD PTR $T251311[ebp]
	mov	eax, DWORD PTR _pUnit$227093[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T251311[ebp]
	mov	dl, BYTE PTR _pUnit$227093[ebp+4]
	mov	BYTE PTR [ecx+4], dl
	mov	eax, DWORD PTR $T251311[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN218@ExecuteArt
	mov	ecx, DWORD PTR $T251311[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN218@ExecuteArt:
	mov	edx, DWORD PTR $T251311[ebp]
	mov	DWORD PTR tv445[ebp], edx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv446[ebp], eax
	mov	eax, DWORD PTR tv446[ebp]
	mov	DWORD PTR _iTurns$227115[ebp], eax

; 3411 : 								if (iTurns < iBestTurns)

	mov	ecx, DWORD PTR _iTurns$227115[ebp]
	cmp	ecx, DWORD PTR _iBestTurns$227114[ebp]
	jge	SHORT $LN10@ExecuteArt

; 3412 : 								{
; 3413 : 									pBestTarget = pAdjacentPlot;

	mov	edx, DWORD PTR _pAdjacentPlot$227122[ebp]
	mov	DWORD PTR _pBestTarget$227113[ebp], edx

; 3414 : 									iBestTurns = iTurns;

	mov	eax, DWORD PTR _iTurns$227115[ebp]
	mov	DWORD PTR _iBestTurns$227114[ebp], eax
$LN10@ExecuteArt:

; 3415 : 								}
; 3416 : 							}
; 3417 : 						}

	jmp	$LN12@ExecuteArt
$LN11@ExecuteArt:

; 3418 : 
; 3419 : 						if (pBestTarget)

	cmp	DWORD PTR _pBestTarget$227113[ebp], 0
	je	$LN8@ExecuteArt

; 3420 : 						{
; 3421 : 							// In less than one turn?
; 3422 : 							if (iBestTurns == 0)

	cmp	DWORD PTR _iBestTurns$227114[ebp], 0
	jne	$LN7@ExecuteArt

; 3423 : 							{
; 3424 : 								pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestTarget->getX(), pBestTarget->getY());

	mov	ecx, DWORD PTR _pBestTarget$227113[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T251315[ebp], edx
	mov	eax, DWORD PTR _pBestTarget$227113[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T251319[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227093[ebp]
	mov	DWORD PTR $T251323[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR $T251315[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251319[ebp]
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T251323[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3425 : 								pUnit->PushMission(CvTypes::getMISSION_GREAT_WORK());

	mov	edx, DWORD PTR _pUnit$227093[ebp]
	mov	DWORD PTR $T251327[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_GREAT_WORK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GREAT_WORK
	push	eax
	mov	ecx, DWORD PTR $T251327[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3426 : 								UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR _pUnit$227093[ebp]
	mov	DWORD PTR $T251331[ebp], eax
	mov	ecx, DWORD PTR $T251331[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T251340[ebp], edx
	mov	eax, DWORD PTR $T251340[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3427 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@ExecuteArt
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN6@ExecuteArt

; 3428 : 								{
; 3429 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227130[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 3430 : 									strLogString.Format("Moving and creating Great Work at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR _pUnit$227093[ebp]
	mov	DWORD PTR $T251348[ebp], eax
	mov	ecx, DWORD PTR $T251348[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T251357[ebp], edx
	mov	eax, DWORD PTR _pUnit$227093[ebp]
	mov	DWORD PTR $T251361[ebp], eax
	mov	ecx, DWORD PTR $T251361[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T251370[ebp], edx
	mov	eax, DWORD PTR $T251357[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251370[ebp]
	push	ecx
	push	OFFSET ??_C@_0DA@JBCEOIDB@Moving?5and?5creating?5Great?5Work?5a@
	lea	edx, DWORD PTR _strLogString$227130[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3431 : 									LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227130[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3432 : 									continue;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227130[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227093[ebp], 0
	je	SHORT $LN255@ExecuteArt
	mov	ecx, DWORD PTR _pUnit$227093[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN255@ExecuteArt:
	jmp	$LN27@ExecuteArt
$LN6@ExecuteArt:

; 3433 : 								}
; 3434 : 							}
; 3435 : 
; 3436 : 							// In multiple moves
; 3437 : 							else

	jmp	$LN5@ExecuteArt
$LN7@ExecuteArt:

; 3438 : 							{
; 3439 : 								pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestTarget->getX(), pBestTarget->getY());

	mov	ecx, DWORD PTR _pBestTarget$227113[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T251387[ebp], edx
	mov	eax, DWORD PTR _pBestTarget$227113[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T251391[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227093[ebp]
	mov	DWORD PTR $T251395[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR $T251387[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251391[ebp]
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T251395[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3440 : 								pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$227093[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3441 : 								UnitProcessed(it->GetID());

	mov	edx, DWORD PTR _it$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T251402[ebp], eax
	mov	ecx, DWORD PTR $T251402[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3442 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@ExecuteArt
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@ExecuteArt

; 3443 : 								{
; 3444 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227133[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 3445 : 									strLogString.Format("Moving Great Artist toward Great Work city at, X: %d, Y: %d", pBestTarget->getX(),  pBestTarget->getY());

	mov	ecx, DWORD PTR _pBestTarget$227113[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T251410[ebp], edx
	mov	eax, DWORD PTR $T251410[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBestTarget$227113[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0DM@GOAKOAAM@Moving?5Great?5Artist?5toward?5Great@
	lea	eax, DWORD PTR _strLogString$227133[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3446 : 									LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227133[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3447 : 								}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227133[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@ExecuteArt:

; 3448 : 							}
; 3449 : 						}
; 3450 : 						else

	jmp	$LN18@ExecuteArt
$LN8@ExecuteArt:

; 3451 : 						{
; 3452 : 							if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN18@ExecuteArt
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	$LN18@ExecuteArt

; 3453 : 							{
; 3454 : 								CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227137[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 3455 : 								strLogString.Format("Could not find a target for Great Artist at, X: %d, Y: %d", pUnit->getX(),  pUnit->getY());

	mov	ecx, DWORD PTR _pUnit$227093[ebp]
	mov	DWORD PTR $T251425[ebp], ecx
	mov	edx, DWORD PTR $T251425[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T251434[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227093[ebp]
	mov	DWORD PTR $T251438[ebp], ecx
	mov	edx, DWORD PTR $T251438[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T251447[ebp], eax
	mov	ecx, DWORD PTR $T251434[ebp]
	push	ecx
	mov	edx, DWORD PTR $T251447[ebp]
	push	edx
	push	OFFSET ??_C@_0DK@JDIJFIAC@Could?5not?5find?5a?5target?5for?5Grea@
	lea	eax, DWORD PTR _strLogString$227137[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3456 : 								LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227137[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3457 : 							}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227137[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN18@ExecuteArt:

; 3458 : 						}
; 3459 : 					}
; 3460 : 				}
; 3461 : 			}	
; 3462 : 			break;

	jmp	SHORT $LN23@ExecuteArt

; 3463 : 
; 3464 : 		case NO_GREAT_PEOPLE_DIRECTIVE_TYPE:
; 3465 : 			MoveCivilianToSafety(pUnit.pointer());

$LN297@ExecuteArt:
	push	0
	mov	edx, DWORD PTR _pUnit$227093[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
$LN23@ExecuteArt:

; 3466 : 			break;
; 3467 : 		}
; 3468 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227093[ebp], 0
	je	SHORT $LN300@ExecuteArt
	mov	ecx, DWORD PTR _pUnit$227093[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN300@ExecuteArt:
	jmp	$LN27@ExecuteArt
$LN29@ExecuteArt:

; 3469 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227093[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$227106[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$227111[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strLogString$227130[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR _strLogString$227133[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _strLogString$227137[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-504]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteArtistMoves
PUBLIC	??_C@_0DM@DPGBEIHH@Could?5not?5find?5a?5target?5for?5Grea@ ; `string'
PUBLIC	??_C@_0DO@LGPADEGO@Moving?5Great?5Musician?5toward?5Gre@ ; `string'
PUBLIC	??_C@_0DP@LIICEKLM@Great?5musician?5can?8t?5find?5a?5Grea@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0DM@DPGBEIHH@Could?5not?5find?5a?5target?5for?5Grea@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0DM@DPGBEIHH@Could?5not?5find?5a?5target?5for?5Grea@ DB 'Could not '
	DB	'find a target for Great Musician at, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@LGPADEGO@Moving?5Great?5Musician?5toward?5Gre@
CONST	SEGMENT
??_C@_0DO@LGPADEGO@Moving?5Great?5Musician?5toward?5Gre@ DB 'Moving Great'
	DB	' Musician toward Great Work city at, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@LIICEKLM@Great?5musician?5can?8t?5find?5a?5Grea@
CONST	SEGMENT
??_C@_0DP@LIICEKLM@Great?5musician?5can?8t?5find?5a?5Grea@ DB 'Great musi'
	DB	'cian can''t find a Great Work slot. Running to safety', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$5
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$6
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv441 = -512						; size = 4
tv440 = -508						; size = 4
tv434 = -504						; size = 4
tv433 = -500						; size = 4
tv129 = -496						; size = 4
_this$ = -492						; size = 4
$T251995 = -488						; size = 4
$T251986 = -484						; size = 4
$T251982 = -480						; size = 4
$T251973 = -476						; size = 4
$T251958 = -472						; size = 4
$T251950 = -468						; size = 4
$T251943 = -464						; size = 4
$T251939 = -460						; size = 4
$T251935 = -456						; size = 4
$T251918 = -452						; size = 4
$T251909 = -448						; size = 4
$T251905 = -444						; size = 4
$T251896 = -440						; size = 4
$T251888 = -436						; size = 4
$T251879 = -432						; size = 4
$T251875 = -428						; size = 4
$T251871 = -424						; size = 4
$T251867 = -420						; size = 4
$T251863 = -416						; size = 4
$T251859 = -412						; size = 4
$T251695 = -328						; size = 4
$T251686 = -324						; size = 4
$T251677 = -320						; size = 4
$T251654 = -316						; size = 4
$T251645 = -312						; size = 4
$T251641 = -308						; size = 4
$T251632 = -304						; size = 4
$T251624 = -300						; size = 4
$T251615 = -296						; size = 4
$T251611 = -292						; size = 4
$T251582 = -256						; size = 4
$T251573 = -252						; size = 4
$T251569 = -248						; size = 4
$T251560 = -244						; size = 4
$T251556 = -240						; size = 4
$T251547 = -236						; size = 4
$T251527 = -232						; size = 4
$T251523 = -228						; size = 4
$T251519 = -224						; size = 4
$T251503 = -220						; size = 4
$T251493 = -216						; size = 4
$T251489 = -212						; size = 4
$T251474 = -208						; size = 4
$T251473 = -204						; size = 4
_strLogString$227192 = -200				; size = 28
_strLogString$227188 = -172				; size = 28
_strLogString$227185 = -144				; size = 28
_pAdjacentPlot$227177 = -116				; size = 4
_iI$227173 = -112					; size = 4
_iBestTurns$227169 = -108				; size = 4
_pBestTarget$227168 = -104				; size = 4
_iTurns$227170 = -100					; size = 4
_strLogString$227166 = -96				; size = 28
_strLogString$227161 = -68				; size = 28
__$ArrayPad$ = -40					; size = 4
_pTargetCity$227158 = -36				; size = 4
_eGreatWorkType$227157 = -32				; size = 4
_pUnit$227148 = -28					; size = 8
_eDirective$227150 = -20				; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteMusicianMoves, COMDAT
; _this$ = ecx

; 3473 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 500				; 000001f4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3474 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 3475 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN28@ExecuteMus
$LN27@ExecuteMus:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], edx
$LN28@ExecuteMus:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T251489[ebp], eax
	mov	ecx, DWORD PTR $T251489[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T251489[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN29@ExecuteMus

; 3476 : 	{
; 3477 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T251493[ebp], edx
	mov	eax, DWORD PTR $T251493[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T251503[ebp], eax
	mov	edx, DWORD PTR $T251503[ebp]
	mov	DWORD PTR _pUnit$227148[ebp], edx
	mov	BYTE PTR _pUnit$227148[ebp+4], 0
	cmp	DWORD PTR _pUnit$227148[ebp], 0
	je	SHORT $LN46@ExecuteMus
	mov	ecx, DWORD PTR _pUnit$227148[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN46@ExecuteMus:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3478 : 		if(!pUnit)

	xor	eax, eax
	cmp	DWORD PTR _pUnit$227148[ebp], 0
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN25@ExecuteMus

; 3479 : 		{
; 3480 : 			continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227148[ebp], 0
	je	SHORT $LN53@ExecuteMus
	mov	ecx, DWORD PTR _pUnit$227148[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@ExecuteMus:
	jmp	$LN27@ExecuteMus
$LN25@ExecuteMus:

; 3481 : 		}
; 3482 : 
; 3483 : 		GreatPeopleDirectiveTypes eDirective = pUnit->GetGreatPeopleDirective();

	mov	edx, DWORD PTR _pUnit$227148[ebp]
	mov	DWORD PTR $T251519[ebp], edx
	mov	ecx, DWORD PTR $T251519[ebp]
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective
	mov	DWORD PTR _eDirective$227150[ebp], eax

; 3484 : 		switch(eDirective)

	mov	eax, DWORD PTR _eDirective$227150[ebp]
	mov	DWORD PTR tv129[ebp], eax
	cmp	DWORD PTR tv129[ebp], -1
	je	$LN295@ExecuteMus
	cmp	DWORD PTR tv129[ebp], 1
	je	SHORT $LN21@ExecuteMus
	jmp	$LN23@ExecuteMus

; 3485 : 		{
; 3486 : 		case GREAT_PEOPLE_DIRECTIVE_TOURISM_BLAST:
; 3487 : 			break;

	jmp	$LN23@ExecuteMus
$LN21@ExecuteMus:

; 3488 : 
; 3489 : 		case GREAT_PEOPLE_DIRECTIVE_USE_POWER:
; 3490 : 			{
; 3491 : 				// Do we want to create a Great Work?
; 3492 : 				GreatWorkType eGreatWorkType = pUnit->GetGreatWork();

	mov	ecx, DWORD PTR _pUnit$227148[ebp]
	mov	DWORD PTR $T251523[ebp], ecx
	mov	ecx, DWORD PTR $T251523[ebp]
	call	?GetGreatWork@CvUnit@@QBE?AW4GreatWorkType@@XZ ; CvUnit::GetGreatWork
	mov	DWORD PTR _eGreatWorkType$227157[ebp], eax

; 3493 : 				CvCity* pTargetCity = m_pPlayer->GetEconomicAI()->GetBestGreatWorkCity(pUnit->plot(), eGreatWorkType);

	mov	edx, DWORD PTR _pUnit$227148[ebp]
	mov	DWORD PTR $T251527[ebp], edx
	mov	eax, DWORD PTR _eGreatWorkType$227157[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251527[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z ; CvEconomicAI::GetBestGreatWorkCity
	mov	DWORD PTR _pTargetCity$227158[ebp], eax

; 3494 : 
; 3495 : 				// No?  Just move to safety...
; 3496 : 				if (pTargetCity == NULL)

	cmp	DWORD PTR _pTargetCity$227158[ebp], 0
	jne	SHORT $LN73@ExecuteMus

; 3497 : 				{
; 3498 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN69@ExecuteMus
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN69@ExecuteMus

; 3499 : 					{
; 3500 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227161[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3501 : 						strLogString.Format("Great musician can't find a Great Work slot. Running to safety");

	push	OFFSET ??_C@_0DP@LIICEKLM@Great?5musician?5can?8t?5find?5a?5Grea@
	lea	ecx, DWORD PTR _strLogString$227161[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3502 : 						LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227161[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3503 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227161[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3504 : 
; 3505 : 					MoveCivilianToSafety(pUnit.pointer());

$LN69@ExecuteMus:
	push	0
	mov	eax, DWORD PTR _pUnit$227148[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety

; 3506 : 				}
; 3507 : 				else

	jmp	$LN18@ExecuteMus

; 3508 : 				{
; 3509 : 					// Already at (or adjacent to) target?
; 3510 : 					if (plotDistance(pUnit->getX(), pUnit->getY(), pTargetCity->getX(), pTargetCity->getY()) <= 1)

$LN73@ExecuteMus:
	mov	ecx, DWORD PTR _pTargetCity$227158[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T251547[ebp], edx
	mov	eax, DWORD PTR _pTargetCity$227158[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T251556[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227148[ebp]
	mov	DWORD PTR $T251560[ebp], edx
	mov	eax, DWORD PTR $T251560[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T251569[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227148[ebp]
	mov	DWORD PTR $T251573[ebp], edx
	mov	eax, DWORD PTR $T251573[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T251582[ebp], ecx
	mov	edx, DWORD PTR $T251547[ebp]
	push	edx
	mov	eax, DWORD PTR $T251556[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251569[ebp]
	push	ecx
	mov	edx, DWORD PTR $T251582[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jg	$LN17@ExecuteMus

; 3511 : 					{
; 3512 : 						pUnit->PushMission(CvTypes::getMISSION_GREAT_WORK());

	mov	eax, DWORD PTR _pUnit$227148[ebp]
	mov	DWORD PTR $T251611[ebp], eax
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_GREAT_WORK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GREAT_WORK
	push	eax
	mov	ecx, DWORD PTR $T251611[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3513 : 						UnitProcessed(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$227148[ebp]
	mov	DWORD PTR $T251615[ebp], ecx
	mov	edx, DWORD PTR $T251615[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T251624[ebp], eax
	mov	ecx, DWORD PTR $T251624[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3514 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN16@ExecuteMus
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	$LN16@ExecuteMus

; 3515 : 						{
; 3516 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227166[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 3517 : 							strLogString.Format("Creating Great Work at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	ecx, DWORD PTR _pUnit$227148[ebp]
	mov	DWORD PTR $T251632[ebp], ecx
	mov	edx, DWORD PTR $T251632[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T251641[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227148[ebp]
	mov	DWORD PTR $T251645[ebp], ecx
	mov	edx, DWORD PTR $T251645[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T251654[ebp], eax
	mov	ecx, DWORD PTR $T251641[ebp]
	push	ecx
	mov	edx, DWORD PTR $T251654[ebp]
	push	edx
	push	OFFSET ??_C@_0CF@OKBFAJHG@Creating?5Great?5Work?5at?0?5X?3?5?$CFd?0?5Y@
	lea	eax, DWORD PTR _strLogString$227166[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3518 : 							LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227166[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3519 : 							continue;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227166[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227148[ebp], 0
	je	SHORT $LN134@ExecuteMus
	mov	ecx, DWORD PTR _pUnit$227148[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN134@ExecuteMus:
	jmp	$LN27@ExecuteMus
$LN16@ExecuteMus:

; 3520 : 						}
; 3521 : 					}
; 3522 : 
; 3523 : 					// No, then move there
; 3524 : 					else

	jmp	$LN18@ExecuteMus
$LN17@ExecuteMus:

; 3525 : 					{
; 3526 : 						// Find which plot (in or adjacent), we can reach in the fewest turns
; 3527 : 						CvPlot *pBestTarget = NULL;

	mov	DWORD PTR _pBestTarget$227168[ebp], 0

; 3528 : 						int iBestTurns = MAX_INT;

	mov	DWORD PTR _iBestTurns$227169[ebp], 2147483647 ; 7fffffffH

; 3529 : 						int iTurns;
; 3530 : 						iTurns = TurnsToReachTarget(pUnit, pTargetCity->plot());

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _pTargetCity$227158[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	sub	esp, 8
	mov	edx, esp
	mov	DWORD PTR $T251473[ebp], esp
	mov	DWORD PTR $T251677[ebp], edx
	mov	eax, DWORD PTR $T251677[ebp]
	mov	ecx, DWORD PTR _pUnit$227148[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T251677[ebp]
	mov	al, BYTE PTR _pUnit$227148[ebp+4]
	mov	BYTE PTR [edx+4], al
	mov	ecx, DWORD PTR $T251677[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN139@ExecuteMus
	mov	edx, DWORD PTR $T251677[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN139@ExecuteMus:
	mov	eax, DWORD PTR $T251677[ebp]
	mov	DWORD PTR tv433[ebp], eax
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv434[ebp], eax
	mov	ecx, DWORD PTR tv434[ebp]
	mov	DWORD PTR _iTurns$227170[ebp], ecx

; 3531 : 						if (iTurns < iBestTurns)

	mov	edx, DWORD PTR _iTurns$227170[ebp]
	cmp	edx, DWORD PTR _iBestTurns$227169[ebp]
	jge	SHORT $LN14@ExecuteMus

; 3532 : 						{
; 3533 : 							pBestTarget = pTargetCity->plot();

	mov	ecx, DWORD PTR _pTargetCity$227158[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pBestTarget$227168[ebp], eax
$LN14@ExecuteMus:

; 3534 : 						}
; 3535 : 						for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	DWORD PTR _iI$227173[ebp], 0
	jmp	SHORT $LN13@ExecuteMus
$LN12@ExecuteMus:
	mov	eax, DWORD PTR _iI$227173[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$227173[ebp], eax
$LN13@ExecuteMus:
	cmp	DWORD PTR _iI$227173[ebp], 6
	jge	$LN11@ExecuteMus

; 3536 : 						{
; 3537 : 							CvPlot* pAdjacentPlot = plotDirection(pTargetCity->getX(), pTargetCity->getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _pTargetCity$227158[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T251686[ebp], edx
	mov	eax, DWORD PTR _pTargetCity$227158[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T251695[ebp], ecx
	mov	edx, DWORD PTR _iI$227173[ebp]
	push	edx
	mov	eax, DWORD PTR $T251686[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251695[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$227177[ebp], eax

; 3538 : 							if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$227177[ebp], 0
	je	$LN10@ExecuteMus

; 3539 : 							{
; 3540 : 								iTurns = TurnsToReachTarget(pUnit, pAdjacentPlot);

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _pAdjacentPlot$227177[ebp]
	push	edx
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T251474[ebp], esp
	mov	DWORD PTR $T251859[ebp], eax
	mov	ecx, DWORD PTR $T251859[ebp]
	mov	edx, DWORD PTR _pUnit$227148[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T251859[ebp]
	mov	cl, BYTE PTR _pUnit$227148[ebp+4]
	mov	BYTE PTR [eax+4], cl
	mov	edx, DWORD PTR $T251859[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN216@ExecuteMus
	mov	eax, DWORD PTR $T251859[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN216@ExecuteMus:
	mov	ecx, DWORD PTR $T251859[ebp]
	mov	DWORD PTR tv440[ebp], ecx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv441[ebp], eax
	mov	edx, DWORD PTR tv441[ebp]
	mov	DWORD PTR _iTurns$227170[ebp], edx

; 3541 : 								if (iTurns < iBestTurns)

	mov	eax, DWORD PTR _iTurns$227170[ebp]
	cmp	eax, DWORD PTR _iBestTurns$227169[ebp]
	jge	SHORT $LN10@ExecuteMus

; 3542 : 								{
; 3543 : 									pBestTarget = pAdjacentPlot;

	mov	ecx, DWORD PTR _pAdjacentPlot$227177[ebp]
	mov	DWORD PTR _pBestTarget$227168[ebp], ecx

; 3544 : 									iBestTurns = iTurns;

	mov	edx, DWORD PTR _iTurns$227170[ebp]
	mov	DWORD PTR _iBestTurns$227169[ebp], edx
$LN10@ExecuteMus:

; 3545 : 								}
; 3546 : 							}
; 3547 : 						}

	jmp	$LN12@ExecuteMus
$LN11@ExecuteMus:

; 3548 : 
; 3549 : 						if (pBestTarget)

	cmp	DWORD PTR _pBestTarget$227168[ebp], 0
	je	$LN8@ExecuteMus

; 3550 : 						{
; 3551 : 							// In less than one turn?
; 3552 : 							if (iBestTurns == 0)

	cmp	DWORD PTR _iBestTurns$227169[ebp], 0
	jne	$LN7@ExecuteMus

; 3553 : 							{
; 3554 : 								pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestTarget->getX(), pBestTarget->getY());

	mov	eax, DWORD PTR _pBestTarget$227168[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T251863[ebp], ecx
	mov	edx, DWORD PTR _pBestTarget$227168[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T251867[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227148[ebp]
	mov	DWORD PTR $T251871[ebp], ecx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR $T251863[ebp]
	push	edx
	mov	eax, DWORD PTR $T251867[ebp]
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T251871[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3555 : 								pUnit->PushMission(CvTypes::getMISSION_GREAT_WORK());

	mov	ecx, DWORD PTR _pUnit$227148[ebp]
	mov	DWORD PTR $T251875[ebp], ecx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_GREAT_WORK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GREAT_WORK
	push	eax
	mov	ecx, DWORD PTR $T251875[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3556 : 								UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$227148[ebp]
	mov	DWORD PTR $T251879[ebp], edx
	mov	eax, DWORD PTR $T251879[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T251888[ebp], ecx
	mov	edx, DWORD PTR $T251888[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3557 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN6@ExecuteMus
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@ExecuteMus

; 3558 : 								{
; 3559 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227185[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 3560 : 									strLogString.Format("Moving and creating Great Work at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	edx, DWORD PTR _pUnit$227148[ebp]
	mov	DWORD PTR $T251896[ebp], edx
	mov	eax, DWORD PTR $T251896[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T251905[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227148[ebp]
	mov	DWORD PTR $T251909[ebp], edx
	mov	eax, DWORD PTR $T251909[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T251918[ebp], ecx
	mov	edx, DWORD PTR $T251905[ebp]
	push	edx
	mov	eax, DWORD PTR $T251918[ebp]
	push	eax
	push	OFFSET ??_C@_0DA@JBCEOIDB@Moving?5and?5creating?5Great?5Work?5a@
	lea	ecx, DWORD PTR _strLogString$227185[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3561 : 									LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227185[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3562 : 									continue;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227185[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227148[ebp], 0
	je	SHORT $LN253@ExecuteMus
	mov	ecx, DWORD PTR _pUnit$227148[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN253@ExecuteMus:
	jmp	$LN27@ExecuteMus
$LN6@ExecuteMus:

; 3563 : 								}
; 3564 : 							}
; 3565 : 
; 3566 : 							// In multiple moves
; 3567 : 							else

	jmp	$LN5@ExecuteMus
$LN7@ExecuteMus:

; 3568 : 							{
; 3569 : 								pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestTarget->getX(), pBestTarget->getY());

	mov	eax, DWORD PTR _pBestTarget$227168[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T251935[ebp], ecx
	mov	edx, DWORD PTR _pBestTarget$227168[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T251939[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227148[ebp]
	mov	DWORD PTR $T251943[ebp], ecx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR $T251935[ebp]
	push	edx
	mov	eax, DWORD PTR $T251939[ebp]
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T251943[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3570 : 								pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$227148[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3571 : 								UnitProcessed(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T251950[ebp], edx
	mov	eax, DWORD PTR $T251950[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3572 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@ExecuteMus
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@ExecuteMus

; 3573 : 								{
; 3574 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227188[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 3575 : 									strLogString.Format("Moving Great Musician toward Great Work city at, X: %d, Y: %d", pBestTarget->getX(),  pBestTarget->getY());

	mov	eax, DWORD PTR _pBestTarget$227168[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T251958[ebp], ecx
	mov	edx, DWORD PTR $T251958[ebp]
	push	edx
	mov	eax, DWORD PTR _pBestTarget$227168[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0DO@LGPADEGO@Moving?5Great?5Musician?5toward?5Gre@
	lea	edx, DWORD PTR _strLogString$227188[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3576 : 									LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227188[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3577 : 								}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227188[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@ExecuteMus:

; 3578 : 							}
; 3579 : 						}
; 3580 : 						else

	jmp	$LN18@ExecuteMus
$LN8@ExecuteMus:

; 3581 : 						{
; 3582 : 							if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN18@ExecuteMus
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN18@ExecuteMus

; 3583 : 							{
; 3584 : 								CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227192[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 3585 : 								strLogString.Format("Could not find a target for Great Musician at, X: %d, Y: %d", pUnit->getX(),  pUnit->getY());

	mov	eax, DWORD PTR _pUnit$227148[ebp]
	mov	DWORD PTR $T251973[ebp], eax
	mov	ecx, DWORD PTR $T251973[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T251982[ebp], edx
	mov	eax, DWORD PTR _pUnit$227148[ebp]
	mov	DWORD PTR $T251986[ebp], eax
	mov	ecx, DWORD PTR $T251986[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T251995[ebp], edx
	mov	eax, DWORD PTR $T251982[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251995[ebp]
	push	ecx
	push	OFFSET ??_C@_0DM@DPGBEIHH@Could?5not?5find?5a?5target?5for?5Grea@
	lea	edx, DWORD PTR _strLogString$227192[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3586 : 								LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227192[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3587 : 							}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227192[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN18@ExecuteMus:

; 3588 : 						}
; 3589 : 					}
; 3590 : 				}
; 3591 : 			}	
; 3592 : 			break;

	jmp	SHORT $LN23@ExecuteMus

; 3593 : 
; 3594 : 		case NO_GREAT_PEOPLE_DIRECTIVE_TYPE:
; 3595 : 			MoveCivilianToSafety(pUnit.pointer());

$LN295@ExecuteMus:
	push	0
	mov	ecx, DWORD PTR _pUnit$227148[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
$LN23@ExecuteMus:

; 3596 : 			break;
; 3597 : 		}
; 3598 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227148[ebp], 0
	je	SHORT $LN298@ExecuteMus
	mov	ecx, DWORD PTR _pUnit$227148[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN298@ExecuteMus:
	jmp	$LN27@ExecuteMus
$LN29@ExecuteMus:

; 3599 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227148[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$227161[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$227166[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strLogString$227185[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR _strLogString$227188[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _strLogString$227192[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-504]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteMusicianMoves
PUBLIC	??_C@_0DG@NCJHOPCF@Great?5scientist?5discovered?5free?5@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getMISSION_DISCOVER@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_DISCOVER
;	COMDAT ??_C@_0DG@NCJHOPCF@Great?5scientist?5discovered?5free?5@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0DG@NCJHOPCF@Great?5scientist?5discovered?5free?5@ DB 'Great scient'
	DB	'ist discovered free tech at, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ$1
__ehfuncinfo$?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv129 = -112						; size = 4
_this$ = -108						; size = 4
$T252109 = -104						; size = 4
$T252100 = -100						; size = 4
$T252096 = -96						; size = 4
$T252087 = -92						; size = 4
$T252079 = -88						; size = 4
$T252070 = -84						; size = 4
$T252066 = -80						; size = 4
$T252059 = -76						; size = 4
$T252043 = -72						; size = 4
$T252033 = -68						; size = 4
$T252029 = -64						; size = 4
_strLogString$227213 = -60				; size = 28
__$ArrayPad$ = -32					; size = 4
_pUnit$227203 = -28					; size = 8
_eDirective$227205 = -20				; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::ExecuteScientistMoves, COMDAT
; _this$ = ecx

; 3603 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3604 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 3605 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN11@ExecuteSci
$LN10@ExecuteSci:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], edx
$LN11@ExecuteSci:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T252029[ebp], eax
	mov	ecx, DWORD PTR $T252029[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T252029[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN12@ExecuteSci

; 3606 : 	{
; 3607 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T252033[ebp], edx
	mov	eax, DWORD PTR $T252033[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T252043[ebp], eax
	mov	edx, DWORD PTR $T252043[ebp]
	mov	DWORD PTR _pUnit$227203[ebp], edx
	mov	BYTE PTR _pUnit$227203[ebp+4], 0
	cmp	DWORD PTR _pUnit$227203[ebp], 0
	je	SHORT $LN23@ExecuteSci
	mov	ecx, DWORD PTR _pUnit$227203[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN23@ExecuteSci:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3608 : 		if(!pUnit)

	xor	eax, eax
	cmp	DWORD PTR _pUnit$227203[ebp], 0
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@ExecuteSci

; 3609 : 		{
; 3610 : 			continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227203[ebp], 0
	je	SHORT $LN30@ExecuteSci
	mov	ecx, DWORD PTR _pUnit$227203[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN30@ExecuteSci:
	jmp	$LN10@ExecuteSci
$LN8@ExecuteSci:

; 3611 : 		}
; 3612 : 
; 3613 : 		GreatPeopleDirectiveTypes eDirective = pUnit->GetGreatPeopleDirective();

	mov	edx, DWORD PTR _pUnit$227203[ebp]
	mov	DWORD PTR $T252059[ebp], edx
	mov	ecx, DWORD PTR $T252059[ebp]
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective
	mov	DWORD PTR _eDirective$227205[ebp], eax

; 3614 : 		switch(eDirective)

	mov	eax, DWORD PTR _eDirective$227205[ebp]
	mov	DWORD PTR tv129[ebp], eax
	mov	ecx, DWORD PTR tv129[ebp]
	add	ecx, 1
	mov	DWORD PTR tv129[ebp], ecx
	cmp	DWORD PTR tv129[ebp], 3
	ja	$LN6@ExecuteSci
	mov	edx, DWORD PTR tv129[ebp]
	jmp	DWORD PTR $LN74@ExecuteSci[edx*4]

; 3615 : 		{
; 3616 : 		case GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE:
; 3617 : 			ExecuteGoldenAgeMove(pUnit.pointer());

$LN36@ExecuteSci:
	mov	eax, DWORD PTR _pUnit$227203[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteGoldenAgeMove

; 3618 : 			break;

	jmp	$LN6@ExecuteSci
$LN4@ExecuteSci:

; 3619 : 		case GREAT_PEOPLE_DIRECTIVE_USE_POWER:
; 3620 : 			pUnit->PushMission(CvTypes::getMISSION_DISCOVER());

	mov	ecx, DWORD PTR _pUnit$227203[ebp]
	mov	DWORD PTR $T252066[ebp], ecx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_DISCOVER@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_DISCOVER
	push	eax
	mov	ecx, DWORD PTR $T252066[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3621 : 			UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$227203[ebp]
	mov	DWORD PTR $T252070[ebp], edx
	mov	eax, DWORD PTR $T252070[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T252079[ebp], ecx
	mov	edx, DWORD PTR $T252079[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3622 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@ExecuteSci
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@ExecuteSci

; 3623 : 			{
; 3624 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227213[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3625 : 				strLogString.Format("Great scientist discovered free tech at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	edx, DWORD PTR _pUnit$227203[ebp]
	mov	DWORD PTR $T252087[ebp], edx
	mov	eax, DWORD PTR $T252087[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T252096[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227203[ebp]
	mov	DWORD PTR $T252100[ebp], edx
	mov	eax, DWORD PTR $T252100[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T252109[ebp], ecx
	mov	edx, DWORD PTR $T252096[ebp]
	push	edx
	mov	eax, DWORD PTR $T252109[ebp]
	push	eax
	push	OFFSET ??_C@_0DG@NCJHOPCF@Great?5scientist?5discovered?5free?5@
	lea	ecx, DWORD PTR _strLogString$227213[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3626 : 				LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227213[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3627 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227213[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@ExecuteSci:

; 3628 : 			break;

	jmp	SHORT $LN6@ExecuteSci

; 3629 : 		case GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT:
; 3630 : 			ExecuteWorkerMove(pUnit.pointer());

$LN64@ExecuteSci:
	mov	eax, DWORD PTR _pUnit$227203[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteWorkerMove

; 3631 : 			break;

	jmp	SHORT $LN6@ExecuteSci

; 3632 : 		case NO_GREAT_PEOPLE_DIRECTIVE_TYPE:
; 3633 : 			MoveCivilianToSafety(pUnit.pointer());

$LN66@ExecuteSci:
	push	0
	mov	ecx, DWORD PTR _pUnit$227203[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
$LN6@ExecuteSci:

; 3634 : 			break;
; 3635 : 		}
; 3636 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227203[ebp], 0
	je	SHORT $LN69@ExecuteSci
	mov	ecx, DWORD PTR _pUnit$227203[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN69@ExecuteSci:
	jmp	$LN10@ExecuteSci
$LN12@ExecuteSci:

; 3637 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN74@ExecuteSci:
	DD	$LN66@ExecuteSci
	DD	$LN36@ExecuteSci
	DD	$LN4@ExecuteSci
	DD	$LN64@ExecuteSci
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227203[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$227213[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::ExecuteScientistMoves
PUBLIC	??_C@_0DP@LAMCBAAF@Moving?5Great?5Engineer?5for?5free?5w@ ; `string'
PUBLIC	??_C@_0EC@HINDLONB@Great?5Engineer?5not?5needed?5to?5hur@ ; `string'
PUBLIC	??_C@_0DF@PPKDINGF@Great?5Engineer?5hurrying?5free?5won@ ; `string'
PUBLIC	??_C@_0EK@FAPNIIHA@Moving?5Great?5Engineer?5to?5city?5sp@ ; `string'
PUBLIC	??_C@_0FB@EJMDHEAJ@Great?5Engineer?5hurrying?5wonder?5c@ ; `string'
PUBLIC	??_C@_0ED@KFJAFDHP@Great?5builder?5can?8t?5find?5a?5good?5@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?pushOrder@CvCity@@QAEXW4OrderTypes@@HH_N111@Z:PROC ; CvCity::pushOrder
EXTRN	?getMISSION_HURRY@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_HURRY
EXTRN	?getProductionTurnsLeft@CvCity@@QBEHXZ:PROC	; CvCity::getProductionTurnsLeft
EXTRN	?getProductionBuilding@CvCity@@QBE?AW4BuildingTypes@@XZ:PROC ; CvCity::getProductionBuilding
EXTRN	?getProductionNeeded@CvCity@@QBEHW4BuildingTypes@@@Z:PROC ; CvCity::getProductionNeeded
EXTRN	?getProduction@CvCity@@QBEHXZ:PROC		; CvCity::getProduction
EXTRN	?GetWonderBuildCity@CvCitySpecializationAI@@QBEPAVCvCity@@XZ:PROC ; CvCitySpecializationAI::GetWonderBuildCity
EXTRN	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ:PROC ; CvPlayer::GetCitySpecializationAI
EXTRN	?ChooseWonderForGreatEngineer@CvWonderProductionAI@@QAE?AW4BuildingTypes@@_NAAHAAPAVCvCity@@@Z:PROC ; CvWonderProductionAI::ChooseWonderForGreatEngineer
EXTRN	?GetWonderProductionAI@CvPlayer@@QBEPAVCvWonderProductionAI@@XZ:PROC ; CvPlayer::GetWonderProductionAI
;	COMDAT ??_C@_0DP@LAMCBAAF@Moving?5Great?5Engineer?5for?5free?5w@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0DP@LAMCBAAF@Moving?5Great?5Engineer?5for?5free?5w@ DB 'Moving Grea'
	DB	't Engineer for free wonder to city at, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@HINDLONB@Great?5Engineer?5not?5needed?5to?5hur@
CONST	SEGMENT
??_C@_0EC@HINDLONB@Great?5Engineer?5not?5needed?5to?5hur@ DB 'Great Engin'
	DB	'eer not needed to hurry 1-turn wonder at, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PPKDINGF@Great?5Engineer?5hurrying?5free?5won@
CONST	SEGMENT
??_C@_0DF@PPKDINGF@Great?5Engineer?5hurrying?5free?5won@ DB 'Great Engine'
	DB	'er hurrying free wonder at, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@FAPNIIHA@Moving?5Great?5Engineer?5to?5city?5sp@
CONST	SEGMENT
??_C@_0EK@FAPNIIHA@Moving?5Great?5Engineer?5to?5city?5sp@ DB 'Moving Grea'
	DB	't Engineer to city specialization wonder city at, X: %d, Y: %'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@EJMDHEAJ@Great?5Engineer?5hurrying?5wonder?5c@
CONST	SEGMENT
??_C@_0FB@EJMDHEAJ@Great?5Engineer?5hurrying?5wonder?5c@ DB 'Great Engine'
	DB	'er hurrying wonder chosen by city specialization AI at, X: %d'
	DB	', Y: %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@KFJAFDHP@Great?5builder?5can?8t?5find?5a?5good?5@
CONST	SEGMENT
??_C@_0ED@KFJAFDHP@Great?5builder?5can?8t?5find?5a?5good?5@ DB 'Great bui'
	DB	'lder can''t find a good wonder to build. Running to safety', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$3
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$6
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$7
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$8
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv466 = -388						; size = 4
tv465 = -384						; size = 4
tv455 = -380						; size = 4
tv454 = -376						; size = 4
tv129 = -372						; size = 4
_this$ = -368						; size = 4
$T252442 = -364						; size = 4
$T252433 = -360						; size = 4
$T252407 = -356						; size = 4
$T252398 = -352						; size = 4
$T252394 = -348						; size = 4
$T252385 = -344						; size = 4
$T252364 = -340						; size = 4
$T252355 = -336						; size = 4
$T252351 = -332						; size = 4
$T252342 = -328						; size = 4
$T252334 = -324						; size = 4
$T252325 = -320						; size = 4
$T252321 = -316						; size = 4
$T252317 = -312						; size = 4
$T252313 = -308						; size = 4
$T252299 = -304						; size = 4
$T252290 = -300						; size = 4
$T252264 = -296						; size = 4
$T252255 = -292						; size = 4
$T252251 = -288						; size = 4
$T252242 = -284						; size = 4
$T252234 = -280						; size = 4
$T252225 = -276						; size = 4
$T252221 = -272						; size = 4
$T252217 = -268						; size = 4
$T252213 = -264						; size = 4
$T252186 = -260						; size = 4
$T252170 = -256						; size = 4
$T252160 = -252						; size = 4
$T252156 = -248						; size = 4
$T252140 = -244						; size = 4
$T252139 = -240						; size = 4
_strLogString$227277 = -236				; size = 28
_strLogString$227272 = -208				; size = 28
_strLogString$227268 = -180				; size = 28
_strLogString$227260 = -152				; size = 28
_strLogString$227255 = -124				; size = 28
_iTurnsRemaining$227250 = -96				; size = 4
_iProductionSoFar$227247 = -92				; size = 4
_iProductionRemaining$227248 = -88			; size = 4
_bForceWonderCity$227245 = -81				; size = 1
_strLogString$227242 = -80				; size = 28
__$ArrayPad$ = -52					; size = 4
_pCityToBuildAt$227238 = -48				; size = 4
_eNextWonderDesired$227239 = -44			; size = 4
_iNextWonderWeight$227237 = -40				; size = 4
_pUnit$227227 = -36					; size = 8
_eDirective$227229 = -28				; size = 4
_pWonderCity$ = -24					; size = 4
_iTurnsToTarget$ = -20					; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteEngineerMoves, COMDAT
; _this$ = ecx

; 3641 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 376				; 00000178H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3642 : 	CvCity* pWonderCity;
; 3643 : 	int iTurnsToTarget;
; 3644 : 
; 3645 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 3646 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN31@ExecuteEng
$LN30@ExecuteEng:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], edx
$LN31@ExecuteEng:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T252156[ebp], eax
	mov	ecx, DWORD PTR $T252156[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T252156[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN32@ExecuteEng

; 3647 : 	{
; 3648 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T252160[ebp], edx
	mov	eax, DWORD PTR $T252160[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T252170[ebp], eax
	mov	edx, DWORD PTR $T252170[ebp]
	mov	DWORD PTR _pUnit$227227[ebp], edx
	mov	BYTE PTR _pUnit$227227[ebp+4], 0
	cmp	DWORD PTR _pUnit$227227[ebp], 0
	je	SHORT $LN50@ExecuteEng
	mov	ecx, DWORD PTR _pUnit$227227[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN50@ExecuteEng:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3649 : 		if(!pUnit)

	xor	eax, eax
	cmp	DWORD PTR _pUnit$227227[ebp], 0
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN28@ExecuteEng

; 3650 : 		{
; 3651 : 			continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227227[ebp], 0
	je	SHORT $LN57@ExecuteEng
	mov	ecx, DWORD PTR _pUnit$227227[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN57@ExecuteEng:
	jmp	$LN30@ExecuteEng
$LN28@ExecuteEng:

; 3652 : 		}
; 3653 : 
; 3654 : 		GreatPeopleDirectiveTypes eDirective = pUnit->GetGreatPeopleDirective();

	mov	edx, DWORD PTR _pUnit$227227[ebp]
	mov	DWORD PTR $T252186[ebp], edx
	mov	ecx, DWORD PTR $T252186[ebp]
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective
	mov	DWORD PTR _eDirective$227229[ebp], eax

; 3655 : 		switch(eDirective)

	mov	eax, DWORD PTR _eDirective$227229[ebp]
	mov	DWORD PTR tv129[ebp], eax
	mov	ecx, DWORD PTR tv129[ebp]
	add	ecx, 1
	mov	DWORD PTR tv129[ebp], ecx
	cmp	DWORD PTR tv129[ebp], 3
	ja	$LN26@ExecuteEng
	mov	edx, DWORD PTR tv129[ebp]
	jmp	DWORD PTR $LN210@ExecuteEng[edx*4]

; 3656 : 		{
; 3657 : 		case GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT:
; 3658 : 			ExecuteWorkerMove(pUnit.pointer());

$LN63@ExecuteEng:
	mov	eax, DWORD PTR _pUnit$227227[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteWorkerMove

; 3659 : 			break;

	jmp	$LN26@ExecuteEng

; 3660 : 		case GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE:
; 3661 : 			ExecuteGoldenAgeMove(pUnit.pointer());

$LN65@ExecuteEng:
	mov	ecx, DWORD PTR _pUnit$227227[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteGoldenAgeMove

; 3662 : 			break;

	jmp	$LN26@ExecuteEng
$LN23@ExecuteEng:

; 3663 : 		case GREAT_PEOPLE_DIRECTIVE_USE_POWER:
; 3664 : 		{
; 3665 : 			// Do we want to build any wonder?
; 3666 : 			int iNextWonderWeight;
; 3667 : 			CvCity* pCityToBuildAt = 0;

	mov	DWORD PTR _pCityToBuildAt$227238[ebp], 0

; 3668 : 			BuildingTypes eNextWonderDesired = m_pPlayer->GetWonderProductionAI()->ChooseWonderForGreatEngineer(false, iNextWonderWeight, pCityToBuildAt);

	lea	edx, DWORD PTR _pCityToBuildAt$227238[ebp]
	push	edx
	lea	eax, DWORD PTR _iNextWonderWeight$227237[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetWonderProductionAI@CvPlayer@@QBEPAVCvWonderProductionAI@@XZ ; CvPlayer::GetWonderProductionAI
	mov	ecx, eax
	call	?ChooseWonderForGreatEngineer@CvWonderProductionAI@@QAE?AW4BuildingTypes@@_NAAHAAPAVCvCity@@@Z ; CvWonderProductionAI::ChooseWonderForGreatEngineer
	mov	DWORD PTR _eNextWonderDesired$227239[ebp], eax

; 3669 : 
; 3670 : 			// No?  Just move to safety...
; 3671 : 			if(eNextWonderDesired == NO_BUILDING)

	cmp	DWORD PTR _eNextWonderDesired$227239[ebp], -1
	jne	SHORT $LN22@ExecuteEng

; 3672 : 			{
; 3673 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN73@ExecuteEng
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN73@ExecuteEng

; 3674 : 				{
; 3675 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227242[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3676 : 					strLogString.Format("Great builder can't find a good wonder to build. Running to safety");

	push	OFFSET ??_C@_0ED@KFJAFDHP@Great?5builder?5can?8t?5find?5a?5good?5@
	lea	ecx, DWORD PTR _strLogString$227242[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3677 : 					LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227242[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3678 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227242[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3679 : 
; 3680 : 				MoveCivilianToSafety(pUnit.pointer());

$LN73@ExecuteEng:
	push	0
	mov	eax, DWORD PTR _pUnit$227227[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety

; 3681 : 			}
; 3682 : 			else

	jmp	$LN20@ExecuteEng
$LN22@ExecuteEng:

; 3683 : 			{
; 3684 : 				bool bForceWonderCity = true;

	mov	BYTE PTR _bForceWonderCity$227245[ebp], 1

; 3685 : 
; 3686 : 				// Are we less than 25% done building the most desired wonder chosen by the city specialization AI?
; 3687 : 				pWonderCity = m_pPlayer->GetCitySpecializationAI()->GetWonderBuildCity();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ ; CvPlayer::GetCitySpecializationAI
	mov	ecx, eax
	call	?GetWonderBuildCity@CvCitySpecializationAI@@QBEPAVCvCity@@XZ ; CvCitySpecializationAI::GetWonderBuildCity
	mov	DWORD PTR _pWonderCity$[ebp], eax

; 3688 : 				if(pWonderCity)

	cmp	DWORD PTR _pWonderCity$[ebp], 0
	je	$LN19@ExecuteEng

; 3689 : 				{
; 3690 : 					int iProductionSoFar = pWonderCity->getProduction();

	mov	ecx, DWORD PTR _pWonderCity$[ebp]
	call	?getProduction@CvCity@@QBEHXZ		; CvCity::getProduction
	mov	DWORD PTR _iProductionSoFar$227247[ebp], eax

; 3691 : 					int iProductionRemaining = pWonderCity->getProductionNeeded(eNextWonderDesired);

	mov	edx, DWORD PTR _eNextWonderDesired$227239[ebp]
	push	edx
	mov	ecx, DWORD PTR _pWonderCity$[ebp]
	call	?getProductionNeeded@CvCity@@QBEHW4BuildingTypes@@@Z ; CvCity::getProductionNeeded
	mov	DWORD PTR _iProductionRemaining$227248[ebp], eax

; 3692 : 
; 3693 : 					if(pWonderCity->getProductionBuilding() == eNextWonderDesired && iProductionSoFar * 3 < iProductionRemaining)

	mov	ecx, DWORD PTR _pWonderCity$[ebp]
	call	?getProductionBuilding@CvCity@@QBE?AW4BuildingTypes@@XZ ; CvCity::getProductionBuilding
	cmp	eax, DWORD PTR _eNextWonderDesired$227239[ebp]
	jne	$LN19@ExecuteEng
	mov	eax, DWORD PTR _iProductionSoFar$227247[ebp]
	imul	eax, 3
	cmp	eax, DWORD PTR _iProductionRemaining$227248[ebp]
	jge	$LN19@ExecuteEng

; 3694 : 					{
; 3695 : 						// If engineer can move to city before half done
; 3696 : 						int iTurnsRemaining = pWonderCity->getProductionTurnsLeft();

	mov	ecx, DWORD PTR _pWonderCity$[ebp]
	call	?getProductionTurnsLeft@CvCity@@QBEHXZ	; CvCity::getProductionTurnsLeft
	mov	DWORD PTR _iTurnsRemaining$227250[ebp], eax

; 3697 : 						iTurnsToTarget = TurnsToReachTarget(pUnit, pWonderCity->plot(), true /*bReusePaths*/, true);

	push	0
	push	1
	push	1
	mov	ecx, DWORD PTR _pWonderCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T252139[ebp], esp
	mov	DWORD PTR $T252213[ebp], ecx
	mov	edx, DWORD PTR $T252213[ebp]
	mov	eax, DWORD PTR _pUnit$227227[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T252213[ebp]
	mov	dl, BYTE PTR _pUnit$227227[ebp+4]
	mov	BYTE PTR [ecx+4], dl
	mov	eax, DWORD PTR $T252213[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN76@ExecuteEng
	mov	ecx, DWORD PTR $T252213[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN76@ExecuteEng:
	mov	edx, DWORD PTR $T252213[ebp]
	mov	DWORD PTR tv454[ebp], edx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv455[ebp], eax
	mov	eax, DWORD PTR tv455[ebp]
	mov	DWORD PTR _iTurnsToTarget$[ebp], eax

; 3698 : 						if(iTurnsToTarget * 3 < iTurnsRemaining)

	mov	ecx, DWORD PTR _iTurnsToTarget$[ebp]
	imul	ecx, 3
	cmp	ecx, DWORD PTR _iTurnsRemaining$227250[ebp]
	jge	$LN19@ExecuteEng

; 3699 : 						{
; 3700 : 							bForceWonderCity = false;

	mov	BYTE PTR _bForceWonderCity$227245[ebp], 0

; 3701 : 
; 3702 : 							// Already at target and the wonder is underway?
; 3703 : 							if(pWonderCity->getProductionBuilding() == eNextWonderDesired && iTurnsToTarget == 0 && pUnit->plot() == pWonderCity->plot())

	mov	ecx, DWORD PTR _pWonderCity$[ebp]
	call	?getProductionBuilding@CvCity@@QBE?AW4BuildingTypes@@XZ ; CvCity::getProductionBuilding
	cmp	eax, DWORD PTR _eNextWonderDesired$227239[ebp]
	jne	$LN16@ExecuteEng
	cmp	DWORD PTR _iTurnsToTarget$[ebp], 0
	jne	$LN16@ExecuteEng
	mov	edx, DWORD PTR _pUnit$227227[ebp]
	mov	DWORD PTR $T252217[ebp], edx
	mov	ecx, DWORD PTR $T252217[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	esi, eax
	mov	ecx, DWORD PTR _pWonderCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	cmp	esi, eax
	jne	$LN16@ExecuteEng

; 3704 : 							{
; 3705 : 								pUnit->PushMission(CvTypes::getMISSION_HURRY());

	mov	eax, DWORD PTR _pUnit$227227[ebp]
	mov	DWORD PTR $T252221[ebp], eax
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_HURRY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_HURRY
	push	eax
	mov	ecx, DWORD PTR $T252221[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3706 : 								UnitProcessed(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$227227[ebp]
	mov	DWORD PTR $T252225[ebp], ecx
	mov	edx, DWORD PTR $T252225[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T252234[ebp], eax
	mov	ecx, DWORD PTR $T252234[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3707 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN15@ExecuteEng
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	$LN15@ExecuteEng

; 3708 : 								{
; 3709 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227255[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 3710 : 									strLogString.Format("Great Engineer hurrying wonder chosen by city specialization AI at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	ecx, DWORD PTR _pUnit$227227[ebp]
	mov	DWORD PTR $T252242[ebp], ecx
	mov	edx, DWORD PTR $T252242[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T252251[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227227[ebp]
	mov	DWORD PTR $T252255[ebp], ecx
	mov	edx, DWORD PTR $T252255[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T252264[ebp], eax
	mov	ecx, DWORD PTR $T252251[ebp]
	push	ecx
	mov	edx, DWORD PTR $T252264[ebp]
	push	edx
	push	OFFSET ??_C@_0FB@EJMDHEAJ@Great?5Engineer?5hurrying?5wonder?5c@
	lea	eax, DWORD PTR _strLogString$227255[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3711 : 									LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227255[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3712 : 									continue;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227255[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227227[ebp], 0
	je	SHORT $LN109@ExecuteEng
	mov	ecx, DWORD PTR _pUnit$227227[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN109@ExecuteEng:
	jmp	$LN30@ExecuteEng
$LN15@ExecuteEng:

; 3713 : 								}
; 3714 : 							}
; 3715 : 
; 3716 : 							// No, then move there
; 3717 : 							else

	jmp	$LN19@ExecuteEng
$LN16@ExecuteEng:

; 3718 : 							{
; 3719 : 								if(GetBestUnitToReachTarget(pWonderCity->plot(), MAX_INT))

	push	2147483647				; 7fffffffH
	mov	ecx, DWORD PTR _pWonderCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z ; CvHomelandAI::GetBestUnitToReachTarget
	movzx	edx, al
	test	edx, edx
	je	$LN19@ExecuteEng

; 3720 : 								{
; 3721 : 									ExecuteMoveToTarget(pWonderCity->plot());

	mov	ecx, DWORD PTR _pWonderCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget

; 3722 : 
; 3723 : 									if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@ExecuteEng
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN19@ExecuteEng

; 3724 : 									{
; 3725 : 										CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227260[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 3726 : 										strLogString.Format("Moving Great Engineer to city specialization wonder city at, X: %d, Y: %d", pWonderCity->getX(),  pWonderCity->getY());

	mov	edx, DWORD PTR _pWonderCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T252290[ebp], eax
	mov	ecx, DWORD PTR _pWonderCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T252299[ebp], edx
	mov	eax, DWORD PTR $T252290[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252299[ebp]
	push	ecx
	push	OFFSET ??_C@_0EK@FAPNIIHA@Moving?5Great?5Engineer?5to?5city?5sp@
	lea	edx, DWORD PTR _strLogString$227260[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3727 : 										LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227260[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3728 : 									}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227260[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN19@ExecuteEng:

; 3729 : 								}
; 3730 : 							}
; 3731 : 						}
; 3732 : 					}
; 3733 : 				}
; 3734 : 
; 3735 : 				if(bForceWonderCity)

	movzx	ecx, BYTE PTR _bForceWonderCity$227245[ebp]
	test	ecx, ecx
	je	$LN20@ExecuteEng

; 3736 : 				{
; 3737 : 					pWonderCity = pCityToBuildAt;

	mov	edx, DWORD PTR _pCityToBuildAt$227238[ebp]
	mov	DWORD PTR _pWonderCity$[ebp], edx

; 3738 : 
; 3739 : 					if(pWonderCity)

	cmp	DWORD PTR _pWonderCity$[ebp], 0
	je	$LN20@ExecuteEng

; 3740 : 					{
; 3741 : 						iTurnsToTarget = TurnsToReachTarget(pUnit, pWonderCity->plot(), false /*bReusePaths*/, true);

	push	0
	push	1
	push	0
	mov	ecx, DWORD PTR _pWonderCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T252140[ebp], esp
	mov	DWORD PTR $T252313[ebp], eax
	mov	ecx, DWORD PTR $T252313[ebp]
	mov	edx, DWORD PTR _pUnit$227227[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T252313[ebp]
	mov	cl, BYTE PTR _pUnit$227227[ebp+4]
	mov	BYTE PTR [eax+4], cl
	mov	edx, DWORD PTR $T252313[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN128@ExecuteEng
	mov	eax, DWORD PTR $T252313[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN128@ExecuteEng:
	mov	ecx, DWORD PTR $T252313[ebp]
	mov	DWORD PTR tv465[ebp], ecx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv466[ebp], eax
	mov	edx, DWORD PTR tv466[ebp]
	mov	DWORD PTR _iTurnsToTarget$[ebp], edx

; 3742 : 
; 3743 : 						// Already at target?
; 3744 : 						if(iTurnsToTarget == 0 && pUnit->plot() == pWonderCity->plot())

	cmp	DWORD PTR _iTurnsToTarget$[ebp], 0
	jne	$LN9@ExecuteEng
	mov	eax, DWORD PTR _pUnit$227227[ebp]
	mov	DWORD PTR $T252317[ebp], eax
	mov	ecx, DWORD PTR $T252317[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	esi, eax
	mov	ecx, DWORD PTR _pWonderCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	cmp	esi, eax
	jne	$LN9@ExecuteEng

; 3745 : 						{
; 3746 : 							// Switch production
; 3747 : 							pWonderCity->pushOrder(ORDER_CONSTRUCT, eNextWonderDesired, -1, false, false, false);

	push	0
	push	0
	push	0
	push	0
	push	-1
	mov	ecx, DWORD PTR _eNextWonderDesired$227239[ebp]
	push	ecx
	push	1
	mov	ecx, DWORD PTR _pWonderCity$[ebp]
	call	?pushOrder@CvCity@@QAEXW4OrderTypes@@HH_N111@Z ; CvCity::pushOrder

; 3748 : 
; 3749 : 							if (pWonderCity->getProductionTurnsLeft() > 1)

	mov	ecx, DWORD PTR _pWonderCity$[ebp]
	call	?getProductionTurnsLeft@CvCity@@QBEHXZ	; CvCity::getProductionTurnsLeft
	cmp	eax, 1
	jle	$LN8@ExecuteEng

; 3750 : 							{
; 3751 : 								// Rush it
; 3752 : 								pUnit->PushMission(CvTypes::getMISSION_HURRY());

	mov	edx, DWORD PTR _pUnit$227227[ebp]
	mov	DWORD PTR $T252321[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_HURRY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_HURRY
	push	eax
	mov	ecx, DWORD PTR $T252321[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3753 : 								UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR _pUnit$227227[ebp]
	mov	DWORD PTR $T252325[ebp], eax
	mov	ecx, DWORD PTR $T252325[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T252334[ebp], edx
	mov	eax, DWORD PTR $T252334[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3754 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@ExecuteEng
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN7@ExecuteEng

; 3755 : 								{
; 3756 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227268[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 3757 : 									strLogString.Format("Great Engineer hurrying free wonder at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR _pUnit$227227[ebp]
	mov	DWORD PTR $T252342[ebp], eax
	mov	ecx, DWORD PTR $T252342[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T252351[ebp], edx
	mov	eax, DWORD PTR _pUnit$227227[ebp]
	mov	DWORD PTR $T252355[ebp], eax
	mov	ecx, DWORD PTR $T252355[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T252364[ebp], edx
	mov	eax, DWORD PTR $T252351[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252364[ebp]
	push	ecx
	push	OFFSET ??_C@_0DF@PPKDINGF@Great?5Engineer?5hurrying?5free?5won@
	lea	edx, DWORD PTR _strLogString$227268[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3758 : 									LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227268[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3759 : 									continue;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227268[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227227[ebp], 0
	je	SHORT $LN161@ExecuteEng
	mov	ecx, DWORD PTR _pUnit$227227[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN161@ExecuteEng:
	jmp	$LN30@ExecuteEng
$LN7@ExecuteEng:

; 3760 : 								}
; 3761 : 							}
; 3762 : 							else

	jmp	$LN6@ExecuteEng
$LN8@ExecuteEng:

; 3763 : 							{
; 3764 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@ExecuteEng
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN6@ExecuteEng

; 3765 : 								{
; 3766 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227272[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 3767 : 									strLogString.Format("Great Engineer not needed to hurry 1-turn wonder at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR _pUnit$227227[ebp]
	mov	DWORD PTR $T252385[ebp], eax
	mov	ecx, DWORD PTR $T252385[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T252394[ebp], edx
	mov	eax, DWORD PTR _pUnit$227227[ebp]
	mov	DWORD PTR $T252398[ebp], eax
	mov	ecx, DWORD PTR $T252398[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T252407[ebp], edx
	mov	eax, DWORD PTR $T252394[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252407[ebp]
	push	ecx
	push	OFFSET ??_C@_0EC@HINDLONB@Great?5Engineer?5not?5needed?5to?5hur@
	lea	edx, DWORD PTR _strLogString$227272[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3768 : 									LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227272[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3769 : 									continue;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227272[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227227[ebp], 0
	je	SHORT $LN184@ExecuteEng
	mov	ecx, DWORD PTR _pUnit$227227[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN184@ExecuteEng:
	jmp	$LN30@ExecuteEng
$LN6@ExecuteEng:

; 3770 : 								}
; 3771 : 							}
; 3772 : 						}
; 3773 : 
; 3774 : 						// No, then move there
; 3775 : 						else

	jmp	$LN20@ExecuteEng
$LN9@ExecuteEng:

; 3776 : 						{
; 3777 : 							if(GetBestUnitToReachTarget(pWonderCity->plot(), MAX_INT))

	push	2147483647				; 7fffffffH
	mov	ecx, DWORD PTR _pWonderCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z ; CvHomelandAI::GetBestUnitToReachTarget
	movzx	ecx, al
	test	ecx, ecx
	je	$LN20@ExecuteEng

; 3778 : 							{
; 3779 : 								ExecuteMoveToTarget(pWonderCity->plot());

	mov	ecx, DWORD PTR _pWonderCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget

; 3780 : 
; 3781 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN20@ExecuteEng
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN20@ExecuteEng

; 3782 : 								{
; 3783 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227277[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 3784 : 									strLogString.Format("Moving Great Engineer for free wonder to city at, X: %d, Y: %d", pWonderCity->getX(),  pWonderCity->getY());

	mov	ecx, DWORD PTR _pWonderCity$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T252433[ebp], edx
	mov	eax, DWORD PTR _pWonderCity$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T252442[ebp], ecx
	mov	edx, DWORD PTR $T252433[ebp]
	push	edx
	mov	eax, DWORD PTR $T252442[ebp]
	push	eax
	push	OFFSET ??_C@_0DP@LAMCBAAF@Moving?5Great?5Engineer?5for?5free?5w@
	lea	ecx, DWORD PTR _strLogString$227277[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3785 : 									LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227277[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3786 : 								}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227277[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN20@ExecuteEng:

; 3787 : 							}
; 3788 : 						}
; 3789 : 
; 3790 : 					}
; 3791 : 				}
; 3792 : 			}
; 3793 : 		}
; 3794 : 		break;

	jmp	SHORT $LN26@ExecuteEng

; 3795 : 		case NO_GREAT_PEOPLE_DIRECTIVE_TYPE:
; 3796 : 			MoveCivilianToSafety(pUnit.pointer());

$LN202@ExecuteEng:
	push	0
	mov	eax, DWORD PTR _pUnit$227227[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
$LN26@ExecuteEng:

; 3797 : 			break;
; 3798 : 		}
; 3799 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227227[ebp], 0
	je	SHORT $LN205@ExecuteEng
	mov	ecx, DWORD PTR _pUnit$227227[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN205@ExecuteEng:
	jmp	$LN30@ExecuteEng
$LN32@ExecuteEng:

; 3800 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN210@ExecuteEng:
	DD	$LN202@ExecuteEng
	DD	$LN65@ExecuteEng
	DD	$LN23@ExecuteEng
	DD	$LN63@ExecuteEng
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227227[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$227242[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strLogString$227255[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLogString$227260[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR _strLogString$227268[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _strLogString$227272[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$8:
	lea	ecx, DWORD PTR _strLogString$227277[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-384]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteEngineerMoves
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv129 = -52						; size = 4
_this$ = -48						; size = 4
$T252505 = -44						; size = 4
$T252489 = -40						; size = 4
$T252479 = -36						; size = 4
$T252475 = -32						; size = 4
_pUnit$227288 = -28					; size = 8
_eDirective$227290 = -20				; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteMerchantMoves, COMDAT
; _this$ = ecx

; 3803 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3804 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 3805 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN10@ExecuteMer
$LN9@ExecuteMer:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], edx
$LN10@ExecuteMer:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T252475[ebp], eax
	mov	ecx, DWORD PTR $T252475[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T252475[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN11@ExecuteMer

; 3806 : 	{
; 3807 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T252479[ebp], edx
	mov	eax, DWORD PTR $T252479[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T252489[ebp], eax
	mov	edx, DWORD PTR $T252489[ebp]
	mov	DWORD PTR _pUnit$227288[ebp], edx
	mov	BYTE PTR _pUnit$227288[ebp+4], 0
	cmp	DWORD PTR _pUnit$227288[ebp], 0
	je	SHORT $LN21@ExecuteMer
	mov	ecx, DWORD PTR _pUnit$227288[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN21@ExecuteMer:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3808 : 		if(!pUnit)

	xor	eax, eax
	cmp	DWORD PTR _pUnit$227288[ebp], 0
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@ExecuteMer

; 3809 : 		{
; 3810 : 			continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227288[ebp], 0
	je	SHORT $LN28@ExecuteMer
	mov	ecx, DWORD PTR _pUnit$227288[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN28@ExecuteMer:
	jmp	$LN9@ExecuteMer
$LN7@ExecuteMer:

; 3811 : 		}
; 3812 : 
; 3813 : 		GreatPeopleDirectiveTypes eDirective = pUnit->GetGreatPeopleDirective();

	mov	edx, DWORD PTR _pUnit$227288[ebp]
	mov	DWORD PTR $T252505[ebp], edx
	mov	ecx, DWORD PTR $T252505[ebp]
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective
	mov	DWORD PTR _eDirective$227290[ebp], eax

; 3814 : 		switch(eDirective)

	mov	eax, DWORD PTR _eDirective$227290[ebp]
	mov	DWORD PTR tv129[ebp], eax
	cmp	DWORD PTR tv129[ebp], -1
	je	SHORT $LN38@ExecuteMer
	cmp	DWORD PTR tv129[ebp], 0
	je	SHORT $LN34@ExecuteMer
	cmp	DWORD PTR tv129[ebp], 2
	je	SHORT $LN36@ExecuteMer
	jmp	SHORT $LN5@ExecuteMer

; 3815 : 		{
; 3816 : 		case GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE:
; 3817 : 			ExecuteGoldenAgeMove(pUnit.pointer());

$LN34@ExecuteMer:
	mov	ecx, DWORD PTR _pUnit$227288[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteGoldenAgeMove

; 3818 : 			break;

	jmp	SHORT $LN5@ExecuteMer

; 3819 : 		case GREAT_PEOPLE_DIRECTIVE_USE_POWER:
; 3820 : 			// handled by economic AI
; 3821 : 			break;

	jmp	SHORT $LN5@ExecuteMer

; 3822 : 		case GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT:
; 3823 : 			ExecuteWorkerMove(pUnit.pointer());

$LN36@ExecuteMer:
	mov	edx, DWORD PTR _pUnit$227288[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteWorkerMove

; 3824 : 			break;

	jmp	SHORT $LN5@ExecuteMer

; 3825 : 		case NO_GREAT_PEOPLE_DIRECTIVE_TYPE:
; 3826 : 			MoveCivilianToSafety(pUnit.pointer());

$LN38@ExecuteMer:
	push	0
	mov	eax, DWORD PTR _pUnit$227288[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
$LN5@ExecuteMer:

; 3827 : 			break;
; 3828 : 		}
; 3829 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227288[ebp], 0
	je	SHORT $LN41@ExecuteMer
	mov	ecx, DWORD PTR _pUnit$227288[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@ExecuteMer:
	jmp	$LN9@ExecuteMer
$LN11@ExecuteMer:

; 3830 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227288[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteMerchantMoves
PUBLIC	??_C@_0FF@LDCMHMMB@Moving?5to?5plot?5adjacent?5to?5conve@ ; `string'
PUBLIC	??_C@_0CG@EKOOMPMN@Move?5to?5spread?5religion?0?5X?3?5?$CFd?0?5@ ; `string'
PUBLIC	??_C@_0CB@DDJKBPIG@Spreading?5religion?0?5X?3?5?$CFd?0?5Y?3?5?$CFd@ ; `string'
PUBLIC	??_C@_0DA@GLKAHKEO@No?5place?5to?5move?5Great?5Prophet?5a@ ; `string'
PUBLIC	??_C@_0EE@BNIKHBAF@Moving?5Great?5Prophet?5to?5nearest?5@ ; `string'
PUBLIC	??_C@_0DB@FKBCIMBH@Great?5Prophet?5enhancing?5a?5religi@ ; `string'
PUBLIC	??_C@_0DA@CCADKFGO@Great?5Prophet?5founding?5a?5religio@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getMISSION_SPREAD_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_SPREAD_RELIGION
EXTRN	?ChooseProphetTargetPlot@CvReligionAI@@QAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@PAH@Z:PROC ; CvReligionAI::ChooseProphetTargetPlot
EXTRN	?GetReligionAI@CvPlayer@@QBEPAVCvReligionAI@@XZ:PROC ; CvPlayer::GetReligionAI
EXTRN	?getNumUnits@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumUnits
EXTRN	?DoEnhanceReligion@CvUnit@@QAE_NXZ:PROC		; CvUnit::DoEnhanceReligion
EXTRN	?CanEnhanceReligion@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC ; CvUnit::CanEnhanceReligion
EXTRN	?DoFoundReligion@CvUnit@@QAE_NXZ:PROC		; CvUnit::DoFoundReligion
EXTRN	?CanFoundReligion@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC ; CvUnit::CanFoundReligion
;	COMDAT ??_C@_0FF@LDCMHMMB@Moving?5to?5plot?5adjacent?5to?5conve@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0FF@LDCMHMMB@Moving?5to?5plot?5adjacent?5to?5conve@ DB 'Moving to p'
	DB	'lot adjacent to conversion city, X: %d, Y: %d, Currently at, '
	DB	'X: %d, Y: %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@EKOOMPMN@Move?5to?5spread?5religion?0?5X?3?5?$CFd?0?5@
CONST	SEGMENT
??_C@_0CG@EKOOMPMN@Move?5to?5spread?5religion?0?5X?3?5?$CFd?0?5@ DB 'Move'
	DB	' to spread religion, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DDJKBPIG@Spreading?5religion?0?5X?3?5?$CFd?0?5Y?3?5?$CFd@
CONST	SEGMENT
??_C@_0CB@DDJKBPIG@Spreading?5religion?0?5X?3?5?$CFd?0?5Y?3?5?$CFd@ DB 'S'
	DB	'preading religion, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@GLKAHKEO@No?5place?5to?5move?5Great?5Prophet?5a@
CONST	SEGMENT
??_C@_0DA@GLKAHKEO@No?5place?5to?5move?5Great?5Prophet?5a@ DB 'No place t'
	DB	'o move Great Prophet at, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@BNIKHBAF@Moving?5Great?5Prophet?5to?5nearest?5@
CONST	SEGMENT
??_C@_0EE@BNIKHBAF@Moving?5Great?5Prophet?5to?5nearest?5@ DB 'Moving Grea'
	DB	't Prophet to nearest city without civilian, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@FKBCIMBH@Great?5Prophet?5enhancing?5a?5religi@
CONST	SEGMENT
??_C@_0DB@FKBCIMBH@Great?5Prophet?5enhancing?5a?5religi@ DB 'Great Prophe'
	DB	't enhancing a religion, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@CCADKFGO@Great?5Prophet?5founding?5a?5religio@
CONST	SEGMENT
??_C@_0DA@CCADKFGO@Great?5Prophet?5founding?5a?5religio@ DB 'Great Prophe'
	DB	't founding a religion, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$5
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$6
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$7
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$8
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$9
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv515 = -496						; size = 4
tv514 = -492						; size = 4
tv509 = -488						; size = 4
tv508 = -484						; size = 4
tv129 = -480						; size = 4
_this$ = -476						; size = 4
$T252878 = -472						; size = 4
$T252874 = -468						; size = 4
$T252865 = -464						; size = 4
$T252861 = -460						; size = 4
$T252852 = -456						; size = 4
$T252844 = -452						; size = 4
$T252833 = -448						; size = 4
$T252825 = -444						; size = 4
$T252821 = -440						; size = 4
$T252817 = -436						; size = 4
$T252813 = -432						; size = 4
$T252809 = -428						; size = 4
$T252805 = -424						; size = 4
$T252794 = -420						; size = 4
$T252786 = -416						; size = 4
$T252782 = -412						; size = 4
$T252778 = -408						; size = 4
$T252764 = -404						; size = 4
$T252755 = -400						; size = 4
$T252751 = -396						; size = 4
$T252742 = -392						; size = 4
$T252734 = -388						; size = 4
$T252725 = -384						; size = 4
$T252711 = -380						; size = 4
$T252703 = -376						; size = 4
$T252694 = -372						; size = 4
$T252687 = -368						; size = 4
$T252683 = -364						; size = 4
$T252679 = -360						; size = 4
$T252675 = -356						; size = 4
$T252665 = -352						; size = 4
$T252649 = -348						; size = 4
$T252645 = -344						; size = 4
$T252641 = -340						; size = 4
$T252640 = -336						; size = 4
$T252636 = -332						; size = 4
$T252628 = -328						; size = 4
$T252624 = -324						; size = 4
$T252613 = -320						; size = 4
$T252609 = -316						; size = 4
$T252605 = -312						; size = 4
$T252604 = -308						; size = 4
$T252600 = -304						; size = 4
$T252592 = -300						; size = 4
$T252588 = -296						; size = 4
$T252581 = -292						; size = 4
$T252565 = -288						; size = 4
$T252555 = -284						; size = 4
$T252551 = -280						; size = 4
$T252534 = -276						; size = 4
$T252533 = -272						; size = 4
_strLogString$227368 = -268				; size = 28
_strLogString$227363 = -240				; size = 28
_strLogString$227357 = -212				; size = 28
_iTargetTurns$227351 = -184				; size = 4
_pTarget$227352 = -180					; size = 4
_strLogString$227348 = -176				; size = 28
_strLogString$227344 = -148				; size = 28
_iTurns$227339 = -120					; size = 4
_iUnitLoop$227333 = -116				; size = 4
_pTarget$227332 = -112					; size = 4
_bSkipCity$227331 = -105				; size = 1
_iLoopCity$227325 = -104				; size = 4
_iBestTurns$227326 = -100				; size = 4
_pBestCityPlot$227327 = -96				; size = 4
_pLoopCity$227324 = -92					; size = 4
_strLogString$227321 = -88				; size = 28
_strLogString$227317 = -60				; size = 28
__$ArrayPad$ = -32					; size = 4
_pUnit$227307 = -28					; size = 8
_eDirective$227309 = -20				; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteProphetMoves, COMDAT
; _this$ = ecx

; 3833 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 484				; 000001e4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3834 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 3835 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN37@ExecutePro
$LN36@ExecutePro:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], edx
$LN37@ExecutePro:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T252551[ebp], eax
	mov	ecx, DWORD PTR $T252551[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T252551[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN38@ExecutePro

; 3836 : 	{
; 3837 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T252555[ebp], edx
	mov	eax, DWORD PTR $T252555[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T252565[ebp], eax
	mov	edx, DWORD PTR $T252565[ebp]
	mov	DWORD PTR _pUnit$227307[ebp], edx
	mov	BYTE PTR _pUnit$227307[ebp+4], 0
	cmp	DWORD PTR _pUnit$227307[ebp], 0
	je	SHORT $LN57@ExecutePro
	mov	ecx, DWORD PTR _pUnit$227307[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN57@ExecutePro:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3838 : 		if(!pUnit)

	xor	eax, eax
	cmp	DWORD PTR _pUnit$227307[ebp], 0
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN34@ExecutePro

; 3839 : 		{
; 3840 : 			continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227307[ebp], 0
	je	SHORT $LN64@ExecutePro
	mov	ecx, DWORD PTR _pUnit$227307[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN64@ExecutePro:
	jmp	$LN36@ExecutePro
$LN34@ExecutePro:

; 3841 : 		}
; 3842 : 
; 3843 : 		GreatPeopleDirectiveTypes eDirective = pUnit->GetGreatPeopleDirective();

	mov	edx, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252581[ebp], edx
	mov	ecx, DWORD PTR $T252581[ebp]
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective
	mov	DWORD PTR _eDirective$227309[ebp], eax

; 3844 : 		switch(eDirective)

	mov	eax, DWORD PTR _eDirective$227309[ebp]
	mov	DWORD PTR tv129[ebp], eax
	mov	ecx, DWORD PTR tv129[ebp]
	add	ecx, 1
	mov	DWORD PTR tv129[ebp], ecx
	cmp	DWORD PTR tv129[ebp], 4
	ja	$LN32@ExecutePro
	mov	edx, DWORD PTR tv129[ebp]
	jmp	DWORD PTR $LN244@ExecutePro[edx*4]

; 3845 : 		{
; 3846 : 		case GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT:
; 3847 : 			ExecuteWorkerMove(pUnit.pointer());

$LN70@ExecutePro:
	mov	eax, DWORD PTR _pUnit$227307[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteWorkerMove

; 3848 : 			break;

	jmp	$LN32@ExecutePro
$LN30@ExecutePro:

; 3849 : 
; 3850 : 		case GREAT_PEOPLE_DIRECTIVE_USE_POWER:
; 3851 : 
; 3852 : 			// Can I found a religion?
; 3853 : 			if(pUnit->CanFoundReligion(pUnit->plot()))

	mov	ecx, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252588[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252592[ebp], edx
	mov	ecx, DWORD PTR $T252588[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR $T252592[ebp]
	call	?CanFoundReligion@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::CanFoundReligion
	movzx	eax, al
	test	eax, eax
	je	$LN29@ExecutePro

; 3854 : 			{
; 3855 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227317[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3856 : 				strLogString.Format("Great Prophet founding a religion, X: %d, Y: %d", pUnit->plot()->getX(), pUnit->plot()->getY());

	mov	ecx, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252600[ebp], ecx
	mov	ecx, DWORD PTR $T252600[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR $T252604[ebp], eax
	mov	edx, DWORD PTR $T252604[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T252605[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252609[ebp], ecx
	mov	ecx, DWORD PTR $T252609[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR $T252613[ebp], eax
	mov	edx, DWORD PTR $T252605[ebp]
	push	edx
	mov	eax, DWORD PTR $T252613[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0DA@CCADKFGO@Great?5Prophet?5founding?5a?5religio@
	lea	edx, DWORD PTR _strLogString$227317[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3857 : 				LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227317[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3858 : 
; 3859 : 				pUnit->DoFoundReligion();

	mov	ecx, DWORD PTR _pUnit$227307[ebp]
	call	?DoFoundReligion@CvUnit@@QAE_NXZ	; CvUnit::DoFoundReligion

; 3860 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227317[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN28@ExecutePro
$LN29@ExecutePro:

; 3861 : 
; 3862 : 			// Can I enhance a religion?
; 3863 : 			else if(pUnit->CanEnhanceReligion(pUnit->plot()))

	mov	ecx, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252624[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252628[ebp], edx
	mov	ecx, DWORD PTR $T252624[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR $T252628[ebp]
	call	?CanEnhanceReligion@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::CanEnhanceReligion
	movzx	eax, al
	test	eax, eax
	je	$LN27@ExecutePro

; 3864 : 			{
; 3865 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227321[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 3866 : 				strLogString.Format("Great Prophet enhancing a religion, X: %d, Y: %d", pUnit->plot()->getX(), pUnit->plot()->getY());

	mov	ecx, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252636[ebp], ecx
	mov	ecx, DWORD PTR $T252636[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR $T252640[ebp], eax
	mov	edx, DWORD PTR $T252640[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T252641[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252645[ebp], ecx
	mov	ecx, DWORD PTR $T252645[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR $T252649[ebp], eax
	mov	edx, DWORD PTR $T252641[ebp]
	push	edx
	mov	eax, DWORD PTR $T252649[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0DB@FKBCIMBH@Great?5Prophet?5enhancing?5a?5religi@
	lea	edx, DWORD PTR _strLogString$227321[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3867 : 				LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227321[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3868 : 
; 3869 : 				pUnit->DoEnhanceReligion();

	mov	ecx, DWORD PTR _pUnit$227307[ebp]
	call	?DoEnhanceReligion@CvUnit@@QAE_NXZ	; CvUnit::DoEnhanceReligion

; 3870 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227321[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3871 : 
; 3872 : 			// Move to closest city without a civilian in it
; 3873 : 			else

	jmp	$LN28@ExecutePro
$LN27@ExecutePro:

; 3874 : 			{
; 3875 : 				CvCity* pLoopCity;
; 3876 : 				int iLoopCity = 0;

	mov	DWORD PTR _iLoopCity$227325[ebp], 0

; 3877 : 				int iBestTurns = MAX_INT;

	mov	DWORD PTR _iBestTurns$227326[ebp], 2147483647 ; 7fffffffH

; 3878 : 				CvPlot* pBestCityPlot = NULL;

	mov	DWORD PTR _pBestCityPlot$227327[ebp], 0

; 3879 : 				for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	push	0
	lea	ecx, DWORD PTR _iLoopCity$227325[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$227324[ebp], eax
	jmp	SHORT $LN25@ExecutePro
$LN24@ExecutePro:
	push	0
	lea	eax, DWORD PTR _iLoopCity$227325[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$227324[ebp], eax
$LN25@ExecutePro:
	cmp	DWORD PTR _pLoopCity$227324[ebp], 0
	je	$LN23@ExecutePro

; 3880 : 				{
; 3881 : 					bool bSkipCity = false;

	mov	BYTE PTR _bSkipCity$227331[ebp], 0

; 3882 : 
; 3883 : 					CvPlot* pTarget = pLoopCity->plot();

	mov	ecx, DWORD PTR _pLoopCity$227324[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pTarget$227332[ebp], eax

; 3884 : #ifdef AUI_WARNING_FIXES
; 3885 : 					if (!pTarget)
; 3886 : 						continue;
; 3887 : 					for (uint iUnitLoop = 0; iUnitLoop < pTarget->getNumUnits(); iUnitLoop++)
; 3888 : #else
; 3889 : 					for(int iUnitLoop = 0; iUnitLoop < pTarget->getNumUnits(); iUnitLoop++)

	mov	DWORD PTR _iUnitLoop$227333[ebp], 0
	jmp	SHORT $LN22@ExecutePro
$LN21@ExecutePro:
	mov	edx, DWORD PTR _iUnitLoop$227333[ebp]
	add	edx, 1
	mov	DWORD PTR _iUnitLoop$227333[ebp], edx
$LN22@ExecutePro:
	mov	ecx, DWORD PTR _pTarget$227332[ebp]
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	DWORD PTR _iUnitLoop$227333[ebp], eax
	jge	SHORT $LN20@ExecutePro

; 3890 : #endif
; 3891 : 					{
; 3892 : 						// Don't go here if a civilian is already present
; 3893 : 						if(!pTarget->getUnitByIndex(iUnitLoop)->IsCombatUnit())

	mov	eax, DWORD PTR _iUnitLoop$227333[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarget$227332[ebp]
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	DWORD PTR $T252665[ebp], eax
	mov	ecx, DWORD PTR $T252665[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+1044], 0
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN19@ExecutePro

; 3894 : 						{
; 3895 : 							bSkipCity = true;

	mov	BYTE PTR _bSkipCity$227331[ebp], 1

; 3896 : 							break;

	jmp	SHORT $LN20@ExecutePro
$LN19@ExecutePro:

; 3897 : 						}
; 3898 : 					}

	jmp	SHORT $LN21@ExecutePro
$LN20@ExecutePro:

; 3899 : 
; 3900 : 					if(!bSkipCity)

	movzx	ecx, BYTE PTR _bSkipCity$227331[ebp]
	test	ecx, ecx
	jne	$LN18@ExecutePro

; 3901 : 					{
; 3902 : 						int iTurns = TurnsToReachTarget(pUnit, pTarget);

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _pTarget$227332[ebp]
	push	edx
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T252533[ebp], esp
	mov	DWORD PTR $T252675[ebp], eax
	mov	ecx, DWORD PTR $T252675[ebp]
	mov	edx, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T252675[ebp]
	mov	cl, BYTE PTR _pUnit$227307[ebp+4]
	mov	BYTE PTR [eax+4], cl
	mov	edx, DWORD PTR $T252675[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN117@ExecutePro
	mov	eax, DWORD PTR $T252675[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN117@ExecutePro:
	mov	ecx, DWORD PTR $T252675[ebp]
	mov	DWORD PTR tv508[ebp], ecx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv509[ebp], eax
	mov	edx, DWORD PTR tv509[ebp]
	mov	DWORD PTR _iTurns$227339[ebp], edx

; 3903 : 						if(iTurns < iBestTurns)

	mov	eax, DWORD PTR _iTurns$227339[ebp]
	cmp	eax, DWORD PTR _iBestTurns$227326[ebp]
	jge	SHORT $LN18@ExecutePro

; 3904 : 						{
; 3905 : 							iBestTurns = iTurns;

	mov	ecx, DWORD PTR _iTurns$227339[ebp]
	mov	DWORD PTR _iBestTurns$227326[ebp], ecx

; 3906 : 							pBestCityPlot = pTarget;

	mov	edx, DWORD PTR _pTarget$227332[ebp]
	mov	DWORD PTR _pBestCityPlot$227327[ebp], edx
$LN18@ExecutePro:

; 3907 : 						}
; 3908 : 					}
; 3909 : 				}

	jmp	$LN24@ExecutePro
$LN23@ExecutePro:

; 3910 : 
; 3911 : 				if(pBestCityPlot)

	cmp	DWORD PTR _pBestCityPlot$227327[ebp], 0
	je	$LN145@ExecutePro

; 3912 : 				{
; 3913 : 					pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestCityPlot->getX(), pBestCityPlot->getY());

	mov	eax, DWORD PTR _pBestCityPlot$227327[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T252679[ebp], ecx
	mov	edx, DWORD PTR _pBestCityPlot$227327[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T252683[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252687[ebp], ecx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR $T252679[ebp]
	push	edx
	mov	eax, DWORD PTR $T252683[ebp]
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T252687[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3914 : 					pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$227307[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3915 : 					UnitProcessed(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252694[ebp], ecx
	mov	edx, DWORD PTR $T252694[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T252703[ebp], eax
	mov	ecx, DWORD PTR $T252703[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3916 : 
; 3917 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN15@ExecutePro
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@ExecutePro

; 3918 : 					{
; 3919 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227344[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 3920 : 						strLogString.Format("Moving Great Prophet to nearest city without civilian, X: %d, Y: %d", pBestCityPlot->getX(), pBestCityPlot->getY());

	mov	ecx, DWORD PTR _pBestCityPlot$227327[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T252711[ebp], edx
	mov	eax, DWORD PTR $T252711[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBestCityPlot$227327[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0EE@BNIKHBAF@Moving?5Great?5Prophet?5to?5nearest?5@
	lea	eax, DWORD PTR _strLogString$227344[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3921 : 						LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227344[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3922 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227344[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN15@ExecutePro:

; 3923 : 				}
; 3924 : 				else

	jmp	$LN28@ExecutePro

; 3925 : 				{
; 3926 : 					pUnit->finishMoves();

$LN145@ExecutePro:
	mov	ecx, DWORD PTR _pUnit$227307[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3927 : 					UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252725[ebp], edx
	mov	eax, DWORD PTR $T252725[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T252734[ebp], ecx
	mov	edx, DWORD PTR $T252734[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3928 : 
; 3929 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN28@ExecutePro
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN28@ExecutePro

; 3930 : 					{
; 3931 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227348[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 3932 : 						strLogString.Format("No place to move Great Prophet at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	edx, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252742[ebp], edx
	mov	eax, DWORD PTR $T252742[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T252751[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252755[ebp], edx
	mov	eax, DWORD PTR $T252755[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T252764[ebp], ecx
	mov	edx, DWORD PTR $T252751[ebp]
	push	edx
	mov	eax, DWORD PTR $T252764[ebp]
	push	eax
	push	OFFSET ??_C@_0DA@GLKAHKEO@No?5place?5to?5move?5Great?5Prophet?5a@
	lea	ecx, DWORD PTR _strLogString$227348[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3933 : 						LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227348[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3934 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227348[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN28@ExecutePro:

; 3935 : 				}
; 3936 : 			}
; 3937 : 
; 3938 : 			break;

	jmp	$LN32@ExecutePro
$LN12@ExecutePro:

; 3939 : 
; 3940 : 		case GREAT_PEOPLE_DIRECTIVE_SPREAD_RELIGION:
; 3941 : 			{
; 3942 : 				int iTargetTurns;
; 3943 : 				CvPlot* pTarget = m_pPlayer->GetReligionAI()->ChooseProphetTargetPlot(pUnit, &iTargetTurns);

	lea	eax, DWORD PTR _iTargetTurns$227351[ebp]
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T252534[ebp], esp
	mov	DWORD PTR $T252778[ebp], ecx
	mov	edx, DWORD PTR $T252778[ebp]
	mov	eax, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T252778[ebp]
	mov	dl, BYTE PTR _pUnit$227307[ebp+4]
	mov	BYTE PTR [ecx+4], dl
	mov	eax, DWORD PTR $T252778[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN172@ExecutePro
	mov	ecx, DWORD PTR $T252778[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN172@ExecutePro:
	mov	edx, DWORD PTR $T252778[ebp]
	mov	DWORD PTR tv514[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetReligionAI@CvPlayer@@QBEPAVCvReligionAI@@XZ ; CvPlayer::GetReligionAI
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, eax
	call	?ChooseProphetTargetPlot@CvReligionAI@@QAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@PAH@Z ; CvReligionAI::ChooseProphetTargetPlot
	mov	DWORD PTR tv515[ebp], eax
	mov	ecx, DWORD PTR tv515[ebp]
	mov	DWORD PTR _pTarget$227352[ebp], ecx

; 3944 : 				if(pTarget)

	cmp	DWORD PTR _pTarget$227352[ebp], 0
	je	$LN11@ExecutePro

; 3945 : 				{
; 3946 : 					if(pUnit->plot() == pTarget)

	mov	edx, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252782[ebp], edx
	mov	ecx, DWORD PTR $T252782[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pTarget$227352[ebp]
	jne	$LN10@ExecutePro

; 3947 : 					{
; 3948 : 						pUnit->PushMission(CvTypes::getMISSION_SPREAD_RELIGION());

	mov	eax, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252786[ebp], eax
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SPREAD_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SPREAD_RELIGION
	push	eax
	mov	ecx, DWORD PTR $T252786[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3949 : 
; 3950 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@ExecutePro
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN9@ExecutePro

; 3951 : 						{
; 3952 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227357[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 3953 : 							strLogString.Format("Spreading religion, X: %d, Y: %d", pTarget->getX(), pTarget->getY());

	mov	eax, DWORD PTR _pTarget$227352[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T252794[ebp], ecx
	mov	edx, DWORD PTR $T252794[ebp]
	push	edx
	mov	eax, DWORD PTR _pTarget$227352[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0CB@DDJKBPIG@Spreading?5religion?0?5X?3?5?$CFd?0?5Y?3?5?$CFd@
	lea	edx, DWORD PTR _strLogString$227357[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3954 : 							LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227357[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3955 : 						}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227357[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN9@ExecutePro:

; 3956 : 					}

	jmp	$LN11@ExecutePro
$LN10@ExecutePro:

; 3957 : 					else if(iTargetTurns < 1)

	cmp	DWORD PTR _iTargetTurns$227351[ebp], 1
	jge	$LN7@ExecutePro

; 3958 : 					{
; 3959 : 						pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());

	mov	ecx, DWORD PTR _pTarget$227352[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T252805[ebp], edx
	mov	eax, DWORD PTR _pTarget$227352[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T252809[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252813[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR $T252805[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252809[ebp]
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T252813[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3960 : 
; 3961 : 						if(pUnit->plot() == pTarget && pUnit->canMove())

	mov	edx, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252817[ebp], edx
	mov	ecx, DWORD PTR $T252817[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pTarget$227352[ebp]
	jne	$LN4@ExecutePro
	mov	eax, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252821[ebp], eax
	mov	ecx, DWORD PTR $T252821[ebp]
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@ExecutePro

; 3962 : 						{
; 3963 : 							pUnit->PushMission(CvTypes::getMISSION_SPREAD_RELIGION());

	mov	edx, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252825[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SPREAD_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SPREAD_RELIGION
	push	eax
	mov	ecx, DWORD PTR $T252825[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3964 : 
; 3965 : 							if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@ExecutePro
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@ExecutePro

; 3966 : 							{
; 3967 : 								CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227363[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 3968 : 								strLogString.Format("Move to spread religion, X: %d, Y: %d", pTarget->getX(), pTarget->getY());

	mov	edx, DWORD PTR _pTarget$227352[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T252833[ebp], eax
	mov	ecx, DWORD PTR $T252833[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTarget$227352[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_0CG@EKOOMPMN@Move?5to?5spread?5religion?0?5X?3?5?$CFd?0?5@
	lea	ecx, DWORD PTR _strLogString$227363[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3969 : 								LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227363[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3970 : 							}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227363[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@ExecutePro:

; 3971 : 						}
; 3972 : 						else
; 3973 : 						{
; 3974 : 							CvAssertMsg(false, "Internal error with Prophet spread religion AI move, contact Ed.");
; 3975 : 						}
; 3976 : 					}
; 3977 : 					else

	jmp	$LN11@ExecutePro
$LN7@ExecutePro:

; 3978 : 					{
; 3979 : 						
; 3980 : 						m_CurrentBestMoveHighPriorityUnit = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2404], 0

; 3981 : 						m_CurrentBestMoveUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T252844[ebp], edx
	mov	eax, DWORD PTR $T252844[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2396], eax

; 3982 : 						ExecuteMoveToTarget(pTarget);

	mov	eax, DWORD PTR _pTarget$227352[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget

; 3983 : 
; 3984 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN11@ExecutePro
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN11@ExecutePro

; 3985 : 						{
; 3986 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227368[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 3987 : 							strLogString.Format("Moving to plot adjacent to conversion city, X: %d, Y: %d, Currently at, X: %d, Y: %d", pTarget->getX(), pTarget->getY(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252852[ebp], eax
	mov	ecx, DWORD PTR $T252852[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T252861[ebp], edx
	mov	eax, DWORD PTR _pUnit$227307[ebp]
	mov	DWORD PTR $T252865[ebp], eax
	mov	ecx, DWORD PTR $T252865[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T252874[ebp], edx
	mov	eax, DWORD PTR _pTarget$227352[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T252878[ebp], ecx
	mov	edx, DWORD PTR $T252861[ebp]
	push	edx
	mov	eax, DWORD PTR $T252874[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252878[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTarget$227352[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_0FF@LDCMHMMB@Moving?5to?5plot?5adjacent?5to?5conve@
	lea	ecx, DWORD PTR _strLogString$227368[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 3988 : 							LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227368[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3989 : 						}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227368[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN11@ExecutePro:

; 3990 : 					}
; 3991 : 				}
; 3992 : 			}
; 3993 : 			break;

	jmp	SHORT $LN32@ExecutePro

; 3994 : 
; 3995 : 		case NO_GREAT_PEOPLE_DIRECTIVE_TYPE:
; 3996 : 			MoveCivilianToSafety(pUnit.pointer());

$LN236@ExecutePro:
	push	0
	mov	eax, DWORD PTR _pUnit$227307[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
$LN32@ExecutePro:

; 3997 : 			break;
; 3998 : 		}
; 3999 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227307[ebp], 0
	je	SHORT $LN239@ExecutePro
	mov	ecx, DWORD PTR _pUnit$227307[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN239@ExecutePro:
	jmp	$LN36@ExecutePro
$LN38@ExecutePro:

; 4000 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN244@ExecutePro:
	DD	$LN236@ExecutePro
	DD	$LN32@ExecutePro
	DD	$LN30@ExecutePro
	DD	$LN70@ExecutePro
	DD	$LN12@ExecutePro
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227307[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$227317[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$227321[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLogString$227344[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strLogString$227348[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$6:
	mov	ecx, DWORD PTR $T252534[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _strLogString$227357[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$8:
	lea	ecx, DWORD PTR _strLogString$227363[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$9:
	lea	ecx, DWORD PTR _strLogString$227368[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-488]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteProphetMoves
PUBLIC	??_C@_0DA@BEEFGJKG@No?5place?5to?5move?5Great?5General?5a@ ; `string'
PUBLIC	??_C@_0DE@EOKCAJKD@Moving?5Great?5General?5to?5city?5gar@ ; `string'
PUBLIC	??_C@_0DJ@BICCHHAL@Great?5General?5remaining?5as?5garri@ ; `string'
PUBLIC	??_C@_0DO@COBKCAKA@Great?5general?5moving?5to?5culture?5@ ; `string'
PUBLIC	??_C@_0DI@DALKKNEG@Great?5General?5culture?5bombed?1cit@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?FindBestArtistTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@AAH@Z:PROC ; CvPlayerAI::FindBestArtistTargetPlot
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
EXTRN	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligion
EXTRN	?GetReligionCreatedByPlayer@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligionCreatedByPlayer
EXTRN	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ:PROC ; CvGame::GetGameReligions
EXTRN	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z:PROC ; CvTeam::getProjectCount
;	COMDAT ??_C@_0DA@BEEFGJKG@No?5place?5to?5move?5Great?5General?5a@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0DA@BEEFGJKG@No?5place?5to?5move?5Great?5General?5a@ DB 'No place t'
	DB	'o move Great General at, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@EOKCAJKD@Moving?5Great?5General?5to?5city?5gar@
CONST	SEGMENT
??_C@_0DE@EOKCAJKD@Moving?5Great?5General?5to?5city?5gar@ DB 'Moving Grea'
	DB	't General to city garrison, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@BICCHHAL@Great?5General?5remaining?5as?5garri@
CONST	SEGMENT
??_C@_0DJ@BICCHHAL@Great?5General?5remaining?5as?5garri@ DB 'Great Genera'
	DB	'l remaining as garrison for %s, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@COBKCAKA@Great?5general?5moving?5to?5culture?5@
CONST	SEGMENT
??_C@_0DO@COBKCAKA@Great?5general?5moving?5to?5culture?5@ DB 'Great gener'
	DB	'al moving to culture bomb/citadel at, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@DALKKNEG@Great?5General?5culture?5bombed?1cit@
CONST	SEGMENT
??_C@_0DI@DALKKNEG@Great?5General?5culture?5bombed?1cit@ DB 'Great Genera'
	DB	'l culture bombed/citadel''d at, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$6
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv561 = -580						; size = 4
tv560 = -576						; size = 4
tv748 = -572						; size = 4
tv602 = -568						; size = 4
_this$ = -564						; size = 4
$T253387 = -560						; size = 4
$T253378 = -556						; size = 4
$T253374 = -552						; size = 4
$T253365 = -548						; size = 4
$T253350 = -544						; size = 4
$T253342 = -540						; size = 4
$T253333 = -536						; size = 4
$T253326 = -532						; size = 4
$T253322 = -528						; size = 4
$T253318 = -524						; size = 4
$T253314 = -520						; size = 4
$T253296 = -516						; size = 4
$T253287 = -508						; size = 4
$T253283 = -504						; size = 4
$T253274 = -500						; size = 4
$T253270 = -496						; size = 4
$T253261 = -492						; size = 4
$T253253 = -488						; size = 4
$T253244 = -484						; size = 4
$T253232 = -476						; size = 4
$T253228 = -472						; size = 4
$T253212 = -468						; size = 4
$T253195 = -464						; size = 4
$T253186 = -460						; size = 4
$T253182 = -456						; size = 4
$T253173 = -452						; size = 4
$T253165 = -448						; size = 4
$T253156 = -444						; size = 4
$T253149 = -440						; size = 4
$T253145 = -436						; size = 4
$T253141 = -432						; size = 4
$T253133 = -428						; size = 4
$T253124 = -424						; size = 4
$T253120 = -420						; size = 4
$T253111 = -416						; size = 4
$T253103 = -412						; size = 4
$T253099 = -408						; size = 4
$T253095 = -404						; size = 4
$T253091 = -400						; size = 4
$T253087 = -396						; size = 4
$T253083 = -392						; size = 4
$T253074 = -388						; size = 4
$T253070 = -384						; size = 4
$T253054 = -380						; size = 4
$T253044 = -376						; size = 4
$T253040 = -372						; size = 4
$T253033 = -368						; size = 4
$T253024 = -364						; size = 4
$T253010 = -356						; size = 4
$T253009 = -352						; size = 4
$T252984 = -348						; size = 4
$T252979 = -344						; size = 4
$T252975 = -337						; size = 1
$T252971 = -336						; size = 4
$T252967 = -329						; size = 1
_iMapY$253008 = -328					; size = 4
_iMapX$253007 = -324					; size = 4
$T252960 = -320						; size = 4
$T252956 = -316						; size = 4
$T252947 = -312						; size = 4
$T252938 = -308						; size = 4
$T252934 = -304						; size = 4
$T252930 = -300						; size = 4
$T252929 = -296						; size = 4
$T252909 = -292						; size = 4
$T252908 = -288						; size = 28
_strLogString$227455 = -260				; size = 28
_strLogString$227451 = -232				; size = 28
_iTurns$227446 = -204					; size = 4
_iUnitLoop$227438 = -200				; size = 4
_pTarget$227437 = -196					; size = 4
_bSkipCity$227436 = -189				; size = 1
_iLoopCity$227428 = -188				; size = 4
_iBestTurns$227429 = -184				; size = 4
_pBestCityPlot$227430 = -180				; size = 4
_pLoopCity$227427 = -176				; size = 4
_strLogString$227423 = -172				; size = 28
_strLogString$227415 = -144				; size = 28
_strLogString$227411 = -116				; size = 28
__$ArrayPad$ = -88					; size = 4
_pkBuild$227406 = -84					; size = 4
_eSelectedBuildType$227399 = -80			; size = 4
_eBuild$227400 = -76					; size = 4
_iBuildIndex$227401 = -72				; size = 4
_pTargetPlot$227396 = -68				; size = 4
_iValue$227395 = -64					; size = 4
_pUnit$227392 = -60					; size = 8
_pUnitPlot$227418 = -52					; size = 4
_eMyReligion$ = -48					; size = 4
_pHolyCityPlot$ = -44					; size = 4
_bHaveApolloInCapital$ = -37				; size = 1
_pHolyCity$ = -36					; size = 4
_pReligions$ = -32					; size = 4
_eApolloProgram$ = -28					; size = 4
_bKeepHolyCityClear$ = -21				; size = 1
_pMyReligion$ = -20					; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteGeneralMoves, COMDAT
; _this$ = ecx

; 4004 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 568				; 00000238H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4005 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 4006 : 	CvPlot* pHolyCityPlot = NULL;

	mov	DWORD PTR _pHolyCityPlot$[ebp], 0

; 4007 : 	CvCity* pHolyCity = NULL;

	mov	DWORD PTR _pHolyCity$[ebp], 0

; 4008 : 
; 4009 : 	// Do we have an Apollo program to stay clear of?
; 4010 : 	bool bHaveApolloInCapital = false;

	mov	BYTE PTR _bHaveApolloInCapital$[ebp], 0

; 4011 : 	ProjectTypes eApolloProgram = (ProjectTypes) GC.getSPACE_RACE_TRIGGER_PROJECT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8424
	mov	DWORD PTR _eApolloProgram$[ebp], eax

; 4012 : 	if(eApolloProgram != NO_PROJECT)

	cmp	DWORD PTR _eApolloProgram$[ebp], -1
	je	SHORT $LN43@ExecuteGen

; 4013 : 	{
; 4014 : 		if(GET_TEAM(m_pPlayer->getTeam()).getProjectCount(eApolloProgram) > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T252929[ebp], edx
	mov	eax, DWORD PTR $T252929[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T252930[ebp], eax
	mov	edx, DWORD PTR $T252930[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T252934[ebp], edx
	mov	eax, DWORD PTR _eApolloProgram$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252934[ebp]
	call	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectCount
	test	eax, eax
	jle	SHORT $LN43@ExecuteGen

; 4015 : 		{
; 4016 : 			bHaveApolloInCapital = true;

	mov	BYTE PTR _bHaveApolloInCapital$[ebp], 1
$LN43@ExecuteGen:

; 4017 : 		}
; 4018 : 	}
; 4019 : 
; 4020 : 	// Do we have a holy city to stay clear of?
; 4021 : 	bool bKeepHolyCityClear = false;

	mov	BYTE PTR _bKeepHolyCityClear$[ebp], 0

; 4022 : 	CvGameReligions* pReligions = GC.getGame().GetGameReligions();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T252938[ebp], ecx
	mov	ecx, DWORD PTR $T252938[ebp]
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	DWORD PTR _pReligions$[ebp], eax

; 4023 : 	ReligionTypes eMyReligion = pReligions->GetReligionCreatedByPlayer(m_pPlayer->GetID());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T252947[ebp], ecx
	mov	edx, DWORD PTR $T252947[ebp]
	push	edx
	mov	ecx, DWORD PTR _pReligions$[ebp]
	call	?GetReligionCreatedByPlayer@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligionCreatedByPlayer
	mov	DWORD PTR _eMyReligion$[ebp], eax

; 4024 : 	const CvReligion* pMyReligion = pReligions->GetReligion(eMyReligion, m_pPlayer->GetID());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T252956[ebp], edx
	mov	eax, DWORD PTR $T252956[ebp]
	push	eax
	mov	ecx, DWORD PTR _eMyReligion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pReligions$[ebp]
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion
	mov	DWORD PTR _pMyReligion$[ebp], eax

; 4025 : 	if(pMyReligion)

	cmp	DWORD PTR _pMyReligion$[ebp], 0
	je	$LN41@ExecuteGen

; 4026 : 	{
; 4027 : 		pHolyCityPlot = GC.getMap().plot(pMyReligion->m_iHolyCityX, pMyReligion->m_iHolyCityY);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T252960[ebp], edx
	mov	eax, DWORD PTR _pMyReligion$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T253010[ebp], ecx
	mov	edx, DWORD PTR _pMyReligion$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T253009[ebp], eax
	cmp	DWORD PTR $T253009[ebp], -2147483647	; 80000001H
	je	SHORT $LN74@ExecuteGen
	cmp	DWORD PTR $T253010[ebp], -2147483647	; 80000001H
	jne	SHORT $LN75@ExecuteGen
$LN74@ExecuteGen:
	mov	DWORD PTR _pHolyCityPlot$[ebp], 0
	jmp	$LN76@ExecuteGen
$LN75@ExecuteGen:
	mov	ecx, DWORD PTR $T252960[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T252967[ebp], dl
	mov	eax, DWORD PTR $T252960[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T252971[ebp], ecx
	movzx	edx, BYTE PTR $T252967[ebp]
	push	edx
	mov	eax, DWORD PTR $T252971[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253009[ebp]
	push	ecx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapX$253007[ebp], eax
	mov	edx, DWORD PTR $T252960[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T252975[ebp], al
	mov	ecx, DWORD PTR $T252960[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T252979[ebp], edx
	movzx	eax, BYTE PTR $T252975[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252979[ebp]
	push	ecx
	mov	edx, DWORD PTR $T253010[ebp]
	push	edx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$253008[ebp], eax
	mov	eax, DWORD PTR _iMapY$253008[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$253007[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T252960[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN78@ExecuteGen
	mov	edx, DWORD PTR $T252960[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T252984[ebp], eax
	mov	ecx, DWORD PTR _iMapY$253008[ebp]
	imul	ecx, DWORD PTR $T252984[ebp]
	add	ecx, DWORD PTR _iMapX$253007[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T252960[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv602[ebp], ecx
	jmp	SHORT $LN79@ExecuteGen
$LN78@ExecuteGen:
	mov	DWORD PTR tv602[ebp], 0
$LN79@ExecuteGen:
	mov	eax, DWORD PTR tv602[ebp]
	mov	DWORD PTR _pHolyCityPlot$[ebp], eax
$LN76@ExecuteGen:

; 4028 : 		pHolyCity = pHolyCityPlot->getPlotCity();

	mov	ecx, DWORD PTR _pHolyCityPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pHolyCity$[ebp], eax

; 4029 : 		if(pHolyCity && (pHolyCity->getOwner() == m_pPlayer->GetID()))

	cmp	DWORD PTR _pHolyCity$[ebp], 0
	je	SHORT $LN41@ExecuteGen
	mov	ecx, DWORD PTR _pHolyCity$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T253024[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T253033[ebp], edx
	mov	eax, DWORD PTR $T253024[ebp]
	cmp	eax, DWORD PTR $T253033[ebp]
	jne	SHORT $LN41@ExecuteGen

; 4030 : 		{
; 4031 : 			bKeepHolyCityClear = true;

	mov	BYTE PTR _bKeepHolyCityClear$[ebp], 1
$LN41@ExecuteGen:

; 4032 : 		}
; 4033 : 	}
; 4034 : 
; 4035 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _it$[ebp], edx
	jmp	SHORT $LN39@ExecuteGen
$LN38@ExecuteGen:
	mov	eax, DWORD PTR _it$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], eax
$LN39@ExecuteGen:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T253040[ebp], ecx
	mov	edx, DWORD PTR $T253040[ebp]
	mov	eax, DWORD PTR [edx+4]
	shl	eax, 4
	mov	ecx, DWORD PTR $T253040[ebp]
	add	eax, DWORD PTR [ecx]
	cmp	DWORD PTR _it$[ebp], eax
	je	$LN44@ExecuteGen

; 4036 : 	{
; 4037 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	edx, DWORD PTR _it$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T253044[ebp], eax
	mov	ecx, DWORD PTR $T253044[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T253054[ebp], eax
	mov	eax, DWORD PTR $T253054[ebp]
	mov	DWORD PTR _pUnit$227392[ebp], eax
	mov	BYTE PTR _pUnit$227392[ebp+4], 0
	cmp	DWORD PTR _pUnit$227392[ebp], 0
	je	SHORT $LN112@ExecuteGen
	mov	ecx, DWORD PTR _pUnit$227392[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN112@ExecuteGen:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4038 : 		if(!pUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$227392[ebp], 0
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN36@ExecuteGen

; 4039 : 		{
; 4040 : 			continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227392[ebp], 0
	je	SHORT $LN119@ExecuteGen
	mov	ecx, DWORD PTR _pUnit$227392[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN119@ExecuteGen:
	jmp	$LN38@ExecuteGen
$LN36@ExecuteGen:

; 4041 : 		}
; 4042 : 
; 4043 : 		// this is for the citadel/culture bomb
; 4044 : 		if (pUnit->GetGreatPeopleDirective() == GREAT_PEOPLE_DIRECTIVE_USE_POWER)

	mov	eax, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253070[ebp], eax
	mov	ecx, DWORD PTR $T253070[ebp]
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective
	cmp	eax, 1
	jne	$LN35@ExecuteGen

; 4045 : 		{
; 4046 : 			int iValue = 0;

	mov	DWORD PTR _iValue$227395[ebp], 0

; 4047 : 			CvPlot* pTargetPlot = GET_PLAYER(m_pPlayer->GetID()).FindBestArtistTargetPlot(pUnit.pointer(), iValue);

	mov	ecx, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253074[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T253083[ebp], ecx
	mov	edx, DWORD PTR $T253083[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T253087[ebp], edx
	lea	eax, DWORD PTR _iValue$227395[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253074[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T253087[ebp]
	call	?FindBestArtistTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@AAH@Z ; CvPlayerAI::FindBestArtistTargetPlot
	mov	DWORD PTR _pTargetPlot$227396[ebp], eax

; 4048 : 			if(pTargetPlot)

	cmp	DWORD PTR _pTargetPlot$227396[ebp], 0
	je	$LN35@ExecuteGen

; 4049 : 			{
; 4050 : 				if(pUnit->plot() == pTargetPlot)

	mov	edx, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253091[ebp], edx
	mov	ecx, DWORD PTR $T253091[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pTargetPlot$227396[ebp]
	jne	$LN33@ExecuteGen

; 4051 : 				{
; 4052 : 					// find the great general improvement
; 4053 : 					BuildTypes eSelectedBuildType = NO_BUILD;

	mov	DWORD PTR _eSelectedBuildType$227399[ebp], -1

; 4054 : 					BuildTypes eBuild;
; 4055 : #ifdef AUI_WARNING_FIXES
; 4056 : 					for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 4057 : #else
; 4058 : 					int iBuildIndex;
; 4059 : 					for(iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	DWORD PTR _iBuildIndex$227401[ebp], 0
	jmp	SHORT $LN32@ExecuteGen
$LN31@ExecuteGen:
	mov	eax, DWORD PTR _iBuildIndex$227401[ebp]
	add	eax, 1
	mov	DWORD PTR _iBuildIndex$227401[ebp], eax
$LN32@ExecuteGen:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _iBuildIndex$227401[ebp], eax
	jge	SHORT $LN30@ExecuteGen

; 4060 : #endif
; 4061 : 					{
; 4062 : 						eBuild = (BuildTypes)iBuildIndex;

	mov	ecx, DWORD PTR _iBuildIndex$227401[ebp]
	mov	DWORD PTR _eBuild$227400[ebp], ecx

; 4063 : 						CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);

	mov	edx, DWORD PTR _eBuild$227400[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuild$227406[ebp], eax

; 4064 : 						if(pkBuild == NULL)

	cmp	DWORD PTR _pkBuild$227406[ebp], 0
	jne	SHORT $LN29@ExecuteGen

; 4065 : 							continue;

	jmp	SHORT $LN31@ExecuteGen
$LN29@ExecuteGen:

; 4066 : 						
; 4067 : 						if(!pUnit->canBuild(pTargetPlot, eBuild))

	mov	eax, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253095[ebp], eax
	push	1
	push	0
	mov	ecx, DWORD PTR _eBuild$227400[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTargetPlot$227396[ebp]
	push	edx
	mov	ecx, DWORD PTR $T253095[ebp]
	call	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z ; CvUnit::canBuild
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN28@ExecuteGen

; 4068 : 						{
; 4069 : 							continue;

	jmp	SHORT $LN31@ExecuteGen
$LN28@ExecuteGen:

; 4070 : 						}
; 4071 : 	
; 4072 : 						eSelectedBuildType = eBuild;

	mov	ecx, DWORD PTR _eBuild$227400[ebp]
	mov	DWORD PTR _eSelectedBuildType$227399[ebp], ecx

; 4073 : 						break;

	jmp	SHORT $LN30@ExecuteGen

; 4074 : 					}

	jmp	SHORT $LN31@ExecuteGen
$LN30@ExecuteGen:

; 4075 : 
; 4076 : 					CvAssertMsg(eSelectedBuildType != NO_BUILD, "Great General trying to build something it doesn't qualify for");
; 4077 : 					if (eSelectedBuildType != NO_BUILD)

	cmp	DWORD PTR _eSelectedBuildType$227399[ebp], -1
	je	$LN27@ExecuteGen

; 4078 : 					{
; 4079 : 						pUnit->PushMission(CvTypes::getMISSION_BUILD(), eSelectedBuildType, -1, 0, (pUnit->GetLengthMissionQueue() > 0), false, MISSIONAI_BUILD, pTargetPlot);

	mov	edx, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253099[ebp], edx
	mov	eax, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253103[ebp], eax
	push	0
	mov	ecx, DWORD PTR _pTargetPlot$227396[ebp]
	push	ecx
	push	18					; 00000012H
	push	0
	mov	ecx, DWORD PTR $T253099[ebp]
	call	?GetLengthMissionQueue@CvUnit@@QBEHXZ	; CvUnit::GetLengthMissionQueue
	test	eax, eax
	setg	dl
	movzx	eax, dl
	push	eax
	push	0
	push	-1
	mov	ecx, DWORD PTR _eSelectedBuildType$227399[ebp]
	push	ecx
	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	push	eax
	mov	ecx, DWORD PTR $T253103[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4080 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN27@ExecuteGen
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN27@ExecuteGen

; 4081 : 						{
; 4082 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227411[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 4083 : 							strLogString.Format("Great General culture bombed/citadel'd at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	ecx, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253111[ebp], ecx
	mov	edx, DWORD PTR $T253111[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T253120[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253124[ebp], ecx
	mov	edx, DWORD PTR $T253124[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T253133[ebp], eax
	mov	ecx, DWORD PTR $T253120[ebp]
	push	ecx
	mov	edx, DWORD PTR $T253133[ebp]
	push	edx
	push	OFFSET ??_C@_0DI@DALKKNEG@Great?5General?5culture?5bombed?1cit@
	lea	eax, DWORD PTR _strLogString$227411[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4084 : 							LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227411[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4085 : 						}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227411[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN27@ExecuteGen:

; 4086 : 					}
; 4087 : 				}
; 4088 : 				else

	jmp	$LN25@ExecuteGen
$LN33@ExecuteGen:

; 4089 : 				{
; 4090 : 					pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTargetPlot->getX(), pTargetPlot->getY());

	mov	edx, DWORD PTR _pTargetPlot$227396[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T253141[ebp], eax
	mov	ecx, DWORD PTR _pTargetPlot$227396[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T253145[ebp], edx
	mov	eax, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253149[ebp], eax
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR $T253141[ebp]
	push	ecx
	mov	edx, DWORD PTR $T253145[ebp]
	push	edx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T253149[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4091 : 					pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$227392[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4092 : 					UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253156[ebp], eax
	mov	ecx, DWORD PTR $T253156[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T253165[ebp], edx
	mov	eax, DWORD PTR $T253165[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 4093 : 
; 4094 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN25@ExecuteGen
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN25@ExecuteGen

; 4095 : 					{
; 4096 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227415[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 4097 : 						strLogString.Format("Great general moving to culture bomb/citadel at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253173[ebp], eax
	mov	ecx, DWORD PTR $T253173[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T253182[ebp], edx
	mov	eax, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253186[ebp], eax
	mov	ecx, DWORD PTR $T253186[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T253195[ebp], edx
	mov	eax, DWORD PTR $T253182[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253195[ebp]
	push	ecx
	push	OFFSET ??_C@_0DO@COBKCAKA@Great?5general?5moving?5to?5culture?5@
	lea	edx, DWORD PTR _strLogString$227415[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4098 : 						LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227415[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4099 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227415[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN25@ExecuteGen:

; 4100 : 				}
; 4101 : 				continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227392[ebp], 0
	je	SHORT $LN192@ExecuteGen
	mov	ecx, DWORD PTR _pUnit$227392[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN192@ExecuteGen:
	jmp	$LN38@ExecuteGen
$LN35@ExecuteGen:

; 4102 : 			}
; 4103 : 		}
; 4104 : 
; 4105 : 
; 4106 : 		if(pUnit->GetGreatPeopleDirective() == GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE)

	mov	ecx, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253212[ebp], ecx
	mov	ecx, DWORD PTR $T253212[ebp]
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective
	test	eax, eax
	jne	SHORT $LN23@ExecuteGen

; 4107 : 		{
; 4108 : 			ExecuteGoldenAgeMove(pUnit.pointer());

	mov	edx, DWORD PTR _pUnit$227392[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteGoldenAgeMove

; 4109 : 			continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227392[ebp], 0
	je	SHORT $LN201@ExecuteGen
	mov	ecx, DWORD PTR _pUnit$227392[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN201@ExecuteGen:
	jmp	$LN38@ExecuteGen
$LN23@ExecuteGen:

; 4110 : 		}
; 4111 : 
; 4112 : 		// if we already built the Apollo Program we don't want the general in the capital because it'll block spaceship parts
; 4113 : 
; 4114 : 		// Already in a friendly city?
; 4115 : 		CvPlot* pUnitPlot =  pUnit->plot();

	mov	eax, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253228[ebp], eax
	mov	ecx, DWORD PTR $T253228[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pUnitPlot$227418[ebp], eax

; 4116 : 		if(pUnitPlot->isFriendlyCity(*pUnit, false) && (!bHaveApolloInCapital || !pUnitPlot->getPlotCity()->isCapital()) && (!bKeepHolyCityClear || pUnitPlot != pHolyCityPlot))

	mov	ecx, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253232[ebp], ecx
	push	0
	mov	edx, DWORD PTR $T253232[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnitPlot$227418[ebp]
	call	?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z ; CvPlot::isFriendlyCity
	movzx	eax, al
	test	eax, eax
	je	$LN22@ExecuteGen
	movzx	ecx, BYTE PTR _bHaveApolloInCapital$[ebp]
	test	ecx, ecx
	je	SHORT $LN21@ExecuteGen
	mov	ecx, DWORD PTR _pUnitPlot$227418[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	ecx, eax
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	edx, al
	test	edx, edx
	jne	$LN22@ExecuteGen
$LN21@ExecuteGen:
	movzx	eax, BYTE PTR _bKeepHolyCityClear$[ebp]
	test	eax, eax
	je	SHORT $LN214@ExecuteGen
	mov	ecx, DWORD PTR _pUnitPlot$227418[ebp]
	cmp	ecx, DWORD PTR _pHolyCityPlot$[ebp]
	je	$LN22@ExecuteGen

; 4117 : 		{
; 4118 : 			pUnit->finishMoves();

$LN214@ExecuteGen:
	mov	ecx, DWORD PTR _pUnit$227392[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4119 : 			UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253244[ebp], edx
	mov	eax, DWORD PTR $T253244[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T253253[ebp], ecx
	mov	edx, DWORD PTR $T253253[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 4120 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN19@ExecuteGen
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN19@ExecuteGen

; 4121 : 			{
; 4122 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227423[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 4123 : 				strLogString.Format("Great General remaining as garrison for %s, X: %d, Y: %d", pUnit->plot()->getPlotCity()->getName().GetCString(), pUnit->getX(), pUnit->getY());

	mov	edx, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253287[ebp], edx
	lea	eax, DWORD PTR $T252908[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253287[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	ecx, eax
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv748[ebp], eax
	mov	ecx, DWORD PTR tv748[ebp]
	mov	DWORD PTR $T253296[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	edx, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253261[ebp], edx
	mov	eax, DWORD PTR $T253261[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T253270[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253274[ebp], edx
	mov	eax, DWORD PTR $T253274[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T253283[ebp], ecx
	mov	edx, DWORD PTR $T253270[ebp]
	push	edx
	mov	eax, DWORD PTR $T253283[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253296[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0DJ@BICCHHAL@Great?5General?5remaining?5as?5garri@
	lea	ecx, DWORD PTR _strLogString$227423[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T252908[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4124 : 				LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227423[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4125 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227423[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN19@ExecuteGen:

; 4126 : 		}
; 4127 : 
; 4128 : 		else

	jmp	$LN18@ExecuteGen
$LN22@ExecuteGen:

; 4129 : 		{
; 4130 : 			CvCity* pLoopCity;
; 4131 : 			int iLoopCity = 0;

	mov	DWORD PTR _iLoopCity$227428[ebp], 0

; 4132 : 			int iBestTurns = MAX_INT;

	mov	DWORD PTR _iBestTurns$227429[ebp], 2147483647 ; 7fffffffH

; 4133 : 			CvPlot* pBestCityPlot = NULL;

	mov	DWORD PTR _pBestCityPlot$227430[ebp], 0

; 4134 : 			for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	push	0
	lea	eax, DWORD PTR _iLoopCity$227428[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$227427[ebp], eax
	jmp	SHORT $LN17@ExecuteGen
$LN16@ExecuteGen:
	push	0
	lea	edx, DWORD PTR _iLoopCity$227428[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$227427[ebp], eax
$LN17@ExecuteGen:
	cmp	DWORD PTR _pLoopCity$227427[ebp], 0
	je	$LN15@ExecuteGen

; 4135 : 			{
; 4136 : 				if(bHaveApolloInCapital && pLoopCity->isCapital())

	movzx	ecx, BYTE PTR _bHaveApolloInCapital$[ebp]
	test	ecx, ecx
	je	SHORT $LN14@ExecuteGen
	mov	ecx, DWORD PTR _pLoopCity$227427[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN14@ExecuteGen

; 4137 : 				{
; 4138 : 					continue;

	jmp	SHORT $LN16@ExecuteGen
$LN14@ExecuteGen:

; 4139 : 				}
; 4140 : 
; 4141 : 				if(bKeepHolyCityClear && pLoopCity == pHolyCity)

	movzx	eax, BYTE PTR _bKeepHolyCityClear$[ebp]
	test	eax, eax
	je	SHORT $LN13@ExecuteGen
	mov	ecx, DWORD PTR _pLoopCity$227427[ebp]
	cmp	ecx, DWORD PTR _pHolyCity$[ebp]
	jne	SHORT $LN13@ExecuteGen

; 4142 : 				{
; 4143 : 					continue;

	jmp	SHORT $LN16@ExecuteGen
$LN13@ExecuteGen:

; 4144 : 				}
; 4145 : 
; 4146 : 				bool bSkipCity = false;

	mov	BYTE PTR _bSkipCity$227436[ebp], 0

; 4147 : 
; 4148 : 				CvPlot* pTarget = pLoopCity->plot();

	mov	ecx, DWORD PTR _pLoopCity$227427[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pTarget$227437[ebp], eax

; 4149 : #ifdef AUI_WARNING_FIXES
; 4150 : 				if (!pTarget)
; 4151 : 					continue;
; 4152 : 				for (uint iUnitLoop = 0; iUnitLoop < pTarget->getNumUnits(); iUnitLoop++)
; 4153 : #else
; 4154 : 				for(int iUnitLoop = 0; iUnitLoop < pTarget->getNumUnits(); iUnitLoop++)

	mov	DWORD PTR _iUnitLoop$227438[ebp], 0
	jmp	SHORT $LN12@ExecuteGen
$LN11@ExecuteGen:
	mov	edx, DWORD PTR _iUnitLoop$227438[ebp]
	add	edx, 1
	mov	DWORD PTR _iUnitLoop$227438[ebp], edx
$LN12@ExecuteGen:
	mov	ecx, DWORD PTR _pTarget$227437[ebp]
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	DWORD PTR _iUnitLoop$227438[ebp], eax
	jge	SHORT $LN10@ExecuteGen

; 4155 : #endif
; 4156 : 				{
; 4157 : 					// Don't go here if a general or admiral is already present
; 4158 : 					if(pTarget->getUnitByIndex(iUnitLoop)->AI_getUnitAIType() == UNITAI_GENERAL)

	mov	eax, DWORD PTR _iUnitLoop$227438[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarget$227437[ebp]
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	ecx, eax
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN9@ExecuteGen

; 4159 : 					{
; 4160 : 						bSkipCity = true;

	mov	BYTE PTR _bSkipCity$227436[ebp], 1
	jmp	SHORT $LN10@ExecuteGen

; 4161 : 						break;

	jmp	SHORT $LN8@ExecuteGen
$LN9@ExecuteGen:

; 4162 : 					}
; 4163 : 					else if(pTarget->getUnitByIndex(iUnitLoop)->AI_getUnitAIType() == UNITAI_ADMIRAL)

	mov	ecx, DWORD PTR _iUnitLoop$227438[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTarget$227437[ebp]
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	ecx, eax
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN8@ExecuteGen

; 4164 : 					{
; 4165 : 						bSkipCity = true;

	mov	BYTE PTR _bSkipCity$227436[ebp], 1

; 4166 : 						break;

	jmp	SHORT $LN10@ExecuteGen
$LN8@ExecuteGen:

; 4167 : 					}
; 4168 : 				}

	jmp	SHORT $LN11@ExecuteGen
$LN10@ExecuteGen:

; 4169 : 
; 4170 : 				if(!bSkipCity)

	movzx	edx, BYTE PTR _bSkipCity$227436[ebp]
	test	edx, edx
	jne	$LN6@ExecuteGen

; 4171 : 				{
; 4172 : 					int iTurns = TurnsToReachTarget(pUnit, pTarget);

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _pTarget$227437[ebp]
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T252909[ebp], esp
	mov	DWORD PTR $T253314[ebp], ecx
	mov	edx, DWORD PTR $T253314[ebp]
	mov	eax, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T253314[ebp]
	mov	dl, BYTE PTR _pUnit$227392[ebp+4]
	mov	BYTE PTR [ecx+4], dl
	mov	eax, DWORD PTR $T253314[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN253@ExecuteGen
	mov	ecx, DWORD PTR $T253314[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN253@ExecuteGen:
	mov	edx, DWORD PTR $T253314[ebp]
	mov	DWORD PTR tv560[ebp], edx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv561[ebp], eax
	mov	eax, DWORD PTR tv561[ebp]
	mov	DWORD PTR _iTurns$227446[ebp], eax

; 4173 : 					if(iTurns < iBestTurns)

	mov	ecx, DWORD PTR _iTurns$227446[ebp]
	cmp	ecx, DWORD PTR _iBestTurns$227429[ebp]
	jge	SHORT $LN6@ExecuteGen

; 4174 : 					{
; 4175 : 						iBestTurns = iTurns;

	mov	edx, DWORD PTR _iTurns$227446[ebp]
	mov	DWORD PTR _iBestTurns$227429[ebp], edx

; 4176 : 						pBestCityPlot = pTarget;

	mov	eax, DWORD PTR _pTarget$227437[ebp]
	mov	DWORD PTR _pBestCityPlot$227430[ebp], eax
$LN6@ExecuteGen:

; 4177 : 					}
; 4178 : 				}
; 4179 : 			}

	jmp	$LN16@ExecuteGen
$LN15@ExecuteGen:

; 4180 : 
; 4181 : 			if(pBestCityPlot)

	cmp	DWORD PTR _pBestCityPlot$227430[ebp], 0
	je	$LN4@ExecuteGen

; 4182 : 			{
; 4183 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestCityPlot->getX(), pBestCityPlot->getY());

	mov	ecx, DWORD PTR _pBestCityPlot$227430[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T253318[ebp], edx
	mov	eax, DWORD PTR _pBestCityPlot$227430[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T253322[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253326[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR $T253318[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253322[ebp]
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T253326[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4184 : 				pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$227392[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4185 : 				UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253333[ebp], edx
	mov	eax, DWORD PTR $T253333[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T253342[ebp], ecx
	mov	edx, DWORD PTR $T253342[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 4186 : 
; 4187 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@ExecuteGen
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@ExecuteGen

; 4188 : 				{
; 4189 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227451[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 4190 : 					strLogString.Format("Moving Great General to city garrison, X: %d, Y: %d", pBestCityPlot->getX(), pBestCityPlot->getY());

	mov	edx, DWORD PTR _pBestCityPlot$227430[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T253350[ebp], eax
	mov	ecx, DWORD PTR $T253350[ebp]
	push	ecx
	mov	edx, DWORD PTR _pBestCityPlot$227430[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_0DE@EOKCAJKD@Moving?5Great?5General?5to?5city?5gar@
	lea	ecx, DWORD PTR _strLogString$227451[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4191 : 					LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227451[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4192 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227451[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@ExecuteGen:

; 4193 : 			}
; 4194 : 			else

	jmp	$LN18@ExecuteGen
$LN4@ExecuteGen:

; 4195 : 			{
; 4196 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN18@ExecuteGen
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN18@ExecuteGen

; 4197 : 				{
; 4198 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227455[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 4199 : 					strLogString.Format("No place to move Great General at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	edx, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253365[ebp], edx
	mov	eax, DWORD PTR $T253365[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T253374[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227392[ebp]
	mov	DWORD PTR $T253378[ebp], edx
	mov	eax, DWORD PTR $T253378[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T253387[ebp], ecx
	mov	edx, DWORD PTR $T253374[ebp]
	push	edx
	mov	eax, DWORD PTR $T253387[ebp]
	push	eax
	push	OFFSET ??_C@_0DA@BEEFGJKG@No?5place?5to?5move?5Great?5General?5a@
	lea	ecx, DWORD PTR _strLogString$227455[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4200 : 					LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227455[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4201 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227455[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN18@ExecuteGen:

; 4202 : 			}
; 4203 : 		}
; 4204 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227392[ebp], 0
	je	SHORT $LN300@ExecuteGen
	mov	ecx, DWORD PTR _pUnit$227392[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN300@ExecuteGen:
	jmp	$LN38@ExecuteGen
$LN44@ExecuteGen:

; 4205 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227392[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$227411[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$227415[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strLogString$227423[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR $T252908[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR _strLogString$227451[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _strLogString$227455[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-572]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteGeneralMoves
PUBLIC	??1?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@XZ ; CvWeightedVector<CvCity *,64,1>::~CvWeightedVector<CvCity *,64,1>
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>
PUBLIC	??_C@_0DA@GNLMOMBK@No?5place?5to?5move?5Great?5Admiral?5a@ ; `string'
PUBLIC	??_C@_0DK@OPCEPNHH@Moving?5Great?5Admiral?5normally?5to@ ; `string'
PUBLIC	??_C@_0DH@COGMIFKF@Transferring?5Great?5Admiral?5to?5ci@ ; `string'
PUBLIC	??_C@_0DN@FEGEKJNA@Great?5Admiral?5still?5in?5most?5favo@ ; `string'
PUBLIC	?SortItems@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAEXXZ ; CvWeightedVector<CvCity *,64,1>::SortItems
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@Z ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::push_back
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>
PUBLIC	__$ArrayPad$
EXTRN	?getMISSION_CHANGE_ADMIRAL_PORT@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_CHANGE_ADMIRAL_PORT
EXTRN	?getDamage@CvCity@@QBEHXZ:PROC			; CvCity::getDamage
EXTRN	?GetSizeLargestAdjacentWater@CvPlot@@QBEHXZ:PROC ; CvPlot::GetSizeLargestAdjacentWater
EXTRN	?isCoastal@CvCity@@QBE_NH@Z:PROC		; CvCity::isCoastal
;	COMDAT ??_C@_0DA@GNLMOMBK@No?5place?5to?5move?5Great?5Admiral?5a@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0DA@GNLMOMBK@No?5place?5to?5move?5Great?5Admiral?5a@ DB 'No place t'
	DB	'o move Great Admiral at, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@OPCEPNHH@Moving?5Great?5Admiral?5normally?5to@
CONST	SEGMENT
??_C@_0DK@OPCEPNHH@Moving?5Great?5Admiral?5normally?5to@ DB 'Moving Great'
	DB	' Admiral normally to city of %s, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@COGMIFKF@Transferring?5Great?5Admiral?5to?5ci@
CONST	SEGMENT
??_C@_0DH@COGMIFKF@Transferring?5Great?5Admiral?5to?5ci@ DB 'Transferring'
	DB	' Great Admiral to city of %s, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@FEGEKJNA@Great?5Admiral?5still?5in?5most?5favo@
CONST	SEGMENT
??_C@_0DN@FEGEKJNA@Great?5Admiral?5still?5in?5most?5favo@ DB 'Great Admir'
	DB	'al still in most favored city of %s, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$3
	DD	02H
	DD	FLAT:__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$4
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$5
	DD	04H
	DD	FLAT:__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$6
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$7
	DD	06H
	DD	FLAT:__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$8
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$9
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv708 = -1156						; size = 4
tv741 = -1152						; size = 4
tv803 = -1148						; size = 4
tv505 = -1144						; size = 4
tv504 = -1140						; size = 4
tv201 = -1136						; size = 4
tv586 = -1132						; size = 4
_this$ = -1128						; size = 4
$T253961 = -1112					; size = 4
$T253952 = -1108					; size = 4
$T253948 = -1104					; size = 4
$T253939 = -1100					; size = 4
$T253931 = -1096					; size = 4
$T253922 = -1092					; size = 4
$T253907 = -1088					; size = 4
$T253903 = -1084					; size = 4
$T253894 = -1080					; size = 4
$T253881 = -1076					; size = 4
$T253872 = -1072					; size = 4
$T253865 = -1068					; size = 4
$T253861 = -1064					; size = 4
$T253852 = -1060					; size = 4
$T253835 = -1056					; size = 4
$T253831 = -1052					; size = 4
$T253822 = -1048					; size = 4
$T253809 = -1044					; size = 4
$T253800 = -1040					; size = 4
$T253793 = -1036					; size = 4
$T253789 = -1032					; size = 4
$T253780 = -1028					; size = 4
$T253763 = -1024					; size = 4
$T253759 = -1020					; size = 4
$T253750 = -1016					; size = 4
$T253737 = -1012					; size = 4
$T253728 = -1008					; size = 4
$T253721 = -1004					; size = 4
$T253705 = -1000					; size = 4
_weightedElem$253685 = -988				; size = 8
$T253679 = -980						; size = 4
$T253669 = -976						; size = 4
$T253660 = -972						; size = 4
$T253656 = -968						; size = 4
$T253647 = -964						; size = 4
$T253638 = -960						; size = 4
$T253634 = -956						; size = 4
$T253621 = -952						; size = 4
$T253612 = -948						; size = 4
$T253608 = -944						; size = 4
$T253607 = -940						; size = 4
$T253603 = -936						; size = 4
$T253594 = -928						; size = 4
$T253578 = -924						; size = 4
$T253562 = -920						; size = 4
$T253552 = -916						; size = 4
$T253548 = -912						; size = 4
$T253541 = -908						; size = 4
$T253532 = -904						; size = 4
$T253518 = -896						; size = 4
$T253517 = -892						; size = 4
$T253492 = -888						; size = 4
$T253487 = -884						; size = 4
$T253483 = -877						; size = 1
$T253479 = -876						; size = 4
$T253475 = -869						; size = 1
_iMapY$253516 = -868					; size = 4
_iMapX$253515 = -864					; size = 4
$T253468 = -860						; size = 4
$T253464 = -856						; size = 4
$T253455 = -852						; size = 4
$T253446 = -848						; size = 4
$T253442 = -844						; size = 4
$T253438 = -840						; size = 4
$T253437 = -836						; size = 4
$T253415 = -832						; size = 28
$T253414 = -804						; size = 28
$T253413 = -776						; size = 28
$T253412 = -748						; size = 4
_strLogString$227744 = -744				; size = 28
_strLogString$227739 = -716				; size = 28
_strLogString$227734 = -688				; size = 28
_strLogString$227728 = -660				; size = 28
_pChosenCity$227725 = -632				; size = 4
_pLoopUnit$227712 = -628				; size = 4
_iUnitLoop$227708 = -624				; size = 4
_pTarget$227707 = -620					; size = 4
_iWeight$227721 = -616					; size = 4
_iTurns$227717 = -612					; size = 4
_bSkipCity$227706 = -605				; size = 1
_pUnit$227478 = -604					; size = 8
_iLoopCity$227483 = -596				; size = 4
_bNotAtFriendlyCity$227481 = -589			; size = 1
_weightedCityList$227699 = -588				; size = 528
__$ArrayPad$ = -56					; size = 4
_pLoopCity$227482 = -52					; size = 4
_eMyReligion$ = -48					; size = 4
_pHolyCityPlot$ = -44					; size = 4
_bHaveApolloInCapital$ = -37				; size = 1
_pHolyCity$ = -36					; size = 4
_pReligions$ = -32					; size = 4
_eApolloProgram$ = -28					; size = 4
_bKeepHolyCityClear$ = -21				; size = 1
_pMyReligion$ = -20					; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteAdmiralMoves, COMDAT
; _this$ = ecx

; 4209 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1144				; 00000478H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4210 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 4211 : 	CvPlot* pHolyCityPlot = NULL;

	mov	DWORD PTR _pHolyCityPlot$[ebp], 0

; 4212 : 	CvCity* pHolyCity = NULL;

	mov	DWORD PTR _pHolyCity$[ebp], 0

; 4213 : 
; 4214 : 	// Do we have an Apollo program to stay clear of?
; 4215 : 	bool bHaveApolloInCapital = false;

	mov	BYTE PTR _bHaveApolloInCapital$[ebp], 0

; 4216 : 	ProjectTypes eApolloProgram = (ProjectTypes) GC.getSPACE_RACE_TRIGGER_PROJECT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8424
	mov	DWORD PTR _eApolloProgram$[ebp], eax

; 4217 : 	if(eApolloProgram != NO_PROJECT)

	cmp	DWORD PTR _eApolloProgram$[ebp], -1
	je	SHORT $LN36@ExecuteAdm

; 4218 : 	{
; 4219 : 		if(GET_TEAM(m_pPlayer->getTeam()).getProjectCount(eApolloProgram) > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T253437[ebp], edx
	mov	eax, DWORD PTR $T253437[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T253438[ebp], eax
	mov	edx, DWORD PTR $T253438[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T253442[ebp], edx
	mov	eax, DWORD PTR _eApolloProgram$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253442[ebp]
	call	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectCount
	test	eax, eax
	jle	SHORT $LN36@ExecuteAdm

; 4220 : 		{
; 4221 : 			bHaveApolloInCapital = true;

	mov	BYTE PTR _bHaveApolloInCapital$[ebp], 1
$LN36@ExecuteAdm:

; 4222 : 		}
; 4223 : 	}
; 4224 : 
; 4225 : 	// Do we have a holy city to stay clear of?
; 4226 : 	bool bKeepHolyCityClear = false;

	mov	BYTE PTR _bKeepHolyCityClear$[ebp], 0

; 4227 : 	CvGameReligions* pReligions = GC.getGame().GetGameReligions();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T253446[ebp], ecx
	mov	ecx, DWORD PTR $T253446[ebp]
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	DWORD PTR _pReligions$[ebp], eax

; 4228 : 	ReligionTypes eMyReligion = pReligions->GetReligionCreatedByPlayer(m_pPlayer->GetID());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T253455[ebp], ecx
	mov	edx, DWORD PTR $T253455[ebp]
	push	edx
	mov	ecx, DWORD PTR _pReligions$[ebp]
	call	?GetReligionCreatedByPlayer@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligionCreatedByPlayer
	mov	DWORD PTR _eMyReligion$[ebp], eax

; 4229 : 	const CvReligion* pMyReligion = pReligions->GetReligion(eMyReligion, m_pPlayer->GetID());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T253464[ebp], edx
	mov	eax, DWORD PTR $T253464[ebp]
	push	eax
	mov	ecx, DWORD PTR _eMyReligion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pReligions$[ebp]
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion
	mov	DWORD PTR _pMyReligion$[ebp], eax

; 4230 : 	if(pMyReligion)

	cmp	DWORD PTR _pMyReligion$[ebp], 0
	je	$LN34@ExecuteAdm

; 4231 : 	{
; 4232 : 		pHolyCityPlot = GC.getMap().plot(pMyReligion->m_iHolyCityX, pMyReligion->m_iHolyCityY);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T253468[ebp], edx
	mov	eax, DWORD PTR _pMyReligion$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T253518[ebp], ecx
	mov	edx, DWORD PTR _pMyReligion$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T253517[ebp], eax
	cmp	DWORD PTR $T253517[ebp], -2147483647	; 80000001H
	je	SHORT $LN71@ExecuteAdm
	cmp	DWORD PTR $T253518[ebp], -2147483647	; 80000001H
	jne	SHORT $LN72@ExecuteAdm
$LN71@ExecuteAdm:
	mov	DWORD PTR _pHolyCityPlot$[ebp], 0
	jmp	$LN73@ExecuteAdm
$LN72@ExecuteAdm:
	mov	ecx, DWORD PTR $T253468[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T253475[ebp], dl
	mov	eax, DWORD PTR $T253468[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T253479[ebp], ecx
	movzx	edx, BYTE PTR $T253475[ebp]
	push	edx
	mov	eax, DWORD PTR $T253479[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253517[ebp]
	push	ecx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapX$253515[ebp], eax
	mov	edx, DWORD PTR $T253468[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T253483[ebp], al
	mov	ecx, DWORD PTR $T253468[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T253487[ebp], edx
	movzx	eax, BYTE PTR $T253483[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253487[ebp]
	push	ecx
	mov	edx, DWORD PTR $T253518[ebp]
	push	edx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$253516[ebp], eax
	mov	eax, DWORD PTR _iMapY$253516[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$253515[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T253468[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN75@ExecuteAdm
	mov	edx, DWORD PTR $T253468[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T253492[ebp], eax
	mov	ecx, DWORD PTR _iMapY$253516[ebp]
	imul	ecx, DWORD PTR $T253492[ebp]
	add	ecx, DWORD PTR _iMapX$253515[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T253468[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv586[ebp], ecx
	jmp	SHORT $LN76@ExecuteAdm
$LN75@ExecuteAdm:
	mov	DWORD PTR tv586[ebp], 0
$LN76@ExecuteAdm:
	mov	eax, DWORD PTR tv586[ebp]
	mov	DWORD PTR _pHolyCityPlot$[ebp], eax
$LN73@ExecuteAdm:

; 4233 : 		pHolyCity = pHolyCityPlot->getPlotCity();

	mov	ecx, DWORD PTR _pHolyCityPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pHolyCity$[ebp], eax

; 4234 : 		if(pHolyCity && pHolyCity->isCoastal() && pHolyCity->getOwner() == m_pPlayer->GetID())

	cmp	DWORD PTR _pHolyCity$[ebp], 0
	je	SHORT $LN34@ExecuteAdm
	push	-1
	mov	ecx, DWORD PTR _pHolyCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN34@ExecuteAdm
	mov	edx, DWORD PTR _pHolyCity$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T253532[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T253541[ebp], eax
	mov	ecx, DWORD PTR $T253532[ebp]
	cmp	ecx, DWORD PTR $T253541[ebp]
	jne	SHORT $LN34@ExecuteAdm

; 4235 : 		{
; 4236 : 			bKeepHolyCityClear = true;

	mov	BYTE PTR _bKeepHolyCityClear$[ebp], 1
$LN34@ExecuteAdm:

; 4237 : 		}
; 4238 : 	}
; 4239 : 
; 4240 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _it$[ebp], eax
	jmp	SHORT $LN32@ExecuteAdm
$LN31@ExecuteAdm:
	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], ecx
$LN32@ExecuteAdm:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T253548[ebp], edx
	mov	eax, DWORD PTR $T253548[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	mov	edx, DWORD PTR $T253548[ebp]
	add	ecx, DWORD PTR [edx]
	cmp	DWORD PTR _it$[ebp], ecx
	je	$LN37@ExecuteAdm

; 4241 : 	{
; 4242 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T253552[ebp], ecx
	mov	edx, DWORD PTR $T253552[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T253562[ebp], eax
	mov	ecx, DWORD PTR $T253562[ebp]
	mov	DWORD PTR _pUnit$227478[ebp], ecx
	mov	BYTE PTR _pUnit$227478[ebp+4], 0
	cmp	DWORD PTR _pUnit$227478[ebp], 0
	je	SHORT $LN109@ExecuteAdm
	mov	ecx, DWORD PTR _pUnit$227478[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN109@ExecuteAdm:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4243 : 		if(!pUnit)

	xor	edx, edx
	cmp	DWORD PTR _pUnit$227478[ebp], 0
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN29@ExecuteAdm

; 4244 : 		{
; 4245 : 			continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227478[ebp], 0
	je	SHORT $LN116@ExecuteAdm
	mov	ecx, DWORD PTR _pUnit$227478[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN116@ExecuteAdm:
	jmp	$LN31@ExecuteAdm
$LN29@ExecuteAdm:

; 4246 : 		}
; 4247 : 
; 4248 : 		if(pUnit->GetGreatPeopleDirective() == GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE)

	mov	ecx, DWORD PTR _pUnit$227478[ebp]
	mov	DWORD PTR $T253578[ebp], ecx
	mov	ecx, DWORD PTR $T253578[ebp]
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective
	test	eax, eax
	jne	SHORT $LN28@ExecuteAdm

; 4249 : 		{
; 4250 : 			ExecuteGoldenAgeMove(pUnit.pointer());

	mov	edx, DWORD PTR _pUnit$227478[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteGoldenAgeMove

; 4251 : 			continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227478[ebp], 0
	je	SHORT $LN125@ExecuteAdm
	mov	ecx, DWORD PTR _pUnit$227478[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN125@ExecuteAdm:
	jmp	$LN31@ExecuteAdm
$LN28@ExecuteAdm:

; 4252 : 		}
; 4253 : 
; 4254 : 		bool bNotAtFriendlyCity = !pUnit->plot()->isCity() || pUnit->plot()->getOwner() != pUnit->getOwner();

	mov	eax, DWORD PTR _pUnit$227478[ebp]
	mov	DWORD PTR $T253594[ebp], eax
	mov	ecx, DWORD PTR $T253594[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN39@ExecuteAdm
	mov	edx, DWORD PTR _pUnit$227478[ebp]
	mov	DWORD PTR $T253603[ebp], edx
	mov	ecx, DWORD PTR $T253603[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR $T253607[ebp], eax
	mov	eax, DWORD PTR $T253607[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T253608[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227478[ebp]
	mov	DWORD PTR $T253612[ebp], edx
	mov	eax, DWORD PTR $T253612[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T253621[ebp], ecx
	mov	edx, DWORD PTR $T253608[ebp]
	cmp	edx, DWORD PTR $T253621[ebp]
	jne	SHORT $LN39@ExecuteAdm
	mov	DWORD PTR tv201[ebp], 0
	jmp	SHORT $LN40@ExecuteAdm
$LN39@ExecuteAdm:
	mov	DWORD PTR tv201[ebp], 1
$LN40@ExecuteAdm:
	mov	al, BYTE PTR tv201[ebp]
	mov	BYTE PTR _bNotAtFriendlyCity$227481[ebp], al

; 4255 : 
; 4256 : 			// Score cities to move to
; 4257 : 		CvCity* pLoopCity;
; 4258 : 		int iLoopCity = 0;

	mov	DWORD PTR _iLoopCity$227483[ebp], 0

; 4259 : 		CvWeightedVector<CvCity *, SAFE_ESTIMATE_NUM_CITIES, true> weightedCityList;

	lea	ecx, DWORD PTR _weightedCityList$227699[ebp]
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 4260 : 		for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	push	0
	lea	ecx, DWORD PTR _iLoopCity$227483[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$227482[ebp], eax
	jmp	SHORT $LN27@ExecuteAdm
$LN26@ExecuteAdm:
	push	0
	lea	eax, DWORD PTR _iLoopCity$227483[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$227482[ebp], eax
$LN27@ExecuteAdm:
	cmp	DWORD PTR _pLoopCity$227482[ebp], 0
	je	$LN25@ExecuteAdm

; 4261 : 		{
; 4262 : 			if (bHaveApolloInCapital && pLoopCity->isCapital())

	movzx	edx, BYTE PTR _bHaveApolloInCapital$[ebp]
	test	edx, edx
	je	SHORT $LN24@ExecuteAdm
	mov	ecx, DWORD PTR _pLoopCity$227482[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN24@ExecuteAdm

; 4263 : 			{
; 4264 : 				continue;

	jmp	SHORT $LN26@ExecuteAdm
$LN24@ExecuteAdm:

; 4265 : 			}
; 4266 : 
; 4267 : 			if (bKeepHolyCityClear && pLoopCity == pHolyCity)

	movzx	ecx, BYTE PTR _bKeepHolyCityClear$[ebp]
	test	ecx, ecx
	je	SHORT $LN23@ExecuteAdm
	mov	edx, DWORD PTR _pLoopCity$227482[ebp]
	cmp	edx, DWORD PTR _pHolyCity$[ebp]
	jne	SHORT $LN23@ExecuteAdm

; 4268 : 			{
; 4269 : 				continue;

	jmp	SHORT $LN26@ExecuteAdm
$LN23@ExecuteAdm:

; 4270 : 			}
; 4271 : 
; 4272 : 			if (!pLoopCity->isCoastal())

	push	-1
	mov	ecx, DWORD PTR _pLoopCity$227482[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN22@ExecuteAdm

; 4273 : 			{
; 4274 : 				continue;

	jmp	SHORT $LN26@ExecuteAdm
$LN22@ExecuteAdm:

; 4275 : 			}
; 4276 : 
; 4277 : 			// Don't go here if a different general or admiral is already present
; 4278 : 			bool bSkipCity = false;

	mov	BYTE PTR _bSkipCity$227706[ebp], 0

; 4279 : 			CvPlot* pTarget = pLoopCity->plot();

	mov	ecx, DWORD PTR _pLoopCity$227482[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pTarget$227707[ebp], eax

; 4280 : #ifdef AUI_WARNING_FIXES
; 4281 : 			for (uint iUnitLoop = 0; iUnitLoop < pTarget->getNumUnits(); iUnitLoop++)
; 4282 : #else
; 4283 : 			for(int iUnitLoop = 0; iUnitLoop < pTarget->getNumUnits(); iUnitLoop++)

	mov	DWORD PTR _iUnitLoop$227708[ebp], 0
	jmp	SHORT $LN21@ExecuteAdm
$LN20@ExecuteAdm:
	mov	ecx, DWORD PTR _iUnitLoop$227708[ebp]
	add	ecx, 1
	mov	DWORD PTR _iUnitLoop$227708[ebp], ecx
$LN21@ExecuteAdm:
	mov	ecx, DWORD PTR _pTarget$227707[ebp]
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	DWORD PTR _iUnitLoop$227708[ebp], eax
	jge	$LN19@ExecuteAdm

; 4284 : #endif
; 4285 : 			{
; 4286 : 				CvUnit *pLoopUnit = pTarget->getUnitByIndex(iUnitLoop);

	mov	edx, DWORD PTR _iUnitLoop$227708[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTarget$227707[ebp]
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	DWORD PTR _pLoopUnit$227712[ebp], eax

; 4287 : 				if(pLoopUnit->AI_getUnitAIType() == UNITAI_GENERAL && pLoopUnit->GetID() != pUnit->GetID())

	mov	ecx, DWORD PTR _pLoopUnit$227712[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN18@ExecuteAdm
	mov	eax, DWORD PTR _pLoopUnit$227712[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T253634[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227478[ebp]
	mov	DWORD PTR $T253638[ebp], edx
	mov	eax, DWORD PTR $T253638[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T253647[ebp], ecx
	mov	edx, DWORD PTR $T253634[ebp]
	cmp	edx, DWORD PTR $T253647[ebp]
	je	SHORT $LN18@ExecuteAdm

; 4288 : 				{
; 4289 : 					bSkipCity = true;

	mov	BYTE PTR _bSkipCity$227706[ebp], 1
	jmp	SHORT $LN19@ExecuteAdm

; 4290 : 					break;

	jmp	SHORT $LN17@ExecuteAdm
$LN18@ExecuteAdm:

; 4291 : 				}
; 4292 : 				else if(pLoopUnit->AI_getUnitAIType() == UNITAI_ADMIRAL && pLoopUnit->GetID() != pUnit->GetID())

	mov	ecx, DWORD PTR _pLoopUnit$227712[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN17@ExecuteAdm
	mov	eax, DWORD PTR _pLoopUnit$227712[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T253656[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227478[ebp]
	mov	DWORD PTR $T253660[ebp], edx
	mov	eax, DWORD PTR $T253660[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T253669[ebp], ecx
	mov	edx, DWORD PTR $T253656[ebp]
	cmp	edx, DWORD PTR $T253669[ebp]
	je	SHORT $LN17@ExecuteAdm

; 4293 : 				{
; 4294 : 					bSkipCity = true;

	mov	BYTE PTR _bSkipCity$227706[ebp], 1

; 4295 : 					break;

	jmp	SHORT $LN19@ExecuteAdm
$LN17@ExecuteAdm:

; 4296 : 				}
; 4297 : 			}

	jmp	$LN20@ExecuteAdm
$LN19@ExecuteAdm:

; 4298 : 			if(bSkipCity)

	movzx	eax, BYTE PTR _bSkipCity$227706[ebp]
	test	eax, eax
	je	SHORT $LN15@ExecuteAdm

; 4299 : 			{
; 4300 : 				continue;

	jmp	$LN26@ExecuteAdm
$LN15@ExecuteAdm:

; 4301 : 			}
; 4302 : 
; 4303 : 			int iTurns = TurnsToReachTarget(pUnit, pLoopCity->plot());

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _pLoopCity$227482[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T253412[ebp], esp
	mov	DWORD PTR $T253679[ebp], ecx
	mov	edx, DWORD PTR $T253679[ebp]
	mov	eax, DWORD PTR _pUnit$227478[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T253679[ebp]
	mov	dl, BYTE PTR _pUnit$227478[ebp+4]
	mov	BYTE PTR [ecx+4], dl
	mov	eax, DWORD PTR $T253679[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN170@ExecuteAdm
	mov	ecx, DWORD PTR $T253679[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN170@ExecuteAdm:
	mov	edx, DWORD PTR $T253679[ebp]
	mov	DWORD PTR tv504[ebp], edx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv505[ebp], eax
	mov	eax, DWORD PTR tv505[ebp]
	mov	DWORD PTR _iTurns$227717[ebp], eax

; 4304 : 
; 4305 : 			// Don't go here if I'm not in a city currently and this city is not reachable by normal movement
; 4306 : 			if (bNotAtFriendlyCity)

	movzx	ecx, BYTE PTR _bNotAtFriendlyCity$227481[ebp]
	test	ecx, ecx
	je	SHORT $LN14@ExecuteAdm

; 4307 : 			{
; 4308 : 				if (iTurns == MAX_INT)

	cmp	DWORD PTR _iTurns$227717[ebp], 2147483647 ; 7fffffffH
	jne	SHORT $LN14@ExecuteAdm

; 4309 : 				{
; 4310 : 					continue;

	jmp	$LN26@ExecuteAdm
$LN14@ExecuteAdm:

; 4311 : 				}
; 4312 : 			}
; 4313 : 
; 4314 : 			// Weight is size of largest adjacent ocean
; 4315 : 			int iWeight = pTarget->GetSizeLargestAdjacentWater();

	mov	ecx, DWORD PTR _pTarget$227707[ebp]
	call	?GetSizeLargestAdjacentWater@CvPlot@@QBEHXZ ; CvPlot::GetSizeLargestAdjacentWater
	mov	DWORD PTR _iWeight$227721[ebp], eax

; 4316 : 
; 4317 : 			// If this city is damaged, divide weight by the damage level
; 4318 : 			if (pLoopCity->getDamage() > 0)

	mov	ecx, DWORD PTR _pLoopCity$227482[ebp]
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	test	eax, eax
	jle	SHORT $LN12@ExecuteAdm

; 4319 : 			{
; 4320 : 				iWeight /= pLoopCity->getDamage();

	mov	ecx, DWORD PTR _pLoopCity$227482[ebp]
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	mov	ecx, eax
	mov	eax, DWORD PTR _iWeight$227721[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _iWeight$227721[ebp], eax
$LN12@ExecuteAdm:

; 4321 : 			}
; 4322 : 
; 4323 : 			// Subtract off turns to reach
; 4324 : 			if (iTurns != MAX_INT)

	cmp	DWORD PTR _iTurns$227717[ebp], 2147483647 ; 7fffffffH
	je	SHORT $LN11@ExecuteAdm

; 4325 : 			{
; 4326 : 				iWeight -= iTurns;

	mov	edx, DWORD PTR _iWeight$227721[ebp]
	sub	edx, DWORD PTR _iTurns$227717[ebp]
	mov	DWORD PTR _iWeight$227721[ebp], edx
$LN11@ExecuteAdm:

; 4327 : 			}
; 4328 : 
; 4329 : 			weightedCityList.push_back(pLoopCity, iWeight);

	mov	DWORD PTR _weightedElem$253685[ebp], 0
	mov	DWORD PTR _weightedElem$253685[ebp+4], 0
	mov	eax, DWORD PTR _pLoopCity$227482[ebp]
	mov	DWORD PTR _weightedElem$253685[ebp], eax
	mov	ecx, DWORD PTR _iWeight$227721[ebp]
	mov	DWORD PTR _weightedElem$253685[ebp+4], ecx
	lea	edx, DWORD PTR _weightedElem$253685[ebp]
	push	edx
	lea	ecx, DWORD PTR _weightedCityList$227699[ebp]
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@Z ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::push_back

; 4330 : 		}

	jmp	$LN26@ExecuteAdm
$LN25@ExecuteAdm:

; 4331 : 
; 4332 : 		weightedCityList.SortItems();

	lea	ecx, DWORD PTR _weightedCityList$227699[ebp]
	call	?SortItems@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAEXXZ ; CvWeightedVector<CvCity *,64,1>::SortItems

; 4333 : 		if (weightedCityList.size() > 0)

	mov	eax, DWORD PTR _weightedCityList$227699[ebp+4]
	mov	DWORD PTR $T253705[ebp], eax
	cmp	DWORD PTR $T253705[ebp], 0
	jle	$LN297@ExecuteAdm

; 4334 : 		{
; 4335 : 			CvCity *pChosenCity = weightedCityList.GetElement(0);

	xor	ecx, ecx
	shl	ecx, 3
	mov	edx, DWORD PTR _weightedCityList$227699[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _pChosenCity$227725[ebp], eax

; 4336 : 
; 4337 : 			// Am I already in chosen city?
; 4338 : 			if (pUnit->plot() == pChosenCity->plot())

	mov	ecx, DWORD PTR _pUnit$227478[ebp]
	mov	DWORD PTR $T253721[ebp], ecx
	mov	ecx, DWORD PTR $T253721[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	esi, eax
	mov	ecx, DWORD PTR _pChosenCity$227725[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	cmp	esi, eax
	jne	$LN9@ExecuteAdm

; 4339 : 			{
; 4340 : 				pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$227478[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4341 : 				UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$227478[ebp]
	mov	DWORD PTR $T253728[ebp], edx
	mov	eax, DWORD PTR $T253728[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T253737[ebp], ecx
	mov	edx, DWORD PTR $T253737[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 4342 : 
; 4343 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN8@ExecuteAdm
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN8@ExecuteAdm

; 4344 : 				{
; 4345 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227728[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 4346 : 					strLogString.Format("Great Admiral still in most favored city of %s, X: %d, Y: %d", pChosenCity->getName().GetCString(), pChosenCity->getX(), pChosenCity->getY());

	lea	edx, DWORD PTR $T253413[ebp]
	push	edx
	mov	ecx, DWORD PTR _pChosenCity$227725[ebp]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv803[ebp], eax
	mov	eax, DWORD PTR tv803[ebp]
	mov	DWORD PTR $T253763[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _pChosenCity$227725[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T253750[ebp], edx
	mov	eax, DWORD PTR _pChosenCity$227725[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T253759[ebp], ecx
	mov	edx, DWORD PTR $T253750[ebp]
	push	edx
	mov	eax, DWORD PTR $T253759[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253763[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0DN@FEGEKJNA@Great?5Admiral?5still?5in?5most?5favo@
	lea	ecx, DWORD PTR _strLogString$227728[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T253413[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4347 : 					LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227728[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4348 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLogString$227728[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN8@ExecuteAdm:

; 4349 : 			}

	jmp	$LN7@ExecuteAdm
$LN9@ExecuteAdm:

; 4350 : 			
; 4351 : 			// Am I currently in a different friendly city?
; 4352 : 			else if (!bNotAtFriendlyCity)

	movzx	eax, BYTE PTR _bNotAtFriendlyCity$227481[ebp]
	test	eax, eax
	jne	$LN262@ExecuteAdm

; 4353 : 			{
; 4354 : 				pUnit->PushMission(CvTypes::getMISSION_CHANGE_ADMIRAL_PORT(), pChosenCity->getX(), pChosenCity->getY());

	mov	ecx, DWORD PTR _pChosenCity$227725[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T253780[ebp], edx
	mov	eax, DWORD PTR _pChosenCity$227725[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T253789[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227478[ebp]
	mov	DWORD PTR $T253793[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR $T253780[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253789[ebp]
	push	ecx
	call	?getMISSION_CHANGE_ADMIRAL_PORT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_CHANGE_ADMIRAL_PORT
	push	eax
	mov	ecx, DWORD PTR $T253793[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4355 : 				pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$227478[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4356 : 				UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$227478[ebp]
	mov	DWORD PTR $T253800[ebp], edx
	mov	eax, DWORD PTR $T253800[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T253809[ebp], ecx
	mov	edx, DWORD PTR $T253809[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 4357 : 
; 4358 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN5@ExecuteAdm
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@ExecuteAdm

; 4359 : 				{
; 4360 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227734[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 4361 : 					strLogString.Format("Transferring Great Admiral to city of %s, X: %d, Y: %d", pChosenCity->getName().GetCString(), pChosenCity->getX(), pChosenCity->getY());

	lea	edx, DWORD PTR $T253414[ebp]
	push	edx
	mov	ecx, DWORD PTR _pChosenCity$227725[ebp]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv741[ebp], eax
	mov	eax, DWORD PTR tv741[ebp]
	mov	DWORD PTR $T253835[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _pChosenCity$227725[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T253822[ebp], edx
	mov	eax, DWORD PTR _pChosenCity$227725[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T253831[ebp], ecx
	mov	edx, DWORD PTR $T253822[ebp]
	push	edx
	mov	eax, DWORD PTR $T253831[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253835[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0DH@COGMIFKF@Transferring?5Great?5Admiral?5to?5ci@
	lea	ecx, DWORD PTR _strLogString$227734[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T253414[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4362 : 					LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227734[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4363 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLogString$227734[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@ExecuteAdm:

; 4364 : 			}
; 4365 : 
; 4366 : 			// Move normally to this city
; 4367 : 			else

	jmp	$LN7@ExecuteAdm

; 4368 : 			{
; 4369 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pChosenCity->getX(), pChosenCity->getY());

$LN262@ExecuteAdm:
	mov	eax, DWORD PTR _pChosenCity$227725[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T253852[ebp], ecx
	mov	edx, DWORD PTR _pChosenCity$227725[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T253861[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227478[ebp]
	mov	DWORD PTR $T253865[ebp], ecx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR $T253852[ebp]
	push	edx
	mov	eax, DWORD PTR $T253861[ebp]
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T253865[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4370 : 				pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$227478[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4371 : 				UnitProcessed(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$227478[ebp]
	mov	DWORD PTR $T253872[ebp], ecx
	mov	edx, DWORD PTR $T253872[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T253881[ebp], eax
	mov	ecx, DWORD PTR $T253881[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 4372 : 
; 4373 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN7@ExecuteAdm
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	$LN7@ExecuteAdm

; 4374 : 				{
; 4375 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227739[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 4376 : 					strLogString.Format("Moving Great Admiral normally to city of %s, X: %d, Y: %d", pChosenCity->getName().GetCString(), pChosenCity->getX(), pChosenCity->getY());

	lea	ecx, DWORD PTR $T253415[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pChosenCity$227725[ebp]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv708[ebp], eax
	mov	edx, DWORD PTR tv708[ebp]
	mov	DWORD PTR $T253907[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR _pChosenCity$227725[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T253894[ebp], ecx
	mov	edx, DWORD PTR _pChosenCity$227725[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T253903[ebp], eax
	mov	ecx, DWORD PTR $T253894[ebp]
	push	ecx
	mov	edx, DWORD PTR $T253903[ebp]
	push	edx
	mov	ecx, DWORD PTR $T253907[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0DK@OPCEPNHH@Moving?5Great?5Admiral?5normally?5to@
	lea	eax, DWORD PTR _strLogString$227739[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T253415[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4377 : 					LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227739[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4378 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLogString$227739[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@ExecuteAdm:

; 4379 : 			}
; 4380 : 		}
; 4381 : 		else

	jmp	$LN2@ExecuteAdm

; 4382 : 		{
; 4383 : 			pUnit->finishMoves();

$LN297@ExecuteAdm:
	mov	ecx, DWORD PTR _pUnit$227478[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4384 : 			UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$227478[ebp]
	mov	DWORD PTR $T253922[ebp], edx
	mov	eax, DWORD PTR $T253922[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T253931[ebp], ecx
	mov	edx, DWORD PTR $T253931[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 4385 : 
; 4386 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN2@ExecuteAdm
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@ExecuteAdm

; 4387 : 			{
; 4388 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227744[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 4389 : 				strLogString.Format("No place to move Great Admiral at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	edx, DWORD PTR _pUnit$227478[ebp]
	mov	DWORD PTR $T253939[ebp], edx
	mov	eax, DWORD PTR $T253939[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T253948[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227478[ebp]
	mov	DWORD PTR $T253952[ebp], edx
	mov	eax, DWORD PTR $T253952[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T253961[ebp], ecx
	mov	edx, DWORD PTR $T253948[ebp]
	push	edx
	mov	eax, DWORD PTR $T253961[ebp]
	push	eax
	push	OFFSET ??_C@_0DA@GNLMOMBK@No?5place?5to?5move?5Great?5Admiral?5a@
	lea	ecx, DWORD PTR _strLogString$227744[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4390 : 				LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227744[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4391 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLogString$227744[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@ExecuteAdm:

; 4392 : 		}
; 4393 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _weightedCityList$227699[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227478[ebp], 0
	je	SHORT $LN342@ExecuteAdm
	mov	ecx, DWORD PTR _pUnit$227478[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN342@ExecuteAdm:
	jmp	$LN31@ExecuteAdm
$LN37@ExecuteAdm:

; 4394 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227478[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _weightedCityList$227699[ebp]
	jmp	??1?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@XZ ; CvWeightedVector<CvCity *,64,1>::~CvWeightedVector<CvCity *,64,1>
__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strLogString$227728[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR $T253413[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strLogString$227734[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR $T253414[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _strLogString$227739[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$8:
	lea	ecx, DWORD PTR $T253415[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$9:
	lea	ecx, DWORD PTR _strLogString$227744[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1152]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteAdmiralMoves
PUBLIC	__$ArrayPad$
EXTRN	?ChooseMissionaryTargetPlot@CvReligionAI@@QAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@PAH@Z:PROC ; CvReligionAI::ChooseMissionaryTargetPlot
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ$3
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ$4
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv292 = -216						; size = 4
tv291 = -212						; size = 4
_this$ = -208						; size = 4
$T254163 = -204						; size = 4
$T254159 = -200						; size = 4
$T254150 = -196						; size = 4
$T254146 = -192						; size = 4
$T254137 = -188						; size = 4
$T254129 = -184						; size = 4
$T254118 = -180						; size = 4
$T254110 = -176						; size = 4
$T254106 = -172						; size = 4
$T254102 = -168						; size = 4
$T254098 = -164						; size = 4
$T254094 = -160						; size = 4
$T254090 = -156						; size = 4
$T254079 = -152						; size = 4
$T254071 = -148						; size = 4
$T254067 = -144						; size = 4
$T254063 = -140						; size = 4
$T254041 = -136						; size = 4
$T254031 = -132						; size = 4
$T254027 = -128						; size = 4
$T254015 = -124						; size = 4
_strLogString$227771 = -120				; size = 28
_strLogString$227767 = -92				; size = 28
_strLogString$227762 = -64				; size = 28
__$ArrayPad$ = -36					; size = 4
_pUnit$227754 = -32					; size = 8
_iTargetTurns$227756 = -24				; size = 4
_pTarget$227757 = -20					; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::ExecuteMissionaryMoves, COMDAT
; _this$ = ecx

; 4398 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4399 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 4400 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN14@ExecuteMis
$LN13@ExecuteMis:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], edx
$LN14@ExecuteMis:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T254027[ebp], eax
	mov	ecx, DWORD PTR $T254027[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T254027[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN15@ExecuteMis

; 4401 : 	{
; 4402 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T254031[ebp], edx
	mov	eax, DWORD PTR $T254031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T254041[ebp], eax
	mov	edx, DWORD PTR $T254041[ebp]
	mov	DWORD PTR _pUnit$227754[ebp], edx
	mov	BYTE PTR _pUnit$227754[ebp+4], 0
	cmp	DWORD PTR _pUnit$227754[ebp], 0
	je	SHORT $LN29@ExecuteMis
	mov	ecx, DWORD PTR _pUnit$227754[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN29@ExecuteMis:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4403 : 		if(!pUnit)

	xor	eax, eax
	cmp	DWORD PTR _pUnit$227754[ebp], 0
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@ExecuteMis

; 4404 : 		{
; 4405 : 			continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227754[ebp], 0
	je	SHORT $LN36@ExecuteMis
	mov	ecx, DWORD PTR _pUnit$227754[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN36@ExecuteMis:
	jmp	$LN13@ExecuteMis
$LN11@ExecuteMis:

; 4406 : 		}
; 4407 : 
; 4408 : 		int iTargetTurns;
; 4409 : 		CvPlot* pTarget = m_pPlayer->GetReligionAI()->ChooseMissionaryTargetPlot(pUnit, &iTargetTurns);

	lea	edx, DWORD PTR _iTargetTurns$227756[ebp]
	push	edx
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T254015[ebp], esp
	mov	DWORD PTR $T254063[ebp], eax
	mov	ecx, DWORD PTR $T254063[ebp]
	mov	edx, DWORD PTR _pUnit$227754[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T254063[ebp]
	mov	cl, BYTE PTR _pUnit$227754[ebp+4]
	mov	BYTE PTR [eax+4], cl
	mov	edx, DWORD PTR $T254063[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN41@ExecuteMis
	mov	eax, DWORD PTR $T254063[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@ExecuteMis:
	mov	ecx, DWORD PTR $T254063[ebp]
	mov	DWORD PTR tv291[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetReligionAI@CvPlayer@@QBEPAVCvReligionAI@@XZ ; CvPlayer::GetReligionAI
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, eax
	call	?ChooseMissionaryTargetPlot@CvReligionAI@@QAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@PAH@Z ; CvReligionAI::ChooseMissionaryTargetPlot
	mov	DWORD PTR tv292[ebp], eax
	mov	eax, DWORD PTR tv292[ebp]
	mov	DWORD PTR _pTarget$227757[ebp], eax

; 4410 : 		if(pTarget)

	cmp	DWORD PTR _pTarget$227757[ebp], 0
	je	$LN10@ExecuteMis

; 4411 : 		{
; 4412 : 			if(pUnit->plot() == pTarget)

	mov	ecx, DWORD PTR _pUnit$227754[ebp]
	mov	DWORD PTR $T254067[ebp], ecx
	mov	ecx, DWORD PTR $T254067[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pTarget$227757[ebp]
	jne	$LN9@ExecuteMis

; 4413 : 			{
; 4414 : 				pUnit->PushMission(CvTypes::getMISSION_SPREAD_RELIGION());

	mov	edx, DWORD PTR _pUnit$227754[ebp]
	mov	DWORD PTR $T254071[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SPREAD_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SPREAD_RELIGION
	push	eax
	mov	ecx, DWORD PTR $T254071[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4415 : 
; 4416 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@ExecuteMis
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@ExecuteMis

; 4417 : 				{
; 4418 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227762[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 4419 : 					strLogString.Format("Spreading religion, X: %d, Y: %d", pTarget->getX(), pTarget->getY());

	mov	edx, DWORD PTR _pTarget$227757[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T254079[ebp], eax
	mov	ecx, DWORD PTR $T254079[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTarget$227757[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_0CB@DDJKBPIG@Spreading?5religion?0?5X?3?5?$CFd?0?5Y?3?5?$CFd@
	lea	ecx, DWORD PTR _strLogString$227762[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4420 : 					LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227762[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4421 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227762[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN8@ExecuteMis:

; 4422 : 			}

	jmp	$LN10@ExecuteMis
$LN9@ExecuteMis:

; 4423 : 			else if(iTargetTurns < 1)

	cmp	DWORD PTR _iTargetTurns$227756[ebp], 1
	jge	$LN6@ExecuteMis

; 4424 : 			{
; 4425 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());

	mov	eax, DWORD PTR _pTarget$227757[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T254090[ebp], ecx
	mov	edx, DWORD PTR _pTarget$227757[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T254094[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227754[ebp]
	mov	DWORD PTR $T254098[ebp], ecx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR $T254090[ebp]
	push	edx
	mov	eax, DWORD PTR $T254094[ebp]
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T254098[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4426 : 
; 4427 : 				if(pUnit->plot() == pTarget && pUnit->canMove())

	mov	ecx, DWORD PTR _pUnit$227754[ebp]
	mov	DWORD PTR $T254102[ebp], ecx
	mov	ecx, DWORD PTR $T254102[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pTarget$227757[ebp]
	jne	$LN3@ExecuteMis
	mov	edx, DWORD PTR _pUnit$227754[ebp]
	mov	DWORD PTR $T254106[ebp], edx
	mov	ecx, DWORD PTR $T254106[ebp]
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	movzx	eax, al
	test	eax, eax
	je	$LN3@ExecuteMis

; 4428 : 				{
; 4429 : 					pUnit->PushMission(CvTypes::getMISSION_SPREAD_RELIGION());

	mov	ecx, DWORD PTR _pUnit$227754[ebp]
	mov	DWORD PTR $T254110[ebp], ecx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SPREAD_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SPREAD_RELIGION
	push	eax
	mov	ecx, DWORD PTR $T254110[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4430 : 
; 4431 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@ExecuteMis
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@ExecuteMis

; 4432 : 					{
; 4433 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227767[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 4434 : 						strLogString.Format("Move to spread religion, X: %d, Y: %d", pTarget->getX(), pTarget->getY());

	mov	ecx, DWORD PTR _pTarget$227757[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T254118[ebp], edx
	mov	eax, DWORD PTR $T254118[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarget$227757[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0CG@EKOOMPMN@Move?5to?5spread?5religion?0?5X?3?5?$CFd?0?5@
	lea	eax, DWORD PTR _strLogString$227767[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4435 : 						LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227767[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4436 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227767[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@ExecuteMis:

; 4437 : 				}
; 4438 : 				else
; 4439 : 				{
; 4440 : 					CvAssertMsg(false, "Internal error with Missionary AI move, contact Ed.");
; 4441 : 				}
; 4442 : 			}
; 4443 : 			else

	jmp	$LN10@ExecuteMis
$LN6@ExecuteMis:

; 4444 : 			{
; 4445 : 				m_CurrentBestMoveHighPriorityUnit = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2404], 0

; 4446 : 				m_CurrentBestMoveUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T254129[ebp], ecx
	mov	edx, DWORD PTR $T254129[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2396], eax

; 4447 : 				ExecuteMoveToTarget(pTarget);

	mov	edx, DWORD PTR _pTarget$227757[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget

; 4448 : 
; 4449 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN10@ExecuteMis
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN10@ExecuteMis

; 4450 : 				{
; 4451 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227771[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 4452 : 					strLogString.Format("Moving to plot adjacent to conversion city, X: %d, Y: %d, Currently at, X: %d, Y: %d", pTarget->getX(), pTarget->getY(), pUnit->getX(), pUnit->getY());

	mov	edx, DWORD PTR _pUnit$227754[ebp]
	mov	DWORD PTR $T254137[ebp], edx
	mov	eax, DWORD PTR $T254137[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T254146[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227754[ebp]
	mov	DWORD PTR $T254150[ebp], edx
	mov	eax, DWORD PTR $T254150[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T254159[ebp], ecx
	mov	edx, DWORD PTR _pTarget$227757[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T254163[ebp], eax
	mov	ecx, DWORD PTR $T254146[ebp]
	push	ecx
	mov	edx, DWORD PTR $T254159[ebp]
	push	edx
	mov	eax, DWORD PTR $T254163[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarget$227757[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0FF@LDCMHMMB@Moving?5to?5plot?5adjacent?5to?5conve@
	lea	eax, DWORD PTR _strLogString$227771[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 4453 : 					LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227771[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4454 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227771[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN10@ExecuteMis:

; 4455 : 			}
; 4456 : 		}
; 4457 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227754[ebp], 0
	je	SHORT $LN106@ExecuteMis
	mov	ecx, DWORD PTR _pUnit$227754[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN106@ExecuteMis:
	jmp	$LN13@ExecuteMis
$LN15@ExecuteMis:

; 4458 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227754[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ$1:
	mov	ecx, DWORD PTR $T254015[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$227762[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strLogString$227767[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLogString$227771[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::ExecuteMissionaryMoves
PUBLIC	??_C@_0FJ@IDAMCEHK@Moving?5to?5plot?5adjacent?5to?5heres@ ; `string'
PUBLIC	??_C@_0CE@FFKFOOGC@Move?5to?5remove?5heresy?0?5X?3?5?$CFd?0?5Y?3@ ; `string'
PUBLIC	??_C@_0BO@PONENJKP@Removing?5heresy?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?$AA@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getMISSION_REMOVE_HERESY@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_REMOVE_HERESY
EXTRN	?ChooseInquisitorTargetPlot@CvReligionAI@@QAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@PAH@Z:PROC ; CvReligionAI::ChooseInquisitorTargetPlot
;	COMDAT ??_C@_0FJ@IDAMCEHK@Moving?5to?5plot?5adjacent?5to?5heres@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0FJ@IDAMCEHK@Moving?5to?5plot?5adjacent?5to?5heres@ DB 'Moving to p'
	DB	'lot adjacent to heresy removal city, X: %d, Y: %d, Currently '
	DB	'at, X: %d, Y: %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FFKFOOGC@Move?5to?5remove?5heresy?0?5X?3?5?$CFd?0?5Y?3@
CONST	SEGMENT
??_C@_0CE@FFKFOOGC@Move?5to?5remove?5heresy?0?5X?3?5?$CFd?0?5Y?3@ DB 'Mov'
	DB	'e to remove heresy, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PONENJKP@Removing?5heresy?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@PONENJKP@Removing?5heresy?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?$AA@ DB 'R'
	DB	'emoving heresy, X: %d, Y: %d', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ$3
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ$4
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv292 = -216						; size = 4
tv291 = -212						; size = 4
_this$ = -208						; size = 4
$T254337 = -204						; size = 4
$T254333 = -200						; size = 4
$T254324 = -196						; size = 4
$T254320 = -192						; size = 4
$T254311 = -188						; size = 4
$T254303 = -184						; size = 4
$T254292 = -180						; size = 4
$T254284 = -176						; size = 4
$T254280 = -172						; size = 4
$T254276 = -168						; size = 4
$T254272 = -164						; size = 4
$T254268 = -160						; size = 4
$T254264 = -156						; size = 4
$T254253 = -152						; size = 4
$T254245 = -148						; size = 4
$T254241 = -144						; size = 4
$T254237 = -140						; size = 4
$T254215 = -136						; size = 4
$T254205 = -132						; size = 4
$T254201 = -128						; size = 4
$T254189 = -124						; size = 4
_strLogString$227799 = -120				; size = 28
_strLogString$227794 = -92				; size = 28
_strLogString$227788 = -64				; size = 28
__$ArrayPad$ = -36					; size = 4
_pUnit$227780 = -32					; size = 8
_iTargetTurns$227782 = -24				; size = 4
_pTarget$227783 = -20					; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::ExecuteInquisitorMoves, COMDAT
; _this$ = ecx

; 4462 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4463 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 4464 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN14@ExecuteInq
$LN13@ExecuteInq:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], edx
$LN14@ExecuteInq:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T254201[ebp], eax
	mov	ecx, DWORD PTR $T254201[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T254201[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN15@ExecuteInq

; 4465 : 	{
; 4466 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T254205[ebp], edx
	mov	eax, DWORD PTR $T254205[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T254215[ebp], eax
	mov	edx, DWORD PTR $T254215[ebp]
	mov	DWORD PTR _pUnit$227780[ebp], edx
	mov	BYTE PTR _pUnit$227780[ebp+4], 0
	cmp	DWORD PTR _pUnit$227780[ebp], 0
	je	SHORT $LN29@ExecuteInq
	mov	ecx, DWORD PTR _pUnit$227780[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN29@ExecuteInq:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4467 : 		if(!pUnit)

	xor	eax, eax
	cmp	DWORD PTR _pUnit$227780[ebp], 0
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@ExecuteInq

; 4468 : 		{
; 4469 : 			continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227780[ebp], 0
	je	SHORT $LN36@ExecuteInq
	mov	ecx, DWORD PTR _pUnit$227780[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN36@ExecuteInq:
	jmp	$LN13@ExecuteInq
$LN11@ExecuteInq:

; 4470 : 		}
; 4471 : 
; 4472 : 		int iTargetTurns;
; 4473 : 		CvPlot* pTarget = m_pPlayer->GetReligionAI()->ChooseInquisitorTargetPlot(pUnit, &iTargetTurns);

	lea	edx, DWORD PTR _iTargetTurns$227782[ebp]
	push	edx
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T254189[ebp], esp
	mov	DWORD PTR $T254237[ebp], eax
	mov	ecx, DWORD PTR $T254237[ebp]
	mov	edx, DWORD PTR _pUnit$227780[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T254237[ebp]
	mov	cl, BYTE PTR _pUnit$227780[ebp+4]
	mov	BYTE PTR [eax+4], cl
	mov	edx, DWORD PTR $T254237[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN41@ExecuteInq
	mov	eax, DWORD PTR $T254237[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@ExecuteInq:
	mov	ecx, DWORD PTR $T254237[ebp]
	mov	DWORD PTR tv291[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetReligionAI@CvPlayer@@QBEPAVCvReligionAI@@XZ ; CvPlayer::GetReligionAI
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, eax
	call	?ChooseInquisitorTargetPlot@CvReligionAI@@QAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@PAH@Z ; CvReligionAI::ChooseInquisitorTargetPlot
	mov	DWORD PTR tv292[ebp], eax
	mov	eax, DWORD PTR tv292[ebp]
	mov	DWORD PTR _pTarget$227783[ebp], eax

; 4474 : 		if(pTarget)

	cmp	DWORD PTR _pTarget$227783[ebp], 0
	je	$LN10@ExecuteInq

; 4475 : 		{
; 4476 : 			if(pUnit->plot() == pTarget)

	mov	ecx, DWORD PTR _pUnit$227780[ebp]
	mov	DWORD PTR $T254241[ebp], ecx
	mov	ecx, DWORD PTR $T254241[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pTarget$227783[ebp]
	jne	$LN9@ExecuteInq

; 4477 : 			{
; 4478 : 				pUnit->PushMission(CvTypes::getMISSION_REMOVE_HERESY());

	mov	edx, DWORD PTR _pUnit$227780[ebp]
	mov	DWORD PTR $T254245[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_REMOVE_HERESY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_REMOVE_HERESY
	push	eax
	mov	ecx, DWORD PTR $T254245[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4479 : 
; 4480 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@ExecuteInq
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@ExecuteInq

; 4481 : 				{
; 4482 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227788[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 4483 : 					strLogString.Format("Removing heresy, X: %d, Y: %d", pTarget->getX(), pTarget->getY());

	mov	edx, DWORD PTR _pTarget$227783[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T254253[ebp], eax
	mov	ecx, DWORD PTR $T254253[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTarget$227783[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_0BO@PONENJKP@Removing?5heresy?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?$AA@
	lea	ecx, DWORD PTR _strLogString$227788[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4484 : 					LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227788[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4485 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227788[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN8@ExecuteInq:

; 4486 : 			}

	jmp	$LN10@ExecuteInq
$LN9@ExecuteInq:

; 4487 : 			else if(iTargetTurns < 1)

	cmp	DWORD PTR _iTargetTurns$227782[ebp], 1
	jge	$LN6@ExecuteInq

; 4488 : 			{
; 4489 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());

	mov	eax, DWORD PTR _pTarget$227783[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T254264[ebp], ecx
	mov	edx, DWORD PTR _pTarget$227783[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T254268[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227780[ebp]
	mov	DWORD PTR $T254272[ebp], ecx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR $T254264[ebp]
	push	edx
	mov	eax, DWORD PTR $T254268[ebp]
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T254272[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4490 : 
; 4491 : 				if(pUnit->plot() == pTarget && pUnit->canMove())

	mov	ecx, DWORD PTR _pUnit$227780[ebp]
	mov	DWORD PTR $T254276[ebp], ecx
	mov	ecx, DWORD PTR $T254276[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pTarget$227783[ebp]
	jne	$LN3@ExecuteInq
	mov	edx, DWORD PTR _pUnit$227780[ebp]
	mov	DWORD PTR $T254280[ebp], edx
	mov	ecx, DWORD PTR $T254280[ebp]
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	movzx	eax, al
	test	eax, eax
	je	$LN3@ExecuteInq

; 4492 : 				{
; 4493 : 					pUnit->PushMission(CvTypes::getMISSION_REMOVE_HERESY());

	mov	ecx, DWORD PTR _pUnit$227780[ebp]
	mov	DWORD PTR $T254284[ebp], ecx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_REMOVE_HERESY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_REMOVE_HERESY
	push	eax
	mov	ecx, DWORD PTR $T254284[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4494 : 
; 4495 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@ExecuteInq
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@ExecuteInq

; 4496 : 					{
; 4497 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227794[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 4498 : 						strLogString.Format("Move to remove heresy, X: %d, Y: %d", pTarget->getX(), pTarget->getY());

	mov	ecx, DWORD PTR _pTarget$227783[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T254292[ebp], edx
	mov	eax, DWORD PTR $T254292[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarget$227783[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0CE@FFKFOOGC@Move?5to?5remove?5heresy?0?5X?3?5?$CFd?0?5Y?3@
	lea	eax, DWORD PTR _strLogString$227794[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4499 : 						LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227794[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4500 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227794[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@ExecuteInq:

; 4501 : 				}
; 4502 : 				else
; 4503 : 				{
; 4504 : 					CvAssertMsg(false, "Internal error with Inquisitor AI move, contact Ed.");
; 4505 : 				}
; 4506 : 			}
; 4507 : 			else

	jmp	$LN10@ExecuteInq
$LN6@ExecuteInq:

; 4508 : 			{
; 4509 : 				m_CurrentBestMoveHighPriorityUnit = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2404], 0

; 4510 : 				m_CurrentBestMoveUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T254303[ebp], ecx
	mov	edx, DWORD PTR $T254303[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2396], eax

; 4511 : 				ExecuteMoveToTarget(pTarget);

	mov	edx, DWORD PTR _pTarget$227783[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget

; 4512 : 
; 4513 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN10@ExecuteInq
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN10@ExecuteInq

; 4514 : 				{
; 4515 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227799[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 4516 : 					strLogString.Format("Moving to plot adjacent to heresy removal city, X: %d, Y: %d, Currently at, X: %d, Y: %d", pTarget->getX(), pTarget->getY(), pUnit->getX(), pUnit->getY());

	mov	edx, DWORD PTR _pUnit$227780[ebp]
	mov	DWORD PTR $T254311[ebp], edx
	mov	eax, DWORD PTR $T254311[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T254320[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227780[ebp]
	mov	DWORD PTR $T254324[ebp], edx
	mov	eax, DWORD PTR $T254324[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T254333[ebp], ecx
	mov	edx, DWORD PTR _pTarget$227783[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T254337[ebp], eax
	mov	ecx, DWORD PTR $T254320[ebp]
	push	ecx
	mov	edx, DWORD PTR $T254333[ebp]
	push	edx
	mov	eax, DWORD PTR $T254337[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarget$227783[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0FJ@IDAMCEHK@Moving?5to?5plot?5adjacent?5to?5heres@
	lea	eax, DWORD PTR _strLogString$227799[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 4517 : 					LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227799[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4518 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227799[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN10@ExecuteInq:

; 4519 : 			}
; 4520 : 		}
; 4521 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227780[ebp], 0
	je	SHORT $LN106@ExecuteInq
	mov	ecx, DWORD PTR _pUnit$227780[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN106@ExecuteInq:
	jmp	$LN13@ExecuteInq
$LN15@ExecuteInq:

; 4522 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227780[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ$1:
	mov	ecx, DWORD PTR $T254189[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$227788[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strLogString$227794[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLogString$227799[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::ExecuteInquisitorMoves
PUBLIC	??_C@_0CO@EAAOLMJN@Moving?5?$CFs?5to?5spaceship?5?9?5now?5at?0@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0CO@EAAOLMJN@Moving?5?$CFs?5to?5spaceship?5?9?5now?5at?0@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0CO@EAAOLMJN@Moving?5?$CFs?5to?5spaceship?5?9?5now?5at?0@ DB 'Movin'
	DB	'g %s to spaceship - now at, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ$2
__ehfuncinfo$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -164						; size = 4
$T254488 = -160						; size = 4
$T254479 = -156						; size = 4
$T254475 = -152						; size = 4
$T254466 = -148						; size = 4
$T254462 = -144						; size = 4
$T254456 = -140						; size = 4
$T254452 = -136						; size = 4
$T254440 = -132						; size = 4
$T254431 = -128						; size = 4
$T254424 = -124						; size = 4
$T254420 = -120						; size = 4
$T254411 = -116						; size = 4
$T254402 = -112						; size = 4
$T254386 = -108						; size = 4
$T254376 = -104						; size = 4
$T254372 = -100						; size = 4
_strLogString$227821 = -96				; size = 28
_strTemp$227822 = -68					; size = 28
__$ArrayPad$ = -40					; size = 4
_pUnit$227817 = -36					; size = 8
_it$227813 = -28					; size = 4
_iLoopCity$ = -24					; size = 4
_pCapitalCity$ = -20					; size = 4
_pLoopCity$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteSSPartMoves, COMDAT
; _this$ = ecx

; 4526 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4527 : 	CvCity* pLoopCity;
; 4528 : 	CvCity* pCapitalCity = NULL;

	mov	DWORD PTR _pCapitalCity$[ebp], 0

; 4529 : 	int iLoopCity = 0;

	mov	DWORD PTR _iLoopCity$[ebp], 0

; 4530 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	push	0
	lea	eax, DWORD PTR _iLoopCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN11@ExecuteSSP
$LN10@ExecuteSSP:
	push	0
	lea	edx, DWORD PTR _iLoopCity$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN11@ExecuteSSP:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN9@ExecuteSSP

; 4531 : 	{
; 4532 : 		if(pLoopCity->isCapital())

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@ExecuteSSP

; 4533 : 		{
; 4534 : 			pCapitalCity = pLoopCity;

	mov	edx, DWORD PTR _pLoopCity$[ebp]
	mov	DWORD PTR _pCapitalCity$[ebp], edx

; 4535 : 			break;

	jmp	SHORT $LN9@ExecuteSSP
$LN8@ExecuteSSP:

; 4536 : 		}
; 4537 : 	}

	jmp	SHORT $LN10@ExecuteSSP
$LN9@ExecuteSSP:

; 4538 : 
; 4539 : 	if(pCapitalCity != NULL)

	cmp	DWORD PTR _pCapitalCity$[ebp], 0
	je	$LN12@ExecuteSSP

; 4540 : 	{
; 4541 : 		FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 4542 : 		for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _it$227813[ebp], ecx
	jmp	SHORT $LN6@ExecuteSSP
$LN5@ExecuteSSP:
	mov	edx, DWORD PTR _it$227813[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$227813[ebp], edx
$LN6@ExecuteSSP:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T254372[ebp], eax
	mov	ecx, DWORD PTR $T254372[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T254372[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$227813[ebp], edx
	je	$LN12@ExecuteSSP

; 4543 : 		{
; 4544 : 			UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$227813[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T254376[ebp], edx
	mov	eax, DWORD PTR $T254376[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T254386[ebp], eax
	mov	edx, DWORD PTR $T254386[ebp]
	mov	DWORD PTR _pUnit$227817[ebp], edx
	mov	BYTE PTR _pUnit$227817[ebp+4], 0
	cmp	DWORD PTR _pUnit$227817[ebp], 0
	je	SHORT $LN24@ExecuteSSP
	mov	ecx, DWORD PTR _pUnit$227817[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN24@ExecuteSSP:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4545 : 			if(!pUnit)

	xor	eax, eax
	cmp	DWORD PTR _pUnit$227817[ebp], 0
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@ExecuteSSP

; 4546 : 			{
; 4547 : 				continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227817[ebp], 0
	je	SHORT $LN31@ExecuteSSP
	mov	ecx, DWORD PTR _pUnit$227817[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN31@ExecuteSSP:
	jmp	$LN5@ExecuteSSP
$LN3@ExecuteSSP:

; 4548 : 			}
; 4549 : 
; 4550 : 			if(pUnit->plot() != pCapitalCity->plot())

	mov	edx, DWORD PTR _pUnit$227817[ebp]
	mov	DWORD PTR $T254402[ebp], edx
	mov	ecx, DWORD PTR $T254402[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	esi, eax
	mov	ecx, DWORD PTR _pCapitalCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	cmp	esi, eax
	je	$LN2@ExecuteSSP

; 4551 : 			{
; 4552 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pCapitalCity->getX(), pCapitalCity->getY());

	mov	eax, DWORD PTR _pCapitalCity$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T254411[ebp], ecx
	mov	edx, DWORD PTR _pCapitalCity$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T254420[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227817[ebp]
	mov	DWORD PTR $T254424[ebp], ecx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR $T254411[ebp]
	push	edx
	mov	eax, DWORD PTR $T254420[ebp]
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T254424[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4553 : 				pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$227817[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4554 : 				UnitProcessed(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$227817[ebp]
	mov	DWORD PTR $T254431[ebp], ecx
	mov	edx, DWORD PTR $T254431[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T254440[ebp], eax
	mov	ecx, DWORD PTR $T254440[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 4555 : 
; 4556 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN2@ExecuteSSP
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	$LN2@ExecuteSSP

; 4557 : 				{
; 4558 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227821[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 4559 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227822[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 4560 : 					strTemp = pUnit->getUnitInfo().GetDescription();

	mov	ecx, DWORD PTR _pUnit$227817[ebp]
	mov	DWORD PTR $T254452[ebp], ecx
	mov	ecx, DWORD PTR $T254452[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	DWORD PTR $T254456[ebp], eax
	mov	ecx, DWORD PTR $T254456[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T254462[ebp], eax
	cmp	DWORD PTR $T254462[ebp], 0
	je	SHORT $LN66@ExecuteSSP
	mov	edx, DWORD PTR $T254462[ebp]
	push	edx
	lea	ecx, DWORD PTR _strTemp$227822[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN67@ExecuteSSP
$LN66@ExecuteSSP:
	lea	ecx, DWORD PTR _strTemp$227822[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN67@ExecuteSSP:

; 4561 : 					strLogString.Format("Moving %s to spaceship - now at, X: %d, Y: %d", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR _pUnit$227817[ebp]
	mov	DWORD PTR $T254466[ebp], eax
	mov	ecx, DWORD PTR $T254466[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T254475[ebp], edx
	mov	eax, DWORD PTR _pUnit$227817[ebp]
	mov	DWORD PTR $T254479[ebp], eax
	mov	ecx, DWORD PTR $T254479[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T254488[ebp], edx
	mov	eax, DWORD PTR $T254475[ebp]
	push	eax
	mov	ecx, DWORD PTR $T254488[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$227822[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CO@EAAOLMJN@Moving?5?$CFs?5to?5spaceship?5?9?5now?5at?0@
	lea	edx, DWORD PTR _strLogString$227821[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4562 : 					LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227821[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4563 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$227822[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227821[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@ExecuteSSP:

; 4564 : 			}
; 4565 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227817[ebp], 0
	je	SHORT $LN90@ExecuteSSP
	mov	ecx, DWORD PTR _pUnit$227817[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN90@ExecuteSSP:
	jmp	$LN5@ExecuteSSP
$LN12@ExecuteSSP:

; 4566 : 	}
; 4567 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227817[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$227821[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$227822[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-160]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteSSPartMoves
PUBLIC	??_C@_0DB@GGGJPMPN@Moving?5?$CFs?5to?5spaceship?5and?5addin@ ; `string'
PUBLIC	??_C@_0CF@FJJFLOOF@Adding?5?$CFs?5to?5spaceship?0?5X?3?5?$CFd?0?5Y@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getMISSION_SPACESHIP@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_SPACESHIP
;	COMDAT ??_C@_0DB@GGGJPMPN@Moving?5?$CFs?5to?5spaceship?5and?5addin@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0DB@GGGJPMPN@Moving?5?$CFs?5to?5spaceship?5and?5addin@ DB 'Moving %'
	DB	's to spaceship and adding it directly in', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@FJJFLOOF@Adding?5?$CFs?5to?5spaceship?0?5X?3?5?$CFd?0?5Y@
CONST	SEGMENT
??_C@_0CF@FJJFLOOF@Adding?5?$CFs?5to?5spaceship?0?5X?3?5?$CFd?0?5Y@ DB 'A'
	DB	'dding %s to spaceship, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ$5
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv322 = -280						; size = 4
tv321 = -276						; size = 4
_this$ = -272						; size = 4
$T254737 = -268						; size = 4
$T254728 = -264						; size = 4
$T254724 = -260						; size = 4
$T254715 = -256						; size = 4
$T254711 = -252						; size = 4
$T254705 = -248						; size = 4
$T254701 = -244						; size = 4
$T254689 = -240						; size = 4
$T254680 = -236						; size = 4
$T254673 = -232						; size = 4
$T254669 = -228						; size = 4
$T254665 = -224						; size = 4
$T254656 = -220						; size = 4
$T254647 = -216						; size = 4
$T254637 = -212						; size = 4
$T254628 = -208						; size = 4
$T254624 = -204						; size = 4
$T254609 = -200						; size = 4
$T254600 = -196						; size = 4
$T254596 = -192						; size = 4
$T254587 = -188						; size = 4
$T254583 = -184						; size = 4
$T254577 = -180						; size = 4
$T254573 = -176						; size = 4
$T254561 = -172						; size = 4
$T254545 = -168						; size = 4
$T254535 = -164						; size = 4
$T254531 = -160						; size = 4
$T254518 = -156						; size = 4
_strLogString$227851 = -152				; size = 28
_strTemp$227852 = -124					; size = 28
_strLogString$227844 = -96				; size = 28
_strTemp$227845 = -68					; size = 28
__$ArrayPad$ = -40					; size = 4
_pUnit$227840 = -36					; size = 8
_it$227836 = -28					; size = 4
_iLoopCity$ = -24					; size = 4
_pCapitalCity$ = -20					; size = 4
_pLoopCity$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteSSPartAdds, COMDAT
; _this$ = ecx

; 4571 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4572 : 	CvCity* pLoopCity;
; 4573 : 	CvCity* pCapitalCity = NULL;

	mov	DWORD PTR _pCapitalCity$[ebp], 0

; 4574 : 	int iLoopCity = 0;

	mov	DWORD PTR _iLoopCity$[ebp], 0

; 4575 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	push	0
	lea	eax, DWORD PTR _iLoopCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN14@ExecuteSSP@2
$LN13@ExecuteSSP@2:
	push	0
	lea	edx, DWORD PTR _iLoopCity$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN14@ExecuteSSP@2:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN12@ExecuteSSP@2

; 4576 : 	{
; 4577 : 		if(pLoopCity->isCapital())

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@ExecuteSSP@2

; 4578 : 		{
; 4579 : 			pCapitalCity = pLoopCity;

	mov	edx, DWORD PTR _pLoopCity$[ebp]
	mov	DWORD PTR _pCapitalCity$[ebp], edx

; 4580 : 			break;

	jmp	SHORT $LN12@ExecuteSSP@2
$LN11@ExecuteSSP@2:

; 4581 : 		}
; 4582 : 	}

	jmp	SHORT $LN13@ExecuteSSP@2
$LN12@ExecuteSSP@2:

; 4583 : 
; 4584 : 	if(pCapitalCity != NULL)

	cmp	DWORD PTR _pCapitalCity$[ebp], 0
	je	$LN15@ExecuteSSP@2

; 4585 : 	{
; 4586 : 		FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 4587 : 		for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _it$227836[ebp], ecx
	jmp	SHORT $LN9@ExecuteSSP@2
$LN8@ExecuteSSP@2:
	mov	edx, DWORD PTR _it$227836[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$227836[ebp], edx
$LN9@ExecuteSSP@2:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T254531[ebp], eax
	mov	ecx, DWORD PTR $T254531[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T254531[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$227836[ebp], edx
	je	$LN15@ExecuteSSP@2

; 4588 : 		{
; 4589 : 			UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$227836[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T254535[ebp], edx
	mov	eax, DWORD PTR $T254535[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T254545[ebp], eax
	mov	edx, DWORD PTR $T254545[ebp]
	mov	DWORD PTR _pUnit$227840[ebp], edx
	mov	BYTE PTR _pUnit$227840[ebp+4], 0
	cmp	DWORD PTR _pUnit$227840[ebp], 0
	je	SHORT $LN30@ExecuteSSP@2
	mov	ecx, DWORD PTR _pUnit$227840[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN30@ExecuteSSP@2:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4590 : 			if(!pUnit)

	xor	eax, eax
	cmp	DWORD PTR _pUnit$227840[ebp], 0
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@ExecuteSSP@2

; 4591 : 			{
; 4592 : 				continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227840[ebp], 0
	je	SHORT $LN37@ExecuteSSP@2
	mov	ecx, DWORD PTR _pUnit$227840[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN37@ExecuteSSP@2:
	jmp	$LN8@ExecuteSSP@2
$LN6@ExecuteSSP@2:

; 4593 : 			}
; 4594 : 
; 4595 : 			if(pUnit->plot() == pCapitalCity->plot())

	mov	edx, DWORD PTR _pUnit$227840[ebp]
	mov	DWORD PTR $T254561[ebp], edx
	mov	ecx, DWORD PTR $T254561[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	esi, eax
	mov	ecx, DWORD PTR _pCapitalCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	cmp	esi, eax
	jne	$LN5@ExecuteSSP@2

; 4596 : 			{
; 4597 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN4@ExecuteSSP@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@ExecuteSSP@2

; 4598 : 				{
; 4599 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227844[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 4600 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227845[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 4601 : 					strTemp = pUnit->getUnitInfo().GetDescription();

	mov	edx, DWORD PTR _pUnit$227840[ebp]
	mov	DWORD PTR $T254573[ebp], edx
	mov	ecx, DWORD PTR $T254573[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	DWORD PTR $T254577[ebp], eax
	mov	ecx, DWORD PTR $T254577[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T254583[ebp], eax
	cmp	DWORD PTR $T254583[ebp], 0
	je	SHORT $LN54@ExecuteSSP@2
	mov	eax, DWORD PTR $T254583[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTemp$227845[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN55@ExecuteSSP@2
$LN54@ExecuteSSP@2:
	lea	ecx, DWORD PTR _strTemp$227845[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN55@ExecuteSSP@2:

; 4602 : 					strLogString.Format("Adding %s to spaceship, X: %d, Y: %d", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

	mov	ecx, DWORD PTR _pUnit$227840[ebp]
	mov	DWORD PTR $T254587[ebp], ecx
	mov	edx, DWORD PTR $T254587[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T254596[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227840[ebp]
	mov	DWORD PTR $T254600[ebp], ecx
	mov	edx, DWORD PTR $T254600[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T254609[ebp], eax
	mov	ecx, DWORD PTR $T254596[ebp]
	push	ecx
	mov	edx, DWORD PTR $T254609[ebp]
	push	edx
	lea	ecx, DWORD PTR _strTemp$227845[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CF@FJJFLOOF@Adding?5?$CFs?5to?5spaceship?0?5X?3?5?$CFd?0?5Y@
	lea	eax, DWORD PTR _strLogString$227844[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4603 : 					LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227844[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4604 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$227845[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227844[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@ExecuteSSP@2:

; 4605 : 
; 4606 : 				pUnit->PushMission(CvTypes::getMISSION_SPACESHIP());

	mov	edx, DWORD PTR _pUnit$227840[ebp]
	mov	DWORD PTR $T254624[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SPACESHIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SPACESHIP
	push	eax
	mov	ecx, DWORD PTR $T254624[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4607 : 				UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR _pUnit$227840[ebp]
	mov	DWORD PTR $T254628[ebp], eax
	mov	ecx, DWORD PTR $T254628[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T254637[ebp], edx
	mov	eax, DWORD PTR $T254637[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed
	jmp	$LN3@ExecuteSSP@2
$LN5@ExecuteSSP@2:

; 4608 : 			}
; 4609 : 
; 4610 : 			else if (TurnsToReachTarget(pUnit, pCapitalCity->plot()) == 0)

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _pCapitalCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T254518[ebp], esp
	mov	DWORD PTR $T254647[ebp], ecx
	mov	edx, DWORD PTR $T254647[ebp]
	mov	eax, DWORD PTR _pUnit$227840[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T254647[ebp]
	mov	dl, BYTE PTR _pUnit$227840[ebp+4]
	mov	BYTE PTR [ecx+4], dl
	mov	eax, DWORD PTR $T254647[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN86@ExecuteSSP@2
	mov	ecx, DWORD PTR $T254647[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN86@ExecuteSSP@2:
	mov	edx, DWORD PTR $T254647[ebp]
	mov	DWORD PTR tv321[ebp], edx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv322[ebp], eax
	cmp	DWORD PTR tv322[ebp], 0
	jne	$LN3@ExecuteSSP@2

; 4611 : 			{
; 4612 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pCapitalCity->getX(), pCapitalCity->getY());

	mov	eax, DWORD PTR _pCapitalCity$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T254656[ebp], ecx
	mov	edx, DWORD PTR _pCapitalCity$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T254665[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227840[ebp]
	mov	DWORD PTR $T254669[ebp], ecx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR $T254656[ebp]
	push	edx
	mov	eax, DWORD PTR $T254665[ebp]
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T254669[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4613 : 				pUnit->PushMission(CvTypes::getMISSION_SPACESHIP());

	mov	ecx, DWORD PTR _pUnit$227840[ebp]
	mov	DWORD PTR $T254673[ebp], ecx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SPACESHIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SPACESHIP
	push	eax
	mov	ecx, DWORD PTR $T254673[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4614 : 				pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$227840[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4615 : 				UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$227840[ebp]
	mov	DWORD PTR $T254680[ebp], edx
	mov	eax, DWORD PTR $T254680[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T254689[ebp], ecx
	mov	edx, DWORD PTR $T254689[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 4616 : 
; 4617 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN3@ExecuteSSP@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@ExecuteSSP@2

; 4618 : 				{
; 4619 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227851[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 4620 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227852[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 4621 : 					strTemp = pUnit->getUnitInfo().GetDescription();

	mov	edx, DWORD PTR _pUnit$227840[ebp]
	mov	DWORD PTR $T254701[ebp], edx
	mov	ecx, DWORD PTR $T254701[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	DWORD PTR $T254705[ebp], eax
	mov	ecx, DWORD PTR $T254705[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T254711[ebp], eax
	cmp	DWORD PTR $T254711[ebp], 0
	je	SHORT $LN121@ExecuteSSP@2
	mov	eax, DWORD PTR $T254711[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTemp$227852[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN122@ExecuteSSP@2
$LN121@ExecuteSSP@2:
	lea	ecx, DWORD PTR _strTemp$227852[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN122@ExecuteSSP@2:

; 4622 : 					strLogString.Format("Moving %s to spaceship and adding it directly in", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

	mov	ecx, DWORD PTR _pUnit$227840[ebp]
	mov	DWORD PTR $T254715[ebp], ecx
	mov	edx, DWORD PTR $T254715[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T254724[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227840[ebp]
	mov	DWORD PTR $T254728[ebp], ecx
	mov	edx, DWORD PTR $T254728[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T254737[ebp], eax
	mov	ecx, DWORD PTR $T254724[ebp]
	push	ecx
	mov	edx, DWORD PTR $T254737[ebp]
	push	edx
	lea	ecx, DWORD PTR _strTemp$227852[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0DB@GGGJPMPN@Moving?5?$CFs?5to?5spaceship?5and?5addin@
	lea	eax, DWORD PTR _strLogString$227851[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4623 : 					LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227851[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4624 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strTemp$227852[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227851[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@ExecuteSSP@2:

; 4625 : 			}
; 4626 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227840[ebp], 0
	je	SHORT $LN145@ExecuteSSP@2
	mov	ecx, DWORD PTR _pUnit$227840[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN145@ExecuteSSP@2:
	jmp	$LN8@ExecuteSSP@2
$LN15@ExecuteSSP@2:

; 4627 : 	}
; 4628 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227840[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$227844[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$227845[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLogString$227851[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strTemp$227852[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-276]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteSSPartAdds
PUBLIC	??_C@_0CM@LFGGHPCB@Moving?5?$CFs?5to?5capital?5?9?5now?5at?0?5X@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0CM@LFGGHPCB@Moving?5?$CFs?5to?5capital?5?9?5now?5at?0?5X@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0CM@LFGGHPCB@Moving?5?$CFs?5to?5capital?5?9?5now?5at?0?5X@ DB 'Movi'
	DB	'ng %s to capital - now at, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ$2
__ehfuncinfo$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -160						; size = 4
$T254888 = -156						; size = 4
$T254879 = -152						; size = 4
$T254875 = -148						; size = 4
$T254866 = -144						; size = 4
$T254862 = -140						; size = 4
$T254856 = -136						; size = 4
$T254852 = -132						; size = 4
$T254840 = -128						; size = 4
$T254831 = -124						; size = 4
$T254824 = -120						; size = 4
$T254820 = -116						; size = 4
$T254811 = -112						; size = 4
$T254790 = -108						; size = 4
$T254780 = -104						; size = 4
$T254776 = -100						; size = 4
_strLogString$227873 = -96				; size = 28
_strTemp$227874 = -68					; size = 28
__$ArrayPad$ = -40					; size = 4
_pUnit$227870 = -36					; size = 8
_it$227866 = -28					; size = 4
_iLoopCity$ = -24					; size = 4
_pCapitalCity$ = -20					; size = 4
_pLoopCity$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteTreasureMoves, COMDAT
; _this$ = ecx

; 4632 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4633 : 	CvCity* pLoopCity;
; 4634 : 	CvCity* pCapitalCity = NULL;

	mov	DWORD PTR _pCapitalCity$[ebp], 0

; 4635 : 	int iLoopCity = 0;

	mov	DWORD PTR _iLoopCity$[ebp], 0

; 4636 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	push	0
	lea	eax, DWORD PTR _iLoopCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN10@ExecuteTre
$LN9@ExecuteTre:
	push	0
	lea	edx, DWORD PTR _iLoopCity$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN10@ExecuteTre:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN8@ExecuteTre

; 4637 : 	{
; 4638 : 		if(pLoopCity->isCapital())

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@ExecuteTre

; 4639 : 		{
; 4640 : 			pCapitalCity = pLoopCity;

	mov	edx, DWORD PTR _pLoopCity$[ebp]
	mov	DWORD PTR _pCapitalCity$[ebp], edx

; 4641 : 			break;

	jmp	SHORT $LN8@ExecuteTre
$LN7@ExecuteTre:

; 4642 : 		}
; 4643 : 	}

	jmp	SHORT $LN9@ExecuteTre
$LN8@ExecuteTre:

; 4644 : 
; 4645 : 	if(pCapitalCity != NULL)

	cmp	DWORD PTR _pCapitalCity$[ebp], 0
	je	$LN11@ExecuteTre

; 4646 : 	{
; 4647 : 		FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 4648 : 		for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _it$227866[ebp], ecx
	jmp	SHORT $LN5@ExecuteTre
$LN4@ExecuteTre:
	mov	edx, DWORD PTR _it$227866[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$227866[ebp], edx
$LN5@ExecuteTre:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T254776[ebp], eax
	mov	ecx, DWORD PTR $T254776[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T254776[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$227866[ebp], edx
	je	$LN11@ExecuteTre

; 4649 : 		{
; 4650 : 			UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$227866[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T254780[ebp], edx
	mov	eax, DWORD PTR $T254780[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T254790[ebp], eax
	mov	edx, DWORD PTR $T254790[ebp]
	mov	DWORD PTR _pUnit$227870[ebp], edx
	mov	BYTE PTR _pUnit$227870[ebp+4], 0
	cmp	DWORD PTR _pUnit$227870[ebp], 0
	je	SHORT $LN23@ExecuteTre
	mov	ecx, DWORD PTR _pUnit$227870[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN23@ExecuteTre:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4651 : 			if(!pUnit)

	xor	eax, eax
	cmp	DWORD PTR _pUnit$227870[ebp], 0
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN36@ExecuteTre

; 4652 : 			{
; 4653 : 				continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227870[ebp], 0
	je	SHORT $LN30@ExecuteTre
	mov	ecx, DWORD PTR _pUnit$227870[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN30@ExecuteTre:
	jmp	$LN4@ExecuteTre

; 4654 : 			}
; 4655 : 
; 4656 : 			pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pCapitalCity->getX(), pCapitalCity->getY());

$LN36@ExecuteTre:
	mov	edx, DWORD PTR _pCapitalCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T254811[ebp], eax
	mov	ecx, DWORD PTR _pCapitalCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T254820[ebp], edx
	mov	eax, DWORD PTR _pUnit$227870[ebp]
	mov	DWORD PTR $T254824[ebp], eax
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR $T254811[ebp]
	push	ecx
	mov	edx, DWORD PTR $T254820[ebp]
	push	edx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR $T254824[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4657 : 			pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$227870[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4658 : 			UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR _pUnit$227870[ebp]
	mov	DWORD PTR $T254831[ebp], eax
	mov	ecx, DWORD PTR $T254831[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T254840[ebp], edx
	mov	eax, DWORD PTR $T254840[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 4659 : 
; 4660 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN1@ExecuteTre
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN1@ExecuteTre

; 4661 : 			{
; 4662 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227873[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 4663 : 				CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227874[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 4664 : 				strTemp = pUnit->getUnitInfo().GetDescription();

	mov	eax, DWORD PTR _pUnit$227870[ebp]
	mov	DWORD PTR $T254852[ebp], eax
	mov	ecx, DWORD PTR $T254852[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	DWORD PTR $T254856[ebp], eax
	mov	ecx, DWORD PTR $T254856[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T254862[ebp], eax
	cmp	DWORD PTR $T254862[ebp], 0
	je	SHORT $LN63@ExecuteTre
	mov	ecx, DWORD PTR $T254862[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$227874[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN64@ExecuteTre
$LN63@ExecuteTre:
	lea	ecx, DWORD PTR _strTemp$227874[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN64@ExecuteTre:

; 4665 : 				strLogString.Format("Moving %s to capital - now at, X: %d, Y: %d", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

	mov	edx, DWORD PTR _pUnit$227870[ebp]
	mov	DWORD PTR $T254866[ebp], edx
	mov	eax, DWORD PTR $T254866[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T254875[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227870[ebp]
	mov	DWORD PTR $T254879[ebp], edx
	mov	eax, DWORD PTR $T254879[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T254888[ebp], ecx
	mov	edx, DWORD PTR $T254875[ebp]
	push	edx
	mov	eax, DWORD PTR $T254888[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTemp$227874[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CM@LFGGHPCB@Moving?5?$CFs?5to?5capital?5?9?5now?5at?0?5X@
	lea	ecx, DWORD PTR _strLogString$227873[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4666 : 				LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227873[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4667 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$227874[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227873[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteTre:

; 4668 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227870[ebp], 0
	je	SHORT $LN87@ExecuteTre
	mov	ecx, DWORD PTR _pUnit$227870[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN87@ExecuteTre:
	jmp	$LN4@ExecuteTre
$LN11@ExecuteTre:

; 4669 : 	}
; 4670 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227870[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$227873[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$227874[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-152]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteTreasureMoves
PUBLIC	??_C@_0CM@GHFJOEKD@No?5better?5place?5to?5move?5?$CFs?5at?0?5X@ ; `string'
PUBLIC	??_C@_0CC@IJNALDOH@Rebasing?5?$CFs?5onto?5?$CFs?0?5X?3?5?$CFd?0?5Y?3?5?$CF@ ; `string'
PUBLIC	??_C@_0CL@LBILOFEO@Rebasing?5?$CFs?5to?5city?5garrison?0?5X?3@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getMISSION_REBASE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_REBASE
EXTRN	?IsRazing@CvCity@@QBE_NXZ:PROC			; CvCity::IsRazing
EXTRN	?GetMaxHitPoints@CvCity@@QBEHXZ:PROC		; CvCity::GetMaxHitPoints
EXTRN	?canLoadUnit@CvUnit@@QBE_NABV1@ABVCvPlot@@@Z:PROC ; CvUnit::canLoadUnit
EXTRN	?canRebaseAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z:PROC	; CvUnit::canRebaseAt
;	COMDAT ??_C@_0CM@GHFJOEKD@No?5better?5place?5to?5move?5?$CFs?5at?0?5X@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0CM@GHFJOEKD@No?5better?5place?5to?5move?5?$CFs?5at?0?5X@ DB 'No be'
	DB	'tter place to move %s at, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@IJNALDOH@Rebasing?5?$CFs?5onto?5?$CFs?0?5X?3?5?$CFd?0?5Y?3?5?$CF@
CONST	SEGMENT
??_C@_0CC@IJNALDOH@Rebasing?5?$CFs?5onto?5?$CFs?0?5X?3?5?$CFd?0?5Y?3?5?$CF@ DB 'R'
	DB	'ebasing %s onto %s, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LBILOFEO@Rebasing?5?$CFs?5to?5city?5garrison?0?5X?3@
CONST	SEGMENT
??_C@_0CL@LBILOFEO@Rebasing?5?$CFs?5to?5city?5garrison?0?5X?3@ DB 'Rebasi'
	DB	'ng %s to city garrison, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$3
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$5
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -368						; size = 4
$T255163 = -364						; size = 4
$T255154 = -360						; size = 4
$T255150 = -356						; size = 4
$T255141 = -352						; size = 4
$T255133 = -348						; size = 4
$T255127 = -344						; size = 4
$T255123 = -340						; size = 4
$T255115 = -336						; size = 4
$T255106 = -332						; size = 4
$T255084 = -328						; size = 4
$T255080 = -324						; size = 4
$T255076 = -320						; size = 4
$T255069 = -316						; size = 4
$T255065 = -312						; size = 4
$T255056 = -304						; size = 4
$T255050 = -300						; size = 4
$T255046 = -296						; size = 4
$T255040 = -292						; size = 4
$T255036 = -288						; size = 4
$T255020 = -284						; size = 4
$T255011 = -280						; size = 4
$T255004 = -276						; size = 4
$T255000 = -272						; size = 4
$T254996 = -268						; size = 4
$T254992 = -264						; size = 4
$T254988 = -260						; size = 4
$T254984 = -256						; size = 4
$T254980 = -252						; size = 4
$T254976 = -248						; size = 4
$T254972 = -244						; size = 4
$T254968 = -240						; size = 4
$T254964 = -236						; size = 4
$T254960 = -232						; size = 4
$T254944 = -228						; size = 4
$T254934 = -224						; size = 4
$T254930 = -220						; size = 4
_strLogString$227926 = -216				; size = 28
_strTemp$227925 = -188					; size = 28
_strTemp2$227917 = -160					; size = 28
_strLogString$227915 = -132				; size = 28
_strTemp$227916 = -104					; size = 28
__$ArrayPad$ = -76					; size = 4
_iPlotDanger$227911 = -72				; size = 4
_pTarget$227907 = -68					; size = 4
_iPlotDanger$227899 = -64				; size = 4
_pLoopUnitPlot$227895 = -60				; size = 4
_pLoopUnit$227891 = -56					; size = 4
_pUnit$227884 = -52					; size = 8
_iLoopCity$227903 = -44					; size = 4
_pUnitPlot$227886 = -40					; size = 4
_iMostDangerous$227889 = -36				; size = 4
_pBestPlot$227888 = -32					; size = 4
_iLoopUnit$227890 = -28					; size = 4
_pTransportUnit$227887 = -24				; size = 4
_pLoopCity$227902 = -20					; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteAircraftMoves, COMDAT
; _this$ = ecx

; 4674 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 356				; 00000164H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4675 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 4676 : 
; 4677 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN26@ExecuteAir
$LN25@ExecuteAir:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], edx
$LN26@ExecuteAir:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T254930[ebp], eax
	mov	ecx, DWORD PTR $T254930[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T254930[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN27@ExecuteAir

; 4678 : 	{
; 4679 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T254934[ebp], edx
	mov	eax, DWORD PTR $T254934[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T254944[ebp], eax
	mov	edx, DWORD PTR $T254944[ebp]
	mov	DWORD PTR _pUnit$227884[ebp], edx
	mov	BYTE PTR _pUnit$227884[ebp+4], 0
	cmp	DWORD PTR _pUnit$227884[ebp], 0
	je	SHORT $LN42@ExecuteAir
	mov	ecx, DWORD PTR _pUnit$227884[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN42@ExecuteAir:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4680 : 		if(!pUnit)

	xor	eax, eax
	cmp	DWORD PTR _pUnit$227884[ebp], 0
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN23@ExecuteAir

; 4681 : 		{
; 4682 : 			continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227884[ebp], 0
	je	SHORT $LN49@ExecuteAir
	mov	ecx, DWORD PTR _pUnit$227884[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN49@ExecuteAir:
	jmp	$LN25@ExecuteAir
$LN23@ExecuteAir:

; 4683 : 		}
; 4684 : 
; 4685 : 		CvPlot* pUnitPlot = pUnit->plot();

	mov	edx, DWORD PTR _pUnit$227884[ebp]
	mov	DWORD PTR $T254960[ebp], edx
	mov	ecx, DWORD PTR $T254960[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pUnitPlot$227886[ebp], eax

; 4686 : 		CvUnit* pTransportUnit = NULL;

	mov	DWORD PTR _pTransportUnit$227887[ebp], 0

; 4687 : 		CvPlot* pBestPlot = NULL;

	mov	DWORD PTR _pBestPlot$227888[ebp], 0

; 4688 : 		int iMostDangerous = 0;

	mov	DWORD PTR _iMostDangerous$227889[ebp], 0

; 4689 : 
; 4690 : 		// first look for open carrier slots
; 4691 : 		int iLoopUnit = 0;

	mov	DWORD PTR _iLoopUnit$227890[ebp], 0

; 4692 : 		for(CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoopUnit))

	push	0
	lea	eax, DWORD PTR _iLoopUnit$227890[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$227891[ebp], eax
	jmp	SHORT $LN22@ExecuteAir
$LN21@ExecuteAir:
	push	0
	lea	edx, DWORD PTR _iLoopUnit$227890[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$227891[ebp], eax
$LN22@ExecuteAir:
	cmp	DWORD PTR _pLoopUnit$227891[ebp], 0
	je	$LN20@ExecuteAir

; 4693 : 		{
; 4694 : 			CvPlot* pLoopUnitPlot = pLoopUnit->plot();

	mov	ecx, DWORD PTR _pLoopUnit$227891[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pLoopUnitPlot$227895[ebp], eax

; 4695 : 
; 4696 : 			if(pLoopUnit->getDamage() > (GC.getMAX_HIT_POINTS() / 5))  // this might not be a good place to land

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	DWORD PTR $T254964[ebp], ecx
	mov	ecx, DWORD PTR _pLoopUnit$227891[ebp]
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ecx, eax
	mov	eax, DWORD PTR $T254964[ebp]
	cdq
	mov	esi, 5
	idiv	esi
	cmp	ecx, eax
	jle	SHORT $LN19@ExecuteAir

; 4697 : 			{
; 4698 : 				continue;

	jmp	SHORT $LN21@ExecuteAir
$LN19@ExecuteAir:

; 4699 : 			}
; 4700 : 
; 4701 : 			if(pBestPlot != pUnitPlot && !pUnit->canRebaseAt(pUnitPlot, pLoopUnitPlot->getX(),pLoopUnitPlot->getY()))

	mov	edx, DWORD PTR _pBestPlot$227888[ebp]
	cmp	edx, DWORD PTR _pUnitPlot$227886[ebp]
	je	SHORT $LN18@ExecuteAir
	mov	eax, DWORD PTR _pLoopUnitPlot$227895[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T254968[ebp], ecx
	mov	edx, DWORD PTR _pLoopUnitPlot$227895[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T254972[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227884[ebp]
	mov	DWORD PTR $T254976[ebp], ecx
	mov	edx, DWORD PTR $T254968[ebp]
	push	edx
	mov	eax, DWORD PTR $T254972[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnitPlot$227886[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T254976[ebp]
	call	?canRebaseAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z ; CvUnit::canRebaseAt
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN18@ExecuteAir

; 4702 : 			{
; 4703 : 				continue;

	jmp	$LN21@ExecuteAir
$LN18@ExecuteAir:

; 4704 : 			}
; 4705 : 
; 4706 : 			if(!pUnit->canLoadUnit(*pLoopUnit, *pLoopUnitPlot))

	mov	eax, DWORD PTR _pUnit$227884[ebp]
	mov	DWORD PTR $T254980[ebp], eax
	mov	ecx, DWORD PTR _pLoopUnitPlot$227895[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLoopUnit$227891[ebp]
	push	edx
	mov	ecx, DWORD PTR $T254980[ebp]
	call	?canLoadUnit@CvUnit@@QBE_NABV1@ABVCvPlot@@@Z ; CvUnit::canLoadUnit
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN17@ExecuteAir

; 4707 : 			{
; 4708 : 				continue;

	jmp	$LN21@ExecuteAir
$LN17@ExecuteAir:

; 4709 : 			}
; 4710 : 
; 4711 : 			int iPlotDanger = m_pPlayer->GetPlotDanger(*pLoopUnitPlot);

	mov	ecx, DWORD PTR _pLoopUnitPlot$227895[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	mov	DWORD PTR _iPlotDanger$227899[ebp], eax

; 4712 : 			if (pLoopUnit->getArmyID() != FFreeList::INVALID_INDEX)

	mov	ecx, DWORD PTR _pLoopUnit$227891[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	je	SHORT $LN16@ExecuteAir

; 4713 : 			{
; 4714 : 				iPlotDanger += 5000;

	mov	eax, DWORD PTR _iPlotDanger$227899[ebp]
	add	eax, 5000				; 00001388H
	mov	DWORD PTR _iPlotDanger$227899[ebp], eax
$LN16@ExecuteAir:

; 4715 : 			}
; 4716 : 			if(iPlotDanger >= iMostDangerous)

	mov	ecx, DWORD PTR _iPlotDanger$227899[ebp]
	cmp	ecx, DWORD PTR _iMostDangerous$227889[ebp]
	jl	SHORT $LN15@ExecuteAir

; 4717 : 			{
; 4718 : 				iMostDangerous = iPlotDanger;

	mov	edx, DWORD PTR _iPlotDanger$227899[ebp]
	mov	DWORD PTR _iMostDangerous$227889[ebp], edx

; 4719 : 				pBestPlot = pLoopUnitPlot;

	mov	eax, DWORD PTR _pLoopUnitPlot$227895[ebp]
	mov	DWORD PTR _pBestPlot$227888[ebp], eax

; 4720 : 				pTransportUnit = pLoopUnit;

	mov	ecx, DWORD PTR _pLoopUnit$227891[ebp]
	mov	DWORD PTR _pTransportUnit$227887[ebp], ecx
$LN15@ExecuteAir:

; 4721 : 			}
; 4722 : 
; 4723 : 		}

	jmp	$LN21@ExecuteAir
$LN20@ExecuteAir:

; 4724 : 
; 4725 : 		CvCity* pLoopCity;
; 4726 : 		int iLoopCity = 0;

	mov	DWORD PTR _iLoopCity$227903[ebp], 0

; 4727 : 		for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	push	0
	lea	edx, DWORD PTR _iLoopCity$227903[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$227902[ebp], eax
	jmp	SHORT $LN14@ExecuteAir
$LN13@ExecuteAir:
	push	0
	lea	ecx, DWORD PTR _iLoopCity$227903[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$227902[ebp], eax
$LN14@ExecuteAir:
	cmp	DWORD PTR _pLoopCity$227902[ebp], 0
	je	$LN12@ExecuteAir

; 4728 : 		{
; 4729 : 			CvPlot* pTarget = pLoopCity->plot();

	mov	ecx, DWORD PTR _pLoopCity$227902[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pTarget$227907[ebp], eax

; 4730 : 
; 4731 : 			if(pLoopCity->getDamage() > (pLoopCity->GetMaxHitPoints() / 5))

	mov	ecx, DWORD PTR _pLoopCity$227902[ebp]
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	mov	esi, eax
	mov	ecx, DWORD PTR _pLoopCity$227902[ebp]
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	cdq
	mov	ecx, 5
	idiv	ecx
	cmp	esi, eax
	jle	SHORT $LN11@ExecuteAir

; 4732 : 			{
; 4733 : 				continue;

	jmp	SHORT $LN13@ExecuteAir
$LN11@ExecuteAir:

; 4734 : 			}
; 4735 : 
; 4736 : 			if(pBestPlot != pUnitPlot && !pUnit->canRebaseAt(pUnitPlot,pTarget->getX(),pTarget->getY()))

	mov	edx, DWORD PTR _pBestPlot$227888[ebp]
	cmp	edx, DWORD PTR _pUnitPlot$227886[ebp]
	je	SHORT $LN10@ExecuteAir
	mov	eax, DWORD PTR _pTarget$227907[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T254984[ebp], ecx
	mov	edx, DWORD PTR _pTarget$227907[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T254988[ebp], eax
	mov	ecx, DWORD PTR _pUnit$227884[ebp]
	mov	DWORD PTR $T254992[ebp], ecx
	mov	edx, DWORD PTR $T254984[ebp]
	push	edx
	mov	eax, DWORD PTR $T254988[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnitPlot$227886[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T254992[ebp]
	call	?canRebaseAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z ; CvUnit::canRebaseAt
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN10@ExecuteAir

; 4737 : 			{
; 4738 : 				continue;

	jmp	$LN13@ExecuteAir
$LN10@ExecuteAir:

; 4739 : 			}
; 4740 : 
; 4741 : 			if (pLoopCity->IsRazing())

	mov	ecx, DWORD PTR _pLoopCity$227902[ebp]
	call	?IsRazing@CvCity@@QBE_NXZ		; CvCity::IsRazing
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@ExecuteAir

; 4742 : 			{
; 4743 : 				continue;

	jmp	$LN13@ExecuteAir
$LN9@ExecuteAir:

; 4744 : 			}
; 4745 : 
; 4746 : 			int iPlotDanger = m_pPlayer->GetPlotDanger(*pTarget);

	mov	ecx, DWORD PTR _pTarget$227907[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	mov	DWORD PTR _iPlotDanger$227911[ebp], eax

; 4747 : 			if(iPlotDanger >= iMostDangerous)

	mov	eax, DWORD PTR _iPlotDanger$227911[ebp]
	cmp	eax, DWORD PTR _iMostDangerous$227889[ebp]
	jl	SHORT $LN8@ExecuteAir

; 4748 : 			{
; 4749 : 				iMostDangerous = iPlotDanger;

	mov	ecx, DWORD PTR _iPlotDanger$227911[ebp]
	mov	DWORD PTR _iMostDangerous$227889[ebp], ecx

; 4750 : 				pBestPlot = pTarget;

	mov	edx, DWORD PTR _pTarget$227907[ebp]
	mov	DWORD PTR _pBestPlot$227888[ebp], edx

; 4751 : 				pTransportUnit = NULL;

	mov	DWORD PTR _pTransportUnit$227887[ebp], 0
$LN8@ExecuteAir:

; 4752 : 			}
; 4753 : 		}

	jmp	$LN13@ExecuteAir
$LN12@ExecuteAir:

; 4754 : 
; 4755 : 		if(pBestPlot && pBestPlot != pUnitPlot)

	cmp	DWORD PTR _pBestPlot$227888[ebp], 0
	je	$LN136@ExecuteAir
	mov	eax, DWORD PTR _pBestPlot$227888[ebp]
	cmp	eax, DWORD PTR _pUnitPlot$227886[ebp]
	je	$LN136@ExecuteAir

; 4756 : 		{
; 4757 : 			pUnit->PushMission(CvTypes::getMISSION_REBASE(), pBestPlot->getX(), pBestPlot->getY());

	mov	ecx, DWORD PTR _pBestPlot$227888[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T254996[ebp], edx
	mov	eax, DWORD PTR _pBestPlot$227888[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T255000[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227884[ebp]
	mov	DWORD PTR $T255004[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR $T254996[ebp]
	push	eax
	mov	ecx, DWORD PTR $T255000[ebp]
	push	ecx
	call	?getMISSION_REBASE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_REBASE
	push	eax
	mov	ecx, DWORD PTR $T255004[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4758 : 			pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$227884[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4759 : 			UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$227884[ebp]
	mov	DWORD PTR $T255011[ebp], edx
	mov	eax, DWORD PTR $T255011[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T255020[ebp], ecx
	mov	edx, DWORD PTR $T255020[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 4760 : 
; 4761 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN6@ExecuteAir
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@ExecuteAir

; 4762 : 			{
; 4763 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227915[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 4764 : 				CvString strTemp, strTemp2;

	lea	ecx, DWORD PTR _strTemp$227916[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strTemp2$227917[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 4765 : #ifdef AUI_WARNING_FIXES
; 4766 : 				strTemp = pUnit->getUnitInfo().GetDescription();
; 4767 : 				if (pTransportUnit)
; 4768 : 				{
; 4769 : 					strTemp2 = pTransportUnit->getUnitInfo().GetDescription();
; 4770 : #else
; 4771 : 				strTemp = GC.getUnitInfo(pUnit->getUnitType())->GetDescription();

	mov	edx, DWORD PTR _pUnit$227884[ebp]
	mov	DWORD PTR $T255036[ebp], edx
	mov	ecx, DWORD PTR $T255036[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR $T255040[ebp], eax
	mov	ecx, DWORD PTR $T255040[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T255046[ebp], eax
	cmp	DWORD PTR $T255046[ebp], 0
	je	SHORT $LN99@ExecuteAir
	mov	eax, DWORD PTR $T255046[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTemp$227916[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN100@ExecuteAir
$LN99@ExecuteAir:
	lea	ecx, DWORD PTR _strTemp$227916[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN100@ExecuteAir:

; 4772 : 				if (pTransportUnit)

	cmp	DWORD PTR _pTransportUnit$227887[ebp], 0
	je	SHORT $LN5@ExecuteAir

; 4773 : 				{
; 4774 : 					strTemp2 = GC.getUnitInfo(pTransportUnit->getUnitType())->GetDescription();

	mov	ecx, DWORD PTR _pTransportUnit$227887[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR $T255050[ebp], eax
	mov	ecx, DWORD PTR $T255050[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T255056[ebp], eax
	cmp	DWORD PTR $T255056[ebp], 0
	je	SHORT $LN105@ExecuteAir
	mov	ecx, DWORD PTR $T255056[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp2$227917[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN5@ExecuteAir
$LN105@ExecuteAir:
	lea	ecx, DWORD PTR _strTemp2$227917[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN5@ExecuteAir:

; 4775 : #endif
; 4776 : 				}
; 4777 : 
; 4778 : 				if (pBestPlot->getPlotCity())

	mov	ecx, DWORD PTR _pBestPlot$227888[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	test	eax, eax
	je	SHORT $LN4@ExecuteAir

; 4779 : 				{
; 4780 : 					strLogString.Format("Rebasing %s to city garrison, X: %d, Y: %d", strTemp.GetCString(), pBestPlot->getX(), pBestPlot->getY());

	mov	edx, DWORD PTR _pBestPlot$227888[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T255065[ebp], eax
	mov	ecx, DWORD PTR _pBestPlot$227888[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T255069[ebp], edx
	mov	eax, DWORD PTR $T255065[ebp]
	push	eax
	mov	ecx, DWORD PTR $T255069[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$227916[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CL@LBILOFEO@Rebasing?5?$CFs?5to?5city?5garrison?0?5X?3@
	lea	edx, DWORD PTR _strLogString$227915[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4781 : 				}
; 4782 : 				else

	jmp	SHORT $LN3@ExecuteAir
$LN4@ExecuteAir:

; 4783 : 				{
; 4784 : 					strLogString.Format("Rebasing %s onto %s, X: %d, Y: %d", strTemp.GetCString(), strTemp2.GetCString(), pBestPlot->getX(), pBestPlot->getY());

	mov	eax, DWORD PTR _pBestPlot$227888[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T255076[ebp], ecx
	mov	edx, DWORD PTR _pBestPlot$227888[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T255080[ebp], eax
	lea	ecx, DWORD PTR _strTemp2$227917[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T255084[ebp], eax
	mov	ecx, DWORD PTR $T255076[ebp]
	push	ecx
	mov	edx, DWORD PTR $T255080[ebp]
	push	edx
	mov	eax, DWORD PTR $T255084[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTemp$227916[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CC@IJNALDOH@Rebasing?5?$CFs?5onto?5?$CFs?0?5X?3?5?$CFd?0?5Y?3?5?$CF@
	lea	ecx, DWORD PTR _strLogString$227915[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H
$LN3@ExecuteAir:

; 4785 : 				}
; 4786 : 				LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227915[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4787 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strTemp2$227917[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$227916[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227915[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@ExecuteAir:

; 4788 : 		}
; 4789 : 		else

	jmp	$LN2@ExecuteAir

; 4790 : 		{
; 4791 : 			pUnit->finishMoves();

$LN136@ExecuteAir:
	mov	ecx, DWORD PTR _pUnit$227884[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4792 : 			UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR _pUnit$227884[ebp]
	mov	DWORD PTR $T255106[ebp], eax
	mov	ecx, DWORD PTR $T255106[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T255115[ebp], edx
	mov	eax, DWORD PTR $T255115[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 4793 : 
; 4794 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@ExecuteAir
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN2@ExecuteAir

; 4795 : 			{
; 4796 : #ifdef AUI_WARNING_FIXES
; 4797 : 				CvString strTemp = pUnit->getUnitInfo().GetDescription();
; 4798 : #else
; 4799 : 				CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227925[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 4800 : 				strTemp = GC.getUnitInfo(pUnit->getUnitType())->GetDescription();

	mov	eax, DWORD PTR _pUnit$227884[ebp]
	mov	DWORD PTR $T255123[ebp], eax
	mov	ecx, DWORD PTR $T255123[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR $T255127[ebp], eax
	mov	ecx, DWORD PTR $T255127[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T255133[ebp], eax
	cmp	DWORD PTR $T255133[ebp], 0
	je	SHORT $LN152@ExecuteAir
	mov	ecx, DWORD PTR $T255133[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$227925[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN153@ExecuteAir
$LN152@ExecuteAir:
	lea	ecx, DWORD PTR _strTemp$227925[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN153@ExecuteAir:

; 4801 : #endif
; 4802 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227926[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 4803 : 				strLogString.Format("No better place to move %s at, X: %d, Y: %d", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

	mov	edx, DWORD PTR _pUnit$227884[ebp]
	mov	DWORD PTR $T255141[ebp], edx
	mov	eax, DWORD PTR $T255141[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T255150[ebp], ecx
	mov	edx, DWORD PTR _pUnit$227884[ebp]
	mov	DWORD PTR $T255154[ebp], edx
	mov	eax, DWORD PTR $T255154[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T255163[ebp], ecx
	mov	edx, DWORD PTR $T255150[ebp]
	push	edx
	mov	eax, DWORD PTR $T255163[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTemp$227925[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CM@GHFJOEKD@No?5better?5place?5to?5move?5?$CFs?5at?0?5X@
	lea	ecx, DWORD PTR _strLogString$227926[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4804 : 				LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227926[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4805 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _strLogString$227926[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strTemp$227925[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@ExecuteAir:

; 4806 : 		}
; 4807 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$227884[ebp], 0
	je	SHORT $LN179@ExecuteAir
	mov	ecx, DWORD PTR _pUnit$227884[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN179@ExecuteAir:
	jmp	$LN25@ExecuteAir
$LN27@ExecuteAir:

; 4808 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227884[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$227915[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$227916[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strTemp2$227917[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strTemp$227925[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strLogString$227926[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-364]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteAircraftMoves
PUBLIC	??_C@_0EL@FMPFMLM@?$CFs?5?$CI?$CFd?$CJ?5tried?5to?5move?5to?5a?5safe?5@ ; `string'
PUBLIC	??_C@_0CH@JIBDOEGJ@?$CFs?5?$CI?$CFd?$CJ?5moving?5to?5safety?0?5X?3?5?$CFd?0@ ; `string'
PUBLIC	??_C@_0FC@JAIEONKP@?$CFs?5?$CI?$CFd?$CJ?5tried?5to?5move?5to?5safety?5@ ; `string'
PUBLIC	??_C@_0EG@KOMOJBJG@?$CFs?5?$CI?$CFd?$CJ?5tried?5to?5move?5to?5safety?5@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?canHold@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canHold
EXTRN	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z:PROC		; CvUnit::atPlot
EXTRN	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z:PROC ; CvUnit::GeneratePath
EXTRN	?GetMaxDefenseStrength@CvUnit@@QBEHPBVCvPlot@@PBV1@_N@Z:PROC ; CvUnit::GetMaxDefenseStrength
EXTRN	?isWaiting@CvUnit@@QBE_NXZ:PROC			; CvUnit::isWaiting
EXTRN	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z:PROC ; CvPlot::nextUnitNode
EXTRN	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z:PROC	; getUnit
EXTRN	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ:PROC	; CvPlot::headUnitNode
EXTRN	?getStrengthValue@CvCity@@QBEH_N@Z:PROC		; CvCity::getStrengthValue
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
EXTRN	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z:PROC ; CvPlot::isVisibleEnemyUnit
EXTRN	?PlotValid@CvUnit@@QBE_NPAVCvPlot@@@Z:PROC	; CvUnit::PlotValid
EXTRN	?SearchRange@CvUnit@@QBEHH@Z:PROC		; CvUnit::SearchRange
;	COMDAT ??_C@_0EL@FMPFMLM@?$CFs?5?$CI?$CFd?$CJ?5tried?5to?5move?5to?5a?5safe?5@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0EL@FMPFMLM@?$CFs?5?$CI?$CFd?$CJ?5tried?5to?5move?5to?5a?5safe?5@ DB '%'
	DB	's (%d) tried to move to a safe point but couldn''t find a goo'
	DB	'd place to go', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JIBDOEGJ@?$CFs?5?$CI?$CFd?$CJ?5moving?5to?5safety?0?5X?3?5?$CFd?0@
CONST	SEGMENT
??_C@_0CH@JIBDOEGJ@?$CFs?5?$CI?$CFd?$CJ?5moving?5to?5safety?0?5X?3?5?$CFd?0@ DB '%'
	DB	's (%d) moving to safety, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@JAIEONKP@?$CFs?5?$CI?$CFd?$CJ?5tried?5to?5move?5to?5safety?5@
CONST	SEGMENT
??_C@_0FC@JAIEONKP@?$CFs?5?$CI?$CFd?$CJ?5tried?5to?5move?5to?5safety?5@ DB '%'
	DB	's (%d) tried to move to safety but cannot hold in current loc'
	DB	'ation, X: %d, Y: %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@KOMOJBJG@?$CFs?5?$CI?$CFd?$CJ?5tried?5to?5move?5to?5safety?5@
CONST	SEGMENT
??_C@_0EG@KOMOJBJG@?$CFs?5?$CI?$CFd?$CJ?5tried?5to?5move?5to?5safety?5@ DB '%'
	DB	's (%d) tried to move to safety but is at the best spot, X: %d'
	DB	', Y: %d', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$8
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z
_TEXT	SEGMENT
_this$ = -1300						; size = 4
$T255532 = -1284					; size = 4
$T255523 = -1280					; size = 4
$T255517 = -1276					; size = 4
$T255489 = -1264					; size = 4
$T255485 = -1260					; size = 4
$T255470 = -1256					; size = 4
$T255461 = -1252					; size = 4
$T255457 = -1248					; size = 4
$T255453 = -1244					; size = 4
$T255447 = -1240					; size = 4
$T255424 = -1236					; size = 4
$T255415 = -1232					; size = 4
$T255411 = -1228					; size = 4
$T255407 = -1224					; size = 4
$T255401 = -1220					; size = 4
$T255374 = -1216					; size = 4
$T255365 = -1212					; size = 4
$T255361 = -1208					; size = 4
$T255357 = -1204					; size = 4
$T255351 = -1200					; size = 4
$T255315 = -1188					; size = 4
_weightedElem$255310 = -1184				; size = 8
$T255301 = -1176					; size = 4
$T255292 = -1172					; size = 4
$T255283 = -1168					; size = 4
$T255274 = -1160					; size = 4
$T255265 = -1156					; size = 4
$T255256 = -1152					; size = 4
$T255252 = -1148					; size = 4
$T255234 = -1124					; size = 4
$T255225 = -1120					; size = 4
$T255195 = -1115					; size = 1
$T255194 = -1114					; size = 1
$T255193 = -1113					; size = 1
_strLogString$227995 = -1112				; size = 28
_strTemp$227996 = -1084					; size = 28
_strLogString$227989 = -1056				; size = 28
_strTemp$227990 = -1028					; size = 28
_strLogString$227984 = -1000				; size = 28
_strTemp$227985 = -972					; size = 28
_strLogString$227978 = -944				; size = 28
_strTemp$227979 = -916					; size = 28
_pPlot$227970 = -888					; size = 4
_iPathTurns$227971 = -884				; size = 4
_i$227966 = -880					; size = 4
_pLoopUnit$227957 = -876				; size = 4
_pUnitNode$227953 = -872				; size = 4
_pCity$227949 = -868					; size = 4
_pLoopPlot$227943 = -864				; size = 4
_iValue$227947 = -860					; size = 4
_iDY$227939 = -856					; size = 4
_iDX$227935 = -852					; size = 4
_uiListSize$ = -848					; size = 4
_iSearchRange$ = -844					; size = 4
_pBestPlot$ = -840					; size = 4
_aBestPlotList$ = -836					; size = 816
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
_bIgnoreUnits$ = 12					; size = 1
?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z PROC ; CvHomelandAI::MoveCivilianToSafety, COMDAT
; _this$ = ecx

; 4813 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1288				; 00000508H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4814 : 	int iSearchRange = pUnit->SearchRange(1);

	push	1
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?SearchRange@CvUnit@@QBEHH@Z		; CvUnit::SearchRange
	mov	DWORD PTR _iSearchRange$[ebp], eax

; 4815 : 
; 4816 : 	// Collecting all the possibilities first.
; 4817 : 	WeightedPlotVector aBestPlotList;

	lea	ecx, DWORD PTR _aBestPlotList$[ebp]
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4818 : 	aBestPlotList.reserve( ((iSearchRange * 2) + 1) * 2 );

	mov	eax, DWORD PTR _iSearchRange$[ebp]
	shl	eax, 1
	lea	ecx, DWORD PTR [eax+eax+2]
	push	ecx
	lea	ecx, DWORD PTR _aBestPlotList$[ebp]
	call	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSizeToFit

; 4819 : 
; 4820 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 4821 : 	int iMaxDX, iDX;
; 4822 : 	CvPlot* pLoopPlot;
; 4823 : 	for (int iDY = -iSearchRange; iDY <= iSearchRange; iDY++)
; 4824 : 	{
; 4825 : 		iMaxDX = iSearchRange - MAX(0, iDY);
; 4826 : 		for (iDX = -iSearchRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 4827 : 		{
; 4828 : 			// No need for range check because loops are set up properly
; 4829 : 			pLoopPlot = plotXY(pUnit->getX(), pUnit->getY(), iDX, iDY);
; 4830 : #else
; 4831 : 	for(int iDX = -(iSearchRange); iDX <= iSearchRange; iDX++)

	mov	edx, DWORD PTR _iSearchRange$[ebp]
	neg	edx
	mov	DWORD PTR _iDX$227935[ebp], edx
	jmp	SHORT $LN36@MoveCivili
$LN35@MoveCivili:
	mov	eax, DWORD PTR _iDX$227935[ebp]
	add	eax, 1
	mov	DWORD PTR _iDX$227935[ebp], eax
$LN36@MoveCivili:
	mov	ecx, DWORD PTR _iDX$227935[ebp]
	cmp	ecx, DWORD PTR _iSearchRange$[ebp]
	jg	$LN34@MoveCivili

; 4832 : 	{
; 4833 : 		for(int iDY = -(iSearchRange); iDY <= iSearchRange; iDY++)

	mov	edx, DWORD PTR _iSearchRange$[ebp]
	neg	edx
	mov	DWORD PTR _iDY$227939[ebp], edx
	jmp	SHORT $LN33@MoveCivili
$LN32@MoveCivili:
	mov	eax, DWORD PTR _iDY$227939[ebp]
	add	eax, 1
	mov	DWORD PTR _iDY$227939[ebp], eax
$LN33@MoveCivili:
	mov	ecx, DWORD PTR _iDY$227939[ebp]
	cmp	ecx, DWORD PTR _iSearchRange$[ebp]
	jg	$LN31@MoveCivili

; 4834 : 		{
; 4835 : 			CvPlot* pLoopPlot = plotXYWithRangeCheck(pUnit->getX(), pUnit->getY(), iDX, iDY, iSearchRange);

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T255225[ebp], eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T255234[ebp], edx
	mov	eax, DWORD PTR _iSearchRange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDY$227939[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDX$227935[ebp]
	push	edx
	mov	eax, DWORD PTR $T255225[ebp]
	push	eax
	mov	ecx, DWORD PTR $T255234[ebp]
	push	ecx
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pLoopPlot$227943[ebp], eax

; 4836 : #endif
; 4837 : 			if(!pLoopPlot)

	cmp	DWORD PTR _pLoopPlot$227943[ebp], 0
	jne	SHORT $LN30@MoveCivili

; 4838 : 			{
; 4839 : 				continue;

	jmp	SHORT $LN32@MoveCivili
$LN30@MoveCivili:

; 4840 : 			}
; 4841 : 
; 4842 : 			if(!pUnit->PlotValid(pLoopPlot))

	mov	edx, DWORD PTR _pLoopPlot$227943[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?PlotValid@CvUnit@@QBE_NPAVCvPlot@@@Z	; CvUnit::PlotValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN29@MoveCivili

; 4843 : 			{
; 4844 : 				continue;

	jmp	$LN32@MoveCivili
$LN29@MoveCivili:

; 4845 : 			}
; 4846 : 
; 4847 : 			if(pLoopPlot->isVisibleEnemyUnit(pUnit))

	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopPlot$227943[ebp]
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyUnit
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN28@MoveCivili

; 4848 : 			{
; 4849 : 				continue;

	jmp	$LN32@MoveCivili
$LN28@MoveCivili:

; 4850 : 			}
; 4851 : 
; 4852 : 			int iValue = 0;

	mov	DWORD PTR _iValue$227947[ebp], 0

; 4853 : 			if(pLoopPlot->getOwner() != NO_PLAYER && GET_PLAYER(pLoopPlot->getOwner()).getTeam() == m_pPlayer->getTeam())

	mov	eax, DWORD PTR _pLoopPlot$227943[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	ecx, -1
	je	SHORT $LN27@MoveCivili
	mov	edx, DWORD PTR _pLoopPlot$227943[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T255252[ebp], eax
	mov	ecx, DWORD PTR $T255252[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T255256[ebp], ecx
	mov	edx, DWORD PTR $T255256[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T255265[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T255274[ebp], edx
	mov	eax, DWORD PTR $T255274[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	DWORD PTR $T255265[ebp], eax
	jne	SHORT $LN27@MoveCivili

; 4854 : 			{
; 4855 : 				// if this is within our territory, provide a minor benefit
; 4856 : 				iValue += 1;

	mov	edx, DWORD PTR _iValue$227947[ebp]
	add	edx, 1
	mov	DWORD PTR _iValue$227947[ebp], edx
$LN27@MoveCivili:

; 4857 : 			}
; 4858 : 
; 4859 : 			CvCity* pCity = pLoopPlot->getPlotCity();

	mov	ecx, DWORD PTR _pLoopPlot$227943[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$227949[ebp], eax

; 4860 : 			if(pCity && pCity->getTeam() == pUnit->getTeam())

	cmp	DWORD PTR _pCity$227949[ebp], 0
	je	SHORT $LN26@MoveCivili
	mov	ecx, DWORD PTR _pCity$227949[ebp]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	mov	esi, eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	esi, eax
	jne	SHORT $LN26@MoveCivili

; 4861 : 			{
; 4862 : 				iValue += pCity->getStrengthValue() * (GC.getMAX_CITY_DEFENSE_DAMAGE() - pCity->getDamage());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6740
	mov	DWORD PTR $T255283[ebp], eax
	push	0
	mov	ecx, DWORD PTR _pCity$227949[ebp]
	call	?getStrengthValue@CvCity@@QBEH_N@Z	; CvCity::getStrengthValue
	mov	esi, eax
	mov	ecx, DWORD PTR _pCity$227949[ebp]
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	mov	ecx, DWORD PTR $T255283[ebp]
	sub	ecx, eax
	imul	esi, ecx
	add	esi, DWORD PTR _iValue$227947[ebp]
	mov	DWORD PTR _iValue$227947[ebp], esi
	jmp	$LN25@MoveCivili
$LN26@MoveCivili:

; 4863 : 			}
; 4864 : 			else if(!bIgnoreUnits)

	movzx	edx, BYTE PTR _bIgnoreUnits$[ebp]
	test	edx, edx
	jne	$LN25@MoveCivili

; 4865 : 			{
; 4866 : 				IDInfo* pUnitNode = pLoopPlot->headUnitNode();

	mov	ecx, DWORD PTR _pLoopPlot$227943[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$227953[ebp], eax
$LN23@MoveCivili:

; 4867 : 				while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$227953[ebp], 0
	je	$LN25@MoveCivili

; 4868 : 				{
; 4869 : 					CvUnit* pLoopUnit = ::getUnit(*pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$227953[ebp]
	push	eax
	call	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z	; getUnit
	add	esp, 4
	mov	DWORD PTR _pLoopUnit$227957[ebp], eax

; 4870 : 					pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);

	mov	ecx, DWORD PTR _pUnitNode$227953[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopPlot$227943[ebp]
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$227953[ebp], eax

; 4871 : 
; 4872 : 					if(pLoopUnit && pLoopUnit->getOwner() == pUnit->getOwner())

	cmp	DWORD PTR _pLoopUnit$227957[ebp], 0
	je	$LN21@MoveCivili
	mov	edx, DWORD PTR _pLoopUnit$227957[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T255292[ebp], eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T255301[ebp], edx
	mov	eax, DWORD PTR $T255292[ebp]
	cmp	eax, DWORD PTR $T255301[ebp]
	jne	SHORT $LN21@MoveCivili

; 4873 : 					{
; 4874 : 						if(pLoopUnit->IsCanDefend())

	push	0
	mov	ecx, DWORD PTR _pLoopUnit$227957[ebp]
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN21@MoveCivili

; 4875 : 						{
; 4876 : 							if(pLoopUnit != pUnit)

	mov	edx, DWORD PTR _pLoopUnit$227957[ebp]
	cmp	edx, DWORD PTR _pUnit$[ebp]
	je	SHORT $LN21@MoveCivili

; 4877 : 							{
; 4878 : 								if(pLoopUnit->isWaiting() || !(pLoopUnit->canMove()))

	mov	ecx, DWORD PTR _pLoopUnit$227957[ebp]
	call	?isWaiting@CvUnit@@QBE_NXZ		; CvUnit::isWaiting
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN17@MoveCivili
	mov	ecx, DWORD PTR _pLoopUnit$227957[ebp]
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN21@MoveCivili
$LN17@MoveCivili:

; 4879 : 								{
; 4880 : 									iValue += pLoopUnit->GetMaxDefenseStrength(pLoopPlot, NULL) * pLoopUnit->GetCurrHitPoints();

	push	0
	push	0
	mov	edx, DWORD PTR _pLoopPlot$227943[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopUnit$227957[ebp]
	call	?GetMaxDefenseStrength@CvUnit@@QBEHPBVCvPlot@@PBV1@_N@Z ; CvUnit::GetMaxDefenseStrength
	mov	esi, eax
	mov	ecx, DWORD PTR _pLoopUnit$227957[ebp]
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	imul	esi, eax
	add	esi, DWORD PTR _iValue$227947[ebp]
	mov	DWORD PTR _iValue$227947[ebp], esi
$LN21@MoveCivili:

; 4881 : 								}
; 4882 : 							}
; 4883 : 						}
; 4884 : 					}
; 4885 : 				}

	jmp	$LN23@MoveCivili
$LN25@MoveCivili:

; 4886 : 			}
; 4887 : 
; 4888 : 			iValue -= m_pPlayer->GetPlotDanger(*pLoopPlot);

	mov	eax, DWORD PTR _pLoopPlot$227943[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	mov	edx, DWORD PTR _iValue$227947[ebp]
	sub	edx, eax
	mov	DWORD PTR _iValue$227947[ebp], edx

; 4889 : 
; 4890 : 			aBestPlotList.push_back(pLoopPlot, iValue);

	mov	DWORD PTR _weightedElem$255310[ebp], 0
	mov	DWORD PTR _weightedElem$255310[ebp+4], 0
	mov	eax, DWORD PTR _pLoopPlot$227943[ebp]
	mov	DWORD PTR _weightedElem$255310[ebp], eax
	mov	ecx, DWORD PTR _iValue$227947[ebp]
	mov	DWORD PTR _weightedElem$255310[ebp+4], ecx
	lea	edx, DWORD PTR _weightedElem$255310[ebp]
	push	edx
	lea	ecx, DWORD PTR _aBestPlotList$[ebp]
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::push_back

; 4891 : 		}

	jmp	$LN32@MoveCivili
$LN31@MoveCivili:

; 4892 : 	}

	jmp	$LN35@MoveCivili
$LN34@MoveCivili:

; 4893 : 
; 4894 : 	// Now loop through the sorted score list and go to the best one we can reach in one turn.
; 4895 : 	CvPlot* pBestPlot = NULL;

	mov	DWORD PTR _pBestPlot$[ebp], 0

; 4896 : 	uint uiListSize;
; 4897 : 	if ((uiListSize = aBestPlotList.size()) > 0)

	mov	eax, DWORD PTR _aBestPlotList$[ebp+4]
	mov	DWORD PTR $T255315[ebp], eax
	mov	ecx, DWORD PTR $T255315[ebp]
	mov	DWORD PTR _uiListSize$[ebp], ecx
	cmp	DWORD PTR _uiListSize$[ebp], 0
	jbe	$LN16@MoveCivili

; 4898 : 	{
; 4899 : 		aBestPlotList.SortItems();	// highest score will be first.

	lea	ecx, DWORD PTR _aBestPlotList$[ebp]
	call	?SortItems@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXXZ ; CvWeightedVector<CvPlot *,100,1>::SortItems

; 4900 : 		for (uint i = 0; i < uiListSize; ++i )	

	mov	DWORD PTR _i$227966[ebp], 0
	jmp	SHORT $LN15@MoveCivili
$LN14@MoveCivili:
	mov	edx, DWORD PTR _i$227966[ebp]
	add	edx, 1
	mov	DWORD PTR _i$227966[ebp], edx
$LN15@MoveCivili:
	mov	eax, DWORD PTR _i$227966[ebp]
	cmp	eax, DWORD PTR _uiListSize$[ebp]
	jae	SHORT $LN16@MoveCivili

; 4901 : 		{
; 4902 : 			CvPlot* pPlot = aBestPlotList.GetElement(i);

	mov	ecx, DWORD PTR _i$227966[ebp]
	mov	edx, DWORD PTR _aBestPlotList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _pPlot$227970[ebp], eax

; 4903 : 
; 4904 : 			int iPathTurns;
; 4905 : 			if(!pUnit->GeneratePath(pPlot, MOVE_UNITS_IGNORE_DANGER, true, &iPathTurns))

	lea	ecx, DWORD PTR _iPathTurns$227971[ebp]
	push	ecx
	push	1
	push	8
	mov	edx, DWORD PTR _pPlot$227970[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN12@MoveCivili

; 4906 : 			{
; 4907 : 				continue;

	jmp	SHORT $LN14@MoveCivili
$LN12@MoveCivili:

; 4908 : 			}
; 4909 : 
; 4910 : 			// if we can't get there this turn, forget it
; 4911 : 			if(iPathTurns > 1)

	cmp	DWORD PTR _iPathTurns$227971[ebp], 1
	jle	SHORT $LN11@MoveCivili

; 4912 : 			{
; 4913 : 				continue;

	jmp	SHORT $LN14@MoveCivili
$LN11@MoveCivili:

; 4914 : 			}
; 4915 : 
; 4916 : 			pBestPlot = pPlot;

	mov	ecx, DWORD PTR _pPlot$227970[ebp]
	mov	DWORD PTR _pBestPlot$[ebp], ecx

; 4917 : 			break;

	jmp	SHORT $LN16@MoveCivili

; 4918 : 		}

	jmp	SHORT $LN14@MoveCivili
$LN16@MoveCivili:

; 4919 : 	}
; 4920 : 
; 4921 : 	if(pBestPlot != NULL)

	cmp	DWORD PTR _pBestPlot$[ebp], 0
	je	$LN10@MoveCivili

; 4922 : 	{
; 4923 : 		if(pUnit->atPlot(*pBestPlot))

	mov	edx, DWORD PTR _pBestPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z	; CvUnit::atPlot
	movzx	eax, al
	test	eax, eax
	je	$LN9@MoveCivili

; 4924 : 		{
; 4925 : 			if (pUnit->canHold(pBestPlot))

	mov	ecx, DWORD PTR _pBestPlot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canHold@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canHold
	movzx	edx, al
	test	edx, edx
	je	$LN8@MoveCivili

; 4926 : 			{
; 4927 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN7@MoveCivili
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@MoveCivili

; 4928 : 				{
; 4929 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227978[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 4930 : #ifdef AUI_WARNING_FIXES
; 4931 : 					CvString strTemp = pUnit->getUnitInfo().GetDescription();
; 4932 : #else
; 4933 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227979[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 4934 : 					strTemp = GC.getUnitInfo(pUnit->getUnitType())->GetDescription();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR $T255351[ebp], eax
	mov	ecx, DWORD PTR $T255351[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T255357[ebp], eax
	cmp	DWORD PTR $T255357[ebp], 0
	je	SHORT $LN136@MoveCivili
	mov	edx, DWORD PTR $T255357[ebp]
	push	edx
	lea	ecx, DWORD PTR _strTemp$227979[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN137@MoveCivili
$LN136@MoveCivili:
	lea	ecx, DWORD PTR _strTemp$227979[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN137@MoveCivili:

; 4935 : #endif
; 4936 : 					strLogString.Format("%s (%d) tried to move to safety but is at the best spot, X: %d, Y: %d", strTemp.GetCString(), pUnit->GetID(), pBestPlot->getX(), pBestPlot->getY());

	mov	eax, DWORD PTR _pBestPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T255361[ebp], ecx
	mov	edx, DWORD PTR _pBestPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T255365[ebp], eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T255374[ebp], edx
	mov	eax, DWORD PTR $T255361[ebp]
	push	eax
	mov	ecx, DWORD PTR $T255365[ebp]
	push	ecx
	mov	edx, DWORD PTR $T255374[ebp]
	push	edx
	lea	ecx, DWORD PTR _strTemp$227979[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0EG@KOMOJBJG@?$CFs?5?$CI?$CFd?$CJ?5tried?5to?5move?5to?5safety?5@
	lea	eax, DWORD PTR _strLogString$227978[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 4937 : 					LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227978[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4938 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$227979[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227978[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@MoveCivili:

; 4939 : 
; 4940 : 				pUnit->PushMission(CvTypes::getMISSION_SKIP());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SKIP
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4941 : 				return true;

	mov	BYTE PTR $T255193[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _aBestPlotList$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>
	mov	al, BYTE PTR $T255193[ebp]
	jmp	$LN37@MoveCivili

; 4942 : 			}
; 4943 : 			else

	jmp	$LN6@MoveCivili
$LN8@MoveCivili:

; 4944 : 			{
; 4945 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN5@MoveCivili
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	$LN5@MoveCivili

; 4946 : 				{
; 4947 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227984[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 4948 : #ifdef AUI_WARNING_FIXES
; 4949 : 					CvString strTemp = pUnit->getUnitInfo().GetDescription();
; 4950 : #else
; 4951 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227985[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 4952 : 					strTemp = GC.getUnitInfo(pUnit->getUnitType())->GetDescription();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR $T255401[ebp], eax
	mov	ecx, DWORD PTR $T255401[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T255407[ebp], eax
	cmp	DWORD PTR $T255407[ebp], 0
	je	SHORT $LN167@MoveCivili
	mov	ecx, DWORD PTR $T255407[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$227985[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN168@MoveCivili
$LN167@MoveCivili:
	lea	ecx, DWORD PTR _strTemp$227985[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN168@MoveCivili:

; 4953 : #endif
; 4954 : 					strLogString.Format("%s (%d) tried to move to safety but cannot hold in current location, X: %d, Y: %d", strTemp.GetCString(), pUnit->GetID(), pBestPlot->getX(), pBestPlot->getY());

	mov	edx, DWORD PTR _pBestPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T255411[ebp], eax
	mov	ecx, DWORD PTR _pBestPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T255415[ebp], edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T255424[ebp], ecx
	mov	edx, DWORD PTR $T255411[ebp]
	push	edx
	mov	eax, DWORD PTR $T255415[ebp]
	push	eax
	mov	ecx, DWORD PTR $T255424[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$227985[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0FC@JAIEONKP@?$CFs?5?$CI?$CFd?$CJ?5tried?5to?5move?5to?5safety?5@
	lea	edx, DWORD PTR _strLogString$227984[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 4955 : 					LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227984[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4956 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strTemp$227985[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227984[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@MoveCivili:

; 4957 : 				pUnit->SetAutomateType(NO_AUTOMATE);

	push	-1
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z ; CvUnit::SetAutomateType
$LN6@MoveCivili:

; 4958 : 			}
; 4959 : 		}
; 4960 : 		else

	jmp	$LN4@MoveCivili
$LN9@MoveCivili:

; 4961 : 		{
; 4962 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@MoveCivili
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN3@MoveCivili

; 4963 : 			{
; 4964 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227989[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 4965 : #ifdef AUI_WARNING_FIXES
; 4966 : 				CvString strTemp = pUnit->getUnitInfo().GetDescription();
; 4967 : #else
; 4968 : 				CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227990[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 4969 : 				strTemp = GC.getUnitInfo(pUnit->getUnitType())->GetDescription();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR $T255447[ebp], eax
	mov	ecx, DWORD PTR $T255447[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T255453[ebp], eax
	cmp	DWORD PTR $T255453[ebp], 0
	je	SHORT $LN195@MoveCivili
	mov	eax, DWORD PTR $T255453[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTemp$227990[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN196@MoveCivili
$LN195@MoveCivili:
	lea	ecx, DWORD PTR _strTemp$227990[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN196@MoveCivili:

; 4970 : #endif
; 4971 : 				strLogString.Format("%s (%d) moving to safety, X: %d, Y: %d", strTemp.GetCString(), pUnit->GetID(), pBestPlot->getX(), pBestPlot->getY());

	mov	ecx, DWORD PTR _pBestPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T255457[ebp], edx
	mov	eax, DWORD PTR _pBestPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T255461[ebp], ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T255470[ebp], eax
	mov	ecx, DWORD PTR $T255457[ebp]
	push	ecx
	mov	edx, DWORD PTR $T255461[ebp]
	push	edx
	mov	eax, DWORD PTR $T255470[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTemp$227990[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CH@JIBDOEGJ@?$CFs?5?$CI?$CFd?$CJ?5moving?5to?5safety?0?5X?3?5?$CFd?0@
	lea	ecx, DWORD PTR _strLogString$227989[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 4972 : 				LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227989[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4973 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR _strTemp$227990[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227989[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@MoveCivili:

; 4974 : 
; 4975 : 			pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestPlot->getX(), pBestPlot->getY(), MOVE_UNITS_IGNORE_DANGER);

	mov	eax, DWORD PTR _pBestPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T255485[ebp], ecx
	mov	edx, DWORD PTR _pBestPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T255489[ebp], eax
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	8
	mov	ecx, DWORD PTR $T255485[ebp]
	push	ecx
	mov	edx, DWORD PTR $T255489[ebp]
	push	edx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4976 : 			return true;

	mov	BYTE PTR $T255194[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _aBestPlotList$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>
	mov	al, BYTE PTR $T255194[ebp]
	jmp	$LN37@MoveCivili
$LN4@MoveCivili:

; 4977 : 		}
; 4978 : 	}
; 4979 : 	else

	jmp	$LN2@MoveCivili
$LN10@MoveCivili:

; 4980 : 	{
; 4981 : 		if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN2@MoveCivili
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@MoveCivili

; 4982 : 		{
; 4983 : 			CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227995[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 4984 : 			CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227996[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 4985 : 			strTemp = pUnit->getUnitInfo().GetDescription();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	DWORD PTR $T255517[ebp], eax
	mov	ecx, DWORD PTR $T255517[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T255523[ebp], eax
	cmp	DWORD PTR $T255523[ebp], 0
	je	SHORT $LN239@MoveCivili
	mov	edx, DWORD PTR $T255523[ebp]
	push	edx
	lea	ecx, DWORD PTR _strTemp$227996[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN244@MoveCivili
$LN239@MoveCivili:
	lea	ecx, DWORD PTR _strTemp$227996[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 4986 : 			strLogString.Format("%s (%d) tried to move to a safe point but couldn't find a good place to go", strTemp.GetCString(), pUnit->GetID());

$LN244@MoveCivili:
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T255532[ebp], ecx
	mov	edx, DWORD PTR $T255532[ebp]
	push	edx
	lea	ecx, DWORD PTR _strTemp$227996[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0EL@FMPFMLM@?$CFs?5?$CI?$CFd?$CJ?5tried?5to?5move?5to?5a?5safe?5@
	lea	eax, DWORD PTR _strLogString$227995[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4987 : 			LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227995[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4988 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _strTemp$227996[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$227995[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@MoveCivili:

; 4989 : 	}
; 4990 : 
; 4991 : 
; 4992 : 	return false;

	mov	BYTE PTR $T255195[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _aBestPlotList$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>
	mov	al, BYTE PTR $T255195[ebp]
$LN37@MoveCivili:

; 4993 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$0:
	lea	ecx, DWORD PTR _aBestPlotList$[ebp]
	jmp	??1?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ ; CvWeightedVector<CvPlot *,100,1>::~CvWeightedVector<CvPlot *,100,1>
__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$1:
	lea	ecx, DWORD PTR _strLogString$227978[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$2:
	lea	ecx, DWORD PTR _strTemp$227979[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$3:
	lea	ecx, DWORD PTR _strLogString$227984[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$4:
	lea	ecx, DWORD PTR _strTemp$227985[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$5:
	lea	ecx, DWORD PTR _strLogString$227989[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$6:
	lea	ecx, DWORD PTR _strTemp$227990[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$7:
	lea	ecx, DWORD PTR _strLogString$227995[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$8:
	lea	ecx, DWORD PTR _strTemp$227996[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1296]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ENDP ; CvHomelandAI::MoveCivilianToSafety
PUBLIC	??_C@_0BC@GLFDOKEF@Trade?5unit?5idling?$AA@	; `string'
PUBLIC	??_C@_0DD@BNGIFPFN@Establishing?5trade?5route?0?5X?3?5?$CFd?0@ ; `string'
PUBLIC	??_C@_0CN@PKHEFHNM@Establishing?5trade?5route?0?5X?3?5?$CFd?0@ ; `string'
PUBLIC	??_C@_0CN@MFFCMADF@Establishing?5trade?5route?0?5X?3?5?$CFd?0@ ; `string'
PUBLIC	??_C@_0CN@BANMAHFA@Changing?5trade?5route?5home?5city?0?5@ ; `string'
PUBLIC	??_C@_0EG@JOIHGMNN@Disbanding?5unit?5because?5we?5want?5@ ; `string'
PUBLIC	??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnection,168,0,297,0>::FStaticVector<TradeConnection,168,0,297,0>
PUBLIC	__$ArrayPad$
EXTRN	?getMISSION_ESTABLISH_TRADE_ROUTE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_ESTABLISH_TRADE_ROUTE
EXTRN	?getMISSION_CHANGE_TRADE_UNIT_HOME_CITY@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_CHANGE_TRADE_UNIT_HOME_CITY
EXTRN	?ChooseTradeUnitTargetPlot@CvTradeAI@@QAE_NPAVCvUnit@@AAH1AAW4TradeConnectionType@@AA_NABV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z:PROC ; CvTradeAI::ChooseTradeUnitTargetPlot
EXTRN	?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z:PROC ; CvTradeAI::PrioritizeTradeRoutes
EXTRN	_atexit:PROC
EXTRN	?GetTradeAI@CvPlayer@@QBEPAVCvTradeAI@@XZ:PROC	; CvPlayer::GetTradeAI
;	COMDAT ?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_BSS	SEGMENT
?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A DB 012370H DUP (?) ; `CvHomelandAI::ExecuteTradeUnitMoves'::`2'::aTradeConnections
_BSS	ENDS
;	COMDAT ?$S1@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4IA
_BSS	SEGMENT
?$S1@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4IA DD 01H DUP (?) ; `CvHomelandAI::ExecuteTradeUnitMoves'::`2'::$S1
_BSS	ENDS
;	COMDAT ??_C@_0BC@GLFDOKEF@Trade?5unit?5idling?$AA@
CONST	SEGMENT
??_C@_0BC@GLFDOKEF@Trade?5unit?5idling?$AA@ DB 'Trade unit idling', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@BNGIFPFN@Establishing?5trade?5route?0?5X?3?5?$CFd?0@
CONST	SEGMENT
??_C@_0DD@BNGIFPFN@Establishing?5trade?5route?0?5X?3?5?$CFd?0@ DB 'Establ'
	DB	'ishing trade route, X: %d, Y: %d, production', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@PKHEFHNM@Establishing?5trade?5route?0?5X?3?5?$CFd?0@
CONST	SEGMENT
??_C@_0CN@PKHEFHNM@Establishing?5trade?5route?0?5X?3?5?$CFd?0@ DB 'Establ'
	DB	'ishing trade route, X: %d, Y: %d, gold', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@MFFCMADF@Establishing?5trade?5route?0?5X?3?5?$CFd?0@
CONST	SEGMENT
??_C@_0CN@MFFCMADF@Establishing?5trade?5route?0?5X?3?5?$CFd?0@ DB 'Establ'
	DB	'ishing trade route, X: %d, Y: %d, food', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@BANMAHFA@Changing?5trade?5route?5home?5city?0?5@
CONST	SEGMENT
??_C@_0CN@BANMAHFA@Changing?5trade?5route?5home?5city?0?5@ DB 'Changing t'
	DB	'rade route home city, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@JOIHGMNN@Disbanding?5unit?5because?5we?5want?5@
CONST	SEGMENT
??_C@_0EG@JOIHGMNN@Disbanding?5unit?5because?5we?5want?5@ DB 'Disbanding '
	DB	'unit because we want different domains for our trade units', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ$4
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv236 = -244						; size = 4
tv374 = -240						; size = 4
tv351 = -236						; size = 4
tv344 = -232						; size = 4
_this$ = -228						; size = 4
$T255708 = -224						; size = 4
$T255701 = -220						; size = 4
$T255694 = -216						; size = 4
$T255680 = -212						; size = 4
$T255673 = -208						; size = 4
$T255662 = -204						; size = 4
$T255648 = -200						; size = 4
$T255641 = -196						; size = 4
$T255637 = -192						; size = 4
$T255633 = -188						; size = 4
$T255623 = -184						; size = 4
$T255616 = -180						; size = 4
$T255604 = -176						; size = 4
$T255600 = -172						; size = 4
_strLogString$228049 = -168				; size = 28
_pPlot$228035 = -140					; size = 4
_strLogString$228036 = -136				; size = 28
_pPlot$228030 = -108					; size = 4
_strLogString$228031 = -104				; size = 28
_pOriginPlot$228027 = -76				; size = 4
_strLogString$228024 = -72				; size = 28
__$ArrayPad$ = -44					; size = 4
_pUnit$228014 = -40					; size = 4
_bDisband$228019 = -34					; size = 1
_bSuccess$228020 = -33					; size = 1
_iDestPlotIndex$228017 = -32				; size = 4
_iOriginPlotIndex$228016 = -28				; size = 4
_eTradeConnectionType$228018 = -24			; size = 4
_pkTradeAI$ = -20					; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::ExecuteTradeUnitMoves, COMDAT
; _this$ = ecx

; 4997 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4998 : 	CvTradeAI* pkTradeAI = m_pPlayer->GetTradeAI();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetTradeAI@CvPlayer@@QBEPAVCvTradeAI@@XZ ; CvPlayer::GetTradeAI
	mov	DWORD PTR _pkTradeAI$[ebp], eax

; 4999 : 
; 5000 : 	static TradeConnectionList aTradeConnections; // slewis - added static to work around the stack limit

	mov	ecx, DWORD PTR ?$S1@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4IA
	and	ecx, 1
	jne	SHORT $LN20@ExecuteTra
	mov	edx, DWORD PTR ?$S1@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4IA
	or	edx, 1
	mov	DWORD PTR ?$S1@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4IA, edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, OFFSET ?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A
	call	??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnection,168,0,297,0>::FStaticVector<TradeConnection,168,0,297,0>
	push	OFFSET ??__FaTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@YAXXZ ; `CvHomelandAI::ExecuteTradeUnitMoves'::`2'::`dynamic atexit destructor for 'aTradeConnections''
	call	_atexit
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN20@ExecuteTra:

; 5001 : 	pkTradeAI->PrioritizeTradeRoutes(aTradeConnections);

	push	OFFSET ?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A
	mov	ecx, DWORD PTR _pkTradeAI$[ebp]
	call	?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z ; CvTradeAI::PrioritizeTradeRoutes

; 5002 : 
; 5003 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 5004 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN19@ExecuteTra
$LN18@ExecuteTra:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], edx
$LN19@ExecuteTra:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T255600[ebp], eax
	mov	ecx, DWORD PTR $T255600[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T255600[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN21@ExecuteTra

; 5005 : 	{
; 5006 : 		CvUnit* pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T255604[ebp], edx
	mov	eax, DWORD PTR $T255604[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pUnit$228014[ebp], eax

; 5007 : 		if(!pUnit)

	cmp	DWORD PTR _pUnit$228014[ebp], 0
	jne	SHORT $LN16@ExecuteTra

; 5008 : 		{
; 5009 : 			continue;

	jmp	SHORT $LN18@ExecuteTra
$LN16@ExecuteTra:

; 5010 : 		}
; 5011 : 
; 5012 : 		int iOriginPlotIndex = MAX_INT;

	mov	DWORD PTR _iOriginPlotIndex$228016[ebp], 2147483647 ; 7fffffffH

; 5013 : 		int iDestPlotIndex = MAX_INT;

	mov	DWORD PTR _iDestPlotIndex$228017[ebp], 2147483647 ; 7fffffffH

; 5014 : 		TradeConnectionType eTradeConnectionType = NUM_TRADE_CONNECTION_TYPES;

	mov	DWORD PTR _eTradeConnectionType$228018[ebp], 3

; 5015 : 		bool bDisband = false;

	mov	BYTE PTR _bDisband$228019[ebp], 0

; 5016 : 		bool bSuccess = m_pPlayer->GetTradeAI()->ChooseTradeUnitTargetPlot(pUnit, iOriginPlotIndex, iDestPlotIndex, eTradeConnectionType, bDisband, aTradeConnections);

	push	OFFSET ?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A
	lea	edx, DWORD PTR _bDisband$228019[ebp]
	push	edx
	lea	eax, DWORD PTR _eTradeConnectionType$228018[ebp]
	push	eax
	lea	ecx, DWORD PTR _iDestPlotIndex$228017[ebp]
	push	ecx
	lea	edx, DWORD PTR _iOriginPlotIndex$228016[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$228014[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetTradeAI@CvPlayer@@QBEPAVCvTradeAI@@XZ ; CvPlayer::GetTradeAI
	mov	ecx, eax
	call	?ChooseTradeUnitTargetPlot@CvTradeAI@@QAE_NPAVCvUnit@@AAH1AAW4TradeConnectionType@@AA_NABV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z ; CvTradeAI::ChooseTradeUnitTargetPlot
	mov	BYTE PTR _bSuccess$228020[ebp], al

; 5017 : 		if (bSuccess)

	movzx	edx, BYTE PTR _bSuccess$228020[ebp]
	test	edx, edx
	je	$LN15@ExecuteTra

; 5018 : 		{
; 5019 : 			if (bDisband)

	movzx	eax, BYTE PTR _bDisband$228019[ebp]
	test	eax, eax
	je	SHORT $LN14@ExecuteTra

; 5020 : 			{
; 5021 : 				pUnit->kill(true);

	push	-1
	push	1
	mov	ecx, DWORD PTR _pUnit$228014[ebp]
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill

; 5022 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@ExecuteTra
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN13@ExecuteTra

; 5023 : 				{
; 5024 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228024[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 5025 : 					strLogString.Format("Disbanding unit because we want different domains for our trade units");

	push	OFFSET ??_C@_0EG@JOIHGMNN@Disbanding?5unit?5because?5we?5want?5@
	lea	eax, DWORD PTR _strLogString$228024[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 5026 : 					LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$228024[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 5027 : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$228024[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN13@ExecuteTra:

; 5028 : 			}
; 5029 : 			else

	jmp	$LN12@ExecuteTra
$LN14@ExecuteTra:

; 5030 : 			{
; 5031 : 				CvPlot* pOriginPlot = GC.getMap().plotByIndex(iOriginPlotIndex);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T255616[ebp], edx
	cmp	DWORD PTR _iOriginPlotIndex$228016[ebp], 0
	jl	SHORT $LN49@ExecuteTra
	mov	eax, DWORD PTR $T255616[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T255623[ebp], ecx
	mov	edx, DWORD PTR _iOriginPlotIndex$228016[ebp]
	cmp	edx, DWORD PTR $T255623[ebp]
	jge	SHORT $LN49@ExecuteTra
	mov	eax, DWORD PTR _iOriginPlotIndex$228016[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T255616[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv344[ebp], eax
	jmp	SHORT $LN47@ExecuteTra
$LN49@ExecuteTra:
	mov	DWORD PTR tv344[ebp], 0
$LN47@ExecuteTra:
	mov	edx, DWORD PTR tv344[ebp]
	mov	DWORD PTR _pOriginPlot$228027[ebp], edx

; 5032 : 				if (pOriginPlot != pUnit->plot())

	mov	ecx, DWORD PTR _pUnit$228014[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	DWORD PTR _pOriginPlot$228027[ebp], eax
	je	$LN11@ExecuteTra

; 5033 : 				{
; 5034 : 					pUnit->PushMission(CvTypes::getMISSION_CHANGE_TRADE_UNIT_HOME_CITY(), pOriginPlot->getX(), pOriginPlot->getY());

	mov	eax, DWORD PTR _pOriginPlot$228027[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T255633[ebp], ecx
	mov	edx, DWORD PTR _pOriginPlot$228027[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T255637[ebp], eax
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR $T255633[ebp]
	push	ecx
	mov	edx, DWORD PTR $T255637[ebp]
	push	edx
	call	?getMISSION_CHANGE_TRADE_UNIT_HOME_CITY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_CHANGE_TRADE_UNIT_HOME_CITY
	push	eax
	mov	ecx, DWORD PTR _pUnit$228014[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 5035 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN10@ExecuteTra
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN10@ExecuteTra

; 5036 : 					{
; 5037 : 						CvPlot* pPlot = GC.getMap().plotByIndex(iDestPlotIndex);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T255641[ebp], edx
	cmp	DWORD PTR _iDestPlotIndex$228017[ebp], 0
	jl	SHORT $LN61@ExecuteTra
	mov	eax, DWORD PTR $T255641[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T255648[ebp], ecx
	mov	edx, DWORD PTR _iDestPlotIndex$228017[ebp]
	cmp	edx, DWORD PTR $T255648[ebp]
	jge	SHORT $LN61@ExecuteTra
	mov	eax, DWORD PTR _iDestPlotIndex$228017[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T255641[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv351[ebp], eax
	jmp	SHORT $LN59@ExecuteTra
$LN61@ExecuteTra:
	mov	DWORD PTR tv351[ebp], 0
$LN59@ExecuteTra:
	mov	edx, DWORD PTR tv351[ebp]
	mov	DWORD PTR _pPlot$228030[ebp], edx

; 5038 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228031[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 5039 : 						strLogString.Format("Changing trade route home city, X: %d, Y: %d", pPlot->getX(), pPlot->getY());

	mov	eax, DWORD PTR _pPlot$228030[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T255662[ebp], ecx
	mov	edx, DWORD PTR $T255662[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlot$228030[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0CN@BANMAHFA@Changing?5trade?5route?5home?5city?0?5@
	lea	edx, DWORD PTR _strLogString$228031[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5040 : 						LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$228031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 5041 : 					}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$228031[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN10@ExecuteTra:

; 5042 : 				}
; 5043 : 				else

	jmp	$LN12@ExecuteTra
$LN11@ExecuteTra:

; 5044 : 				{
; 5045 : 					pUnit->PushMission(CvTypes::getMISSION_ESTABLISH_TRADE_ROUTE(), iDestPlotIndex, eTradeConnectionType);

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _eTradeConnectionType$228018[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDestPlotIndex$228017[ebp]
	push	edx
	call	?getMISSION_ESTABLISH_TRADE_ROUTE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ESTABLISH_TRADE_ROUTE
	push	eax
	mov	ecx, DWORD PTR _pUnit$228014[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 5046 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN12@ExecuteTra
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN12@ExecuteTra

; 5047 : 					{
; 5048 : 						CvPlot* pPlot = GC.getMap().plotByIndex(iDestPlotIndex);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T255673[ebp], edx
	cmp	DWORD PTR _iDestPlotIndex$228017[ebp], 0
	jl	SHORT $LN79@ExecuteTra
	mov	eax, DWORD PTR $T255673[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T255680[ebp], ecx
	mov	edx, DWORD PTR _iDestPlotIndex$228017[ebp]
	cmp	edx, DWORD PTR $T255680[ebp]
	jge	SHORT $LN79@ExecuteTra
	mov	eax, DWORD PTR _iDestPlotIndex$228017[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T255673[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv374[ebp], eax
	jmp	SHORT $LN77@ExecuteTra
$LN79@ExecuteTra:
	mov	DWORD PTR tv374[ebp], 0
$LN77@ExecuteTra:
	mov	edx, DWORD PTR tv374[ebp]
	mov	DWORD PTR _pPlot$228035[ebp], edx

; 5049 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228036[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 5050 : 
; 5051 : 						switch (eTradeConnectionType)

	mov	eax, DWORD PTR _eTradeConnectionType$228018[ebp]
	mov	DWORD PTR tv236[ebp], eax
	cmp	DWORD PTR tv236[ebp], 0
	je	SHORT $LN4@ExecuteTra
	cmp	DWORD PTR tv236[ebp], 1
	je	SHORT $LN5@ExecuteTra
	cmp	DWORD PTR tv236[ebp], 2
	je	SHORT $LN3@ExecuteTra
	jmp	$LN6@ExecuteTra
$LN5@ExecuteTra:

; 5052 : 						{
; 5053 : 						case TRADE_CONNECTION_FOOD:
; 5054 : 							strLogString.Format("Establishing trade route, X: %d, Y: %d, food", pPlot->getX(), pPlot->getY());

	mov	ecx, DWORD PTR _pPlot$228035[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T255694[ebp], edx
	mov	eax, DWORD PTR $T255694[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$228035[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0CN@MFFCMADF@Establishing?5trade?5route?0?5X?3?5?$CFd?0@
	lea	eax, DWORD PTR _strLogString$228036[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5055 : 							break;

	jmp	SHORT $LN6@ExecuteTra
$LN4@ExecuteTra:

; 5056 : 						case TRADE_CONNECTION_INTERNATIONAL:
; 5057 : 							strLogString.Format("Establishing trade route, X: %d, Y: %d, gold", pPlot->getX(), pPlot->getY());

	mov	ecx, DWORD PTR _pPlot$228035[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T255701[ebp], edx
	mov	eax, DWORD PTR $T255701[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$228035[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0CN@PKHEFHNM@Establishing?5trade?5route?0?5X?3?5?$CFd?0@
	lea	eax, DWORD PTR _strLogString$228036[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5058 : 							break;

	jmp	SHORT $LN6@ExecuteTra
$LN3@ExecuteTra:

; 5059 : 						case TRADE_CONNECTION_PRODUCTION:
; 5060 : 							strLogString.Format("Establishing trade route, X: %d, Y: %d, production", pPlot->getX(), pPlot->getY());

	mov	ecx, DWORD PTR _pPlot$228035[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T255708[ebp], edx
	mov	eax, DWORD PTR $T255708[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$228035[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0DD@BNGIFPFN@Establishing?5trade?5route?0?5X?3?5?$CFd?0@
	lea	eax, DWORD PTR _strLogString$228036[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H
$LN6@ExecuteTra:

; 5061 : 							break;
; 5062 : 						}
; 5063 : 
; 5064 : 						LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$228036[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 5065 : 					}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$228036[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN12@ExecuteTra:

; 5066 : 				}
; 5067 : 			}
; 5068 : 		}
; 5069 : 		else

	jmp	$LN2@ExecuteTra
$LN15@ExecuteTra:

; 5070 : 		{
; 5071 : 			pUnit->PushMission(CvTypes::getMISSION_SKIP());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SKIP
	push	eax
	mov	ecx, DWORD PTR _pUnit$228014[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 5072 : 			pUnit->finishMoves();			

	mov	ecx, DWORD PTR _pUnit$228014[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 5073 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@ExecuteTra
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@ExecuteTra

; 5074 : 			{
; 5075 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228049[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 5076 : 				strLogString.Format("Trade unit idling");

	push	OFFSET ??_C@_0BC@GLFDOKEF@Trade?5unit?5idling?$AA@
	lea	ecx, DWORD PTR _strLogString$228049[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 5077 : 				LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$228049[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 5078 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$228049[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@ExecuteTra:

; 5079 : 		}

	jmp	$LN18@ExecuteTra
$LN21@ExecuteTra:

; 5080 : 	}
; 5081 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ$0:
	mov	eax, DWORD PTR ?$S1@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4IA, eax
	ret	0
__unwindfunclet$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$228024[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$228031[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strLogString$228036[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLogString$228049[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::ExecuteTradeUnitMoves
PUBLIC	??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ	; BaseVector<TradeConnection,0>::~BaseVector<TradeConnection,0>
PUBLIC	?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z ; FStaticVector<TradeConnection,168,0,297,0>::Free
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__FaTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__FaTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@YAXXZ$0
__ehfuncinfo$??__FaTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__FaTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??__FaTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__FaTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@YAXXZ PROC ; `CvHomelandAI::ExecuteTradeUnitMoves'::`2'::`dynamic atexit destructor for 'aTradeConnections'', COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??__FaTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A+4
	push	eax
	mov	ecx, DWORD PTR ?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A
	push	ecx
	mov	ecx, OFFSET ?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A
	call	?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z ; FStaticVector<TradeConnection,168,0,297,0>::Free
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__FaTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@YAXXZ$0:
	mov	ecx, OFFSET ?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A
	jmp	??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ ; BaseVector<TradeConnection,0>::~BaseVector<TradeConnection,0>
__ehhandler$??__FaTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??__FaTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__FaTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@YAXXZ ENDP ; `CvHomelandAI::ExecuteTradeUnitMoves'::`2'::`dynamic atexit destructor for 'aTradeConnections''
PUBLIC	??_C@_0CM@DNKIHEOF@Archaeologist?5creating?5dig?5at?0?5X@ ; `string'
PUBLIC	??_C@_0CO@KOBKHIOH@Archaeologist?5moving?5to?5site?5at?0@ ; `string'
PUBLIC	??_C@_0BG@MPJMNPKL@BUILD_ARCHAEOLOGY_DIG?$AA@	; `string'
PUBLIC	?FindArchaeologistTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z ; CvHomelandAI::FindArchaeologistTarget
PUBLIC	__$ArrayPad$
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
;	COMDAT ??_C@_0CM@DNKIHEOF@Archaeologist?5creating?5dig?5at?0?5X@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fautovariable.h
CONST	SEGMENT
??_C@_0CM@DNKIHEOF@Archaeologist?5creating?5dig?5at?0?5X@ DB 'Archaeologi'
	DB	'st creating dig at, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@KOBKHIOH@Archaeologist?5moving?5to?5site?5at?0@
CONST	SEGMENT
??_C@_0CO@KOBKHIOH@Archaeologist?5moving?5to?5site?5at?0@ DB 'Archaeologi'
	DB	'st moving to site at, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MPJMNPKL@BUILD_ARCHAEOLOGY_DIG?$AA@
CONST	SEGMENT
??_C@_0BG@MPJMNPKL@BUILD_ARCHAEOLOGY_DIG?$AA@ DB 'BUILD_ARCHAEOLOGY_DIG', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ$1
__ehfuncinfo$?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -128						; size = 4
$T255870 = -124						; size = 4
$T255854 = -120						; size = 4
$T255839 = -116						; size = 4
$T255831 = -112						; size = 4
$T255827 = -108						; size = 4
$T255823 = -104						; size = 4
$T255819 = -100						; size = 4
$T255815 = -96						; size = 4
$T255811 = -92						; size = 4
_strLogString$228073 = -88				; size = 28
_strLogString$228069 = -60				; size = 28
__$ArrayPad$ = -32					; size = 4
_eBuild$228064 = -28					; size = 4
_pUnit$228060 = -24					; size = 4
_pTarget$228062 = -20					; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::ExecuteArchaeologistMoves, COMDAT
; _this$ = ecx

; 5085 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5086 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 5087 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN10@ExecuteArc
$LN9@ExecuteArc:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], edx
$LN10@ExecuteArc:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T255811[ebp], eax
	mov	ecx, DWORD PTR $T255811[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T255811[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN11@ExecuteArc

; 5088 : 	{
; 5089 : 		CvUnit* pUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T255815[ebp], edx
	mov	eax, DWORD PTR $T255815[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pUnit$228060[ebp], eax

; 5090 : 		if(!pUnit)

	cmp	DWORD PTR _pUnit$228060[ebp], 0
	jne	SHORT $LN7@ExecuteArc

; 5091 : 		{
; 5092 : 			continue;

	jmp	SHORT $LN9@ExecuteArc
$LN7@ExecuteArc:

; 5093 : 		}
; 5094 : 
; 5095 : 		CvPlot* pTarget = FindArchaeologistTarget(pUnit);

	mov	edx, DWORD PTR _pUnit$228060[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindArchaeologistTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z ; CvHomelandAI::FindArchaeologistTarget
	mov	DWORD PTR _pTarget$228062[ebp], eax

; 5096 : 		if (pTarget)

	cmp	DWORD PTR _pTarget$228062[ebp], 0
	je	$LN6@ExecuteArc

; 5097 : 		{
; 5098 : 			BuildTypes eBuild = (BuildTypes)GC.getInfoTypeForString("BUILD_ARCHAEOLOGY_DIG");

	push	0
	push	OFFSET ??_C@_0BG@MPJMNPKL@BUILD_ARCHAEOLOGY_DIG?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eBuild$228064[ebp], eax

; 5099 : 			if(pUnit->UnitPathTo(pTarget->getX(), pTarget->getY(), 0) > 0)

	mov	eax, DWORD PTR _pTarget$228062[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T255819[ebp], ecx
	mov	edx, DWORD PTR _pTarget$228062[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T255823[ebp], eax
	push	0
	push	-1
	push	0
	mov	ecx, DWORD PTR $T255819[ebp]
	push	ecx
	mov	edx, DWORD PTR $T255823[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnit$228060[ebp]
	call	?UnitPathTo@CvUnit@@QAEHHHHH_N@Z	; CvUnit::UnitPathTo
	test	eax, eax
	jle	$LN51@ExecuteArc

; 5100 : 			{
; 5101 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());

	mov	eax, DWORD PTR _pTarget$228062[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T255827[ebp], ecx
	mov	edx, DWORD PTR _pTarget$228062[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T255831[ebp], eax
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR $T255827[ebp]
	push	ecx
	mov	edx, DWORD PTR $T255831[ebp]
	push	edx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR _pUnit$228060[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 5102 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@ExecuteArc
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@ExecuteArc

; 5103 : 				{
; 5104 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228069[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5105 : 					strLogString.Format("Archaeologist moving to site at, X: %d, Y: %d", pTarget->getX(), pTarget->getY());

	mov	edx, DWORD PTR _pTarget$228062[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T255839[ebp], eax
	mov	ecx, DWORD PTR $T255839[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTarget$228062[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_0CO@KOBKHIOH@Archaeologist?5moving?5to?5site?5at?0@
	lea	ecx, DWORD PTR _strLogString$228069[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5106 : 					LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$228069[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 5107 : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$228069[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@ExecuteArc:

; 5108 : 
; 5109 : 				if(pUnit->plot() == pTarget)

	mov	ecx, DWORD PTR _pUnit$228060[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pTarget$228062[ebp]
	jne	$LN3@ExecuteArc

; 5110 : 				{
; 5111 : 					pUnit->PushMission(CvTypes::getMISSION_BUILD(), eBuild, -1, 0, (pUnit->GetLengthMissionQueue() > 0), false, MISSIONAI_BUILD, pTarget);

	push	0
	mov	eax, DWORD PTR _pTarget$228062[ebp]
	push	eax
	push	18					; 00000012H
	push	0
	mov	ecx, DWORD PTR _pUnit$228060[ebp]
	call	?GetLengthMissionQueue@CvUnit@@QBEHXZ	; CvUnit::GetLengthMissionQueue
	test	eax, eax
	setg	cl
	movzx	edx, cl
	push	edx
	push	0
	push	-1
	mov	eax, DWORD PTR _eBuild$228064[ebp]
	push	eax
	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	push	eax
	mov	ecx, DWORD PTR _pUnit$228060[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 5112 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@ExecuteArc
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@ExecuteArc

; 5113 : 					{
; 5114 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228073[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 5115 : 						strLogString.Format("Archaeologist creating dig at, X: %d, Y: %d", pTarget->getX(), pTarget->getY());

	mov	eax, DWORD PTR _pTarget$228062[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T255854[ebp], ecx
	mov	edx, DWORD PTR $T255854[ebp]
	push	edx
	mov	eax, DWORD PTR _pTarget$228062[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0CM@DNKIHEOF@Archaeologist?5creating?5dig?5at?0?5X@
	lea	edx, DWORD PTR _strLogString$228073[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5116 : 						LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$228073[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 5117 : 					}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$228073[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@ExecuteArc:

; 5118 : 				}
; 5119 : 				else

	jmp	SHORT $LN51@ExecuteArc
$LN3@ExecuteArc:

; 5120 : 				{
; 5121 : 					pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$228060[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 5122 : 				}
; 5123 : 			}
; 5124 : 			// Delete this unit from those we have to move
; 5125 : 			UnitProcessed(pUnit->GetID());

$LN51@ExecuteArc:
	mov	ecx, DWORD PTR _pUnit$228060[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T255870[ebp], edx
	mov	eax, DWORD PTR $T255870[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed
$LN6@ExecuteArc:

; 5126 : 		}

	jmp	$LN9@ExecuteArc
$LN11@ExecuteArc:

; 5127 : 	}
; 5128 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strLogString$228069[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$228073[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-120]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::ExecuteArchaeologistMoves
PUBLIC	??4?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator=
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ$2
__ehfuncinfo$?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -376						; size = 4
$T256373 = -260						; size = 4
$T256369 = -256						; size = 4
$T256353 = -252						; size = 4
$T256349 = -248						; size = 4
$T256333 = -244						; size = 4
$T256329 = -240						; size = 4
$T256313 = -236						; size = 4
$T256309 = -232						; size = 4
$T256279 = -228						; size = 4
$T256255 = -224						; size = 4
$T256231 = -220						; size = 4
$T256207 = -216						; size = 4
$T256181 = -212						; size = 4
$T256155 = -208						; size = 4
$T256139 = -204						; size = 4
$T256167 = -200						; size = 4
$T256166 = -196						; size = 4
$T256165 = -192						; size = 4
$T256164 = -188						; size = 4
$T256163 = -184						; size = 4
$T255945 = -80						; size = 4
$T255944 = -76						; size = 4
$T255911 = -72						; size = 4
$T255895 = -68						; size = 4
$T255884 = -64						; size = 4
$T255883 = -60						; size = 4
$T255882 = -56						; size = 4
$T255881 = -52						; size = 4
$T255880 = -48						; size = 4
$T255879 = -44						; size = 4
_bFoundAdjacent$228097 = -37				; size = 1
_tempPoints$ = -36					; size = 16
_it2$ = -20						; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ PROC ; CvHomelandAI::EliminateAdjacentSentryPoints, COMDAT
; _this$ = ecx

; 5132 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 364				; 0000016cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5133 : 	// First, sort the sentry points by priority
; 5134 : 	std::stable_sort(m_TargetedSentryPoints.begin(), m_TargetedSentryPoints.end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2436]
	mov	DWORD PTR $T255895[ebp], ecx
	mov	edx, DWORD PTR $T255895[ebp]
	mov	DWORD PTR $T255879[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2432]
	mov	DWORD PTR $T255911[ebp], ecx
	mov	edx, DWORD PTR $T255911[ebp]
	mov	DWORD PTR $T255880[ebp], edx
	mov	eax, DWORD PTR $T255879[ebp]
	mov	DWORD PTR $T255945[ebp], eax
	mov	ecx, DWORD PTR $T255880[ebp]
	mov	DWORD PTR $T255944[ebp], ecx
	mov	edx, DWORD PTR $T255944[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T255945[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN25@EliminateA
	push	0
	push	0
	mov	eax, DWORD PTR $T255945[ebp]
	push	eax
	mov	ecx, DWORD PTR $T255944[ebp]
	push	ecx
	call	??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
	add	esp, 16					; 00000010H
$LN25@EliminateA:

; 5135 : 
; 5136 : 	// Create temporary copy of list
; 5137 : 	std::vector<CvHomelandTarget> tempPoints;

	lea	ecx, DWORD PTR _tempPoints$[ebp]
	call	??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5138 : 	tempPoints = m_TargetedSentryPoints;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2428				; 0000097cH
	push	edx
	lea	ecx, DWORD PTR _tempPoints$[ebp]
	call	??4?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator=

; 5139 : 
; 5140 : 	// Clear out main list
; 5141 : 	m_TargetedSentryPoints.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2428				; 0000097cH
	mov	DWORD PTR $T256181[ebp], eax
	mov	ecx, DWORD PTR $T256181[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T256139[ebp], edx
	mov	eax, DWORD PTR $T256139[ebp]
	mov	DWORD PTR $T256164[ebp], eax
	mov	ecx, DWORD PTR $T256164[ebp]
	mov	DWORD PTR $T256163[ebp], ecx
	mov	edx, DWORD PTR $T256181[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T256155[ebp], eax
	mov	ecx, DWORD PTR $T256155[ebp]
	mov	DWORD PTR $T256166[ebp], ecx
	mov	edx, DWORD PTR $T256166[ebp]
	mov	DWORD PTR $T256165[ebp], edx
	mov	eax, DWORD PTR $T256163[ebp]
	push	eax
	mov	ecx, DWORD PTR $T256165[ebp]
	push	ecx
	lea	edx, DWORD PTR $T256167[ebp]
	push	edx
	mov	ecx, DWORD PTR $T256181[ebp]
	call	?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase

; 5142 : 
; 5143 : 	// Loop through all points in copy
; 5144 : 	std::vector<CvHomelandTarget>::iterator it, it2;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it2$[ebp], 0

; 5145 : 	for(it = tempPoints.begin(); it != tempPoints.end(); ++it)

	mov	eax, DWORD PTR _tempPoints$[ebp+4]
	mov	DWORD PTR $T256207[ebp], eax
	mov	ecx, DWORD PTR $T256207[ebp]
	mov	DWORD PTR $T255881[ebp], ecx
	mov	edx, DWORD PTR $T255881[ebp]
	mov	DWORD PTR _it$[ebp], edx
	jmp	SHORT $LN8@EliminateA
$LN7@EliminateA:
	mov	eax, DWORD PTR _it$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _it$[ebp], eax
$LN8@EliminateA:
	mov	ecx, DWORD PTR _tempPoints$[ebp+8]
	mov	DWORD PTR $T256231[ebp], ecx
	mov	edx, DWORD PTR $T256231[ebp]
	mov	DWORD PTR $T255882[ebp], edx
	mov	eax, DWORD PTR _it$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T255882[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN6@EliminateA

; 5146 : 	{
; 5147 : 		bool bFoundAdjacent = false;

	mov	BYTE PTR _bFoundAdjacent$228097[ebp], 0

; 5148 : 
; 5149 : 		// Is it adjacent to a point in the main list?
; 5150 : 		for(it2 = m_TargetedSentryPoints.begin(); it2 != m_TargetedSentryPoints.end(); ++it2)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2432]
	mov	DWORD PTR $T256255[ebp], edx
	mov	eax, DWORD PTR $T256255[ebp]
	mov	DWORD PTR $T255883[ebp], eax
	mov	ecx, DWORD PTR $T255883[ebp]
	mov	DWORD PTR _it2$[ebp], ecx
	jmp	SHORT $LN5@EliminateA
$LN4@EliminateA:
	mov	edx, DWORD PTR _it2$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR _it2$[ebp], edx
$LN5@EliminateA:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2436]
	mov	DWORD PTR $T256279[ebp], ecx
	mov	edx, DWORD PTR $T256279[ebp]
	mov	DWORD PTR $T255884[ebp], edx
	mov	eax, DWORD PTR _it2$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T255884[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN3@EliminateA

; 5151 : 		{
; 5152 : 			if(plotDistance(it->GetTargetX(), it->GetTargetY(), it2->GetTargetX(), it2->GetTargetY()) == 1)

	mov	ecx, DWORD PTR _it2$[ebp]
	mov	DWORD PTR $T256309[ebp], ecx
	mov	edx, DWORD PTR $T256309[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T256313[ebp], eax
	mov	ecx, DWORD PTR _it2$[ebp]
	mov	DWORD PTR $T256329[ebp], ecx
	mov	edx, DWORD PTR $T256329[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T256333[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T256349[ebp], ecx
	mov	edx, DWORD PTR $T256349[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T256353[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T256369[ebp], ecx
	mov	edx, DWORD PTR $T256369[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T256373[ebp], eax
	mov	ecx, DWORD PTR $T256313[ebp]
	push	ecx
	mov	edx, DWORD PTR $T256333[ebp]
	push	edx
	mov	eax, DWORD PTR $T256353[ebp]
	push	eax
	mov	ecx, DWORD PTR $T256373[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jne	SHORT $LN2@EliminateA

; 5153 : 			{
; 5154 : 				bFoundAdjacent = true;

	mov	BYTE PTR _bFoundAdjacent$228097[ebp], 1

; 5155 : 				break;

	jmp	SHORT $LN3@EliminateA
$LN2@EliminateA:

; 5156 : 			}
; 5157 : 		}

	jmp	$LN4@EliminateA
$LN3@EliminateA:

; 5158 : 
; 5159 : 		if(!bFoundAdjacent)

	movzx	edx, BYTE PTR _bFoundAdjacent$228097[ebp]
	test	edx, edx
	jne	SHORT $LN1@EliminateA

; 5160 : 		{
; 5161 : 			m_TargetedSentryPoints.push_back(*it);

	mov	eax, DWORD PTR _it$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2428				; 0000097cH
	call	?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back
$LN1@EliminateA:

; 5162 : 		}
; 5163 : 	}

	jmp	$LN7@EliminateA
$LN6@EliminateA:

; 5164 : }

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _tempPoints$[ebp]
	call	?_Tidy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _tempPoints$[ebp]
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__unwindfunclet$?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _tempPoints$[ebp]
	jmp	??1?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
__ehhandler$?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-368]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ ENDP ; CvHomelandAI::EliminateAdjacentSentryPoints
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ$2
__ehfuncinfo$?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -376						; size = 4
$T256991 = -236						; size = 4
$T256987 = -232						; size = 4
$T256971 = -228						; size = 4
$T256967 = -224						; size = 4
$T256951 = -220						; size = 4
$T256947 = -216						; size = 4
$T256931 = -212						; size = 4
$T256927 = -208						; size = 4
$T256897 = -204						; size = 4
$T256873 = -200						; size = 4
$T256849 = -196						; size = 4
$T256825 = -192						; size = 4
$T256799 = -188						; size = 4
$T256773 = -184						; size = 4
$T256757 = -180						; size = 4
$T256786 = -176						; size = 4
$T256785 = -172						; size = 4
$T256784 = -168						; size = 4
$T256783 = -164						; size = 4
$T256782 = -160						; size = 4
$T256562 = -56						; size = 4
$T256561 = -52						; size = 4
$T256560 = -48						; size = 4
$T256559 = -44						; size = 4
_bFoundAdjacent$228124 = -37				; size = 1
_tempPoints$ = -36					; size = 16
_it2$ = -20						; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ PROC ; CvHomelandAI::EliminateAdjacentHomelandRoads, COMDAT
; _this$ = ecx

; 5168 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 364				; 0000016cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5169 : 	// Create temporary copy of list
; 5170 : 	std::vector<CvHomelandTarget> tempPoints;

	lea	ecx, DWORD PTR _tempPoints$[ebp]
	call	??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5171 : 	tempPoints = m_TargetedHomelandRoads;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2476				; 000009acH
	push	eax
	lea	ecx, DWORD PTR _tempPoints$[ebp]
	call	??4?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator=

; 5172 : 
; 5173 : 	// Clear out main list
; 5174 : 	m_TargetedHomelandRoads.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2476				; 000009acH
	mov	DWORD PTR $T256799[ebp], ecx
	mov	edx, DWORD PTR $T256799[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T256757[ebp], eax
	mov	ecx, DWORD PTR $T256757[ebp]
	mov	DWORD PTR $T256783[ebp], ecx
	mov	edx, DWORD PTR $T256783[ebp]
	mov	DWORD PTR $T256782[ebp], edx
	mov	eax, DWORD PTR $T256799[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T256773[ebp], ecx
	mov	edx, DWORD PTR $T256773[ebp]
	mov	DWORD PTR $T256785[ebp], edx
	mov	eax, DWORD PTR $T256785[ebp]
	mov	DWORD PTR $T256784[ebp], eax
	mov	ecx, DWORD PTR $T256782[ebp]
	push	ecx
	mov	edx, DWORD PTR $T256784[ebp]
	push	edx
	lea	eax, DWORD PTR $T256786[ebp]
	push	eax
	mov	ecx, DWORD PTR $T256799[ebp]
	call	?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase

; 5175 : 
; 5176 : 	// Loop through all points in copy
; 5177 : 	std::vector<CvHomelandTarget>::iterator it, it2;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it2$[ebp], 0

; 5178 : 	for(it = tempPoints.begin(); it != tempPoints.end(); ++it)

	mov	ecx, DWORD PTR _tempPoints$[ebp+4]
	mov	DWORD PTR $T256825[ebp], ecx
	mov	edx, DWORD PTR $T256825[ebp]
	mov	DWORD PTR $T256559[ebp], edx
	mov	eax, DWORD PTR $T256559[ebp]
	mov	DWORD PTR _it$[ebp], eax
	jmp	SHORT $LN8@EliminateA@2
$LN7@EliminateA@2:
	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _it$[ebp], ecx
$LN8@EliminateA@2:
	mov	edx, DWORD PTR _tempPoints$[ebp+8]
	mov	DWORD PTR $T256849[ebp], edx
	mov	eax, DWORD PTR $T256849[ebp]
	mov	DWORD PTR $T256560[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T256560[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@EliminateA@2

; 5179 : 	{
; 5180 : 		bool bFoundAdjacent = false;

	mov	BYTE PTR _bFoundAdjacent$228124[ebp], 0

; 5181 : 
; 5182 : 		// Is it adjacent to a point in the main list?
; 5183 : 		for(it2 = m_TargetedHomelandRoads.begin(); it2 != m_TargetedHomelandRoads.end(); ++it2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2480]
	mov	DWORD PTR $T256873[ebp], eax
	mov	ecx, DWORD PTR $T256873[ebp]
	mov	DWORD PTR $T256561[ebp], ecx
	mov	edx, DWORD PTR $T256561[ebp]
	mov	DWORD PTR _it2$[ebp], edx
	jmp	SHORT $LN5@EliminateA@2
$LN4@EliminateA@2:
	mov	eax, DWORD PTR _it2$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _it2$[ebp], eax
$LN5@EliminateA@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2484]
	mov	DWORD PTR $T256897[ebp], edx
	mov	eax, DWORD PTR $T256897[ebp]
	mov	DWORD PTR $T256562[ebp], eax
	mov	ecx, DWORD PTR _it2$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T256562[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@EliminateA@2

; 5184 : 		{
; 5185 : 			if(plotDistance(it->GetTargetX(), it->GetTargetY(), it2->GetTargetX(), it2->GetTargetY()) == 1)

	mov	edx, DWORD PTR _it2$[ebp]
	mov	DWORD PTR $T256927[ebp], edx
	mov	eax, DWORD PTR $T256927[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T256931[ebp], ecx
	mov	edx, DWORD PTR _it2$[ebp]
	mov	DWORD PTR $T256947[ebp], edx
	mov	eax, DWORD PTR $T256947[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T256951[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T256967[ebp], edx
	mov	eax, DWORD PTR $T256967[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T256971[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T256987[ebp], edx
	mov	eax, DWORD PTR $T256987[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T256991[ebp], ecx
	mov	edx, DWORD PTR $T256931[ebp]
	push	edx
	mov	eax, DWORD PTR $T256951[ebp]
	push	eax
	mov	ecx, DWORD PTR $T256971[ebp]
	push	ecx
	mov	edx, DWORD PTR $T256991[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jne	SHORT $LN2@EliminateA@2

; 5186 : 			{
; 5187 : 				bFoundAdjacent = true;

	mov	BYTE PTR _bFoundAdjacent$228124[ebp], 1

; 5188 : 				break;

	jmp	SHORT $LN3@EliminateA@2
$LN2@EliminateA@2:

; 5189 : 			}
; 5190 : 		}

	jmp	$LN4@EliminateA@2
$LN3@EliminateA@2:

; 5191 : 
; 5192 : 		if(!bFoundAdjacent)

	movzx	eax, BYTE PTR _bFoundAdjacent$228124[ebp]
	test	eax, eax
	jne	SHORT $LN1@EliminateA@2

; 5193 : 		{
; 5194 : 			m_TargetedHomelandRoads.push_back(*it);

	mov	ecx, DWORD PTR _it$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2476				; 000009acH
	call	?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back
$LN1@EliminateA@2:

; 5195 : 		}
; 5196 : 	}

	jmp	$LN7@EliminateA@2
$LN6@EliminateA@2:

; 5197 : }

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _tempPoints$[ebp]
	call	?_Tidy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _tempPoints$[ebp]
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__unwindfunclet$?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _tempPoints$[ebp]
	jmp	??1?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
__ehhandler$?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-368]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ ENDP ; CvHomelandAI::EliminateAdjacentHomelandRoads
PUBLIC	??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>
PUBLIC	?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z ; CvHomelandAI::FindWorkersInSameArea
EXTRN	?IsCanAttack@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsCanAttack
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z$0
__ehfuncinfo$?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z
_TEXT	SEGMENT
tv205 = -192						; size = 4
tv204 = -188						; size = 4
_this$ = -184						; size = 4
$T257404 = -116						; size = 4
$T257400 = -112						; size = 4
$T257399 = -108						; size = 4
$T257373 = -100						; size = 4
$T257364 = -96						; size = 4
$T257360 = -92						; size = 4
$T257350 = -88						; size = 4
$T257346 = -84						; size = 4
$T257333 = -80						; size = 4
$T257326 = -76						; size = 4
$T257316 = -72						; size = 4
$T257286 = -68						; size = 4
$T257253 = -64						; size = 4
$T257244 = -60						; size = 4
$T257237 = -56						; size = 4
$T257236 = -52						; size = 4
_unit$228152 = -48					; size = 16
_iMoves$228153 = -32					; size = 4
_pLoopUnit$228148 = -28					; size = 8
_it$228142 = -20					; size = 4
_rtnValue$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_pTarget$ = 8						; size = 4
_eBuild$ = 12						; size = 4
?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z PROC ; CvHomelandAI::FindWorkersInSameArea, COMDAT
; _this$ = ecx

; 5201 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5202 : 	bool rtnValue = false;

	mov	BYTE PTR _rtnValue$[ebp], 0

; 5203 : 	ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 5204 : 
; 5205 : 	// Loop through all units available to homeland AI this turn
; 5206 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T257244[ebp], ecx
	mov	edx, DWORD PTR $T257244[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T257253[ebp], eax
	mov	ecx, DWORD PTR $T257253[ebp]
	mov	DWORD PTR _it$228142[ebp], ecx
	jmp	SHORT $LN7@FindWorker
$LN24@FindWorker:
	mov	edx, DWORD PTR _it$228142[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$228142[ebp], eax
$LN7@FindWorker:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T257286[ebp], edx
	mov	eax, DWORD PTR $T257286[ebp]
	mov	DWORD PTR $T257236[ebp], eax
	mov	ecx, DWORD PTR _it$228142[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T257236[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@FindWorker

; 5207 : 	{
; 5208 : 		UnitHandle pLoopUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR _it$228142[ebp]
	add	edx, 8
	mov	DWORD PTR $T257316[ebp], edx
	mov	eax, DWORD PTR $T257316[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T257326[ebp], eax
	mov	eax, DWORD PTR $T257326[ebp]
	mov	DWORD PTR _pLoopUnit$228148[ebp], eax
	mov	BYTE PTR _pLoopUnit$228148[ebp+4], 0
	cmp	DWORD PTR _pLoopUnit$228148[ebp], 0
	je	SHORT $LN43@FindWorker
	mov	ecx, DWORD PTR _pLoopUnit$228148[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN43@FindWorker:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5209 : 		if(pLoopUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pLoopUnit$228148[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN4@FindWorker

; 5210 : 		{
; 5211 : 			// Civilians only
; 5212 : 			if(pLoopUnit->IsCanAttack())

	mov	eax, DWORD PTR _pLoopUnit$228148[ebp]
	mov	DWORD PTR $T257333[ebp], eax
	mov	ecx, DWORD PTR $T257333[ebp]
	call	?IsCanAttack@CvUnit@@QBE_NXZ		; CvUnit::IsCanAttack
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@FindWorker

; 5213 : 			{
; 5214 : 				continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pLoopUnit$228148[ebp], 0
	je	SHORT $LN52@FindWorker
	mov	ecx, DWORD PTR _pLoopUnit$228148[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN52@FindWorker:
	jmp	$LN24@FindWorker
$LN3@FindWorker:

; 5215 : 			}
; 5216 : 
; 5217 : 			// Can this worker make the right improvement?
; 5218 : 			if(pLoopUnit->canBuild(pTarget, eBuild))

	mov	edx, DWORD PTR _pLoopUnit$228148[ebp]
	mov	DWORD PTR $T257346[ebp], edx
	push	1
	push	0
	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarget$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T257346[ebp]
	call	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z ; CvUnit::canBuild
	movzx	edx, al
	test	edx, edx
	je	$LN4@FindWorker

; 5219 : 			{
; 5220 : 				CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$228152[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 5221 : 				int iMoves = TurnsToReachTarget(pLoopUnit.pointer(), pTarget);

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _pTarget$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$228148[ebp]
	mov	DWORD PTR $T257350[ebp], ecx
	sub	esp, 8
	mov	edx, esp
	mov	DWORD PTR $T257237[ebp], esp
	mov	DWORD PTR $T257360[ebp], edx
	mov	eax, DWORD PTR $T257360[ebp]
	mov	ecx, DWORD PTR $T257350[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T257360[ebp]
	mov	BYTE PTR [edx+4], 0
	mov	eax, DWORD PTR $T257360[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN61@FindWorker
	mov	ecx, DWORD PTR $T257360[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN61@FindWorker:
	mov	edx, DWORD PTR $T257360[ebp]
	mov	DWORD PTR tv204[ebp], edx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv205[ebp], eax
	mov	eax, DWORD PTR tv205[ebp]
	mov	DWORD PTR _iMoves$228153[ebp], eax

; 5222 : 
; 5223 : 				if(iMoves != MAX_INT)

	cmp	DWORD PTR _iMoves$228153[ebp], 2147483647 ; 7fffffffH
	je	SHORT $LN4@FindWorker

; 5224 : 				{
; 5225 : 					unit.SetID(pLoopUnit->GetID());

	mov	ecx, DWORD PTR _pLoopUnit$228148[ebp]
	mov	DWORD PTR $T257364[ebp], ecx
	mov	edx, DWORD PTR $T257364[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T257373[ebp], eax
	mov	ecx, DWORD PTR $T257373[ebp]
	mov	DWORD PTR _unit$228152[ebp], ecx

; 5226 : 					unit.SetMovesToTarget(iMoves);

	mov	edx, DWORD PTR _iMoves$228153[ebp]
	mov	DWORD PTR _unit$228152[ebp+8], edx

; 5227 : 					m_CurrentMoveUnits.push_back(unit);

	lea	eax, DWORD PTR _unit$228152[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back

; 5228 : 					rtnValue = true;

	mov	BYTE PTR _rtnValue$[ebp], 1
$LN4@FindWorker:

; 5229 : 				}
; 5230 : 			}
; 5231 : 		}
; 5232 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pLoopUnit$228148[ebp], 0
	je	SHORT $LN83@FindWorker
	mov	ecx, DWORD PTR _pLoopUnit$228148[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN83@FindWorker:
	jmp	$LN24@FindWorker
$LN5@FindWorker:

; 5233 : 
; 5234 : 	// Now sort them in the order we'd like them to move
; 5235 : 	std::stable_sort(m_CurrentMoveUnits.begin(), m_CurrentMoveUnits.end());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T257399[ebp], ecx
	mov	edx, DWORD PTR $T257399[ebp]
	mov	eax, DWORD PTR [edx+4]
	shl	eax, 4
	mov	ecx, DWORD PTR $T257399[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T257400[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR $T257404[ebp], eax
	mov	ecx, DWORD PTR $T257404[ebp]
	cmp	ecx, DWORD PTR $T257400[ebp]
	je	SHORT $LN92@FindWorker
	push	0
	push	0
	mov	edx, DWORD PTR $T257400[ebp]
	push	edx
	mov	eax, DWORD PTR $T257404[ebp]
	push	eax
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 16					; 00000010H
$LN92@FindWorker:

; 5236 : 
; 5237 : 	return rtnValue;

	mov	al, BYTE PTR _rtnValue$[ebp]

; 5238 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z$0:
	lea	ecx, DWORD PTR _pLoopUnit$228148[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-184]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z ENDP ; CvHomelandAI::FindWorkersInSameArea
PUBLIC	??4?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::operator=
PUBLIC	?ClearCurrentMoveHighPriorityUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveHighPriorityUnits
PUBLIC	__$ArrayPad$
EXTRN	?getExtraVisibilityRange@CvUnit@@QBEHXZ:PROC	; CvUnit::getExtraVisibilityRange
EXTRN	?noDefensiveBonus@CvUnit@@QBE_NXZ:PROC		; CvUnit::noDefensiveBonus
EXTRN	?getExtraCombatPercent@CvUnit@@QBEHXZ:PROC	; CvUnit::getExtraCombatPercent
EXTRN	?getAttackModifier@CvUnit@@QBEHXZ:PROC		; CvUnit::getAttackModifier
EXTRN	?getDefenseModifier@CvUnit@@QBEHXZ:PROC		; CvUnit::getDefenseModifier
EXTRN	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z:PROC	; CvUnitEntry::GetUnitAIType
EXTRN	?isRanged@CvUnit@@QBE_NXZ:PROC			; CvUnit::isRanged
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z$1
__ehfuncinfo$?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z
_TEXT	SEGMENT
tv156 = -1380						; size = 4
_this$ = -1376						; size = 4
$T258095 = -1356					; size = 4
$T258085 = -1352					; size = 4
$T258059 = -1348					; size = 4
$T258058 = -1344					; size = 4
$T258072 = -1340					; size = 4
$T257986 = -1336					; size = 4
$T257977 = -1332					; size = 4
$T257966 = -1328					; size = 4
$T257956 = -1324					; size = 4
$T257917 = -1308					; size = 4
$T257907 = -1304					; size = 4
$T257881 = -1300					; size = 4
$T257880 = -1296					; size = 4
$T257884 = -1292					; size = 4
$T257808 = -1288					; size = 4
$T257799 = -1284					; size = 4
$T257788 = -1280					; size = 4
$T257778 = -1276					; size = 4
$T257720 = -1260					; size = 4
$T257711 = -1256					; size = 4
$T257707 = -1252					; size = 4
$T257703 = -1248					; size = 4
$T257699 = -1244					; size = 4
$T257695 = -1240					; size = 4
$T257691 = -1236					; size = 4
$T257687 = -1232					; size = 4
$T257683 = -1228					; size = 4
$T257679 = -1224					; size = 4
$T257675 = -1220					; size = 4
$T257671 = -1216					; size = 4
$T257667 = -1212					; size = 4
$T257663 = -1208					; size = 4
$T257659 = -1204					; size = 4
$T257655 = -1200					; size = 4
$T257651 = -1196					; size = 4
$T257647 = -1192					; size = 4
$T257634 = -1188					; size = 4
$T257633 = -1184					; size = 4
$T257629 = -1180					; size = 4
$T257608 = -1176					; size = 4
$T257604 = -1172					; size = 4
$T257597 = -1168					; size = 4
$T257587 = -1164					; size = 4
$T257557 = -1160					; size = 4
$T257524 = -1156					; size = 4
$T257515 = -1152					; size = 4
$T257508 = -1148					; size = 4
$T257507 = -1144					; size = 4
$T257506 = -1140					; size = 4
$T257505 = -1136					; size = 4
$T257504 = -1132					; size = 4
$T257503 = -1128					; size = 4
$T257502 = -1124					; size = 4
$T257501 = -1120					; size = 4
$T257500 = -1116					; size = 4
$T257499 = -1112					; size = 4
$T257498 = -1108					; size = 4
_it2$228220 = -1104					; size = 4
_tempList$228213 = -1100				; size = 1040
__$ArrayPad$ = -56					; size = 4
_it$228215 = -52					; size = 4
_unit$228208 = -48					; size = 16
_bHighPriority$228183 = -30				; size = 1
_bSuitableUnit$228182 = -29				; size = 1
_pLoopUnit$228178 = -28					; size = 8
_it$228172 = -20					; size = 4
_rtnValue$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_eMove$ = 8						; size = 4
_bFirstTime$ = 12					; size = 1
?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z PROC ; CvHomelandAI::FindUnitsForThisMove, COMDAT
; _this$ = ecx

; 5242 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1368				; 00000558H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5243 : 	bool rtnValue = false;

	mov	BYTE PTR _rtnValue$[ebp], 0

; 5244 : 
; 5245 : 	if(bFirstTime)

	movzx	eax, BYTE PTR _bFirstTime$[ebp]
	test	eax, eax
	je	$LN40@FindUnitsF

; 5246 : 	{
; 5247 : 		ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 5248 : 		ClearCurrentMoveHighPriorityUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveHighPriorityUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveHighPriorityUnits

; 5249 : 
; 5250 : 		// Loop through all units available to homeland AI this turn
; 5251 : 		for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T257515[ebp], edx
	mov	eax, DWORD PTR $T257515[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T257524[ebp], ecx
	mov	edx, DWORD PTR $T257524[ebp]
	mov	DWORD PTR _it$228172[ebp], edx
	jmp	SHORT $LN39@FindUnitsF
$LN57@FindUnitsF:
	mov	eax, DWORD PTR _it$228172[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _it$228172[ebp], ecx
$LN39@FindUnitsF:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T257557[ebp], eax
	mov	ecx, DWORD PTR $T257557[ebp]
	mov	DWORD PTR $T257498[ebp], ecx
	mov	edx, DWORD PTR _it$228172[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T257498[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN37@FindUnitsF

; 5252 : 		{
; 5253 : 			UnitHandle pLoopUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR _it$228172[ebp]
	add	eax, 8
	mov	DWORD PTR $T257587[ebp], eax
	mov	ecx, DWORD PTR $T257587[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T257597[ebp], eax
	mov	ecx, DWORD PTR $T257597[ebp]
	mov	DWORD PTR _pLoopUnit$228178[ebp], ecx
	mov	BYTE PTR _pLoopUnit$228178[ebp+4], 0
	cmp	DWORD PTR _pLoopUnit$228178[ebp], 0
	je	SHORT $LN76@FindUnitsF
	mov	ecx, DWORD PTR _pLoopUnit$228178[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN76@FindUnitsF:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5254 : 			if(pLoopUnit && !pLoopUnit->isHuman())

	xor	edx, edx
	cmp	DWORD PTR _pLoopUnit$228178[ebp], 0
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN36@FindUnitsF
	mov	ecx, DWORD PTR _pLoopUnit$228178[ebp]
	mov	DWORD PTR $T257604[ebp], ecx
	mov	ecx, DWORD PTR $T257604[ebp]
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	movzx	edx, al
	test	edx, edx
	jne	$LN36@FindUnitsF

; 5255 : 			{
; 5256 : 				// Civilians aren't useful for any of these moves
; 5257 : 				if(!pLoopUnit->IsCombatUnit())

	mov	eax, DWORD PTR _pLoopUnit$228178[ebp]
	mov	DWORD PTR $T257608[ebp], eax
	mov	ecx, DWORD PTR $T257608[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+1044], 0
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN35@FindUnitsF

; 5258 : 				{
; 5259 : 					continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pLoopUnit$228178[ebp], 0
	je	SHORT $LN91@FindUnitsF
	mov	ecx, DWORD PTR _pLoopUnit$228178[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN91@FindUnitsF:
	jmp	$LN57@FindUnitsF
$LN35@FindUnitsF:

; 5260 : 				}
; 5261 : 
; 5262 : #ifndef AUI_HOMELAND_ALWAYS_MOVE_SCOUTS
; 5263 : 				// Scouts aren't useful unless recon is entirely shut off
; 5264 : 				if(pLoopUnit->AI_getUnitAIType() == UNITAI_EXPLORE && m_pPlayer->GetEconomicAI()->GetReconState() != RECON_STATE_ENOUGH)

	mov	ecx, DWORD PTR _pLoopUnit$228178[ebp]
	mov	DWORD PTR $T257629[ebp], ecx
	mov	ecx, DWORD PTR $T257629[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN34@FindUnitsF
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR $T257633[ebp], eax
	mov	eax, DWORD PTR $T257633[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR $T257634[ebp], ecx
	cmp	DWORD PTR $T257634[ebp], 0
	je	SHORT $LN34@FindUnitsF

; 5265 : 				{
; 5266 : 					continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pLoopUnit$228178[ebp], 0
	je	SHORT $LN100@FindUnitsF
	mov	ecx, DWORD PTR _pLoopUnit$228178[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN100@FindUnitsF:
	jmp	$LN57@FindUnitsF
$LN34@FindUnitsF:

; 5267 : 				}
; 5268 : #endif
; 5269 : 
; 5270 : 				bool bSuitableUnit = false;

	mov	BYTE PTR _bSuitableUnit$228182[ebp], 0

; 5271 : 				bool bHighPriority = false;

	mov	BYTE PTR _bHighPriority$228183[ebp], 0

; 5272 : 
; 5273 : 				switch(eMove)

	mov	edx, DWORD PTR _eMove$[ebp]
	mov	DWORD PTR tv156[ebp], edx
	mov	eax, DWORD PTR tv156[ebp]
	sub	eax, 4
	mov	DWORD PTR tv156[ebp], eax
	cmp	DWORD PTR tv156[ebp], 10		; 0000000aH
	ja	$LN32@FindUnitsF
	mov	ecx, DWORD PTR tv156[ebp]
	movzx	edx, BYTE PTR $LN327@FindUnitsF[ecx]
	jmp	DWORD PTR $LN329@FindUnitsF[edx*4]
$LN31@FindUnitsF:

; 5274 : 				{
; 5275 : 				case AI_HOMELAND_MOVE_GARRISON:
; 5276 : 				case AI_HOMELAND_MOVE_GARRISON_CITY_STATE:
; 5277 : 					// Want to put ranged units in cities to give them a ranged attack
; 5278 : 					if(pLoopUnit->isRanged() && !pLoopUnit->getUnitInfo().GetUnitAIType(UNITAI_CITY_BOMBARD))

	mov	eax, DWORD PTR _pLoopUnit$228178[ebp]
	mov	DWORD PTR $T257647[ebp], eax
	mov	ecx, DWORD PTR $T257647[ebp]
	call	?isRanged@CvUnit@@QBE_NXZ		; CvUnit::isRanged
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN30@FindUnitsF
	mov	edx, DWORD PTR _pLoopUnit$228178[ebp]
	mov	DWORD PTR $T257651[ebp], edx
	push	4
	mov	ecx, DWORD PTR $T257651[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN30@FindUnitsF

; 5279 : 					{
; 5280 : 						bSuitableUnit = true;

	mov	BYTE PTR _bSuitableUnit$228182[ebp], 1

; 5281 : 						bHighPriority = true;

	mov	BYTE PTR _bHighPriority$228183[ebp], 1
	jmp	SHORT $LN29@FindUnitsF
$LN30@FindUnitsF:

; 5282 : 					}
; 5283 : 
; 5284 : 					// Don't use non-combatants
; 5285 : 					else if(pLoopUnit->IsCanAttack())

	mov	ecx, DWORD PTR _pLoopUnit$228178[ebp]
	mov	DWORD PTR $T257655[ebp], ecx
	mov	ecx, DWORD PTR $T257655[ebp]
	call	?IsCanAttack@CvUnit@@QBE_NXZ		; CvUnit::IsCanAttack
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN29@FindUnitsF

; 5286 : 					{
; 5287 : 						// Don't put units with a combat strength boosted from promotions in cities, these boosts are ignored
; 5288 : 						if(pLoopUnit->getDefenseModifier() == 0 &&
; 5289 : 						        pLoopUnit->getAttackModifier() == 0 &&
; 5290 : 						        pLoopUnit->getExtraCombatPercent() == 0)

	mov	eax, DWORD PTR _pLoopUnit$228178[ebp]
	mov	DWORD PTR $T257659[ebp], eax
	mov	ecx, DWORD PTR $T257659[ebp]
	call	?getDefenseModifier@CvUnit@@QBEHXZ	; CvUnit::getDefenseModifier
	test	eax, eax
	jne	SHORT $LN29@FindUnitsF
	mov	ecx, DWORD PTR _pLoopUnit$228178[ebp]
	mov	DWORD PTR $T257663[ebp], ecx
	mov	ecx, DWORD PTR $T257663[ebp]
	call	?getAttackModifier@CvUnit@@QBEHXZ	; CvUnit::getAttackModifier
	test	eax, eax
	jne	SHORT $LN29@FindUnitsF
	mov	edx, DWORD PTR _pLoopUnit$228178[ebp]
	mov	DWORD PTR $T257667[ebp], edx
	mov	ecx, DWORD PTR $T257667[ebp]
	call	?getExtraCombatPercent@CvUnit@@QBEHXZ	; CvUnit::getExtraCombatPercent
	test	eax, eax
	jne	SHORT $LN29@FindUnitsF

; 5291 : 						{
; 5292 : 							bSuitableUnit = true;

	mov	BYTE PTR _bSuitableUnit$228182[ebp], 1
$LN29@FindUnitsF:

; 5293 : 						}
; 5294 : 					}
; 5295 : 					break;

	jmp	$LN32@FindUnitsF
$LN26@FindUnitsF:

; 5296 : 
; 5297 : 				case AI_HOMELAND_MOVE_SENTRY:
; 5298 : 					// No ranged units as sentries
; 5299 : 					if(!pLoopUnit->isRanged() && !pLoopUnit->noDefensiveBonus())

	mov	eax, DWORD PTR _pLoopUnit$228178[ebp]
	mov	DWORD PTR $T257671[ebp], eax
	mov	ecx, DWORD PTR $T257671[ebp]
	call	?isRanged@CvUnit@@QBE_NXZ		; CvUnit::isRanged
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN25@FindUnitsF
	mov	edx, DWORD PTR _pLoopUnit$228178[ebp]
	mov	DWORD PTR $T257675[ebp], edx
	mov	ecx, DWORD PTR $T257675[ebp]
	call	?noDefensiveBonus@CvUnit@@QBE_NXZ	; CvUnit::noDefensiveBonus
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN25@FindUnitsF

; 5300 : 					{
; 5301 : 						bSuitableUnit = true;

	mov	BYTE PTR _bSuitableUnit$228182[ebp], 1

; 5302 : 
; 5303 : 						// Units with extra sight are especially valuable
; 5304 : 						if(pLoopUnit->getExtraVisibilityRange() > 0)

	mov	ecx, DWORD PTR _pLoopUnit$228178[ebp]
	mov	DWORD PTR $T257679[ebp], ecx
	mov	ecx, DWORD PTR $T257679[ebp]
	call	?getExtraVisibilityRange@CvUnit@@QBEHXZ	; CvUnit::getExtraVisibilityRange
	test	eax, eax
	jle	SHORT $LN24@FindUnitsF

; 5305 : 						{
; 5306 : 							bHighPriority = true;

	mov	BYTE PTR _bHighPriority$228183[ebp], 1
$LN24@FindUnitsF:

; 5307 : 						}
; 5308 : 					}

	jmp	SHORT $LN23@FindUnitsF
$LN25@FindUnitsF:

; 5309 : 					else if(pLoopUnit->noDefensiveBonus() && pLoopUnit->getExtraVisibilityRange() > 0)

	mov	edx, DWORD PTR _pLoopUnit$228178[ebp]
	mov	DWORD PTR $T257683[ebp], edx
	mov	ecx, DWORD PTR $T257683[ebp]
	call	?noDefensiveBonus@CvUnit@@QBE_NXZ	; CvUnit::noDefensiveBonus
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@FindUnitsF
	mov	ecx, DWORD PTR _pLoopUnit$228178[ebp]
	mov	DWORD PTR $T257687[ebp], ecx
	mov	ecx, DWORD PTR $T257687[ebp]
	call	?getExtraVisibilityRange@CvUnit@@QBEHXZ	; CvUnit::getExtraVisibilityRange
	test	eax, eax
	jle	SHORT $LN23@FindUnitsF

; 5310 : 					{
; 5311 : 						bSuitableUnit = true;

	mov	BYTE PTR _bSuitableUnit$228182[ebp], 1

; 5312 : 						bHighPriority = true;

	mov	BYTE PTR _bHighPriority$228183[ebp], 1
$LN23@FindUnitsF:

; 5313 : 					}
; 5314 : 					break;

	jmp	$LN32@FindUnitsF
$LN21@FindUnitsF:

; 5315 : 
; 5316 : 				case AI_HOMELAND_MOVE_MOBILE_RESERVE:
; 5317 : 					// Ranged units are excellent in the mobile reserve as are fast movers
; 5318 : 					if(pLoopUnit->isRanged() || pLoopUnit->getUnitInfo().GetUnitAIType(UNITAI_FAST_ATTACK))

	mov	edx, DWORD PTR _pLoopUnit$228178[ebp]
	mov	DWORD PTR $T257691[ebp], edx
	mov	ecx, DWORD PTR $T257691[ebp]
	call	?isRanged@CvUnit@@QBE_NXZ		; CvUnit::isRanged
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN19@FindUnitsF
	mov	ecx, DWORD PTR _pLoopUnit$228178[ebp]
	mov	DWORD PTR $T257695[ebp], ecx
	push	5
	mov	ecx, DWORD PTR $T257695[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN20@FindUnitsF
$LN19@FindUnitsF:

; 5319 : 					{
; 5320 : 						bSuitableUnit = true;

	mov	BYTE PTR _bSuitableUnit$228182[ebp], 1

; 5321 : 						bHighPriority = true;

	mov	BYTE PTR _bHighPriority$228183[ebp], 1
	jmp	SHORT $LN18@FindUnitsF
$LN20@FindUnitsF:

; 5322 : 					}
; 5323 : 					else if(pLoopUnit->IsCanAttack())

	mov	eax, DWORD PTR _pLoopUnit$228178[ebp]
	mov	DWORD PTR $T257699[ebp], eax
	mov	ecx, DWORD PTR $T257699[ebp]
	call	?IsCanAttack@CvUnit@@QBE_NXZ		; CvUnit::IsCanAttack
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN18@FindUnitsF

; 5324 : 					{
; 5325 : 						bSuitableUnit = true;

	mov	BYTE PTR _bSuitableUnit$228182[ebp], 1
$LN18@FindUnitsF:

; 5326 : 					}
; 5327 : 					break;

	jmp	SHORT $LN32@FindUnitsF
$LN16@FindUnitsF:

; 5328 : 
; 5329 : 				case AI_HOMELAND_MOVE_ANCIENT_RUINS:
; 5330 : 					// Fast movers are top priority
; 5331 : 					if(pLoopUnit->getUnitInfo().GetUnitAIType(UNITAI_FAST_ATTACK))

	mov	edx, DWORD PTR _pLoopUnit$228178[ebp]
	mov	DWORD PTR $T257703[ebp], edx
	push	5
	mov	ecx, DWORD PTR $T257703[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@FindUnitsF

; 5332 : 					{
; 5333 : 						bSuitableUnit = true;

	mov	BYTE PTR _bSuitableUnit$228182[ebp], 1

; 5334 : 						bHighPriority = true;

	mov	BYTE PTR _bHighPriority$228183[ebp], 1
	jmp	SHORT $LN32@FindUnitsF
$LN15@FindUnitsF:

; 5335 : 					}
; 5336 : 					else if(pLoopUnit->IsCanAttack())

	mov	ecx, DWORD PTR _pLoopUnit$228178[ebp]
	mov	DWORD PTR $T257707[ebp], ecx
	mov	ecx, DWORD PTR $T257707[ebp]
	call	?IsCanAttack@CvUnit@@QBE_NXZ		; CvUnit::IsCanAttack
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN32@FindUnitsF

; 5337 : 					{
; 5338 : 						bSuitableUnit = true;

	mov	BYTE PTR _bSuitableUnit$228182[ebp], 1
$LN32@FindUnitsF:

; 5339 : 					}
; 5340 : 					break;
; 5341 : #ifdef AUI_HOMELAND_PLOT_WORKER_MOVES_ALSO_PLOTS_WORKER_DEFENSE
; 5342 : 				case AI_HOMELAND_MOVE_UNASSIGNED:
; 5343 : 					// Override for just selecting combat units
; 5344 : 					bSuitableUnit = pLoopUnit->IsCombatUnit();
; 5345 : 					break;
; 5346 : #endif
; 5347 : 				}
; 5348 : 
; 5349 : 				// If unit was suitable, add it to the proper list
; 5350 : 				if(bSuitableUnit)

	movzx	eax, BYTE PTR _bSuitableUnit$228182[ebp]
	test	eax, eax
	je	SHORT $LN36@FindUnitsF

; 5351 : 				{
; 5352 : 					CvHomelandUnit unit;

	lea	ecx, DWORD PTR _unit$228208[ebp]
	call	??0CvHomelandUnit@@QAE@XZ		; CvHomelandUnit::CvHomelandUnit

; 5353 : 					unit.SetID(pLoopUnit->GetID());

	mov	ecx, DWORD PTR _pLoopUnit$228178[ebp]
	mov	DWORD PTR $T257711[ebp], ecx
	mov	edx, DWORD PTR $T257711[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T257720[ebp], eax
	mov	ecx, DWORD PTR $T257720[ebp]
	mov	DWORD PTR _unit$228208[ebp], ecx

; 5354 : 
; 5355 : 					if(bHighPriority)

	movzx	edx, BYTE PTR _bHighPriority$228183[ebp]
	test	edx, edx
	je	SHORT $LN11@FindUnitsF

; 5356 : 					{
; 5357 : 						m_CurrentMoveHighPriorityUnits.push_back(unit);

	lea	eax, DWORD PTR _unit$228208[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1056				; 00000420H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back

; 5358 : 					}
; 5359 : 					else

	jmp	SHORT $LN10@FindUnitsF
$LN11@FindUnitsF:

; 5360 : 					{
; 5361 : 						m_CurrentMoveUnits.push_back(unit);

	lea	ecx, DWORD PTR _unit$228208[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
$LN10@FindUnitsF:

; 5362 : 					}
; 5363 : 					rtnValue = true;

	mov	BYTE PTR _rtnValue$[ebp], 1
$LN36@FindUnitsF:

; 5364 : 				}
; 5365 : 			}
; 5366 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pLoopUnit$228178[ebp], 0
	je	SHORT $LN159@FindUnitsF
	mov	ecx, DWORD PTR _pLoopUnit$228178[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN159@FindUnitsF:
	jmp	$LN57@FindUnitsF
$LN37@FindUnitsF:

; 5367 : 	}
; 5368 : 
; 5369 : 	// Second time through, just make sure all units are still in list of current units to process
; 5370 : 	else

	jmp	$LN9@FindUnitsF
$LN40@FindUnitsF:

; 5371 : 	{
; 5372 : 		FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL > tempList;

	lea	ecx, DWORD PTR _tempList$228213[ebp]
	call	??0?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandUnit,64,1,297,0>::FStaticVector<CvHomelandUnit,64,1,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 5373 : 		FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 5374 : 		std::list<int>::iterator it2;

	mov	DWORD PTR _it2$228220[ebp], 0

; 5375 : 
; 5376 : 		// Normal priority units
; 5377 : 		tempList = m_CurrentMoveUnits;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	lea	ecx, DWORD PTR _tempList$228213[ebp]
	call	??4?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::operator=

; 5378 : 		ClearCurrentMoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveUnits

; 5379 : 		for(it = tempList.begin(); it != tempList.end(); ++it)

	mov	eax, DWORD PTR _tempList$228213[ebp]
	mov	DWORD PTR _it$228215[ebp], eax
	jmp	SHORT $LN184@FindUnitsF
$LN7@FindUnitsF:
	mov	ecx, DWORD PTR _it$228215[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _it$228215[ebp], ecx
$LN184@FindUnitsF:
	mov	edx, DWORD PTR _tempList$228213[ebp+4]
	shl	edx, 4
	add	edx, DWORD PTR _tempList$228213[ebp]
	cmp	DWORD PTR _it$228215[ebp], edx
	je	$LN6@FindUnitsF

; 5380 : 		{
; 5381 : 			it2 = find(m_CurrentTurnUnits.begin(), m_CurrentTurnUnits.end(), (int)it->GetID());

	mov	eax, DWORD PTR _it$228215[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T257778[ebp], ecx
	mov	edx, DWORD PTR $T257778[ebp]
	mov	DWORD PTR $T257499[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T257788[ebp], ecx
	mov	edx, DWORD PTR $T257788[ebp]
	mov	DWORD PTR $T257500[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T257799[ebp], ecx
	mov	edx, DWORD PTR $T257799[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T257808[ebp], eax
	mov	ecx, DWORD PTR $T257808[ebp]
	mov	DWORD PTR $T257501[ebp], ecx
	mov	edx, DWORD PTR $T257501[ebp]
	mov	DWORD PTR $T257907[ebp], edx
	mov	eax, DWORD PTR $T257500[ebp]
	mov	DWORD PTR $T257881[ebp], eax
	mov	ecx, DWORD PTR $T257907[ebp]
	mov	DWORD PTR $T257880[ebp], ecx
	jmp	SHORT $LN216@FindUnitsF
$LN214@FindUnitsF:
	mov	edx, DWORD PTR $T257880[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T257880[ebp], eax
$LN216@FindUnitsF:
	mov	ecx, DWORD PTR $T257880[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T257881[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN205@FindUnitsF
	mov	edx, DWORD PTR $T257880[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR $T257499[ebp]
	jne	SHORT $LN204@FindUnitsF
	jmp	SHORT $LN205@FindUnitsF
$LN204@FindUnitsF:
	jmp	SHORT $LN214@FindUnitsF
$LN205@FindUnitsF:
	mov	ecx, DWORD PTR $T257880[ebp]
	mov	DWORD PTR $T257884[ebp], ecx
	mov	edx, DWORD PTR $T257884[ebp]
	mov	DWORD PTR $T257907[ebp], edx
	mov	eax, DWORD PTR $T257907[ebp]
	mov	DWORD PTR $T257502[ebp], eax
	mov	ecx, DWORD PTR $T257502[ebp]
	mov	DWORD PTR _it2$228220[ebp], ecx

; 5382 : 			if(it2 != m_CurrentTurnUnits.end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T257917[ebp], eax
	mov	ecx, DWORD PTR $T257917[ebp]
	mov	DWORD PTR $T257503[ebp], ecx
	mov	edx, DWORD PTR _it2$228220[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T257503[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN5@FindUnitsF

; 5383 : 			{
; 5384 : 				m_CurrentMoveUnits.push_back(*it);

	mov	eax, DWORD PTR _it$228215[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back

; 5385 : 				rtnValue = true;

	mov	BYTE PTR _rtnValue$[ebp], 1
$LN5@FindUnitsF:

; 5386 : 			}
; 5387 : 		}

	jmp	$LN7@FindUnitsF
$LN6@FindUnitsF:

; 5388 : 
; 5389 : 		// High priority units
; 5390 : 		tempList = m_CurrentMoveHighPriorityUnits;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1056				; 00000420H
	push	ecx
	lea	ecx, DWORD PTR _tempList$228213[ebp]
	call	??4?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::operator=

; 5391 : 		ClearCurrentMoveHighPriorityUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentMoveHighPriorityUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveHighPriorityUnits

; 5392 : 		for(it = tempList.begin(); it != tempList.end(); ++it)

	mov	edx, DWORD PTR _tempList$228213[ebp]
	mov	DWORD PTR _it$228215[ebp], edx
	jmp	SHORT $LN253@FindUnitsF
$LN3@FindUnitsF:
	mov	eax, DWORD PTR _it$228215[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _it$228215[ebp], eax
$LN253@FindUnitsF:
	mov	ecx, DWORD PTR _tempList$228213[ebp+4]
	shl	ecx, 4
	add	ecx, DWORD PTR _tempList$228213[ebp]
	cmp	DWORD PTR _it$228215[ebp], ecx
	je	$LN2@FindUnitsF

; 5393 : 		{
; 5394 : 			it2 = find(m_CurrentTurnUnits.begin(), m_CurrentTurnUnits.end(), (int)it->GetID());

	mov	edx, DWORD PTR _it$228215[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T257956[ebp], eax
	mov	ecx, DWORD PTR $T257956[ebp]
	mov	DWORD PTR $T257504[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T257966[ebp], eax
	mov	ecx, DWORD PTR $T257966[ebp]
	mov	DWORD PTR $T257505[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T257977[ebp], eax
	mov	ecx, DWORD PTR $T257977[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T257986[ebp], edx
	mov	eax, DWORD PTR $T257986[ebp]
	mov	DWORD PTR $T257506[ebp], eax
	mov	ecx, DWORD PTR $T257506[ebp]
	mov	DWORD PTR $T258085[ebp], ecx
	mov	edx, DWORD PTR $T257505[ebp]
	mov	DWORD PTR $T258059[ebp], edx
	mov	eax, DWORD PTR $T258085[ebp]
	mov	DWORD PTR $T258058[ebp], eax
	jmp	SHORT $LN285@FindUnitsF
$LN283@FindUnitsF:
	mov	ecx, DWORD PTR $T258058[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T258058[ebp], edx
$LN285@FindUnitsF:
	mov	eax, DWORD PTR $T258058[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T258059[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN274@FindUnitsF
	mov	ecx, DWORD PTR $T258058[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR $T257504[ebp]
	jne	SHORT $LN273@FindUnitsF
	jmp	SHORT $LN274@FindUnitsF
$LN273@FindUnitsF:
	jmp	SHORT $LN283@FindUnitsF
$LN274@FindUnitsF:
	mov	eax, DWORD PTR $T258058[ebp]
	mov	DWORD PTR $T258072[ebp], eax
	mov	ecx, DWORD PTR $T258072[ebp]
	mov	DWORD PTR $T258085[ebp], ecx
	mov	edx, DWORD PTR $T258085[ebp]
	mov	DWORD PTR $T257507[ebp], edx
	mov	eax, DWORD PTR $T257507[ebp]
	mov	DWORD PTR _it2$228220[ebp], eax

; 5395 : 			if(it2 != m_CurrentTurnUnits.end())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T258095[ebp], edx
	mov	eax, DWORD PTR $T258095[ebp]
	mov	DWORD PTR $T257508[ebp], eax
	mov	ecx, DWORD PTR _it2$228220[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T257508[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@FindUnitsF

; 5396 : 			{
; 5397 : 				m_CurrentMoveHighPriorityUnits.push_back(*it);

	mov	edx, DWORD PTR _it$228215[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1056				; 00000420H
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back

; 5398 : 				rtnValue = true;

	mov	BYTE PTR _rtnValue$[ebp], 1
$LN1@FindUnitsF:

; 5399 : 			}
; 5400 : 		}

	jmp	$LN3@FindUnitsF
$LN2@FindUnitsF:

; 5401 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tempList$228213[ebp]
	call	??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandUnit,64,1,297,0>::~FStaticVector<CvHomelandUnit,64,1,297,0>
$LN9@FindUnitsF:

; 5402 : 
; 5403 : 	return rtnValue;

	mov	al, BYTE PTR _rtnValue$[ebp]

; 5404 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
$LN329@FindUnitsF:
	DD	$LN31@FindUnitsF
	DD	$LN21@FindUnitsF
	DD	$LN26@FindUnitsF
	DD	$LN16@FindUnitsF
	DD	$LN32@FindUnitsF
$LN327@FindUnitsF:
	DB	0
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z$0:
	lea	ecx, DWORD PTR _pLoopUnit$228178[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z$1:
	lea	ecx, DWORD PTR _tempList$228213[ebp]
	jmp	??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandUnit,64,1,297,0>::~FStaticVector<CvHomelandUnit,64,1,297,0>
__ehhandler$?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1372]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z ENDP ; CvHomelandAI::FindUnitsForThisMove
PUBLIC	??_C@_0BI@LCNKPHMD@Patrol?5Target?5NOT?5FOUND?$AA@ ; `string'
PUBLIC	??_C@_0CA@LMLJDNOG@Patrol?5Target?5FOUND?0?5?$CFi?0?5?$CFi?0?5?$CFi?$AA@ ; `string'
PUBLIC	??_C@_0BP@IFEDIMCM@Adjacent?5Patrol?5Plot?5not?5found?$AA@ ; `string'
PUBLIC	??_C@_0CJ@NEFDIPJH@Adjacent?5Patrol?5Plot?5not?5valid?0?5@ ; `string'
PUBLIC	??_C@_0DF@HCPLHGGA@Adjacent?5Patrol?5Plot?5?$CBisVisibleE@ ; `string'
PUBLIC	??_C@_0CP@ENKAEHJE@Adjacent?5Patrol?5Plot?5?$CBGeneratePa@ ; `string'
PUBLIC	?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z ; CvHomelandAI::LogPatrolMessage
PUBLIC	??_C@_0CH@EHAODBIC@Adjacent?5Patrol?5Plot?5Score?0?5?$CFi?0?5@ ; `string'
PUBLIC	??_C@_09EBJAJPPL@AI?5Patrol?$AA@		; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
;	COMDAT ??_C@_0BI@LCNKPHMD@Patrol?5Target?5NOT?5FOUND?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BI@LCNKPHMD@Patrol?5Target?5NOT?5FOUND?$AA@ DB 'Patrol Target NOT '
	DB	'FOUND', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LMLJDNOG@Patrol?5Target?5FOUND?0?5?$CFi?0?5?$CFi?0?5?$CFi?$AA@
CONST	SEGMENT
??_C@_0CA@LMLJDNOG@Patrol?5Target?5FOUND?0?5?$CFi?0?5?$CFi?0?5?$CFi?$AA@ DB 'P'
	DB	'atrol Target FOUND, %i, %i, %i', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IFEDIMCM@Adjacent?5Patrol?5Plot?5not?5found?$AA@
CONST	SEGMENT
??_C@_0BP@IFEDIMCM@Adjacent?5Patrol?5Plot?5not?5found?$AA@ DB 'Adjacent P'
	DB	'atrol Plot not found', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NEFDIPJH@Adjacent?5Patrol?5Plot?5not?5valid?0?5@
CONST	SEGMENT
??_C@_0CJ@NEFDIPJH@Adjacent?5Patrol?5Plot?5not?5valid?0?5@ DB 'Adjacent P'
	DB	'atrol Plot not valid, , %i, %i', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HCPLHGGA@Adjacent?5Patrol?5Plot?5?$CBisVisibleE@
CONST	SEGMENT
??_C@_0DF@HCPLHGGA@Adjacent?5Patrol?5Plot?5?$CBisVisibleE@ DB 'Adjacent P'
	DB	'atrol Plot !isVisibleEnemyUnit(), , %i, %i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@ENKAEHJE@Adjacent?5Patrol?5Plot?5?$CBGeneratePa@
CONST	SEGMENT
??_C@_0CP@ENKAEHJE@Adjacent?5Patrol?5Plot?5?$CBGeneratePa@ DB 'Adjacent P'
	DB	'atrol Plot !GeneratePath(), , %i, %i', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EHAODBIC@Adjacent?5Patrol?5Plot?5Score?0?5?$CFi?0?5@
CONST	SEGMENT
??_C@_0CH@EHAODBIC@Adjacent?5Patrol?5Plot?5Score?0?5?$CFi?0?5@ DB 'Adjace'
	DB	'nt Patrol Plot Score, %i, %i, %i', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EBJAJPPL@AI?5Patrol?$AA@
CONST	SEGMENT
??_C@_09EBJAJPPL@AI?5Patrol?$AA@ DB 'AI Patrol', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$6
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -356						; size = 4
$T258426 = -352						; size = 4
$T258403 = -348						; size = 4
$T258388 = -344						; size = 4
$T258373 = -340						; size = 4
$T258358 = -336						; size = 4
$T258350 = -332						; size = 4
$T258341 = -328						; size = 4
$T258337 = -324						; size = 4
$T258179 = -240						; size = 4
$T258170 = -236						; size = 4
_strLogString$228286 = -232				; size = 28
_strLogString$228282 = -204				; size = 28
_strLogString$228278 = -176				; size = 28
_strLogString$228274 = -148				; size = 28
_strLogString$228270 = -120				; size = 28
_strLogString$228266 = -92				; size = 28
_strLogString$228261 = -64				; size = 28
__$ArrayPad$ = -36					; size = 4
_pBestPlot$ = -32					; size = 4
_iBestValue$ = -28					; size = 4
_iI$ = -24						; size = 4
_iValue$ = -20						; size = 4
_pAdjacentPlot$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z PROC ; CvHomelandAI::FindPatrolTarget, COMDAT
; _this$ = ecx

; 5408 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 344				; 00000158H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5409 : 	CvPlot* pAdjacentPlot;
; 5410 : 	CvPlot* pBestPlot;
; 5411 : 	int iValue;
; 5412 : 	int iBestValue;
; 5413 : 	int iI;
; 5414 : 
; 5415 : 	iBestValue = 0;

	mov	DWORD PTR _iBestValue$[ebp], 0

; 5416 : 	pBestPlot = NULL;

	mov	DWORD PTR _pBestPlot$[ebp], 0

; 5417 : 
; 5418 : #ifdef AUI_HOMELAND_FIND_PATROL_TARGET_DESIRES_BORDER_AND_ROUTE_AND_CIVILIAN_GUARD
; 5419 : 	int iValueBonus;
; 5420 : 	if (pUnit->IsCombatUnit())
; 5421 : 	{
; 5422 : 		pBestPlot = pUnit->plot();
; 5423 : 		const IDInfo* pUnitNode = pBestPlot->headUnitNode();
; 5424 : 		const UnitHandle pLoopUnit;
; 5425 : 
; 5426 : 		while (pUnitNode != NULL)
; 5427 : 		{
; 5428 : 			pLoopUnit = GetPlayerUnit(*pUnitNode);
; 5429 : 			if (pLoopUnit && !pLoopUnit->IsCombatUnit())
; 5430 : 			{
; 5431 : 				if (!pLoopUnit->canMove())
; 5432 : 					return pBestPlot;
; 5433 : 				else
; 5434 : 				{
; 5435 : 					iBestValue = 20001;
; 5436 : 					break;
; 5437 : 				}
; 5438 : 			}
; 5439 : 			pUnitNode = pBestPlot->nextUnitNode(pUnitNode);
; 5440 : 		}
; 5441 : 	}
; 5442 : #endif
; 5443 : 
; 5444 : #if defined(AUI_HOMELAND_TWEAKED_FIND_PATROL_TARGET_CIVILIAN_NO_DANGER)
; 5445 : 	int iMyDanger = m_pPlayer->GetPlotDanger(*(pUnit->plot()));
; 5446 : #endif
; 5447 : 
; 5448 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN22@FindPatrol
$LN21@FindPatrol:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN22@FindPatrol:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	$LN20@FindPatrol

; 5449 : 	{
; 5450 : 		pAdjacentPlot = plotDirection(pUnit->getX(), pUnit->getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T258170[ebp], edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T258179[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T258170[ebp]
	push	eax
	mov	ecx, DWORD PTR $T258179[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 5451 : 
; 5452 : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	$LN19@FindPatrol

; 5453 : 		{
; 5454 : 			if(pUnit->PlotValid(pAdjacentPlot))

	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?PlotValid@CvUnit@@QBE_NPAVCvPlot@@@Z	; CvUnit::PlotValid
	movzx	eax, al
	test	eax, eax
	je	$LN18@FindPatrol

; 5455 : 			{
; 5456 : 				if(!(pAdjacentPlot->isVisibleEnemyUnit(pUnit)))

	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyUnit
	movzx	edx, al
	test	edx, edx
	jne	$LN17@FindPatrol

; 5457 : 				{
; 5458 : 					if(pUnit->GeneratePath(pAdjacentPlot, 0, true))

	push	0
	push	1
	push	0
	mov	eax, DWORD PTR _pAdjacentPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath
	movzx	ecx, al
	test	ecx, ecx
	je	$LN16@FindPatrol

; 5459 : 					{
; 5460 : #ifdef AUI_HOMELAND_FIND_PATROL_TARGET_DESIRES_BORDER_AND_ROUTE_AND_CIVILIAN_GUARD
; 5461 : 						iValueBonus = 0;
; 5462 : #endif
; 5463 : 						iValue = (1 + GC.getGame().getJonRandNum(10000, "AI Patrol"));

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T258337[ebp], edx
	push	OFFSET ??_C@_09EBJAJPPL@AI?5Patrol?$AA@
	push	10000					; 00002710H
	mov	ecx, DWORD PTR $T258337[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	add	eax, 1
	mov	DWORD PTR _iValue$[ebp], eax

; 5464 : 
; 5465 : 						// Prefer wandering in our own territory
; 5466 : 						if(pAdjacentPlot->getOwner() == pUnit->getOwner())

	mov	eax, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T258341[ebp], ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T258350[ebp], eax
	mov	ecx, DWORD PTR $T258341[ebp]
	cmp	ecx, DWORD PTR $T258350[ebp]
	jne	SHORT $LN15@FindPatrol

; 5467 : 						{
; 5468 : #ifdef AUI_HOMELAND_FIND_PATROL_TARGET_DESIRES_BORDER_AND_ROUTE_AND_CIVILIAN_GUARD
; 5469 : 							iValueBonus = 5000;
; 5470 : #ifdef AUI_HOMELAND_FIND_PATROL_MOVES_CIVILIANS_PATROL_TO_SAFETY
; 5471 : 							if (pAdjacentPlot->isAdjacentPlayer(NO_PLAYER) || pAdjacentPlot->IsAdjacentOwnedByOtherTeam(m_pPlayer->getTeam()) || pAdjacentPlot->isValidRoute(pUnit))
; 5472 : #else
; 5473 : 							if ((pUnit->IsCombatUnit() && (pAdjacentPlot->isAdjacentPlayer(NO_PLAYER) || pAdjacentPlot->IsAdjacentOwnedByOtherTeam(m_pPlayer->getTeam()))) ||
; 5474 : 								(pAdjacentPlot->isValidRoute(pUnit) && (!pAdjacentPlot->isCity() || !pUnit->IsCombatUnit())))
; 5475 : #endif
; 5476 : 							{
; 5477 : 								iValueBonus += 5000;
; 5478 : 							}
; 5479 : #else
; 5480 : 							iValue += 10000;

	mov	edx, DWORD PTR _iValue$[ebp]
	add	edx, 10000				; 00002710H
	mov	DWORD PTR _iValue$[ebp], edx
$LN15@FindPatrol:

; 5481 : #endif
; 5482 : 						}
; 5483 : 
; 5484 : #if defined(AUI_HOMELAND_TWEAKED_FIND_PATROL_TARGET_CIVILIAN_NO_DANGER)
; 5485 : 						if (!pUnit->IsCombatUnit())
; 5486 : 						{
; 5487 : 							int iDanger = m_pPlayer->GetPlotDanger(*pAdjacentPlot);
; 5488 : 							if (iDanger > 0)
; 5489 : 							{
; 5490 : 								if (iMyDanger > 0)
; 5491 : 								{
; 5492 : 									iValue -= iDanger;
; 5493 : #ifdef AUI_HOMELAND_FIND_PATROL_TARGET_DESIRES_BORDER_AND_ROUTE_AND_CIVILIAN_GUARD
; 5494 : 									iValueBonus = 0;
; 5495 : #else
; 5496 : 									// Almost nullifies the value bonus from being in our own territory
; 5497 : 									if (pAdjacentPlot->getOwner() == pUnit->getOwner())
; 5498 : 									{
; 5499 : 										iValue -= 9999;
; 5500 : 									}
; 5501 : #endif
; 5502 : 								}
; 5503 : 								else
; 5504 : 								{
; 5505 : 									iValue = -1;
; 5506 : 								}
; 5507 : 							}
; 5508 : 						}
; 5509 : 						else
; 5510 : 						{
; 5511 : 							const IDInfo* pUnitNode = pAdjacentPlot->headUnitNode();
; 5512 : 							const UnitHandle pLoopUnit;
; 5513 : 
; 5514 : 							while (pUnitNode != NULL)
; 5515 : 							{
; 5516 : 								pLoopUnit = GetPlayerUnit(*pUnitNode);
; 5517 : 								if (pLoopUnit && !pLoopUnit->IsCombatUnit())
; 5518 : 								{
; 5519 : 									if (!pLoopUnit->canMove())
; 5520 : 										iValueBonus += 100000;
; 5521 : 									else
; 5522 : 										iValueBonus += 10000;
; 5523 : 									break;
; 5524 : 								}
; 5525 : 								pUnitNode = pAdjacentPlot->nextUnitNode(pUnitNode);
; 5526 : 							}
; 5527 : 						}
; 5528 : #endif
; 5529 : #ifdef AUI_HOMELAND_FIND_PATROL_TARGET_DESIRES_BORDER_AND_ROUTE_AND_CIVILIAN_GUARD
; 5530 : 						iValue += iValueBonus;
; 5531 : #endif
; 5532 : 
; 5533 : 						if(GC.getLogging() && GC.getAILogging()){

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@FindPatrol
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@FindPatrol

; 5534 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228261[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5535 : 							strLogString.Format("Adjacent Patrol Plot Score, %i, %i, %i", iValue, pAdjacentPlot->getX(), pAdjacentPlot->getY());

	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T258358[ebp], eax
	mov	ecx, DWORD PTR $T258358[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _iValue$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CH@EHAODBIC@Adjacent?5Patrol?5Plot?5Score?0?5?$CFi?0?5@
	lea	edx, DWORD PTR _strLogString$228261[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 5536 : 							LogPatrolMessage(strLogString, pUnit);

	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strLogString$228261[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z ; CvHomelandAI::LogPatrolMessage

; 5537 : 						}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$228261[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN14@FindPatrol:

; 5538 : 
; 5539 : 						if(iValue > iBestValue)

	mov	edx, DWORD PTR _iValue$[ebp]
	cmp	edx, DWORD PTR _iBestValue$[ebp]
	jle	SHORT $LN13@FindPatrol

; 5540 : 						{
; 5541 : 							iBestValue = iValue;

	mov	eax, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iBestValue$[ebp], eax

; 5542 : 							pBestPlot = pAdjacentPlot;

	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	mov	DWORD PTR _pBestPlot$[ebp], ecx
$LN13@FindPatrol:

; 5543 : 						}
; 5544 : 					}
; 5545 : 					else

	jmp	$LN12@FindPatrol
$LN16@FindPatrol:

; 5546 : 					{
; 5547 : 						if(GC.getLogging() && GC.getAILogging()){

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN12@FindPatrol
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@FindPatrol

; 5548 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228266[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 5549 : 							strLogString.Format("Adjacent Patrol Plot !GeneratePath(), , %i, %i", pAdjacentPlot->getX(), pAdjacentPlot->getY());

	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T258373[ebp], edx
	mov	eax, DWORD PTR $T258373[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0CP@ENKAEHJE@Adjacent?5Patrol?5Plot?5?$CBGeneratePa@
	lea	eax, DWORD PTR _strLogString$228266[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5550 : 							LogPatrolMessage(strLogString, pUnit);

	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strLogString$228266[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z ; CvHomelandAI::LogPatrolMessage

; 5551 : 						}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$228266[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN12@FindPatrol:

; 5552 : 					}
; 5553 : 				}
; 5554 : 				else

	jmp	$LN10@FindPatrol
$LN17@FindPatrol:

; 5555 : 				{
; 5556 : 					if(GC.getLogging() && GC.getAILogging()){

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@FindPatrol
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@FindPatrol

; 5557 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228270[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 5558 : 						strLogString.Format("Adjacent Patrol Plot !isVisibleEnemyUnit(), , %i, %i", pAdjacentPlot->getX(), pAdjacentPlot->getY());

	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T258388[ebp], eax
	mov	ecx, DWORD PTR $T258388[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_0DF@HCPLHGGA@Adjacent?5Patrol?5Plot?5?$CBisVisibleE@
	lea	ecx, DWORD PTR _strLogString$228270[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5559 : 						LogPatrolMessage(strLogString, pUnit);

	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	lea	eax, DWORD PTR _strLogString$228270[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z ; CvHomelandAI::LogPatrolMessage

; 5560 : 					}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$228270[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN10@FindPatrol:

; 5561 : 				}
; 5562 : 			}
; 5563 : 			else

	jmp	$LN8@FindPatrol
$LN18@FindPatrol:

; 5564 : 			{
; 5565 : 				if(GC.getLogging() && GC.getAILogging()){

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@FindPatrol
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@FindPatrol

; 5566 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228274[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 5567 : 					strLogString.Format("Adjacent Patrol Plot not valid, , %i, %i", pAdjacentPlot->getX(), pAdjacentPlot->getY());

	mov	eax, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T258403[ebp], ecx
	mov	edx, DWORD PTR $T258403[ebp]
	push	edx
	mov	eax, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0CJ@NEFDIPJH@Adjacent?5Patrol?5Plot?5not?5valid?0?5@
	lea	edx, DWORD PTR _strLogString$228274[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5568 : 					LogPatrolMessage(strLogString, pUnit);

	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strLogString$228274[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z ; CvHomelandAI::LogPatrolMessage

; 5569 : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$228274[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN8@FindPatrol:

; 5570 : 			}
; 5571 : 		}
; 5572 : 		else

	jmp	SHORT $LN6@FindPatrol
$LN19@FindPatrol:

; 5573 : 		{
; 5574 : 			if(GC.getLogging() && GC.getAILogging()){

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@FindPatrol
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@FindPatrol

; 5575 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228278[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 5576 : 				strLogString.Format("Adjacent Patrol Plot not found");

	push	OFFSET ??_C@_0BP@IFEDIMCM@Adjacent?5Patrol?5Plot?5not?5found?$AA@
	lea	ecx, DWORD PTR _strLogString$228278[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 5577 : 				LogPatrolMessage(strLogString, pUnit);

	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	lea	eax, DWORD PTR _strLogString$228278[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z ; CvHomelandAI::LogPatrolMessage

; 5578 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$228278[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@FindPatrol:

; 5579 : 		}
; 5580 : 	}

	jmp	$LN21@FindPatrol
$LN20@FindPatrol:

; 5581 : 
; 5582 : 	if(pBestPlot != NULL)

	cmp	DWORD PTR _pBestPlot$[ebp], 0
	je	$LN4@FindPatrol

; 5583 : 	{
; 5584 : 		if(GC.getLogging() && GC.getAILogging()){

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@FindPatrol
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@FindPatrol

; 5585 : 			CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228282[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 5

; 5586 : 			strLogString.Format("Patrol Target FOUND, %i, %i, %i", iBestValue, pBestPlot->getX(), pBestPlot->getY());

	mov	eax, DWORD PTR _pBestPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T258426[ebp], ecx
	mov	edx, DWORD PTR $T258426[ebp]
	push	edx
	mov	eax, DWORD PTR _pBestPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _iBestValue$[ebp]
	push	edx
	push	OFFSET ??_C@_0CA@LMLJDNOG@Patrol?5Target?5FOUND?0?5?$CFi?0?5?$CFi?0?5?$CFi?$AA@
	lea	eax, DWORD PTR _strLogString$228282[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 5587 : 			LogPatrolMessage(strLogString, pUnit);

	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strLogString$228282[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z ; CvHomelandAI::LogPatrolMessage

; 5588 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$228282[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@FindPatrol:

; 5589 : 
; 5590 : 		CvAssert(!pUnit->atPlot(*pBestPlot));
; 5591 : 		return pBestPlot;

	mov	eax, DWORD PTR _pBestPlot$[ebp]
	jmp	SHORT $LN23@FindPatrol

; 5592 : 	}
; 5593 : 	else

	jmp	SHORT $LN2@FindPatrol
$LN4@FindPatrol:

; 5594 : 	{
; 5595 : 		if(GC.getLogging() && GC.getAILogging()){

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@FindPatrol
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@FindPatrol

; 5596 : 			CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228286[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 6

; 5597 : 			strLogString.Format("Patrol Target NOT FOUND");

	push	OFFSET ??_C@_0BI@LCNKPHMD@Patrol?5Target?5NOT?5FOUND?$AA@
	lea	edx, DWORD PTR _strLogString$228286[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 5598 : 			LogPatrolMessage(strLogString, pUnit);

	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strLogString$228286[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z ; CvHomelandAI::LogPatrolMessage

; 5599 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$228286[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@FindPatrol:

; 5600 : 	}
; 5601 : 
; 5602 : 	return NULL;

	xor	eax, eax
$LN23@FindPatrol:

; 5603 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$0:
	lea	ecx, DWORD PTR _strLogString$228261[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$1:
	lea	ecx, DWORD PTR _strLogString$228266[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$2:
	lea	ecx, DWORD PTR _strLogString$228270[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$3:
	lea	ecx, DWORD PTR _strLogString$228274[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$4:
	lea	ecx, DWORD PTR _strLogString$228278[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$5:
	lea	ecx, DWORD PTR _strLogString$228282[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$6:
	lea	ecx, DWORD PTR _strLogString$228286[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-348]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z ENDP ; CvHomelandAI::FindPatrolTarget
PUBLIC	?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z ; CvHomelandAI::GetClosestUnitByTurnsToTarget
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z$0
__ehfuncinfo$?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z
_TEXT	SEGMENT
tv176 = -88						; size = 4
tv175 = -84						; size = 4
_this$ = -80						; size = 4
$T258523 = -76						; size = 4
$T258501 = -72						; size = 4
$T258491 = -68						; size = 4
$T258472 = -64						; size = 4
$T258462 = -60						; size = 4
$T258450 = -56						; size = 4
_iDistance$228307 = -52					; size = 4
_iMoves$228309 = -48					; size = 4
_pLoopUnit$228305 = -44					; size = 8
_iMinTurns$ = -36					; size = 4
_MAX_FAILED_PATHS$ = -32				; size = 4
_pBestUnit$ = -28					; size = 4
_iFailedPaths$ = -24					; size = 4
_EARLY_OUT_FAILED_PATH_DISTANCE$ = -20			; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_kMoveUnits$ = 8					; size = 4
_pTarget$ = 12						; size = 4
_iMaxTurns$ = 16					; size = 4
_ppClosestUnit$ = 20					; size = 4
_piClosestTurns$ = 24					; size = 4
?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z PROC ; CvHomelandAI::GetClosestUnitByTurnsToTarget, COMDAT
; _this$ = ecx

; 5608 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5609 : 	CvUnit* pBestUnit = NULL;

	mov	DWORD PTR _pBestUnit$[ebp], 0

; 5610 : 	int iMinTurns = MAX_INT;

	mov	DWORD PTR _iMinTurns$[ebp], 2147483647	; 7fffffffH

; 5611 : 	MoveUnitsArray::iterator it;
; 5612 : 
; 5613 : 	int iFailedPaths = 0;

	mov	DWORD PTR _iFailedPaths$[ebp], 0

; 5614 : 	// If we see this many failed pathing attempts, we assume no unit can get to the target
; 5615 : 	const int MAX_FAILED_PATHS = 2;

	mov	DWORD PTR _MAX_FAILED_PATHS$[ebp], 2

; 5616 : 	// If the last failed pathing attempt was this far (raw distance) from the target, we assume no one can reach the target, even if we have not reached MAX_FAILED_PATHS
; 5617 : 	const int EARLY_OUT_FAILED_PATH_DISTANCE = 12;

	mov	DWORD PTR _EARLY_OUT_FAILED_PATH_DISTANCE$[ebp], 12 ; 0000000cH

; 5618 : 
; 5619 : 	// Now go through and figure out the actual number of turns, and as a result, even if it can get there at all.
; 5620 : 	// We will try and do as few as possible by stopping if we find a unit that can make it in one turn.
; 5621 : 	for(it = kMoveUnits.begin(); it != kMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _kMoveUnits$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN20@GetClosest
$LN12@GetClosest:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], edx
$LN20@GetClosest:
	mov	eax, DWORD PTR _kMoveUnits$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	mov	edx, DWORD PTR _kMoveUnits$[ebp]
	add	ecx, DWORD PTR [edx]
	cmp	DWORD PTR _it$[ebp], ecx
	je	$LN11@GetClosest

; 5622 : 	{
; 5623 : 		UnitHandle pLoopUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T258462[ebp], ecx
	mov	edx, DWORD PTR $T258462[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T258472[ebp], eax
	mov	ecx, DWORD PTR $T258472[ebp]
	mov	DWORD PTR _pLoopUnit$228305[ebp], ecx
	mov	BYTE PTR _pLoopUnit$228305[ebp+4], 0
	cmp	DWORD PTR _pLoopUnit$228305[ebp], 0
	je	SHORT $LN25@GetClosest
	mov	ecx, DWORD PTR _pLoopUnit$228305[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN25@GetClosest:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5624 : 		if (pLoopUnit)

	xor	edx, edx
	cmp	DWORD PTR _pLoopUnit$228305[ebp], 0
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN10@GetClosest

; 5625 : 		{
; 5626 : 			int iDistance = it->GetMovesToTarget();	// Raw distance

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _iDistance$228307[ebp], edx

; 5627 : 			if (iDistance == MAX_INT)

	cmp	DWORD PTR _iDistance$228307[ebp], 2147483647 ; 7fffffffH
	jne	SHORT $LN9@GetClosest

; 5628 : 				continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pLoopUnit$228305[ebp], 0
	je	SHORT $LN34@GetClosest
	mov	ecx, DWORD PTR _pLoopUnit$228305[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN34@GetClosest:
	jmp	$LN12@GetClosest
$LN9@GetClosest:

; 5629 : 			int iMoves = TurnsToReachTarget(pLoopUnit.pointer(), pTarget);

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _pTarget$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$228305[ebp]
	mov	DWORD PTR $T258491[ebp], ecx
	sub	esp, 8
	mov	edx, esp
	mov	DWORD PTR $T258450[ebp], esp
	mov	DWORD PTR $T258501[ebp], edx
	mov	eax, DWORD PTR $T258501[ebp]
	mov	ecx, DWORD PTR $T258491[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T258501[ebp]
	mov	BYTE PTR [edx+4], 0
	mov	eax, DWORD PTR $T258501[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN41@GetClosest
	mov	ecx, DWORD PTR $T258501[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@GetClosest:
	mov	edx, DWORD PTR $T258501[ebp]
	mov	DWORD PTR tv175[ebp], edx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv176[ebp], eax
	mov	eax, DWORD PTR tv176[ebp]
	mov	DWORD PTR _iMoves$228309[ebp], eax

; 5630 : 			it->SetMovesToTarget(iMoves);

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR _iMoves$228309[ebp]
	mov	DWORD PTR [ecx+8], edx

; 5631 : 			// Did we make it at all?
; 5632 : 			if (iMoves != MAX_INT)

	cmp	DWORD PTR _iMoves$228309[ebp], 2147483647 ; 7fffffffH
	je	$LN8@GetClosest

; 5633 : 			{
; 5634 : 				// Reasonably close?
; 5635 : 				if (iDistance == 0 || (iMoves <= iDistance && iMoves <= iMaxTurns && iMoves < iMinTurns))

	cmp	DWORD PTR _iDistance$228307[ebp], 0
	je	SHORT $LN47@GetClosest
	mov	eax, DWORD PTR _iMoves$228309[ebp]
	cmp	eax, DWORD PTR _iDistance$228307[ebp]
	jg	SHORT $LN7@GetClosest
	mov	ecx, DWORD PTR _iMoves$228309[ebp]
	cmp	ecx, DWORD PTR _iMaxTurns$[ebp]
	jg	SHORT $LN7@GetClosest
	mov	edx, DWORD PTR _iMoves$228309[ebp]
	cmp	edx, DWORD PTR _iMinTurns$[ebp]
	jge	SHORT $LN7@GetClosest

; 5636 : 				{
; 5637 : 					pBestUnit = pLoopUnit.pointer();

$LN47@GetClosest:
	mov	eax, DWORD PTR _pLoopUnit$228305[ebp]
	mov	DWORD PTR _pBestUnit$[ebp], eax

; 5638 : 					iMinTurns = iMoves;

	mov	ecx, DWORD PTR _iMoves$228309[ebp]
	mov	DWORD PTR _iMinTurns$[ebp], ecx

; 5639 : 					break;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pLoopUnit$228305[ebp], 0
	je	SHORT $LN50@GetClosest
	mov	ecx, DWORD PTR _pLoopUnit$228305[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN50@GetClosest:
	jmp	$LN11@GetClosest
$LN7@GetClosest:

; 5640 : 				}
; 5641 : 
; 5642 : 				if (iMoves < iMinTurns)

	mov	edx, DWORD PTR _iMoves$228309[ebp]
	cmp	edx, DWORD PTR _iMinTurns$[ebp]
	jge	SHORT $LN5@GetClosest

; 5643 : 				{
; 5644 : 					pBestUnit = pLoopUnit.pointer();

	mov	eax, DWORD PTR _pLoopUnit$228305[ebp]
	mov	DWORD PTR _pBestUnit$[ebp], eax

; 5645 : 					iMinTurns = iMoves;

	mov	ecx, DWORD PTR _iMoves$228309[ebp]
	mov	DWORD PTR _iMinTurns$[ebp], ecx
$LN5@GetClosest:

; 5646 : 				}
; 5647 : 
; 5648 : 				// Were we far away?  If so, this is probably the best we are going to do
; 5649 : 				if (iDistance >= GC.getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2572
	mov	DWORD PTR $T258523[ebp], edx
	mov	eax, DWORD PTR _iDistance$228307[ebp]
	cmp	eax, DWORD PTR $T258523[ebp]
	jl	SHORT $LN4@GetClosest

; 5650 : 					break;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pLoopUnit$228305[ebp], 0
	je	SHORT $LN59@GetClosest
	mov	ecx, DWORD PTR _pLoopUnit$228305[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN59@GetClosest:
	jmp	SHORT $LN11@GetClosest
$LN4@GetClosest:

; 5651 : 			}
; 5652 : 			else

	jmp	SHORT $LN10@GetClosest
$LN8@GetClosest:

; 5653 : 			{
; 5654 : 				++iFailedPaths;

	mov	ecx, DWORD PTR _iFailedPaths$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iFailedPaths$[ebp], ecx

; 5655 : 				if (iFailedPaths >= MAX_FAILED_PATHS)

	cmp	DWORD PTR _iFailedPaths$[ebp], 2
	jl	SHORT $LN2@GetClosest

; 5656 : 					break;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pLoopUnit$228305[ebp], 0
	je	SHORT $LN64@GetClosest
	mov	ecx, DWORD PTR _pLoopUnit$228305[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN64@GetClosest:
	jmp	SHORT $LN11@GetClosest
$LN2@GetClosest:

; 5657 : 				if (iDistance >= EARLY_OUT_FAILED_PATH_DISTANCE)

	cmp	DWORD PTR _iDistance$228307[ebp], 12	; 0000000cH
	jl	SHORT $LN10@GetClosest

; 5658 : 					break;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pLoopUnit$228305[ebp], 0
	je	SHORT $LN69@GetClosest
	mov	ecx, DWORD PTR _pLoopUnit$228305[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN69@GetClosest:
	jmp	SHORT $LN11@GetClosest
$LN10@GetClosest:

; 5659 : 			}
; 5660 : 		}
; 5661 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pLoopUnit$228305[ebp], 0
	je	SHORT $LN74@GetClosest
	mov	ecx, DWORD PTR _pLoopUnit$228305[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN74@GetClosest:
	jmp	$LN12@GetClosest
$LN11@GetClosest:

; 5662 : 
; 5663 : 	*ppClosestUnit = pBestUnit;

	mov	edx, DWORD PTR _ppClosestUnit$[ebp]
	mov	eax, DWORD PTR _pBestUnit$[ebp]
	mov	DWORD PTR [edx], eax

; 5664 : 	*piClosestTurns = iMinTurns;

	mov	ecx, DWORD PTR _piClosestTurns$[ebp]
	mov	edx, DWORD PTR _iMinTurns$[ebp]
	mov	DWORD PTR [ecx], edx

; 5665 : 	return pBestUnit != NULL;

	xor	eax, eax
	cmp	DWORD PTR _pBestUnit$[ebp], 0
	setne	al

; 5666 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z$0:
	lea	ecx, DWORD PTR _pLoopUnit$228305[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z ENDP ; CvHomelandAI::GetClosestUnitByTurnsToTarget
EXTRN	?canMoveInto@CvUnit@@QBE_NABVCvPlot@@E@Z:PROC	; CvUnit::canMoveInto
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z$0
__ehfuncinfo$?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z
_TEXT	SEGMENT
tv301 = -328						; size = 4
_this$ = -324						; size = 4
$T258876 = -272						; size = 4
$T258872 = -268						; size = 4
$T258871 = -264						; size = 4
$T258829 = -224						; size = 4
$T258825 = -220						; size = 4
$T258824 = -216						; size = 4
$T258768 = -156						; size = 4
$T258759 = -152						; size = 4
$T258755 = -148						; size = 4
$T258746 = -144						; size = 4
$T258739 = -140						; size = 4
$T258729 = -136						; size = 4
$T258722 = -132						; size = 4
$T258715 = -128						; size = 4
$T258699 = -124						; size = 4
$T258695 = -120						; size = 4
$T258660 = -84						; size = 4
$T258651 = -80						; size = 4
$T258647 = -76						; size = 4
$T258638 = -72						; size = 4
$T258631 = -68						; size = 4
$T258621 = -64						; size = 4
$T258614 = -60						; size = 4
$T258607 = -56						; size = 4
$T258591 = -52						; size = 4
$T258587 = -48						; size = 4
$T258568 = -41						; size = 1
_iPlotDistance$228346 = -40				; size = 4
_iPlotDistance$228337 = -36				; size = 4
_iTargetX$ = -32					; size = 4
_pLoopUnit$ = -28					; size = 8
_it$ = -20						; size = 4
_iTargetY$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pTarget$ = 8						; size = 4
_iMaxTurns$ = 12					; size = 4
?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z PROC ; CvHomelandAI::GetBestUnitToReachTarget, COMDAT
; _this$ = ecx

; 5671 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 316				; 0000013cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5672 : 	AI_PERF_FORMAT("Homeland-GetBest-perf.csv", ("GetBestUnitToReachTarget, %d, %d, Turn %03d, %s", pTarget->getX(), pTarget->getY(), GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 5673 : 
; 5674 : 	UnitHandle pLoopUnit;

	mov	DWORD PTR _pLoopUnit$[ebp], 0
	mov	BYTE PTR _pLoopUnit$[ebp+4], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5675 : 	MoveUnitsArray::iterator it;
; 5676 : 
; 5677 : 	// Get the raw distance for all units
; 5678 : 	int iTargetX = pTarget->getX();

	mov	eax, DWORD PTR _pTarget$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _iTargetX$[ebp], ecx

; 5679 : 	int iTargetY = pTarget->getY();

	mov	edx, DWORD PTR _pTarget$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR _iTargetY$[ebp], eax

; 5680 : 	
; 5681 : 	// Normal priority units
; 5682 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _it$[ebp], edx
	jmp	SHORT $LN16@GetBestUni
$LN15@GetBestUni:
	mov	eax, DWORD PTR _it$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], eax
$LN16@GetBestUni:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T258587[ebp], ecx
	mov	edx, DWORD PTR $T258587[ebp]
	mov	eax, DWORD PTR [edx+4]
	shl	eax, 4
	mov	ecx, DWORD PTR $T258587[ebp]
	add	eax, DWORD PTR [ecx]
	cmp	DWORD PTR _it$[ebp], eax
	je	$LN14@GetBestUni

; 5683 : 	{
; 5684 : 		pLoopUnit = m_pPlayer->getUnit(it->GetID());

	mov	edx, DWORD PTR _it$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T258591[ebp], eax
	mov	ecx, DWORD PTR $T258591[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T258607[ebp], eax
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN35@GetBestUni
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN35@GetBestUni:
	mov	eax, DWORD PTR $T258607[ebp]
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN42@GetBestUni
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 5685 : 		if(pLoopUnit)

$LN42@GetBestUni:
	xor	ecx, ecx
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN13@GetBestUni

; 5686 : 		{
; 5687 : 			// Make sure domain matches
; 5688 : 			if(pLoopUnit->getDomainType() == DOMAIN_SEA && !pTarget->isWater() ||
; 5689 : 				pLoopUnit->getDomainType() == DOMAIN_LAND && pTarget->isWater())

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T258614[ebp], eax
	mov	ecx, DWORD PTR $T258614[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN10@GetBestUni
	mov	ecx, DWORD PTR _pTarget$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@GetBestUni
$LN10@GetBestUni:
	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T258621[ebp], edx
	mov	ecx, DWORD PTR $T258621[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN12@GetBestUni
	mov	eax, DWORD PTR _pTarget$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN12@GetBestUni
$LN11@GetBestUni:

; 5690 : 			{
; 5691 : 				it->SetMovesToTarget(MAX_INT);

	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR [ecx+8], 2147483647		; 7fffffffH

; 5692 : 				continue;

	jmp	$LN15@GetBestUni
$LN12@GetBestUni:

; 5693 : 			}
; 5694 : 
; 5695 : 			// Make sure we can move into the destination.  The path finder will do a similar check near the beginning, but it is best to get this out of the way before then
; 5696 : 			if(!pLoopUnit->canMoveInto(*pTarget, CvUnit::MOVEFLAG_DESTINATION | CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE))

	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T258631[ebp], edx
	push	132					; 00000084H
	mov	eax, DWORD PTR _pTarget$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T258631[ebp]
	call	?canMoveInto@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveInto
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN9@GetBestUni

; 5697 : 			{
; 5698 : 				it->SetMovesToTarget(MAX_INT);

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR [edx+8], 2147483647		; 7fffffffH

; 5699 : 				continue;

	jmp	$LN15@GetBestUni
$LN9@GetBestUni:

; 5700 : 			}
; 5701 : 
; 5702 : 			int iPlotDistance = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), iTargetX, iTargetY);

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T258638[ebp], eax
	mov	ecx, DWORD PTR $T258638[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T258647[ebp], edx
	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T258651[ebp], eax
	mov	ecx, DWORD PTR $T258651[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T258660[ebp], edx
	mov	eax, DWORD PTR _iTargetY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iTargetX$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T258647[ebp]
	push	edx
	mov	eax, DWORD PTR $T258660[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iPlotDistance$228337[ebp], eax

; 5703 : 			it->SetMovesToTarget(iPlotDistance);

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR _iPlotDistance$228337[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN13@GetBestUni:

; 5704 : 		}
; 5705 : 	}

	jmp	$LN15@GetBestUni
$LN14@GetBestUni:

; 5706 : 
; 5707 : 	// High priority units
; 5708 : 	for(it = m_CurrentMoveHighPriorityUnits.begin(); it != m_CurrentMoveHighPriorityUnits.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1056]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN8@GetBestUni
$LN7@GetBestUni:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _it$[ebp], edx
$LN8@GetBestUni:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1056				; 00000420H
	mov	DWORD PTR $T258695[ebp], eax
	mov	ecx, DWORD PTR $T258695[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	mov	eax, DWORD PTR $T258695[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN6@GetBestUni

; 5709 : 	{
; 5710 : 		pLoopUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T258699[ebp], edx
	mov	eax, DWORD PTR $T258699[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T258715[ebp], eax
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN95@GetBestUni
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN95@GetBestUni:
	mov	edx, DWORD PTR $T258715[ebp]
	mov	DWORD PTR _pLoopUnit$[ebp], edx
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN102@GetBestUni
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 5711 : 		if(pLoopUnit)

$LN102@GetBestUni:
	xor	eax, eax
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@GetBestUni

; 5712 : 		{
; 5713 : 			// Make sure domain matches
; 5714 : 			if(pLoopUnit->getDomainType() == DOMAIN_SEA && !pTarget->isWater() ||
; 5715 : 				pLoopUnit->getDomainType() == DOMAIN_LAND && pTarget->isWater())

	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T258722[ebp], edx
	mov	ecx, DWORD PTR $T258722[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN2@GetBestUni
	mov	eax, DWORD PTR _pTarget$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN3@GetBestUni
$LN2@GetBestUni:
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T258729[ebp], ecx
	mov	ecx, DWORD PTR $T258729[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN4@GetBestUni
	mov	edx, DWORD PTR _pTarget$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@GetBestUni
$LN3@GetBestUni:

; 5716 : 			{
; 5717 : 				it->SetMovesToTarget(MAX_INT);

	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR [eax+8], 2147483647		; 7fffffffH

; 5718 : 				continue;

	jmp	$LN7@GetBestUni
$LN4@GetBestUni:

; 5719 : 			}
; 5720 : 
; 5721 : 			// Make sure we can move into the destination.  The path finder will do a similar check near the beginning, but it is best to get this out of the way before then
; 5722 : 			if(!pLoopUnit->canMoveInto(*pTarget, CvUnit::MOVEFLAG_DESTINATION | CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE))

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T258739[ebp], ecx
	push	132					; 00000084H
	mov	edx, DWORD PTR _pTarget$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T258739[ebp]
	call	?canMoveInto@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveInto
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@GetBestUni

; 5723 : 			{
; 5724 : 				it->SetMovesToTarget(MAX_INT);

	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR [ecx+8], 2147483647		; 7fffffffH

; 5725 : 				continue;

	jmp	$LN7@GetBestUni
$LN1@GetBestUni:

; 5726 : 			}
; 5727 : 
; 5728 : 			int iPlotDistance = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), iTargetX, iTargetY);

	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T258746[ebp], edx
	mov	eax, DWORD PTR $T258746[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T258755[ebp], ecx
	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T258759[ebp], edx
	mov	eax, DWORD PTR $T258759[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T258768[ebp], ecx
	mov	edx, DWORD PTR _iTargetY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iTargetX$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T258755[ebp]
	push	ecx
	mov	edx, DWORD PTR $T258768[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iPlotDistance$228346[ebp], eax

; 5729 : 			it->SetMovesToTarget(iPlotDistance);

	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR _iPlotDistance$228346[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN5@GetBestUni:

; 5730 : 		}
; 5731 : 	}

	jmp	$LN7@GetBestUni
$LN6@GetBestUni:

; 5732 : 
; 5733 : 	// Sort by raw distance
; 5734 : 	std::stable_sort(m_CurrentMoveUnits.begin(), m_CurrentMoveUnits.end());

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T258824[ebp], edx
	mov	eax, DWORD PTR $T258824[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	mov	edx, DWORD PTR $T258824[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T258825[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T258829[ebp], ecx
	mov	edx, DWORD PTR $T258829[ebp]
	cmp	edx, DWORD PTR $T258825[ebp]
	je	SHORT $LN169@GetBestUni
	push	0
	push	0
	mov	eax, DWORD PTR $T258825[ebp]
	push	eax
	mov	ecx, DWORD PTR $T258829[ebp]
	push	ecx
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 16					; 00000010H
$LN169@GetBestUni:

; 5735 : 	std::stable_sort(m_CurrentMoveHighPriorityUnits.begin(), m_CurrentMoveHighPriorityUnits.end());

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1056				; 00000420H
	mov	DWORD PTR $T258871[ebp], edx
	mov	eax, DWORD PTR $T258871[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	mov	edx, DWORD PTR $T258871[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T258872[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1056]
	mov	DWORD PTR $T258876[ebp], ecx
	mov	edx, DWORD PTR $T258876[ebp]
	cmp	edx, DWORD PTR $T258872[ebp]
	je	SHORT $LN191@GetBestUni
	push	0
	push	0
	mov	eax, DWORD PTR $T258872[ebp]
	push	eax
	mov	ecx, DWORD PTR $T258876[ebp]
	push	ecx
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 16					; 00000010H
$LN191@GetBestUni:

; 5736 : 
; 5737 : 	// Find the one with the best true moves distance
; 5738 : 	GetClosestUnitByTurnsToTarget(m_CurrentMoveUnits, pTarget, iMaxTurns, &m_CurrentBestMoveUnit, &m_iCurrentBestMoveUnitTurns);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2400				; 00000960H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2396				; 0000095cH
	push	eax
	mov	ecx, DWORD PTR _iMaxTurns$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTarget$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z ; CvHomelandAI::GetClosestUnitByTurnsToTarget

; 5739 : 	GetClosestUnitByTurnsToTarget(m_CurrentMoveHighPriorityUnits, pTarget, iMaxTurns, &m_CurrentBestMoveHighPriorityUnit, &m_iCurrentBestMoveHighPriorityUnitTurns);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2408				; 00000968H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2404				; 00000964H
	push	edx
	mov	eax, DWORD PTR _iMaxTurns$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarget$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1056				; 00000420H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z ; CvHomelandAI::GetClosestUnitByTurnsToTarget

; 5740 : 
; 5741 : 	return m_CurrentBestMoveHighPriorityUnit != NULL || m_CurrentBestMoveUnit != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2404], 0
	jne	SHORT $LN19@GetBestUni
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2396], 0
	jne	SHORT $LN19@GetBestUni
	mov	DWORD PTR tv301[ebp], 0
	jmp	SHORT $LN20@GetBestUni
$LN19@GetBestUni:
	mov	DWORD PTR tv301[ebp], 1
$LN20@GetBestUni:
	mov	dl, BYTE PTR tv301[ebp]
	mov	BYTE PTR $T258568[ebp], dl
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN225@GetBestUni
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN225@GetBestUni:
	mov	al, BYTE PTR $T258568[ebp]

; 5742 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z$0:
	lea	ecx, DWORD PTR _pLoopUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z ENDP ; CvHomelandAI::GetBestUnitToReachTarget
; Function compile flags: /Odtp
;	COMDAT ?MoveToEmptySpaceNearTarget@CvHomelandAI@@AAE_NPAVCvUnit@@PAVCvPlot@@_N@Z
_TEXT	SEGMENT
_this$ = -140						; size = 4
$T259166 = -136						; size = 4
$T259162 = -132						; size = 4
$T259149 = -128						; size = 4
$T259145 = -124						; size = 4
$T259127 = -120						; size = 4
$T259123 = -116						; size = 4
$T258971 = -40						; size = 4
$T258967 = -36						; size = 4
$T258961 = -32						; size = 8
$T258960 = -21						; size = 1
$T258959 = -20						; size = 8
$T258958 = -9						; size = 1
_iI$228355 = -8						; size = 4
_pLoopPlot$ = -4					; size = 4
_pUnit$ = 8						; size = 4
_pTarget$ = 12						; size = 4
_bLand$ = 16						; size = 1
?MoveToEmptySpaceNearTarget@CvHomelandAI@@AAE_NPAVCvUnit@@PAVCvPlot@@_N@Z PROC ; CvHomelandAI::MoveToEmptySpaceNearTarget, COMDAT
; _this$ = ecx

; 5746 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	DWORD PTR _this$[ebp], ecx

; 5747 : 	CvPlot* pLoopPlot;
; 5748 : 
; 5749 : 	// Look at spaces adjacent to target
; 5750 : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	DWORD PTR _iI$228355[ebp], 0
	jmp	SHORT $LN7@MoveToEmpt
$LN6@MoveToEmpt:
	mov	eax, DWORD PTR _iI$228355[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$228355[ebp], eax
$LN7@MoveToEmpt:
	cmp	DWORD PTR _iI$228355[ebp], 6
	jge	$LN5@MoveToEmpt

; 5751 : 	{
; 5752 : 		pLoopPlot = plotDirection(pTarget->getX(), pTarget->getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _pTarget$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T258967[ebp], edx
	mov	eax, DWORD PTR _pTarget$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T258971[ebp], ecx
	mov	edx, DWORD PTR _iI$228355[ebp]
	push	edx
	mov	eax, DWORD PTR $T258967[ebp]
	push	eax
	mov	ecx, DWORD PTR $T258971[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 5753 : 		if(pLoopPlot != NULL && pLoopPlot->isWater() != bLand)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	$LN4@MoveToEmpt
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	movzx	eax, BYTE PTR _bLand$[ebp]
	cmp	edx, eax
	je	$LN4@MoveToEmpt

; 5754 : 		{
; 5755 : 			// Must be currently empty of friendly combat units
; 5756 : 			if(!pLoopPlot->getBestDefender(m_pPlayer->GetID()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T259123[ebp], eax
	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	mov	ecx, DWORD PTR $T259123[ebp]
	push	ecx
	lea	edx, DWORD PTR $T258959[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	mov	DWORD PTR $T259127[ebp], eax
	mov	eax, DWORD PTR $T259127[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	sete	cl
	mov	BYTE PTR $T258958[ebp], cl
	cmp	DWORD PTR $T258959[ebp], 0
	je	SHORT $LN87@MoveToEmpt
	mov	ecx, DWORD PTR $T258959[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN87@MoveToEmpt:
	movzx	edx, BYTE PTR $T258958[ebp]
	test	edx, edx
	je	$LN4@MoveToEmpt

; 5757 : 			{
; 5758 : 				// Enemies too
; 5759 : 				if(!pLoopPlot->getBestDefender(NO_PLAYER, m_pPlayer->GetID()))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T259145[ebp], edx
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR $T259145[ebp]
	push	eax
	push	-1
	lea	ecx, DWORD PTR $T258961[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	mov	DWORD PTR $T259149[ebp], eax
	mov	edx, DWORD PTR $T259149[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx], 0
	sete	al
	mov	BYTE PTR $T258960[ebp], al
	cmp	DWORD PTR $T258961[ebp], 0
	je	SHORT $LN98@MoveToEmpt
	mov	ecx, DWORD PTR $T258961[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN98@MoveToEmpt:
	movzx	ecx, BYTE PTR $T258960[ebp]
	test	ecx, ecx
	je	SHORT $LN4@MoveToEmpt

; 5760 : 				{
; 5761 : 					// Find a path to this space
; 5762 : 					if(pUnit->GeneratePath(pLoopPlot))

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@MoveToEmpt

; 5763 : 					{
; 5764 : 						// Go ahead with mission
; 5765 : 						pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pLoopPlot->getX(), pLoopPlot->getY());

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T259162[ebp], edx
	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T259166[ebp], ecx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR $T259162[ebp]
	push	edx
	mov	eax, DWORD PTR $T259166[ebp]
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 5766 : 						return true;

	mov	al, 1
	jmp	SHORT $LN8@MoveToEmpt
$LN4@MoveToEmpt:

; 5767 : 					}
; 5768 : 				}
; 5769 : 			}
; 5770 : 		}
; 5771 : 	}

	jmp	$LN6@MoveToEmpt
$LN5@MoveToEmpt:

; 5772 : 	return false;

	xor	al, al
$LN8@MoveToEmpt:

; 5773 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MoveToEmptySpaceNearTarget@CvHomelandAI@@AAE_NPAVCvUnit@@PAVCvPlot@@_N@Z ENDP ; CvHomelandAI::MoveToEmptySpaceNearTarget
_TEXT	ENDS
PUBLIC	?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z ; CvHomelandAI::ChooseBestFreeWonderCity
EXTRN	?canConstruct@CvCity@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z:PROC ; CvCity::canConstruct
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z$0
__ehfuncinfo$?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
tv144 = -56						; size = 4
tv143 = -52						; size = 4
_this$ = -48						; size = 4
$T259182 = -44						; size = 4
$T259170 = -40						; size = 4
$T259169 = -36						; size = 4
_iBestTurns$ = -32					; size = 4
_iTurns$ = -28						; size = 4
_pBestCity$ = -24					; size = 4
_pLoopCity$ = -20					; size = 4
_iLoop$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_eWonder$ = 8						; size = 4
_pEngineer$ = 12					; size = 8
?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvHomelandAI::ChooseBestFreeWonderCity, COMDAT
; _this$ = ecx

; 5777 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5778 : 	CvCity* pBestCity = NULL;

	mov	DWORD PTR _pBestCity$[ebp], 0

; 5779 : 	CvCity* pLoopCity;
; 5780 : 	int iLoop;
; 5781 : 	int iBestTurns = MAX_INT;

	mov	DWORD PTR _iBestTurns$[ebp], 2147483647	; 7fffffffH

; 5782 : 	int iTurns;
; 5783 : 
; 5784 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN5@ChooseBest
$LN4@ChooseBest:
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN5@ChooseBest:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	$LN3@ChooseBest

; 5785 : 	{
; 5786 : 		if(pLoopCity->canConstruct(eWonder))

	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _eWonder$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?canConstruct@CvCity@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z ; CvCity::canConstruct
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@ChooseBest

; 5787 : 		{
; 5788 : 			iTurns = TurnsToReachTarget(pEngineer, pLoopCity->plot(), true /*bReusePaths*/);

	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T259169[ebp], esp
	mov	DWORD PTR $T259182[ebp], eax
	mov	ecx, DWORD PTR $T259182[ebp]
	mov	edx, DWORD PTR _pEngineer$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T259182[ebp]
	mov	cl, BYTE PTR _pEngineer$[ebp+4]
	mov	BYTE PTR [eax+4], cl
	mov	edx, DWORD PTR $T259182[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN11@ChooseBest
	mov	eax, DWORD PTR $T259182[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN11@ChooseBest:
	mov	ecx, DWORD PTR $T259182[ebp]
	mov	DWORD PTR tv143[ebp], ecx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv144[ebp], eax
	mov	edx, DWORD PTR tv144[ebp]
	mov	DWORD PTR _iTurns$[ebp], edx

; 5789 : 			if(iTurns < iBestTurns)

	mov	eax, DWORD PTR _iTurns$[ebp]
	cmp	eax, DWORD PTR _iBestTurns$[ebp]
	jge	SHORT $LN2@ChooseBest

; 5790 : 			{
; 5791 : 				pBestCity = pLoopCity;

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	mov	DWORD PTR _pBestCity$[ebp], ecx

; 5792 : 				iBestTurns = iTurns;

	mov	edx, DWORD PTR _iTurns$[ebp]
	mov	DWORD PTR _iBestTurns$[ebp], edx
$LN2@ChooseBest:

; 5793 : 			}
; 5794 : 		}
; 5795 : 	}

	jmp	$LN4@ChooseBest
$LN3@ChooseBest:

; 5796 : 
; 5797 : 	return pBestCity;

	mov	eax, DWORD PTR _pBestCity$[ebp]
	mov	DWORD PTR $T259170[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pEngineer$[ebp], 0
	je	SHORT $LN16@ChooseBest
	mov	ecx, DWORD PTR _pEngineer$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN16@ChooseBest:
	mov	eax, DWORD PTR $T259170[ebp]

; 5798 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _pEngineer$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvHomelandAI::ChooseBestFreeWonderCity
PUBLIC	?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase
; Function compile flags: /Odtp
;	COMDAT ?FindArchaeologistTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z
_TEXT	SEGMENT
tv214 = -220						; size = 4
tv213 = -216						; size = 4
tv273 = -212						; size = 4
_this$ = -208						; size = 4
$T259487 = -148						; size = 4
$T259483 = -144						; size = 4
$T259464 = -140						; size = 4
$T259460 = -136						; size = 4
$T259430 = -132						; size = 4
__Tmp$259420 = -128					; size = 4
$T259398 = -124						; size = 4
$T259388 = -120						; size = 4
$T259348 = -116						; size = 4
$T259343 = -112						; size = 4
$T259339 = -105						; size = 1
$T259328 = -104						; size = 4
$T259324 = -97						; size = 1
_iMapY$259378 = -96					; size = 4
_iMapX$259377 = -92					; size = 4
$T259317 = -88						; size = 4
$T259313 = -84						; size = 4
$T259309 = -80						; size = 4
$T259293 = -76						; size = 4
$T259289 = -72						; size = 4
$T259259 = -68						; size = 4
__Tmp$259249 = -64					; size = 4
$T259227 = -60						; size = 4
$T259208 = -56						; size = 4
$T259207 = -52						; size = 4
$T259206 = -48						; size = 4
$T259205 = -44						; size = 4
$T259204 = -40						; size = 4
$T259203 = -36						; size = 4
$T259202 = -32						; size = 4
$T259201 = -28						; size = 4
$T259200 = -24						; size = 4
_iTurns$228404 = -20					; size = 4
_pTarget$228402 = -16					; size = 4
_iBestTurns$ = -12					; size = 4
_pBestTarget$ = -8					; size = 4
_it$ = -4						; size = 4
_pUnit$ = 8						; size = 4
?FindArchaeologistTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z PROC ; CvHomelandAI::FindArchaeologistTarget, COMDAT
; _this$ = ecx

; 5802 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	mov	DWORD PTR _this$[ebp], ecx

; 5803 : 	CvPlot *pBestTarget = NULL;

	mov	DWORD PTR _pBestTarget$[ebp], 0

; 5804 : 	int iBestTurns = MAX_INT;

	mov	DWORD PTR _iBestTurns$[ebp], 2147483647	; 7fffffffH

; 5805 : 
; 5806 : 	// Reverse the logic from most of the Homeland moves; for this we'll loop through units and find the best targets for them (instead of vice versa)
; 5807 : 	std::vector<CvHomelandTarget>::iterator it;

	mov	DWORD PTR _it$[ebp], 0

; 5808 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 5809 : 	for (it = m_TargetedAntiquitySites.begin(); it != m_TargetedAntiquitySites.end(); ++it)
; 5810 : #else
; 5811 : 	for (it = m_TargetedAntiquitySites.begin(); it != m_TargetedAntiquitySites.end(); it++)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2512]
	mov	DWORD PTR $T259227[ebp], ecx
	mov	edx, DWORD PTR $T259227[ebp]
	mov	DWORD PTR $T259200[ebp], edx
	mov	eax, DWORD PTR $T259200[ebp]
	mov	DWORD PTR _it$[ebp], eax
	jmp	SHORT $LN10@FindArchae@2
$LN9@FindArchae@2:
	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR __Tmp$259249[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR _it$[ebp], edx
	mov	eax, DWORD PTR __Tmp$259249[ebp]
	mov	DWORD PTR $T259201[ebp], eax
$LN10@FindArchae@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2516]
	mov	DWORD PTR $T259259[ebp], edx
	mov	eax, DWORD PTR $T259259[ebp]
	mov	DWORD PTR $T259202[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T259202[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN8@FindArchae@2

; 5812 : #endif
; 5813 : 	{
; 5814 : 		CvPlot* pTarget = GC.getMap().plot(it->GetTargetX(), it->GetTargetY());

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T259289[ebp], edx
	mov	eax, DWORD PTR $T259289[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T259293[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T259309[ebp], edx
	mov	eax, DWORD PTR $T259309[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T259313[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T259317[ebp], edx
	cmp	DWORD PTR $T259313[ebp], -2147483647	; 80000001H
	je	SHORT $LN58@FindArchae@2
	cmp	DWORD PTR $T259293[ebp], -2147483647	; 80000001H
	jne	SHORT $LN59@FindArchae@2
$LN58@FindArchae@2:
	mov	DWORD PTR _pTarget$228402[ebp], 0
	jmp	$LN60@FindArchae@2
$LN59@FindArchae@2:
	mov	eax, DWORD PTR $T259317[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T259324[ebp], cl
	mov	edx, DWORD PTR $T259317[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T259328[ebp], eax
	movzx	ecx, BYTE PTR $T259324[ebp]
	test	ecx, ecx
	je	SHORT $LN71@FindArchae@2
	cmp	DWORD PTR $T259313[ebp], 0
	jge	SHORT $LN70@FindArchae@2
	mov	eax, DWORD PTR $T259313[ebp]
	cdq
	idiv	DWORD PTR $T259328[ebp]
	add	edx, DWORD PTR $T259328[ebp]
	mov	DWORD PTR _iMapX$259377[ebp], edx
	jmp	SHORT $LN72@FindArchae@2
	jmp	SHORT $LN71@FindArchae@2
$LN70@FindArchae@2:
	mov	edx, DWORD PTR $T259313[ebp]
	cmp	edx, DWORD PTR $T259328[ebp]
	jl	SHORT $LN71@FindArchae@2
	mov	eax, DWORD PTR $T259313[ebp]
	cdq
	idiv	DWORD PTR $T259328[ebp]
	mov	DWORD PTR _iMapX$259377[ebp], edx
	jmp	SHORT $LN72@FindArchae@2
$LN71@FindArchae@2:
	mov	eax, DWORD PTR $T259313[ebp]
	mov	DWORD PTR _iMapX$259377[ebp], eax
$LN72@FindArchae@2:
	mov	ecx, DWORD PTR $T259317[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T259339[ebp], dl
	mov	eax, DWORD PTR $T259317[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T259343[ebp], ecx
	movzx	edx, BYTE PTR $T259339[ebp]
	push	edx
	mov	eax, DWORD PTR $T259343[ebp]
	push	eax
	mov	ecx, DWORD PTR $T259293[ebp]
	push	ecx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$259378[ebp], eax
	mov	edx, DWORD PTR _iMapY$259378[ebp]
	push	edx
	mov	eax, DWORD PTR _iMapX$259377[ebp]
	push	eax
	mov	ecx, DWORD PTR $T259317[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN62@FindArchae@2
	mov	ecx, DWORD PTR $T259317[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T259348[ebp], edx
	mov	eax, DWORD PTR _iMapY$259378[ebp]
	imul	eax, DWORD PTR $T259348[ebp]
	add	eax, DWORD PTR _iMapX$259377[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T259317[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv273[ebp], eax
	jmp	SHORT $LN63@FindArchae@2
$LN62@FindArchae@2:
	mov	DWORD PTR tv273[ebp], 0
$LN63@FindArchae@2:
	mov	edx, DWORD PTR tv273[ebp]
	mov	DWORD PTR _pTarget$228402[ebp], edx
$LN60@FindArchae@2:

; 5815 : 		if (m_pPlayer->GetPlotDanger(*pTarget) == 0)

	mov	eax, DWORD PTR _pTarget$228402[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	test	eax, eax
	jne	SHORT $LN7@FindArchae@2

; 5816 : 		{
; 5817 : 			int iTurns = TurnsToReachTarget(pUnit, pTarget);

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _pTarget$228402[ebp]
	push	edx
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T259203[ebp], esp
	mov	DWORD PTR $T259388[ebp], eax
	mov	ecx, DWORD PTR $T259388[ebp]
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T259388[ebp]
	mov	BYTE PTR [eax+4], 0
	mov	ecx, DWORD PTR $T259388[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN83@FindArchae@2
	mov	edx, DWORD PTR $T259388[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN83@FindArchae@2:
	mov	eax, DWORD PTR $T259388[ebp]
	mov	DWORD PTR tv213[ebp], eax
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv214[ebp], eax
	mov	ecx, DWORD PTR tv214[ebp]
	mov	DWORD PTR _iTurns$228404[ebp], ecx

; 5818 : 
; 5819 : 			if (iTurns < iBestTurns)

	mov	edx, DWORD PTR _iTurns$228404[ebp]
	cmp	edx, DWORD PTR _iBestTurns$[ebp]
	jge	SHORT $LN7@FindArchae@2

; 5820 : 			{
; 5821 : 				pBestTarget = pTarget;

	mov	eax, DWORD PTR _pTarget$228402[ebp]
	mov	DWORD PTR _pBestTarget$[ebp], eax

; 5822 : 				iBestTurns = iTurns;

	mov	ecx, DWORD PTR _iTurns$228404[ebp]
	mov	DWORD PTR _iBestTurns$[ebp], ecx
$LN7@FindArchae@2:

; 5823 : 			}
; 5824 : 		}
; 5825 : 	}

	jmp	$LN9@FindArchae@2
$LN8@FindArchae@2:

; 5826 : 
; 5827 : 	// Erase this site from future contention
; 5828 : 	if (pBestTarget)

	cmp	DWORD PTR _pBestTarget$[ebp], 0
	je	$LN5@FindArchae@2

; 5829 : 	{
; 5830 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 5831 : 		for (it = m_TargetedAntiquitySites.begin(); it != m_TargetedAntiquitySites.end(); ++it)
; 5832 : #else
; 5833 : 		for (it = m_TargetedAntiquitySites.begin(); it != m_TargetedAntiquitySites.end(); it++)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2512]
	mov	DWORD PTR $T259398[ebp], eax
	mov	ecx, DWORD PTR $T259398[ebp]
	mov	DWORD PTR $T259204[ebp], ecx
	mov	edx, DWORD PTR $T259204[ebp]
	mov	DWORD PTR _it$[ebp], edx
	jmp	SHORT $LN4@FindArchae@2
$LN3@FindArchae@2:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR __Tmp$259420[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _it$[ebp], ecx
	mov	edx, DWORD PTR __Tmp$259420[ebp]
	mov	DWORD PTR $T259205[ebp], edx
$LN4@FindArchae@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2516]
	mov	DWORD PTR $T259430[ebp], ecx
	mov	edx, DWORD PTR $T259430[ebp]
	mov	DWORD PTR $T259206[ebp], edx
	mov	eax, DWORD PTR _it$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T259206[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN5@FindArchae@2

; 5834 : #endif
; 5835 : 		{
; 5836 : 			if (it->GetTargetX() == pBestTarget->getX() && it->GetTargetY() == pBestTarget->getY())

	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T259460[ebp], ecx
	mov	edx, DWORD PTR $T259460[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T259464[ebp], eax
	mov	ecx, DWORD PTR _pBestTarget$[ebp]
	movsx	edx, WORD PTR [ecx]
	cmp	DWORD PTR $T259464[ebp], edx
	jne	SHORT $LN1@FindArchae@2
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T259483[ebp], eax
	mov	ecx, DWORD PTR $T259483[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T259487[ebp], edx
	mov	eax, DWORD PTR _pBestTarget$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	cmp	DWORD PTR $T259487[ebp], ecx
	jne	SHORT $LN1@FindArchae@2

; 5837 : 			{
; 5838 : 				m_TargetedAntiquitySites.erase(it);

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T259207[ebp], edx
	mov	eax, DWORD PTR $T259207[ebp]
	push	eax
	lea	ecx, DWORD PTR $T259208[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2508				; 000009ccH
	call	?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase

; 5839 : 				break;

	jmp	SHORT $LN5@FindArchae@2
$LN1@FindArchae@2:

; 5840 : 			}
; 5841 : 		}

	jmp	$LN3@FindArchae@2
$LN5@FindArchae@2:

; 5842 : 	}
; 5843 : 
; 5844 : 	return pBestTarget;

	mov	eax, DWORD PTR _pBestTarget$[ebp]

; 5845 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindArchaeologistTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z ENDP ; CvHomelandAI::FindArchaeologistTarget
_TEXT	ENDS
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_06NHKAIDD@?$CF03d?0?5?$AA@		; `string'
PUBLIC	?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z ; CvHomelandAI::GetLogFileName
PUBLIC	__$ArrayPad$
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
CONST	SEGMENT
??_C@_06NHKAIDD@?$CF03d?0?5?$AA@ DB '%03d, ', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z
_TEXT	SEGMENT
tv223 = -292						; size = 4
tv193 = -288						; size = 4
tv234 = -284						; size = 4
tv245 = -280						; size = 4
tv93 = -276						; size = 4
_this$ = -272						; size = 4
$T259670 = -268						; size = 4
$T259666 = -264						; size = 4
$T259662 = -260						; size = 4
$T259654 = -256						; size = 4
$T259653 = -252						; size = 4
$T259649 = -248						; size = 4
$T259615 = -244						; size = 28
$T259614 = -216						; size = 28
$T259613 = -188						; size = 28
_strOutBuf$228422 = -160				; size = 28
_szTemp2$228425 = -132					; size = 28
_strPlayerName$228426 = -104				; size = 28
_pLog$228427 = -76					; size = 4
_strTemp$228424 = -72					; size = 28
_strBaseString$228423 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strMsg$ = 8						; size = 4
?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z PROC ; CvHomelandAI::LogHomelandMessage, COMDAT
; _this$ = ecx

; 5850 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 280				; 00000118H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5851 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN2@LogHomelan
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@LogHomelan

; 5852 : 	{
; 5853 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$228422[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5854 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$228423[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 5855 : 		CvString strTemp, szTemp2;

	lea	ecx, DWORD PTR _strTemp$228424[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _szTemp2$228425[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 5856 : 		CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$228426[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 5857 : 		FILogFile* pLog;
; 5858 : 
; 5859 : 		strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T259649[ebp], eax
	cmp	DWORD PTR $T259649[ebp], 0
	je	SHORT $LN28@LogHomelan
	mov	eax, DWORD PTR $T259649[ebp]
	push	eax
	lea	ecx, DWORD PTR _strPlayerName$228426[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN29@LogHomelan
$LN28@LogHomelan:
	lea	ecx, DWORD PTR _strPlayerName$228426[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN29@LogHomelan:

; 5860 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv93[ebp], eax
	lea	ecx, DWORD PTR _strPlayerName$228426[ebp]
	push	ecx
	lea	edx, DWORD PTR $T259613[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z ; CvHomelandAI::GetLogFileName
	mov	DWORD PTR tv245[ebp], eax
	mov	eax, DWORD PTR tv245[ebp]
	mov	DWORD PTR $T259653[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T259653[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T259654[ebp], eax
	push	0
	push	1
	mov	ecx, DWORD PTR $T259654[ebp]
	push	ecx
	mov	edx, DWORD PTR tv93[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv93[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pLog$228427[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T259613[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5861 : 
; 5862 : 		// Get the leading info for this line
; 5863 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T259662[ebp], eax
	mov	ecx, DWORD PTR $T259662[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	ecx, DWORD PTR _strBaseString$228423[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 5864 : 		strBaseString += strPlayerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	edx, DWORD PTR _strPlayerName$228426[ebp]
	push	edx
	lea	eax, DWORD PTR $T259614[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv234[ebp], eax
	mov	ecx, DWORD PTR tv234[ebp]
	mov	DWORD PTR tv193[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR tv193[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBaseString$228423[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T259614[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5865 : 		strOutBuf = strBaseString + strMsg;

	mov	eax, DWORD PTR _strMsg$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$228423[ebp]
	push	ecx
	lea	edx, DWORD PTR $T259615[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv223[ebp], eax
	mov	eax, DWORD PTR tv223[ebp]
	mov	DWORD PTR $T259666[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T259666[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$228422[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T259615[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5866 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$228422[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T259670[ebp], eax
	mov	ecx, DWORD PTR $T259670[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$228427[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$228427[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8

; 5867 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strPlayerName$228426[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _szTemp2$228425[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$228424[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$228423[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$228422[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@LogHomelan:

; 5868 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$228422[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$228423[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$228424[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$3:
	lea	ecx, DWORD PTR _szTemp2$228425[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$4:
	lea	ecx, DWORD PTR _strPlayerName$228426[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$5:
	lea	ecx, DWORD PTR $T259613[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$6:
	lea	ecx, DWORD PTR $T259614[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$7:
	lea	ecx, DWORD PTR $T259615[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ENDP ; CvHomelandAI::LogHomelandMessage
PUBLIC	??_C@_08GEMFNCOI@?$CFs?5?$CI?$CFd?$CJ?0?$AA@	; `string'
PUBLIC	??_C@_0BO@OFPJGPOA@PlayerHomelandAIPatrolLog?4csv?$AA@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_08GEMFNCOI@?$CFs?5?$CI?$CFd?$CJ?0?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_08GEMFNCOI@?$CFs?5?$CI?$CFd?$CJ?0?$AA@ DB '%s (%d),', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OFPJGPOA@PlayerHomelandAIPatrolLog?4csv?$AA@
CONST	SEGMENT
??_C@_0BO@OFPJGPOA@PlayerHomelandAIPatrolLog?4csv?$AA@ DB 'PlayerHomeland'
	DB	'AIPatrolLog.csv', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z$3
__ehfuncinfo$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z
_TEXT	SEGMENT
tv79 = -168						; size = 4
tv217 = -164						; size = 4
_this$ = -160						; size = 4
$T259754 = -156						; size = 4
$T259750 = -152						; size = 4
$T259746 = -148						; size = 4
$T259737 = -144						; size = 4
$T259733 = -140						; size = 4
$T259715 = -136						; size = 4
_strFileName$ = -132					; size = 28
_strLog$ = -104						; size = 28
_strPlayerName$ = -76					; size = 28
_pLog$ = -48						; size = 4
_strTemp$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strMsg$ = 8						; size = 4
_pPatrolUnit$ = 12					; size = 4
?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z PROC ; CvHomelandAI::LogPatrolMessage, COMDAT
; _this$ = ecx

; 5871 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 156				; 0000009cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5872 : 	if(!pPatrolUnit || !(GC.getLogging() && GC.getAILogging()))

	cmp	DWORD PTR _pPatrolUnit$[ebp], 0
	je	SHORT $LN2@LogPatrolM
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@LogPatrolM
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@LogPatrolM
$LN2@LogPatrolM:

; 5873 : 	{
; 5874 : 		return;

	jmp	$LN4@LogPatrolM
$LN3@LogPatrolM:

; 5875 : 	}
; 5876 : 
; 5877 : 	// Open the log file
; 5878 : 	CvString strFileName = "PlayerHomelandAIPatrolLog.csv";

	mov	edx, OFFSET ??_C@_0BO@OFPJGPOA@PlayerHomelandAIPatrolLog?4csv?$AA@
	test	edx, edx
	je	SHORT $LN12@LogPatrolM
	mov	DWORD PTR tv217[ebp], OFFSET ??_C@_0BO@OFPJGPOA@PlayerHomelandAIPatrolLog?4csv?$AA@
	jmp	SHORT $LN13@LogPatrolM
$LN12@LogPatrolM:
	mov	DWORD PTR tv217[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN13@LogPatrolM:
	mov	eax, DWORD PTR tv217[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFileName$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5879 : 	FILogFile* pLog;
; 5880 : 	pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv79[ebp], eax
	lea	ecx, DWORD PTR _strFileName$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T259715[ebp], eax
	push	0
	push	1
	mov	ecx, DWORD PTR $T259715[ebp]
	push	ecx
	mov	edx, DWORD PTR tv79[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv79[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pLog$[ebp], eax

; 5881 : 
; 5882 : 	CvString strLog, strTemp;

	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 5883 : 
; 5884 : 	CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 5885 : 	strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T259733[ebp], eax
	cmp	DWORD PTR $T259733[ebp], 0
	je	SHORT $LN27@LogPatrolM
	mov	ecx, DWORD PTR $T259733[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN28@LogPatrolM
$LN27@LogPatrolM:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN28@LogPatrolM:

; 5886 : 	strLog += strPlayerName;

	lea	edx, DWORD PTR _strPlayerName$[ebp]
	push	edx
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 5887 : 	strLog += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 5888 : 
; 5889 : 	strTemp.Format("%d,", GC.getGame().getGameTurn()); // turn

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T259737[ebp], eax
	mov	ecx, DWORD PTR $T259737[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	push	OFFSET ??_C@_03DPLIHHLN@?$CFd?0?$AA@
	lea	ecx, DWORD PTR _strTemp$[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 5890 : 	strLog += strTemp;

	lea	edx, DWORD PTR _strTemp$[ebp]
	push	edx
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 5891 : 
; 5892 : 	strTemp.Format("%s (%d),", pPatrolUnit->getUnitInfo().GetDescription(), pPatrolUnit->GetID());

	mov	eax, DWORD PTR _pPatrolUnit$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T259746[ebp], ecx
	mov	ecx, DWORD PTR _pPatrolUnit$[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	DWORD PTR $T259750[ebp], eax
	mov	edx, DWORD PTR $T259746[ebp]
	push	edx
	mov	ecx, DWORD PTR $T259750[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_08GEMFNCOI@?$CFs?5?$CI?$CFd?$CJ?0?$AA@
	lea	eax, DWORD PTR _strTemp$[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5893 : 	strLog += strTemp;

	lea	ecx, DWORD PTR _strTemp$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 5894 : 
; 5895 : 	strLog += strMsg;

	mov	edx, DWORD PTR _strMsg$[ebp]
	push	edx
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 5896 : 	pLog->Msg(strLog);

	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T259754[ebp], eax
	mov	eax, DWORD PTR $T259754[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8

; 5897 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strFileName$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@LogPatrolM:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z$0:
	lea	ecx, DWORD PTR _strFileName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z$1:
	lea	ecx, DWORD PTR _strLog$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z$3:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-160]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z ENDP ; CvHomelandAI::LogPatrolMessage
PUBLIC	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
; Function compile flags: /Odtp
;	COMDAT ?UnitProcessed@CvHomelandAI@@AAEXH@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
_pUnit$ = -4						; size = 4
_iID$ = 8						; size = 4
?UnitProcessed@CvHomelandAI@@AAEXH@Z PROC		; CvHomelandAI::UnitProcessed, COMDAT
; _this$ = ecx

; 5901 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 5902 : 	CvUnit* pUnit;
; 5903 : 
; 5904 : 	m_CurrentTurnUnits.remove(iID);

	lea	eax, DWORD PTR _iID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove

; 5905 : 	pUnit = m_pPlayer->getUnit(iID);

	mov	ecx, DWORD PTR _iID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pUnit$[ebp], eax

; 5906 : 
; 5907 : 	CvAssert(pUnit);
; 5908 : 	if(!pUnit) return;

	cmp	DWORD PTR _pUnit$[ebp], 0
	jne	SHORT $LN1@UnitProces
	jmp	SHORT $LN2@UnitProces
$LN1@UnitProces:

; 5909 : 
; 5910 : 	pUnit->SetTurnProcessed(true);

	push	1
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN2@UnitProces:

; 5911 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?UnitProcessed@CvHomelandAI@@AAEXH@Z ENDP		; CvHomelandAI::UnitProcessed
_TEXT	ENDS
PUBLIC	??_C@_0BJ@LOKIGBFI@builder?5has?5no?5directive?$AA@ ; `string'
PUBLIC	??_C@_0BE@CFAGMCM@Moving?5to?5location?0?$AA@	; `string'
PUBLIC	??_C@_0CB@MJENMAJN@Removing?5feature?5for?5production?0@ ; `string'
PUBLIC	??_C@_0BG@OOJFILAP@Building?5improvement?0?$AA@	; `string'
PUBLIC	??_C@_0BA@OBGAAJNE@Repairing?5route?$AA@	; `string'
PUBLIC	??_C@_0BG@IFGNLKAE@Repairing?5improvement?$AA@	; `string'
PUBLIC	??_C@_0P@HPOKIMG@Removing?5road?0?$AA@		; `string'
PUBLIC	??_C@_0CC@GLOANJEG@Removing?5resource?5for?5production@ ; `string'
PUBLIC	??_C@_0BA@BHADBDHG@Building?5route?0?$AA@	; `string'
PUBLIC	??_C@_0L@MDAAAMJ@Repairing?0?$AA@		; `string'
PUBLIC	??_C@_08EMGNHHGI@On?5plot?0?$AA@		; `string'
PUBLIC	??_C@_0N@BAKDODEG@On?5resource?0?$AA@		; `string'
PUBLIC	__$ArrayPad$
EXTRN	?ReadyToMove@CvUnit@@QBE_NXZ:PROC		; CvUnit::ReadyToMove
EXTRN	?GetHeadMissionData@CvUnit@@QAEPBUMissionData@@XZ:PROC ; CvUnit::GetHeadMissionData
EXTRN	?IsImprovementPillaged@CvPlot@@QBE_NXZ:PROC	; CvPlot::IsImprovementPillaged
EXTRN	?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z:PROC ; CvBuilderTaskingAI::EvaluateBuilder
EXTRN	?GetBuilderTaskingAI@CvPlayer@@QBEPAVCvBuilderTaskingAI@@XZ:PROC ; CvPlayer::GetBuilderTaskingAI
;	COMDAT ??_C@_0BJ@LOKIGBFI@builder?5has?5no?5directive?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BJ@LOKIGBFI@builder?5has?5no?5directive?$AA@ DB 'builder has no di'
	DB	'rective', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CFAGMCM@Moving?5to?5location?0?$AA@
CONST	SEGMENT
??_C@_0BE@CFAGMCM@Moving?5to?5location?0?$AA@ DB 'Moving to location,', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MJENMAJN@Removing?5feature?5for?5production?0@
CONST	SEGMENT
??_C@_0CB@MJENMAJN@Removing?5feature?5for?5production?0@ DB 'Removing fea'
	DB	'ture for production,', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OOJFILAP@Building?5improvement?0?$AA@
CONST	SEGMENT
??_C@_0BG@OOJFILAP@Building?5improvement?0?$AA@ DB 'Building improvement,'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OBGAAJNE@Repairing?5route?$AA@
CONST	SEGMENT
??_C@_0BA@OBGAAJNE@Repairing?5route?$AA@ DB 'Repairing route', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IFGNLKAE@Repairing?5improvement?$AA@
CONST	SEGMENT
??_C@_0BG@IFGNLKAE@Repairing?5improvement?$AA@ DB 'Repairing improvement', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HPOKIMG@Removing?5road?0?$AA@
CONST	SEGMENT
??_C@_0P@HPOKIMG@Removing?5road?0?$AA@ DB 'Removing road,', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GLOANJEG@Removing?5resource?5for?5production@
CONST	SEGMENT
??_C@_0CC@GLOANJEG@Removing?5resource?5for?5production@ DB 'Removing reso'
	DB	'urce for production,', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BHADBDHG@Building?5route?0?$AA@
CONST	SEGMENT
??_C@_0BA@BHADBDHG@Building?5route?0?$AA@ DB 'Building route,', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MDAAAMJ@Repairing?0?$AA@
CONST	SEGMENT
??_C@_0L@MDAAAMJ@Repairing?0?$AA@ DB 'Repairing,', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EMGNHHGI@On?5plot?0?$AA@
CONST	SEGMENT
??_C@_08EMGNHHGI@On?5plot?0?$AA@ DB 'On plot,', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BAKDODEG@On?5resource?0?$AA@
CONST	SEGMENT
??_C@_0N@BAKDODEG@On?5resource?0?$AA@ DB 'On resource,', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$4
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
_TEXT	SEGMENT
tv379 = -340						; size = 4
tv570 = -336						; size = 4
tv209 = -332						; size = 4
tv144 = -328						; size = 4
tv478 = -324						; size = 4
tv463 = -320						; size = 4
tv472 = -316						; size = 4
tv79 = -312						; size = 4
_this$ = -308						; size = 4
$T260135 = -304						; size = 4
$T260123 = -300						; size = 4
$T260114 = -296						; size = 4
$T260089 = -292						; size = 4
$T260085 = -288						; size = 4
$T260076 = -284						; size = 4
$T260072 = -280						; size = 4
$T260054 = -276						; size = 4
$T260042 = -272						; size = 4
$T260033 = -268						; size = 4
$T260024 = -264						; size = 4
$T260023 = -260						; size = 4
$T259990 = -256						; size = 4
$T259977 = -252						; size = 4
$T259973 = -248						; size = 4
$T259966 = -244						; size = 4
$T259962 = -237						; size = 1
$T259958 = -236						; size = 4
$T259954 = -229						; size = 1
_iMapY$259999 = -228					; size = 4
_iMapX$259998 = -224					; size = 4
$T259947 = -220						; size = 4
$T259943 = -216						; size = 4
$T259942 = -212						; size = 4
_strFileName$228522 = -208				; size = 28
_pLog$228523 = -180					; size = 4
_pkMissionData$228514 = -176				; size = 4
_bPushMission$228513 = -169				; size = 1
_strFileName$228473 = -168				; size = 28
_strLog$228475 = -140					; size = 28
_strPlayerName$228477 = -112				; size = 28
_pLog$228474 = -84					; size = 4
_strTemp$228476 = -80					; size = 28
__$ArrayPad$ = -52					; size = 4
_pPlot$228468 = -48					; size = 4
_eMission$228469 = -44					; size = 4
_aDirective$ = -40					; size = 20
_bHasDirective$ = -17					; size = 1
_ciDirectiveSize$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z PROC ; CvHomelandAI::ExecuteWorkerMove, COMDAT
; _this$ = ecx

; 5914 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 328				; 00000148H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5915 : 	const UINT ciDirectiveSize = 1;

	mov	DWORD PTR _ciDirectiveSize$[ebp], 1

; 5916 : 	BuilderDirective aDirective[ ciDirectiveSize ];

	mov	DWORD PTR $T259943[ebp], 1
	lea	eax, DWORD PTR _aDirective$[ebp]
	mov	DWORD PTR $T259942[ebp], eax
$LN45@ExecuteWor@3:
	mov	ecx, DWORD PTR $T259943[ebp]
	sub	ecx, 1
	mov	DWORD PTR $T259943[ebp], ecx
	js	SHORT $LN46@ExecuteWor@3
	mov	edx, DWORD PTR $T259942[ebp]
	mov	DWORD PTR [edx], 6
	mov	eax, DWORD PTR $T259942[ebp]
	mov	DWORD PTR [eax+4], -1
	mov	ecx, DWORD PTR $T259942[ebp]
	mov	DWORD PTR [ecx+8], -1
	or	edx, -1
	mov	eax, DWORD PTR $T259942[ebp]
	mov	WORD PTR [eax+12], dx
	or	ecx, -1
	mov	edx, DWORD PTR $T259942[ebp]
	mov	WORD PTR [edx+14], cx
	or	eax, -1
	mov	ecx, DWORD PTR $T259942[ebp]
	mov	WORD PTR [ecx+16], ax
	mov	edx, DWORD PTR $T259942[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T259942[ebp], edx
	jmp	SHORT $LN45@ExecuteWor@3
$LN46@ExecuteWor@3:

; 5917 : 
; 5918 : 	// evaluator
; 5919 : 	bool bHasDirective = m_pPlayer->GetBuilderTaskingAI()->EvaluateBuilder(pUnit, aDirective, ciDirectiveSize);

	push	0
	push	0
	push	1
	lea	eax, DWORD PTR _aDirective$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetBuilderTaskingAI@CvPlayer@@QBEPAVCvBuilderTaskingAI@@XZ ; CvPlayer::GetBuilderTaskingAI
	mov	ecx, eax
	call	?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z ; CvBuilderTaskingAI::EvaluateBuilder
	mov	BYTE PTR _bHasDirective$[ebp], al

; 5920 : 	if(bHasDirective)

	movzx	eax, BYTE PTR _bHasDirective$[ebp]
	test	eax, eax
	je	$LN36@ExecuteWor@3

; 5921 : 	{
; 5922 : 		switch(aDirective[0].m_eDirective)

	mov	ecx, DWORD PTR _aDirective$[ebp]
	mov	DWORD PTR tv79[ebp], ecx
	cmp	DWORD PTR tv79[ebp], 0
	jl	$LN34@ExecuteWor@3
	cmp	DWORD PTR tv79[ebp], 5
	jle	SHORT $LN33@ExecuteWor@3
	jmp	$LN34@ExecuteWor@3
$LN33@ExecuteWor@3:

; 5923 : 		{
; 5924 : 		case BuilderDirective::BUILD_IMPROVEMENT_ON_RESOURCE:
; 5925 : 		case BuilderDirective::BUILD_IMPROVEMENT:
; 5926 : 		case BuilderDirective::REPAIR:
; 5927 : 		case BuilderDirective::BUILD_ROUTE:
; 5928 : 		case BuilderDirective::CHOP:
; 5929 : 		case BuilderDirective::REMOVE_ROAD:
; 5930 : 		{
; 5931 : 			CvPlot* pPlot = GC.getMap().plot(aDirective[0].m_sX, aDirective[0].m_sY);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T259947[ebp], edx
	movsx	eax, WORD PTR _aDirective$[ebp+14]
	mov	DWORD PTR $T260024[ebp], eax
	movsx	ecx, WORD PTR _aDirective$[ebp+12]
	mov	DWORD PTR $T260023[ebp], ecx
	cmp	DWORD PTR $T260023[ebp], -2147483647	; 80000001H
	je	SHORT $LN52@ExecuteWor@3
	cmp	DWORD PTR $T260024[ebp], -2147483647	; 80000001H
	jne	SHORT $LN53@ExecuteWor@3
$LN52@ExecuteWor@3:
	mov	DWORD PTR _pPlot$228468[ebp], 0
	jmp	$LN54@ExecuteWor@3
$LN53@ExecuteWor@3:
	mov	edx, DWORD PTR $T259947[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T259954[ebp], al
	mov	ecx, DWORD PTR $T259947[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T259958[ebp], edx
	movzx	eax, BYTE PTR $T259954[ebp]
	push	eax
	mov	ecx, DWORD PTR $T259958[ebp]
	push	ecx
	mov	edx, DWORD PTR $T260023[ebp]
	push	edx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapX$259998[ebp], eax
	mov	eax, DWORD PTR $T259947[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T259962[ebp], cl
	mov	edx, DWORD PTR $T259947[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T259966[ebp], eax
	movzx	ecx, BYTE PTR $T259962[ebp]
	push	ecx
	mov	edx, DWORD PTR $T259966[ebp]
	push	edx
	mov	eax, DWORD PTR $T260024[ebp]
	push	eax
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$259999[ebp], eax
	cmp	DWORD PTR _iMapX$259998[ebp], 0
	jl	SHORT $LN68@ExecuteWor@3
	mov	ecx, DWORD PTR $T259947[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T259973[ebp], edx
	mov	eax, DWORD PTR _iMapX$259998[ebp]
	cmp	eax, DWORD PTR $T259973[ebp]
	jge	SHORT $LN68@ExecuteWor@3
	cmp	DWORD PTR _iMapY$259999[ebp], 0
	jl	SHORT $LN68@ExecuteWor@3
	mov	ecx, DWORD PTR $T259947[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T259977[ebp], edx
	mov	eax, DWORD PTR _iMapY$259999[ebp]
	cmp	eax, DWORD PTR $T259977[ebp]
	jge	SHORT $LN68@ExecuteWor@3
	mov	DWORD PTR tv472[ebp], 1
	jmp	SHORT $LN66@ExecuteWor@3
$LN68@ExecuteWor@3:
	mov	DWORD PTR tv472[ebp], 0
$LN66@ExecuteWor@3:
	cmp	DWORD PTR tv472[ebp], 0
	je	SHORT $LN56@ExecuteWor@3
	mov	ecx, DWORD PTR $T259947[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T259990[ebp], edx
	mov	eax, DWORD PTR _iMapY$259999[ebp]
	imul	eax, DWORD PTR $T259990[ebp]
	add	eax, DWORD PTR _iMapX$259998[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T259947[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv463[ebp], eax
	jmp	SHORT $LN57@ExecuteWor@3
$LN56@ExecuteWor@3:
	mov	DWORD PTR tv463[ebp], 0
$LN57@ExecuteWor@3:
	mov	edx, DWORD PTR tv463[ebp]
	mov	DWORD PTR _pPlot$228468[ebp], edx
$LN54@ExecuteWor@3:

; 5932 : 			MissionTypes eMission = NO_MISSION;

	mov	DWORD PTR _eMission$228469[ebp], -1

; 5933 : 			if(pUnit->getX() == aDirective[0].m_sX && pUnit->getY() == aDirective[0].m_sY)

	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T260033[ebp], ecx
	movsx	edx, WORD PTR _aDirective$[ebp+12]
	cmp	DWORD PTR $T260033[ebp], edx
	jne	SHORT $LN32@ExecuteWor@3
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T260042[ebp], ecx
	movsx	edx, WORD PTR _aDirective$[ebp+14]
	cmp	DWORD PTR $T260042[ebp], edx
	jne	SHORT $LN32@ExecuteWor@3

; 5934 : 			{
; 5935 : 				eMission = CvTypes::getMISSION_BUILD();

	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	mov	DWORD PTR _eMission$228469[ebp], eax

; 5936 : 			}
; 5937 : 			else

	jmp	SHORT $LN31@ExecuteWor@3
$LN32@ExecuteWor@3:

; 5938 : 			{
; 5939 : #ifdef AUI_HOMELAND_FIX_EXECUTE_WORKER_MOVE_MOVE_AND_BUILD
; 5940 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), aDirective[0].m_sX, aDirective[0].m_sY, 0, false, false, MISSIONAI_BUILD, pPlot);
; 5941 : 				if (pUnit->canMove())
; 5942 : 				{
; 5943 : 					eMission = CvTypes::getMISSION_BUILD();
; 5944 : 				}
; 5945 : 				else
; 5946 : 				{
; 5947 : 					eMission = CvTypes::getMISSION_MOVE_TO();
; 5948 : 					pUnit->finishMoves();
; 5949 : 					UnitProcessed(pUnit->GetID());
; 5950 : 				}
; 5951 : #else
; 5952 : 				eMission = CvTypes::getMISSION_MOVE_TO();

	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	mov	DWORD PTR _eMission$228469[ebp], eax
$LN31@ExecuteWor@3:

; 5953 : #endif
; 5954 : 			}
; 5955 : 
; 5956 : 			if(GC.getLogging() && GC.GetBuilderAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN30@ExecuteWor@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuilderAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::GetBuilderAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN30@ExecuteWor@3

; 5957 : 			{
; 5958 : 				// Open the log file
; 5959 : 				CvString strFileName = "BuilderTaskingLog.csv";

	mov	edx, OFFSET ??_C@_0BG@IAMEKOEI@BuilderTaskingLog?4csv?$AA@
	test	edx, edx
	je	SHORT $LN88@ExecuteWor@3
	mov	DWORD PTR tv478[ebp], OFFSET ??_C@_0BG@IAMEKOEI@BuilderTaskingLog?4csv?$AA@
	jmp	SHORT $LN89@ExecuteWor@3
$LN88@ExecuteWor@3:
	mov	DWORD PTR tv478[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN89@ExecuteWor@3:
	mov	eax, DWORD PTR tv478[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFileName$228473[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5960 : 				FILogFile* pLog;
; 5961 : 				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv144[ebp], eax
	lea	ecx, DWORD PTR _strFileName$228473[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T260054[ebp], eax
	push	0
	push	1
	mov	ecx, DWORD PTR $T260054[ebp]
	push	ecx
	mov	edx, DWORD PTR tv144[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv144[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pLog$228474[ebp], eax

; 5962 : 
; 5963 : 				// write in data
; 5964 : 				CvString strLog;

	lea	ecx, DWORD PTR _strLog$228475[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 5965 : 				CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$228476[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 5966 : 
; 5967 : 				CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$228477[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 5968 : 				strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T260072[ebp], eax
	cmp	DWORD PTR $T260072[ebp], 0
	je	SHORT $LN103@ExecuteWor@3
	mov	ecx, DWORD PTR $T260072[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strPlayerName$228477[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN104@ExecuteWor@3
$LN103@ExecuteWor@3:
	lea	ecx, DWORD PTR _strPlayerName$228477[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN104@ExecuteWor@3:

; 5969 : 				strLog += strPlayerName;

	lea	edx, DWORD PTR _strPlayerName$228477[ebp]
	push	edx
	lea	ecx, DWORD PTR _strLog$228475[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 5970 : 				strLog += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	lea	ecx, DWORD PTR _strLog$228475[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 5971 : 
; 5972 : 				strTemp.Format("%d,", GC.getGame().getGameTurn()); // turn

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T260076[ebp], eax
	mov	ecx, DWORD PTR $T260076[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	push	OFFSET ??_C@_03DPLIHHLN@?$CFd?0?$AA@
	lea	ecx, DWORD PTR _strTemp$228476[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 5973 : 				strLog += strTemp;

	lea	edx, DWORD PTR _strTemp$228476[ebp]
	push	edx
	lea	ecx, DWORD PTR _strLog$228475[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 5974 : 
; 5975 : 				strTemp.Format("%d,", pUnit->GetID()); // unit id

	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T260085[ebp], ecx
	mov	edx, DWORD PTR $T260085[ebp]
	push	edx
	push	OFFSET ??_C@_03DPLIHHLN@?$CFd?0?$AA@
	lea	eax, DWORD PTR _strTemp$228476[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 5976 : 				strLog += strTemp;

	lea	ecx, DWORD PTR _strTemp$228476[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strLog$228475[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 5977 : 
; 5978 : 				switch(aDirective[0].m_eDirective)

	mov	edx, DWORD PTR _aDirective$[ebp]
	mov	DWORD PTR tv209[ebp], edx
	cmp	DWORD PTR tv209[ebp], 5
	ja	SHORT $LN28@ExecuteWor@3
	mov	eax, DWORD PTR tv209[ebp]
	jmp	DWORD PTR $LN145@ExecuteWor@3[eax*4]
$LN27@ExecuteWor@3:

; 5979 : 				{
; 5980 : 				case BuilderDirective::BUILD_IMPROVEMENT_ON_RESOURCE:
; 5981 : 					strLog += "On resource,";

	push	OFFSET ??_C@_0N@BAKDODEG@On?5resource?0?$AA@
	lea	ecx, DWORD PTR _strLog$228475[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 5982 : 					break;

	jmp	SHORT $LN28@ExecuteWor@3
$LN26@ExecuteWor@3:

; 5983 : 				case BuilderDirective::BUILD_IMPROVEMENT:
; 5984 : 					strLog += "On plot,";

	push	OFFSET ??_C@_08EMGNHHGI@On?5plot?0?$AA@
	lea	ecx, DWORD PTR _strLog$228475[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 5985 : 					break;

	jmp	SHORT $LN28@ExecuteWor@3
$LN25@ExecuteWor@3:

; 5986 : 				case BuilderDirective::REPAIR:
; 5987 : 					strLog += "Repairing,";

	push	OFFSET ??_C@_0L@MDAAAMJ@Repairing?0?$AA@
	lea	ecx, DWORD PTR _strLog$228475[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 5988 : 					break;

	jmp	SHORT $LN28@ExecuteWor@3
$LN24@ExecuteWor@3:

; 5989 : 				case BuilderDirective::BUILD_ROUTE:
; 5990 : 					strLog += "Building route,";

	push	OFFSET ??_C@_0BA@BHADBDHG@Building?5route?0?$AA@
	lea	ecx, DWORD PTR _strLog$228475[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 5991 : 					break;

	jmp	SHORT $LN28@ExecuteWor@3
$LN23@ExecuteWor@3:

; 5992 : 				case BuilderDirective::CHOP:
; 5993 : 					strLog += "Removing resource for production,";

	push	OFFSET ??_C@_0CC@GLOANJEG@Removing?5resource?5for?5production@
	lea	ecx, DWORD PTR _strLog$228475[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 5994 : 					break;

	jmp	SHORT $LN28@ExecuteWor@3
$LN22@ExecuteWor@3:

; 5995 : 				case BuilderDirective::REMOVE_ROAD:
; 5996 : 					strLog += "Removing road,";

	push	OFFSET ??_C@_0P@HPOKIMG@Removing?5road?0?$AA@
	lea	ecx, DWORD PTR _strLog$228475[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN28@ExecuteWor@3:

; 5997 : 					break;
; 5998 : 				}
; 5999 : 
; 6000 : 				if(eMission == CvTypes::getMISSION_BUILD())

	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	cmp	DWORD PTR _eMission$228469[ebp], eax
	jne	$LN21@ExecuteWor@3

; 6001 : 				{
; 6002 : 					if(aDirective[0].m_eDirective == BuilderDirective::REPAIR)

	cmp	DWORD PTR _aDirective$[ebp], 3
	jne	SHORT $LN20@ExecuteWor@3

; 6003 : 					{
; 6004 : 						if(pPlot->IsImprovementPillaged())

	mov	ecx, DWORD PTR _pPlot$228468[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN19@ExecuteWor@3

; 6005 : 						{
; 6006 : 							strLog += "Repairing improvement";

	push	OFFSET ??_C@_0BG@IFGNLKAE@Repairing?5improvement?$AA@
	lea	ecx, DWORD PTR _strLog$228475[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 6007 : 						}
; 6008 : 						else

	jmp	SHORT $LN18@ExecuteWor@3
$LN19@ExecuteWor@3:

; 6009 : 						{
; 6010 : 							strLog += "Repairing route";

	push	OFFSET ??_C@_0BA@OBGAAJNE@Repairing?5route?$AA@
	lea	ecx, DWORD PTR _strLog$228475[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN18@ExecuteWor@3:

; 6011 : 						}

	jmp	SHORT $LN17@ExecuteWor@3
$LN20@ExecuteWor@3:

; 6012 : 					}
; 6013 : 					else if(aDirective[0].m_eDirective == BuilderDirective::BUILD_ROUTE)

	cmp	DWORD PTR _aDirective$[ebp], 2
	jne	SHORT $LN16@ExecuteWor@3

; 6014 : 					{
; 6015 : 						strLog += "Building route,";

	push	OFFSET ??_C@_0BA@BHADBDHG@Building?5route?0?$AA@
	lea	ecx, DWORD PTR _strLog$228475[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	jmp	SHORT $LN17@ExecuteWor@3
$LN16@ExecuteWor@3:

; 6016 : 					}
; 6017 : 					else if(aDirective[0].m_eDirective == BuilderDirective::BUILD_IMPROVEMENT || aDirective[0].m_eDirective == BuilderDirective::BUILD_IMPROVEMENT_ON_RESOURCE)

	cmp	DWORD PTR _aDirective$[ebp], 1
	je	SHORT $LN13@ExecuteWor@3
	cmp	DWORD PTR _aDirective$[ebp], 0
	jne	SHORT $LN14@ExecuteWor@3
$LN13@ExecuteWor@3:

; 6018 : 					{
; 6019 : 						strLog += "Building improvement,";

	push	OFFSET ??_C@_0BG@OOJFILAP@Building?5improvement?0?$AA@
	lea	ecx, DWORD PTR _strLog$228475[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	jmp	SHORT $LN17@ExecuteWor@3
$LN14@ExecuteWor@3:

; 6020 : 					}
; 6021 : 					else if(aDirective[0].m_eDirective == BuilderDirective::CHOP)

	cmp	DWORD PTR _aDirective$[ebp], 4
	jne	SHORT $LN11@ExecuteWor@3

; 6022 : 					{
; 6023 : 						strLog += "Removing feature for production,";

	push	OFFSET ??_C@_0CB@MJENMAJN@Removing?5feature?5for?5production?0@
	lea	ecx, DWORD PTR _strLog$228475[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 6024 : 					}
; 6025 : 					else

	jmp	SHORT $LN17@ExecuteWor@3
$LN11@ExecuteWor@3:

; 6026 : 					{
; 6027 : 						strLog += "Removing road,";

	push	OFFSET ??_C@_0P@HPOKIMG@Removing?5road?0?$AA@
	lea	ecx, DWORD PTR _strLog$228475[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN17@ExecuteWor@3:

; 6028 : 					}
; 6029 : 				}
; 6030 : 				else

	jmp	SHORT $LN9@ExecuteWor@3
$LN21@ExecuteWor@3:

; 6031 : 				{
; 6032 : 					strLog += "Moving to location,";

	push	OFFSET ??_C@_0BE@CFAGMCM@Moving?5to?5location?0?$AA@
	lea	ecx, DWORD PTR _strLog$228475[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN9@ExecuteWor@3:

; 6033 : 				}
; 6034 : 
; 6035 : 				pLog->Msg(strLog);

	lea	ecx, DWORD PTR _strLog$228475[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T260089[ebp], eax
	mov	edx, DWORD PTR $T260089[ebp]
	push	edx
	mov	eax, DWORD PTR _pLog$228474[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pLog$228474[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 6036 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strPlayerName$228477[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$228476[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLog$228475[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strFileName$228473[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN30@ExecuteWor@3:

; 6037 : 
; 6038 : 			if(eMission == CvTypes::getMISSION_BUILD())

	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	cmp	DWORD PTR _eMission$228469[ebp], eax
	jne	$LN8@ExecuteWor@3

; 6039 : 			{
; 6040 : 				// check to see if we already have this mission as the unit's head mission
; 6041 : 				bool bPushMission = true;

	mov	BYTE PTR _bPushMission$228513[ebp], 1

; 6042 : 				const MissionData* pkMissionData = pUnit->GetHeadMissionData();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?GetHeadMissionData@CvUnit@@QAEPBUMissionData@@XZ ; CvUnit::GetHeadMissionData
	mov	DWORD PTR _pkMissionData$228514[ebp], eax

; 6043 : 				if(pkMissionData != NULL)

	cmp	DWORD PTR _pkMissionData$228514[ebp], 0
	je	SHORT $LN7@ExecuteWor@3

; 6044 : 				{
; 6045 : 					if(pkMissionData->eMissionType == eMission && pkMissionData->iData1 == aDirective[0].m_eBuild)

	mov	ecx, DWORD PTR _pkMissionData$228514[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _eMission$228469[ebp]
	jne	SHORT $LN7@ExecuteWor@3
	mov	eax, DWORD PTR _pkMissionData$228514[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _aDirective$[ebp+4]
	jne	SHORT $LN7@ExecuteWor@3

; 6046 : 					{
; 6047 : 						bPushMission = false;

	mov	BYTE PTR _bPushMission$228513[ebp], 0
$LN7@ExecuteWor@3:

; 6048 : 					}
; 6049 : 				}
; 6050 : 
; 6051 : 				if(bPushMission)

	movzx	edx, BYTE PTR _bPushMission$228513[ebp]
	test	edx, edx
	je	SHORT $LN5@ExecuteWor@3

; 6052 : 				{
; 6053 : 					pUnit->PushMission(CvTypes::getMISSION_BUILD(), aDirective[0].m_eBuild, -1, 0, (pUnit->GetLengthMissionQueue() > 0), false, MISSIONAI_BUILD, pPlot);

	push	0
	mov	eax, DWORD PTR _pPlot$228468[ebp]
	push	eax
	push	18					; 00000012H
	push	0
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?GetLengthMissionQueue@CvUnit@@QBEHXZ	; CvUnit::GetLengthMissionQueue
	test	eax, eax
	setg	cl
	movzx	edx, cl
	push	edx
	push	0
	push	-1
	mov	eax, DWORD PTR _aDirective$[ebp+4]
	push	eax
	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission
$LN5@ExecuteWor@3:

; 6054 : 				}
; 6055 : 
; 6056 : 				CvAssertMsg(!pUnit->ReadyToMove(), "Worker did not do their mission this turn. Could cause game to hang.");
; 6057 : 				if(pUnit->ReadyToMove())

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?ReadyToMove@CvUnit@@QBE_NXZ		; CvUnit::ReadyToMove
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN128@ExecuteWor@3

; 6058 : 				{
; 6059 : 					pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 6060 : 				}
; 6061 : 				UnitProcessed(pUnit->GetID());

$LN128@ExecuteWor@3:
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T260114[ebp], eax
	mov	ecx, DWORD PTR $T260114[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 6062 : 			}
; 6063 : #ifndef AUI_HOMELAND_FIX_EXECUTE_WORKER_MOVE_MOVE_AND_BUILD
; 6064 : 			else

	jmp	SHORT $LN3@ExecuteWor@3
$LN8@ExecuteWor@3:

; 6065 : 			{
; 6066 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), aDirective[0].m_sX, aDirective[0].m_sY, 0, false, false, MISSIONAI_BUILD, pPlot);

	push	0
	mov	edx, DWORD PTR _pPlot$228468[ebp]
	push	edx
	push	18					; 00000012H
	push	0
	push	0
	push	0
	movsx	eax, WORD PTR _aDirective$[ebp+14]
	push	eax
	movsx	ecx, WORD PTR _aDirective$[ebp+12]
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 6067 : 				pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 6068 : 				UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T260123[ebp], eax
	mov	ecx, DWORD PTR $T260123[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed
$LN3@ExecuteWor@3:

; 6069 : 			}
; 6070 : #endif
; 6071 : 
; 6072 : 			return true;

	mov	al, 1
	jmp	$LN37@ExecuteWor@3
$LN34@ExecuteWor@3:

; 6073 : 		}
; 6074 : 		break;
; 6075 : 		}
; 6076 : 	}
; 6077 : 	else

	jmp	$LN2@ExecuteWor@3
$LN36@ExecuteWor@3:

; 6078 : 	{
; 6079 : 		if(GC.getLogging() && GC.GetBuilderAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN2@ExecuteWor@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuilderAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::GetBuilderAILogging
	movzx	eax, al
	test	eax, eax
	je	$LN2@ExecuteWor@3

; 6080 : 		{
; 6081 : 			CvString strFileName = "BuilderTaskingLog.csv";

	mov	ecx, OFFSET ??_C@_0BG@IAMEKOEI@BuilderTaskingLog?4csv?$AA@
	test	ecx, ecx
	je	SHORT $LN136@ExecuteWor@3
	mov	DWORD PTR tv570[ebp], OFFSET ??_C@_0BG@IAMEKOEI@BuilderTaskingLog?4csv?$AA@
	jmp	SHORT $LN137@ExecuteWor@3
$LN136@ExecuteWor@3:
	mov	DWORD PTR tv570[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN137@ExecuteWor@3:
	mov	edx, DWORD PTR tv570[ebp]
	push	edx
	lea	ecx, DWORD PTR _strFileName$228522[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 6082 : 			FILogFile* pLog;
; 6083 : 			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv379[ebp], eax
	lea	ecx, DWORD PTR _strFileName$228522[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T260135[ebp], eax
	push	0
	push	1
	mov	eax, DWORD PTR $T260135[ebp]
	push	eax
	mov	ecx, DWORD PTR tv379[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv379[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$228523[ebp], eax

; 6084 : 			pLog->Msg("builder has no directive");

	push	OFFSET ??_C@_0BJ@LOKIGBFI@builder?5has?5no?5directive?$AA@
	mov	ecx, DWORD PTR _pLog$228523[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$228523[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8

; 6085 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strFileName$228522[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@ExecuteWor@3:

; 6086 : 	}
; 6087 : 
; 6088 : 	return false;

	xor	al, al
$LN37@ExecuteWor@3:

; 6089 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN145@ExecuteWor@3:
	DD	$LN27@ExecuteWor@3
	DD	$LN26@ExecuteWor@3
	DD	$LN24@ExecuteWor@3
	DD	$LN25@ExecuteWor@3
	DD	$LN23@ExecuteWor@3
	DD	$LN22@ExecuteWor@3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$0:
	lea	ecx, DWORD PTR _strFileName$228473[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$1:
	lea	ecx, DWORD PTR _strLog$228475[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$228476[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$3:
	lea	ecx, DWORD PTR _strPlayerName$228477[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$4:
	lea	ecx, DWORD PTR _strFileName$228522[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-332]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ENDP ; CvHomelandAI::ExecuteWorkerMove
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	js	SHORT $LN3@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $LN2@vector
$LN3@vector:
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_C@_0CO@HEDNHFBG@?$CFs?5blasted?5culture?5with?5unit?5at?0@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getMISSION_GIVE_POLICIES@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_GIVE_POLICIES
EXTRN	?canGivePolicies@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC ; CvUnit::canGivePolicies
;	COMDAT ??_C@_0CO@HEDNHFBG@?$CFs?5blasted?5culture?5with?5unit?5at?0@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CO@HEDNHFBG@?$CFs?5blasted?5culture?5with?5unit?5at?0@ DB '%s blas'
	DB	'ted culture with unit at, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$1
__ehfuncinfo$?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -96						; size = 4
$T260198 = -92						; size = 4
$T260189 = -88						; size = 4
$T260180 = -84						; size = 4
$T260174 = -80						; size = 4
$T260162 = -76						; size = 4
_strLogString$228542 = -72				; size = 28
_strTemp$228543 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z PROC ; CvHomelandAI::ExecuteCultureBlast, COMDAT
; _this$ = ecx

; 6092 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 6093 : 	if (pUnit->canGivePolicies(pUnit->plot()))

	push	0
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canGivePolicies@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canGivePolicies
	movzx	eax, al
	test	eax, eax
	je	$LN3@ExecuteCul

; 6094 : 	{
; 6095 : 		pUnit->PushMission(CvTypes::getMISSION_GIVE_POLICIES());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_GIVE_POLICIES@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GIVE_POLICIES
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 6096 : 		UnitProcessed(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T260162[ebp], edx
	mov	eax, DWORD PTR $T260162[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 6097 : 
; 6098 : 		if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@ExecuteCul
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN2@ExecuteCul

; 6099 : 		{
; 6100 : 			CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228542[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 6101 : 			CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$228543[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 6102 : 			strTemp = pUnit->getUnitInfo().GetDescription();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	DWORD PTR $T260174[ebp], eax
	mov	ecx, DWORD PTR $T260174[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T260180[ebp], eax
	cmp	DWORD PTR $T260180[ebp], 0
	je	SHORT $LN21@ExecuteCul
	mov	eax, DWORD PTR $T260180[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTemp$228543[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN26@ExecuteCul
$LN21@ExecuteCul:
	lea	ecx, DWORD PTR _strTemp$228543[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 6103 : 			strLogString.Format("%s blasted culture with unit at, X: %d, Y: %d", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

$LN26@ExecuteCul:
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T260189[ebp], edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T260198[ebp], ecx
	mov	edx, DWORD PTR $T260189[ebp]
	push	edx
	mov	eax, DWORD PTR $T260198[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTemp$228543[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CO@HEDNHFBG@?$CFs?5blasted?5culture?5with?5unit?5at?0@
	lea	ecx, DWORD PTR _strLogString$228542[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 6104 : 			LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$228542[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 6105 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strTemp$228543[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$228542[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@ExecuteCul:

; 6106 : 	}
; 6107 : 	else

	jmp	SHORT $LN1@ExecuteCul
$LN3@ExecuteCul:

; 6108 : 	{
; 6109 : 		MoveCivilianToSafety(pUnit);

	push	0
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
$LN1@ExecuteCul:

; 6110 : 	}
; 6111 : 
; 6112 : 	return true;

	mov	al, 1

; 6113 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$0:
	lea	ecx, DWORD PTR _strLogString$228542[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$1:
	lea	ecx, DWORD PTR _strTemp$228543[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ENDP ; CvHomelandAI::ExecuteCultureBlast
PUBLIC	??_C@_0DB@GDIBJMDE@?$CFs?5started?5golden?5age?5with?5unit?5@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getMISSION_GOLDEN_AGE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_GOLDEN_AGE
EXTRN	?canGoldenAge@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC	; CvUnit::canGoldenAge
;	COMDAT ??_C@_0DB@GDIBJMDE@?$CFs?5started?5golden?5age?5with?5unit?5@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0DB@GDIBJMDE@?$CFs?5started?5golden?5age?5with?5unit?5@ DB '%s star'
	DB	'ted golden age with unit at, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$1
__ehfuncinfo$?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -96						; size = 4
$T260265 = -92						; size = 4
$T260256 = -88						; size = 4
$T260247 = -84						; size = 4
$T260241 = -80						; size = 4
$T260229 = -76						; size = 4
_strLogString$228552 = -72				; size = 28
_strTemp$228553 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z PROC ; CvHomelandAI::ExecuteGoldenAgeMove, COMDAT
; _this$ = ecx

; 6116 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 6117 : 	if (pUnit->canGoldenAge(pUnit->plot()))

	push	0
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canGoldenAge@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canGoldenAge
	movzx	eax, al
	test	eax, eax
	je	$LN3@ExecuteGol

; 6118 : 	{
; 6119 : 		pUnit->PushMission(CvTypes::getMISSION_GOLDEN_AGE());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_GOLDEN_AGE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GOLDEN_AGE
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 6120 : 		UnitProcessed(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T260229[ebp], edx
	mov	eax, DWORD PTR $T260229[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 6121 : 
; 6122 : 		if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@ExecuteGol
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN2@ExecuteGol

; 6123 : 		{
; 6124 : 			CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228552[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 6125 : 			CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$228553[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 6126 : 			strTemp = pUnit->getUnitInfo().GetDescription();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	DWORD PTR $T260241[ebp], eax
	mov	ecx, DWORD PTR $T260241[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T260247[ebp], eax
	cmp	DWORD PTR $T260247[ebp], 0
	je	SHORT $LN21@ExecuteGol
	mov	eax, DWORD PTR $T260247[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTemp$228553[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN26@ExecuteGol
$LN21@ExecuteGol:
	lea	ecx, DWORD PTR _strTemp$228553[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 6127 : 			strLogString.Format("%s started golden age with unit at, X: %d, Y: %d", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

$LN26@ExecuteGol:
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T260256[ebp], edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T260265[ebp], ecx
	mov	edx, DWORD PTR $T260256[ebp]
	push	edx
	mov	eax, DWORD PTR $T260265[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTemp$228553[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0DB@GDIBJMDE@?$CFs?5started?5golden?5age?5with?5unit?5@
	lea	ecx, DWORD PTR _strLogString$228552[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 6128 : 			LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$228552[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 6129 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strTemp$228553[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$228552[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@ExecuteGol:

; 6130 : 	}
; 6131 : 	else

	jmp	SHORT $LN1@ExecuteGol
$LN3@ExecuteGol:

; 6132 : 	{
; 6133 : 		MoveCivilianToSafety(pUnit);

	push	0
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
$LN1@ExecuteGol:

; 6134 : 	}
; 6135 : 
; 6136 : 	return true;

	mov	al, 1

; 6137 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$0:
	lea	ecx, DWORD PTR _strLogString$228552[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$1:
	lea	ecx, DWORD PTR _strTemp$228553[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ENDP ; CvHomelandAI::ExecuteGoldenAgeMove
EXTRN	?CanEverEmbark@CvUnit@@QBE_NXZ:PROC		; CvUnit::CanEverEmbark
EXTRN	?area@CvUnit@@QBEPAVCvArea@@XZ:PROC		; CvUnit::area
EXTRN	?area@CvPlot@@QBEPAVCvArea@@XZ:PROC		; CvPlot::area
; Function compile flags: /Odtp
;	COMDAT ?IsValidExplorerEndTurnPlot@CvHomelandAI@@ABE_NPBVCvUnit@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T260321 = -28						; size = 4
$T260312 = -24						; size = 4
$T260295 = -16						; size = 4
_uiOffset$260293 = -12					; size = 4
_eDomain$ = -8						; size = 4
_pCity$ = -4						; size = 4
_pUnit$ = 8						; size = 4
_pPlot$ = 12						; size = 4
?IsValidExplorerEndTurnPlot@CvHomelandAI@@ABE_NPBVCvUnit@@PAVCvPlot@@@Z PROC ; CvHomelandAI::IsValidExplorerEndTurnPlot, COMDAT
; _this$ = ecx

; 6140 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 6141 : 	if(pUnit->atPlot(*pPlot))

	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z	; CvUnit::atPlot
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@IsValidExp

; 6142 : 	{
; 6143 : 		return false;

	xor	al, al
	jmp	$LN9@IsValidExp
$LN8@IsValidExp:

; 6144 : 	}
; 6145 : 
; 6146 : 	if(!pPlot->isRevealed(pUnit->getTeam()))

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	DWORD PTR $T260295[ebp], eax
	mov	edx, DWORD PTR $T260295[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$260293[ebp], edx
	mov	eax, DWORD PTR _uiOffset$260293[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR $T260295[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$260293[ebp]
	mov	ecx, DWORD PTR _pPlot$[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN7@IsValidExp

; 6147 : 	{
; 6148 : 		return false;

	xor	al, al
	jmp	$LN9@IsValidExp
$LN7@IsValidExp:

; 6149 : 	}
; 6150 : 
; 6151 : 	DomainTypes eDomain = pUnit->getDomainType();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	mov	DWORD PTR _eDomain$[ebp], eax

; 6152 : 
; 6153 : 	if(pPlot->area() != pUnit->area())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	esi, eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?area@CvUnit@@QBEPAVCvArea@@XZ		; CvUnit::area
	cmp	esi, eax
	je	SHORT $LN6@IsValidExp

; 6154 : 	{
; 6155 : 		if(!pUnit->CanEverEmbark())

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN6@IsValidExp

; 6156 : 		{
; 6157 : 			if(!(eDomain == DOMAIN_SEA && pPlot->isWater()))

	cmp	DWORD PTR _eDomain$[ebp], 0
	jne	SHORT $LN3@IsValidExp
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN6@IsValidExp
$LN3@IsValidExp:

; 6158 : 			{
; 6159 : 				return false;

	xor	al, al
	jmp	SHORT $LN9@IsValidExp
$LN6@IsValidExp:

; 6160 : 			}
; 6161 : 		}
; 6162 : 	}
; 6163 : 
; 6164 : 	// don't let the auto-explore end it's turn in a city
; 6165 : 	CvCity* pCity = pPlot->getPlotCity();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$[ebp], eax

; 6166 : 	if(pCity && pCity->getOwner() != pUnit->getOwner())

	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN2@IsValidExp
	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T260312[ebp], ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T260321[ebp], eax
	mov	ecx, DWORD PTR $T260312[ebp]
	cmp	ecx, DWORD PTR $T260321[ebp]
	je	SHORT $LN2@IsValidExp

; 6167 : 	{
; 6168 : 		return false;

	xor	al, al
	jmp	SHORT $LN9@IsValidExp
$LN2@IsValidExp:

; 6169 : 	}
; 6170 : 
; 6171 : 	if(!pUnit->canMoveInto(*pPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE))

	push	128					; 00000080H
	mov	edx, DWORD PTR _pPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canMoveInto@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveInto
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@IsValidExp

; 6172 : 	{
; 6173 : 		return false;

	xor	al, al
	jmp	SHORT $LN9@IsValidExp
$LN1@IsValidExp:

; 6174 : 	}
; 6175 : 
; 6176 : 	return true;

	mov	al, 1
$LN9@IsValidExp:

; 6177 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?IsValidExplorerEndTurnPlot@CvHomelandAI@@ABE_NPBVCvUnit@@PAVCvPlot@@@Z ENDP ; CvHomelandAI::IsValidExplorerEndTurnPlot
_TEXT	ENDS
PUBLIC	??_C@_0EL@FALMLJJO@UnitID?3?5?$CFd?5Moving?5to?5script?5expl@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z ; CvHomelandAI::ExecuteSpecialExploreMove
;	COMDAT ??_C@_0EL@FALMLJJO@UnitID?3?5?$CFd?5Moving?5to?5script?5expl@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fautovariable.h
CONST	SEGMENT
??_C@_0EL@FALMLJJO@UnitID?3?5?$CFd?5Moving?5to?5script?5expl@ DB 'UnitID:'
	DB	' %d Moving to script explore target, X: %d, Y: %d, from X: %d'
	DB	' Y: %d', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$0
__ehfuncinfo$?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -104						; size = 4
$T260411 = -100						; size = 4
$T260402 = -96						; size = 4
$T260398 = -92						; size = 4
$T260390 = -88						; size = 4
$T260381 = -84						; size = 4
$T260377 = -80						; size = 4
$T260373 = -76						; size = 4
$T260364 = -72						; size = 4
$T260351 = -68						; size = 4
$T260342 = -64						; size = 4
$T260333 = -60						; size = 4
$T260329 = -56						; size = 4
_strLogString$228581 = -52				; size = 28
__$ArrayPad$ = -24					; size = 4
_pPlot$228578 = -20					; size = 4
_bCanFindPath$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
_pTargetPlot$ = 12					; size = 4
?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z PROC ; CvHomelandAI::ExecuteSpecialExploreMove, COMDAT
; _this$ = ecx

; 6181 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 6182 : 	bool bCanFindPath = GC.getPathFinder().GenerateUnitPath(pUnit, pUnit->getX(), pUnit->getY(), pTargetPlot->getX(), pTargetPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER /*iFlags*/, true/*bReuse*/);

	mov	eax, DWORD PTR _pTargetPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T260329[ebp], ecx
	mov	edx, DWORD PTR _pTargetPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T260333[ebp], eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T260342[ebp], edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T260351[ebp], ecx
	push	1
	push	138					; 0000008aH
	mov	edx, DWORD PTR $T260329[ebp]
	push	edx
	mov	eax, DWORD PTR $T260333[ebp]
	push	eax
	mov	ecx, DWORD PTR $T260342[ebp]
	push	ecx
	mov	edx, DWORD PTR $T260351[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	ecx, eax
	call	?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z ; CvTwoLayerPathFinder::GenerateUnitPath
	mov	BYTE PTR _bCanFindPath$[ebp], al

; 6183 : 	if(bCanFindPath)

	movzx	ecx, BYTE PTR _bCanFindPath$[ebp]
	test	ecx, ecx
	je	$LN3@ExecuteSpe

; 6184 : 	{
; 6185 : 		CvPlot* pPlot = GC.getPathFinder().GetPathEndTurnPlot();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	ecx, eax
	call	?GetPathEndTurnPlot@CvTwoLayerPathFinder@@QBEPAVCvPlot@@XZ ; CvTwoLayerPathFinder::GetPathEndTurnPlot
	mov	DWORD PTR _pPlot$228578[ebp], eax

; 6186 : 		if(pPlot)

	cmp	DWORD PTR _pPlot$228578[ebp], 0
	je	$LN3@ExecuteSpe

; 6187 : 		{
; 6188 : 			CvAssert(!pUnit->atPlot(*pPlot));
; 6189 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN1@ExecuteSpe
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@ExecuteSpe

; 6190 : 			{
; 6191 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228581[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 6192 : 				strLogString.Format("UnitID: %d Moving to script explore target, X: %d, Y: %d, from X: %d Y: %d", pUnit->GetID(), pPlot->getX(), pPlot->getY(), pUnit->getX(), pUnit->getY());

	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T260364[ebp], edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T260373[ebp], ecx
	mov	edx, DWORD PTR _pPlot$228578[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T260377[ebp], eax
	mov	ecx, DWORD PTR _pPlot$228578[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T260381[ebp], edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T260390[ebp], ecx
	mov	edx, DWORD PTR $T260364[ebp]
	push	edx
	mov	eax, DWORD PTR $T260373[ebp]
	push	eax
	mov	ecx, DWORD PTR $T260377[ebp]
	push	ecx
	mov	edx, DWORD PTR $T260381[ebp]
	push	edx
	mov	eax, DWORD PTR $T260390[ebp]
	push	eax
	push	OFFSET ??_C@_0EL@FALMLJJO@UnitID?3?5?$CFd?5Moving?5to?5script?5expl@
	lea	ecx, DWORD PTR _strLogString$228581[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH

; 6193 : 				LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$228581[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 6194 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$228581[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteSpe:

; 6195 : 			pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pPlot->getX(), pPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER, false, false, MISSIONAI_EXPLORE, pPlot);

	mov	eax, DWORD PTR _pPlot$228578[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T260398[ebp], ecx
	mov	edx, DWORD PTR _pPlot$228578[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T260402[ebp], eax
	push	0
	mov	ecx, DWORD PTR _pPlot$228578[ebp]
	push	ecx
	push	14					; 0000000eH
	push	0
	push	0
	push	138					; 0000008aH
	mov	edx, DWORD PTR $T260398[ebp]
	push	edx
	mov	eax, DWORD PTR $T260402[ebp]
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 6196 : 			pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 6197 : 			UnitProcessed(pUnit->GetID());

	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T260411[ebp], edx
	mov	eax, DWORD PTR $T260411[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 6198 : 
; 6199 : 			return true;

	mov	al, 1
	jmp	SHORT $LN4@ExecuteSpe
$LN3@ExecuteSpe:

; 6200 : 		}
; 6201 : 	}
; 6202 : 	return false;

	xor	al, al
$LN4@ExecuteSpe:

; 6203 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _strLogString$228581[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z ENDP ; CvHomelandAI::ExecuteSpecialExploreMove
PUBLIC	??_C@_0BI@KNEFOAGL@PlayerHomelandAILog?4csv?$AA@ ; `string'
PUBLIC	??_C@_04EBGNMJBD@?4csv?$AA@			; `string'
PUBLIC	??_C@_0BF@GJGMEKDH@PlayerHomelandAILog_?$AA@	; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
;	COMDAT ??_C@_0BI@KNEFOAGL@PlayerHomelandAILog?4csv?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BI@KNEFOAGL@PlayerHomelandAILog?4csv?$AA@ DB 'PlayerHomelandAILog.'
	DB	'csv', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04EBGNMJBD@?4csv?$AA@
CONST	SEGMENT
??_C@_04EBGNMJBD@?4csv?$AA@ DB '.csv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GJGMEKDH@PlayerHomelandAILog_?$AA@
CONST	SEGMENT
??_C@_0BF@GJGMEKDH@PlayerHomelandAILog_?$AA@ DB 'PlayerHomelandAILog_', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z$2
__ehfuncinfo$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z
_TEXT	SEGMENT
tv142 = -124						; size = 4
tv129 = -120						; size = 4
tv169 = -116						; size = 4
_this$ = -112						; size = 4
$T260436 = -108						; size = 4
$T260427 = -104						; size = 4
$T260422 = -100						; size = 28
$T260421 = -72						; size = 28
_strLogName$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_playerName$ = 12					; size = 4
?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z PROC ; CvHomelandAI::GetLogFileName, COMDAT
; _this$ = ecx

; 6207 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T260427[ebp], 0

; 6208 : 	CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 6209 : 
; 6210 : 	// Open the log file
; 6211 : 	if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@GetLogFile

; 6212 : 	{
; 6213 : 		strLogName = "PlayerHomelandAILog_" + playerName + ".csv";

	mov	ecx, DWORD PTR _playerName$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BF@GJGMEKDH@PlayerHomelandAILog_?$AA@
	lea	edx, DWORD PTR $T260421[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv169[ebp], eax
	mov	eax, DWORD PTR tv169[ebp]
	mov	DWORD PTR tv129[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	OFFSET ??_C@_04EBGNMJBD@?4csv?$AA@
	mov	ecx, DWORD PTR tv129[ebp]
	push	ecx
	lea	edx, DWORD PTR $T260422[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv142[ebp], eax
	mov	eax, DWORD PTR tv142[ebp]
	mov	DWORD PTR $T260436[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T260436[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T260422[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T260421[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6214 : 	}
; 6215 : 	else

	jmp	SHORT $LN1@GetLogFile
$LN2@GetLogFile:

; 6216 : 	{
; 6217 : 		strLogName = "PlayerHomelandAILog.csv";

	mov	ecx, OFFSET ??_C@_0BI@KNEFOAGL@PlayerHomelandAILog?4csv?$AA@
	test	ecx, ecx
	je	SHORT $LN16@GetLogFile
	push	OFFSET ??_C@_0BI@KNEFOAGL@PlayerHomelandAILog?4csv?$AA@
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN1@GetLogFile
$LN16@GetLogFile:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN1@GetLogFile:

; 6218 : 	}
; 6219 : 
; 6220 : 	return strLogName;

	lea	edx, DWORD PTR _strLogName$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T260427[ebp]
	or	eax, 1
	mov	DWORD PTR $T260427[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 6221 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z$0:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z$1:
	lea	ecx, DWORD PTR $T260421[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z$2:
	lea	ecx, DWORD PTR $T260422[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z$3:
	mov	eax, DWORD PTR $T260427[ebp]
	and	eax, 1
	je	$LN9@GetLogFile
	and	DWORD PTR $T260427[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN9@GetLogFile:
	ret	0
__ehhandler$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z ENDP ; CvHomelandAI::GetLogFileName
; Function compile flags: /Odtp
;	COMDAT ?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T260476 = -8						; size = 4
_i$260472 = -4						; size = 4
?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::ClearCurrentMoveUnits, COMDAT
; _this$ = ecx

; 6225 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 6226 : 	m_CurrentMoveUnits.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T260476[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN9@ClearCurre
	mov	DWORD PTR _i$260472[ebp], 0
	jmp	SHORT $LN7@ClearCurre
$LN6@ClearCurre:
	mov	edx, DWORD PTR _i$260472[ebp]
	add	edx, 1
	mov	DWORD PTR _i$260472[ebp], edx
$LN7@ClearCurre:
	mov	eax, DWORD PTR $T260476[ebp]
	mov	ecx, DWORD PTR _i$260472[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN9@ClearCurre
	jmp	SHORT $LN6@ClearCurre
$LN9@ClearCurre:
	mov	edx, DWORD PTR $T260476[ebp]
	mov	DWORD PTR [edx+4], 0

; 6227 : 	m_CurrentBestMoveUnit = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2396], 0

; 6228 : 	m_iCurrentBestMoveUnitTurns = MAX_INT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2400], 2147483647	; 7fffffffH

; 6229 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::ClearCurrentMoveUnits
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ClearCurrentMoveHighPriorityUnits@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T260497 = -8						; size = 4
_i$260493 = -4						; size = 4
?ClearCurrentMoveHighPriorityUnits@CvHomelandAI@@AAEXXZ PROC ; CvHomelandAI::ClearCurrentMoveHighPriorityUnits, COMDAT
; _this$ = ecx

; 6233 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 6234 : 	m_CurrentMoveHighPriorityUnits.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1056				; 00000420H
	mov	DWORD PTR $T260497[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN9@ClearCurre@2
	mov	DWORD PTR _i$260493[ebp], 0
	jmp	SHORT $LN7@ClearCurre@2
$LN6@ClearCurre@2:
	mov	edx, DWORD PTR _i$260493[ebp]
	add	edx, 1
	mov	DWORD PTR _i$260493[ebp], edx
$LN7@ClearCurre@2:
	mov	eax, DWORD PTR $T260497[ebp]
	mov	ecx, DWORD PTR _i$260493[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN9@ClearCurre@2
	jmp	SHORT $LN6@ClearCurre@2
$LN9@ClearCurre@2:
	mov	edx, DWORD PTR $T260497[ebp]
	mov	DWORD PTR [edx+4], 0

; 6235 : 	m_CurrentBestMoveHighPriorityUnit = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2404], 0

; 6236 : 	m_iCurrentBestMoveHighPriorityUnitTurns = MAX_INT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2408], 2147483647	; 7fffffffH

; 6237 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearCurrentMoveHighPriorityUnits@CvHomelandAI@@AAEXXZ ENDP ; CvHomelandAI::ClearCurrentMoveHighPriorityUnits
_TEXT	ENDS
PUBLIC	?CvHomelandUnitAuxIntSort@HomelandAIHelpers@@YA_NVCvHomelandUnit@@0@Z ; HomelandAIHelpers::CvHomelandUnitAuxIntSort
; Function compile flags: /Odtp
;	COMDAT ?CvHomelandUnitAuxIntSort@HomelandAIHelpers@@YA_NVCvHomelandUnit@@0@Z
_TEXT	SEGMENT
$T260507 = -8						; size = 4
$T260503 = -4						; size = 4
_obj1$ = 8						; size = 16
_obj2$ = 24						; size = 16
?CvHomelandUnitAuxIntSort@HomelandAIHelpers@@YA_NVCvHomelandUnit@@0@Z PROC ; HomelandAIHelpers::CvHomelandUnitAuxIntSort, COMDAT

; 6246 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6247 : 	return obj1.GetAuxIntData() < obj2.GetAuxIntData();

	mov	eax, DWORD PTR _obj1$[ebp+4]
	mov	DWORD PTR $T260503[ebp], eax
	mov	ecx, DWORD PTR _obj2$[ebp+4]
	mov	DWORD PTR $T260507[ebp], ecx
	mov	edx, DWORD PTR $T260503[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T260507[ebp]
	setl	al

; 6248 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CvHomelandUnitAuxIntSort@HomelandAIHelpers@@YA_NVCvHomelandUnit@@0@Z ENDP ; HomelandAIHelpers::CvHomelandUnitAuxIntSort
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?CvHomelandUnitAuxIntReverseSort@HomelandAIHelpers@@YA_NVCvHomelandUnit@@0@Z
_TEXT	SEGMENT
$T260517 = -8						; size = 4
$T260513 = -4						; size = 4
_obj1$ = 8						; size = 16
_obj2$ = 24						; size = 16
?CvHomelandUnitAuxIntReverseSort@HomelandAIHelpers@@YA_NVCvHomelandUnit@@0@Z PROC ; HomelandAIHelpers::CvHomelandUnitAuxIntReverseSort, COMDAT

; 6251 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6252 : 	return obj1.GetAuxIntData() > obj2.GetAuxIntData();

	mov	eax, DWORD PTR _obj1$[ebp+4]
	mov	DWORD PTR $T260513[ebp], eax
	mov	ecx, DWORD PTR _obj2$[ebp+4]
	mov	DWORD PTR $T260517[ebp], ecx
	mov	edx, DWORD PTR $T260513[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T260517[ebp]
	setg	al

; 6253 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CvHomelandUnitAuxIntReverseSort@HomelandAIHelpers@@YA_NVCvHomelandUnit@@0@Z ENDP ; HomelandAIHelpers::CvHomelandUnitAuxIntReverseSort
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
_TEXT	ENDS
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 146  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		if(m_target) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN2@FObjectHan:

; 150  : 		}
; 151  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Buynode
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
xdata$x	ENDS
;	COMDAT ??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv90 = -68						; size = 4
tv148 = -64						; size = 4
tv173 = -60						; size = 4
tv197 = -56						; size = 4
_this$ = -52						; size = 4
$T260615 = -48						; size = 1
$T260588 = -47						; size = 1
$T260568 = -46						; size = 1
$T260555 = -45						; size = 1
$T260551 = -44						; size = 4
$T260544 = -36						; size = 4
$T260537 = -28						; size = 4
$T260530 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::list<int,std::allocator<int> >::list<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 436  : 		{	// construct empty list

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T260615[ebp]
	mov	DWORD PTR $T260530[ebp], eax
	lea	ecx, DWORD PTR $T260588[ebp]
	mov	DWORD PTR $T260537[ebp], ecx
	lea	edx, DWORD PTR $T260568[ebp]
	mov	DWORD PTR $T260544[ebp], edx
	lea	eax, DWORD PTR $T260555[ebp]
	mov	DWORD PTR $T260551[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv197[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv173[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv148[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv90[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Buynode
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 437  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_List_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::list<int,std::allocator<int> >::list<int,std::allocator<int> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
xdata$x	ENDS
;	COMDAT ??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T260678 = -36						; size = 4
$T260655 = -32						; size = 4
__$EHRec$ = -12						; size = 12
??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 520  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 521  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ ; std::list<int,std::allocator<int> >::clear
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T260655[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T260678[ebp], eax
	mov	ecx, DWORD PTR $T260678[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0

; 522  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_List_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >
; Function compile flags: /Odtp
;	COMDAT ?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T260737 = -16						; size = 4
$T260733 = -12						; size = 4
__Pnext$ = -8						; size = 4
__Pnode$ = -4						; size = 4
?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ PROC	; std::list<int,std::allocator<int> >::clear, COMDAT
; _this$ = ecx

; 825  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 826  : 
; 827  :  #if _HAS_ITERATOR_DEBUGGING
; 828  : 		this->_Orphan_ptr(*this, 0);
; 829  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 830  : 
; 831  : 		_Nodeptr _Pnext;
; 832  : 		_Nodeptr _Pnode = _Nextnode(_Myhead);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T260733[ebp], ecx
	mov	edx, DWORD PTR $T260733[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 833  : 		_Nextnode(_Myhead) = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T260737[ebp], edx
	mov	eax, DWORD PTR $T260737[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 834  : 		_Prevnode(_Myhead) = _Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 835  : 		_Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 836  : 
; 837  : 		for (; _Pnode != _Myhead; _Pnode = _Pnext)

	jmp	SHORT $LN3@clear
$LN2@clear:
	mov	edx, DWORD PTR __Pnext$[ebp]
	mov	DWORD PTR __Pnode$[ebp], edx
$LN3@clear:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN4@clear

; 838  : 			{	// delete an element
; 839  : 			_Pnext = _Nextnode(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnext$[ebp], eax

; 840  : 			this->_Alnod.destroy(_Pnode);
; 841  : 			this->_Alnod.deallocate(_Pnode, 1);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 842  : 			}

	jmp	SHORT $LN2@clear
$LN4@clear:

; 843  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::list<int,std::allocator<int> >::clear
_TEXT	ENDS
PUBLIC	?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ; std::list<int,std::allocator<int> >::erase
; Function compile flags: /Odtp
;	COMDAT ?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T260788 = -32						; size = 4
$T260779 = -28						; size = 4
$T260768 = -24						; size = 4
$T260758 = -20						; size = 4
$T260757 = -16						; size = 4
__First$228672 = -12					; size = 4
__Val$ = -8						; size = 4
__Last$ = -4						; size = 4
__Val_arg$ = 8						; size = 4
?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::list<int,std::allocator<int> >::remove, COMDAT
; _this$ = ecx

; 927  : 		{	// erase each element matching _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 928  : 		/* Dinkumware makes a copy of _Val_arg in case it's removed along the way, i.e.
; 929  : 		 * when the user pass an element of the list as _Val_arg.
; 930  : 		 *
; 931  : 		 * We believe that the signature of std::list::remove should be changed
; 932  : 		 * from remove(const _Ty&) to remove(_Ty) to explicitly indicate that a copy is involved.
; 933  : 		 */
; 934  : 		const _Ty _Val = _Val_arg;	// in case it's removed along the way

	mov	eax, DWORD PTR __Val_arg$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Val$[ebp], ecx

; 935  : 		iterator _Last = end();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T260768[ebp], eax
	mov	ecx, DWORD PTR $T260768[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 936  : 		for (iterator _First = begin(); _First != _Last; )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T260779[ebp], eax
	mov	ecx, DWORD PTR $T260779[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T260788[ebp], edx
	mov	eax, DWORD PTR $T260788[ebp]
	mov	DWORD PTR __First$228672[ebp], eax
$LN21@remove:
	mov	ecx, DWORD PTR __First$228672[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR __Last$[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@remove

; 937  : 			if (*_First == _Val)

	mov	edx, DWORD PTR __First$228672[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR __Val$[ebp]
	jne	SHORT $LN70@remove

; 938  : 				_First = erase(_First);

	mov	ecx, DWORD PTR __First$228672[ebp]
	mov	DWORD PTR $T260757[ebp], ecx
	mov	edx, DWORD PTR $T260757[ebp]
	push	edx
	lea	eax, DWORD PTR $T260758[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ; std::list<int,std::allocator<int> >::erase
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __First$228672[ebp], ecx

; 939  : 			else

	jmp	SHORT $LN1@remove

; 940  : 				++_First;

$LN70@remove:
	mov	edx, DWORD PTR __First$228672[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __First$228672[ebp], eax
$LN1@remove:
	jmp	SHORT $LN21@remove
$LN5@remove:

; 941  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::list<int,std::allocator<int> >::remove
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvHomelandUnit@@$00@@QAE@XZ	; BaseVector<CvHomelandUnit,1>::~BaseVector<CvHomelandUnit,1>
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T260913 = -20						; size = 4
_pRet$260909 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvHomelandUnit,64,1,297,0>::FStaticVector<CvHomelandUnit,64,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 64			; 00000040H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T260913[ebp], edx
	cmp	DWORD PTR $T260913[ebp], 64		; 00000040H
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T260913[ebp]
	shl	eax, 4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$260909[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T260913[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$260909[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 64			; 00000040H
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$260909[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@VCvHomelandUnit@@$00@@QAE@XZ ; BaseVector<CvHomelandUnit,1>::~BaseVector<CvHomelandUnit,1>
__ehhandler$??0?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvHomelandUnit,64,1,297,0>::FStaticVector<CvHomelandUnit,64,1,297,0>
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T260944 = -24						; size = 4
$T260943 = -20						; size = 4
_i$260938 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvHomelandUnit,64,1,297,0>::~FStaticVector<CvHomelandUnit,64,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T260944[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T260943[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@2
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@2
	mov	DWORD PTR _i$260938[ebp], 0
	jmp	SHORT $LN10@FStaticVec@2
$LN9@FStaticVec@2:
	mov	eax, DWORD PTR _i$260938[ebp]
	add	eax, 1
	mov	DWORD PTR _i$260938[ebp], eax
$LN10@FStaticVec@2:
	mov	ecx, DWORD PTR _i$260938[ebp]
	cmp	ecx, DWORD PTR $T260944[ebp]
	jae	SHORT $LN5@FStaticVec@2
	jmp	SHORT $LN9@FStaticVec@2
$LN5@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T260943[ebp], edx
	je	SHORT $LN1@FStaticVec@2
	mov	eax, DWORD PTR $T260943[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@2:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@VCvHomelandUnit@@$00@@QAE@XZ ; BaseVector<CvHomelandUnit,1>::~BaseVector<CvHomelandUnit,1>
__ehhandler$??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvHomelandUnit,64,1,297,0>::~FStaticVector<CvHomelandUnit,64,1,297,0>
PUBLIC	?Copy@?$BaseVector@VCvHomelandUnit@@$00@@IAEXABV1@@Z ; BaseVector<CvHomelandUnit,1>::Copy
; Function compile flags: /Odtp
;	COMDAT ??4?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
_i$260988 = -24						; size = 4
$T260984 = -20						; size = 4
_pRet$260980 = -16					; size = 4
$T260977 = -12						; size = 4
$T260976 = -8						; size = 4
_i$260971 = -4						; size = 4
_RHS$ = 8						; size = 4
??4?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z PROC ; FStaticVector<CvHomelandUnit,64,1,297,0>::operator=, COMDAT
; _this$ = ecx

; 620  : 	void operator = (const THIS_TYPE& RHS){

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 621  : 		if( m_uiCurrMaxSize <= RHS.m_uiCurrSize){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	ja	$LN2@operator

; 622  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T260977[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T260976[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN6@operator
	xor	edx, edx
	je	SHORT $LN6@operator
	mov	DWORD PTR _i$260971[ebp], 0
	jmp	SHORT $LN11@operator
$LN10@operator:
	mov	eax, DWORD PTR _i$260971[ebp]
	add	eax, 1
	mov	DWORD PTR _i$260971[ebp], eax
$LN11@operator:
	mov	ecx, DWORD PTR _i$260971[ebp]
	cmp	ecx, DWORD PTR $T260977[ebp]
	jae	SHORT $LN6@operator
	jmp	SHORT $LN10@operator
$LN6@operator:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T260976[ebp], edx
	je	SHORT $LN7@operator
	mov	eax, DWORD PTR $T260976[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN7@operator:

; 623  : 			m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T260984[ebp], edx
	cmp	DWORD PTR $T260984[ebp], 64		; 00000040H
	jbe	SHORT $LN16@operator
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T260984[ebp]
	shl	eax, 4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$260980[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T260984[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN17@operator
$LN16@operator:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$260980[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 64			; 00000040H
$LN17@operator:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$260980[ebp]
	mov	DWORD PTR [edx], eax

; 624  : 		}else{

	jmp	SHORT $LN1@operator
$LN2@operator:

; 625  : 			Destroy(m_pData, m_uiCurrSize);

	xor	ecx, ecx
	je	SHORT $LN1@operator
	mov	DWORD PTR _i$260988[ebp], 0
	jmp	SHORT $LN21@operator
$LN20@operator:
	mov	edx, DWORD PTR _i$260988[ebp]
	add	edx, 1
	mov	DWORD PTR _i$260988[ebp], edx
$LN21@operator:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$260988[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN1@operator
	jmp	SHORT $LN20@operator
$LN1@operator:

; 626  : 		}
; 627  : 		Copy(RHS);

	mov	edx, DWORD PTR _RHS$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Copy@?$BaseVector@VCvHomelandUnit@@$00@@IAEXABV1@@Z ; BaseVector<CvHomelandUnit,1>::Copy

; 628  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z ENDP ; FStaticVector<CvHomelandUnit,64,1,297,0>::operator=
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z
_TEXT	SEGMENT
tv141 = -52						; size = 4
tv132 = -48						; size = 4
_this$ = -44						; size = 4
$T261002 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z PROC ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1036], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T261002[ebp], ecx
	je	SHORT $LN4@push_back
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR $T261002[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR $T261002[ebp]
	mov	DWORD PTR tv132[ebp], ecx
	jmp	SHORT $LN5@push_back
$LN4@push_back:
	mov	DWORD PTR tv132[ebp], 0
$LN5@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv141[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR tv141[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ENDP ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvHomelandMove@@$00@@QAE@XZ	; BaseVector<CvHomelandMove,1>::~BaseVector<CvHomelandMove,1>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T261056 = -20						; size = 4
_pRet$261052 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvHomelandMove,35,1,297,0>::FStaticVector<CvHomelandMove,35,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 35			; 00000023H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T261056[ebp], edx
	cmp	DWORD PTR $T261056[ebp], 35		; 00000023H
	jbe	SHORT $LN7@FStaticVec@3
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T261056[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$261052[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T261056[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@3
$LN7@FStaticVec@3:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$261052[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 35			; 00000023H
$LN8@FStaticVec@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$261052[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@VCvHomelandMove@@$00@@QAE@XZ ; BaseVector<CvHomelandMove,1>::~BaseVector<CvHomelandMove,1>
__ehhandler$??0?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvHomelandMove,35,1,297,0>::FStaticVector<CvHomelandMove,35,1,297,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T261087 = -24						; size = 4
$T261086 = -20						; size = 4
_i$261081 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvHomelandMove,35,1,297,0>::~FStaticVector<CvHomelandMove,35,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T261087[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T261086[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@4
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@4
	mov	DWORD PTR _i$261081[ebp], 0
	jmp	SHORT $LN10@FStaticVec@4
$LN9@FStaticVec@4:
	mov	eax, DWORD PTR _i$261081[ebp]
	add	eax, 1
	mov	DWORD PTR _i$261081[ebp], eax
$LN10@FStaticVec@4:
	mov	ecx, DWORD PTR _i$261081[ebp]
	cmp	ecx, DWORD PTR $T261087[ebp]
	jae	SHORT $LN5@FStaticVec@4
	jmp	SHORT $LN9@FStaticVec@4
$LN5@FStaticVec@4:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T261086[ebp], edx
	je	SHORT $LN1@FStaticVec@4
	mov	eax, DWORD PTR $T261086[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@4:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@VCvHomelandMove@@$00@@QAE@XZ ; BaseVector<CvHomelandMove,1>::~BaseVector<CvHomelandMove,1>
__ehhandler$??1?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvHomelandMove,35,1,297,0>::~FStaticVector<CvHomelandMove,35,1,297,0>
PUBLIC	?GrowSize@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandMove,35,1,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAEIABVCvHomelandMove@@@Z
_TEXT	SEGMENT
tv141 = -52						; size = 4
tv132 = -48						; size = 4
_this$ = -44						; size = 4
$T261099 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAEIABVCvHomelandMove@@@Z PROC ; FStaticVector<CvHomelandMove,35,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+292], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandMove,35,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T261099[ebp], ecx
	cmp	DWORD PTR $T261099[ebp], 0
	je	SHORT $LN4@push_back@2
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T261099[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T261099[ebp]
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN5@push_back@2
$LN4@push_back@2:
	mov	DWORD PTR tv132[ebp], 0
$LN5@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv141[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv141[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAEIABVCvHomelandMove@@@Z ENDP ; FStaticVector<CvHomelandMove,35,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE_NI@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T261172 = -30						; size = 1
$T261159 = -29						; size = 1
$T261155 = -28						; size = 4
$T261148 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T261172[ebp]
	mov	DWORD PTR $T261148[ebp], eax
	lea	ecx, DWORD PTR $T261159[ebp]
	mov	DWORD PTR $T261155[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE_NI@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
PUBLIC	??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
tv240 = -300						; size = 4
_this$ = -296						; size = 4
$T261695 = -292						; size = 4
$T261694 = -288						; size = 4
$T261693 = -284						; size = 4
$T261683 = -280						; size = 4
$T261682 = -276						; size = 4
__Cat$261690 = -271					; size = 1
$T261687 = -270						; size = 1
$T261686 = -269						; size = 1
$T261632 = -180						; size = 4
$T261628 = -176						; size = 4
$T261627 = -172						; size = 4
$T261623 = -168						; size = 4
$T261622 = -164						; size = 4
$T261604 = -160						; size = 4
$T261603 = -156						; size = 4
$T261587 = -152						; size = 4
__Cat$261610 = -146					; size = 1
$T261607 = -145						; size = 1
$T261561 = -144						; size = 4
$T261560 = -140						; size = 4
$T261550 = -136						; size = 4
$T261549 = -132						; size = 4
__Cat$261557 = -127					; size = 1
$T261554 = -126						; size = 1
$T261553 = -125						; size = 1
$T261533 = -124						; size = 4
$T261532 = -120						; size = 4
$T261515 = -114						; size = 1
$T261514 = -113						; size = 1
$T261513 = -112						; size = 4
$T261512 = -108						; size = 4
__Cat$261522 = -100					; size = 1
$T261519 = -99						; size = 1
$T261518 = -98						; size = 1
$T261517 = -97						; size = 1
$T261483 = -96						; size = 4
$T261476 = -92						; size = 4
$T261458 = -88						; size = 4
$T261457 = -84						; size = 4
$T261441 = -80						; size = 4
__Cat$261464 = -74					; size = 1
$T261461 = -73						; size = 1
$T261415 = -72						; size = 4
$T261414 = -68						; size = 4
$T261413 = -64						; size = 4
$T261396 = -58						; size = 1
$T261395 = -57						; size = 1
$T261394 = -56						; size = 4
$T261393 = -52						; size = 4
__Cat$261403 = -44					; size = 1
$T261400 = -43						; size = 1
$T261399 = -42						; size = 1
$T261398 = -41						; size = 1
$T261371 = -40						; size = 4
$T261342 = -36						; size = 4
$T261326 = -32						; size = 4
$T261354 = -28						; size = 4
$T261353 = -24						; size = 4
$T261352 = -20						; size = 4
$T261351 = -16						; size = 4
$T261350 = -12						; size = 4
__Ptr$228751 = -8					; size = 4
__Ptr$228741 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@2

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	test	eax, eax
	jne	SHORT $LN8@operator@2

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T261326[ebp], eax
	mov	ecx, DWORD PTR $T261326[ebp]
	mov	DWORD PTR $T261351[ebp], ecx
	mov	edx, DWORD PTR $T261351[ebp]
	mov	DWORD PTR $T261350[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T261342[ebp], ecx
	mov	edx, DWORD PTR $T261342[ebp]
	mov	DWORD PTR $T261353[ebp], edx
	mov	eax, DWORD PTR $T261353[ebp]
	mov	DWORD PTR $T261352[ebp], eax
	mov	ecx, DWORD PTR $T261350[ebp]
	push	ecx
	mov	edx, DWORD PTR $T261352[ebp]
	push	edx
	lea	eax, DWORD PTR $T261354[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase

; 573  : 			else if (_Right.size() <= size())

	jmp	$LN9@operator@2
$LN8@operator@2:
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR $T261371[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	cmp	DWORD PTR $T261371[ebp], eax
	ja	$LN6@operator@2

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T261415[ebp], eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T261414[ebp], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T261413[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T261398[ebp], dl
	mov	al, BYTE PTR __Cat$261403[ebp]
	mov	BYTE PTR $T261399[ebp], al
	mov	cl, BYTE PTR $T261398[ebp]
	mov	BYTE PTR $T261396[ebp], cl
	mov	dl, BYTE PTR $T261400[ebp]
	mov	BYTE PTR $T261395[ebp], dl
	mov	eax, DWORD PTR $T261415[ebp]
	mov	DWORD PTR $T261394[ebp], eax
	mov	ecx, DWORD PTR $T261413[ebp]
	mov	DWORD PTR $T261393[ebp], ecx
	jmp	SHORT $LN40@operator@2
$LN39@operator@2:
	mov	edx, DWORD PTR $T261394[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T261394[ebp], edx
	mov	eax, DWORD PTR $T261393[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T261393[ebp], eax
$LN40@operator@2:
	mov	ecx, DWORD PTR $T261393[ebp]
	cmp	ecx, DWORD PTR $T261414[ebp]
	je	SHORT $LN32@operator@2
	mov	edx, DWORD PTR $T261393[ebp]
	mov	eax, DWORD PTR $T261394[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	jmp	SHORT $LN39@operator@2
$LN32@operator@2:
	mov	eax, DWORD PTR $T261394[ebp]
	mov	DWORD PTR __Ptr$228741[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T261476[ebp], edx
	mov	eax, DWORD PTR $T261476[ebp]
	mov	DWORD PTR $T261458[ebp], eax
	mov	ecx, DWORD PTR __Ptr$228741[ebp]
	mov	DWORD PTR $T261457[ebp], ecx
	mov	dl, BYTE PTR __Cat$261464[ebp]
	mov	BYTE PTR $T261461[ebp], dl
	mov	eax, DWORD PTR $T261457[ebp]
	mov	DWORD PTR $T261441[ebp], eax
	jmp	SHORT $LN51@operator@2
$LN50@operator@2:
	mov	ecx, DWORD PTR $T261441[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T261441[ebp], ecx
$LN51@operator@2:
	mov	edx, DWORD PTR $T261441[ebp]
	cmp	edx, DWORD PTR $T261458[ebp]
	je	SHORT $LN58@operator@2
	jmp	SHORT $LN50@operator@2

; 578  : 				_Mylast = _Myfirst + _Right.size();

$LN58@operator@2:
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	imul	eax, 20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
	jmp	$LN9@operator@2
$LN6@operator@2:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR $T261483[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN64@operator@2
	mov	DWORD PTR tv240[ebp], 0
	jmp	SHORT $LN62@operator@2
$LN64@operator@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR tv240[ebp], eax
$LN62@operator@2:
	mov	edx, DWORD PTR $T261483[ebp]
	cmp	edx, DWORD PTR tv240[ebp]
	ja	$LN4@operator@2

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	imul	eax, 20					; 00000014H
	mov	edx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Ptr$228751[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T261533[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T261532[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T261517[ebp], cl
	mov	dl, BYTE PTR __Cat$261522[ebp]
	mov	BYTE PTR $T261518[ebp], dl
	mov	al, BYTE PTR $T261517[ebp]
	mov	BYTE PTR $T261515[ebp], al
	mov	cl, BYTE PTR $T261519[ebp]
	mov	BYTE PTR $T261514[ebp], cl
	mov	edx, DWORD PTR $T261533[ebp]
	mov	DWORD PTR $T261513[ebp], edx
	mov	eax, DWORD PTR $T261532[ebp]
	mov	DWORD PTR $T261512[ebp], eax
	jmp	SHORT $LN76@operator@2
$LN75@operator@2:
	mov	ecx, DWORD PTR $T261513[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T261513[ebp], ecx
	mov	edx, DWORD PTR $T261512[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T261512[ebp], edx
$LN76@operator@2:
	mov	eax, DWORD PTR $T261512[ebp]
	cmp	eax, DWORD PTR __Ptr$228751[ebp]
	je	SHORT $LN68@operator@2
	mov	ecx, DWORD PTR $T261512[ebp]
	mov	edx, DWORD PTR $T261513[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	jmp	SHORT $LN75@operator@2
$LN68@operator@2:

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T261561[ebp], eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T261560[ebp], edx
	mov	eax, DWORD PTR $T261561[ebp]
	mov	DWORD PTR $T261550[ebp], eax
	mov	ecx, DWORD PTR __Ptr$228751[ebp]
	mov	DWORD PTR $T261549[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T261553[ebp], dl
	mov	al, BYTE PTR __Cat$261557[ebp]
	mov	BYTE PTR $T261554[ebp], al
	movzx	ecx, BYTE PTR $T261553[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T261554[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T261550[ebp]
	push	ecx
	mov	edx, DWORD PTR $T261560[ebp]
	push	edx
	mov	eax, DWORD PTR $T261549[ebp]
	push	eax
	call	??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 585  : 				}
; 586  : 			else

	jmp	$LN9@operator@2
$LN4@operator@2:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN2@operator@2

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T261623[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T261622[ebp], eax
	mov	ecx, DWORD PTR $T261623[ebp]
	mov	DWORD PTR $T261604[ebp], ecx
	mov	edx, DWORD PTR $T261622[ebp]
	mov	DWORD PTR $T261603[ebp], edx
	mov	al, BYTE PTR __Cat$261610[ebp]
	mov	BYTE PTR $T261607[ebp], al
	mov	ecx, DWORD PTR $T261603[ebp]
	mov	DWORD PTR $T261587[ebp], ecx
	jmp	SHORT $LN93@operator@2
$LN92@operator@2:
	mov	edx, DWORD PTR $T261587[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T261587[ebp], edx
$LN93@operator@2:
	mov	eax, DWORD PTR $T261587[ebp]
	cmp	eax, DWORD PTR $T261604[ebp]
	je	SHORT $LN85@operator@2
	jmp	SHORT $LN92@operator@2
$LN85@operator@2:

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR $T261628[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T261627[ebp], eax
	mov	ecx, DWORD PTR $T261627[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@operator@2:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR $T261632[ebp], eax
	mov	edx, DWORD PTR $T261632[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE_NI@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	$LN9@operator@2

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T261695[ebp], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T261694[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T261693[ebp], eax
	mov	ecx, DWORD PTR $T261695[ebp]
	mov	DWORD PTR $T261683[ebp], ecx
	mov	edx, DWORD PTR $T261693[ebp]
	mov	DWORD PTR $T261682[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T261686[ebp], al
	mov	cl, BYTE PTR __Cat$261690[ebp]
	mov	BYTE PTR $T261687[ebp], cl
	movzx	edx, BYTE PTR $T261686[ebp]
	push	edx
	movzx	eax, BYTE PTR $T261687[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T261683[ebp]
	push	edx
	mov	eax, DWORD PTR $T261694[ebp]
	push	eax
	mov	ecx, DWORD PTR $T261682[ebp]
	push	ecx
	call	??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax
$LN9@operator@2:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator=
_TEXT	ENDS
PUBLIC	?insert@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@ABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::insert
PUBLIC	??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvHomelandTarget *,unsigned int,CvHomelandTarget,std::allocator<CvHomelandTarget> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T261747 = -32						; size = 4
$T261737 = -28						; size = 4
$T261727 = -24						; size = 4
__Cat$261734 = -19					; size = 1
$T261731 = -18						; size = 1
$T261730 = -17						; size = 1
$T261704 = -16						; size = 4
$T261700 = -12						; size = 4
$T261699 = -8						; size = 4
$T261698 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR $T261704[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN9@push_back@3
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@3
$LN9@push_back@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@3:
	mov	edx, DWORD PTR $T261704[ebp]
	cmp	edx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@3

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T261737[ebp], ecx
	mov	edx, DWORD PTR $T261737[ebp]
	mov	DWORD PTR $T261727[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T261730[ebp], al
	mov	cl, BYTE PTR __Cat$261734[ebp]
	mov	BYTE PTR $T261731[ebp], cl
	movzx	edx, BYTE PTR $T261730[ebp]
	push	edx
	movzx	eax, BYTE PTR $T261731[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR $T261727[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvHomelandTarget *,unsigned int,CvHomelandTarget,std::allocator<CvHomelandTarget> >
	add	esp, 24					; 00000018H
	mov	ecx, 1
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR $T261737[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@3
$LN2@push_back@3:

; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T261747[ebp], ecx
	mov	edx, DWORD PTR $T261747[ebp]
	mov	DWORD PTR $T261699[ebp], edx
	mov	eax, DWORD PTR $T261699[ebp]
	mov	DWORD PTR $T261698[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T261698[ebp]
	push	edx
	lea	eax, DWORD PTR $T261700[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@ABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::insert
$LN3@push_back@3:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T261917 = -56						; size = 4
$T261916 = -52						; size = 4
$T261898 = -48						; size = 4
$T261897 = -44						; size = 4
$T261881 = -40						; size = 4
__Cat$261903 = -34					; size = 1
$T261901 = -33						; size = 1
$T261855 = -32						; size = 4
$T261854 = -28						; size = 4
$T261853 = -24						; size = 4
$T261836 = -18						; size = 1
$T261835 = -17						; size = 1
$T261834 = -16						; size = 4
$T261833 = -12						; size = 4
__Cat$261842 = -4					; size = 1
$T261840 = -3						; size = 1
$T261839 = -2						; size = 1
$T261838 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@@Z PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase, COMDAT
; _this$ = ecx

; 1017 : 		{	// erase element at where

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 1018 : 		_STDEXT unchecked_copy(_VEC_ITER_BASE(_Where) + 1, _Mylast,
; 1019 : 			_VEC_ITER_BASE(_Where));

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T261855[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T261854[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T261853[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T261838[ebp], cl
	mov	dl, BYTE PTR __Cat$261842[ebp]
	mov	BYTE PTR $T261839[ebp], dl
	mov	al, BYTE PTR $T261838[ebp]
	mov	BYTE PTR $T261836[ebp], al
	mov	cl, BYTE PTR $T261840[ebp]
	mov	BYTE PTR $T261835[ebp], cl
	mov	edx, DWORD PTR $T261855[ebp]
	mov	DWORD PTR $T261834[ebp], edx
	mov	eax, DWORD PTR $T261853[ebp]
	mov	DWORD PTR $T261833[ebp], eax
	jmp	SHORT $LN11@erase
$LN10@erase:
	mov	ecx, DWORD PTR $T261834[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T261834[ebp], ecx
	mov	edx, DWORD PTR $T261833[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T261833[ebp], edx
$LN11@erase:
	mov	eax, DWORD PTR $T261833[ebp]
	cmp	eax, DWORD PTR $T261854[ebp]
	je	SHORT $LN3@erase
	mov	ecx, DWORD PTR $T261833[ebp]
	mov	edx, DWORD PTR $T261834[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	jmp	SHORT $LN10@erase
$LN3@erase:

; 1020 : 		_Destroy(_Mylast - 1, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T261917[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 20					; 00000014H
	mov	DWORD PTR $T261916[ebp], edx
	mov	eax, DWORD PTR $T261917[ebp]
	mov	DWORD PTR $T261898[ebp], eax
	mov	ecx, DWORD PTR $T261916[ebp]
	mov	DWORD PTR $T261897[ebp], ecx
	mov	dl, BYTE PTR __Cat$261903[ebp]
	mov	BYTE PTR $T261901[ebp], dl
	mov	eax, DWORD PTR $T261897[ebp]
	mov	DWORD PTR $T261881[ebp], eax
	jmp	SHORT $LN22@erase
$LN21@erase:
	mov	ecx, DWORD PTR $T261881[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T261881[ebp], ecx
$LN22@erase:
	mov	edx, DWORD PTR $T261881[ebp]
	cmp	edx, DWORD PTR $T261898[ebp]
	je	SHORT $LN14@erase
	jmp	SHORT $LN21@erase
$LN14@erase:

; 1021 : 		--_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1022 : 		return (_Make_iter(_Where));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1023 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@@Z ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T261945 = -20						; size = 4
_pRet$261942 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<TradeConnection,168,0,297,0>::FStaticVector<TradeConnection,168,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 168			; 000000a8H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T261945[ebp], edx
	cmp	DWORD PTR $T261945[ebp], 168		; 000000a8H
	jbe	SHORT $LN7@FStaticVec@5
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T261945[ebp]
	imul	eax, 444				; 000001bcH
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$261942[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T261945[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@5
$LN7@FStaticVec@5:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$261942[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 168			; 000000a8H
$LN8@FStaticVec@5:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$261942[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ ; BaseVector<TradeConnection,0>::~BaseVector<TradeConnection,0>
__ehhandler$??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<TradeConnection,168,0,297,0>::FStaticVector<TradeConnection,168,0,297,0>
PUBLIC	?_Buy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE_NI@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T261983 = -30						; size = 1
$T261970 = -29						; size = 1
$T261966 = -28						; size = 4
$T261959 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::vector<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T261983[ebp]
	mov	DWORD PTR $T261959[ebp], eax
	lea	ecx, DWORD PTR $T261970[ebp]
	mov	DWORD PTR $T261966[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE_NI@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::vector<CvPlot *,std::allocator<CvPlot *> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::~vector<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::~vector<CvPlot *,std::allocator<CvPlot *> >
PUBLIC	?insert@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@ABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::insert
PUBLIC	??$unchecked_fill_n@PAPAVCvPlot@@IPAV1@@stdext@@YAXPAPAVCvPlot@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvPlot * *,unsigned int,CvPlot *>
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXABQAVCvPlot@@@Z
_TEXT	SEGMENT
tv129 = -96						; size = 4
_this$ = -92						; size = 4
$T262176 = -64						; size = 4
$T262166 = -60						; size = 4
$T262154 = -56						; size = 4
$T262144 = -49						; size = 1
$T262143 = -48						; size = 4
__Cat$262160 = -19					; size = 1
$T262158 = -18						; size = 1
$T262157 = -17						; size = 1
$T262095 = -16						; size = 4
$T262091 = -12						; size = 4
$T262090 = -8						; size = 4
$T262089 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXABQAVCvPlot@@@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T262095[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back@4
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@4
$LN9@push_back@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@4:
	mov	ecx, DWORD PTR $T262095[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@4

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T262166[ebp], eax
	mov	ecx, DWORD PTR $T262166[ebp]
	mov	DWORD PTR $T262154[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T262157[ebp], dl
	mov	al, BYTE PTR __Cat$262160[ebp]
	mov	BYTE PTR $T262158[ebp], al
	mov	cl, BYTE PTR $T262157[ebp]
	mov	BYTE PTR $T262144[ebp], cl
	mov	edx, DWORD PTR $T262154[ebp]
	mov	DWORD PTR $T262143[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR $T262143[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAPAVCvPlot@@IPAV1@@stdext@@YAXPAPAVCvPlot@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvPlot * *,unsigned int,CvPlot *>
	add	esp, 12					; 0000000cH
	mov	edx, 1
	shl	edx, 2
	add	edx, DWORD PTR $T262166[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@4
$LN2@push_back@4:

; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T262176[ebp], edx
	mov	eax, DWORD PTR $T262176[ebp]
	mov	DWORD PTR $T262090[ebp], eax
	mov	ecx, DWORD PTR $T262090[ebp]
	mov	DWORD PTR $T262089[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR $T262089[ebp]
	push	eax
	lea	ecx, DWORD PTR $T262091[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@ABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::insert
$LN3@push_back@4:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXABQAVCvPlot@@@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::push_back
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@XZ$0
__ehfuncinfo$??1?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T262270 = -24						; size = 4
$T262269 = -20						; size = 4
_i$262261 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@XZ PROC ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::~FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 316  : 	~FFastVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T262270[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T262269[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN4@FFastVecto
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN4@FFastVecto
	mov	DWORD PTR _i$262261[ebp], 0
	jmp	SHORT $LN9@FFastVecto
$LN8@FFastVecto:
	mov	eax, DWORD PTR _i$262261[ebp]
	add	eax, 1
	mov	DWORD PTR _i$262261[ebp], eax
$LN9@FFastVecto:
	mov	ecx, DWORD PTR _i$262261[ebp]
	cmp	ecx, DWORD PTR $T262270[ebp]
	jae	SHORT $LN4@FFastVecto
	jmp	SHORT $LN8@FFastVecto
$LN4@FFastVecto:
	mov	edx, DWORD PTR $T262269[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 318  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QAE@XZ ; BaseVector<std::pair<int,CvPlot *>,0>::~BaseVector<std::pair<int,CvPlot *>,0>
__ehhandler$??1?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@XZ ENDP ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::~FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>
PUBLIC	?GrowSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAEIABU?$pair@HPAVCvPlot@@@std@@@Z
_TEXT	SEGMENT
tv140 = -56						; size = 4
tv131 = -52						; size = 4
_this$ = -48						; size = 4
$T262282 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAEIABU?$pair@HPAVCvPlot@@@std@@@Z PROC ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::push_back, COMDAT
; _this$ = ecx

; 376  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN39@push_back@5

; 378  : 			GrowSize(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::GrowSize

; 379  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back@5:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T262282[ebp], eax
	cmp	DWORD PTR $T262282[ebp], 0
	je	SHORT $LN4@push_back@5
	mov	ecx, DWORD PTR _element$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T262282[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T262282[ebp]
	mov	DWORD PTR tv131[ebp], edx
	jmp	SHORT $LN5@push_back@5
$LN4@push_back@5:
	mov	DWORD PTR tv131[ebp], 0
$LN5@push_back@5:

; 380  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv140[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR tv140[ebp]

; 381  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAEIABU?$pair@HPAVCvPlot@@@std@@@Z ENDP ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::push_back
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T262363 = -30						; size = 1
$T262350 = -29						; size = 1
$T262346 = -28						; size = 4
$T262339 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T262363[ebp]
	mov	DWORD PTR $T262339[ebp], eax
	lea	ecx, DWORD PTR $T262350[ebp]
	mov	DWORD PTR $T262346[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
PUBLIC	?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::insert
PUBLIC	??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z
_TEXT	SEGMENT
tv129 = -96						; size = 4
_this$ = -92						; size = 4
$T262556 = -64						; size = 4
$T262546 = -60						; size = 4
$T262534 = -56						; size = 4
$T262524 = -49						; size = 1
$T262523 = -48						; size = 4
__Cat$262541 = -19					; size = 1
$T262538 = -18						; size = 1
$T262537 = -17						; size = 1
$T262475 = -16						; size = 4
$T262471 = -12						; size = 4
$T262470 = -8						; size = 4
$T262469 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T262475[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back@6
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@6
$LN9@push_back@6:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@6:
	mov	ecx, DWORD PTR $T262475[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@6

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T262546[ebp], eax
	mov	ecx, DWORD PTR $T262546[ebp]
	mov	DWORD PTR $T262534[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T262537[ebp], dl
	mov	al, BYTE PTR __Cat$262541[ebp]
	mov	BYTE PTR $T262538[ebp], al
	mov	cl, BYTE PTR $T262537[ebp]
	mov	BYTE PTR $T262524[ebp], cl
	mov	edx, DWORD PTR $T262534[ebp]
	mov	DWORD PTR $T262523[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR $T262523[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
	add	esp, 12					; 0000000cH
	mov	edx, 1
	shl	edx, 2
	add	edx, DWORD PTR $T262546[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@6
$LN2@push_back@6:

; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T262556[ebp], edx
	mov	eax, DWORD PTR $T262556[ebp]
	mov	DWORD PTR $T262470[ebp], eax
	mov	ecx, DWORD PTR $T262470[ebp]
	mov	DWORD PTR $T262469[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR $T262469[ebp]
	push	eax
	lea	ecx, DWORD PTR $T262471[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::insert
$LN3@push_back@6:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
_TEXT	ENDS
;	COMDAT ??1?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ PROC	; CvWeightedVector<CvPlot *,100,1>::~CvWeightedVector<CvPlot *,100,1>, COMDAT
; _this$ = ecx

; 58   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 	};

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ ENDP	; CvWeightedVector<CvPlot *,100,1>::~CvWeightedVector<CvPlot *,100,1>
_TEXT	ENDS
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int>
; Function compile flags: /Odtp
;	COMDAT ?SortItems@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXXZ
_TEXT	SEGMENT
_this$ = -156						; size = 4
$T262661 = -8						; size = 4
$T262657 = -4						; size = 4
?SortItems@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXXZ PROC ; CvWeightedVector<CvPlot *,100,1>::SortItems, COMDAT
; _this$ = ecx

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T262657[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T262661[ebp], eax
	mov	ecx, DWORD PTR $T262657[ebp]
	sub	ecx, DWORD PTR $T262661[ebp]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR $T262657[ebp]
	push	edx
	mov	eax, DWORD PTR $T262661[ebp]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?SortItems@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXXZ ENDP ; CvWeightedVector<CvPlot *,100,1>::SortItems
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@XZ PROC	; CvWeightedVector<CvCity *,64,1>::~CvWeightedVector<CvCity *,64,1>, COMDAT
; _this$ = ecx

; 58   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 	};

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@XZ ENDP	; CvWeightedVector<CvCity *,64,1>::~CvWeightedVector<CvCity *,64,1>
_TEXT	ENDS
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int>
; Function compile flags: /Odtp
;	COMDAT ?SortItems@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAEXXZ
_TEXT	SEGMENT
_this$ = -156						; size = 4
$T262879 = -8						; size = 4
$T262875 = -4						; size = 4
?SortItems@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAEXXZ PROC ; CvWeightedVector<CvCity *,64,1>::SortItems, COMDAT
; _this$ = ecx

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T262875[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T262879[ebp], eax
	mov	ecx, DWORD PTR $T262875[ebp]
	sub	ecx, DWORD PTR $T262879[ebp]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR $T262875[ebp]
	push	edx
	mov	eax, DWORD PTR $T262879[ebp]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?SortItems@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAEXXZ ENDP ; CvWeightedVector<CvCity *,64,1>::SortItems
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_List_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_List_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_List_val<int,std::allocator<int> >::~_List_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_List_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_List_val<int,std::allocator<int> >::~_List_val<int,std::allocator<int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~_Vector_val<CvHomelandTarget,std::allocator<CvHomelandTarget> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~_Vector_val<CvHomelandTarget,std::allocator<CvHomelandTarget> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::~_Vector_val<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::~_Vector_val<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::list<int,std::allocator<int> >::_Incsize
PUBLIC	?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z ; std::list<int,std::allocator<int> >::_Buynode
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?_Insert@?$list@HV?$allocator@H@std@@@std@@QAEXV?$_Const_iterator@$0A@@12@ABH@Z
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T263137 = -84						; size = 4
__Pnode$ = -8						; size = 4
__Newnode$ = -4						; size = 4
__Where$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Insert@?$list@HV?$allocator@H@std@@@std@@QAEXV?$_Const_iterator@$0A@@12@ABH@Z PROC ; std::list<int,std::allocator<int> >::_Insert, COMDAT
; _this$ = ecx

; 710  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	DWORD PTR _this$[ebp], ecx

; 711  : 
; 712  :  #if _HAS_ITERATOR_DEBUGGING
; 713  : 		if (_Where._Mycont != this)
; 714  : 			_DEBUG_ERROR("list insert iterator outside range");
; 715  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 716  : 
; 717  : 		_Nodeptr _Pnode = _Where._Mynode();

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 718  : 		_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z ; std::list<int,std::allocator<int> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 719  : 		_Incsize(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::list<int,std::allocator<int> >::_Incsize

; 720  : 		_Prevnode(_Pnode) = _Newnode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 721  : 		_Nextnode(_Prevnode(_Newnode)) = _Newnode;

	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T263137[ebp], edx
	mov	eax, DWORD PTR $T263137[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Insert@?$list@HV?$allocator@H@std@@@std@@QAEXV?$_Const_iterator@$0A@@12@ABH@Z ENDP ; std::list<int,std::allocator<int> >::_Insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T263205 = -20						; size = 4
$T263169 = -16						; size = 4
__Tmp$263151 = -12					; size = 4
$T263140 = -8						; size = 4
__Pnode$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z PROC ; std::list<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 786  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 787  : 
; 788  :  #if _HAS_ITERATOR_DEBUGGING
; 789  : 		if (_Where._Mycont != this || _Where._Ptr == _Myhead)
; 790  : 			_DEBUG_ERROR("list erase iterator outside range");
; 791  : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 792  : 		_Orphan_ptr(*this, _Pnode);
; 793  : 
; 794  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 795  : 		_Nodeptr _Pnode = (_Where++)._Mynode();

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Tmp$263151[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Where$[ebp], edx
	mov	eax, DWORD PTR __Tmp$263151[ebp]
	mov	DWORD PTR $T263140[ebp], eax
	mov	ecx, DWORD PTR $T263140[ebp]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 796  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 797  : 
; 798  : 		if (_Pnode != _Myhead)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	je	SHORT $LN1@erase@2

; 799  : 			{	// not list head, safe to erase
; 800  : 			_Nextnode(_Prevnode(_Pnode)) = _Nextnode(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T263169[ebp], edx
	mov	eax, DWORD PTR $T263169[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 801  : 			_Prevnode(_Nextnode(_Pnode)) = _Prevnode(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 802  : 			this->_Alnod.destroy(_Pnode);
; 803  : 			this->_Alnod.deallocate(_Pnode, 1);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 804  : 			--_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN1@erase@2:

; 805  : 			}
; 806  : 		return (_Make_iter(_Where));

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T263205[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR $T263205[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 807  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ENDP ; std::list<int,std::allocator<int> >::erase
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::allocate
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ$0
__unwindtable$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
xdata$x	ENDS
;	COMDAT ?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
tv157 = -84						; size = 4
tv152 = -80						; size = 4
_this$ = -76						; size = 4
$T263297 = -72						; size = 4
$T263282 = -68						; size = 4
$T263274 = -64						; size = 4
__Vptr$263280 = -60					; size = 4
$T263252 = -56						; size = 4
$T263244 = -52						; size = 4
__Vptr$263250 = -48					; size = 4
__Pnode$ = -24						; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ PROC ; std::list<int,std::allocator<int> >::_Buynode, COMDAT
; _this$ = ecx

; 1171 : 		{	// allocate a head node and set links

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1172 : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::allocate
	mov	DWORD PTR __Pnode$[ebp], eax

; 1173 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1174 : 
; 1175 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1176 : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR $T263252[ebp], eax
	mov	ecx, DWORD PTR $T263252[ebp]
	mov	DWORD PTR __Vptr$263250[ebp], ecx
	mov	edx, DWORD PTR __Vptr$263250[ebp]
	mov	DWORD PTR $T263244[ebp], edx
	cmp	DWORD PTR $T263244[ebp], 0
	je	SHORT $LN22@Buynode
	mov	eax, DWORD PTR $T263244[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T263244[ebp]
	mov	DWORD PTR tv152[ebp], edx
	jmp	SHORT $LN18@Buynode
$LN22@Buynode:
	mov	DWORD PTR tv152[ebp], 0
$LN18@Buynode:

; 1177 : 		++_Linkcnt;

	mov	eax, DWORD PTR __Linkcnt$[ebp]
	add	eax, 1
	mov	DWORD PTR __Linkcnt$[ebp], eax

; 1178 : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T263282[ebp], ecx
	mov	edx, DWORD PTR $T263282[ebp]
	mov	DWORD PTR __Vptr$263280[ebp], edx
	mov	eax, DWORD PTR __Vptr$263280[ebp]
	mov	DWORD PTR $T263274[ebp], eax
	cmp	DWORD PTR $T263274[ebp], 0
	je	SHORT $LN32@Buynode
	mov	ecx, DWORD PTR $T263274[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T263274[ebp]
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN28@Buynode
$LN32@Buynode:
	mov	DWORD PTR tv157[ebp], 0
$LN28@Buynode:
	jmp	SHORT $LN5@Buynode
__catch$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ$0:

; 1179 : 		_CATCH_ALL
; 1180 : 		if (0 < _Linkcnt)
; 1181 : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 1182 : 		this->_Alnod.deallocate(_Pnode, 1);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR $T263297[ebp], ecx
	mov	edx, DWORD PTR $T263297[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1183 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1184 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ$1
	ret	0
$LN5@Buynode:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ$1:

; 1185 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
$LN4@Buynode:

; 1186 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ ENDP ; std::list<int,std::allocator<int> >::_Buynode
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv179 = -44						; size = 4
_this$ = -40						; size = 4
$T263343 = -36						; size = 4
$T263342 = -32						; size = 4
_i$263335 = -28						; size = 4
$T263318 = -24						; size = 4
_pRet$263315 = -20					; size = 4
$T263309 = -16						; size = 4
_i$229051 = -12						; size = 4
_uiNewSize$229043 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$229043[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$229043[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$229043[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T263318[ebp], ecx
	cmp	DWORD PTR $T263318[ebp], 64		; 00000040H
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T263318[ebp]
	shl	edx, 4
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$263315[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T263318[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize
$LN15@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$263315[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 64			; 00000040H
$LN16@GrowSize:
	mov	ecx, DWORD PTR _pRet$263315[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$229051[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$229051[ebp]
	add	edx, 1
	mov	DWORD PTR _i$229051[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$229051[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$229051[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR $T263309[ebp], edx
	je	SHORT $LN12@GrowSize
	mov	eax, DWORD PTR _i$229051[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR $T263309[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T263309[ebp]
	mov	DWORD PTR tv179[ebp], eax
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv179[ebp], 0
$LN13@GrowSize:
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T263343[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T263342[ebp], ecx
	xor	edx, edx
	je	SHORT $LN21@GrowSize
	xor	eax, eax
	je	SHORT $LN21@GrowSize
	mov	DWORD PTR _i$263335[ebp], 0
	jmp	SHORT $LN26@GrowSize
$LN25@GrowSize:
	mov	ecx, DWORD PTR _i$263335[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$263335[ebp], ecx
$LN26@GrowSize:
	mov	edx, DWORD PTR _i$263335[ebp]
	cmp	edx, DWORD PTR $T263343[ebp]
	jae	SHORT $LN21@GrowSize
	jmp	SHORT $LN25@GrowSize
$LN21@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	cmp	DWORD PTR $T263342[ebp], eax
	je	SHORT $LN22@GrowSize
	mov	ecx, DWORD PTR $T263342[ebp]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], eax

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1036], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@VCvHomelandUnit@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@VCvHomelandUnit@@$00@@QAE@XZ PROC	; BaseVector<CvHomelandUnit,1>::~BaseVector<CvHomelandUnit,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@VCvHomelandUnit@@$00@@QAE@XZ ENDP	; BaseVector<CvHomelandUnit,1>::~BaseVector<CvHomelandUnit,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Copy@?$BaseVector@VCvHomelandUnit@@$00@@IAEXABV1@@Z
_TEXT	SEGMENT
tv84 = -16						; size = 4
_this$ = -12						; size = 4
$T263349 = -8						; size = 4
_i$229091 = -4						; size = 4
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@VCvHomelandUnit@@$00@@IAEXABV1@@Z PROC ; BaseVector<CvHomelandUnit,1>::Copy, COMDAT
; _this$ = ecx

; 229  : 	void Copy(const THIS_TYPE& RHS){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 231  : 		if( bPODType ){

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@Copy

; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);

	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 4
	push	edx
	mov	eax, DWORD PTR _RHS$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 233  : 		}else{

	jmp	SHORT $LN6@Copy
$LN5@Copy:

; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){

	mov	DWORD PTR _i$229091[ebp], 0
	jmp	SHORT $LN3@Copy
$LN2@Copy:
	mov	ecx, DWORD PTR _i$229091[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$229091[ebp], ecx
$LN3@Copy:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$229091[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN6@Copy

; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );

	mov	ecx, DWORD PTR _i$229091[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T263349[ebp], ecx
	je	SHORT $LN8@Copy
	mov	eax, DWORD PTR _i$229091[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR $T263349[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T263349[ebp]
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN9@Copy
$LN8@Copy:
	mov	DWORD PTR tv84[ebp], 0
$LN9@Copy:

; 236  : 			}

	jmp	SHORT $LN2@Copy
$LN6@Copy:

; 237  : 		}
; 238  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?Copy@?$BaseVector@VCvHomelandUnit@@$00@@IAEXABV1@@Z ENDP ; BaseVector<CvHomelandUnit,1>::Copy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv179 = -44						; size = 4
_this$ = -40						; size = 4
$T263391 = -36						; size = 4
$T263390 = -32						; size = 4
_i$263383 = -28						; size = 4
$T263366 = -24						; size = 4
_pRet$263363 = -20					; size = 4
$T263357 = -16						; size = 4
_i$229112 = -12						; size = 4
_uiNewSize$229104 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvHomelandMove,35,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@2

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$229104[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$229104[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@2

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@2
$LN6@GrowSize@2:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$229104[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@2
$LN7@GrowSize@2:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T263366[ebp], ecx
	cmp	DWORD PTR $T263366[ebp], 35		; 00000023H
	jbe	SHORT $LN15@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T263366[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$263363[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T263366[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize@2
$LN15@GrowSize@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$263363[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 35			; 00000023H
$LN16@GrowSize@2:
	mov	ecx, DWORD PTR _pRet$263363[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize@2

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@2
$LN5@GrowSize@2:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$229112[ebp], 0
	jmp	SHORT $LN3@GrowSize@2
$LN2@GrowSize@2:
	mov	edx, DWORD PTR _i$229112[ebp]
	add	edx, 1
	mov	DWORD PTR _i$229112[ebp], edx
$LN3@GrowSize@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$229112[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@2

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$229112[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T263357[ebp], ecx
	cmp	DWORD PTR $T263357[ebp], 0
	je	SHORT $LN12@GrowSize@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$229112[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	ecx, DWORD PTR $T263357[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T263357[ebp]
	mov	DWORD PTR tv179[ebp], edx
	jmp	SHORT $LN13@GrowSize@2
$LN12@GrowSize@2:
	mov	DWORD PTR tv179[ebp], 0
$LN13@GrowSize@2:
	jmp	SHORT $LN2@GrowSize@2
$LN4@GrowSize@2:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T263391[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T263390[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN21@GrowSize@2
	xor	edx, edx
	je	SHORT $LN21@GrowSize@2
	mov	DWORD PTR _i$263383[ebp], 0
	jmp	SHORT $LN26@GrowSize@2
$LN25@GrowSize@2:
	mov	eax, DWORD PTR _i$263383[ebp]
	add	eax, 1
	mov	DWORD PTR _i$263383[ebp], eax
$LN26@GrowSize@2:
	mov	ecx, DWORD PTR _i$263383[ebp]
	cmp	ecx, DWORD PTR $T263391[ebp]
	jae	SHORT $LN21@GrowSize@2
	jmp	SHORT $LN25@GrowSize@2
$LN21@GrowSize@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T263390[ebp], edx
	je	SHORT $LN22@GrowSize@2
	mov	eax, DWORD PTR $T263390[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize@2:

; 769  : 		m_pData = pTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], edx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+292], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvHomelandMove,35,1,297,0>::GrowSize
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_TEXT	ENDS
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@VCvHomelandMove@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@VCvHomelandMove@@$00@@QAE@XZ PROC	; BaseVector<CvHomelandMove,1>::~BaseVector<CvHomelandMove,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@VCvHomelandMove@@$00@@QAE@XZ ENDP	; BaseVector<CvHomelandMove,1>::~BaseVector<CvHomelandMove,1>
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Insert_n
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@ABVCvHomelandTarget@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$263456 = -24					; size = 4
$T263434 = -20						; size = 4
$T263415 = -16						; size = 4
$T263402 = -12						; size = 4
$T263399 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@ABVCvHomelandTarget@@@Z PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	test	eax, eax
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T263415[ebp], eax
	mov	ecx, DWORD PTR $T263415[ebp]
	mov	DWORD PTR $T263399[ebp], ecx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T263399[ebp]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], edx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T263434[ebp], eax
	mov	ecx, DWORD PTR $T263434[ebp]
	mov	DWORD PTR $T263402[ebp], ecx
	mov	edx, DWORD PTR $T263402[ebp]
	mov	DWORD PTR __Tmp$263456[ebp], edx
	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Tmp$263456[ebp]
	mov	DWORD PTR __Tmp$263456[ebp], eax
	mov	ecx, DWORD PTR __Tmp$263456[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@ABVCvHomelandTarget@@@Z ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T263598 = -64						; size = 4
$T263580 = -60						; size = 4
$T263579 = -56						; size = 4
$T263563 = -52						; size = 4
__Cat$263586 = -46					; size = 1
$T263583 = -45						; size = 1
$T263537 = -44						; size = 4
$T263536 = -40						; size = 4
$T263535 = -36						; size = 4
$T263518 = -30						; size = 1
$T263517 = -29						; size = 1
$T263516 = -28						; size = 4
$T263515 = -24						; size = 4
__Cat$263525 = -16					; size = 1
$T263522 = -15						; size = 1
$T263521 = -14						; size = 1
$T263520 = -13						; size = 1
__Ptr$229167 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0@Z PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase@3

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T263537[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T263536[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T263535[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T263520[ebp], cl
	mov	dl, BYTE PTR __Cat$263525[ebp]
	mov	BYTE PTR $T263521[ebp], dl
	mov	al, BYTE PTR $T263520[ebp]
	mov	BYTE PTR $T263518[ebp], al
	mov	cl, BYTE PTR $T263522[ebp]
	mov	BYTE PTR $T263517[ebp], cl
	mov	edx, DWORD PTR $T263537[ebp]
	mov	DWORD PTR $T263516[ebp], edx
	mov	eax, DWORD PTR $T263535[ebp]
	mov	DWORD PTR $T263515[ebp], eax
	jmp	SHORT $LN28@erase@3
$LN27@erase@3:
	mov	ecx, DWORD PTR $T263516[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T263516[ebp], ecx
	mov	edx, DWORD PTR $T263515[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T263515[ebp], edx
$LN28@erase@3:
	mov	eax, DWORD PTR $T263515[ebp]
	cmp	eax, DWORD PTR $T263536[ebp]
	je	SHORT $LN20@erase@3
	mov	ecx, DWORD PTR $T263515[ebp]
	mov	edx, DWORD PTR $T263516[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	jmp	SHORT $LN27@erase@3
$LN20@erase@3:
	mov	edx, DWORD PTR $T263516[ebp]
	mov	DWORD PTR __Ptr$229167[ebp], edx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T263598[ebp], ecx
	mov	edx, DWORD PTR $T263598[ebp]
	mov	DWORD PTR $T263580[ebp], edx
	mov	eax, DWORD PTR __Ptr$229167[ebp]
	mov	DWORD PTR $T263579[ebp], eax
	mov	cl, BYTE PTR __Cat$263586[ebp]
	mov	BYTE PTR $T263583[ebp], cl
	mov	edx, DWORD PTR $T263579[ebp]
	mov	DWORD PTR $T263563[ebp], edx
	jmp	SHORT $LN39@erase@3
$LN38@erase@3:
	mov	eax, DWORD PTR $T263563[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T263563[ebp], eax
$LN39@erase@3:
	mov	ecx, DWORD PTR $T263563[ebp]
	cmp	ecx, DWORD PTR $T263580[ebp]
	je	SHORT $LN31@erase@3
	jmp	SHORT $LN38@erase@3
$LN31@erase@3:

; 1049 : 			_Mylast = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$229167[ebp]
	mov	DWORD PTR [edx+8], eax
$LN1@erase@3:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0@Z ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@VCvHomelandTarget@@@std@@YAPAVCvHomelandTarget@@IPAV1@@Z ; std::_Allocate<CvHomelandTarget>
PUBLIC	?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$263616 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$263616[ebp], 214748364 ; 0cccccccH
	cmp	DWORD PTR __Count$263616[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$263616[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@VCvHomelandTarget@@@std@@YAPAVCvHomelandTarget@@IPAV1@@Z ; std::_Allocate<CvHomelandTarget>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T263709 = -32						; size = 4
$T263708 = -28						; size = 4
$T263704 = -24						; size = 4
$T263703 = -20						; size = 4
$T263685 = -16						; size = 4
$T263684 = -12						; size = 4
$T263668 = -8						; size = 4
__Cat$263691 = -2					; size = 1
$T263688 = -1						; size = 1
?_Tidy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXXZ PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T263704[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T263703[ebp], ecx
	mov	edx, DWORD PTR $T263704[ebp]
	mov	DWORD PTR $T263685[ebp], edx
	mov	eax, DWORD PTR $T263703[ebp]
	mov	DWORD PTR $T263684[ebp], eax
	mov	cl, BYTE PTR __Cat$263691[ebp]
	mov	BYTE PTR $T263688[ebp], cl
	mov	edx, DWORD PTR $T263684[ebp]
	mov	DWORD PTR $T263668[ebp], edx
	jmp	SHORT $LN12@Tidy
$LN11@Tidy:
	mov	eax, DWORD PTR $T263668[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T263668[ebp], eax
$LN12@Tidy:
	mov	ecx, DWORD PTR $T263668[ebp]
	cmp	ecx, DWORD PTR $T263685[ebp]
	je	SHORT $LN4@Tidy
	jmp	SHORT $LN11@Tidy
$LN4@Tidy:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR $T263709[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T263708[ebp], eax
	mov	ecx, DWORD PTR $T263708[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Tidy
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T263750 = -20						; size = 4
_i$263753 = -4						; size = 4
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z PROC ; FStaticVector<TradeConnection,168,0,297,0>::Free, COMDAT
; _this$ = ecx

; 809  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@Free
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN2@Free
	mov	DWORD PTR _i$263753[ebp], 0
	jmp	SHORT $LN7@Free
$LN6@Free:
	mov	edx, DWORD PTR _i$263753[ebp]
	add	edx, 1
	mov	DWORD PTR _i$263753[ebp], edx
$LN7@Free:
	mov	eax, DWORD PTR _i$263753[ebp]
	cmp	eax, DWORD PTR _uiNumElements$[ebp]
	jae	SHORT $LN2@Free
	mov	ecx, DWORD PTR _i$263753[ebp]
	imul	ecx, 444				; 000001bcH
	add	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR $T263750[ebp], ecx
	mov	ecx, DWORD PTR $T263750[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN12@Free
	mov	eax, DWORD PTR $T263750[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN12@Free:
	jmp	SHORT $LN6@Free
$LN2@Free:

; 811  : 		if( pVal != (T*)m_aData )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR _pVal$[ebp], ecx
	je	SHORT $LN3@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	mov	edx, DWORD PTR _pVal$[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN3@Free:

; 813  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z ENDP ; FStaticVector<TradeConnection,168,0,297,0>::Free
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ PROC	; BaseVector<TradeConnection,0>::~BaseVector<TradeConnection,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ ENDP	; BaseVector<TradeConnection,0>::~BaseVector<TradeConnection,0>
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@ABQAVCvPlot@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$263819 = -24					; size = 4
$T263802 = -20						; size = 4
$T263783 = -16						; size = 4
$T263770 = -12						; size = 4
$T263767 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@ABQAVCvPlot@@@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN3@insert@2
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T263783[ebp], ecx
	mov	edx, DWORD PTR $T263783[ebp]
	mov	DWORD PTR $T263767[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T263767[ebp]
	sar	eax, 2
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@2:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T263802[ebp], edx
	mov	eax, DWORD PTR $T263802[ebp]
	mov	DWORD PTR $T263770[ebp], eax
	mov	ecx, DWORD PTR $T263770[ebp]
	mov	DWORD PTR __Tmp$263819[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$263819[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$263819[ebp], ecx
	mov	edx, DWORD PTR __Tmp$263819[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@ABQAVCvPlot@@@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::insert
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);

	lea	eax, DWORD PTR _lpszFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Odtp
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T263852 = -2092					; size = 4
$T263851 = -2088					; size = 4
$T263850 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T263850[ebp], eax
	mov	ecx, DWORD PTR $T263850[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T263851[ebp], eax
	mov	eax, DWORD PTR $T263851[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T263852[ebp], eax
	mov	ecx, DWORD PTR $T263852[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z ; std::_Allocate<CvPlot *>
PUBLIC	?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$263867 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$263867[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$263867[ebp], 0
	jbe	SHORT $LN11@Buy@2
	mov	eax, DWORD PTR __Count$263867[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@2
$LN11@Buy@2:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@2:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@2:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z ; std::_Allocate<CvPlot *>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T263933 = -28						; size = 4
$T263932 = -24						; size = 4
$T263928 = -20						; size = 4
$T263927 = -16						; size = 4
$T263916 = -12						; size = 4
$T263915 = -8						; size = 4
__Cat$263924 = -2					; size = 1
$T263921 = -1						; size = 1
?_Tidy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXXZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T263928[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T263927[ebp], ecx
	mov	edx, DWORD PTR $T263928[ebp]
	mov	DWORD PTR $T263916[ebp], edx
	mov	eax, DWORD PTR $T263927[ebp]
	mov	DWORD PTR $T263915[ebp], eax
	mov	cl, BYTE PTR __Cat$263924[ebp]
	mov	BYTE PTR $T263921[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T263933[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T263932[ebp], eax
	mov	ecx, DWORD PTR $T263932[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Tidy
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QAE@XZ PROC ; BaseVector<std::pair<int,CvPlot *>,0>::~BaseVector<std::pair<int,CvPlot *>,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QAE@XZ ENDP ; BaseVector<std::pair<int,CvPlot *>,0>::~BaseVector<std::pair<int,CvPlot *>,0>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z
_TEXT	SEGMENT
tv185 = -48						; size = 4
_this$ = -44						; size = 4
$T263980 = -40						; size = 4
$T263979 = -36						; size = 4
_i$263970 = -32						; size = 4
$T263951 = -28						; size = 4
_pRet$263950 = -24					; size = 4
$T263938 = -20						; size = 4
_i$229287 = -16						; size = 4
_uiNewSize$229278 = -12					; size = 4
_nOld$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z PROC ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _nOld$[ebp], ecx

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN10@GrowSize@3
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1
$LN10@GrowSize@3:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jb	SHORT $LN9@GrowSize@3

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	DWORD PTR _uiNewSize$229278[ebp], ecx

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiNewSize$229278[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN8@GrowSize@3

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 433  : 				break;

	jmp	SHORT $LN9@GrowSize@3
$LN8@GrowSize@3:

; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$229278[ebp]
	mov	DWORD PTR [eax+8], ecx

; 438  : 		}

	jmp	SHORT $LN10@GrowSize@3
$LN9@GrowSize@3:

; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T263951[ebp], eax
	cmp	DWORD PTR $T263951[ebp], 0
	jbe	SHORT $LN16@GrowSize@3
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	ecx, DWORD PTR $T263951[ebp]
	shl	ecx, 3
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$263950[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T263951[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _pRet$263950[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx
	jmp	SHORT $LN17@GrowSize@3
$LN16@GrowSize@3:
	mov	DWORD PTR _pTemp$[ebp], 0
$LN17@GrowSize@3:

; 441  : 		if (pTemp)

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	$LN7@GrowSize@3

; 442  : 		{
; 443  : 			if( bPODType ){

	xor	edx, edx
	je	SHORT $LN6@GrowSize@3

; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 445  : 			}else{

	jmp	SHORT $LN5@GrowSize@3
$LN6@GrowSize@3:

; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$229287[ebp], 0
	jmp	SHORT $LN4@GrowSize@3
$LN3@GrowSize@3:
	mov	edx, DWORD PTR _i$229287[ebp]
	add	edx, 1
	mov	DWORD PTR _i$229287[ebp], edx
$LN4@GrowSize@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$229287[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN5@GrowSize@3

; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$229287[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T263938[ebp], ecx
	cmp	DWORD PTR $T263938[ebp], 0
	je	SHORT $LN14@GrowSize@3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$229287[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	ecx, DWORD PTR $T263938[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T263938[ebp]
	mov	DWORD PTR tv185[ebp], edx
	jmp	SHORT $LN15@GrowSize@3
$LN14@GrowSize@3:
	mov	DWORD PTR tv185[ebp], 0
$LN15@GrowSize@3:
	jmp	SHORT $LN3@GrowSize@3
$LN5@GrowSize@3:

; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T263980[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T263979[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN23@GrowSize@3
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN23@GrowSize@3
	mov	DWORD PTR _i$263970[ebp], 0
	jmp	SHORT $LN28@GrowSize@3
$LN27@GrowSize@3:
	mov	eax, DWORD PTR _i$263970[ebp]
	add	eax, 1
	mov	DWORD PTR _i$263970[ebp], eax
$LN28@GrowSize@3:
	mov	ecx, DWORD PTR _i$263970[ebp]
	cmp	ecx, DWORD PTR $T263980[ebp]
	jae	SHORT $LN23@GrowSize@3
	jmp	SHORT $LN27@GrowSize@3
$LN23@GrowSize@3:
	mov	edx, DWORD PTR $T263979[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 450  : 			m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 451  : 		}
; 452  : 		else

	jmp	SHORT $LN12@GrowSize@3
$LN7@GrowSize@3:

; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nOld$[ebp]
	mov	DWORD PTR [edx+8], eax
$LN12@GrowSize@3:

; 456  : 		}
; 457  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z ENDP ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Alloc@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEPAU?$pair@HPAVCvPlot@@@std@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pRet$229301 = -4					; size = 4
_uiSize$ = 8						; size = 4
?Alloc@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEPAU?$pair@HPAVCvPlot@@@std@@I@Z PROC ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::Alloc, COMDAT
; _this$ = ecx

; 503  : 	T* Alloc( unsigned int uiSize ){

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 504  : 		if( uiSize > 0 ){

	cmp	DWORD PTR _uiSize$[ebp], 0
	jbe	SHORT $LN1@Alloc

; 505  :             
; 506  :             T* pRet = (T*)FAST_VEC_ALLOC::AllocAligned( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR _uiSize$[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$229301[ebp], eax

; 507  : 			m_uiCurrMaxSize = uiSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiSize$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 508  : 			return pRet;

	mov	eax, DWORD PTR _pRet$229301[ebp]
	jmp	SHORT $LN2@Alloc
$LN1@Alloc:

; 509  : 		}
; 510  : 		return NULL;

	xor	eax, eax
$LN2@Alloc:

; 511  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?Alloc@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEPAU?$pair@HPAVCvPlot@@@std@@I@Z ENDP ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::Alloc
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$264040 = -24					; size = 4
$T264023 = -20						; size = 4
$T264004 = -16						; size = 4
$T263991 = -12						; size = 4
$T263988 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN3@insert@3
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T264004[ebp], ecx
	mov	edx, DWORD PTR $T264004[ebp]
	mov	DWORD PTR $T263988[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T263988[ebp]
	sar	eax, 2
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@3:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T264023[ebp], edx
	mov	eax, DWORD PTR $T264023[ebp]
	mov	DWORD PTR $T263991[ebp], eax
	mov	ecx, DWORD PTR $T263991[ebp]
	mov	DWORD PTR __Tmp$264040[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$264040[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$264040[ebp], ecx
	mov	edx, DWORD PTR __Tmp$264040[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::insert
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
PUBLIC	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$264060 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@3

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@3
	jmp	SHORT $LN3@Buy@3
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$264060[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$264060[ebp], 0
	jbe	SHORT $LN11@Buy@3
	mov	eax, DWORD PTR __Count$264060[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@3
$LN11@Buy@3:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@3:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@3

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@3:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@3:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@3:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T264126 = -28						; size = 4
$T264125 = -24						; size = 4
$T264121 = -20						; size = 4
$T264120 = -16						; size = 4
$T264109 = -12						; size = 4
$T264108 = -8						; size = 4
__Cat$264116 = -2					; size = 1
$T264114 = -1						; size = 1
?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T264121[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T264120[ebp], ecx
	mov	edx, DWORD PTR $T264121[ebp]
	mov	DWORD PTR $T264109[ebp], edx
	mov	eax, DWORD PTR $T264120[ebp]
	mov	DWORD PTR $T264108[ebp], eax
	mov	cl, BYTE PTR __Cat$264116[ebp]
	mov	BYTE PTR $T264114[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T264126[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T264125[ebp], eax
	mov	ecx, DWORD PTR $T264125[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T264139 = -20						; size = 4
_pRet$264135 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 100			; 00000064H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T264139[ebp], edx
	cmp	DWORD PTR $T264139[ebp], 100		; 00000064H
	jbe	SHORT $LN7@FStaticVec@6
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T264139[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$264135[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T264139[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@6
$LN7@FStaticVec@6:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$264135[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 100			; 00000064H
$LN8@FStaticVec@6:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$264135[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>
__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T264170 = -24						; size = 4
$T264169 = -20						; size = 4
_i$264164 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T264170[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T264169[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@7
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@7
	mov	DWORD PTR _i$264164[ebp], 0
	jmp	SHORT $LN10@FStaticVec@7
$LN9@FStaticVec@7:
	mov	eax, DWORD PTR _i$264164[ebp]
	add	eax, 1
	mov	DWORD PTR _i$264164[ebp], eax
$LN10@FStaticVec@7:
	mov	ecx, DWORD PTR _i$264164[ebp]
	cmp	ecx, DWORD PTR $T264170[ebp]
	jae	SHORT $LN5@FStaticVec@7
	jmp	SHORT $LN9@FStaticVec@7
$LN5@FStaticVec@7:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T264169[ebp], edx
	je	SHORT $LN1@FStaticVec@7
	mov	eax, DWORD PTR $T264169[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@7:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>
__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@Z
_TEXT	SEGMENT
tv157 = -64						; size = 4
tv149 = -60						; size = 4
_this$ = -56						; size = 4
$T264183 = -8						; size = 4
$T264182 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+812], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN39@push_back@7

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back@7:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T264183[ebp], ecx
	cmp	DWORD PTR $T264183[ebp], 0
	je	SHORT $LN4@push_back@7
	mov	edx, DWORD PTR $T264183[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T264183[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR $T264183[ebp]
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN5@push_back@7
$LN4@push_back@7:
	mov	DWORD PTR tv149[ebp], 0
$LN5@push_back@7:
	mov	eax, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T264182[ebp], eax

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv157[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv157[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T264247 = -20						; size = 4
_pRet$264244 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 64			; 00000040H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T264247[ebp], edx
	cmp	DWORD PTR $T264247[ebp], 64		; 00000040H
	jbe	SHORT $LN7@FStaticVec@8
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T264247[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$264244[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T264247[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@8
$LN7@FStaticVec@8:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$264244[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 64			; 00000040H
$LN8@FStaticVec@8:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$264244[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>
__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T264278 = -24						; size = 4
$T264277 = -20						; size = 4
_i$264270 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T264278[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T264277[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@9
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@9
	mov	DWORD PTR _i$264270[ebp], 0
	jmp	SHORT $LN10@FStaticVec@9
$LN9@FStaticVec@9:
	mov	eax, DWORD PTR _i$264270[ebp]
	add	eax, 1
	mov	DWORD PTR _i$264270[ebp], eax
$LN10@FStaticVec@9:
	mov	ecx, DWORD PTR _i$264270[ebp]
	cmp	ecx, DWORD PTR $T264278[ebp]
	jae	SHORT $LN5@FStaticVec@9
	jmp	SHORT $LN9@FStaticVec@9
$LN5@FStaticVec@9:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T264277[ebp], edx
	je	SHORT $LN1@FStaticVec@9
	mov	eax, DWORD PTR $T264277[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@9:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>
__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@Z
_TEXT	SEGMENT
tv157 = -64						; size = 4
tv149 = -60						; size = 4
_this$ = -56						; size = 4
$T264291 = -8						; size = 4
$T264290 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@Z PROC ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+524], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN39@push_back@8

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back@8:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T264291[ebp], ecx
	cmp	DWORD PTR $T264291[ebp], 0
	je	SHORT $LN4@push_back@8
	mov	edx, DWORD PTR $T264291[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T264291[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR $T264291[ebp]
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN5@push_back@8
$LN4@push_back@8:
	mov	DWORD PTR tv149[ebp], 0
$LN5@push_back@8:
	mov	eax, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T264290[ebp], eax

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv157[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv157[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::push_back
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z$0
__unwindtable$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z$2
__ehfuncinfo$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
xdata$x	ENDS
;	COMDAT ?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z
_TEXT	SEGMENT
tv72 = -84						; size = 4
tv178 = -80						; size = 4
tv173 = -76						; size = 4
_this$ = -72						; size = 4
$T264439 = -68						; size = 4
__Vptr$264445 = -64					; size = 4
$T264411 = -60						; size = 4
__Vptr$264417 = -56					; size = 4
$T264382 = -52						; size = 4
__Vptr$264388 = -48					; size = 4
__Pnode$ = -24						; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z PROC ; std::list<int,std::allocator<int> >::_Buynode, COMDAT
; _this$ = ecx

; 1190 : 		{	// allocate a node and set links and value

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1191 : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::allocate
	mov	DWORD PTR __Pnode$[ebp], eax

; 1192 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1193 : 
; 1194 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1195 : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Next);

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Vptr$264388[ebp], eax
	mov	ecx, DWORD PTR __Vptr$264388[ebp]
	mov	DWORD PTR $T264382[ebp], ecx
	cmp	DWORD PTR $T264382[ebp], 0
	je	SHORT $LN23@Buynode@2
	mov	edx, DWORD PTR $T264382[ebp]
	mov	eax, DWORD PTR __Next$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T264382[ebp]
	mov	DWORD PTR tv173[ebp], ecx
	jmp	SHORT $LN19@Buynode@2
$LN23@Buynode@2:
	mov	DWORD PTR tv173[ebp], 0
$LN19@Buynode@2:

; 1196 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1197 : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Prev);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4
	mov	DWORD PTR __Vptr$264417[ebp], eax
	mov	ecx, DWORD PTR __Vptr$264417[ebp]
	mov	DWORD PTR $T264411[ebp], ecx
	cmp	DWORD PTR $T264411[ebp], 0
	je	SHORT $LN33@Buynode@2
	mov	edx, DWORD PTR $T264411[ebp]
	mov	eax, DWORD PTR __Prev$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T264411[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	jmp	SHORT $LN29@Buynode@2
$LN33@Buynode@2:
	mov	DWORD PTR tv178[ebp], 0
$LN29@Buynode@2:

; 1198 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1199 : 		this->_Alval.construct(&_Myval(_Pnode), _Val);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8
	mov	DWORD PTR __Vptr$264445[ebp], eax
	mov	ecx, DWORD PTR __Vptr$264445[ebp]
	mov	DWORD PTR $T264439[ebp], ecx
	cmp	DWORD PTR $T264439[ebp], 0
	je	SHORT $LN43@Buynode@2
	mov	edx, DWORD PTR $T264439[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T264439[ebp]
	mov	DWORD PTR tv72[ebp], edx
	jmp	SHORT $LN39@Buynode@2
$LN43@Buynode@2:
	mov	DWORD PTR tv72[ebp], 0
$LN39@Buynode@2:
	jmp	SHORT $LN6@Buynode@2
__catch$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z$0:

; 1200 : 		_CATCH_ALL
; 1201 : 		if (1 < _Linkcnt)
; 1202 : 			this->_Alptr.destroy(&_Prevnode(_Pnode));
; 1203 : 		if (0 < _Linkcnt)
; 1204 : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 1205 : 		this->_Alnod.deallocate(_Pnode, 1);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1206 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1207 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z$1
	ret	0
$LN6@Buynode@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z$1:

; 1208 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
$LN5@Buynode@2:

; 1209 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z ENDP ; std::list<int,std::allocator<int> >::_Buynode
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
xdata$x	ENDS
;	COMDAT ?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
tv89 = -92						; size = 4
_this$ = -88						; size = 4
__Count$264500 = -84					; size = 4
$T264484 = -80						; size = 28
$T264483 = -52						; size = 40
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z PROC ; std::list<int,std::allocator<int> >::_Incsize, COMDAT
; _this$ = ecx

; 1239 : 		{	// alter element count, with checking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1240 : 		if (max_size() - _Mysize < _Count)

	mov	DWORD PTR __Count$264500[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$264500[ebp], 0
	jbe	SHORT $LN9@Incsize
	mov	eax, DWORD PTR __Count$264500[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN5@Incsize
$LN9@Incsize:
	mov	DWORD PTR tv89[ebp], 1
$LN5@Incsize:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv89[ebp]
	sub	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Incsize

; 1241 : 			_THROW(length_error, "list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T264484[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T264483[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T264483[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T264484[ebp]
	push	eax
	lea	ecx, DWORD PTR $T264483[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T264483[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T264483[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T264484[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@Incsize:

; 1242 : 		_Mysize += _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN3@Incsize:

; 1243 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z$0:
	lea	ecx, DWORD PTR $T264484[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z$2:
	lea	ecx, DWORD PTR $T264483[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z ENDP ; std::list<int,std::allocator<int> >::_Incsize
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??$_Allocate@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<int,std::allocator<int> >::_Node>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z PROC ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<int,std::allocator<int> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@stdext@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z$0
__unwindtable$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z
_TEXT	SEGMENT
tv84 = -456						; size = 4
tv304 = -452						; size = 4
tv290 = -448						; size = 4
tv282 = -444						; size = 4
_this$ = -440						; size = 4
$T265242 = -436						; size = 4
$T265234 = -432						; size = 4
$T265233 = -428						; size = 4
$T265210 = -422						; size = 1
$T265209 = -421						; size = 1
$T265208 = -420						; size = 4
$T265207 = -416						; size = 4
$T265195 = -409						; size = 1
$T265194 = -408						; size = 4
$T265193 = -404						; size = 4
$T265192 = -400						; size = 4
__Cat$265227 = -396					; size = 1
$T265225 = -395						; size = 1
$T265224 = -394						; size = 1
__Cat$265217 = -392					; size = 1
$T265215 = -391						; size = 1
$T265214 = -390						; size = 1
$T265213 = -389						; size = 1
$T265167 = -388						; size = 4
$T265148 = -384						; size = 4
$T265131 = -377						; size = 1
$T265130 = -376						; size = 4
$T265120 = -372						; size = 4
$T265119 = -368						; size = 4
__Cat$265164 = -362					; size = 1
$T265162 = -361						; size = 1
$T265161 = -360						; size = 1
__Cat$265155 = -359					; size = 1
$T265153 = -358						; size = 1
$T265152 = -357						; size = 1
$T265095 = -356						; size = 4
$T265087 = -352						; size = 4
$T265079 = -348						; size = 4
$T265061 = -344						; size = 4
$T265060 = -340						; size = 4
$T265044 = -336						; size = 4
__Cat$265067 = -330					; size = 1
$T265065 = -329						; size = 1
$T265018 = -328						; size = 4
$T265017 = -324						; size = 4
$T265007 = -320						; size = 4
__Cat$265013 = -315					; size = 1
$T265011 = -314						; size = 1
$T265010 = -313						; size = 1
$T264991 = -312						; size = 4
$T264972 = -308						; size = 4
$T264955 = -301						; size = 1
$T264954 = -300						; size = 4
$T264944 = -296						; size = 4
$T264943 = -292						; size = 4
__Cat$264987 = -286					; size = 1
$T264985 = -285						; size = 1
$T264984 = -284						; size = 1
__Cat$264979 = -283					; size = 1
$T264976 = -282						; size = 1
$T264975 = -281						; size = 1
$T264919 = -280						; size = 4
$T264918 = -276						; size = 4
$T264914 = -272						; size = 4
$T264913 = -268						; size = 4
$T264895 = -264						; size = 4
$T264894 = -260						; size = 4
$T264878 = -256						; size = 4
__Cat$264900 = -250					; size = 1
$T264898 = -249						; size = 1
$T264829 = -248						; size = 4
$T264828 = -244						; size = 4
$T264812 = -240						; size = 4
__Cat$264835 = -234					; size = 1
$T264832 = -233						; size = 1
$T264769 = -232						; size = 4
$T264768 = -228						; size = 4
$T264752 = -224						; size = 4
__Cat$264775 = -218					; size = 1
$T264772 = -217						; size = 1
$T264726 = -216						; size = 4
$T264714 = -212						; size = 4
$T264704 = -205						; size = 1
$T264703 = -204						; size = 4
__Cat$264721 = -199					; size = 1
$T264718 = -198						; size = 1
$T264717 = -197						; size = 1
$T264691 = -196						; size = 4
$T264679 = -192						; size = 4
$T264669 = -185						; size = 1
$T264668 = -184						; size = 4
__Cat$264686 = -179					; size = 1
$T264683 = -178						; size = 1
$T264682 = -177						; size = 1
$T264656 = -176						; size = 4
$T264646 = -172						; size = 4
__Cat$264653 = -167					; size = 1
$T264650 = -166						; size = 1
$T264649 = -165						; size = 1
__Count$264619 = -152					; size = 4
__Count$264593 = -80					; size = 4
__Tmp$229531 = -76					; size = 20
__Oldend$229532 = -56					; size = 4
__Tmp$229521 = -52					; size = 20
__Ncopied$229508 = -32					; size = 4
__Newvec$229506 = -28					; size = 4
__Whereoff$229507 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 440				; 000001b8H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n
	mov	DWORD PTR tv282[ebp], 0
	jmp	SHORT $LN27@Insert_n
$LN29@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR tv282[ebp], eax
$LN27@Insert_n:
	mov	edx, DWORD PTR tv282[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$264593[ebp], 214748364 ; 0cccccccH
	cmp	DWORD PTR __Count$264593[ebp], 0
	jbe	SHORT $LN35@Insert_n
	mov	eax, DWORD PTR __Count$264593[ebp]
	mov	DWORD PTR tv290[ebp], eax
	jmp	SHORT $LN37@Insert_n
$LN35@Insert_n:
	mov	DWORD PTR tv290[ebp], 1
$LN37@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	edx, DWORD PTR tv290[ebp]
	sub	edx, eax
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$264619[ebp], 214748364 ; 0cccccccH
	cmp	DWORD PTR __Count$264619[ebp], 0
	jbe	SHORT $LN48@Insert_n
	mov	edx, DWORD PTR __Count$264619[ebp]
	mov	DWORD PTR tv304[ebp], edx
	jmp	SHORT $LN44@Insert_n
$LN48@Insert_n:
	mov	DWORD PTR tv304[ebp], 1
$LN44@Insert_n:
	mov	eax, DWORD PTR __Capacity$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR tv304[ebp]
	sub	ecx, eax
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN54@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@VCvHomelandTarget@@@std@@YAPAVCvHomelandTarget@@IPAV1@@Z ; std::_Allocate<CvHomelandTarget>
	add	esp, 8
	mov	DWORD PTR __Newvec$229506[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR __Whereoff$229507[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$229508[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Whereoff$229507[ebp]
	imul	edx, 20					; 00000014H
	add	edx, DWORD PTR __Newvec$229506[ebp]
	mov	DWORD PTR $T264656[ebp], edx
	mov	eax, DWORD PTR $T264656[ebp]
	mov	DWORD PTR $T264646[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T264649[ebp], cl
	mov	dl, BYTE PTR __Cat$264653[ebp]
	mov	BYTE PTR $T264650[ebp], dl
	movzx	eax, BYTE PTR $T264649[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T264650[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T264646[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvHomelandTarget *,unsigned int,CvHomelandTarget,std::allocator<CvHomelandTarget> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$229508[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$229508[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T264691[ebp], edx
	mov	eax, DWORD PTR __Newvec$229506[ebp]
	mov	DWORD PTR $T264679[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T264682[ebp], cl
	mov	dl, BYTE PTR __Cat$264686[ebp]
	mov	BYTE PTR $T264683[ebp], dl
	mov	al, BYTE PTR $T264682[ebp]
	mov	BYTE PTR $T264669[ebp], al
	mov	ecx, DWORD PTR $T264679[ebp]
	mov	DWORD PTR $T264668[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T264668[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T264691[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@stdext@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$229508[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$229508[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T264726[ebp], edx
	mov	eax, DWORD PTR __Whereoff$229507[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Newvec$229506[ebp]
	mov	DWORD PTR $T264714[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T264717[ebp], cl
	mov	dl, BYTE PTR __Cat$264721[ebp]
	mov	BYTE PTR $T264718[ebp], dl
	mov	al, BYTE PTR $T264717[ebp]
	mov	BYTE PTR $T264704[ebp], al
	mov	ecx, DWORD PTR $T264714[ebp]
	mov	DWORD PTR $T264703[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T264703[ebp]
	push	eax
	mov	ecx, DWORD PTR $T264726[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@stdext@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$229508[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$229507[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Newvec$229506[ebp]
	mov	DWORD PTR $T264769[ebp], eax
	mov	ecx, DWORD PTR __Newvec$229506[ebp]
	mov	DWORD PTR $T264768[ebp], ecx
	mov	dl, BYTE PTR __Cat$264775[ebp]
	mov	BYTE PTR $T264772[ebp], dl
	mov	eax, DWORD PTR $T264768[ebp]
	mov	DWORD PTR $T264752[ebp], eax
	jmp	SHORT $LN91@Insert_n
$LN90@Insert_n:
	mov	ecx, DWORD PTR $T264752[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T264752[ebp], ecx
$LN91@Insert_n:
	mov	edx, DWORD PTR $T264752[ebp]
	cmp	edx, DWORD PTR $T264769[ebp]
	je	SHORT $LN7@Insert_n
	jmp	SHORT $LN90@Insert_n
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$229508[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR __Whereoff$229507[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR __Newvec$229506[ebp]
	add	ecx, eax
	mov	DWORD PTR $T264829[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$229507[ebp]
	imul	edx, 20					; 00000014H
	add	edx, DWORD PTR __Newvec$229506[ebp]
	mov	DWORD PTR $T264828[ebp], edx
	mov	al, BYTE PTR __Cat$264835[ebp]
	mov	BYTE PTR $T264832[ebp], al
	mov	ecx, DWORD PTR $T264828[ebp]
	mov	DWORD PTR $T264812[ebp], ecx
	jmp	SHORT $LN106@Insert_n
$LN105@Insert_n:
	mov	edx, DWORD PTR $T264812[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T264812[ebp], edx
$LN106@Insert_n:
	mov	eax, DWORD PTR $T264812[ebp]
	cmp	eax, DWORD PTR $T264829[ebp]
	je	SHORT $LN6@Insert_n
	jmp	SHORT $LN105@Insert_n
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$229506[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN115@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN115@Insert_n:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T264914[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T264913[ebp], eax
	mov	ecx, DWORD PTR $T264914[ebp]
	mov	DWORD PTR $T264895[ebp], ecx
	mov	edx, DWORD PTR $T264913[ebp]
	mov	DWORD PTR $T264894[ebp], edx
	mov	al, BYTE PTR __Cat$264900[ebp]
	mov	BYTE PTR $T264898[ebp], al
	mov	ecx, DWORD PTR $T264894[ebp]
	mov	DWORD PTR $T264878[ebp], ecx
	jmp	SHORT $LN125@Insert_n
$LN124@Insert_n:
	mov	edx, DWORD PTR $T264878[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T264878[ebp], edx
$LN125@Insert_n:
	mov	eax, DWORD PTR $T264878[ebp]
	cmp	eax, DWORD PTR $T264895[ebp]
	je	SHORT $LN117@Insert_n
	jmp	SHORT $LN124@Insert_n
$LN117@Insert_n:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR $T264919[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T264918[ebp], eax
	mov	ecx, DWORD PTR $T264918[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 20					; 00000014H
	add	edx, DWORD PTR __Newvec$229506[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR __Newvec$229506[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$229506[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$229521[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$229521[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$229521[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$229521[ebp+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR __Tmp$229521[ebp+16], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T264991[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 20					; 00000014H
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T264972[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T264975[ebp], al
	mov	cl, BYTE PTR __Cat$264979[ebp]
	mov	BYTE PTR $T264976[ebp], cl
	mov	dl, BYTE PTR $T264975[ebp]
	mov	BYTE PTR $T264955[ebp], dl
	mov	eax, DWORD PTR $T264972[ebp]
	mov	DWORD PTR $T264954[ebp], eax
	mov	ecx, DWORD PTR $T264954[ebp]
	mov	DWORD PTR $T264944[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T264943[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T264984[ebp], al
	mov	cl, BYTE PTR __Cat$264987[ebp]
	mov	BYTE PTR $T264985[ebp], cl
	movzx	edx, BYTE PTR $T264984[ebp]
	push	edx
	movzx	eax, BYTE PTR $T264985[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T264944[ebp]
	push	edx
	mov	eax, DWORD PTR $T264991[ebp]
	push	eax
	mov	ecx, DWORD PTR $T264943[ebp]
	push	ecx
	call	??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	mov	DWORD PTR $T265018[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T265017[ebp], ecx
	mov	edx, DWORD PTR $T265017[ebp]
	mov	DWORD PTR $T265007[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T265010[ebp], al
	mov	cl, BYTE PTR __Cat$265013[ebp]
	mov	BYTE PTR $T265011[ebp], cl
	movzx	edx, BYTE PTR $T265010[ebp]
	push	edx
	movzx	eax, BYTE PTR $T265011[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Tmp$229521[ebp]
	push	edx
	mov	eax, DWORD PTR $T265018[ebp]
	push	eax
	mov	ecx, DWORD PTR $T265007[ebp]
	push	ecx
	call	??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvHomelandTarget *,unsigned int,CvHomelandTarget,std::allocator<CvHomelandTarget> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T265079[ebp], edx
	mov	ecx, DWORD PTR $T265079[ebp]
	mov	DWORD PTR $T265061[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 20					; 00000014H
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T265060[ebp], edx
	mov	al, BYTE PTR __Cat$265067[ebp]
	mov	BYTE PTR $T265065[ebp], al
	mov	ecx, DWORD PTR $T265060[ebp]
	mov	DWORD PTR $T265044[ebp], ecx
	jmp	SHORT $LN160@Insert_n
$LN159@Insert_n:
	mov	edx, DWORD PTR $T265044[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T265044[ebp], edx
$LN160@Insert_n:
	mov	eax, DWORD PTR $T265044[ebp]
	cmp	eax, DWORD PTR $T265061[ebp]
	je	SHORT $LN152@Insert_n
	jmp	SHORT $LN159@Insert_n
$LN152@Insert_n:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, ecx
	mov	DWORD PTR $T265095[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T265087[ebp], ecx
	jmp	SHORT $LN171@Insert_n
$LN170@Insert_n:
	mov	edx, DWORD PTR $T265087[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T265087[ebp], edx
$LN171@Insert_n:
	mov	eax, DWORD PTR $T265087[ebp]
	cmp	eax, DWORD PTR $T265095[ebp]
	je	SHORT $LN167@Insert_n
	mov	ecx, DWORD PTR $T265087[ebp]
	mov	edx, DWORD PTR __Tmp$229521[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$229521[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Tmp$229521[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Tmp$229521[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR __Tmp$229521[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	jmp	SHORT $LN170@Insert_n
$LN167@Insert_n:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$229531[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$229531[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$229531[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$229531[ebp+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR __Tmp$229531[ebp+16], eax

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Oldend$229532[ebp], edx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T265167[ebp], ecx
	mov	edx, DWORD PTR $T265167[ebp]
	mov	DWORD PTR $T265148[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T265152[ebp], al
	mov	cl, BYTE PTR __Cat$265155[ebp]
	mov	BYTE PTR $T265153[ebp], cl
	mov	dl, BYTE PTR $T265152[ebp]
	mov	BYTE PTR $T265131[ebp], dl
	mov	eax, DWORD PTR $T265148[ebp]
	mov	DWORD PTR $T265130[ebp], eax
	mov	ecx, DWORD PTR $T265130[ebp]
	mov	DWORD PTR $T265120[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR __Oldend$229532[ebp]
	sub	eax, edx
	mov	DWORD PTR $T265119[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T265161[ebp], cl
	mov	dl, BYTE PTR __Cat$265164[ebp]
	mov	BYTE PTR $T265162[ebp], dl
	movzx	eax, BYTE PTR $T265161[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T265162[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T265120[ebp]
	push	eax
	mov	ecx, DWORD PTR __Oldend$229532[ebp]
	push	ecx
	mov	edx, DWORD PTR $T265119[ebp]
	push	edx
	call	??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$229532[ebp]
	mov	DWORD PTR $T265234[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T265233[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T265213[ebp], cl
	mov	dl, BYTE PTR __Cat$265217[ebp]
	mov	BYTE PTR $T265214[ebp], dl
	mov	al, BYTE PTR $T265213[ebp]
	mov	BYTE PTR $T265210[ebp], al
	mov	cl, BYTE PTR $T265215[ebp]
	mov	BYTE PTR $T265209[ebp], cl
	mov	edx, DWORD PTR $T265234[ebp]
	mov	DWORD PTR $T265208[ebp], edx
	mov	eax, DWORD PTR $T265233[ebp]
	mov	DWORD PTR $T265207[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T265224[ebp], cl
	mov	dl, BYTE PTR __Cat$265227[ebp]
	mov	BYTE PTR $T265225[ebp], dl
	mov	al, BYTE PTR $T265224[ebp]
	mov	BYTE PTR $T265195[ebp], al
	mov	ecx, DWORD PTR $T265208[ebp]
	mov	DWORD PTR $T265194[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR __Oldend$229532[ebp]
	sub	eax, edx
	mov	DWORD PTR $T265193[ebp], eax
	mov	ecx, DWORD PTR $T265207[ebp]
	mov	DWORD PTR $T265192[ebp], ecx
$LN197@Insert_n:
	mov	edx, DWORD PTR $T265192[ebp]
	cmp	edx, DWORD PTR $T265193[ebp]
	je	SHORT $LN186@Insert_n
	mov	eax, DWORD PTR $T265193[ebp]
	sub	eax, 20					; 00000014H
	mov	DWORD PTR $T265193[ebp], eax
	mov	ecx, DWORD PTR $T265194[ebp]
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR $T265194[ebp], ecx
	mov	edx, DWORD PTR $T265193[ebp]
	mov	eax, DWORD PTR $T265194[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	jmp	SHORT $LN197@Insert_n
$LN186@Insert_n:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T265242[ebp], eax
	jmp	SHORT $LN204@Insert_n
$LN203@Insert_n:
	mov	ecx, DWORD PTR $T265242[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T265242[ebp], ecx
$LN204@Insert_n:
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 20					; 00000014H
	add	edx, DWORD PTR __Where$[ebp]
	cmp	DWORD PTR $T265242[ebp], edx
	je	SHORT $LN16@Insert_n
	mov	eax, DWORD PTR $T265242[ebp]
	mov	ecx, DWORD PTR __Tmp$229531[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$229531[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Tmp$229531[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Tmp$229531[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR __Tmp$229531[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	jmp	SHORT $LN203@Insert_n
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-460]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Insert_n
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T265264 = -80						; size = 28
$T265263 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T265264[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T265263[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T265263[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T265264[ebp]
	push	eax
	lea	ecx, DWORD PTR $T265263[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T265263[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T265263[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T265264[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T265264[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T265263[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Xlen
PUBLIC	??$_Unchecked_move_backward@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvPlot * *,CvPlot * *>
PUBLIC	?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Ufill
PUBLIC	??$_Uninit_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
PUBLIC	??$unchecked_uninitialized_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z$2
__catchsym$?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z$0
__unwindtable$?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv302 = -428						; size = 4
tv288 = -424						; size = 4
tv280 = -420						; size = 4
_this$ = -416						; size = 4
$T265836 = -412						; size = 4
$T265784 = -368						; size = 4
$T265772 = -364						; size = 4
$T265762 = -357						; size = 1
$T265761 = -356						; size = 4
__Cat$265780 = -327					; size = 1
$T265777 = -326						; size = 1
$T265776 = -325						; size = 1
$T265733 = -324						; size = 4
$T265725 = -320						; size = 4
$T265717 = -316						; size = 4
$T265706 = -312						; size = 4
$T265705 = -308						; size = 4
__Cat$265714 = -302					; size = 1
$T265711 = -301						; size = 1
$T265634 = -276						; size = 4
$T265615 = -272						; size = 4
$T265598 = -265						; size = 1
$T265597 = -264						; size = 4
$T265587 = -260						; size = 4
$T265586 = -256						; size = 4
__Cat$265630 = -250					; size = 1
$T265627 = -249						; size = 1
$T265626 = -248						; size = 1
__Cat$265623 = -247					; size = 1
$T265620 = -246						; size = 1
$T265619 = -245						; size = 1
$T265562 = -244						; size = 4
$T265561 = -240						; size = 4
$T265557 = -236						; size = 4
$T265556 = -232						; size = 4
$T265545 = -228						; size = 4
$T265544 = -224						; size = 4
__Cat$265553 = -218					; size = 1
$T265550 = -217						; size = 1
$T265509 = -216						; size = 4
$T265508 = -212						; size = 4
__Cat$265517 = -206					; size = 1
$T265514 = -205						; size = 1
$T265479 = -204						; size = 4
$T265478 = -200						; size = 4
__Cat$265487 = -194					; size = 1
$T265484 = -193						; size = 1
$T265459 = -192						; size = 4
$T265447 = -188						; size = 4
$T265437 = -181						; size = 1
$T265436 = -180						; size = 4
__Cat$265455 = -175					; size = 1
$T265452 = -174						; size = 1
$T265451 = -173						; size = 1
$T265424 = -172						; size = 4
$T265412 = -168						; size = 4
$T265402 = -161						; size = 1
$T265401 = -160						; size = 4
__Cat$265420 = -155					; size = 1
$T265417 = -154						; size = 1
$T265416 = -153						; size = 1
$T265389 = -152						; size = 4
$T265377 = -148						; size = 4
$T265367 = -141						; size = 1
$T265366 = -140						; size = 4
__Cat$265384 = -135					; size = 1
$T265381 = -134						; size = 1
$T265380 = -133						; size = 1
__Count$265342 = -120					; size = 4
__Count$265316 = -48					; size = 4
__Tmp$229607 = -44					; size = 4
__Oldend$229608 = -40					; size = 4
__Tmp$229597 = -36					; size = 4
__Ncopied$229584 = -32					; size = 4
__Newvec$229582 = -28					; size = 4
__Whereoff$229583 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@2
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n@2
$LN29@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n@2:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@2
	jmp	$LN16@Insert_n@2
$LN14@Insert_n@2:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$265316[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$265316[ebp], 0
	jbe	SHORT $LN35@Insert_n@2
	mov	edx, DWORD PTR __Count$265316[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n@2
$LN35@Insert_n@2:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Xlen
	jmp	$LN16@Insert_n@2

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$265342[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$265342[ebp], 0
	jbe	SHORT $LN48@Insert_n@2
	mov	ecx, DWORD PTR __Count$265342[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n@2
$LN48@Insert_n@2:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n@2:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@2:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@2:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z ; std::_Allocate<CvPlot *>
	add	esp, 8
	mov	DWORD PTR __Newvec$229582[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$229583[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$229584[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$229583[ebp]
	mov	ecx, DWORD PTR __Newvec$229582[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T265389[ebp], edx
	mov	eax, DWORD PTR $T265389[ebp]
	mov	DWORD PTR $T265377[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T265380[ebp], cl
	mov	dl, BYTE PTR __Cat$265384[ebp]
	mov	BYTE PTR $T265381[ebp], dl
	mov	al, BYTE PTR $T265380[ebp]
	mov	BYTE PTR $T265367[ebp], al
	mov	ecx, DWORD PTR $T265377[ebp]
	mov	DWORD PTR $T265366[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T265366[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAPAVCvPlot@@IPAV1@@stdext@@YAXPAPAVCvPlot@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvPlot * *,unsigned int,CvPlot *>
	add	esp, 12					; 0000000cH

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$229584[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$229584[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T265424[ebp], ecx
	mov	edx, DWORD PTR __Newvec$229582[ebp]
	mov	DWORD PTR $T265412[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T265416[ebp], al
	mov	cl, BYTE PTR __Cat$265420[ebp]
	mov	BYTE PTR $T265417[ebp], cl
	mov	dl, BYTE PTR $T265416[ebp]
	mov	BYTE PTR $T265402[ebp], dl
	mov	eax, DWORD PTR $T265412[ebp]
	mov	DWORD PTR $T265401[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T265401[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T265424[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$229584[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$229584[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T265459[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$229583[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$229582[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T265447[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T265451[ebp], dl
	mov	al, BYTE PTR __Cat$265455[ebp]
	mov	BYTE PTR $T265452[ebp], al
	mov	cl, BYTE PTR $T265451[ebp]
	mov	BYTE PTR $T265437[ebp], cl
	mov	edx, DWORD PTR $T265447[ebp]
	mov	DWORD PTR $T265436[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T265436[ebp]
	push	ecx
	mov	edx, DWORD PTR $T265459[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@2
__catch$?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$229584[ebp], 1
	jle	SHORT $LN7@Insert_n@2

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	ecx, DWORD PTR __Whereoff$229583[ebp]
	mov	edx, DWORD PTR __Newvec$229582[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T265479[ebp], eax
	mov	ecx, DWORD PTR __Newvec$229582[ebp]
	mov	DWORD PTR $T265478[ebp], ecx
	mov	dl, BYTE PTR __Cat$265487[ebp]
	mov	BYTE PTR $T265484[ebp], dl
$LN7@Insert_n@2:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$229584[ebp], 0
	jle	SHORT $LN6@Insert_n@2

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Whereoff$229583[ebp]
	mov	ecx, DWORD PTR __Newvec$229582[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T265509[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$229583[ebp]
	mov	eax, DWORD PTR __Newvec$229582[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T265508[ebp], ecx
	mov	dl, BYTE PTR __Cat$265517[ebp]
	mov	BYTE PTR $T265514[ebp], dl
$LN6@Insert_n@2:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Newvec$229582[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN103@Insert_n@2
	ret	0
$LN19@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN103@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T265557[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T265556[ebp], edx
	mov	eax, DWORD PTR $T265557[ebp]
	mov	DWORD PTR $T265545[ebp], eax
	mov	ecx, DWORD PTR $T265556[ebp]
	mov	DWORD PTR $T265544[ebp], ecx
	mov	dl, BYTE PTR __Cat$265553[ebp]
	mov	BYTE PTR $T265550[ebp], dl

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T265562[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T265561[ebp], ecx
	mov	edx, DWORD PTR $T265561[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$229582[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$229582[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$229582[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	$LN16@Insert_n@2
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$229597[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T265634[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T265615[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T265619[ebp], cl
	mov	dl, BYTE PTR __Cat$265623[ebp]
	mov	BYTE PTR $T265620[ebp], dl
	mov	al, BYTE PTR $T265619[ebp]
	mov	BYTE PTR $T265598[ebp], al
	mov	ecx, DWORD PTR $T265615[ebp]
	mov	DWORD PTR $T265597[ebp], ecx
	mov	edx, DWORD PTR $T265597[ebp]
	mov	DWORD PTR $T265587[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T265586[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T265626[ebp], cl
	mov	dl, BYTE PTR __Cat$265630[ebp]
	mov	BYTE PTR $T265627[ebp], dl
	movzx	eax, BYTE PTR $T265626[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T265627[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T265587[ebp]
	push	eax
	mov	ecx, DWORD PTR $T265634[ebp]
	push	ecx
	mov	edx, DWORD PTR $T265586[ebp]
	push	edx
	call	??$_Uninit_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$229597[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Ufill
	jmp	SHORT $LN21@Insert_n@2
__catch$?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T265717[ebp], eax
	mov	ecx, DWORD PTR $T265717[ebp]
	mov	DWORD PTR $T265706[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T265705[ebp], ecx
	mov	dl, BYTE PTR __Cat$265714[ebp]
	mov	BYTE PTR $T265711[ebp], dl

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z$3
	ret	0
$LN21@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T265733[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T265725[ebp], edx
	jmp	SHORT $LN151@Insert_n@2
$LN150@Insert_n@2:
	mov	eax, DWORD PTR $T265725[ebp]
	add	eax, 4
	mov	DWORD PTR $T265725[ebp], eax
$LN151@Insert_n@2:
	mov	ecx, DWORD PTR $T265725[ebp]
	cmp	ecx, DWORD PTR $T265733[ebp]
	je	SHORT $LN147@Insert_n@2
	mov	edx, DWORD PTR $T265725[ebp]
	mov	eax, DWORD PTR __Tmp$229597[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN150@Insert_n@2
$LN147@Insert_n@2:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@2
$LN3@Insert_n@2:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$229607[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$229608[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T265784[ebp], eax
	mov	ecx, DWORD PTR $T265784[ebp]
	mov	DWORD PTR $T265772[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T265776[ebp], dl
	mov	al, BYTE PTR __Cat$265780[ebp]
	mov	BYTE PTR $T265777[ebp], al
	mov	cl, BYTE PTR $T265776[ebp]
	mov	BYTE PTR $T265762[ebp], cl
	mov	edx, DWORD PTR $T265772[ebp]
	mov	DWORD PTR $T265761[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T265761[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$229608[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$229608[ebp]
	sub	ecx, eax
	push	ecx
	call	??$unchecked_uninitialized_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$229608[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$229608[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Unchecked_move_backward@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvPlot * *,CvPlot * *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T265836[ebp], ecx
	jmp	SHORT $LN186@Insert_n@2
$LN185@Insert_n@2:
	mov	edx, DWORD PTR $T265836[ebp]
	add	edx, 4
	mov	DWORD PTR $T265836[ebp], edx
$LN186@Insert_n@2:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR $T265836[ebp], edx
	je	SHORT $LN16@Insert_n@2
	mov	eax, DWORD PTR $T265836[ebp]
	mov	ecx, DWORD PTR __Tmp$229607[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN185@Insert_n@2
$LN16@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T265907 = -40						; size = 4
$T265897 = -33						; size = 1
$T265896 = -32						; size = 4
__Cat$265903 = -3					; size = 1
$T265900 = -2						; size = 1
$T265899 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T265907[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T265899[ebp], cl
	mov	dl, BYTE PTR __Cat$265903[ebp]
	mov	BYTE PTR $T265900[ebp], dl
	mov	al, BYTE PTR $T265899[ebp]
	mov	BYTE PTR $T265897[ebp], al
	mov	ecx, DWORD PTR $T265907[ebp]
	mov	DWORD PTR $T265896[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T265896[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAPAVCvPlot@@IPAV1@@stdext@@YAXPAPAVCvPlot@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvPlot * *,unsigned int,CvPlot *>
	add	esp, 12					; 0000000cH

; 1255 : 		return (_Ptr + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Ufill
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T265911 = -80						; size = 28
$T265910 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T265911[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T265910[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T265910[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T265911[ebp]
	push	eax
	lea	ecx, DWORD PTR $T265910[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T265910[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T265910[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T265911[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T265911[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T265910[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Xlen
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?SetSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z
_TEXT	SEGMENT
tv155 = -52						; size = 4
tv185 = -48						; size = 4
_this$ = -44						; size = 4
$T265983 = -40						; size = 4
_i$265974 = -36						; size = 4
$T265955 = -32						; size = 4
_pRet$265954 = -28					; size = 4
$T265944 = -24						; size = 4
$T265941 = -20						; size = 4
$T265932 = -16						; size = 4
_i$229657 = -12						; size = 4
_nOld$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?SetSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z PROC ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::SetSize, COMDAT
; _this$ = ecx

; 468  : 	void SetSize(unsigned int uiFit){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 469  : 
; 470  : 		unsigned int nOld = m_uiCurrSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _nOld$[ebp], ecx

; 471  : 
; 472  : 		m_uiCurrSize = MIN( m_uiCurrSize, uiFit );

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T265944[ebp], edx
	mov	eax, DWORD PTR $T265944[ebp]
	mov	ecx, DWORD PTR _uiFit$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jae	SHORT $LN16@SetSize
	lea	edx, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR tv185[ebp], edx
	jmp	SHORT $LN17@SetSize
$LN16@SetSize:
	mov	eax, DWORD PTR $T265944[ebp]
	mov	DWORD PTR tv185[ebp], eax
$LN17@SetSize:
	mov	ecx, DWORD PTR tv185[ebp]
	mov	DWORD PTR $T265941[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T265941[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], ecx

; 473  : 
; 474  : 		T* pTemp = NULL;

	mov	DWORD PTR _pTemp$[ebp], 0

; 475  : 		if( uiFit > 0 ){

	cmp	DWORD PTR _uiFit$[ebp], 0
	jbe	$LN9@SetSize

; 476  : 			pTemp = Alloc(uiFit);

	mov	edx, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR $T265955[ebp], edx
	cmp	DWORD PTR $T265955[ebp], 0
	jbe	SHORT $LN18@SetSize
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T265955[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$265954[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T265955[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _pRet$265954[ebp]
	mov	DWORD PTR _pTemp$[ebp], eax
	jmp	SHORT $LN19@SetSize
$LN18@SetSize:
	mov	DWORD PTR _pTemp$[ebp], 0
$LN19@SetSize:

; 477  : 			if (pTemp)

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	$LN8@SetSize

; 478  : 			{
; 479  : 				if( bPODType ){

	xor	ecx, ecx
	je	SHORT $LN7@SetSize

; 480  : 					memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pTemp$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 481  : 				}else{

	jmp	SHORT $LN6@SetSize
$LN7@SetSize:

; 482  : 					for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$229657[ebp], 0
	jmp	SHORT $LN5@SetSize
$LN4@SetSize:
	mov	ecx, DWORD PTR _i$229657[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$229657[ebp], ecx
$LN5@SetSize:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$229657[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN6@SetSize

; 483  : 						new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	ecx, DWORD PTR _i$229657[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR $T265932[ebp], eax
	cmp	DWORD PTR $T265932[ebp], 0
	je	SHORT $LN12@SetSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$229657[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [edx+eax*8+4]
	mov	eax, DWORD PTR $T265932[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T265932[ebp]
	mov	DWORD PTR tv155[ebp], ecx
	jmp	SHORT $LN13@SetSize
$LN12@SetSize:
	mov	DWORD PTR tv155[ebp], 0
$LN13@SetSize:
	jmp	SHORT $LN4@SetSize
$LN6@SetSize:

; 484  : 				}
; 485  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 486  : 			}
; 487  : 			else

	jmp	SHORT $LN2@SetSize
$LN8@SetSize:

; 488  : 			{
; 489  : 				FAssertMsg2(0, "Failed to set array size from %u to %u", nOld, uiFit);
; 490  : 				m_uiCurrSize = nOld;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nOld$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 491  : 				return;

	jmp	SHORT $LN10@SetSize
$LN2@SetSize:

; 492  : 			}
; 493  : 		}
; 494  : 		else

	jmp	SHORT $LN1@SetSize
$LN9@SetSize:

; 495  : 		{
; 496  : 			m_uiCurrMaxSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN1@SetSize:

; 497  : 		}
; 498  : 		Free(m_pData, nOld);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T265983[ebp], edx
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN25@SetSize
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN25@SetSize
	mov	DWORD PTR _i$265974[ebp], 0
	jmp	SHORT $LN30@SetSize
$LN29@SetSize:
	mov	edx, DWORD PTR _i$265974[ebp]
	add	edx, 1
	mov	DWORD PTR _i$265974[ebp], edx
$LN30@SetSize:
	mov	eax, DWORD PTR _i$265974[ebp]
	cmp	eax, DWORD PTR _nOld$[ebp]
	jae	SHORT $LN25@SetSize
	jmp	SHORT $LN29@SetSize
$LN25@SetSize:
	mov	ecx, DWORD PTR $T265983[ebp]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 499  : 		m_pData = pTemp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], eax
$LN10@SetSize:

; 500  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z ENDP ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::SetSize
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>
PUBLIC	?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill
PUBLIC	??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
PUBLIC	??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$2
__catchsym$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$0
__unwindtable$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv302 = -428						; size = 4
tv288 = -424						; size = 4
tv280 = -420						; size = 4
_this$ = -416						; size = 4
$T266537 = -412						; size = 4
$T266485 = -368						; size = 4
$T266473 = -364						; size = 4
$T266463 = -357						; size = 1
$T266462 = -356						; size = 4
__Cat$266481 = -327					; size = 1
$T266478 = -326						; size = 1
$T266477 = -325						; size = 1
$T266434 = -324						; size = 4
$T266426 = -320						; size = 4
$T266418 = -316						; size = 4
$T266407 = -312						; size = 4
$T266406 = -308						; size = 4
__Cat$266413 = -302					; size = 1
$T266410 = -301						; size = 1
$T266335 = -276						; size = 4
$T266316 = -272						; size = 4
$T266299 = -265						; size = 1
$T266298 = -264						; size = 4
$T266288 = -260						; size = 4
$T266287 = -256						; size = 4
__Cat$266330 = -250					; size = 1
$T266327 = -249						; size = 1
$T266326 = -248						; size = 1
__Cat$266323 = -247					; size = 1
$T266320 = -246						; size = 1
$T266319 = -245						; size = 1
$T266263 = -244						; size = 4
$T266262 = -240						; size = 4
$T266258 = -236						; size = 4
$T266257 = -232						; size = 4
$T266246 = -228						; size = 4
$T266245 = -224						; size = 4
__Cat$266248 = -218					; size = 1
$T266256 = -217						; size = 1
$T266210 = -216						; size = 4
$T266209 = -212						; size = 4
__Cat$266217 = -206					; size = 1
$T266215 = -205						; size = 1
$T266180 = -204						; size = 4
$T266179 = -200						; size = 4
__Cat$266187 = -194					; size = 1
$T266185 = -193						; size = 1
$T266160 = -192						; size = 4
$T266148 = -188						; size = 4
$T266138 = -181						; size = 1
$T266137 = -180						; size = 4
__Cat$266156 = -175					; size = 1
$T266153 = -174						; size = 1
$T266152 = -173						; size = 1
$T266125 = -172						; size = 4
$T266113 = -168						; size = 4
$T266103 = -161						; size = 1
$T266102 = -160						; size = 4
__Cat$266121 = -155					; size = 1
$T266118 = -154						; size = 1
$T266117 = -153						; size = 1
$T266090 = -152						; size = 4
$T266078 = -148						; size = 4
$T266068 = -141						; size = 1
$T266067 = -140						; size = 4
__Cat$266084 = -135					; size = 1
$T266082 = -134						; size = 1
$T266081 = -133						; size = 1
__Count$266041 = -120					; size = 4
__Count$266015 = -48					; size = 4
__Tmp$229726 = -44					; size = 4
__Oldend$229727 = -40					; size = 4
__Tmp$229716 = -36					; size = 4
__Ncopied$229703 = -32					; size = 4
__Newvec$229701 = -28					; size = 4
__Whereoff$229702 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@3
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n@3
$LN29@Insert_n@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n@3:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@3
	jmp	$LN16@Insert_n@3
$LN14@Insert_n@3:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$266015[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$266015[ebp], 0
	jbe	SHORT $LN35@Insert_n@3
	mov	edx, DWORD PTR __Count$266015[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n@3
$LN35@Insert_n@3:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
	jmp	$LN16@Insert_n@3

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$266041[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$266041[ebp], 0
	jbe	SHORT $LN48@Insert_n@3
	mov	ecx, DWORD PTR __Count$266041[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n@3
$LN48@Insert_n@3:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n@3:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@3
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@3:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@3:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
	add	esp, 8
	mov	DWORD PTR __Newvec$229701[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$229702[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$229703[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$229702[ebp]
	mov	ecx, DWORD PTR __Newvec$229701[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T266090[ebp], edx
	mov	eax, DWORD PTR $T266090[ebp]
	mov	DWORD PTR $T266078[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T266081[ebp], cl
	mov	dl, BYTE PTR __Cat$266084[ebp]
	mov	BYTE PTR $T266082[ebp], dl
	mov	al, BYTE PTR $T266081[ebp]
	mov	BYTE PTR $T266068[ebp], al
	mov	ecx, DWORD PTR $T266078[ebp]
	mov	DWORD PTR $T266067[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T266067[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
	add	esp, 12					; 0000000cH

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$229703[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$229703[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T266125[ebp], ecx
	mov	edx, DWORD PTR __Newvec$229701[ebp]
	mov	DWORD PTR $T266113[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T266117[ebp], al
	mov	cl, BYTE PTR __Cat$266121[ebp]
	mov	BYTE PTR $T266118[ebp], cl
	mov	dl, BYTE PTR $T266117[ebp]
	mov	BYTE PTR $T266103[ebp], dl
	mov	eax, DWORD PTR $T266113[ebp]
	mov	DWORD PTR $T266102[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T266102[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T266125[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$229703[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$229703[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T266160[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$229702[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$229701[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T266148[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T266152[ebp], dl
	mov	al, BYTE PTR __Cat$266156[ebp]
	mov	BYTE PTR $T266153[ebp], al
	mov	cl, BYTE PTR $T266152[ebp]
	mov	BYTE PTR $T266138[ebp], cl
	mov	edx, DWORD PTR $T266148[ebp]
	mov	DWORD PTR $T266137[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T266137[ebp]
	push	ecx
	mov	edx, DWORD PTR $T266160[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@3
__catch$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$229703[ebp], 1
	jle	SHORT $LN7@Insert_n@3

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	ecx, DWORD PTR __Whereoff$229702[ebp]
	mov	edx, DWORD PTR __Newvec$229701[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T266180[ebp], eax
	mov	ecx, DWORD PTR __Newvec$229701[ebp]
	mov	DWORD PTR $T266179[ebp], ecx
	mov	dl, BYTE PTR __Cat$266187[ebp]
	mov	BYTE PTR $T266185[ebp], dl
$LN7@Insert_n@3:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$229703[ebp], 0
	jle	SHORT $LN6@Insert_n@3

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Whereoff$229702[ebp]
	mov	ecx, DWORD PTR __Newvec$229701[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T266210[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$229702[ebp]
	mov	eax, DWORD PTR __Newvec$229701[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T266209[ebp], ecx
	mov	dl, BYTE PTR __Cat$266217[ebp]
	mov	BYTE PTR $T266215[ebp], dl
$LN6@Insert_n@3:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Newvec$229701[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN103@Insert_n@3
	ret	0
$LN19@Insert_n@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN103@Insert_n@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T266258[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T266257[ebp], edx
	mov	eax, DWORD PTR $T266258[ebp]
	mov	DWORD PTR $T266246[ebp], eax
	mov	ecx, DWORD PTR $T266257[ebp]
	mov	DWORD PTR $T266245[ebp], ecx
	mov	dl, BYTE PTR __Cat$266248[ebp]
	mov	BYTE PTR $T266256[ebp], dl

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T266263[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T266262[ebp], ecx
	mov	edx, DWORD PTR $T266262[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$229701[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$229701[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$229701[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	$LN16@Insert_n@3
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@3

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$229716[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T266335[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T266316[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T266319[ebp], cl
	mov	dl, BYTE PTR __Cat$266323[ebp]
	mov	BYTE PTR $T266320[ebp], dl
	mov	al, BYTE PTR $T266319[ebp]
	mov	BYTE PTR $T266299[ebp], al
	mov	ecx, DWORD PTR $T266316[ebp]
	mov	DWORD PTR $T266298[ebp], ecx
	mov	edx, DWORD PTR $T266298[ebp]
	mov	DWORD PTR $T266288[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T266287[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T266326[ebp], cl
	mov	dl, BYTE PTR __Cat$266330[ebp]
	mov	BYTE PTR $T266327[ebp], dl
	movzx	eax, BYTE PTR $T266326[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T266327[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T266288[ebp]
	push	eax
	mov	ecx, DWORD PTR $T266335[ebp]
	push	ecx
	mov	edx, DWORD PTR $T266287[ebp]
	push	edx
	call	??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$229716[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill
	jmp	SHORT $LN21@Insert_n@3
__catch$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T266418[ebp], eax
	mov	ecx, DWORD PTR $T266418[ebp]
	mov	DWORD PTR $T266407[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T266406[ebp], ecx
	mov	dl, BYTE PTR __Cat$266413[ebp]
	mov	BYTE PTR $T266410[ebp], dl

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$3
	ret	0
$LN21@Insert_n@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T266434[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T266426[ebp], edx
	jmp	SHORT $LN151@Insert_n@3
$LN150@Insert_n@3:
	mov	eax, DWORD PTR $T266426[ebp]
	add	eax, 4
	mov	DWORD PTR $T266426[ebp], eax
$LN151@Insert_n@3:
	mov	ecx, DWORD PTR $T266426[ebp]
	cmp	ecx, DWORD PTR $T266434[ebp]
	je	SHORT $LN147@Insert_n@3
	mov	edx, DWORD PTR $T266426[ebp]
	mov	eax, DWORD PTR __Tmp$229716[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN150@Insert_n@3
$LN147@Insert_n@3:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@3
$LN3@Insert_n@3:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$229726[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$229727[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T266485[ebp], eax
	mov	ecx, DWORD PTR $T266485[ebp]
	mov	DWORD PTR $T266473[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T266477[ebp], dl
	mov	al, BYTE PTR __Cat$266481[ebp]
	mov	BYTE PTR $T266478[ebp], al
	mov	cl, BYTE PTR $T266477[ebp]
	mov	BYTE PTR $T266463[ebp], cl
	mov	edx, DWORD PTR $T266473[ebp]
	mov	DWORD PTR $T266462[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T266462[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$229727[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$229727[ebp]
	sub	ecx, eax
	push	ecx
	call	??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$229727[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$229727[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T266537[ebp], ecx
	jmp	SHORT $LN186@Insert_n@3
$LN185@Insert_n@3:
	mov	edx, DWORD PTR $T266537[ebp]
	add	edx, 4
	mov	DWORD PTR $T266537[ebp], edx
$LN186@Insert_n@3:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR $T266537[ebp], edx
	je	SHORT $LN16@Insert_n@3
	mov	eax, DWORD PTR $T266537[ebp]
	mov	ecx, DWORD PTR __Tmp$229726[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN185@Insert_n@3
$LN16@Insert_n@3:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T266608 = -40						; size = 4
$T266598 = -33						; size = 1
$T266597 = -32						; size = 4
__Cat$266604 = -3					; size = 1
$T266601 = -2						; size = 1
$T266600 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T266608[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T266600[ebp], cl
	mov	dl, BYTE PTR __Cat$266604[ebp]
	mov	BYTE PTR $T266601[ebp], dl
	mov	al, BYTE PTR $T266600[ebp]
	mov	BYTE PTR $T266598[ebp], al
	mov	ecx, DWORD PTR $T266608[ebp]
	mov	DWORD PTR $T266597[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T266597[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
	add	esp, 12					; 0000000cH

; 1255 : 		return (_Ptr + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T266612 = -80						; size = 28
$T266611 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T266612[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T266611[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T266611[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T266612[ebp]
	push	eax
	lea	ecx, DWORD PTR $T266611[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T266611[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T266611[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T266612[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@3:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T266612[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T266611[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv186 = -52						; size = 4
_this$ = -48						; size = 4
$T266673 = -44						; size = 4
$T266672 = -40						; size = 4
_i$266665 = -36						; size = 4
$T266651 = -32						; size = 4
$T266644 = -28						; size = 4
_pRet$266641 = -24					; size = 4
$T266634 = -20						; size = 4
$T266633 = -16						; size = 4
_i$229783 = -12						; size = 4
_uiNewSize$229775 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@4:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@4

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$229775[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$229775[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@4

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@4
$LN6@GrowSize@4:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$229775[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@4
$LN7@GrowSize@4:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T266644[ebp], ecx
	cmp	DWORD PTR $T266644[ebp], 100		; 00000064H
	jbe	SHORT $LN16@GrowSize@4
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T266644[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$266641[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T266644[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN17@GrowSize@4
$LN16@GrowSize@4:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$266641[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 100			; 00000064H
$LN17@GrowSize@4:
	mov	ecx, DWORD PTR _pRet$266641[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize@4

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@4
$LN5@GrowSize@4:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$229783[ebp], 0
	jmp	SHORT $LN3@GrowSize@4
$LN2@GrowSize@4:
	mov	edx, DWORD PTR _i$229783[ebp]
	add	edx, 1
	mov	DWORD PTR _i$229783[ebp], edx
$LN3@GrowSize@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$229783[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@4

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$229783[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T266634[ebp], ecx
	cmp	DWORD PTR $T266634[ebp], 0
	je	SHORT $LN12@GrowSize@4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$229783[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T266651[ebp], edx
	mov	eax, DWORD PTR $T266634[ebp]
	mov	ecx, DWORD PTR $T266651[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T266634[ebp]
	mov	ecx, DWORD PTR $T266651[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR $T266634[ebp]
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN13@GrowSize@4
$LN12@GrowSize@4:
	mov	DWORD PTR tv186[ebp], 0
$LN13@GrowSize@4:
	mov	ecx, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T266633[ebp], ecx
	jmp	SHORT $LN2@GrowSize@4
$LN4@GrowSize@4:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T266673[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T266672[ebp], edx
	xor	eax, eax
	je	SHORT $LN24@GrowSize@4
	xor	ecx, ecx
	je	SHORT $LN24@GrowSize@4
	mov	DWORD PTR _i$266665[ebp], 0
	jmp	SHORT $LN29@GrowSize@4
$LN28@GrowSize@4:
	mov	edx, DWORD PTR _i$266665[ebp]
	add	edx, 1
	mov	DWORD PTR _i$266665[ebp], edx
$LN29@GrowSize@4:
	mov	eax, DWORD PTR _i$266665[ebp]
	cmp	eax, DWORD PTR $T266673[ebp]
	jae	SHORT $LN24@GrowSize@4
	jmp	SHORT $LN28@GrowSize@4
$LN24@GrowSize@4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T266672[ebp], ecx
	je	SHORT $LN25@GrowSize@4
	mov	edx, DWORD PTR $T266672[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN25@GrowSize@4:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+812], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv158 = -48						; size = 4
_this$ = -44						; size = 4
$T266716 = -40						; size = 4
$T266715 = -36						; size = 4
_i$266711 = -32						; size = 4
$T266694 = -28						; size = 4
$T266687 = -24						; size = 4
_pRet$266683 = -20					; size = 4
$T266677 = -16						; size = 4
$T266676 = -12						; size = 4
_i$229802 = -8						; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSizeToFit, COMDAT
; _this$ = ecx

; 776  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 777  : 		if( uiFit <= m_uiCurrMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiFit$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	ja	SHORT $LN6@GrowSizeTo

; 778  : 			return;

	jmp	$LN7@GrowSizeTo
$LN6@GrowSizeTo:

; 779  : 
; 780  : 		m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 781  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T266687[ebp], edx
	cmp	DWORD PTR $T266687[ebp], 100		; 00000064H
	jbe	SHORT $LN13@GrowSizeTo
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T266687[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$266683[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T266687[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN14@GrowSizeTo
$LN13@GrowSizeTo:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$266683[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 100			; 00000064H
$LN14@GrowSizeTo:
	mov	edx, DWORD PTR _pRet$266683[ebp]
	mov	DWORD PTR _pTemp$[ebp], edx

; 782  : 		if( bPODType ){

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@GrowSizeTo

; 783  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pTemp$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 784  : 		}else{

	jmp	SHORT $LN4@GrowSizeTo
$LN5@GrowSizeTo:

; 785  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$229802[ebp], 0
	jmp	SHORT $LN3@GrowSizeTo
$LN2@GrowSizeTo:
	mov	eax, DWORD PTR _i$229802[ebp]
	add	eax, 1
	mov	DWORD PTR _i$229802[ebp], eax
$LN3@GrowSizeTo:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$229802[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN4@GrowSizeTo

; 786  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	eax, DWORD PTR _i$229802[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T266677[ebp], edx
	cmp	DWORD PTR $T266677[ebp], 0
	je	SHORT $LN9@GrowSizeTo
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$229802[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR $T266694[ebp], eax
	mov	ecx, DWORD PTR $T266677[ebp]
	mov	edx, DWORD PTR $T266694[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T266677[ebp]
	mov	edx, DWORD PTR $T266694[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR $T266677[ebp]
	mov	DWORD PTR tv158[ebp], ecx
	jmp	SHORT $LN10@GrowSizeTo
$LN9@GrowSizeTo:
	mov	DWORD PTR tv158[ebp], 0
$LN10@GrowSizeTo:
	mov	edx, DWORD PTR tv158[ebp]
	mov	DWORD PTR $T266676[ebp], edx
	jmp	SHORT $LN2@GrowSizeTo
$LN4@GrowSizeTo:

; 787  : 		}
; 788  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T266716[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T266715[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN21@GrowSizeTo
	xor	edx, edx
	je	SHORT $LN21@GrowSizeTo
	mov	DWORD PTR _i$266711[ebp], 0
	jmp	SHORT $LN26@GrowSizeTo
$LN25@GrowSizeTo:
	mov	eax, DWORD PTR _i$266711[ebp]
	add	eax, 1
	mov	DWORD PTR _i$266711[ebp], eax
$LN26@GrowSizeTo:
	mov	ecx, DWORD PTR _i$266711[ebp]
	cmp	ecx, DWORD PTR $T266716[ebp]
	jae	SHORT $LN21@GrowSizeTo
	jmp	SHORT $LN25@GrowSizeTo
$LN21@GrowSizeTo:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T266715[ebp], edx
	je	SHORT $LN22@GrowSizeTo
	mov	eax, DWORD PTR $T266715[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSizeTo:

; 789  : 		m_pData = pTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], edx

; 790  : 
; 791  : 		m_bIsResized = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+812], 1
$LN7@GrowSizeTo:

; 792  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSizeToFit
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv186 = -52						; size = 4
_this$ = -48						; size = 4
$T266761 = -44						; size = 4
$T266760 = -40						; size = 4
_i$266756 = -36						; size = 4
$T266739 = -32						; size = 4
$T266732 = -28						; size = 4
_pRet$266729 = -24					; size = 4
$T266722 = -20						; size = 4
$T266721 = -16						; size = 4
_i$229854 = -12						; size = 4
_uiNewSize$229846 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@5:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@5

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$229846[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$229846[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@5

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@5
$LN6@GrowSize@5:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$229846[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@5
$LN7@GrowSize@5:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T266732[ebp], ecx
	cmp	DWORD PTR $T266732[ebp], 64		; 00000040H
	jbe	SHORT $LN16@GrowSize@5
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T266732[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$266729[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T266732[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN17@GrowSize@5
$LN16@GrowSize@5:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$266729[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 64			; 00000040H
$LN17@GrowSize@5:
	mov	ecx, DWORD PTR _pRet$266729[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize@5

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@5
$LN5@GrowSize@5:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$229854[ebp], 0
	jmp	SHORT $LN3@GrowSize@5
$LN2@GrowSize@5:
	mov	edx, DWORD PTR _i$229854[ebp]
	add	edx, 1
	mov	DWORD PTR _i$229854[ebp], edx
$LN3@GrowSize@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$229854[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@5

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$229854[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T266722[ebp], ecx
	cmp	DWORD PTR $T266722[ebp], 0
	je	SHORT $LN12@GrowSize@5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$229854[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T266739[ebp], edx
	mov	eax, DWORD PTR $T266722[ebp]
	mov	ecx, DWORD PTR $T266739[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T266722[ebp]
	mov	ecx, DWORD PTR $T266739[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR $T266722[ebp]
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN13@GrowSize@5
$LN12@GrowSize@5:
	mov	DWORD PTR tv186[ebp], 0
$LN13@GrowSize@5:
	mov	ecx, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T266721[ebp], ecx
	jmp	SHORT $LN2@GrowSize@5
$LN4@GrowSize@5:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T266761[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T266760[ebp], edx
	xor	eax, eax
	je	SHORT $LN24@GrowSize@5
	xor	ecx, ecx
	je	SHORT $LN24@GrowSize@5
	mov	DWORD PTR _i$266756[ebp], 0
	jmp	SHORT $LN29@GrowSize@5
$LN28@GrowSize@5:
	mov	edx, DWORD PTR _i$266756[ebp]
	add	edx, 1
	mov	DWORD PTR _i$266756[ebp], edx
$LN29@GrowSize@5:
	mov	eax, DWORD PTR _i$266756[ebp]
	cmp	eax, DWORD PTR $T266761[ebp]
	jae	SHORT $LN24@GrowSize@5
	jmp	SHORT $LN28@GrowSize@5
$LN24@GrowSize@5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T266760[ebp], ecx
	je	SHORT $LN25@GrowSize@5
	mov	edx, DWORD PTR $T266760[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN25@GrowSize@5:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+524], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ ; BaseVector<TradeConnectionPlot,0>::~BaseVector<TradeConnectionPlot,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T266788 = -24						; size = 4
$T266787 = -20						; size = 4
_i$266780 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T266788[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T266787[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN5@FStaticVec@10
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@FStaticVec@10
	mov	DWORD PTR _i$266780[ebp], 0
	jmp	SHORT $LN10@FStaticVec@10
$LN9@FStaticVec@10:
	mov	eax, DWORD PTR _i$266780[ebp]
	add	eax, 1
	mov	DWORD PTR _i$266780[ebp], eax
$LN10@FStaticVec@10:
	mov	ecx, DWORD PTR _i$266780[ebp]
	cmp	ecx, DWORD PTR $T266788[ebp]
	jae	SHORT $LN5@FStaticVec@10
	jmp	SHORT $LN9@FStaticVec@10
$LN5@FStaticVec@10:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T266787[ebp], edx
	je	SHORT $LN1@FStaticVec@10
	mov	eax, DWORD PTR $T266787[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@10:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ ; BaseVector<TradeConnectionPlot,0>::~BaseVector<TradeConnectionPlot,0>
__ehhandler$??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
; Function compile flags: /Odtp
;	COMDAT ??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ PROC	; BaseVector<TradeConnectionPlot,0>::~BaseVector<TradeConnectionPlot,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ ENDP	; BaseVector<TradeConnectionPlot,0>::~BaseVector<TradeConnectionPlot,0>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T266806 = -16						; size = 4
$T266802 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_List_nod<int,std::allocator<int> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T266806[ebp], 0
	lea	eax, DWORD PTR $T266806[ebp]
	push	eax
	lea	ecx, DWORD PTR $T266802[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T266802[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T266802[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<int,std::allocator<int> >::_Node>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@VCvHomelandTarget@@@std@@YAPAVCvHomelandTarget@@IPAV1@@Z
_TEXT	SEGMENT
$T266820 = -16						; size = 4
$T266816 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvHomelandTarget@@@std@@YAPAVCvHomelandTarget@@IPAV1@@Z PROC ; std::_Allocate<CvHomelandTarget>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 20					; 00000014H
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T266820[ebp], 0
	lea	eax, DWORD PTR $T266820[ebp]
	push	eax
	lea	ecx, DWORD PTR $T266816[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T266816[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T266816[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 20					; 00000014H
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@VCvHomelandTarget@@@std@@YAPAVCvHomelandTarget@@IPAV1@@Z ENDP ; std::_Allocate<CvHomelandTarget>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z
_TEXT	SEGMENT
$T266865 = -38						; size = 1
$T266864 = -37						; size = 1
$T266863 = -36						; size = 4
$T266862 = -32						; size = 4
$T266849 = -25						; size = 1
$T266848 = -24						; size = 4
$T266847 = -20						; size = 4
__Off$266858 = -16					; size = 4
__Result$266859 = -12					; size = 4
__Cat$266855 = -8					; size = 1
$T266852 = -7						; size = 1
$T266851 = -6						; size = 1
__Cat$266829 = -4					; size = 1
$T266825 = -3						; size = 1
$T266824 = -2						; size = 1
$T266823 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvPlot * *,CvPlot * *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T266823[ebp], al
	mov	cl, BYTE PTR __Cat$266829[ebp]
	mov	BYTE PTR $T266824[ebp], cl
	mov	dl, BYTE PTR $T266823[ebp]
	mov	BYTE PTR $T266865[ebp], dl
	mov	al, BYTE PTR $T266825[ebp]
	mov	BYTE PTR $T266864[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T266863[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T266862[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T266851[ebp], al
	mov	cl, BYTE PTR __Cat$266855[ebp]
	mov	BYTE PTR $T266852[ebp], cl
	mov	dl, BYTE PTR $T266851[ebp]
	mov	BYTE PTR $T266849[ebp], dl
	mov	eax, DWORD PTR $T266863[ebp]
	mov	DWORD PTR $T266848[ebp], eax
	mov	ecx, DWORD PTR $T266862[ebp]
	mov	DWORD PTR $T266847[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T266847[ebp]
	sar	edx, 2
	mov	DWORD PTR __Off$266858[ebp], edx
	mov	eax, DWORD PTR __Off$266858[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR $T266848[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$266859[ebp], ecx
	cmp	DWORD PTR __Off$266858[ebp], 0
	jle	SHORT $LN7@Unchecked_
	mov	edx, DWORD PTR __Off$266858[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T266847[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$266858[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __Result$266859[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN7@Unchecked_:
	mov	eax, DWORD PTR __Result$266859[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvPlot * *,CvPlot * *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z
_TEXT	SEGMENT
$T266872 = -16						; size = 4
$T266868 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z PROC ; std::_Allocate<CvPlot *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T266872[ebp], 0
	lea	eax, DWORD PTR $T266872[ebp]
	push	eax
	lea	ecx, DWORD PTR $T266868[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T266868[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T266868[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z ENDP ; std::_Allocate<CvPlot *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z
_TEXT	SEGMENT
$T266917 = -38						; size = 1
$T266916 = -37						; size = 1
$T266915 = -36						; size = 4
$T266914 = -32						; size = 4
$T266901 = -25						; size = 1
$T266900 = -24						; size = 4
$T266899 = -20						; size = 4
__Off$266910 = -16					; size = 4
__Result$266911 = -12					; size = 4
__Cat$266907 = -8					; size = 1
$T266904 = -7						; size = 1
$T266903 = -6						; size = 1
__Cat$266881 = -4					; size = 1
$T266877 = -3						; size = 1
$T266876 = -2						; size = 1
$T266875 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T266875[ebp], al
	mov	cl, BYTE PTR __Cat$266881[ebp]
	mov	BYTE PTR $T266876[ebp], cl
	mov	dl, BYTE PTR $T266875[ebp]
	mov	BYTE PTR $T266917[ebp], dl
	mov	al, BYTE PTR $T266877[ebp]
	mov	BYTE PTR $T266916[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T266915[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T266914[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T266903[ebp], al
	mov	cl, BYTE PTR __Cat$266907[ebp]
	mov	BYTE PTR $T266904[ebp], cl
	mov	dl, BYTE PTR $T266903[ebp]
	mov	BYTE PTR $T266901[ebp], dl
	mov	eax, DWORD PTR $T266915[ebp]
	mov	DWORD PTR $T266900[ebp], eax
	mov	ecx, DWORD PTR $T266914[ebp]
	mov	DWORD PTR $T266899[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T266899[ebp]
	sar	edx, 2
	mov	DWORD PTR __Off$266910[ebp], edx
	mov	eax, DWORD PTR __Off$266910[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR $T266900[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$266911[ebp], ecx
	cmp	DWORD PTR __Off$266910[ebp], 0
	jle	SHORT $LN7@Unchecked_@2
	mov	edx, DWORD PTR __Off$266910[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T266899[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$266910[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __Result$266911[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN7@Unchecked_@2:
	mov	eax, DWORD PTR __Result$266911[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z
_TEXT	SEGMENT
$T266924 = -16						; size = 4
$T266920 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z PROC ; std::_Allocate<CvCity *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@4
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T266924[ebp], 0
	lea	eax, DWORD PTR $T266924[ebp]
	push	eax
	lea	ecx, DWORD PTR $T266920[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T266920[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T266920[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@4:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ENDP ; std::_Allocate<CvCity *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@ZU12@@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z0@Z ; std::_Insertion_sort1<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &),std::pair<int,CvPlot *> >
PUBLIC	??$_Sort_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z ; std::_Sort_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
PUBLIC	??$make_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z ; std::make_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
PUBLIC	??$_Unguarded_partition@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@0@PAU?$pair@HPAVCvPlot@@@0@0P6A_NABU20@1@Z@Z ; std::_Unguarded_partition<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAU?$pair@HPAVCvPlot@@@std@@HP6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0HP6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__Mid$230725 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Sort@PAU?$pair@HPAVCvPlot@@@std@@HP6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0HP6A_NABU10@1@Z@Z PROC ; std::_Sort<std::pair<int,CvPlot *> *,int,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 3244 : 	{	// order [_First, _Last), using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
$LN7@Sort:

; 3245 : 	_Diff _Count;
; 3246 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Count$[ebp], eax
	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN6@Sort
	cmp	DWORD PTR __Ideal$[ebp], 0
	jle	$LN6@Sort

; 3247 : 		{	// divide and conquer by quicksort
; 3248 : 		pair<_RanIt, _RanIt> _Mid =
; 3249 : 			std::_Unguarded_partition(_First, _Last, _Pred);

	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Mid$230725[ebp]
	push	ecx
	call	??$_Unguarded_partition@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@0@PAU?$pair@HPAVCvPlot@@@0@0P6A_NABU20@1@Z@Z ; std::_Unguarded_partition<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 16					; 00000010H

; 3250 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Ideal$[ebp], eax
	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR __Ideal$[ebp]
	mov	DWORD PTR __Ideal$[ebp], eax

; 3251 : 
; 3252 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	edx, DWORD PTR __Mid$230725[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __Mid$230725[ebp+4]
	sar	eax, 3
	cmp	edx, eax
	jge	SHORT $LN5@Sort

; 3253 : 			{	// loop on second half
; 3254 : 			std::_Sort(_First, _Mid.first, _Ideal, _Pred);

	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ideal$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$230725[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Sort@PAU?$pair@HPAVCvPlot@@@std@@HP6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0HP6A_NABU10@1@Z@Z ; std::_Sort<std::pair<int,CvPlot *> *,int,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 16					; 00000010H

; 3255 : 			_First = _Mid.second;

	mov	edx, DWORD PTR __Mid$230725[ebp+4]
	mov	DWORD PTR __First$[ebp], edx

; 3256 : 			}
; 3257 : 		else

	jmp	SHORT $LN4@Sort
$LN5@Sort:

; 3258 : 			{	// loop on first half
; 3259 : 			std::_Sort(_Mid.second, _Last, _Ideal, _Pred);

	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ideal$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$230725[ebp+4]
	push	eax
	call	??$_Sort@PAU?$pair@HPAVCvPlot@@@std@@HP6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0HP6A_NABU10@1@Z@Z ; std::_Sort<std::pair<int,CvPlot *> *,int,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 16					; 00000010H

; 3260 : 			_Last = _Mid.first;

	mov	ecx, DWORD PTR __Mid$230725[ebp]
	mov	DWORD PTR __Last$[ebp], ecx
$LN4@Sort:

; 3261 : 			}
; 3262 : 		}

	jmp	$LN7@Sort
$LN6@Sort:

; 3263 : 
; 3264 : 	if (_ISORT_MAX < _Count)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	SHORT $LN3@Sort

; 3265 : 		{	// heap sort if too many divisions
; 3266 : 		std::make_heap(_First, _Last, _Pred);

	mov	edx, DWORD PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$make_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z ; std::make_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 12					; 0000000cH

; 3267 : 		std::sort_heap(_First, _Last, _Pred);

	mov	edx, DWORD PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Sort_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z ; std::_Sort_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 12					; 0000000cH

; 3268 : 		}
; 3269 : 	else if (1 < _Count)

	jmp	SHORT $LN8@Sort
$LN3@Sort:
	cmp	DWORD PTR __Count$[ebp], 1
	jle	SHORT $LN8@Sort

; 3270 : 		std::_Insertion_sort(_First, _Last, _Pred);	// small

	push	0
	mov	edx, DWORD PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Insertion_sort1@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@ZU12@@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z0@Z ; std::_Insertion_sort1<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &),std::pair<int,CvPlot *> >
	add	esp, 16					; 00000010H
$LN8@Sort:

; 3271 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort@PAU?$pair@HPAVCvPlot@@@std@@HP6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0HP6A_NABU10@1@Z@Z ENDP ; std::_Sort<std::pair<int,CvPlot *> *,int,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandMove>::~_Temp_iterator<CvHomelandMove>
PUBLIC	??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z$0
__ehfuncinfo$??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z
_TEXT	SEGMENT
$T267204 = -112						; size = 4
__Next$267207 = -108					; size = 4
$T267121 = -48						; size = 4
$T267117 = -44						; size = 4
__Tempbuf$ = -36					; size = 20
__Count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z PROC ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>, COMDAT

; 3410 : 	{	// sort preserving order of equivalents, using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 3411 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 3412 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T267117[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR $T267117[ebp]
	sar	ecx, 3
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 3413 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR $T267121[ebp], eax
	mov	DWORD PTR __Tempbuf$[ebp], 0
	mov	DWORD PTR __Tempbuf$[ebp+4], 0
	mov	DWORD PTR __Tempbuf$[ebp+8], 0
	mov	edx, DWORD PTR $T267121[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+12], edx
	lea	eax, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+16], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3414 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf);

	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>
	add	esp, 16					; 00000010H

; 3415 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Tempbuf$[ebp], 0
	je	SHORT $LN1@Stable_sor
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Next$267207[ebp], edx
	jmp	SHORT $LN62@Stable_sor
$LN61@Stable_sor:
	mov	eax, DWORD PTR __Next$267207[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$267207[ebp], eax
$LN62@Stable_sor:
	mov	ecx, DWORD PTR __Next$267207[ebp]
	cmp	ecx, DWORD PTR __Tempbuf$[ebp+8]
	je	SHORT $LN60@Stable_sor
	jmp	SHORT $LN61@Stable_sor
$LN60@Stable_sor:
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR $T267204[ebp], edx
	mov	eax, DWORD PTR $T267204[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Stable_sor:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandMove>::~_Temp_iterator<CvHomelandMove>
__ehhandler$??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z ENDP ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>
PUBLIC	??1?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandTarget>::~_Temp_iterator<CvHomelandTarget>
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z$0
__ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z
_TEXT	SEGMENT
$T267379 = -120						; size = 4
__Next$267382 = -116					; size = 4
$T267264 = -56						; size = 4
$T267260 = -52						; size = 4
$T267247 = -48						; size = 4
$T267246 = -44						; size = 4
__Tempbuf$ = -36					; size = 20
__Count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>, COMDAT

; 3410 : 	{	// sort preserving order of equivalents, using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 3411 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 3412 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T267260[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T267247[ebp], ecx
	mov	edx, DWORD PTR $T267260[ebp]
	mov	DWORD PTR $T267246[ebp], edx
	mov	eax, DWORD PTR $T267247[ebp]
	sub	eax, DWORD PTR $T267246[ebp]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 3413 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR $T267264[ebp], eax
	mov	DWORD PTR __Tempbuf$[ebp], 0
	mov	DWORD PTR __Tempbuf$[ebp+4], 0
	mov	DWORD PTR __Tempbuf$[ebp+8], 0
	mov	edx, DWORD PTR $T267264[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+12], edx
	lea	eax, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+16], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3414 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf);

	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
	add	esp, 16					; 00000010H

; 3415 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Tempbuf$[ebp], 0
	je	SHORT $LN1@Stable_sor@2
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Next$267382[ebp], edx
	jmp	SHORT $LN74@Stable_sor@2
$LN73@Stable_sor@2:
	mov	eax, DWORD PTR __Next$267382[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __Next$267382[ebp], eax
$LN74@Stable_sor@2:
	mov	ecx, DWORD PTR __Next$267382[ebp]
	cmp	ecx, DWORD PTR __Tempbuf$[ebp+8]
	je	SHORT $LN72@Stable_sor@2
	jmp	SHORT $LN73@Stable_sor@2
$LN72@Stable_sor@2:
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR $T267379[ebp], edx
	mov	eax, DWORD PTR $T267379[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Stable_sor@2:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandTarget>::~_Temp_iterator<CvHomelandTarget>
__ehhandler$??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
PUBLIC	??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
PUBLIC	??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z$0
__ehfuncinfo$??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z
_TEXT	SEGMENT
$T267504 = -112						; size = 4
__Next$267507 = -108					; size = 4
$T267421 = -48						; size = 4
$T267417 = -44						; size = 4
__Tempbuf$ = -36					; size = 20
__Count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z PROC ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 3560 : 	{	// sort preserving order of equivalents, using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 3561 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 3562 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T267417[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR $T267417[ebp]
	sar	ecx, 4
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 3563 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR $T267421[ebp], eax
	mov	DWORD PTR __Tempbuf$[ebp], 0
	mov	DWORD PTR __Tempbuf$[ebp+4], 0
	mov	DWORD PTR __Tempbuf$[ebp+8], 0
	mov	edx, DWORD PTR $T267421[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+12], edx
	lea	eax, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+16], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3564 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);

	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 20					; 00000014H

; 3565 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Tempbuf$[ebp], 0
	je	SHORT $LN1@Stable_sor@3
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Next$267507[ebp], eax
	jmp	SHORT $LN62@Stable_sor@3
$LN61@Stable_sor@3:
	mov	ecx, DWORD PTR __Next$267507[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Next$267507[ebp], ecx
$LN62@Stable_sor@3:
	mov	edx, DWORD PTR __Next$267507[ebp]
	cmp	edx, DWORD PTR __Tempbuf$[ebp+8]
	je	SHORT $LN60@Stable_sor@3
	jmp	SHORT $LN61@Stable_sor@3
$LN60@Stable_sor@3:
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR $T267504[ebp], eax
	mov	ecx, DWORD PTR $T267504[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Stable_sor@3:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
__ehhandler$??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z ENDP ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
; Function compile flags: /Odtp
;	COMDAT ??$_Find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$_Find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z PROC ; std::_Find<std::list<int,std::allocator<int> >::_Iterator<0>,int>, COMDAT

; 37   : 	{	// find first matching _Val

	push	ebp
	mov	ebp, esp

; 38   : 	_DEBUG_RANGE(_First, _Last);
; 39   : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN13@Find
$LN11@Find:
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __First$[ebp], ecx
$LN13@Find:
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Find

; 40   : 		if (*_First == _Val)

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN1@Find

; 41   : 			break;

	jmp	SHORT $LN2@Find
$LN1@Find:

; 42   : 	return (_First);

	jmp	SHORT $LN11@Find
$LN2@Find:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 43   : 	}

	pop	ebp
	ret	0
??$_Find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z ENDP ; std::_Find<std::list<int,std::allocator<int> >::_Iterator<0>,int>
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z$0
__ehfuncinfo$??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z
_TEXT	SEGMENT
$T267669 = -112						; size = 4
__Next$267672 = -108					; size = 4
$T267586 = -48						; size = 4
$T267582 = -44						; size = 4
__Tempbuf$ = -36					; size = 20
__Count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z PROC ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>, COMDAT

; 3410 : 	{	// sort preserving order of equivalents, using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 3411 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 3412 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T267582[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR $T267582[ebp]
	sar	ecx, 4
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 3413 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR $T267586[ebp], eax
	mov	DWORD PTR __Tempbuf$[ebp], 0
	mov	DWORD PTR __Tempbuf$[ebp+4], 0
	mov	DWORD PTR __Tempbuf$[ebp+8], 0
	mov	edx, DWORD PTR $T267586[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+12], edx
	lea	eax, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+16], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3414 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf);

	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 16					; 00000010H

; 3415 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Tempbuf$[ebp], 0
	je	SHORT $LN1@Stable_sor@4
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Next$267672[ebp], edx
	jmp	SHORT $LN62@Stable_sor@4
$LN61@Stable_sor@4:
	mov	eax, DWORD PTR __Next$267672[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$267672[ebp], eax
$LN62@Stable_sor@4:
	mov	ecx, DWORD PTR __Next$267672[ebp]
	cmp	ecx, DWORD PTR __Tempbuf$[ebp+8]
	je	SHORT $LN60@Stable_sor@4
	jmp	SHORT $LN61@Stable_sor@4
$LN60@Stable_sor@4:
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR $T267669[ebp], edx
	mov	eax, DWORD PTR $T267669[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Stable_sor@4:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
__ehhandler$??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z ENDP ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@stdext@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@std@@@Z
_TEXT	SEGMENT
__Cat$267694 = -3					; size = 1
$T267690 = -2						; size = 1
$T267689 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@stdext@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T267689[ebp], al
	mov	cl, BYTE PTR __Cat$267694[ebp]
	mov	BYTE PTR $T267690[ebp], cl
	movzx	edx, BYTE PTR $T267689[ebp]
	push	edx
	movzx	eax, BYTE PTR $T267690[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@stdext@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0H@Z
_TEXT	SEGMENT
$T267821 = -128						; size = 4
__Mid$231079 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
$LN7@Sort@2:

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Count$[ebp], eax
	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN6@Sort@2
	cmp	DWORD PTR __Ideal$[ebp], 0
	jle	SHORT $LN6@Sort@2

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR __Mid$231079[ebp]
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Ideal$[ebp], eax
	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR __Ideal$[ebp]
	mov	DWORD PTR __Ideal$[ebp], eax

; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ecx, DWORD PTR __Mid$231079[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Mid$231079[ebp+4]
	sar	edx, 3
	cmp	ecx, edx
	jge	SHORT $LN5@Sort@2

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	mov	eax, DWORD PTR __Ideal$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$231079[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3093 : 			_First = _Mid.second;

	mov	eax, DWORD PTR __Mid$231079[ebp+4]
	mov	DWORD PTR __First$[ebp], eax

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN4@Sort@2
$LN5@Sort@2:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	mov	ecx, DWORD PTR __Ideal$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$231079[ebp+4]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3098 : 			_Last = _Mid.first;

	mov	ecx, DWORD PTR __Mid$231079[ebp]
	mov	DWORD PTR __Last$[ebp], ecx
$LN4@Sort@2:

; 3099 : 			}
; 3100 : 		}

	jmp	$LN7@Sort@2
$LN6@Sort@2:

; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	SHORT $LN3@Sort@2

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN76@Sort@2
	push	0
	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN76@Sort@2:

; 3105 : 		std::sort_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T267821[ebp], edx
	jmp	SHORT $LN92@Sort@2
$LN91@Sort@2:
	mov	eax, DWORD PTR $T267821[ebp]
	sub	eax, 8
	mov	DWORD PTR $T267821[ebp], eax
$LN92@Sort@2:
	mov	ecx, DWORD PTR $T267821[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	cmp	ecx, 1
	jle	SHORT $LN88@Sort@2
	mov	edx, DWORD PTR $T267821[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN96@Sort@2
	push	0
	mov	eax, DWORD PTR $T267821[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN96@Sort@2:
	jmp	SHORT $LN91@Sort@2
$LN88@Sort@2:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	jmp	SHORT $LN8@Sort@2
$LN3@Sort@2:
	cmp	DWORD PTR __Count$[ebp], 1
	jle	SHORT $LN8@Sort@2

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN8@Sort@2:

; 3109 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement>
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement>
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0H@Z
_TEXT	SEGMENT
$T268017 = -128						; size = 4
__Mid$231150 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
$LN7@Sort@3:

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Count$[ebp], eax
	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN6@Sort@3
	cmp	DWORD PTR __Ideal$[ebp], 0
	jle	SHORT $LN6@Sort@3

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR __Mid$231150[ebp]
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Ideal$[ebp], eax
	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR __Ideal$[ebp]
	mov	DWORD PTR __Ideal$[ebp], eax

; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ecx, DWORD PTR __Mid$231150[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Mid$231150[ebp+4]
	sar	edx, 3
	cmp	ecx, edx
	jge	SHORT $LN5@Sort@3

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	mov	eax, DWORD PTR __Ideal$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$231150[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3093 : 			_First = _Mid.second;

	mov	eax, DWORD PTR __Mid$231150[ebp+4]
	mov	DWORD PTR __First$[ebp], eax

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN4@Sort@3
$LN5@Sort@3:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	mov	ecx, DWORD PTR __Ideal$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$231150[ebp+4]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3098 : 			_Last = _Mid.first;

	mov	ecx, DWORD PTR __Mid$231150[ebp]
	mov	DWORD PTR __Last$[ebp], ecx
$LN4@Sort@3:

; 3099 : 			}
; 3100 : 		}

	jmp	$LN7@Sort@3
$LN6@Sort@3:

; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	SHORT $LN3@Sort@3

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN76@Sort@3
	push	0
	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN76@Sort@3:

; 3105 : 		std::sort_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T268017[ebp], edx
	jmp	SHORT $LN92@Sort@3
$LN91@Sort@3:
	mov	eax, DWORD PTR $T268017[ebp]
	sub	eax, 8
	mov	DWORD PTR $T268017[ebp], eax
$LN92@Sort@3:
	mov	ecx, DWORD PTR $T268017[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	cmp	ecx, 1
	jle	SHORT $LN88@Sort@3
	mov	edx, DWORD PTR $T268017[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN96@Sort@3
	push	0
	mov	eax, DWORD PTR $T268017[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN96@Sort@3:
	jmp	SHORT $LN91@Sort@3
$LN88@Sort@3:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	jmp	SHORT $LN8@Sort@3
$LN3@Sort@3:
	cmp	DWORD PTR __Count$[ebp], 1
	jle	SHORT $LN8@Sort@3

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN8@Sort@3:

; 3109 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T268113 = -28						; size = 4
__Vptr$268111 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvHomelandTarget *,unsigned int,CvHomelandTarget,std::allocator<CvHomelandTarget> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$268111[ebp], eax
	mov	ecx, DWORD PTR __Vptr$268111[ebp]
	mov	DWORD PTR $T268113[ebp], ecx
	cmp	DWORD PTR $T268113[ebp], 0
	je	SHORT $LN18@Uninit_fil
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T268113[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR $T268113[ebp]
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN14@Uninit_fil
$LN18@Uninit_fil:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_fil:
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_fil:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvHomelandTarget *,unsigned int,CvHomelandTarget,std::allocator<CvHomelandTarget> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T268144 = -8						; size = 4
__Next$231438 = -4					; size = 4
??1?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@XZ PROC	; std::_Temp_iterator<CvHomelandMove>::~_Temp_iterator<CvHomelandMove>, COMDAT
; _this$ = ecx

; 545  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Temp_itera

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Next$231438[ebp], edx

; 549  : 				_Next != _Buf._Hiwater; ++_Next)

	jmp	SHORT $LN3@Temp_itera
$LN2@Temp_itera:
	mov	eax, DWORD PTR __Next$231438[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$231438[ebp], eax
$LN3@Temp_itera:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Next$231438[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN1@Temp_itera

; 550  : 				_Destroy(&*_Next);

	jmp	SHORT $LN2@Temp_itera
$LN1@Temp_itera:

; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T268144[ebp], ecx
	mov	edx, DWORD PTR $T268144[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Temp_itera:

; 552  : 			}
; 553  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@XZ ENDP	; std::_Temp_iterator<CvHomelandMove>::~_Temp_iterator<CvHomelandMove>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T268153 = -8						; size = 4
__Next$231455 = -4					; size = 4
??1?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@XZ PROC ; std::_Temp_iterator<CvHomelandTarget>::~_Temp_iterator<CvHomelandTarget>, COMDAT
; _this$ = ecx

; 545  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Temp_itera@2

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Next$231455[ebp], edx

; 549  : 				_Next != _Buf._Hiwater; ++_Next)

	jmp	SHORT $LN3@Temp_itera@2
$LN2@Temp_itera@2:
	mov	eax, DWORD PTR __Next$231455[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __Next$231455[ebp], eax
$LN3@Temp_itera@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Next$231455[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN1@Temp_itera@2

; 550  : 				_Destroy(&*_Next);

	jmp	SHORT $LN2@Temp_itera@2
$LN1@Temp_itera@2:

; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T268153[ebp], ecx
	mov	edx, DWORD PTR $T268153[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Temp_itera@2:

; 552  : 			}
; 553  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@XZ ENDP ; std::_Temp_iterator<CvHomelandTarget>::~_Temp_iterator<CvHomelandTarget>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T268162 = -8						; size = 4
__Next$231468 = -4					; size = 4
??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ PROC	; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>, COMDAT
; _this$ = ecx

; 545  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Temp_itera@3

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Next$231468[ebp], edx

; 549  : 				_Next != _Buf._Hiwater; ++_Next)

	jmp	SHORT $LN3@Temp_itera@3
$LN2@Temp_itera@3:
	mov	eax, DWORD PTR __Next$231468[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$231468[ebp], eax
$LN3@Temp_itera@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Next$231468[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN1@Temp_itera@3

; 550  : 				_Destroy(&*_Next);

	jmp	SHORT $LN2@Temp_itera@3
$LN1@Temp_itera@3:

; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T268162[ebp], ecx
	mov	edx, DWORD PTR $T268162[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Temp_itera@3:

; 552  : 			}
; 553  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ENDP	; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
_TEXT	ENDS
PUBLIC	??$_Median@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z ; std::_Median<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@0@PAU?$pair@HPAVCvPlot@@@0@0P6A_NABU20@1@Z@Z
_TEXT	SEGMENT
$T268764 = -180						; size = 4
$T268712 = -176						; size = 4
$T268711 = -172						; size = 4
__Tmp$268761 = -168					; size = 4
__Tmp$268755 = -164					; size = 4
$T268683 = -160						; size = 4
$T268682 = -156						; size = 4
$T268630 = -152						; size = 4
$T268629 = -148						; size = 4
__Tmp$268679 = -144					; size = 4
__Tmp$268673 = -140					; size = 4
$T268601 = -136						; size = 4
$T268549 = -132						; size = 4
$T268548 = -128						; size = 4
__Tmp$268598 = -124					; size = 4
__Tmp$268592 = -120					; size = 4
$T268520 = -116						; size = 4
$T268519 = -112						; size = 4
$T268467 = -108						; size = 4
$T268466 = -104						; size = 4
__Tmp$268513 = -100					; size = 4
__Tmp$268507 = -96					; size = 4
$T268438 = -92						; size = 4
$T268437 = -88						; size = 4
$T268385 = -84						; size = 4
$T268384 = -80						; size = 4
__Tmp$268431 = -76					; size = 4
__Tmp$268425 = -72					; size = 4
$T268353 = -68						; size = 4
$T268352 = -64						; size = 4
$T268300 = -60						; size = 4
$T268299 = -56						; size = 4
__Tmp$268336 = -52					; size = 4
__Tmp$268346 = -48					; size = 4
$T268271 = -44						; size = 4
$T268219 = -40						; size = 4
$T268218 = -36						; size = 4
__Tmp$268269 = -32					; size = 4
__Tmp$268263 = -28					; size = 4
__Plast$ = -20						; size = 4
__Glast$ = -16						; size = 4
__Pfirst$ = -12						; size = 4
__Gfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Unguarded_partition@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@0@PAU?$pair@HPAVCvPlot@@@0@0P6A_NABU20@1@Z@Z PROC ; std::_Unguarded_partition<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 3185 : 	{	// partition [_First, _Last), using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H

; 3186 : 	_RanIt _Mid = _First + (_Last - _First) / 2;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$[ebp], edx

; 3187 : 	std::_Median(_First, _Mid, _Last - 1, _Pred);

	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Median@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z ; std::_Median<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 16					; 00000010H

; 3188 : 	_RanIt _Pfirst = _Mid;

	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Pfirst$[ebp], ecx

; 3189 : 	_RanIt _Plast = _Pfirst + 1;

	mov	edx, DWORD PTR __Pfirst$[ebp]
	add	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
$LN27@Unguarded_:

; 3190 : 
; 3191 : 	while (_First < _Pfirst
; 3192 : 		&& !_DEBUG_LT_PRED(_Pred, *(_Pfirst - 1), *_Pfirst)
; 3193 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Pfirst$[ebp]
	jae	SHORT $LN25@Unguarded_
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	sub	edx, 8
	push	edx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN25@Unguarded_
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 8
	push	ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	push	edx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN25@Unguarded_

; 3194 : 		--_Pfirst;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	jmp	SHORT $LN27@Unguarded_
$LN25@Unguarded_:

; 3195 : 	while (_Plast < _Last
; 3196 : 		&& !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst)
; 3197 : 		&& !_Pred(*_Pfirst, *_Plast))

	mov	edx, DWORD PTR __Plast$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	SHORT $LN24@Unguarded_
	mov	eax, DWORD PTR __Pfirst$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Plast$[ebp]
	push	ecx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN24@Unguarded_
	mov	eax, DWORD PTR __Plast$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	push	ecx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN24@Unguarded_

; 3198 : 		++_Plast;

	mov	eax, DWORD PTR __Plast$[ebp]
	add	eax, 8
	mov	DWORD PTR __Plast$[ebp], eax
	jmp	SHORT $LN25@Unguarded_
$LN24@Unguarded_:

; 3199 : 
; 3200 : 	_RanIt _Gfirst = _Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Gfirst$[ebp], ecx

; 3201 : 	_RanIt _Glast = _Pfirst;

	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Glast$[ebp], edx
$LN23@Unguarded_:

; 3202 : 
; 3203 : 	for (; ; )
; 3204 : 		{	// partition
; 3205 : 		for (; _Gfirst < _Last; ++_Gfirst)

	jmp	SHORT $LN21@Unguarded_
$LN20@Unguarded_:
	mov	eax, DWORD PTR __Gfirst$[ebp]
	add	eax, 8
	mov	DWORD PTR __Gfirst$[ebp], eax
$LN21@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jae	$LN19@Unguarded_

; 3206 : 			if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR __Gfirst$[ebp]
	push	edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	push	eax
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN18@Unguarded_
	jmp	$LN17@Unguarded_
$LN18@Unguarded_:

; 3207 : 				;
; 3208 : 			else if (_Pred(*_Gfirst, *_Pfirst))

	mov	edx, DWORD PTR __Pfirst$[ebp]
	push	edx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	push	eax
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN16@Unguarded_

; 3209 : 				break;

	jmp	SHORT $LN19@Unguarded_

; 3210 : 			else

	jmp	SHORT $LN17@Unguarded_
$LN16@Unguarded_:

; 3211 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T268271[ebp], edx
	mov	eax, DWORD PTR __Plast$[ebp]
	add	eax, 8
	mov	DWORD PTR __Plast$[ebp], eax
	mov	ecx, DWORD PTR $T268271[ebp]
	cmp	ecx, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN17@Unguarded_
	mov	edx, DWORD PTR $T268271[ebp]
	cmp	edx, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN58@Unguarded_
	mov	eax, DWORD PTR $T268271[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$268263[ebp], ecx
	mov	edx, DWORD PTR $T268271[ebp]
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR __Tmp$268263[ebp]
	mov	DWORD PTR [edx], eax
$LN58@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T268219[ebp], ecx
	mov	edx, DWORD PTR $T268271[ebp]
	add	edx, 4
	mov	DWORD PTR $T268218[ebp], edx
	mov	eax, DWORD PTR $T268218[ebp]
	cmp	eax, DWORD PTR $T268219[ebp]
	je	SHORT $LN17@Unguarded_
	mov	ecx, DWORD PTR $T268218[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$268269[ebp], edx
	mov	eax, DWORD PTR $T268218[ebp]
	mov	ecx, DWORD PTR $T268219[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T268219[ebp]
	mov	ecx, DWORD PTR __Tmp$268269[ebp]
	mov	DWORD PTR [eax], ecx
$LN17@Unguarded_:
	jmp	$LN20@Unguarded_
$LN19@Unguarded_:

; 3212 : 		for (; _First < _Glast; --_Glast)

	jmp	SHORT $LN14@Unguarded_
$LN13@Unguarded_:
	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Glast$[ebp], edx
$LN14@Unguarded_:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Glast$[ebp]
	jae	$LN12@Unguarded_

; 3213 : 			if (_DEBUG_LT_PRED(_Pred, *(_Glast - 1), *_Pfirst))

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 8
	push	edx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@Unguarded_
	jmp	$LN10@Unguarded_
$LN11@Unguarded_:

; 3214 : 				;
; 3215 : 			else if (_Pred(*_Pfirst, *(_Glast - 1)))

	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	push	ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	push	edx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@Unguarded_

; 3216 : 				break;

	jmp	SHORT $LN12@Unguarded_

; 3217 : 			else

	jmp	SHORT $LN10@Unguarded_
$LN9@Unguarded_:

; 3218 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 8
	mov	DWORD PTR $T268353[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T268352[ebp], eax
	mov	ecx, DWORD PTR $T268352[ebp]
	cmp	ecx, DWORD PTR $T268353[ebp]
	je	SHORT $LN10@Unguarded_
	mov	edx, DWORD PTR $T268352[ebp]
	cmp	edx, DWORD PTR $T268353[ebp]
	je	SHORT $LN75@Unguarded_
	mov	eax, DWORD PTR $T268352[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$268346[ebp], ecx
	mov	edx, DWORD PTR $T268352[ebp]
	mov	eax, DWORD PTR $T268353[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T268353[ebp]
	mov	eax, DWORD PTR __Tmp$268346[ebp]
	mov	DWORD PTR [edx], eax
$LN75@Unguarded_:
	mov	ecx, DWORD PTR $T268353[ebp]
	add	ecx, 4
	mov	DWORD PTR $T268300[ebp], ecx
	mov	edx, DWORD PTR $T268352[ebp]
	add	edx, 4
	mov	DWORD PTR $T268299[ebp], edx
	mov	eax, DWORD PTR $T268299[ebp]
	cmp	eax, DWORD PTR $T268300[ebp]
	je	SHORT $LN10@Unguarded_
	mov	ecx, DWORD PTR $T268299[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$268336[ebp], edx
	mov	eax, DWORD PTR $T268299[ebp]
	mov	ecx, DWORD PTR $T268300[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T268300[ebp]
	mov	ecx, DWORD PTR __Tmp$268336[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@Unguarded_:
	jmp	$LN13@Unguarded_
$LN12@Unguarded_:

; 3219 : 		if (_Glast == _First && _Gfirst == _Last)

	mov	edx, DWORD PTR __Glast$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	jne	SHORT $LN7@Unguarded_
	mov	eax, DWORD PTR __Gfirst$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	SHORT $LN7@Unguarded_

; 3220 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN28@Unguarded_
$LN7@Unguarded_:

; 3221 : 
; 3222 : 		if (_Glast == _First)

	mov	edx, DWORD PTR __Glast$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	jne	$LN6@Unguarded_

; 3223 : 			{	// no room at bottom, rotate pivot upward
; 3224 : 			if (_Plast != _Gfirst)

	mov	eax, DWORD PTR __Plast$[ebp]
	cmp	eax, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN5@Unguarded_

; 3225 : 				std::iter_swap(_Pfirst, _Plast);

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T268438[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T268437[ebp], edx
	mov	eax, DWORD PTR $T268437[ebp]
	cmp	eax, DWORD PTR $T268438[ebp]
	je	SHORT $LN5@Unguarded_
	mov	ecx, DWORD PTR $T268437[ebp]
	cmp	ecx, DWORD PTR $T268438[ebp]
	je	SHORT $LN94@Unguarded_
	mov	edx, DWORD PTR $T268437[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$268425[ebp], eax
	mov	ecx, DWORD PTR $T268437[ebp]
	mov	edx, DWORD PTR $T268438[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T268438[ebp]
	mov	edx, DWORD PTR __Tmp$268425[ebp]
	mov	DWORD PTR [ecx], edx
$LN94@Unguarded_:
	mov	eax, DWORD PTR $T268438[ebp]
	add	eax, 4
	mov	DWORD PTR $T268385[ebp], eax
	mov	ecx, DWORD PTR $T268437[ebp]
	add	ecx, 4
	mov	DWORD PTR $T268384[ebp], ecx
	mov	edx, DWORD PTR $T268384[ebp]
	cmp	edx, DWORD PTR $T268385[ebp]
	je	SHORT $LN5@Unguarded_
	mov	eax, DWORD PTR $T268384[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$268431[ebp], ecx
	mov	edx, DWORD PTR $T268384[ebp]
	mov	eax, DWORD PTR $T268385[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T268385[ebp]
	mov	eax, DWORD PTR __Tmp$268431[ebp]
	mov	DWORD PTR [edx], eax
$LN5@Unguarded_:

; 3226 : 			++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx

; 3227 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T268520[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T268519[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	add	edx, 8
	mov	DWORD PTR __Gfirst$[ebp], edx
	mov	eax, DWORD PTR $T268519[ebp]
	cmp	eax, DWORD PTR $T268520[ebp]
	je	SHORT $LN104@Unguarded_
	mov	ecx, DWORD PTR $T268519[ebp]
	cmp	ecx, DWORD PTR $T268520[ebp]
	je	SHORT $LN111@Unguarded_
	mov	edx, DWORD PTR $T268519[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$268507[ebp], eax
	mov	ecx, DWORD PTR $T268519[ebp]
	mov	edx, DWORD PTR $T268520[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T268520[ebp]
	mov	edx, DWORD PTR __Tmp$268507[ebp]
	mov	DWORD PTR [ecx], edx
$LN111@Unguarded_:
	mov	eax, DWORD PTR $T268520[ebp]
	add	eax, 4
	mov	DWORD PTR $T268467[ebp], eax
	mov	ecx, DWORD PTR $T268519[ebp]
	add	ecx, 4
	mov	DWORD PTR $T268466[ebp], ecx
	mov	edx, DWORD PTR $T268466[ebp]
	cmp	edx, DWORD PTR $T268467[ebp]
	je	SHORT $LN104@Unguarded_
	mov	eax, DWORD PTR $T268466[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$268513[ebp], ecx
	mov	edx, DWORD PTR $T268466[ebp]
	mov	eax, DWORD PTR $T268467[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T268467[ebp]
	mov	eax, DWORD PTR __Tmp$268513[ebp]
	mov	DWORD PTR [edx], eax
$LN104@Unguarded_:

; 3228 : 			}
; 3229 : 		else if (_Gfirst == _Last)

	jmp	$LN4@Unguarded_
$LN6@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jne	$LN3@Unguarded_

; 3230 : 			{	// no room at top, rotate pivot downward
; 3231 : 			if (--_Glast != --_Pfirst)

	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Glast$[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Pfirst$[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	cmp	ecx, DWORD PTR __Pfirst$[ebp]
	je	$LN2@Unguarded_

; 3232 : 				std::iter_swap(_Glast, _Pfirst);

	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T268601[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR $T268601[ebp]
	je	SHORT $LN2@Unguarded_
	mov	ecx, DWORD PTR __Glast$[ebp]
	cmp	ecx, DWORD PTR $T268601[ebp]
	je	SHORT $LN128@Unguarded_
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$268592[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	edx, DWORD PTR $T268601[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T268601[ebp]
	mov	edx, DWORD PTR __Tmp$268592[ebp]
	mov	DWORD PTR [ecx], edx
$LN128@Unguarded_:
	mov	eax, DWORD PTR $T268601[ebp]
	add	eax, 4
	mov	DWORD PTR $T268549[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T268548[ebp], ecx
	mov	edx, DWORD PTR $T268548[ebp]
	cmp	edx, DWORD PTR $T268549[ebp]
	je	SHORT $LN2@Unguarded_
	mov	eax, DWORD PTR $T268548[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$268598[ebp], ecx
	mov	edx, DWORD PTR $T268548[ebp]
	mov	eax, DWORD PTR $T268549[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T268549[ebp]
	mov	eax, DWORD PTR __Tmp$268598[ebp]
	mov	DWORD PTR [edx], eax
$LN2@Unguarded_:

; 3233 : 			std::iter_swap(_Pfirst, --_Plast);

	mov	ecx, DWORD PTR __Plast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T268683[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T268682[ebp], eax
	mov	ecx, DWORD PTR $T268682[ebp]
	cmp	ecx, DWORD PTR $T268683[ebp]
	je	$LN138@Unguarded_
	mov	edx, DWORD PTR $T268682[ebp]
	cmp	edx, DWORD PTR $T268683[ebp]
	je	SHORT $LN145@Unguarded_
	mov	eax, DWORD PTR $T268682[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$268673[ebp], ecx
	mov	edx, DWORD PTR $T268682[ebp]
	mov	eax, DWORD PTR $T268683[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T268683[ebp]
	mov	eax, DWORD PTR __Tmp$268673[ebp]
	mov	DWORD PTR [edx], eax
$LN145@Unguarded_:
	mov	ecx, DWORD PTR $T268683[ebp]
	add	ecx, 4
	mov	DWORD PTR $T268630[ebp], ecx
	mov	edx, DWORD PTR $T268682[ebp]
	add	edx, 4
	mov	DWORD PTR $T268629[ebp], edx
	mov	eax, DWORD PTR $T268629[ebp]
	cmp	eax, DWORD PTR $T268630[ebp]
	je	SHORT $LN138@Unguarded_
	mov	ecx, DWORD PTR $T268629[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$268679[ebp], edx
	mov	eax, DWORD PTR $T268629[ebp]
	mov	ecx, DWORD PTR $T268630[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T268630[ebp]
	mov	ecx, DWORD PTR __Tmp$268679[ebp]
	mov	DWORD PTR [eax], ecx
$LN138@Unguarded_:

; 3234 : 			}
; 3235 : 		else

	jmp	$LN4@Unguarded_
$LN3@Unguarded_:

; 3236 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Glast$[ebp], edx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T268764[ebp], eax
	mov	ecx, DWORD PTR $T268764[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	je	$LN155@Unguarded_
	mov	edx, DWORD PTR $T268764[ebp]
	cmp	edx, DWORD PTR __Glast$[ebp]
	je	SHORT $LN162@Unguarded_
	mov	eax, DWORD PTR $T268764[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$268755[ebp], ecx
	mov	edx, DWORD PTR $T268764[ebp]
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR __Tmp$268755[ebp]
	mov	DWORD PTR [edx], eax
$LN162@Unguarded_:
	mov	ecx, DWORD PTR __Glast$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T268712[ebp], ecx
	mov	edx, DWORD PTR $T268764[ebp]
	add	edx, 4
	mov	DWORD PTR $T268711[ebp], edx
	mov	eax, DWORD PTR $T268711[ebp]
	cmp	eax, DWORD PTR $T268712[ebp]
	je	SHORT $LN155@Unguarded_
	mov	ecx, DWORD PTR $T268711[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$268761[ebp], edx
	mov	eax, DWORD PTR $T268711[ebp]
	mov	ecx, DWORD PTR $T268712[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T268712[ebp]
	mov	ecx, DWORD PTR __Tmp$268761[ebp]
	mov	DWORD PTR [eax], ecx
$LN155@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	add	edx, 8
	mov	DWORD PTR __Gfirst$[ebp], edx
$LN4@Unguarded_:

; 3237 : 		}

	jmp	$LN23@Unguarded_
$LN28@Unguarded_:

; 3238 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unguarded_partition@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@0@PAU?$pair@HPAVCvPlot@@@0@0P6A_NABU20@1@Z@Z ENDP ; std::_Unguarded_partition<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@HHU10@P6A_NABU10@2@Z@Z ; std::_Adjust_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Odtp
;	COMDAT ??$make_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
$T268786 = -16						; size = 8
__Hole$268789 = -8					; size = 4
__Bottom$268788 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$make_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z PROC ; std::make_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 2203 : 	{	// make [_First, _Last) into a heap, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 2204 : 	_DEBUG_RANGE(_First, _Last);
; 2205 : 	_DEBUG_POINTER(_Pred);
; 2206 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cmp	eax, 1
	jle	SHORT $LN2@make_heap

; 2207 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Pred,
; 2208 : 			_Dist_type(_First), _Val_type(_First));

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	mov	DWORD PTR __Bottom$268788[ebp], ecx
	mov	eax, DWORD PTR __Bottom$268788[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Hole$268789[ebp], eax
$LN9@make_heap:
	cmp	DWORD PTR __Hole$268789[ebp], 0
	jle	SHORT $LN2@make_heap
	mov	edx, DWORD PTR __Hole$268789[ebp]
	sub	edx, 1
	mov	DWORD PTR __Hole$268789[ebp], edx
	mov	eax, DWORD PTR __Hole$268789[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR $T268786[ebp], edx
	mov	DWORD PTR $T268786[ebp+4], eax
	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T268786[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T268786[ebp]
	push	eax
	mov	ecx, DWORD PTR __Bottom$268788[ebp]
	push	ecx
	mov	edx, DWORD PTR __Hole$268789[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Adjust_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@HHU10@P6A_NABU10@2@Z@Z ; std::_Adjust_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 24					; 00000018H
	jmp	SHORT $LN9@make_heap
$LN2@make_heap:

; 2209 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$make_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z ENDP ; std::make_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Buffered_merge<CvHomelandMove *,int,CvHomelandMove>
PUBLIC	??$_Buffered_merge_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Buffered_merge_sort<CvHomelandMove *,int,CvHomelandMove>
PUBLIC	?_Maxlen@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandMove>::_Maxlen
PUBLIC	??$_Insertion_sort1@PAVCvHomelandMove@@V1@@std@@YAXPAVCvHomelandMove@@00@Z ; std::_Insertion_sort1<CvHomelandMove *,CvHomelandMove>
; Function compile flags: /Odtp
;	COMDAT ??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z
_TEXT	SEGMENT
__Count2$231636 = -8					; size = 4
__Mid$231637 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z PROC ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>, COMDAT

; 3381 : 	{	//  sort preserving order of equivalents, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 328				; 00000148H

; 3382 : 	if (_Count <= _ISORT_MAX)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jg	SHORT $LN4@Stable_sor@5

; 3383 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Insertion_sort1@PAVCvHomelandMove@@V1@@std@@YAXPAVCvHomelandMove@@00@Z ; std::_Insertion_sort1<CvHomelandMove *,CvHomelandMove>
	add	esp, 12					; 0000000cH

; 3384 : 	else

	jmp	$LN5@Stable_sor@5
$LN4@Stable_sor@5:

; 3385 : 		{	// sort halves and merge
; 3386 : 		_Diff _Count2 = (_Count + 1) / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$231636[ebp], eax

; 3387 : 		_BidIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$231637[ebp], edx

; 3388 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$231636[ebp]
	mov	ecx, DWORD PTR __Mid$231637[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$231637[ebp], edx

; 3389 : 
; 3390 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandMove>::_Maxlen
	cmp	DWORD PTR __Count2$231636[ebp], eax
	jg	SHORT $LN2@Stable_sor@5

; 3391 : 			{	// temp buffer big enough, sort each half using buffer
; 3392 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$231636[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$231637[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Buffered_merge_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Buffered_merge_sort<CvHomelandMove *,int,CvHomelandMove>
	add	esp, 16					; 00000010H

; 3393 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, DWORD PTR __Count2$231636[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$231637[ebp]
	push	ecx
	call	??$_Buffered_merge_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Buffered_merge_sort<CvHomelandMove *,int,CvHomelandMove>
	add	esp, 16					; 00000010H

; 3394 : 			}
; 3395 : 		else

	jmp	SHORT $LN1@Stable_sor@5
$LN2@Stable_sor@5:

; 3396 : 			{	// temp buffer not big enough, divide and conquer
; 3397 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2$231636[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$231637[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>
	add	esp, 16					; 00000010H

; 3398 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Count2$231636[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$231637[ebp]
	push	eax
	call	??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>
	add	esp, 16					; 00000010H
$LN1@Stable_sor@5:

; 3399 : 			}
; 3400 : 
; 3401 : 		_Buffered_merge(_First, _Mid, _Last,
; 3402 : 			_Count2, _Count - _Count2, _Tempbuf);	// merge sorted halves

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, DWORD PTR __Count2$231636[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2$231636[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$231637[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Buffered_merge@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Buffered_merge<CvHomelandMove *,int,CvHomelandMove>
	add	esp, 24					; 00000018H
$LN5@Stable_sor@5:

; 3403 : 		}
; 3404 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ENDP ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Buffered_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
PUBLIC	??$_Buffered_merge_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
PUBLIC	?_Maxlen@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandTarget>::_Maxlen
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAVCvHomelandTarget@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget>
; Function compile flags: /Odtp
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z
_TEXT	SEGMENT
__Count2$231715 = -8					; size = 4
__Mid$231716 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>, COMDAT

; 3381 : 	{	//  sort preserving order of equivalents, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 356				; 00000164H

; 3382 : 	if (_Count <= _ISORT_MAX)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jg	SHORT $LN4@Stable_sor@6

; 3383 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAVCvHomelandTarget@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget>
	add	esp, 12					; 0000000cH

; 3384 : 	else

	jmp	$LN5@Stable_sor@6
$LN4@Stable_sor@6:

; 3385 : 		{	// sort halves and merge
; 3386 : 		_Diff _Count2 = (_Count + 1) / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$231715[ebp], eax

; 3387 : 		_BidIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$231716[ebp], edx

; 3388 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$231715[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Mid$231716[ebp]
	mov	DWORD PTR __Mid$231716[ebp], eax

; 3389 : 
; 3390 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandTarget>::_Maxlen
	cmp	DWORD PTR __Count2$231715[ebp], eax
	jg	SHORT $LN2@Stable_sor@6

; 3391 : 			{	// temp buffer big enough, sort each half using buffer
; 3392 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count2$231715[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$231716[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
	add	esp, 16					; 00000010H

; 3393 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Count2$231715[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$231716[ebp]
	push	edx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
	add	esp, 16					; 00000010H

; 3394 : 			}
; 3395 : 		else

	jmp	SHORT $LN1@Stable_sor@6
$LN2@Stable_sor@6:

; 3396 : 			{	// temp buffer not big enough, divide and conquer
; 3397 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$231715[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$231716[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
	add	esp, 16					; 00000010H

; 3398 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, DWORD PTR __Count2$231715[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$231716[ebp]
	push	ecx
	call	??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
	add	esp, 16					; 00000010H
$LN1@Stable_sor@6:

; 3399 : 			}
; 3400 : 
; 3401 : 		_Buffered_merge(_First, _Mid, _Last,
; 3402 : 			_Count2, _Count - _Count2, _Tempbuf);	// merge sorted halves

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Count2$231715[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$231715[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$231716[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Buffered_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Buffered_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
	add	esp, 24					; 00000018H
$LN5@Stable_sor@6:

; 3403 : 		}
; 3404 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
PUBLIC	??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Buffered_merge_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
PUBLIC	?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen
PUBLIC	??$_Insertion_sort1@PAVCvHomelandUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z0@Z ; std::_Insertion_sort1<CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),CvHomelandUnit>
; Function compile flags: /Odtp
;	COMDAT ??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z
_TEXT	SEGMENT
__Count2$231796 = -8					; size = 4
__Mid$231797 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z PROC ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 3529 : 	{	// sort preserving order of equivalents, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H

; 3530 : 	if (_Count <= _ISORT_MAX)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jg	SHORT $LN4@Stable_sor@7

; 3531 : 		std::_Insertion_sort(_First, _Last, _Pred);	// small

	push	0
	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Insertion_sort1@PAVCvHomelandUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z0@Z ; std::_Insertion_sort1<CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),CvHomelandUnit>
	add	esp, 16					; 00000010H

; 3532 : 	else

	jmp	$LN5@Stable_sor@7
$LN4@Stable_sor@7:

; 3533 : 		{	// sort halves and merge
; 3534 : 		_Diff _Count2 = (_Count + 1) / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$231796[ebp], eax

; 3535 : 		_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$231797[ebp], eax

; 3536 : 		std::advance(_Mid, _Count2);

	mov	ecx, DWORD PTR __Count2$231796[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Mid$231797[ebp]
	mov	DWORD PTR __Mid$231797[ebp], ecx

; 3537 : 
; 3538 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen
	cmp	DWORD PTR __Count2$231796[ebp], eax
	jg	SHORT $LN2@Stable_sor@7

; 3539 : 			{	// temp buffer big enough, sort each half using buffer
; 3540 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	mov	edx, DWORD PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$231796[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$231797[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Buffered_merge_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 20					; 00000014H

; 3541 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
; 3542 : 				_Tempbuf, _Pred);

	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Count2$231796[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$231797[ebp]
	push	edx
	call	??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Buffered_merge_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 20					; 00000014H

; 3543 : 			}
; 3544 : 		else

	jmp	SHORT $LN1@Stable_sor@7
$LN2@Stable_sor@7:

; 3545 : 			{	// temp buffer not big enough, divide and conquer
; 3546 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count2$231796[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$231797[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 20					; 00000014H

; 3547 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);

	mov	edx, DWORD PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Count2$231796[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$231797[ebp]
	push	eax
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 20					; 00000014H
$LN1@Stable_sor@7:

; 3548 : 			}
; 3549 : 
; 3550 : 		_Buffered_merge(_First, _Mid, _Last,
; 3551 : 			_Count2, _Count - _Count2, _Tempbuf, _Pred);	// merge halves

	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Count2$231796[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$231796[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$231797[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Buffered_merge@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 28					; 0000001cH
$LN5@Stable_sor@7:

; 3552 : 		}
; 3553 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ENDP ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit>
PUBLIC	??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Buffered_merge_sort<CvHomelandUnit *,int,CvHomelandUnit>
PUBLIC	??$_Insertion_sort1@PAVCvHomelandUnit@@V1@@std@@YAXPAVCvHomelandUnit@@00@Z ; std::_Insertion_sort1<CvHomelandUnit *,CvHomelandUnit>
; Function compile flags: /Odtp
;	COMDAT ??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z
_TEXT	SEGMENT
__Count2$231840 = -8					; size = 4
__Mid$231841 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z PROC ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>, COMDAT

; 3381 : 	{	//  sort preserving order of equivalents, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 360				; 00000168H

; 3382 : 	if (_Count <= _ISORT_MAX)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jg	SHORT $LN4@Stable_sor@8

; 3383 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Insertion_sort1@PAVCvHomelandUnit@@V1@@std@@YAXPAVCvHomelandUnit@@00@Z ; std::_Insertion_sort1<CvHomelandUnit *,CvHomelandUnit>
	add	esp, 12					; 0000000cH

; 3384 : 	else

	jmp	$LN5@Stable_sor@8
$LN4@Stable_sor@8:

; 3385 : 		{	// sort halves and merge
; 3386 : 		_Diff _Count2 = (_Count + 1) / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$231840[ebp], eax

; 3387 : 		_BidIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$231841[ebp], edx

; 3388 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$231840[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Mid$231841[ebp]
	mov	DWORD PTR __Mid$231841[ebp], eax

; 3389 : 
; 3390 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen
	cmp	DWORD PTR __Count2$231840[ebp], eax
	jg	SHORT $LN2@Stable_sor@8

; 3391 : 			{	// temp buffer big enough, sort each half using buffer
; 3392 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count2$231840[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$231841[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Buffered_merge_sort<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 16					; 00000010H

; 3393 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Count2$231840[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$231841[ebp]
	push	edx
	call	??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Buffered_merge_sort<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 16					; 00000010H

; 3394 : 			}
; 3395 : 		else

	jmp	SHORT $LN1@Stable_sor@8
$LN2@Stable_sor@8:

; 3396 : 			{	// temp buffer not big enough, divide and conquer
; 3397 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$231840[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$231841[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 16					; 00000010H

; 3398 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, DWORD PTR __Count2$231840[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$231841[ebp]
	push	ecx
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 16					; 00000010H
$LN1@Stable_sor@8:

; 3399 : 			}
; 3400 : 
; 3401 : 		_Buffered_merge(_First, _Mid, _Last,
; 3402 : 			_Count2, _Count - _Count2, _Tempbuf);	// merge sorted halves

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Count2$231840[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$231840[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$231841[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Buffered_merge@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 24					; 00000018H
$LN5@Stable_sor@8:

; 3403 : 		}
; 3404 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ENDP ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T270157 = -28						; size = 4
__Vptr$270155 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$270155[ebp], ecx
	mov	edx, DWORD PTR __Vptr$270155[ebp]
	mov	DWORD PTR $T270157[ebp], edx
	cmp	DWORD PTR $T270157[ebp], 0
	je	SHORT $LN18@Uninit_cop
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR $T270157[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T270157[ebp]
	mov	DWORD PTR tv84[ebp], ecx
	jmp	SHORT $LN14@Uninit_cop
$LN18@Uninit_cop:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_cop:
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Median<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z
_TEXT	SEGMENT
$T270353 = -124						; size = 4
__Tmp$270349 = -120					; size = 8
$T270333 = -112						; size = 4
$T270332 = -108						; size = 4
__Tmp$270328 = -104					; size = 8
$T270312 = -96						; size = 4
__Tmp$270311 = -92					; size = 8
$T270292 = -84						; size = 4
$T270291 = -80						; size = 4
__Tmp$270290 = -76					; size = 8
$T270271 = -68						; size = 4
$T270270 = -64						; size = 4
__Tmp$270269 = -60					; size = 8
$T270247 = -52						; size = 4
$T270246 = -48						; size = 4
__Tmp$270245 = -44					; size = 8
$T270220 = -36						; size = 4
__Tmp$270219 = -32					; size = 8
__Plast$ = -20						; size = 4
__Glast$ = -16						; size = 4
__Pfirst$ = -12						; size = 4
__Gfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$[ebp], edx

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Median<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Pfirst$[ebp], eax

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
$LN27@Unguarded_@2:

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Pfirst$[ebp]
	jae	SHORT $LN25@Unguarded_@2
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax-4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN25@Unguarded_@2
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax-4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN25@Unguarded_@2

; 3033 : 		--_Pfirst;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	jmp	SHORT $LN27@Unguarded_@2
$LN25@Unguarded_@2:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	mov	edx, DWORD PTR __Plast$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	SHORT $LN24@Unguarded_@2
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN24@Unguarded_@2
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN24@Unguarded_@2

; 3037 : 		++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
	jmp	SHORT $LN25@Unguarded_@2
$LN24@Unguarded_@2:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Gfirst$[ebp], edx

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Glast$[ebp], eax
$LN23@Unguarded_@2:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	jmp	SHORT $LN21@Unguarded_@2
$LN20@Unguarded_@2:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN21@Unguarded_@2:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	$LN19@Unguarded_@2

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN44@Unguarded_@2
	jmp	SHORT $LN17@Unguarded_@2

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

$LN44@Unguarded_@2:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN16@Unguarded_@2

; 3048 : 				break;

	jmp	SHORT $LN19@Unguarded_@2

; 3049 : 			else

	jmp	SHORT $LN17@Unguarded_@2
$LN16@Unguarded_@2:

; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T270220[ebp], ecx
	mov	edx, DWORD PTR __Plast$[ebp]
	add	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR $T270220[ebp]
	cmp	eax, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN17@Unguarded_@2
	mov	ecx, DWORD PTR $T270220[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$270219[ebp], edx
	mov	eax, DWORD PTR $T270220[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$270219[ebp+4], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T270220[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	ecx, DWORD PTR __Tmp$270219[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$270219[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN17@Unguarded_@2:
	jmp	$LN20@Unguarded_@2
$LN19@Unguarded_@2:

; 3051 : 		for (; _First < _Glast; --_Glast)

	jmp	SHORT $LN14@Unguarded_@2
$LN13@Unguarded_@2:
	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Glast$[ebp], eax
$LN14@Unguarded_@2:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	jae	$LN12@Unguarded_@2

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx-4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN55@Unguarded_@2
	jmp	SHORT $LN10@Unguarded_@2

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

$LN55@Unguarded_@2:
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN9@Unguarded_@2

; 3055 : 				break;

	jmp	SHORT $LN12@Unguarded_@2

; 3056 : 			else

	jmp	SHORT $LN10@Unguarded_@2
$LN9@Unguarded_@2:

; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	mov	eax, DWORD PTR __Pfirst$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Pfirst$[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T270247[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T270246[ebp], edx
	mov	eax, DWORD PTR $T270246[ebp]
	cmp	eax, DWORD PTR $T270247[ebp]
	je	SHORT $LN10@Unguarded_@2
	mov	ecx, DWORD PTR $T270246[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$270245[ebp], edx
	mov	eax, DWORD PTR $T270246[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$270245[ebp+4], ecx
	mov	edx, DWORD PTR $T270247[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T270246[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T270247[ebp]
	mov	ecx, DWORD PTR __Tmp$270245[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$270245[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN10@Unguarded_@2:
	jmp	$LN13@Unguarded_@2
$LN12@Unguarded_@2:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	SHORT $LN7@Unguarded_@2
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN7@Unguarded_@2

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN28@Unguarded_@2
$LN7@Unguarded_@2:

; 3060 : 
; 3061 : 		if (_Glast == _First)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	$LN6@Unguarded_@2

; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	mov	ecx, DWORD PTR __Plast$[ebp]
	cmp	ecx, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN5@Unguarded_@2

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T270271[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T270270[ebp], eax
	mov	ecx, DWORD PTR $T270270[ebp]
	cmp	ecx, DWORD PTR $T270271[ebp]
	je	SHORT $LN5@Unguarded_@2
	mov	edx, DWORD PTR $T270270[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$270269[ebp], eax
	mov	ecx, DWORD PTR $T270270[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$270269[ebp+4], edx
	mov	eax, DWORD PTR $T270271[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T270270[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T270271[ebp]
	mov	edx, DWORD PTR __Tmp$270269[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$270269[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN5@Unguarded_@2:

; 3065 : 			++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx

; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T270292[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T270291[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	add	edx, 8
	mov	DWORD PTR __Gfirst$[ebp], edx
	mov	eax, DWORD PTR $T270291[ebp]
	cmp	eax, DWORD PTR $T270292[ebp]
	je	SHORT $LN73@Unguarded_@2
	mov	ecx, DWORD PTR $T270291[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$270290[ebp], edx
	mov	eax, DWORD PTR $T270291[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$270290[ebp+4], ecx
	mov	edx, DWORD PTR $T270292[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T270291[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T270292[ebp]
	mov	ecx, DWORD PTR __Tmp$270290[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$270290[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN73@Unguarded_@2:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)

	jmp	$LN4@Unguarded_@2
$LN6@Unguarded_@2:
	mov	eax, DWORD PTR __Gfirst$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	$LN3@Unguarded_@2

; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Glast$[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Pfirst$[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __Pfirst$[ebp]
	je	SHORT $LN2@Unguarded_@2

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T270312[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	cmp	edx, DWORD PTR $T270312[ebp]
	je	SHORT $LN2@Unguarded_@2
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$270311[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$270311[ebp+4], eax
	mov	ecx, DWORD PTR $T270312[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T270312[ebp]
	mov	eax, DWORD PTR __Tmp$270311[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$270311[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN2@Unguarded_@2:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T270333[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T270332[ebp], ecx
	mov	edx, DWORD PTR $T270332[ebp]
	cmp	edx, DWORD PTR $T270333[ebp]
	je	SHORT $LN87@Unguarded_@2
	mov	eax, DWORD PTR $T270332[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$270328[ebp], ecx
	mov	edx, DWORD PTR $T270332[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$270328[ebp+4], eax
	mov	ecx, DWORD PTR $T270333[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T270332[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T270333[ebp]
	mov	eax, DWORD PTR __Tmp$270328[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$270328[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN87@Unguarded_@2:

; 3073 : 			}
; 3074 : 		else

	jmp	SHORT $LN4@Unguarded_@2
$LN3@Unguarded_@2:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Glast$[ebp], edx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T270353[ebp], eax
	mov	ecx, DWORD PTR $T270353[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	je	SHORT $LN94@Unguarded_@2
	mov	edx, DWORD PTR $T270353[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$270349[ebp], eax
	mov	ecx, DWORD PTR $T270353[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$270349[ebp+4], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T270353[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	edx, DWORD PTR __Tmp$270349[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$270349[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN94@Unguarded_@2:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN4@Unguarded_@2:

; 3076 : 		}

	jmp	$LN23@Unguarded_@2
$LN28@Unguarded_@2:

; 3077 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Median<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z
_TEXT	SEGMENT
$T270527 = -124						; size = 4
__Tmp$270522 = -120					; size = 8
$T270507 = -112						; size = 4
$T270506 = -108						; size = 4
__Tmp$270501 = -104					; size = 8
$T270486 = -96						; size = 4
__Tmp$270481 = -92					; size = 8
$T270466 = -84						; size = 4
$T270465 = -80						; size = 4
__Tmp$270460 = -76					; size = 8
$T270445 = -68						; size = 4
$T270444 = -64						; size = 4
__Tmp$270442 = -60					; size = 8
$T270421 = -52						; size = 4
$T270420 = -48						; size = 4
__Tmp$270418 = -44					; size = 8
$T270394 = -36						; size = 4
__Tmp$270392 = -32					; size = 8
__Plast$ = -20						; size = 4
__Glast$ = -16						; size = 4
__Pfirst$ = -12						; size = 4
__Gfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<CvCity *,64,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$[ebp], edx

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Median<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Pfirst$[ebp], eax

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
$LN27@Unguarded_@3:

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Pfirst$[ebp]
	jae	SHORT $LN25@Unguarded_@3
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax-4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN25@Unguarded_@3
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax-4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN25@Unguarded_@3

; 3033 : 		--_Pfirst;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	jmp	SHORT $LN27@Unguarded_@3
$LN25@Unguarded_@3:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	mov	edx, DWORD PTR __Plast$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	SHORT $LN24@Unguarded_@3
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN24@Unguarded_@3
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN24@Unguarded_@3

; 3037 : 		++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
	jmp	SHORT $LN25@Unguarded_@3
$LN24@Unguarded_@3:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Gfirst$[ebp], edx

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Glast$[ebp], eax
$LN23@Unguarded_@3:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	jmp	SHORT $LN21@Unguarded_@3
$LN20@Unguarded_@3:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN21@Unguarded_@3:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	$LN19@Unguarded_@3

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN44@Unguarded_@3
	jmp	SHORT $LN17@Unguarded_@3

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

$LN44@Unguarded_@3:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN16@Unguarded_@3

; 3048 : 				break;

	jmp	SHORT $LN19@Unguarded_@3

; 3049 : 			else

	jmp	SHORT $LN17@Unguarded_@3
$LN16@Unguarded_@3:

; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T270394[ebp], ecx
	mov	edx, DWORD PTR __Plast$[ebp]
	add	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR $T270394[ebp]
	cmp	eax, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN17@Unguarded_@3
	mov	ecx, DWORD PTR $T270394[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$270392[ebp], edx
	mov	eax, DWORD PTR $T270394[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$270392[ebp+4], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T270394[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	ecx, DWORD PTR __Tmp$270392[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$270392[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN17@Unguarded_@3:
	jmp	$LN20@Unguarded_@3
$LN19@Unguarded_@3:

; 3051 : 		for (; _First < _Glast; --_Glast)

	jmp	SHORT $LN14@Unguarded_@3
$LN13@Unguarded_@3:
	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Glast$[ebp], eax
$LN14@Unguarded_@3:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	jae	$LN12@Unguarded_@3

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx-4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN55@Unguarded_@3
	jmp	SHORT $LN10@Unguarded_@3

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

$LN55@Unguarded_@3:
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN9@Unguarded_@3

; 3055 : 				break;

	jmp	SHORT $LN12@Unguarded_@3

; 3056 : 			else

	jmp	SHORT $LN10@Unguarded_@3
$LN9@Unguarded_@3:

; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	mov	eax, DWORD PTR __Pfirst$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Pfirst$[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T270421[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T270420[ebp], edx
	mov	eax, DWORD PTR $T270420[ebp]
	cmp	eax, DWORD PTR $T270421[ebp]
	je	SHORT $LN10@Unguarded_@3
	mov	ecx, DWORD PTR $T270420[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$270418[ebp], edx
	mov	eax, DWORD PTR $T270420[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$270418[ebp+4], ecx
	mov	edx, DWORD PTR $T270421[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T270420[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T270421[ebp]
	mov	ecx, DWORD PTR __Tmp$270418[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$270418[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN10@Unguarded_@3:
	jmp	$LN13@Unguarded_@3
$LN12@Unguarded_@3:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	SHORT $LN7@Unguarded_@3
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN7@Unguarded_@3

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN28@Unguarded_@3
$LN7@Unguarded_@3:

; 3060 : 
; 3061 : 		if (_Glast == _First)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	$LN6@Unguarded_@3

; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	mov	ecx, DWORD PTR __Plast$[ebp]
	cmp	ecx, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN5@Unguarded_@3

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T270445[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T270444[ebp], eax
	mov	ecx, DWORD PTR $T270444[ebp]
	cmp	ecx, DWORD PTR $T270445[ebp]
	je	SHORT $LN5@Unguarded_@3
	mov	edx, DWORD PTR $T270444[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$270442[ebp], eax
	mov	ecx, DWORD PTR $T270444[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$270442[ebp+4], edx
	mov	eax, DWORD PTR $T270445[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T270444[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T270445[ebp]
	mov	edx, DWORD PTR __Tmp$270442[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$270442[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN5@Unguarded_@3:

; 3065 : 			++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx

; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T270466[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T270465[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	add	edx, 8
	mov	DWORD PTR __Gfirst$[ebp], edx
	mov	eax, DWORD PTR $T270465[ebp]
	cmp	eax, DWORD PTR $T270466[ebp]
	je	SHORT $LN73@Unguarded_@3
	mov	ecx, DWORD PTR $T270465[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$270460[ebp], edx
	mov	eax, DWORD PTR $T270465[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$270460[ebp+4], ecx
	mov	edx, DWORD PTR $T270466[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T270465[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T270466[ebp]
	mov	ecx, DWORD PTR __Tmp$270460[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$270460[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN73@Unguarded_@3:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)

	jmp	$LN4@Unguarded_@3
$LN6@Unguarded_@3:
	mov	eax, DWORD PTR __Gfirst$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	$LN3@Unguarded_@3

; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Glast$[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Pfirst$[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __Pfirst$[ebp]
	je	SHORT $LN2@Unguarded_@3

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T270486[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	cmp	edx, DWORD PTR $T270486[ebp]
	je	SHORT $LN2@Unguarded_@3
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$270481[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$270481[ebp+4], eax
	mov	ecx, DWORD PTR $T270486[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T270486[ebp]
	mov	eax, DWORD PTR __Tmp$270481[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$270481[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN2@Unguarded_@3:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T270507[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T270506[ebp], ecx
	mov	edx, DWORD PTR $T270506[ebp]
	cmp	edx, DWORD PTR $T270507[ebp]
	je	SHORT $LN87@Unguarded_@3
	mov	eax, DWORD PTR $T270506[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$270501[ebp], ecx
	mov	edx, DWORD PTR $T270506[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$270501[ebp+4], eax
	mov	ecx, DWORD PTR $T270507[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T270506[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T270507[ebp]
	mov	eax, DWORD PTR __Tmp$270501[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$270501[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN87@Unguarded_@3:

; 3073 : 			}
; 3074 : 		else

	jmp	SHORT $LN4@Unguarded_@3
$LN3@Unguarded_@3:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Glast$[ebp], edx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T270527[ebp], eax
	mov	ecx, DWORD PTR $T270527[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	je	SHORT $LN94@Unguarded_@3
	mov	edx, DWORD PTR $T270527[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$270522[ebp], eax
	mov	ecx, DWORD PTR $T270527[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$270522[ebp+4], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T270527[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	edx, DWORD PTR __Tmp$270522[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$270522[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN94@Unguarded_@3:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN4@Unguarded_@3:

; 3076 : 		}

	jmp	$LN23@Unguarded_@3
$LN28@Unguarded_@3:

; 3077 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAPAVCvPlot@@IPAV1@@stdext@@YAXPAPAVCvPlot@@IABQAV1@@Z
_TEXT	SEGMENT
$T270557 = -22						; size = 1
$T270556 = -21						; size = 1
$T270555 = -20						; size = 4
$T270546 = -13						; size = 1
$T270545 = -12						; size = 4
$T270544 = -8						; size = 4
$T270548 = -4						; size = 1
$T270531 = -2						; size = 1
$T270530 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVCvPlot@@IPAV1@@stdext@@YAXPAPAVCvPlot@@IABQAV1@@Z PROC ; stdext::unchecked_fill_n<CvPlot * *,unsigned int,CvPlot *>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T270530[ebp], al
	mov	cl, BYTE PTR $T270530[ebp]
	mov	BYTE PTR $T270557[ebp], cl
	mov	dl, BYTE PTR $T270531[ebp]
	mov	BYTE PTR $T270556[ebp], dl
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T270555[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T270548[ebp], cl
	mov	dl, BYTE PTR $T270548[ebp]
	mov	BYTE PTR $T270546[ebp], dl
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR $T270545[ebp], eax
	mov	ecx, DWORD PTR $T270555[ebp]
	mov	DWORD PTR $T270544[ebp], ecx
	jmp	SHORT $LN9@unchecked_
$LN8@unchecked_:
	mov	edx, DWORD PTR $T270545[ebp]
	sub	edx, 1
	mov	DWORD PTR $T270545[ebp], edx
	mov	eax, DWORD PTR $T270544[ebp]
	add	eax, 4
	mov	DWORD PTR $T270544[ebp], eax
$LN9@unchecked_:
	cmp	DWORD PTR $T270545[ebp], 0
	jbe	SHORT $LN1@unchecked_
	mov	ecx, DWORD PTR $T270544[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN8@unchecked_
$LN1@unchecked_:

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPAVCvPlot@@IPAV1@@stdext@@YAXPAPAVCvPlot@@IABQAV1@@Z ENDP ; stdext::unchecked_fill_n<CvPlot * *,unsigned int,CvPlot *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z
_TEXT	SEGMENT
$T270587 = -22						; size = 1
$T270586 = -21						; size = 1
$T270585 = -20						; size = 4
$T270576 = -13						; size = 1
$T270575 = -12						; size = 4
$T270574 = -8						; size = 4
$T270578 = -4						; size = 1
$T270561 = -2						; size = 1
$T270560 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z PROC ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T270560[ebp], al
	mov	cl, BYTE PTR $T270560[ebp]
	mov	BYTE PTR $T270587[ebp], cl
	mov	dl, BYTE PTR $T270561[ebp]
	mov	BYTE PTR $T270586[ebp], dl
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T270585[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T270578[ebp], cl
	mov	dl, BYTE PTR $T270578[ebp]
	mov	BYTE PTR $T270576[ebp], dl
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR $T270575[ebp], eax
	mov	ecx, DWORD PTR $T270585[ebp]
	mov	DWORD PTR $T270574[ebp], ecx
	jmp	SHORT $LN9@unchecked_@2
$LN8@unchecked_@2:
	mov	edx, DWORD PTR $T270575[ebp]
	sub	edx, 1
	mov	DWORD PTR $T270575[ebp], edx
	mov	eax, DWORD PTR $T270574[ebp]
	add	eax, 4
	mov	DWORD PTR $T270574[ebp], eax
$LN9@unchecked_@2:
	cmp	DWORD PTR $T270575[ebp], 0
	jbe	SHORT $LN1@unchecked_@2
	mov	ecx, DWORD PTR $T270574[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN8@unchecked_@2
$LN1@unchecked_@2:

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ENDP ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@VCvHomelandMove@@@std@@YA?AU?$pair@PAVCvHomelandMove@@H@0@H@Z ; std::get_temporary_buffer<CvHomelandMove>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Maxlen@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEHXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
__Pair$232196 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CvHomelandMove>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN1@Maxlen
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $LN1@Maxlen

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR __Pair$232196[ebp]
	push	ecx
	call	??$get_temporary_buffer@VCvHomelandMove@@@std@@YA?AU?$pair@PAVCvHomelandMove@@H@0@H@Z ; std::get_temporary_buffer<CvHomelandMove>
	add	esp, 8

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$232196[ebp]
	mov	DWORD PTR [eax], ecx

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$232196[ebp]
	mov	DWORD PTR [eax+4], ecx

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$232196[ebp]
	mov	DWORD PTR [eax+8], ecx

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$232196[ebp+4]
	mov	DWORD PTR [eax+12], ecx
$LN1@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [eax+12]

; 619  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Maxlen@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CvHomelandMove>::_Maxlen
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@VCvHomelandTarget@@@std@@YA?AU?$pair@PAVCvHomelandTarget@@H@0@H@Z ; std::get_temporary_buffer<CvHomelandTarget>
; Function compile flags: /Odtp
;	COMDAT ?_Maxlen@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEHXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
__Pair$232245 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CvHomelandTarget>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN1@Maxlen@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $LN1@Maxlen@2

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR __Pair$232245[ebp]
	push	ecx
	call	??$get_temporary_buffer@VCvHomelandTarget@@@std@@YA?AU?$pair@PAVCvHomelandTarget@@H@0@H@Z ; std::get_temporary_buffer<CvHomelandTarget>
	add	esp, 8

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$232245[ebp]
	mov	DWORD PTR [eax], ecx

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$232245[ebp]
	mov	DWORD PTR [eax+4], ecx

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$232245[ebp]
	mov	DWORD PTR [eax+8], ecx

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$232245[ebp+4]
	mov	DWORD PTR [eax+12], ecx
$LN1@Maxlen@2:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [eax+12]

; 619  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Maxlen@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CvHomelandTarget>::_Maxlen
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@VCvHomelandUnit@@@std@@YA?AU?$pair@PAVCvHomelandUnit@@H@0@H@Z ; std::get_temporary_buffer<CvHomelandUnit>
; Function compile flags: /Odtp
;	COMDAT ?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
__Pair$232294 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN1@Maxlen@3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $LN1@Maxlen@3

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR __Pair$232294[ebp]
	push	ecx
	call	??$get_temporary_buffer@VCvHomelandUnit@@@std@@YA?AU?$pair@PAVCvHomelandUnit@@H@0@H@Z ; std::get_temporary_buffer<CvHomelandUnit>
	add	esp, 8

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$232294[ebp]
	mov	DWORD PTR [eax], ecx

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$232294[ebp]
	mov	DWORD PTR [eax+4], ecx

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$232294[ebp]
	mov	DWORD PTR [eax+8], ecx

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$232294[ebp+4]
	mov	DWORD PTR [eax+12], ecx
$LN1@Maxlen@3:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [eax+12]

; 619  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen
_TEXT	ENDS
PUBLIC	??$_Med3@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z ; std::_Med3<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Median@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__Step$232317 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Median@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z PROC ; std::_Median<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 3168 : 	{	// sort median element to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H

; 3169 : 	if (40 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median

; 3170 : 		{	// median of nine
; 3171 : 		size_t _Step = (_Last - _First + 1) / 8;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	add	eax, 1
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR __Step$232317[ebp], eax

; 3172 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);

	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Step$232317[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR __First$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	mov	edx, DWORD PTR __Step$232317[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Med3@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z ; std::_Med3<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 16					; 00000010H

; 3173 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Step$232317[ebp]
	mov	edx, DWORD PTR __Mid$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Step$232317[ebp]
	shl	edx, 3
	mov	eax, DWORD PTR __Mid$[ebp]
	sub	eax, edx
	push	eax
	call	??$_Med3@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z ; std::_Med3<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 16					; 00000010H

; 3174 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);

	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$232317[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Step$232317[ebp]
	shl	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, edx
	push	eax
	call	??$_Med3@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z ; std::_Med3<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 16					; 00000010H

; 3175 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);

	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Step$232317[ebp]
	shl	edx, 3
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Step$232317[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	call	??$_Med3@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z ; std::_Med3<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 16					; 00000010H

; 3176 : 		}
; 3177 : 	else

	jmp	SHORT $LN3@Median
$LN2@Median:

; 3178 : 		std::_Med3(_First, _Mid, _Last, _Pred);

	mov	edx, DWORD PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Med3@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z ; std::_Med3<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 16					; 00000010H
$LN3@Median:

; 3179 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Median@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z ENDP ; std::_Median<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Sort_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
$T271864 = -8						; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Sort_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z PROC ; std::_Sort_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 2232 : 	{	// order heap by repeatedly popping, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 2233 : 	for (; 1 < _Last - _First; --_Last)

	jmp	SHORT $LN3@Sort_heap
$LN2@Sort_heap:
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Last$[ebp], eax
$LN3@Sort_heap:
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	cmp	ecx, 1
	jle	SHORT $LN4@Sort_heap

; 2234 : 		std::pop_heap(_First, _Last, _Pred);

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN7@Sort_heap
	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR [eax-8]
	mov	edx, DWORD PTR [eax-4]
	mov	DWORD PTR $T271864[ebp], ecx
	mov	DWORD PTR $T271864[ebp+4], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [eax-8], ecx
	mov	DWORD PTR [eax-4], edx
	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T271864[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T271864[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	push	ecx
	push	0
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Adjust_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@HHU10@P6A_NABU10@2@Z@Z ; std::_Adjust_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 24					; 00000018H
$LN7@Sort_heap:
	jmp	SHORT $LN2@Sort_heap
$LN4@Sort_heap:

; 2235 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z ENDP ; std::_Sort_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@ZU12@@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z0@Z
_TEXT	SEGMENT
$T271911 = -52						; size = 4
$T271910 = -48						; size = 4
$T271894 = -42						; size = 1
$T271893 = -41						; size = 1
$T271892 = -40						; size = 4
$T271891 = -36						; size = 4
$T271890 = -32						; size = 4
__Cat$271900 = -24					; size = 1
$T271898 = -23						; size = 1
$T271897 = -22						; size = 1
$T271896 = -21						; size = 1
__First1$232392 = -20					; size = 4
__Val$232382 = -16					; size = 8
__Next1$232381 = -8					; size = 4
__Next$232377 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Insertion_sort1@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@ZU12@@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z0@Z PROC ; std::_Insertion_sort1<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &),std::pair<int,CvPlot *> >, COMDAT

; 3123 : 	{	// insertion sort [_First, _Last), using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 3124 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$232377[ebp], ecx
$LN7@Insertion_:
	mov	edx, DWORD PTR __Next$232377[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$232377[ebp], edx
	mov	eax, DWORD PTR __Next$232377[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 3126 : 			{	// order next element
; 3127 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$232377[ebp]
	mov	DWORD PTR __Next1$232381[ebp], ecx

; 3128 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$232377[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Val$232382[ebp], eax
	mov	DWORD PTR __Val$232382[ebp+4], ecx

; 3129 : 
; 3130 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR __Val$232382[ebp]
	push	eax
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@Insertion_

; 3131 : 				{	// found new earliest element, move to front
; 3132 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	edx, DWORD PTR __Next1$232381[ebp]
	add	edx, 8
	mov	DWORD PTR __Next1$232381[ebp], edx
	mov	eax, DWORD PTR __Next1$232381[ebp]
	mov	DWORD PTR $T271911[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T271910[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T271896[ebp], dl
	mov	al, BYTE PTR __Cat$271900[ebp]
	mov	BYTE PTR $T271897[ebp], al
	mov	cl, BYTE PTR $T271896[ebp]
	mov	BYTE PTR $T271894[ebp], cl
	mov	dl, BYTE PTR $T271898[ebp]
	mov	BYTE PTR $T271893[ebp], dl
	mov	eax, DWORD PTR $T271911[ebp]
	mov	DWORD PTR $T271892[ebp], eax
	mov	ecx, DWORD PTR __Next$232377[ebp]
	mov	DWORD PTR $T271891[ebp], ecx
	mov	edx, DWORD PTR $T271910[ebp]
	mov	DWORD PTR $T271890[ebp], edx
$LN18@Insertion_:
	mov	eax, DWORD PTR $T271890[ebp]
	cmp	eax, DWORD PTR $T271891[ebp]
	je	SHORT $LN11@Insertion_
	mov	ecx, DWORD PTR $T271891[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T271891[ebp], ecx
	mov	edx, DWORD PTR $T271892[ebp]
	sub	edx, 8
	mov	DWORD PTR $T271892[ebp], edx
	mov	eax, DWORD PTR $T271891[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T271892[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN18@Insertion_
$LN11@Insertion_:

; 3133 : 				*_First = _Val;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Val$232382[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Val$232382[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 3134 : 				}
; 3135 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 3136 : 				{	// look for insertion point after first
; 3137 : 				for (_BidIt _First1 = _Next1;

	mov	ecx, DWORD PTR __Next1$232381[ebp]
	mov	DWORD PTR __First1$232392[ebp], ecx

; 3138 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3139 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_
$LN2@Insertion_:
	mov	edx, DWORD PTR __First1$232392[ebp]
	mov	DWORD PTR __Next1$232381[ebp], edx
$LN3@Insertion_:
	mov	eax, DWORD PTR __First1$232392[ebp]
	sub	eax, 8
	mov	DWORD PTR __First1$232392[ebp], eax
	mov	ecx, DWORD PTR __First1$232392[ebp]
	push	ecx
	lea	edx, DWORD PTR __Val$232382[ebp]
	push	edx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@Insertion_

; 3140 : 					*_Next1 = *_First1;	// move hole down

	mov	ecx, DWORD PTR __First1$232392[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Next1$232381[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN2@Insertion_
$LN1@Insertion_:

; 3141 : 				*_Next1 = _Val;	// insert element in hole

	mov	edx, DWORD PTR __Next1$232381[ebp]
	mov	eax, DWORD PTR __Val$232382[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Val$232382[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN4@Insertion_:

; 3142 : 				}
; 3143 : 			}

	jmp	$LN7@Insertion_
$LN9@Insertion_:

; 3144 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@ZU12@@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z0@Z ENDP ; std::_Insertion_sort1<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &),std::pair<int,CvPlot *> >
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvHomelandMove@@PAV1@H@std@@YAXPAVCvHomelandMove@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandMove *,CvHomelandMove *,int>
PUBLIC	??$_Unchecked_chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@stdext@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,int>
; Function compile flags: /Odtp
;	COMDAT ??$_Buffered_merge_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z
_TEXT	SEGMENT
tv139 = -216						; size = 4
$T272178 = -101						; size = 1
$T272016 = -100						; size = 4
$T272012 = -96						; size = 4
$T271975 = -72						; size = 4
$T271948 = -48						; size = 4
$T271914 = -20						; size = 4
__Chunk$232447 = -16					; size = 4
__Midend$232445 = -12					; size = 4
__Nleft$232441 = -8					; size = 4
__Mid$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Buffered_merge_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z PROC ; std::_Buffered_merge_sort<CvHomelandMove *,int,CvHomelandMove>, COMDAT

; 3355 : 	{	// sort using temp buffer for merges, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H

; 3356 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3357 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Nleft$232441[ebp], ecx
	jmp	SHORT $LN6@Buffered_m
$LN5@Buffered_m:
	mov	edx, DWORD PTR __Nleft$232441[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR __Nleft$232441[ebp], edx
$LN6@Buffered_m:
	cmp	DWORD PTR __Nleft$232441[ebp], 32	; 00000020H
	jl	SHORT $LN36@Buffered_m

; 3358 : 		{	// sort chunks
; 3359 : 		_BidIt _Midend = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Midend$232445[ebp], eax

; 3360 : 		std::advance(_Midend, (int)_ISORT_MAX);

	mov	ecx, 32					; 00000020H
	shl	ecx, 3
	add	ecx, DWORD PTR __Midend$232445[ebp]
	mov	DWORD PTR __Midend$232445[ebp], ecx

; 3361 : 
; 3362 : 		std::_Insertion_sort(_Mid, _Midend);

	mov	edx, DWORD PTR __Midend$232445[ebp]
	mov	DWORD PTR $T271948[ebp], edx
	push	0
	mov	eax, DWORD PTR $T271948[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	call	??$_Insertion_sort1@PAVCvHomelandMove@@V1@@std@@YAXPAVCvHomelandMove@@00@Z ; std::_Insertion_sort1<CvHomelandMove *,CvHomelandMove>
	add	esp, 12					; 0000000cH

; 3363 : 		_Mid = _Midend;

	mov	edx, DWORD PTR __Midend$232445[ebp]
	mov	DWORD PTR __Mid$[ebp], edx

; 3364 : 		}

	jmp	SHORT $LN5@Buffered_m

; 3365 : 	std::_Insertion_sort(_Mid, _Last);	// sort partial last chunk

$LN36@Buffered_m:
	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	call	??$_Insertion_sort1@PAVCvHomelandMove@@V1@@std@@YAXPAVCvHomelandMove@@00@Z ; std::_Insertion_sort1<CvHomelandMove *,CvHomelandMove>
	add	esp, 12					; 0000000cH

; 3366 : 
; 3367 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	DWORD PTR __Chunk$232447[ebp], 32	; 00000020H
	jmp	SHORT $LN3@Buffered_m
$LN2@Buffered_m:
	mov	edx, DWORD PTR __Chunk$232447[ebp]
	shl	edx, 1
	mov	DWORD PTR __Chunk$232447[ebp], edx
$LN3@Buffered_m:
	mov	eax, DWORD PTR __Chunk$232447[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jge	$LN7@Buffered_m

; 3368 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3369 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3370 : 			_Chunk, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Chunk$232447[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T271914[ebp], esp
	mov	DWORD PTR $T271975[ebp], edx
	mov	eax, DWORD PTR $T271975[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T271975[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T271975[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T271975[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T271975[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T271975[ebp]
	mov	DWORD PTR tv139[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@stdext@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,int>
	add	esp, 36					; 00000024H

; 3371 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3372 : 			_Chunk *= 2, _Count);

	mov	ecx, DWORD PTR __Chunk$232447[ebp]
	shl	ecx, 1
	mov	DWORD PTR __Chunk$232447[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T272012[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T272016[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T272178[ebp], dl
	movzx	eax, BYTE PTR $T272178[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Chunk$232447[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T272012[ebp]
	push	ecx
	mov	edx, DWORD PTR $T272016[ebp]
	push	edx
	call	??$_Chunked_merge@PAVCvHomelandMove@@PAV1@H@std@@YAXPAVCvHomelandMove@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandMove *,CvHomelandMove *,int>
	add	esp, 24					; 00000018H

; 3373 : 		}

	jmp	$LN2@Buffered_m
$LN7@Buffered_m:

; 3374 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ENDP ; std::_Buffered_merge_sort<CvHomelandMove *,int,CvHomelandMove>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@PAVCvHomelandMove@@HV1@@std@@YAPAVCvHomelandMove@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Buffered_rotate<CvHomelandMove *,int,CvHomelandMove>
PUBLIC	??$_Upper_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvHomelandMove *,CvHomelandMove,int>
PUBLIC	??$_Lower_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvHomelandMove *,CvHomelandMove,int>
PUBLIC	??$_Merge_backward@PAVCvHomelandMove@@PAV1@PAV1@@std@@YAPAVCvHomelandMove@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *>
PUBLIC	??$_Merge@PAVCvHomelandMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z ; stdext::unchecked_copy<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
; Function compile flags: /Odtp
;	COMDAT ??$_Buffered_merge@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z
_TEXT	SEGMENT
tv221 = -296						; size = 4
tv220 = -292						; size = 4
tv217 = -288						; size = 4
tv216 = -284						; size = 4
$T272435 = -212						; size = 4
$T272417 = -204						; size = 4
$T272416 = -200						; size = 4
$T272351 = -168						; size = 4
$T272333 = -160						; size = 4
$T272332 = -156						; size = 4
$T272306 = -149						; size = 1
$T272301 = -148						; size = 4
$T272297 = -144						; size = 4
$T272282 = -140						; size = 4
__Next$272285 = -136					; size = 4
$T272274 = -132						; size = 4
$T272261 = -120						; size = 4
$T272260 = -116						; size = 4
$T272259 = -112						; size = 4
$T272255 = -106						; size = 1
$T272254 = -105						; size = 1
$T272244 = -104						; size = 4
$T272240 = -100						; size = 4
$T272225 = -96						; size = 4
__Next$272228 = -92					; size = 4
$T272217 = -88						; size = 4
__Tmp$272203 = -76					; size = 8
$T272185 = -68						; size = 20
$T272184 = -48						; size = 4
$T272183 = -44						; size = 20
$T272182 = -24						; size = 4
__Firstn$232517 = -20					; size = 4
__Count2n$232520 = -16					; size = 4
__Midn$232537 = -12					; size = 4
__Lastn$232518 = -8					; size = 4
__Count1n$232519 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_merge@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z PROC ; std::_Buffered_merge<CvHomelandMove *,int,CvHomelandMove>, COMDAT

; 2759 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H

; 2760 : 	if (_Count1 + _Count2 == 2)

	mov	eax, DWORD PTR __Count1$[ebp]
	add	eax, DWORD PTR __Count2$[ebp]
	cmp	eax, 2
	jne	SHORT $LN9@Buffered_m@2

; 2761 : 		{	// order two one-element partitions
; 2762 : 		if (_DEBUG_LT(*_Mid, *_First))

	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN8@Buffered_m@2

; 2763 : 			std::iter_swap(_First, _Mid);

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Mid$[ebp]
	je	SHORT $LN8@Buffered_m@2
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$272203[ebp], edx
	mov	DWORD PTR __Tmp$272203[ebp+4], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR __Tmp$272203[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$272203[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN8@Buffered_m@2:

; 2764 : 		}

	jmp	$LN10@Buffered_m@2
$LN9@Buffered_m@2:

; 2765 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	edx, DWORD PTR __Count1$[ebp]
	cmp	edx, DWORD PTR __Count2$[ebp]
	jg	$LN6@Buffered_m@2
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandMove>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN6@Buffered_m@2

; 2766 : 		{	// buffer left partition, then merge
; 2767 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T272182[ebp], esp
	mov	DWORD PTR $T272217[ebp], edx
	mov	eax, DWORD PTR $T272217[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T272217[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T272217[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T272217[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T272217[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T272217[ebp]
	mov	DWORD PTR tv216[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T272183[ebp]
	push	ecx
	call	??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z ; stdext::unchecked_copy<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv217[ebp], eax
	cmp	DWORD PTR $T272183[ebp], 0
	je	SHORT $LN36@Buffered_m@2
	mov	edx, DWORD PTR $T272183[ebp]
	mov	DWORD PTR __Next$272228[ebp], edx
	jmp	SHORT $LN34@Buffered_m@2
$LN33@Buffered_m@2:
	mov	eax, DWORD PTR __Next$272228[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$272228[ebp], eax
$LN34@Buffered_m@2:
	mov	ecx, DWORD PTR __Next$272228[ebp]
	cmp	ecx, DWORD PTR $T272183[ebp+8]
	je	SHORT $LN32@Buffered_m@2
	jmp	SHORT $LN33@Buffered_m@2
$LN32@Buffered_m@2:
	mov	edx, DWORD PTR $T272183[ebp]
	mov	DWORD PTR $T272225[ebp], edx
	mov	eax, DWORD PTR $T272225[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN36@Buffered_m@2:

; 2768 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T272240[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T272244[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T272261[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T272260[ebp], edx
	mov	eax, DWORD PTR $T272244[ebp]
	mov	DWORD PTR $T272259[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T272254[ebp], cl
	movzx	edx, BYTE PTR $T272254[ebp]
	push	edx
	movzx	eax, BYTE PTR $T272255[ebp]
	push	eax
	mov	ecx, DWORD PTR $T272261[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T272260[ebp]
	push	eax
	mov	ecx, DWORD PTR $T272240[ebp]
	push	ecx
	mov	edx, DWORD PTR $T272259[ebp]
	push	edx
	call	??$_Merge@PAVCvHomelandMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2769 : 		}
; 2770 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	jmp	$LN10@Buffered_m@2
$LN6@Buffered_m@2:
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandMove>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN4@Buffered_m@2

; 2771 : 		{	// buffer right partition, then merge
; 2772 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T272184[ebp], esp
	mov	DWORD PTR $T272274[ebp], edx
	mov	eax, DWORD PTR $T272274[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T272274[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T272274[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T272274[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T272274[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T272274[ebp]
	mov	DWORD PTR tv220[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T272185[ebp]
	push	ecx
	call	??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z ; stdext::unchecked_copy<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv221[ebp], eax
	cmp	DWORD PTR $T272185[ebp], 0
	je	SHORT $LN63@Buffered_m@2
	mov	edx, DWORD PTR $T272185[ebp]
	mov	DWORD PTR __Next$272285[ebp], edx
	jmp	SHORT $LN61@Buffered_m@2
$LN60@Buffered_m@2:
	mov	eax, DWORD PTR __Next$272285[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$272285[ebp], eax
$LN61@Buffered_m@2:
	mov	ecx, DWORD PTR __Next$272285[ebp]
	cmp	ecx, DWORD PTR $T272185[ebp+8]
	je	SHORT $LN59@Buffered_m@2
	jmp	SHORT $LN60@Buffered_m@2
$LN59@Buffered_m@2:
	mov	edx, DWORD PTR $T272185[ebp]
	mov	DWORD PTR $T272282[ebp], edx
	mov	eax, DWORD PTR $T272282[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN63@Buffered_m@2:

; 2773 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid,
; 2774 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T272297[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T272301[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T272306[ebp], cl
	movzx	edx, BYTE PTR $T272306[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T272297[ebp]
	push	ecx
	mov	edx, DWORD PTR $T272301[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Merge_backward@PAVCvHomelandMove@@PAV1@PAV1@@std@@YAPAVCvHomelandMove@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *>
	add	esp, 24					; 00000018H

; 2775 : 		}
; 2776 : 	else

	jmp	$LN10@Buffered_m@2
$LN4@Buffered_m@2:

; 2777 : 		{	// buffer too small, divide and conquer
; 2778 : 		_BidIt _Firstn, _Lastn;
; 2779 : 		_Diff _Count1n, _Count2n;
; 2780 : 
; 2781 : 		if (_Count2 < _Count1)

	mov	edx, DWORD PTR __Count2$[ebp]
	cmp	edx, DWORD PTR __Count1$[ebp]
	jge	SHORT $LN2@Buffered_m@2

; 2782 : 			{	// left larger, cut it in half and partition right to match
; 2783 : 			_Count1n = _Count1 / 2, _Count2n = 0;

	mov	eax, DWORD PTR __Count1$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count1n$232519[ebp], eax
	mov	DWORD PTR __Count2n$232520[ebp], 0

; 2784 : 			_Firstn = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Firstn$232517[ebp], eax

; 2785 : 			std::advance(_Firstn, _Count1n);

	mov	ecx, DWORD PTR __Count1n$232519[ebp]
	mov	edx, DWORD PTR __Firstn$232517[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Firstn$232517[ebp], eax

; 2786 : 			_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);

	mov	ecx, DWORD PTR __Firstn$232517[ebp]
	mov	DWORD PTR $T272333[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T272332[ebp], edx
	push	0
	mov	eax, DWORD PTR $T272333[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T272332[ebp]
	push	edx
	call	??$_Lower_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvHomelandMove *,CvHomelandMove,int>
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T272332[ebp], eax
	mov	eax, DWORD PTR $T272332[ebp]
	mov	DWORD PTR __Lastn$232518[ebp], eax

; 2787 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T272351[ebp], ecx
	mov	edx, DWORD PTR __Lastn$232518[ebp]
	sub	edx, DWORD PTR $T272351[ebp]
	sar	edx, 3
	add	edx, DWORD PTR __Count2n$232520[ebp]
	mov	DWORD PTR __Count2n$232520[ebp], edx

; 2788 : 			}
; 2789 : 		else

	jmp	SHORT $LN1@Buffered_m@2
$LN2@Buffered_m@2:

; 2790 : 			{	// right larger, cut it in half and partition left to match
; 2791 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	DWORD PTR __Count1n$232519[ebp], 0
	mov	eax, DWORD PTR __Count2$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2n$232520[ebp], eax

; 2792 : 			_Lastn = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Lastn$232518[ebp], eax

; 2793 : 			std::advance(_Lastn, _Count2n);

	mov	ecx, DWORD PTR __Count2n$232520[ebp]
	mov	edx, DWORD PTR __Lastn$232518[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Lastn$232518[ebp], eax

; 2794 : 			_Firstn = std::upper_bound(_First, _Mid, *_Lastn);

	mov	ecx, DWORD PTR __Lastn$232518[ebp]
	mov	DWORD PTR $T272417[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T272416[ebp], edx
	push	0
	mov	eax, DWORD PTR $T272417[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T272416[ebp]
	push	edx
	call	??$_Upper_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvHomelandMove *,CvHomelandMove,int>
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T272416[ebp], eax
	mov	eax, DWORD PTR $T272416[ebp]
	mov	DWORD PTR __Firstn$232517[ebp], eax

; 2795 : 			_Distance(_First, _Firstn, _Count1n);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T272435[ebp], ecx
	mov	edx, DWORD PTR __Firstn$232517[ebp]
	sub	edx, DWORD PTR $T272435[ebp]
	sar	edx, 3
	add	edx, DWORD PTR __Count1n$232519[ebp]
	mov	DWORD PTR __Count1n$232519[ebp], edx
$LN1@Buffered_m@2:

; 2796 : 			}
; 2797 : 
; 2798 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2799 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2n$232520[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count1$[ebp]
	sub	edx, DWORD PTR __Count1n$232519[ebp]
	push	edx
	mov	eax, DWORD PTR __Lastn$232518[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Firstn$232517[ebp]
	push	edx
	call	??$_Buffered_rotate@PAVCvHomelandMove@@HV1@@std@@YAPAVCvHomelandMove@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Buffered_rotate<CvHomelandMove *,int,CvHomelandMove>
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Midn$232537[ebp], eax

; 2800 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2801 : 			_Count1n, _Count2n, _Tempbuf);	// merge each new part

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2n$232520[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count1n$232519[ebp]
	push	edx
	mov	eax, DWORD PTR __Midn$232537[ebp]
	push	eax
	mov	ecx, DWORD PTR __Firstn$232517[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Buffered_merge@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Buffered_merge<CvHomelandMove *,int,CvHomelandMove>
	add	esp, 24					; 00000018H

; 2802 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2803 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$[ebp]
	sub	ecx, DWORD PTR __Count2n$232520[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count1$[ebp]
	sub	edx, DWORD PTR __Count1n$232519[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Lastn$232518[ebp]
	push	ecx
	mov	edx, DWORD PTR __Midn$232537[ebp]
	push	edx
	call	??$_Buffered_merge@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Buffered_merge<CvHomelandMove *,int,CvHomelandMove>
	add	esp, 24					; 00000018H
$LN10@Buffered_m@2:

; 2804 : 		}
; 2805 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ENDP ; std::_Buffered_merge<CvHomelandMove *,int,CvHomelandMove>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXPAVCvHomelandTarget@@0V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>
PUBLIC	??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@0V?$_Temp_iterator@VCvHomelandTarget@@@2@HH@Z ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,int>
; Function compile flags: /Odtp
;	COMDAT ??$_Buffered_merge_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z
_TEXT	SEGMENT
tv139 = -232						; size = 4
$T273039 = -61						; size = 1
$T272590 = -60						; size = 4
$T272586 = -56						; size = 4
$T272549 = -32						; size = 4
$T272529 = -28						; size = 4
$T272486 = -20						; size = 4
__Chunk$232601 = -16					; size = 4
__Midend$232599 = -12					; size = 4
__Nleft$232595 = -8					; size = 4
__Mid$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Buffered_merge_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z PROC ; std::_Buffered_merge_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>, COMDAT

; 3355 : 	{	// sort using temp buffer for merges, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H

; 3356 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3357 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Nleft$232595[ebp], ecx
	jmp	SHORT $LN6@Buffered_m@3
$LN5@Buffered_m@3:
	mov	edx, DWORD PTR __Nleft$232595[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR __Nleft$232595[ebp], edx
$LN6@Buffered_m@3:
	cmp	DWORD PTR __Nleft$232595[ebp], 32	; 00000020H
	jl	SHORT $LN26@Buffered_m@3

; 3358 : 		{	// sort chunks
; 3359 : 		_BidIt _Midend = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Midend$232599[ebp], eax

; 3360 : 		std::advance(_Midend, (int)_ISORT_MAX);

	mov	ecx, 32					; 00000020H
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR __Midend$232599[ebp]
	mov	DWORD PTR __Midend$232599[ebp], ecx

; 3361 : 
; 3362 : 		std::_Insertion_sort(_Mid, _Midend);

	mov	edx, DWORD PTR __Midend$232599[ebp]
	mov	DWORD PTR $T272529[ebp], edx
	push	0
	mov	eax, DWORD PTR $T272529[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAVCvHomelandTarget@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget>
	add	esp, 12					; 0000000cH

; 3363 : 		_Mid = _Midend;

	mov	edx, DWORD PTR __Midend$232599[ebp]
	mov	DWORD PTR __Mid$[ebp], edx

; 3364 : 		}

	jmp	SHORT $LN5@Buffered_m@3

; 3365 : 	std::_Insertion_sort(_Mid, _Last);	// sort partial last chunk

$LN26@Buffered_m@3:
	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAVCvHomelandTarget@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget>
	add	esp, 12					; 0000000cH

; 3366 : 
; 3367 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	DWORD PTR __Chunk$232601[ebp], 32	; 00000020H
	jmp	SHORT $LN3@Buffered_m@3
$LN2@Buffered_m@3:
	mov	edx, DWORD PTR __Chunk$232601[ebp]
	shl	edx, 1
	mov	DWORD PTR __Chunk$232601[ebp], edx
$LN3@Buffered_m@3:
	mov	eax, DWORD PTR __Chunk$232601[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jge	$LN7@Buffered_m@3

; 3368 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3369 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3370 : 			_Chunk, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Chunk$232601[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T272486[ebp], esp
	mov	DWORD PTR $T272549[ebp], edx
	mov	eax, DWORD PTR $T272549[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T272549[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T272549[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T272549[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T272549[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T272549[ebp]
	mov	DWORD PTR tv139[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@0V?$_Temp_iterator@VCvHomelandTarget@@@2@HH@Z ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,int>
	add	esp, 36					; 00000024H

; 3371 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3372 : 			_Chunk *= 2, _Count);

	mov	ecx, DWORD PTR __Chunk$232601[ebp]
	shl	ecx, 1
	mov	DWORD PTR __Chunk$232601[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T272586[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T272590[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T273039[ebp], dl
	movzx	eax, BYTE PTR $T273039[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Chunk$232601[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T272586[ebp]
	push	ecx
	mov	edx, DWORD PTR $T272590[ebp]
	push	edx
	call	??$_Chunked_merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXPAVCvHomelandTarget@@0V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>
	add	esp, 24					; 00000018H

; 3373 : 		}

	jmp	$LN2@Buffered_m@3
$LN7@Buffered_m@3:

; 3374 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ENDP ; std::_Buffered_merge_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
PUBLIC	??$_Upper_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget,int>
PUBLIC	??$_Lower_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget,int>
PUBLIC	??$_Merge_backward@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@V12@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0PAVCvHomelandTarget@@10U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
PUBLIC	??$_Merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V23@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@11Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
PUBLIC	??$swap@VCvHomelandTarget@@@std@@YAXAAVCvHomelandTarget@@0@Z ; std::swap<CvHomelandTarget>
; Function compile flags: /Odtp
;	COMDAT ??$_Buffered_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z
_TEXT	SEGMENT
tv237 = -328						; size = 4
tv236 = -324						; size = 4
tv233 = -320						; size = 4
tv232 = -316						; size = 4
$T273404 = -256						; size = 4
$T273391 = -252						; size = 4
$T273390 = -248						; size = 4
$T273368 = -240						; size = 4
$T273367 = -236						; size = 4
$T273364 = -232						; size = 4
$T273356 = -228						; size = 4
$T273314 = -220						; size = 4
$T273301 = -216						; size = 4
$T273300 = -212						; size = 4
$T273278 = -204						; size = 4
$T273275 = -200						; size = 4
$T273267 = -196						; size = 4
$T273209 = -188						; size = 4
$T273208 = -184						; size = 4
$T273207 = -177						; size = 1
$T273202 = -176						; size = 4
$T273198 = -172						; size = 4
$T273183 = -168						; size = 4
__Next$273186 = -164					; size = 4
$T273175 = -160						; size = 4
$T273162 = -148						; size = 4
$T273161 = -144						; size = 4
$T273160 = -140						; size = 4
$T273156 = -134						; size = 1
$T273155 = -133						; size = 1
$T273145 = -132						; size = 4
$T273141 = -128						; size = 4
$T273126 = -124						; size = 4
__Next$273129 = -120					; size = 4
$T273118 = -116						; size = 4
$T273105 = -104						; size = 4
$T273104 = -100						; size = 4
$T273085 = -96						; size = 4
$T273072 = -92						; size = 4
$T273063 = -88						; size = 4
$T273050 = -84						; size = 4
$T273049 = -80						; size = 4
$T273048 = -76						; size = 4
$T273047 = -72						; size = 20
$T273046 = -52						; size = 4
$T273045 = -48						; size = 4
$T273044 = -44						; size = 20
$T273043 = -24						; size = 4
__Firstn$232673 = -20					; size = 4
__Count2n$232676 = -16					; size = 4
__Midn$232695 = -12					; size = 4
__Lastn$232674 = -8					; size = 4
__Count1n$232675 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z PROC ; std::_Buffered_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>, COMDAT

; 2759 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 328				; 00000148H

; 2760 : 	if (_Count1 + _Count2 == 2)

	mov	eax, DWORD PTR __Count1$[ebp]
	add	eax, DWORD PTR __Count2$[ebp]
	cmp	eax, 2
	jne	SHORT $LN9@Buffered_m@4

; 2761 : 		{	// order two one-element partitions
; 2762 : 		if (_DEBUG_LT(*_Mid, *_First))

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T273063[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T273072[ebp], edx
	mov	eax, DWORD PTR $T273072[ebp]
	mov	ecx, DWORD PTR $T273063[ebp]
	mov	edx, DWORD PTR [eax+16]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+16]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@Buffered_m@4

; 2763 : 			std::iter_swap(_First, _Mid);

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T273105[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T273104[ebp], eax
	mov	ecx, DWORD PTR $T273105[ebp]
	mov	DWORD PTR $T273085[ebp], ecx
	mov	edx, DWORD PTR $T273085[ebp]
	push	edx
	mov	eax, DWORD PTR $T273104[ebp]
	push	eax
	call	??$swap@VCvHomelandTarget@@@std@@YAXAAVCvHomelandTarget@@0@Z ; std::swap<CvHomelandTarget>
	add	esp, 8
$LN8@Buffered_m@4:

; 2764 : 		}

	jmp	$LN10@Buffered_m@4
$LN9@Buffered_m@4:

; 2765 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Count1$[ebp]
	cmp	ecx, DWORD PTR __Count2$[ebp]
	jg	$LN6@Buffered_m@4
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandTarget>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN6@Buffered_m@4

; 2766 : 		{	// buffer left partition, then merge
; 2767 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T273043[ebp], esp
	mov	DWORD PTR $T273118[ebp], ecx
	mov	edx, DWORD PTR $T273118[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T273118[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T273118[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T273118[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T273118[ebp]
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR $T273118[ebp]
	mov	DWORD PTR tv232[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T273044[ebp]
	push	eax
	call	??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv233[ebp], eax
	cmp	DWORD PTR $T273044[ebp], 0
	je	SHORT $LN49@Buffered_m@4
	mov	ecx, DWORD PTR $T273044[ebp]
	mov	DWORD PTR __Next$273129[ebp], ecx
	jmp	SHORT $LN47@Buffered_m@4
$LN46@Buffered_m@4:
	mov	edx, DWORD PTR __Next$273129[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __Next$273129[ebp], edx
$LN47@Buffered_m@4:
	mov	eax, DWORD PTR __Next$273129[ebp]
	cmp	eax, DWORD PTR $T273044[ebp+8]
	je	SHORT $LN45@Buffered_m@4
	jmp	SHORT $LN46@Buffered_m@4
$LN45@Buffered_m@4:
	mov	ecx, DWORD PTR $T273044[ebp]
	mov	DWORD PTR $T273126[ebp], ecx
	mov	edx, DWORD PTR $T273126[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN49@Buffered_m@4:

; 2768 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T273141[ebp], edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T273145[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T273162[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T273161[ebp], ecx
	mov	edx, DWORD PTR $T273145[ebp]
	mov	DWORD PTR $T273160[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T273155[ebp], al
	movzx	ecx, BYTE PTR $T273155[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T273156[ebp]
	push	edx
	mov	eax, DWORD PTR $T273162[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T273161[ebp]
	push	edx
	mov	eax, DWORD PTR $T273141[ebp]
	push	eax
	mov	ecx, DWORD PTR $T273160[ebp]
	push	ecx
	lea	edx, DWORD PTR $T273045[ebp]
	push	edx
	call	??$_Merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V23@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@11Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
	add	esp, 32					; 00000020H

; 2769 : 		}
; 2770 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	jmp	$LN10@Buffered_m@4
$LN6@Buffered_m@4:
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandTarget>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN4@Buffered_m@4

; 2771 : 		{	// buffer right partition, then merge
; 2772 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T273046[ebp], esp
	mov	DWORD PTR $T273175[ebp], edx
	mov	eax, DWORD PTR $T273175[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T273175[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T273175[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T273175[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T273175[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T273175[ebp]
	mov	DWORD PTR tv236[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T273047[ebp]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv237[ebp], eax
	cmp	DWORD PTR $T273047[ebp], 0
	je	SHORT $LN76@Buffered_m@4
	mov	edx, DWORD PTR $T273047[ebp]
	mov	DWORD PTR __Next$273186[ebp], edx
	jmp	SHORT $LN74@Buffered_m@4
$LN73@Buffered_m@4:
	mov	eax, DWORD PTR __Next$273186[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __Next$273186[ebp], eax
$LN74@Buffered_m@4:
	mov	ecx, DWORD PTR __Next$273186[ebp]
	cmp	ecx, DWORD PTR $T273047[ebp+8]
	je	SHORT $LN72@Buffered_m@4
	jmp	SHORT $LN73@Buffered_m@4
$LN72@Buffered_m@4:
	mov	edx, DWORD PTR $T273047[ebp]
	mov	DWORD PTR $T273183[ebp], edx
	mov	eax, DWORD PTR $T273183[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN76@Buffered_m@4:

; 2773 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid,
; 2774 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T273198[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T273202[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T273209[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T273208[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T273207[ebp], al
	movzx	ecx, BYTE PTR $T273207[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T273198[ebp]
	push	eax
	mov	ecx, DWORD PTR $T273202[ebp]
	push	ecx
	mov	edx, DWORD PTR $T273209[ebp]
	push	edx
	mov	eax, DWORD PTR $T273208[ebp]
	push	eax
	lea	ecx, DWORD PTR $T273048[ebp]
	push	ecx
	call	??$_Merge_backward@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@V12@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0PAVCvHomelandTarget@@10U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
	add	esp, 28					; 0000001cH

; 2775 : 		}
; 2776 : 	else

	jmp	$LN10@Buffered_m@4
$LN4@Buffered_m@4:

; 2777 : 		{	// buffer too small, divide and conquer
; 2778 : 		_BidIt _Firstn, _Lastn;

	mov	DWORD PTR __Firstn$232673[ebp], 0
	mov	DWORD PTR __Lastn$232674[ebp], 0

; 2779 : 		_Diff _Count1n, _Count2n;
; 2780 : 
; 2781 : 		if (_Count2 < _Count1)

	mov	edx, DWORD PTR __Count2$[ebp]
	cmp	edx, DWORD PTR __Count1$[ebp]
	jge	$LN2@Buffered_m@4

; 2782 : 			{	// left larger, cut it in half and partition right to match
; 2783 : 			_Count1n = _Count1 / 2, _Count2n = 0;

	mov	eax, DWORD PTR __Count1$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count1n$232675[ebp], eax
	mov	DWORD PTR __Count2n$232676[ebp], 0

; 2784 : 			_Firstn = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Firstn$232673[ebp], eax

; 2785 : 			std::advance(_Firstn, _Count1n);

	mov	ecx, DWORD PTR __Count1n$232675[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR __Firstn$232673[ebp]
	mov	DWORD PTR __Firstn$232673[ebp], ecx

; 2786 : 			_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);

	mov	edx, DWORD PTR __Firstn$232673[ebp]
	mov	DWORD PTR $T273267[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T273278[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T273267[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T273278[ebp]
	push	eax
	lea	ecx, DWORD PTR $T273275[ebp]
	push	ecx
	call	??$_Lower_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget,int>
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T273278[ebp], edx
	mov	eax, DWORD PTR $T273278[ebp]
	mov	DWORD PTR $T273049[ebp], eax
	mov	ecx, DWORD PTR $T273049[ebp]
	mov	DWORD PTR __Lastn$232674[ebp], ecx

; 2787 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T273314[ebp], edx
	mov	eax, DWORD PTR __Lastn$232674[ebp]
	mov	DWORD PTR $T273301[ebp], eax
	mov	ecx, DWORD PTR $T273314[ebp]
	mov	DWORD PTR $T273300[ebp], ecx
	mov	eax, DWORD PTR $T273301[ebp]
	sub	eax, DWORD PTR $T273300[ebp]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	add	eax, DWORD PTR __Count2n$232676[ebp]
	mov	DWORD PTR __Count2n$232676[ebp], eax

; 2788 : 			}
; 2789 : 		else

	jmp	$LN1@Buffered_m@4
$LN2@Buffered_m@4:

; 2790 : 			{	// right larger, cut it in half and partition left to match
; 2791 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	DWORD PTR __Count1n$232675[ebp], 0
	mov	eax, DWORD PTR __Count2$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2n$232676[ebp], eax

; 2792 : 			_Lastn = _Mid;

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Lastn$232674[ebp], edx

; 2793 : 			std::advance(_Lastn, _Count2n);

	mov	eax, DWORD PTR __Count2n$232676[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Lastn$232674[ebp]
	mov	DWORD PTR __Lastn$232674[ebp], eax

; 2794 : 			_Firstn = std::upper_bound(_First, _Mid, *_Lastn);

	mov	ecx, DWORD PTR __Lastn$232674[ebp]
	mov	DWORD PTR $T273356[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T273368[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T273367[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T273356[ebp]
	push	ecx
	mov	edx, DWORD PTR $T273368[ebp]
	push	edx
	mov	eax, DWORD PTR $T273367[ebp]
	push	eax
	lea	ecx, DWORD PTR $T273364[ebp]
	push	ecx
	call	??$_Upper_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget,int>
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T273367[ebp], edx
	mov	eax, DWORD PTR $T273367[ebp]
	mov	DWORD PTR $T273050[ebp], eax
	mov	ecx, DWORD PTR $T273050[ebp]
	mov	DWORD PTR __Firstn$232673[ebp], ecx

; 2795 : 			_Distance(_First, _Firstn, _Count1n);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T273404[ebp], edx
	mov	eax, DWORD PTR __Firstn$232673[ebp]
	mov	DWORD PTR $T273391[ebp], eax
	mov	ecx, DWORD PTR $T273404[ebp]
	mov	DWORD PTR $T273390[ebp], ecx
	mov	eax, DWORD PTR $T273391[ebp]
	sub	eax, DWORD PTR $T273390[ebp]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	add	eax, DWORD PTR __Count1n$232675[ebp]
	mov	DWORD PTR __Count1n$232675[ebp], eax
$LN1@Buffered_m@4:

; 2796 : 			}
; 2797 : 
; 2798 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2799 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2n$232676[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1$[ebp]
	sub	ecx, DWORD PTR __Count1n$232675[ebp]
	push	ecx
	mov	edx, DWORD PTR __Lastn$232674[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Firstn$232673[ebp]
	push	ecx
	lea	edx, DWORD PTR __Midn$232695[ebp]
	push	edx
	call	??$_Buffered_rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
	add	esp, 28					; 0000001cH

; 2800 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2801 : 			_Count1n, _Count2n, _Tempbuf);	// merge each new part

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2n$232676[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count1n$232675[ebp]
	push	edx
	mov	eax, DWORD PTR __Midn$232695[ebp]
	push	eax
	mov	ecx, DWORD PTR __Firstn$232673[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Buffered_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Buffered_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
	add	esp, 24					; 00000018H

; 2802 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2803 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$[ebp]
	sub	ecx, DWORD PTR __Count2n$232676[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count1$[ebp]
	sub	edx, DWORD PTR __Count1n$232675[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Lastn$232674[ebp]
	push	ecx
	mov	edx, DWORD PTR __Midn$232695[ebp]
	push	edx
	call	??$_Buffered_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Buffered_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
	add	esp, 24					; 00000018H
$LN10@Buffered_m@4:

; 2804 : 		}
; 2805 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ENDP ; std::_Buffered_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHP6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
PUBLIC	??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
; Function compile flags: /Odtp
;	COMDAT ??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z
_TEXT	SEGMENT
tv144 = -224						; size = 4
$T273707 = -89						; size = 1
$T273507 = -88						; size = 4
$T273503 = -84						; size = 4
$T273466 = -60						; size = 4
$T273445 = -28						; size = 4
$T273418 = -20						; size = 4
__Chunk$232762 = -16					; size = 4
__Midn$232760 = -12					; size = 4
__Nleft$232756 = -8					; size = 4
__Mid$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z PROC ; std::_Buffered_merge_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 3502 : 	{	// sort using temp buffer for merges, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H

; 3503 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3504 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Nleft$232756[ebp], ecx
	jmp	SHORT $LN6@Buffered_m@5
$LN5@Buffered_m@5:
	mov	edx, DWORD PTR __Nleft$232756[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR __Nleft$232756[ebp], edx
$LN6@Buffered_m@5:
	cmp	DWORD PTR __Nleft$232756[ebp], 32	; 00000020H
	jl	SHORT $LN22@Buffered_m@5

; 3505 : 		{	// sort chunks
; 3506 : 		_BidIt _Midn = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Midn$232760[ebp], eax

; 3507 : 		std::advance(_Midn, (int)_ISORT_MAX);

	mov	ecx, 32					; 00000020H
	shl	ecx, 4
	add	ecx, DWORD PTR __Midn$232760[ebp]
	mov	DWORD PTR __Midn$232760[ebp], ecx

; 3508 : 
; 3509 : 		std::_Insertion_sort(_Mid, _Midn, _Pred);

	mov	edx, DWORD PTR __Midn$232760[ebp]
	mov	DWORD PTR $T273445[ebp], edx
	push	0
	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T273445[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	call	??$_Insertion_sort1@PAVCvHomelandUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z0@Z ; std::_Insertion_sort1<CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),CvHomelandUnit>
	add	esp, 16					; 00000010H

; 3510 : 		_Mid = _Midn;

	mov	eax, DWORD PTR __Midn$232760[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3511 : 		}

	jmp	SHORT $LN5@Buffered_m@5

; 3512 : 	std::_Insertion_sort(_Mid, _Last, _Pred);	// sort partial last chunk

$LN22@Buffered_m@5:
	push	0
	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	call	??$_Insertion_sort1@PAVCvHomelandUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z0@Z ; std::_Insertion_sort1<CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),CvHomelandUnit>
	add	esp, 16					; 00000010H

; 3513 : 
; 3514 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	DWORD PTR __Chunk$232762[ebp], 32	; 00000020H
	jmp	SHORT $LN3@Buffered_m@5
$LN2@Buffered_m@5:
	mov	ecx, DWORD PTR __Chunk$232762[ebp]
	shl	ecx, 1
	mov	DWORD PTR __Chunk$232762[ebp], ecx
$LN3@Buffered_m@5:
	mov	edx, DWORD PTR __Chunk$232762[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jge	$LN7@Buffered_m@5

; 3515 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3516 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3517 : 			_Chunk, _Count, _Pred);

	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Chunk$232762[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T273418[ebp], esp
	mov	DWORD PTR $T273466[ebp], edx
	mov	eax, DWORD PTR $T273466[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T273466[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T273466[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T273466[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T273466[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T273466[ebp]
	mov	DWORD PTR tv144[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 40					; 00000028H

; 3518 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3519 : 			_Chunk *= 2, _Count, _Pred);

	mov	ecx, DWORD PTR __Chunk$232762[ebp]
	shl	ecx, 1
	mov	DWORD PTR __Chunk$232762[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T273503[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T273507[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T273707[ebp], dl
	movzx	eax, BYTE PTR $T273707[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Chunk$232762[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T273503[ebp]
	push	edx
	mov	eax, DWORD PTR $T273507[ebp]
	push	eax
	call	??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHP6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 28					; 0000001cH

; 3520 : 		}

	jmp	$LN2@Buffered_m@5
$LN7@Buffered_m@5:

; 3521 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ENDP ; std::_Buffered_merge_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@PAVCvHomelandUnit@@HV1@@std@@YAPAVCvHomelandUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Buffered_rotate<CvHomelandUnit *,int,CvHomelandUnit>
PUBLIC	??$_Upper_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ; std::_Upper_bound<CvHomelandUnit *,CvHomelandUnit,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
PUBLIC	??$_Lower_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ; std::_Lower_bound<CvHomelandUnit *,CvHomelandUnit,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
PUBLIC	??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
PUBLIC	??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
; Function compile flags: /Odtp
;	COMDAT ??$_Buffered_merge@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z
_TEXT	SEGMENT
tv227 = -236						; size = 4
tv226 = -232						; size = 4
tv223 = -228						; size = 4
tv222 = -224						; size = 4
$T273958 = -220						; size = 4
$T273940 = -212						; size = 4
$T273939 = -208						; size = 4
$T273877 = -176						; size = 4
$T273859 = -168						; size = 4
$T273858 = -164						; size = 4
$T273831 = -157						; size = 1
$T273827 = -156						; size = 4
$T273823 = -152						; size = 4
$T273808 = -148						; size = 4
__Next$273811 = -144					; size = 4
$T273800 = -140						; size = 4
$T273787 = -128						; size = 4
$T273786 = -124						; size = 4
$T273785 = -120						; size = 4
$T273780 = -114						; size = 1
$T273779 = -113						; size = 1
$T273770 = -112						; size = 4
$T273766 = -108						; size = 4
$T273751 = -104						; size = 4
__Next$273754 = -100					; size = 4
$T273743 = -96						; size = 4
__Tmp$273729 = -84					; size = 16
$T273714 = -68						; size = 20
$T273713 = -48						; size = 4
$T273712 = -44						; size = 20
$T273711 = -24						; size = 4
__Firstn$232840 = -20					; size = 4
__Count2n$232843 = -16					; size = 4
__Midn$232864 = -12					; size = 4
__Lastn$232841 = -8					; size = 4
__Count1n$232842 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
__Pred$ = 32						; size = 4
??$_Buffered_merge@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z PROC ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 2889 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH

; 2890 : 	if (_Count1 + _Count2 == 2)

	mov	eax, DWORD PTR __Count1$[ebp]
	add	eax, DWORD PTR __Count2$[ebp]
	cmp	eax, 2
	jne	$LN9@Buffered_m@6

; 2891 : 		{	// order two one-element partitions
; 2892 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	ecx, DWORD PTR __First$[ebp]
	sub	esp, 16					; 00000010H
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 32					; 00000020H
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@Buffered_m@6

; 2893 : 			std::iter_swap(_First, _Mid);

	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Mid$[ebp]
	je	SHORT $LN8@Buffered_m@6
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$273729[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$273729[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$273729[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$273729[ebp+12], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR __Tmp$273729[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$273729[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Tmp$273729[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Tmp$273729[ebp+12]
	mov	DWORD PTR [eax+12], edx
$LN8@Buffered_m@6:

; 2894 : 		}

	jmp	$LN10@Buffered_m@6
$LN9@Buffered_m@6:

; 2895 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	eax, DWORD PTR __Count1$[ebp]
	cmp	eax, DWORD PTR __Count2$[ebp]
	jg	$LN6@Buffered_m@6
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN6@Buffered_m@6

; 2896 : 		{	// buffer left partition, then merge
; 2897 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T273711[ebp], esp
	mov	DWORD PTR $T273743[ebp], eax
	mov	ecx, DWORD PTR $T273743[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T273743[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T273743[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T273743[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T273743[ebp]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T273743[ebp]
	mov	DWORD PTR tv222[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T273712[ebp]
	push	edx
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv223[ebp], eax
	cmp	DWORD PTR $T273712[ebp], 0
	je	SHORT $LN34@Buffered_m@6
	mov	eax, DWORD PTR $T273712[ebp]
	mov	DWORD PTR __Next$273754[ebp], eax
	jmp	SHORT $LN32@Buffered_m@6
$LN31@Buffered_m@6:
	mov	ecx, DWORD PTR __Next$273754[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Next$273754[ebp], ecx
$LN32@Buffered_m@6:
	mov	edx, DWORD PTR __Next$273754[ebp]
	cmp	edx, DWORD PTR $T273712[ebp+8]
	je	SHORT $LN30@Buffered_m@6
	jmp	SHORT $LN31@Buffered_m@6
$LN30@Buffered_m@6:
	mov	eax, DWORD PTR $T273712[ebp]
	mov	DWORD PTR $T273751[ebp], eax
	mov	ecx, DWORD PTR $T273751[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@Buffered_m@6:

; 2898 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(),
; 2899 : 			_Mid, _Last, _First, _Pred);

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T273766[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T273770[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T273787[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T273786[ebp], eax
	mov	ecx, DWORD PTR $T273770[ebp]
	mov	DWORD PTR $T273785[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T273779[ebp], dl
	movzx	eax, BYTE PTR $T273779[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T273780[ebp]
	push	ecx
	mov	edx, DWORD PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR $T273787[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T273786[ebp]
	push	edx
	mov	eax, DWORD PTR $T273766[ebp]
	push	eax
	mov	ecx, DWORD PTR $T273785[ebp]
	push	ecx
	call	??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),std::random_access_iterator_tag>
	add	esp, 32					; 00000020H

; 2900 : 		}
; 2901 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	jmp	$LN10@Buffered_m@6
$LN6@Buffered_m@6:
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN4@Buffered_m@6

; 2902 : 		{	// buffer right partition, then merge
; 2903 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T273713[ebp], esp
	mov	DWORD PTR $T273800[ebp], ecx
	mov	edx, DWORD PTR $T273800[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T273800[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T273800[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T273800[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T273800[ebp]
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR $T273800[ebp]
	mov	DWORD PTR tv226[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	lea	eax, DWORD PTR $T273714[ebp]
	push	eax
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv227[ebp], eax
	cmp	DWORD PTR $T273714[ebp], 0
	je	SHORT $LN61@Buffered_m@6
	mov	ecx, DWORD PTR $T273714[ebp]
	mov	DWORD PTR __Next$273811[ebp], ecx
	jmp	SHORT $LN59@Buffered_m@6
$LN58@Buffered_m@6:
	mov	edx, DWORD PTR __Next$273811[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Next$273811[ebp], edx
$LN59@Buffered_m@6:
	mov	eax, DWORD PTR __Next$273811[ebp]
	cmp	eax, DWORD PTR $T273714[ebp+8]
	je	SHORT $LN57@Buffered_m@6
	jmp	SHORT $LN58@Buffered_m@6
$LN57@Buffered_m@6:
	mov	ecx, DWORD PTR $T273714[ebp]
	mov	DWORD PTR $T273808[ebp], ecx
	mov	edx, DWORD PTR $T273808[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN61@Buffered_m@6:

; 2904 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid, _Tempbuf._First(), _Tempbuf._Last(),
; 2905 : 			_Last, _Pred);

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T273823[ebp], edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T273827[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T273831[ebp], al
	movzx	ecx, BYTE PTR $T273831[ebp]
	push	ecx
	mov	edx, DWORD PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T273823[ebp]
	push	ecx
	mov	edx, DWORD PTR $T273827[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 28					; 0000001cH

; 2906 : 		}
; 2907 : 	else

	jmp	$LN10@Buffered_m@6
$LN4@Buffered_m@6:

; 2908 : 		{	// buffer too small, divide and conquer
; 2909 : 		_BidIt _Firstn, _Lastn;
; 2910 : 		_Diff _Count1n, _Count2n;
; 2911 : 		if (_Count2 < _Count1)

	mov	edx, DWORD PTR __Count2$[ebp]
	cmp	edx, DWORD PTR __Count1$[ebp]
	jge	$LN2@Buffered_m@6

; 2912 : 			{	// left larger, cut it in half and partition right to match
; 2913 : 			_Count1n = _Count1 / 2, _Count2n = 0;

	mov	eax, DWORD PTR __Count1$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count1n$232842[ebp], eax
	mov	DWORD PTR __Count2n$232843[ebp], 0

; 2914 : 			_Firstn = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Firstn$232840[ebp], eax

; 2915 : 			std::advance(_Firstn, _Count1n);

	mov	ecx, DWORD PTR __Count1n$232842[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Firstn$232840[ebp]
	mov	DWORD PTR __Firstn$232840[ebp], ecx

; 2916 : 			_Lastn = lower_bound(_Mid, _Last, *_Firstn, _Pred);

	mov	edx, DWORD PTR __Firstn$232840[ebp]
	mov	DWORD PTR $T273859[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T273858[ebp], eax
	push	0
	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T273859[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T273858[ebp]
	push	ecx
	call	??$_Lower_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ; std::_Lower_bound<CvHomelandUnit *,CvHomelandUnit,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 20					; 00000014H
	mov	DWORD PTR $T273858[ebp], eax
	mov	edx, DWORD PTR $T273858[ebp]
	mov	DWORD PTR __Lastn$232841[ebp], edx

; 2917 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T273877[ebp], eax
	mov	ecx, DWORD PTR __Lastn$232841[ebp]
	sub	ecx, DWORD PTR $T273877[ebp]
	sar	ecx, 4
	add	ecx, DWORD PTR __Count2n$232843[ebp]
	mov	DWORD PTR __Count2n$232843[ebp], ecx

; 2918 : 			}
; 2919 : 		else

	jmp	$LN1@Buffered_m@6
$LN2@Buffered_m@6:

; 2920 : 			{	// right larger, cut it in half and partition left to match
; 2921 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	DWORD PTR __Count1n$232842[ebp], 0
	mov	eax, DWORD PTR __Count2$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2n$232843[ebp], eax

; 2922 : 			_Lastn = _Mid;

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Lastn$232841[ebp], edx

; 2923 : 			std::advance(_Lastn, _Count2n);

	mov	eax, DWORD PTR __Count2n$232843[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Lastn$232841[ebp]
	mov	DWORD PTR __Lastn$232841[ebp], eax

; 2924 : 			_Firstn = upper_bound(_First, _Mid, *_Lastn, _Pred);

	mov	ecx, DWORD PTR __Lastn$232841[ebp]
	mov	DWORD PTR $T273940[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T273939[ebp], edx
	push	0
	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T273940[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR $T273939[ebp]
	push	eax
	call	??$_Upper_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ; std::_Upper_bound<CvHomelandUnit *,CvHomelandUnit,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 20					; 00000014H
	mov	DWORD PTR $T273939[ebp], eax
	mov	ecx, DWORD PTR $T273939[ebp]
	mov	DWORD PTR __Firstn$232840[ebp], ecx

; 2925 : 			_Distance(_First, _Firstn, _Count1n);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T273958[ebp], edx
	mov	eax, DWORD PTR __Firstn$232840[ebp]
	sub	eax, DWORD PTR $T273958[ebp]
	sar	eax, 4
	add	eax, DWORD PTR __Count1n$232842[ebp]
	mov	DWORD PTR __Count1n$232842[ebp], eax
$LN1@Buffered_m@6:

; 2926 : 			}
; 2927 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2928 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count2n$232843[ebp]
	push	edx
	mov	eax, DWORD PTR __Count1$[ebp]
	sub	eax, DWORD PTR __Count1n$232842[ebp]
	push	eax
	mov	ecx, DWORD PTR __Lastn$232841[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __Firstn$232840[ebp]
	push	eax
	call	??$_Buffered_rotate@PAVCvHomelandUnit@@HV1@@std@@YAPAVCvHomelandUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Buffered_rotate<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Midn$232864[ebp], eax

; 2929 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2930 : 			_Count1n, _Count2n, _Tempbuf, _Pred);	// merge each new part

	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2n$232843[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1n$232842[ebp]
	push	ecx
	mov	edx, DWORD PTR __Midn$232864[ebp]
	push	edx
	mov	eax, DWORD PTR __Firstn$232840[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Buffered_merge@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 28					; 0000001cH

; 2931 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2932 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);

	mov	edx, DWORD PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$[ebp]
	sub	ecx, DWORD PTR __Count2n$232843[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count1$[ebp]
	sub	edx, DWORD PTR __Count1n$232842[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Lastn$232841[ebp]
	push	ecx
	mov	edx, DWORD PTR __Midn$232864[ebp]
	push	edx
	call	??$_Buffered_merge@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 28					; 0000001cH
$LN10@Buffered_m@6:

; 2933 : 		}
; 2934 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ENDP ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@H@std@@YAXPAVCvHomelandUnit@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int>
PUBLIC	??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int>
; Function compile flags: /Odtp
;	COMDAT ??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z
_TEXT	SEGMENT
tv139 = -276						; size = 4
$T274285 = -149						; size = 1
$T274111 = -148						; size = 4
$T274107 = -144						; size = 4
$T274070 = -120						; size = 4
$T274019 = -72						; size = 4
$T273961 = -20						; size = 4
__Chunk$232893 = -16					; size = 4
__Midend$232891 = -12					; size = 4
__Nleft$232887 = -8					; size = 4
__Mid$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z PROC ; std::_Buffered_merge_sort<CvHomelandUnit *,int,CvHomelandUnit>, COMDAT

; 3355 : 	{	// sort using temp buffer for merges, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H

; 3356 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3357 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Nleft$232887[ebp], ecx
	jmp	SHORT $LN6@Buffered_m@7
$LN5@Buffered_m@7:
	mov	edx, DWORD PTR __Nleft$232887[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR __Nleft$232887[ebp], edx
$LN6@Buffered_m@7:
	cmp	DWORD PTR __Nleft$232887[ebp], 32	; 00000020H
	jl	SHORT $LN44@Buffered_m@7

; 3358 : 		{	// sort chunks
; 3359 : 		_BidIt _Midend = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Midend$232891[ebp], eax

; 3360 : 		std::advance(_Midend, (int)_ISORT_MAX);

	mov	ecx, 32					; 00000020H
	shl	ecx, 4
	add	ecx, DWORD PTR __Midend$232891[ebp]
	mov	DWORD PTR __Midend$232891[ebp], ecx

; 3361 : 
; 3362 : 		std::_Insertion_sort(_Mid, _Midend);

	mov	edx, DWORD PTR __Midend$232891[ebp]
	mov	DWORD PTR $T274019[ebp], edx
	push	0
	mov	eax, DWORD PTR $T274019[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	call	??$_Insertion_sort1@PAVCvHomelandUnit@@V1@@std@@YAXPAVCvHomelandUnit@@00@Z ; std::_Insertion_sort1<CvHomelandUnit *,CvHomelandUnit>
	add	esp, 12					; 0000000cH

; 3363 : 		_Mid = _Midend;

	mov	edx, DWORD PTR __Midend$232891[ebp]
	mov	DWORD PTR __Mid$[ebp], edx

; 3364 : 		}

	jmp	SHORT $LN5@Buffered_m@7

; 3365 : 	std::_Insertion_sort(_Mid, _Last);	// sort partial last chunk

$LN44@Buffered_m@7:
	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	call	??$_Insertion_sort1@PAVCvHomelandUnit@@V1@@std@@YAXPAVCvHomelandUnit@@00@Z ; std::_Insertion_sort1<CvHomelandUnit *,CvHomelandUnit>
	add	esp, 12					; 0000000cH

; 3366 : 
; 3367 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	DWORD PTR __Chunk$232893[ebp], 32	; 00000020H
	jmp	SHORT $LN3@Buffered_m@7
$LN2@Buffered_m@7:
	mov	edx, DWORD PTR __Chunk$232893[ebp]
	shl	edx, 1
	mov	DWORD PTR __Chunk$232893[ebp], edx
$LN3@Buffered_m@7:
	mov	eax, DWORD PTR __Chunk$232893[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jge	$LN7@Buffered_m@7

; 3368 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3369 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3370 : 			_Chunk, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Chunk$232893[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T273961[ebp], esp
	mov	DWORD PTR $T274070[ebp], edx
	mov	eax, DWORD PTR $T274070[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T274070[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T274070[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T274070[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T274070[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T274070[ebp]
	mov	DWORD PTR tv139[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int>
	add	esp, 36					; 00000024H

; 3371 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3372 : 			_Chunk *= 2, _Count);

	mov	ecx, DWORD PTR __Chunk$232893[ebp]
	shl	ecx, 1
	mov	DWORD PTR __Chunk$232893[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T274107[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T274111[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T274285[ebp], dl
	movzx	eax, BYTE PTR $T274285[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Chunk$232893[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T274107[ebp]
	push	ecx
	mov	edx, DWORD PTR $T274111[ebp]
	push	edx
	call	??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@H@std@@YAXPAVCvHomelandUnit@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int>
	add	esp, 24					; 00000018H

; 3373 : 		}

	jmp	$LN2@Buffered_m@7
$LN7@Buffered_m@7:

; 3374 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ENDP ; std::_Buffered_merge_sort<CvHomelandUnit *,int,CvHomelandUnit>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvHomelandUnit *,CvHomelandUnit,int>
PUBLIC	??$_Lower_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvHomelandUnit *,CvHomelandUnit,int>
PUBLIC	??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@@std@@YAPAVCvHomelandUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *>
PUBLIC	??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Buffered_merge@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z
_TEXT	SEGMENT
tv221 = -320						; size = 4
tv220 = -316						; size = 4
tv217 = -312						; size = 4
tv216 = -308						; size = 4
$T274566 = -236						; size = 4
$T274548 = -228						; size = 4
$T274547 = -224						; size = 4
$T274470 = -184						; size = 4
$T274452 = -176						; size = 4
$T274451 = -172						; size = 4
$T274425 = -165						; size = 1
$T274420 = -164						; size = 4
$T274416 = -160						; size = 4
$T274401 = -156						; size = 4
__Next$274404 = -152					; size = 4
$T274393 = -148						; size = 4
$T274380 = -136						; size = 4
$T274379 = -132						; size = 4
$T274378 = -128						; size = 4
$T274374 = -122						; size = 1
$T274373 = -121						; size = 1
$T274363 = -120						; size = 4
$T274359 = -116						; size = 4
$T274344 = -112						; size = 4
__Next$274347 = -108					; size = 4
$T274336 = -104						; size = 4
__Tmp$274323 = -92					; size = 16
$T274305 = -76						; size = 4
$T274301 = -72						; size = 4
$T274292 = -68						; size = 20
$T274291 = -48						; size = 4
$T274290 = -44						; size = 20
$T274289 = -24						; size = 4
__Firstn$232950 = -20					; size = 4
__Count2n$232953 = -16					; size = 4
__Midn$232970 = -12					; size = 4
__Lastn$232951 = -8					; size = 4
__Count1n$232952 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_merge@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z PROC ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit>, COMDAT

; 2759 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 320				; 00000140H

; 2760 : 	if (_Count1 + _Count2 == 2)

	mov	eax, DWORD PTR __Count1$[ebp]
	add	eax, DWORD PTR __Count2$[ebp]
	cmp	eax, 2
	jne	$LN9@Buffered_m@8

; 2761 : 		{	// order two one-element partitions
; 2762 : 		if (_DEBUG_LT(*_Mid, *_First))

	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T274301[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T274305[ebp], ecx
	mov	edx, DWORD PTR $T274301[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T274305[ebp]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@Buffered_m@8

; 2763 : 			std::iter_swap(_First, _Mid);

	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Mid$[ebp]
	je	SHORT $LN8@Buffered_m@8
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$274323[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$274323[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$274323[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$274323[ebp+12], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __Tmp$274323[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$274323[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Tmp$274323[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Tmp$274323[ebp+12]
	mov	DWORD PTR [ecx+12], eax
$LN8@Buffered_m@8:

; 2764 : 		}

	jmp	$LN10@Buffered_m@8
$LN9@Buffered_m@8:

; 2765 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Count1$[ebp]
	cmp	ecx, DWORD PTR __Count2$[ebp]
	jg	$LN6@Buffered_m@8
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN6@Buffered_m@8

; 2766 : 		{	// buffer left partition, then merge
; 2767 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T274289[ebp], esp
	mov	DWORD PTR $T274336[ebp], ecx
	mov	edx, DWORD PTR $T274336[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T274336[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T274336[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T274336[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T274336[ebp]
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR $T274336[ebp]
	mov	DWORD PTR tv216[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T274290[ebp]
	push	eax
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv217[ebp], eax
	cmp	DWORD PTR $T274290[ebp], 0
	je	SHORT $LN40@Buffered_m@8
	mov	ecx, DWORD PTR $T274290[ebp]
	mov	DWORD PTR __Next$274347[ebp], ecx
	jmp	SHORT $LN38@Buffered_m@8
$LN37@Buffered_m@8:
	mov	edx, DWORD PTR __Next$274347[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Next$274347[ebp], edx
$LN38@Buffered_m@8:
	mov	eax, DWORD PTR __Next$274347[ebp]
	cmp	eax, DWORD PTR $T274290[ebp+8]
	je	SHORT $LN36@Buffered_m@8
	jmp	SHORT $LN37@Buffered_m@8
$LN36@Buffered_m@8:
	mov	ecx, DWORD PTR $T274290[ebp]
	mov	DWORD PTR $T274344[ebp], ecx
	mov	edx, DWORD PTR $T274344[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN40@Buffered_m@8:

; 2768 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T274359[ebp], edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T274363[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T274380[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T274379[ebp], ecx
	mov	edx, DWORD PTR $T274363[ebp]
	mov	DWORD PTR $T274378[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T274373[ebp], al
	movzx	ecx, BYTE PTR $T274373[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T274374[ebp]
	push	edx
	mov	eax, DWORD PTR $T274380[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T274379[ebp]
	push	edx
	mov	eax, DWORD PTR $T274359[ebp]
	push	eax
	mov	ecx, DWORD PTR $T274378[ebp]
	push	ecx
	call	??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2769 : 		}
; 2770 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	jmp	$LN10@Buffered_m@8
$LN6@Buffered_m@8:
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN4@Buffered_m@8

; 2771 : 		{	// buffer right partition, then merge
; 2772 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T274291[ebp], esp
	mov	DWORD PTR $T274393[ebp], ecx
	mov	edx, DWORD PTR $T274393[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T274393[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T274393[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T274393[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T274393[ebp]
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR $T274393[ebp]
	mov	DWORD PTR tv220[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	lea	eax, DWORD PTR $T274292[ebp]
	push	eax
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv221[ebp], eax
	cmp	DWORD PTR $T274292[ebp], 0
	je	SHORT $LN67@Buffered_m@8
	mov	ecx, DWORD PTR $T274292[ebp]
	mov	DWORD PTR __Next$274404[ebp], ecx
	jmp	SHORT $LN65@Buffered_m@8
$LN64@Buffered_m@8:
	mov	edx, DWORD PTR __Next$274404[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Next$274404[ebp], edx
$LN65@Buffered_m@8:
	mov	eax, DWORD PTR __Next$274404[ebp]
	cmp	eax, DWORD PTR $T274292[ebp+8]
	je	SHORT $LN63@Buffered_m@8
	jmp	SHORT $LN64@Buffered_m@8
$LN63@Buffered_m@8:
	mov	ecx, DWORD PTR $T274292[ebp]
	mov	DWORD PTR $T274401[ebp], ecx
	mov	edx, DWORD PTR $T274401[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN67@Buffered_m@8:

; 2773 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid,
; 2774 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last);

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T274416[ebp], edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T274420[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T274425[ebp], al
	movzx	ecx, BYTE PTR $T274425[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T274416[ebp]
	push	eax
	mov	ecx, DWORD PTR $T274420[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@@std@@YAPAVCvHomelandUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *>
	add	esp, 24					; 00000018H

; 2775 : 		}
; 2776 : 	else

	jmp	$LN10@Buffered_m@8
$LN4@Buffered_m@8:

; 2777 : 		{	// buffer too small, divide and conquer
; 2778 : 		_BidIt _Firstn, _Lastn;
; 2779 : 		_Diff _Count1n, _Count2n;
; 2780 : 
; 2781 : 		if (_Count2 < _Count1)

	mov	ecx, DWORD PTR __Count2$[ebp]
	cmp	ecx, DWORD PTR __Count1$[ebp]
	jge	SHORT $LN2@Buffered_m@8

; 2782 : 			{	// left larger, cut it in half and partition right to match
; 2783 : 			_Count1n = _Count1 / 2, _Count2n = 0;

	mov	eax, DWORD PTR __Count1$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count1n$232952[ebp], eax
	mov	DWORD PTR __Count2n$232953[ebp], 0

; 2784 : 			_Firstn = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Firstn$232950[ebp], edx

; 2785 : 			std::advance(_Firstn, _Count1n);

	mov	eax, DWORD PTR __Count1n$232952[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Firstn$232950[ebp]
	mov	DWORD PTR __Firstn$232950[ebp], eax

; 2786 : 			_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);

	mov	ecx, DWORD PTR __Firstn$232950[ebp]
	mov	DWORD PTR $T274452[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T274451[ebp], edx
	push	0
	mov	eax, DWORD PTR $T274452[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T274451[ebp]
	push	edx
	call	??$_Lower_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvHomelandUnit *,CvHomelandUnit,int>
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T274451[ebp], eax
	mov	eax, DWORD PTR $T274451[ebp]
	mov	DWORD PTR __Lastn$232951[ebp], eax

; 2787 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T274470[ebp], ecx
	mov	edx, DWORD PTR __Lastn$232951[ebp]
	sub	edx, DWORD PTR $T274470[ebp]
	sar	edx, 4
	add	edx, DWORD PTR __Count2n$232953[ebp]
	mov	DWORD PTR __Count2n$232953[ebp], edx

; 2788 : 			}
; 2789 : 		else

	jmp	SHORT $LN1@Buffered_m@8
$LN2@Buffered_m@8:

; 2790 : 			{	// right larger, cut it in half and partition left to match
; 2791 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	DWORD PTR __Count1n$232952[ebp], 0
	mov	eax, DWORD PTR __Count2$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2n$232953[ebp], eax

; 2792 : 			_Lastn = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Lastn$232951[ebp], eax

; 2793 : 			std::advance(_Lastn, _Count2n);

	mov	ecx, DWORD PTR __Count2n$232953[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Lastn$232951[ebp]
	mov	DWORD PTR __Lastn$232951[ebp], ecx

; 2794 : 			_Firstn = std::upper_bound(_First, _Mid, *_Lastn);

	mov	edx, DWORD PTR __Lastn$232951[ebp]
	mov	DWORD PTR $T274548[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T274547[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T274548[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR $T274547[ebp]
	push	eax
	call	??$_Upper_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvHomelandUnit *,CvHomelandUnit,int>
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T274547[ebp], eax
	mov	ecx, DWORD PTR $T274547[ebp]
	mov	DWORD PTR __Firstn$232950[ebp], ecx

; 2795 : 			_Distance(_First, _Firstn, _Count1n);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T274566[ebp], edx
	mov	eax, DWORD PTR __Firstn$232950[ebp]
	sub	eax, DWORD PTR $T274566[ebp]
	sar	eax, 4
	add	eax, DWORD PTR __Count1n$232952[ebp]
	mov	DWORD PTR __Count1n$232952[ebp], eax
$LN1@Buffered_m@8:

; 2796 : 			}
; 2797 : 
; 2798 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2799 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count2n$232953[ebp]
	push	edx
	mov	eax, DWORD PTR __Count1$[ebp]
	sub	eax, DWORD PTR __Count1n$232952[ebp]
	push	eax
	mov	ecx, DWORD PTR __Lastn$232951[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __Firstn$232950[ebp]
	push	eax
	call	??$_Buffered_rotate@PAVCvHomelandUnit@@HV1@@std@@YAPAVCvHomelandUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Buffered_rotate<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Midn$232970[ebp], eax

; 2800 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2801 : 			_Count1n, _Count2n, _Tempbuf);	// merge each new part

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count2n$232953[ebp]
	push	edx
	mov	eax, DWORD PTR __Count1n$232952[ebp]
	push	eax
	mov	ecx, DWORD PTR __Midn$232970[ebp]
	push	ecx
	mov	edx, DWORD PTR __Firstn$232950[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Buffered_merge@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 24					; 00000018H

; 2802 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2803 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count2$[ebp]
	sub	edx, DWORD PTR __Count2n$232953[ebp]
	push	edx
	mov	eax, DWORD PTR __Count1$[ebp]
	sub	eax, DWORD PTR __Count1n$232952[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Lastn$232951[ebp]
	push	edx
	mov	eax, DWORD PTR __Midn$232970[ebp]
	push	eax
	call	??$_Buffered_merge@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 24					; 00000018H
$LN10@Buffered_m@8:

; 2804 : 		}
; 2805 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ENDP ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z
_TEXT	SEGMENT
__Step$232973 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z PROC ; std::_Median<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>, COMDAT

; 3009 : 	{	// sort median element to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 3010 : 	if (40 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median@2

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	add	eax, 1
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR __Step$232973[ebp], eax

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	ecx, DWORD PTR __Step$232973[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __Step$232973[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	edx, DWORD PTR __Step$232973[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$232973[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Mid$[ebp]
	sub	ecx, eax
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$232973[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Step$232973[ebp]
	shl	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, edx
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	ecx, DWORD PTR __Step$232973[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Step$232973[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3017 : 		}
; 3018 : 	else

	jmp	SHORT $LN3@Median@2
$LN2@Median@2:

; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
$LN3@Median@2:

; 3020 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
; Function compile flags: /Odtp
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0PAH0@Z
_TEXT	SEGMENT
$T274927 = -20						; size = 4
$T274926 = -16						; size = 4
__Hole$232991 = -8					; size = 4
__Bottom$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Bottom$[ebp], eax

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, DWORD PTR __Bottom$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Hole$232991[ebp], eax
$LN2@Make_heap:
	cmp	DWORD PTR __Hole$232991[ebp], 0
	jle	SHORT $LN3@Make_heap

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;

	mov	ecx, DWORD PTR __Hole$232991[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$232991[ebp], ecx

; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	edx, DWORD PTR __Hole$232991[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T274927[ebp], ecx
	sub	esp, 8
	mov	DWORD PTR $T274926[ebp], esp
	mov	edx, DWORD PTR $T274926[ebp]
	mov	eax, DWORD PTR $T274927[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T274926[ebp]
	mov	eax, DWORD PTR $T274927[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __Bottom$[ebp]
	push	edx
	mov	eax, DWORD PTR __Hole$232991[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2172 : 		}

	jmp	SHORT $LN2@Make_heap
$LN3@Make_heap:

; 2173 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z
_TEXT	SEGMENT
$T274997 = -52						; size = 4
$T274996 = -48						; size = 4
$T274980 = -42						; size = 1
$T274979 = -41						; size = 1
$T274978 = -40						; size = 4
$T274977 = -36						; size = 4
$T274976 = -32						; size = 4
__Cat$274986 = -24					; size = 1
$T274984 = -23						; size = 1
$T274983 = -22						; size = 1
$T274982 = -21						; size = 1
__First1$233032 = -20					; size = 4
__Val$233022 = -16					; size = 8
__Next1$233021 = -8					; size = 4
__Next$233017 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_@2

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$233017[ebp], ecx
$LN7@Insertion_@2:
	mov	edx, DWORD PTR __Next$233017[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$233017[ebp], edx
	mov	eax, DWORD PTR __Next$233017[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_@2

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$233017[ebp]
	mov	DWORD PTR __Next1$233021[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$233017[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Val$233022[ebp], eax
	mov	ecx, DWORD PTR __Next$233017[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Val$233022[ebp+4], edx

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$233022[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN5@Insertion_@2

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	ecx, DWORD PTR __Next1$233021[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next1$233021[ebp], ecx
	mov	edx, DWORD PTR __Next1$233021[ebp]
	mov	DWORD PTR $T274997[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T274996[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T274982[ebp], cl
	mov	dl, BYTE PTR __Cat$274986[ebp]
	mov	BYTE PTR $T274983[ebp], dl
	mov	al, BYTE PTR $T274982[ebp]
	mov	BYTE PTR $T274980[ebp], al
	mov	cl, BYTE PTR $T274984[ebp]
	mov	BYTE PTR $T274979[ebp], cl
	mov	edx, DWORD PTR $T274997[ebp]
	mov	DWORD PTR $T274978[ebp], edx
	mov	eax, DWORD PTR __Next$233017[ebp]
	mov	DWORD PTR $T274977[ebp], eax
	mov	ecx, DWORD PTR $T274996[ebp]
	mov	DWORD PTR $T274976[ebp], ecx
$LN22@Insertion_@2:
	mov	edx, DWORD PTR $T274976[ebp]
	cmp	edx, DWORD PTR $T274977[ebp]
	je	SHORT $LN15@Insertion_@2
	mov	eax, DWORD PTR $T274977[ebp]
	sub	eax, 8
	mov	DWORD PTR $T274977[ebp], eax
	mov	ecx, DWORD PTR $T274978[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T274978[ebp], ecx
	mov	edx, DWORD PTR $T274977[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T274978[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN22@Insertion_@2
$LN15@Insertion_@2:

; 2977 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$233022[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$233022[ebp+4]
	mov	DWORD PTR [eax+4], edx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@2
$LN5@Insertion_@2:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	eax, DWORD PTR __Next1$233021[ebp]
	mov	DWORD PTR __First1$233032[ebp], eax

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_@2
$LN2@Insertion_@2:
	mov	ecx, DWORD PTR __First1$233032[ebp]
	mov	DWORD PTR __Next1$233021[ebp], ecx
$LN3@Insertion_@2:
	mov	edx, DWORD PTR __First1$233032[ebp]
	sub	edx, 8
	mov	DWORD PTR __First1$233032[ebp], edx
	mov	eax, DWORD PTR __First1$233032[ebp]
	mov	ecx, DWORD PTR __Val$233022[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@Insertion_@2

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ecx, DWORD PTR __First1$233032[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Next1$233021[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN2@Insertion_@2
$LN1@Insertion_@2:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	edx, DWORD PTR __Next1$233021[ebp]
	mov	eax, DWORD PTR __Val$233022[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Val$233022[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN4@Insertion_@2:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_@2
$LN9@Insertion_@2:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z
_TEXT	SEGMENT
__Step$233038 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z PROC ; std::_Median<CvWeightedVector<CvCity *,64,1>::WeightedElement *>, COMDAT

; 3009 : 	{	// sort median element to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 3010 : 	if (40 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median@3

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	add	eax, 1
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR __Step$233038[ebp], eax

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	ecx, DWORD PTR __Step$233038[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __Step$233038[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	edx, DWORD PTR __Step$233038[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$233038[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Mid$[ebp]
	sub	ecx, eax
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$233038[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Step$233038[ebp]
	shl	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, edx
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	ecx, DWORD PTR __Step$233038[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Step$233038[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3017 : 		}
; 3018 : 	else

	jmp	SHORT $LN3@Median@3
$LN2@Median@3:

; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
$LN3@Median@3:

; 3020 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
; Function compile flags: /Odtp
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0PAH0@Z
_TEXT	SEGMENT
$T275313 = -20						; size = 4
$T275312 = -16						; size = 4
__Hole$233056 = -8					; size = 4
__Bottom$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Bottom$[ebp], eax

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, DWORD PTR __Bottom$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Hole$233056[ebp], eax
$LN2@Make_heap@2:
	cmp	DWORD PTR __Hole$233056[ebp], 0
	jle	SHORT $LN3@Make_heap@2

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;

	mov	ecx, DWORD PTR __Hole$233056[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$233056[ebp], ecx

; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	edx, DWORD PTR __Hole$233056[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T275313[ebp], ecx
	sub	esp, 8
	mov	DWORD PTR $T275312[ebp], esp
	mov	edx, DWORD PTR $T275312[ebp]
	mov	eax, DWORD PTR $T275313[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T275312[ebp]
	mov	eax, DWORD PTR $T275313[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __Bottom$[ebp]
	push	edx
	mov	eax, DWORD PTR __Hole$233056[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2172 : 		}

	jmp	SHORT $LN2@Make_heap@2
$LN3@Make_heap@2:

; 2173 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z
_TEXT	SEGMENT
$T275383 = -52						; size = 4
$T275382 = -48						; size = 4
$T275366 = -42						; size = 1
$T275365 = -41						; size = 1
$T275364 = -40						; size = 4
$T275363 = -36						; size = 4
$T275362 = -32						; size = 4
__Cat$275373 = -24					; size = 1
$T275371 = -23						; size = 1
$T275370 = -22						; size = 1
$T275369 = -21						; size = 1
__First1$233097 = -20					; size = 4
__Val$233087 = -16					; size = 8
__Next1$233086 = -8					; size = 4
__Next$233082 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_@3

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$233082[ebp], ecx
$LN7@Insertion_@3:
	mov	edx, DWORD PTR __Next$233082[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$233082[ebp], edx
	mov	eax, DWORD PTR __Next$233082[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_@3

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$233082[ebp]
	mov	DWORD PTR __Next1$233086[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$233082[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Val$233087[ebp], eax
	mov	ecx, DWORD PTR __Next$233082[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Val$233087[ebp+4], edx

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$233087[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN5@Insertion_@3

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	ecx, DWORD PTR __Next1$233086[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next1$233086[ebp], ecx
	mov	edx, DWORD PTR __Next1$233086[ebp]
	mov	DWORD PTR $T275383[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T275382[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T275369[ebp], cl
	mov	dl, BYTE PTR __Cat$275373[ebp]
	mov	BYTE PTR $T275370[ebp], dl
	mov	al, BYTE PTR $T275369[ebp]
	mov	BYTE PTR $T275366[ebp], al
	mov	cl, BYTE PTR $T275371[ebp]
	mov	BYTE PTR $T275365[ebp], cl
	mov	edx, DWORD PTR $T275383[ebp]
	mov	DWORD PTR $T275364[ebp], edx
	mov	eax, DWORD PTR __Next$233082[ebp]
	mov	DWORD PTR $T275363[ebp], eax
	mov	ecx, DWORD PTR $T275382[ebp]
	mov	DWORD PTR $T275362[ebp], ecx
$LN22@Insertion_@3:
	mov	edx, DWORD PTR $T275362[ebp]
	cmp	edx, DWORD PTR $T275363[ebp]
	je	SHORT $LN15@Insertion_@3
	mov	eax, DWORD PTR $T275363[ebp]
	sub	eax, 8
	mov	DWORD PTR $T275363[ebp], eax
	mov	ecx, DWORD PTR $T275364[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T275364[ebp], ecx
	mov	edx, DWORD PTR $T275363[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T275364[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN22@Insertion_@3
$LN15@Insertion_@3:

; 2977 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$233087[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$233087[ebp+4]
	mov	DWORD PTR [eax+4], edx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@3
$LN5@Insertion_@3:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	eax, DWORD PTR __Next1$233086[ebp]
	mov	DWORD PTR __First1$233097[ebp], eax

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_@3
$LN2@Insertion_@3:
	mov	ecx, DWORD PTR __First1$233097[ebp]
	mov	DWORD PTR __Next1$233086[ebp], ecx
$LN3@Insertion_@3:
	mov	edx, DWORD PTR __First1$233097[ebp]
	sub	edx, 8
	mov	DWORD PTR __First1$233097[ebp], edx
	mov	eax, DWORD PTR __First1$233097[ebp]
	mov	ecx, DWORD PTR __Val$233087[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@Insertion_@3

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ecx, DWORD PTR __First1$233097[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Next1$233086[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN2@Insertion_@3
$LN1@Insertion_@3:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	edx, DWORD PTR __Next1$233086[ebp]
	mov	eax, DWORD PTR __Val$233087[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Val$233087[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN4@Insertion_@3:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_@3
$LN9@Insertion_@3:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z
_TEXT	SEGMENT
$T275403 = -21						; size = 1
$T275402 = -20						; size = 4
$T275401 = -16						; size = 4
__Result$275398 = -12					; size = 4
__Count$275397 = -8					; size = 4
__Cat$275393 = -3					; size = 1
$T275390 = -2						; size = 1
$T275389 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T275389[ebp], al
	mov	cl, BYTE PTR __Cat$275393[ebp]
	mov	BYTE PTR $T275390[ebp], cl
	mov	dl, BYTE PTR $T275389[ebp]
	mov	BYTE PTR $T275403[ebp], dl
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T275402[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T275401[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T275401[ebp]
	sar	edx, 2
	mov	DWORD PTR __Count$275397[ebp], edx
	mov	eax, DWORD PTR __Count$275397[ebp]
	mov	ecx, DWORD PTR $T275402[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Result$275398[ebp], edx
	cmp	DWORD PTR __Count$275397[ebp], 0
	jbe	SHORT $LN6@unchecked_@3
	mov	eax, DWORD PTR __Count$275397[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T275401[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$275397[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T275402[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN6@unchecked_@3:
	mov	eax, DWORD PTR __Result$275398[ebp]

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z
_TEXT	SEGMENT
$T275420 = -21						; size = 1
$T275419 = -20						; size = 4
$T275418 = -16						; size = 4
__Result$275415 = -12					; size = 4
__Count$275414 = -8					; size = 4
__Cat$275410 = -3					; size = 1
$T275407 = -2						; size = 1
$T275406 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T275406[ebp], al
	mov	cl, BYTE PTR __Cat$275410[ebp]
	mov	BYTE PTR $T275407[ebp], cl
	mov	dl, BYTE PTR $T275406[ebp]
	mov	BYTE PTR $T275420[ebp], dl
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T275419[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T275418[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T275418[ebp]
	sar	edx, 2
	mov	DWORD PTR __Count$275414[ebp], edx
	mov	eax, DWORD PTR __Count$275414[ebp]
	mov	ecx, DWORD PTR $T275419[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Result$275415[ebp], edx
	cmp	DWORD PTR __Count$275414[ebp], 0
	jbe	SHORT $LN6@unchecked_@4
	mov	eax, DWORD PTR __Count$275414[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T275418[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$275414[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T275419[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN6@unchecked_@4:
	mov	eax, DWORD PTR __Result$275415[ebp]

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
; Function compile flags: /Odtp
;	COMDAT ??$get_temporary_buffer@VCvHomelandMove@@@std@@YA?AU?$pair@PAVCvHomelandMove@@H@0@H@Z
_TEXT	SEGMENT
$T275427 = -20						; size = 4
$T275423 = -16						; size = 12
__Pbuf$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@VCvHomelandMove@@@std@@YA?AU?$pair@PAVCvHomelandMove@@H@0@H@Z PROC ; std::get_temporary_buffer<CvHomelandMove>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jg	SHORT $LN7@get_tempor

; 23   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN6@get_tempor
$LN7@get_tempor:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN6@get_tempor

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T275427[ebp], 0
	lea	eax, DWORD PTR $T275427[ebp]
	push	eax
	lea	ecx, DWORD PTR $T275423[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T275423[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T275423[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN6@get_tempor:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	mov	DWORD PTR __Pbuf$[ebp], 0
	jmp	SHORT $LN4@get_tempor
$LN3@get_tempor:
	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN4@get_tempor:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN2@get_tempor

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 3
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	add	esp, 8
	mov	DWORD PTR __Pbuf$[ebp], eax
	cmp	DWORD PTR __Pbuf$[ebp], 0
	je	SHORT $LN1@get_tempor

; 30   : 			break;

	jmp	SHORT $LN2@get_tempor
$LN1@get_tempor:

; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	jmp	SHORT $LN3@get_tempor
$LN2@get_tempor:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Pbuf$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN9@get_tempor:

; 33   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$get_temporary_buffer@VCvHomelandMove@@@std@@YA?AU?$pair@PAVCvHomelandMove@@H@0@H@Z ENDP ; std::get_temporary_buffer<CvHomelandMove>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$get_temporary_buffer@VCvHomelandTarget@@@std@@YA?AU?$pair@PAVCvHomelandTarget@@H@0@H@Z
_TEXT	SEGMENT
$T275437 = -20						; size = 4
$T275433 = -16						; size = 12
__Pbuf$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@VCvHomelandTarget@@@std@@YA?AU?$pair@PAVCvHomelandTarget@@H@0@H@Z PROC ; std::get_temporary_buffer<CvHomelandTarget>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jg	SHORT $LN7@get_tempor@2

; 23   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN6@get_tempor@2
$LN7@get_tempor@2:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 20					; 00000014H
	jae	SHORT $LN6@get_tempor@2

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T275437[ebp], 0
	lea	eax, DWORD PTR $T275437[ebp]
	push	eax
	lea	ecx, DWORD PTR $T275433[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T275433[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T275433[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN6@get_tempor@2:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	mov	DWORD PTR __Pbuf$[ebp], 0
	jmp	SHORT $LN4@get_tempor@2
$LN3@get_tempor@2:
	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN4@get_tempor@2:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN2@get_tempor@2

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 20					; 00000014H
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	add	esp, 8
	mov	DWORD PTR __Pbuf$[ebp], eax
	cmp	DWORD PTR __Pbuf$[ebp], 0
	je	SHORT $LN1@get_tempor@2

; 30   : 			break;

	jmp	SHORT $LN2@get_tempor@2
$LN1@get_tempor@2:

; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	jmp	SHORT $LN3@get_tempor@2
$LN2@get_tempor@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Pbuf$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN9@get_tempor@2:

; 33   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$get_temporary_buffer@VCvHomelandTarget@@@std@@YA?AU?$pair@PAVCvHomelandTarget@@H@0@H@Z ENDP ; std::get_temporary_buffer<CvHomelandTarget>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$get_temporary_buffer@VCvHomelandUnit@@@std@@YA?AU?$pair@PAVCvHomelandUnit@@H@0@H@Z
_TEXT	SEGMENT
$T275447 = -20						; size = 4
$T275443 = -16						; size = 12
__Pbuf$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@VCvHomelandUnit@@@std@@YA?AU?$pair@PAVCvHomelandUnit@@H@0@H@Z PROC ; std::get_temporary_buffer<CvHomelandUnit>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jg	SHORT $LN7@get_tempor@3

; 23   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN6@get_tempor@3
$LN7@get_tempor@3:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN6@get_tempor@3

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T275447[ebp], 0
	lea	eax, DWORD PTR $T275447[ebp]
	push	eax
	lea	ecx, DWORD PTR $T275443[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T275443[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T275443[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN6@get_tempor@3:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	mov	DWORD PTR __Pbuf$[ebp], 0
	jmp	SHORT $LN4@get_tempor@3
$LN3@get_tempor@3:
	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN4@get_tempor@3:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN2@get_tempor@3

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 4
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	add	esp, 8
	mov	DWORD PTR __Pbuf$[ebp], eax
	cmp	DWORD PTR __Pbuf$[ebp], 0
	je	SHORT $LN1@get_tempor@3

; 30   : 			break;

	jmp	SHORT $LN2@get_tempor@3
$LN1@get_tempor@3:

; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	jmp	SHORT $LN3@get_tempor@3
$LN2@get_tempor@3:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Pbuf$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN9@get_tempor@3:

; 33   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$get_temporary_buffer@VCvHomelandUnit@@@std@@YA?AU?$pair@PAVCvHomelandUnit@@H@0@H@Z ENDP ; std::get_temporary_buffer<CvHomelandUnit>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Med3@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
$T275641 = -48						; size = 4
$T275640 = -44						; size = 4
__Tmp$275687 = -40					; size = 4
__Tmp$275681 = -36					; size = 4
$T275561 = -32						; size = 4
$T275560 = -28						; size = 4
__Tmp$275607 = -24					; size = 4
__Tmp$275601 = -20					; size = 4
$T275481 = -16						; size = 4
$T275480 = -12						; size = 4
__Tmp$275524 = -8					; size = 4
__Tmp$275518 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Med3@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z PROC ; std::_Med3<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 3156 : 	{	// sort median of three elements to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 3157 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@Med3

; 3158 : 		std::iter_swap(_Mid, _First);

	mov	eax, DWORD PTR __Mid$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN3@Med3
	mov	ecx, DWORD PTR __Mid$[ebp]
	cmp	ecx, DWORD PTR __First$[ebp]
	je	SHORT $LN13@Med3
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$275518[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Tmp$275518[ebp]
	mov	DWORD PTR [ecx], edx
$LN13@Med3:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR $T275481[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T275480[ebp], ecx
	mov	edx, DWORD PTR $T275480[ebp]
	cmp	edx, DWORD PTR $T275481[ebp]
	je	SHORT $LN3@Med3
	mov	eax, DWORD PTR $T275480[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$275524[ebp], ecx
	mov	edx, DWORD PTR $T275480[ebp]
	mov	eax, DWORD PTR $T275481[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T275481[ebp]
	mov	eax, DWORD PTR __Tmp$275524[ebp]
	mov	DWORD PTR [edx], eax
$LN3@Med3:

; 3159 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Med3

; 3160 : 		std::iter_swap(_Last, _Mid);

	mov	ecx, DWORD PTR __Last$[ebp]
	cmp	ecx, DWORD PTR __Mid$[ebp]
	je	SHORT $LN2@Med3
	mov	edx, DWORD PTR __Last$[ebp]
	cmp	edx, DWORD PTR __Mid$[ebp]
	je	SHORT $LN30@Med3
	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$275601[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR __Tmp$275601[ebp]
	mov	DWORD PTR [edx], eax
$LN30@Med3:
	mov	ecx, DWORD PTR __Mid$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T275561[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	add	edx, 4
	mov	DWORD PTR $T275560[ebp], edx
	mov	eax, DWORD PTR $T275560[ebp]
	cmp	eax, DWORD PTR $T275561[ebp]
	je	SHORT $LN2@Med3
	mov	ecx, DWORD PTR $T275560[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$275607[ebp], edx
	mov	eax, DWORD PTR $T275560[ebp]
	mov	ecx, DWORD PTR $T275561[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T275561[ebp]
	mov	ecx, DWORD PTR __Tmp$275607[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@Med3:

; 3161 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Med3

; 3162 : 		std::iter_swap(_Mid, _First);

	mov	edx, DWORD PTR __Mid$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN4@Med3
	mov	eax, DWORD PTR __Mid$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN47@Med3
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$275681[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Tmp$275681[ebp]
	mov	DWORD PTR [eax], ecx
$LN47@Med3:
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR $T275641[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	add	eax, 4
	mov	DWORD PTR $T275640[ebp], eax
	mov	ecx, DWORD PTR $T275640[ebp]
	cmp	ecx, DWORD PTR $T275641[ebp]
	je	SHORT $LN4@Med3
	mov	edx, DWORD PTR $T275640[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$275687[ebp], eax
	mov	ecx, DWORD PTR $T275640[ebp]
	mov	edx, DWORD PTR $T275641[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T275641[ebp]
	mov	edx, DWORD PTR __Tmp$275687[ebp]
	mov	DWORD PTR [ecx], edx
$LN4@Med3:

; 3163 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Med3@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z ENDP ; std::_Med3<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Adjust_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@HHU10@P6A_NABU10@2@Z@Z
_TEXT	SEGMENT
$T275703 = -24						; size = 8
$T275702 = -16						; size = 4
__Idx$275698 = -12					; size = 4
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
__Pred$ = 28						; size = 4
??$_Adjust_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@HHU10@P6A_NABU10@2@Z@Z PROC ; std::_Adjust_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 2108 : 	{	// percolate _Hole to _Bottom, then push _Val, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi

; 2109 : 	_Diff _Top = _Hole;

	mov	eax, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR __Top$[ebp], eax

; 2110 : 	_Diff _Idx = 2 * _Hole + 2;

	mov	ecx, DWORD PTR __Hole$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	DWORD PTR __Idx$[ebp], edx

; 2111 : 
; 2112 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	jmp	SHORT $LN5@Adjust_hea
$LN4@Adjust_hea:
	mov	eax, DWORD PTR __Idx$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea:
	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jge	SHORT $LN3@Adjust_hea

; 2113 : 		{	// move _Hole down to larger child
; 2114 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

	mov	eax, DWORD PTR __Idx$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8-8]
	push	edx
	mov	eax, DWORD PTR __Idx$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Adjust_hea

; 2115 : 			--_Idx;

	mov	ecx, DWORD PTR __Idx$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Idx$[ebp], ecx
$LN2@Adjust_hea:

; 2116 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	edx, DWORD PTR __Idx$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [eax+edx*8+4]
	mov	eax, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx
	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	DWORD PTR __Hole$[ebp], ecx

; 2117 : 		}

	jmp	SHORT $LN4@Adjust_hea
$LN3@Adjust_hea:

; 2118 : 
; 2119 : 	if (_Idx == _Bottom)

	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jne	SHORT $LN1@Adjust_hea

; 2120 : 		{	// only child at bottom, move _Hole down to it
; 2121 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	eax, DWORD PTR __Bottom$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8-8]
	mov	eax, DWORD PTR [ecx+eax*8-4]
	mov	ecx, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+ecx*8], edx
	mov	DWORD PTR [esi+ecx*8+4], eax

; 2122 : 		_Hole = _Bottom - 1;

	mov	edx, DWORD PTR __Bottom$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Hole$[ebp], edx
$LN1@Adjust_hea:

; 2123 : 		}
; 2124 : 	std::_Push_heap(_First, _Hole, _Top, _Val, _Pred);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR $T275703[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR $T275703[ebp+4], ecx
	mov	edx, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR $T275702[ebp], edx
	mov	eax, DWORD PTR $T275702[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$275698[ebp], eax
	jmp	SHORT $LN10@Adjust_hea
$LN9@Adjust_hea:
	mov	eax, DWORD PTR $T275702[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$275698[ebp], eax
$LN10@Adjust_hea:
	mov	eax, DWORD PTR __Top$[ebp]
	cmp	eax, DWORD PTR $T275702[ebp]
	jge	SHORT $LN8@Adjust_hea
	lea	ecx, DWORD PTR $T275703[ebp]
	push	ecx
	mov	edx, DWORD PTR __Idx$275698[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@Adjust_hea
	mov	eax, DWORD PTR __Idx$275698[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	mov	ecx, DWORD PTR $T275702[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+ecx*8], edx
	mov	DWORD PTR [esi+ecx*8+4], eax
	mov	edx, DWORD PTR __Idx$275698[ebp]
	mov	DWORD PTR $T275702[ebp], edx
	jmp	SHORT $LN9@Adjust_hea
$LN8@Adjust_hea:
	mov	eax, DWORD PTR $T275702[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR $T275703[ebp]
	mov	DWORD PTR [ecx+eax*8], edx
	mov	edx, DWORD PTR $T275703[ebp+4]
	mov	DWORD PTR [ecx+eax*8+4], edx

; 2125 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adjust_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@HHU10@P6A_NABU10@2@Z@Z ENDP ; std::_Adjust_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAVCvHomelandMove@@V1@@std@@YAXPAVCvHomelandMove@@00@Z
_TEXT	SEGMENT
$T275747 = -52						; size = 4
$T275746 = -48						; size = 4
$T275730 = -42						; size = 1
$T275729 = -41						; size = 1
$T275728 = -40						; size = 4
$T275727 = -36						; size = 4
$T275726 = -32						; size = 4
__Cat$275736 = -24					; size = 1
$T275734 = -23						; size = 1
$T275733 = -22						; size = 1
$T275732 = -21						; size = 1
__First1$233424 = -20					; size = 4
__Val$233414 = -16					; size = 8
__Next1$233413 = -8					; size = 4
__Next$233409 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAVCvHomelandMove@@V1@@std@@YAXPAVCvHomelandMove@@00@Z PROC ; std::_Insertion_sort1<CvHomelandMove *,CvHomelandMove>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_@4

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$233409[ebp], ecx
$LN7@Insertion_@4:
	mov	edx, DWORD PTR __Next$233409[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$233409[ebp], edx
	mov	eax, DWORD PTR __Next$233409[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_@4

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$233409[ebp]
	mov	DWORD PTR __Next1$233413[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$233409[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Val$233414[ebp], eax
	mov	DWORD PTR __Val$233414[ebp+4], ecx

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$233414[ebp+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN5@Insertion_@4

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, DWORD PTR __Next1$233413[ebp]
	add	eax, 8
	mov	DWORD PTR __Next1$233413[ebp], eax
	mov	ecx, DWORD PTR __Next1$233413[ebp]
	mov	DWORD PTR $T275747[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T275746[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T275732[ebp], al
	mov	cl, BYTE PTR __Cat$275736[ebp]
	mov	BYTE PTR $T275733[ebp], cl
	mov	dl, BYTE PTR $T275732[ebp]
	mov	BYTE PTR $T275730[ebp], dl
	mov	al, BYTE PTR $T275734[ebp]
	mov	BYTE PTR $T275729[ebp], al
	mov	ecx, DWORD PTR $T275747[ebp]
	mov	DWORD PTR $T275728[ebp], ecx
	mov	edx, DWORD PTR __Next$233409[ebp]
	mov	DWORD PTR $T275727[ebp], edx
	mov	eax, DWORD PTR $T275746[ebp]
	mov	DWORD PTR $T275726[ebp], eax
$LN20@Insertion_@4:
	mov	ecx, DWORD PTR $T275726[ebp]
	cmp	ecx, DWORD PTR $T275727[ebp]
	je	SHORT $LN13@Insertion_@4
	mov	edx, DWORD PTR $T275727[ebp]
	sub	edx, 8
	mov	DWORD PTR $T275727[ebp], edx
	mov	eax, DWORD PTR $T275728[ebp]
	sub	eax, 8
	mov	DWORD PTR $T275728[ebp], eax
	mov	ecx, DWORD PTR $T275727[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T275728[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN20@Insertion_@4
$LN13@Insertion_@4:

; 2977 : 				*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$233414[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Val$233414[ebp+4]
	mov	DWORD PTR [edx+4], ecx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@4
$LN5@Insertion_@4:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	edx, DWORD PTR __Next1$233413[ebp]
	mov	DWORD PTR __First1$233424[ebp], edx

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_@4
$LN2@Insertion_@4:
	mov	eax, DWORD PTR __First1$233424[ebp]
	mov	DWORD PTR __Next1$233413[ebp], eax
$LN3@Insertion_@4:
	mov	ecx, DWORD PTR __First1$233424[ebp]
	sub	ecx, 8
	mov	DWORD PTR __First1$233424[ebp], ecx
	mov	edx, DWORD PTR __First1$233424[ebp]
	mov	eax, DWORD PTR __Val$233414[ebp+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@Insertion_@4

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	eax, DWORD PTR __First1$233424[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Next1$233413[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN2@Insertion_@4
$LN1@Insertion_@4:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	ecx, DWORD PTR __Next1$233413[ebp]
	mov	edx, DWORD PTR __Val$233414[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Val$233414[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN4@Insertion_@4:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_@4
$LN9@Insertion_@4:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAVCvHomelandMove@@V1@@std@@YAXPAVCvHomelandMove@@00@Z ENDP ; std::_Insertion_sort1<CvHomelandMove *,CvHomelandMove>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@std@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,int>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Unchecked_chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@stdext@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@std@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked_chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@stdext@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@std@@HH@Z$0
__ehfuncinfo$??$_Unchecked_chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@stdext@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@std@@HH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked_chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@stdext@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@std@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@stdext@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@std@@HH@Z
_TEXT	SEGMENT
tv92 = -164						; size = 4
$T275907 = -160						; size = 4
__Next$275910 = -156					; size = 4
$T275765 = -24						; size = 4
$T275754 = -20						; size = 4
$T275753 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
??$_Unchecked_chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@stdext@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@std@@HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,int>, COMDAT

; 5252 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unchecked_chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@stdext@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@std@@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T275753[ebp], al
	movzx	ecx, BYTE PTR $T275753[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Chunk$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T275754[ebp], esp
	mov	DWORD PTR $T275765[ebp], ecx
	mov	edx, DWORD PTR $T275765[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T275765[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T275765[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T275765[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T275765[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T275765[ebp]
	mov	DWORD PTR tv92[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@std@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,int>
	add	esp, 40					; 00000028H

; 5254 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN1@Unchecked_@3
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$275910[ebp], edx
	jmp	SHORT $LN77@Unchecked_@3
$LN76@Unchecked_@3:
	mov	eax, DWORD PTR __Next$275910[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$275910[ebp], eax
$LN77@Unchecked_@3:
	mov	ecx, DWORD PTR __Next$275910[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN75@Unchecked_@3
	jmp	SHORT $LN76@Unchecked_@3
$LN75@Unchecked_@3:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T275907[ebp], edx
	mov	eax, DWORD PTR $T275907[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Unchecked_@3:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked_chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@stdext@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@std@@HH@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandMove>::~_Temp_iterator<CvHomelandMove>
__ehhandler$??$_Unchecked_chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@stdext@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@std@@HH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-156]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked_chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@stdext@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@std@@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked_chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@stdext@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@std@@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,int>
PUBLIC	??$_Copy_opt@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,std::forward_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z$0
__ehfuncinfo$??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z
_TEXT	SEGMENT
tv135 = -48						; size = 4
tv134 = -44						; size = 4
$T275960 = -40						; size = 4
__Next$275963 = -36					; size = 4
$T275952 = -32						; size = 4
__Cat$275938 = -25					; size = 1
$T275934 = -24						; size = 4
$T275930 = -20						; size = 4
$T275929 = -15						; size = 1
$T275928 = -14						; size = 1
$T275927 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z PROC ; stdext::unchecked_copy<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T275934[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T275927[ebp], al
	mov	cl, BYTE PTR __Cat$275938[ebp]
	mov	BYTE PTR $T275928[ebp], cl
	movzx	edx, BYTE PTR $T275927[ebp]
	push	edx
	movzx	eax, BYTE PTR $T275928[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T275929[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T275930[ebp], esp
	mov	DWORD PTR $T275952[ebp], edx
	mov	eax, DWORD PTR $T275952[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T275952[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T275952[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T275952[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T275952[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T275952[ebp]
	mov	DWORD PTR tv134[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Copy_opt@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,std::forward_iterator_tag>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv135[ebp], eax
	mov	ecx, DWORD PTR $T275934[ebp]
	or	ecx, 1
	mov	DWORD PTR $T275934[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN19@unchecked_@5
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$275963[ebp], edx
	jmp	SHORT $LN17@unchecked_@5
$LN16@unchecked_@5:
	mov	eax, DWORD PTR __Next$275963[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$275963[ebp], eax
$LN17@unchecked_@5:
	mov	ecx, DWORD PTR __Next$275963[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN15@unchecked_@5
	jmp	SHORT $LN16@unchecked_@5
$LN15@unchecked_@5:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T275960[ebp], edx
	mov	eax, DWORD PTR $T275960[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@unchecked_@5:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3607 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandMove>::~_Temp_iterator<CvHomelandMove>
__ehhandler$??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z ENDP ; stdext::unchecked_copy<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
PUBLIC	??$_Rotate@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00PAH0@Z ; std::_Rotate<CvHomelandMove *,int,CvHomelandMove>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_rotate@PAVCvHomelandMove@@HV1@@std@@YAPAVCvHomelandMove@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z
_TEXT	SEGMENT
tv178 = -260						; size = 4
tv177 = -256						; size = 4
tv174 = -252						; size = 4
tv173 = -248						; size = 4
$T276260 = -240						; size = 4
$T276246 = -233						; size = 1
$T276245 = -232						; size = 4
$T276250 = -225						; size = 1
$T276225 = -224						; size = 4
$T276224 = -220						; size = 4
$T276207 = -214						; size = 1
$T276206 = -213						; size = 1
$T276205 = -212						; size = 4
$T276204 = -208						; size = 4
__Cat$276214 = -200					; size = 1
$T276212 = -199						; size = 1
$T276211 = -198						; size = 1
$T276210 = -197						; size = 1
$T276185 = -196						; size = 4
$T276181 = -192						; size = 4
$T276177 = -188						; size = 4
$T276176 = -184						; size = 4
$T276160 = -178						; size = 1
$T276159 = -177						; size = 1
$T276158 = -176						; size = 4
$T276157 = -172						; size = 4
$T276156 = -168						; size = 4
__Cat$276167 = -160					; size = 1
$T276165 = -159						; size = 1
$T276164 = -158						; size = 1
$T276163 = -157						; size = 1
$T276127 = -156						; size = 4
__Next$276130 = -152					; size = 4
$T276119 = -148						; size = 4
$T276106 = -136						; size = 4
$T276105 = -132						; size = 4
$T276089 = -126						; size = 1
$T276088 = -125						; size = 1
$T276087 = -124						; size = 4
$T276086 = -120						; size = 4
$T276085 = -116						; size = 4
__Cat$276096 = -108					; size = 1
$T276094 = -107						; size = 1
$T276093 = -106						; size = 1
$T276092 = -105						; size = 1
$T276067 = -104						; size = 4
$T276063 = -100						; size = 4
$T276059 = -96						; size = 4
$T276058 = -92						; size = 4
$T276041 = -86						; size = 1
$T276040 = -85						; size = 1
$T276039 = -84						; size = 4
$T276038 = -80						; size = 4
__Cat$276048 = -72					; size = 1
$T276046 = -71						; size = 1
$T276045 = -70						; size = 1
$T276044 = -69						; size = 1
$T276008 = -68						; size = 4
__Next$276011 = -64					; size = 4
$T276000 = -60						; size = 4
$T275983 = -48						; size = 20
$T275982 = -28						; size = 4
$T275981 = -24						; size = 20
$T275980 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_rotate@PAVCvHomelandMove@@HV1@@std@@YAPAVCvHomelandMove@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z PROC ; std::_Buffered_rotate<CvHomelandMove *,int,CvHomelandMove>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	eax, DWORD PTR __Count1$[ebp]
	cmp	eax, DWORD PTR __Count2$[ebp]
	jg	$LN4@Buffered_r
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandMove>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN4@Buffered_r

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T275980[ebp], esp
	mov	DWORD PTR $T276000[ebp], eax
	mov	ecx, DWORD PTR $T276000[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T276000[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T276000[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T276000[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T276000[ebp]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T276000[ebp]
	mov	DWORD PTR tv173[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T275981[ebp]
	push	edx
	call	??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z ; stdext::unchecked_copy<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv174[ebp], eax
	cmp	DWORD PTR $T275981[ebp], 0
	je	SHORT $LN24@Buffered_r
	mov	eax, DWORD PTR $T275981[ebp]
	mov	DWORD PTR __Next$276011[ebp], eax
	jmp	SHORT $LN22@Buffered_r
$LN21@Buffered_r:
	mov	ecx, DWORD PTR __Next$276011[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$276011[ebp], ecx
$LN22@Buffered_r:
	mov	edx, DWORD PTR __Next$276011[ebp]
	cmp	edx, DWORD PTR $T275981[ebp+8]
	je	SHORT $LN20@Buffered_r
	jmp	SHORT $LN21@Buffered_r
$LN20@Buffered_r:
	mov	eax, DWORD PTR $T275981[ebp]
	mov	DWORD PTR $T276008[ebp], eax
	mov	ecx, DWORD PTR $T276008[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Buffered_r:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T276059[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T276058[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T276044[ebp], cl
	mov	dl, BYTE PTR __Cat$276048[ebp]
	mov	BYTE PTR $T276045[ebp], dl
	mov	al, BYTE PTR $T276044[ebp]
	mov	BYTE PTR $T276041[ebp], al
	mov	cl, BYTE PTR $T276046[ebp]
	mov	BYTE PTR $T276040[ebp], cl
	mov	edx, DWORD PTR $T276059[ebp]
	mov	DWORD PTR $T276039[ebp], edx
	mov	eax, DWORD PTR $T276058[ebp]
	mov	DWORD PTR $T276038[ebp], eax
	jmp	SHORT $LN38@Buffered_r
$LN37@Buffered_r:
	mov	ecx, DWORD PTR $T276039[ebp]
	add	ecx, 8
	mov	DWORD PTR $T276039[ebp], ecx
	mov	edx, DWORD PTR $T276038[ebp]
	add	edx, 8
	mov	DWORD PTR $T276038[ebp], edx
$LN38@Buffered_r:
	mov	eax, DWORD PTR $T276038[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN30@Buffered_r
	mov	ecx, DWORD PTR $T276038[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T276039[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN37@Buffered_r
$LN30@Buffered_r:

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T276063[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T276067[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T276106[ebp], edx
	mov	eax, DWORD PTR $T276067[ebp]
	mov	DWORD PTR $T276105[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T276092[ebp], cl
	mov	dl, BYTE PTR __Cat$276096[ebp]
	mov	BYTE PTR $T276093[ebp], dl
	mov	al, BYTE PTR $T276092[ebp]
	mov	BYTE PTR $T276089[ebp], al
	mov	cl, BYTE PTR $T276094[ebp]
	mov	BYTE PTR $T276088[ebp], cl
	mov	edx, DWORD PTR $T276106[ebp]
	mov	DWORD PTR $T276087[ebp], edx
	mov	eax, DWORD PTR $T276063[ebp]
	mov	DWORD PTR $T276086[ebp], eax
	mov	ecx, DWORD PTR $T276105[ebp]
	mov	DWORD PTR $T276085[ebp], ecx
$LN52@Buffered_r:
	mov	edx, DWORD PTR $T276085[ebp]
	cmp	edx, DWORD PTR $T276086[ebp]
	je	SHORT $LN45@Buffered_r
	mov	eax, DWORD PTR $T276086[ebp]
	sub	eax, 8
	mov	DWORD PTR $T276086[ebp], eax
	mov	ecx, DWORD PTR $T276087[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T276087[ebp], ecx
	mov	edx, DWORD PTR $T276086[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T276087[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN52@Buffered_r
$LN45@Buffered_r:
	mov	eax, DWORD PTR $T276087[ebp]
	jmp	$LN5@Buffered_r
	jmp	$LN5@Buffered_r
$LN4@Buffered_r:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandMove>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN2@Buffered_r

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T275982[ebp], esp
	mov	DWORD PTR $T276119[ebp], edx
	mov	eax, DWORD PTR $T276119[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T276119[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T276119[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T276119[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T276119[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T276119[ebp]
	mov	DWORD PTR tv177[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T275983[ebp]
	push	ecx
	call	??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z ; stdext::unchecked_copy<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv178[ebp], eax
	cmp	DWORD PTR $T275983[ebp], 0
	je	SHORT $LN68@Buffered_r
	mov	edx, DWORD PTR $T275983[ebp]
	mov	DWORD PTR __Next$276130[ebp], edx
	jmp	SHORT $LN66@Buffered_r
$LN65@Buffered_r:
	mov	eax, DWORD PTR __Next$276130[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$276130[ebp], eax
$LN66@Buffered_r:
	mov	ecx, DWORD PTR __Next$276130[ebp]
	cmp	ecx, DWORD PTR $T275983[ebp+8]
	je	SHORT $LN64@Buffered_r
	jmp	SHORT $LN65@Buffered_r
$LN64@Buffered_r:
	mov	edx, DWORD PTR $T275983[ebp]
	mov	DWORD PTR $T276127[ebp], edx
	mov	eax, DWORD PTR $T276127[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN68@Buffered_r:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T276177[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T276176[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T276163[ebp], al
	mov	cl, BYTE PTR __Cat$276167[ebp]
	mov	BYTE PTR $T276164[ebp], cl
	mov	dl, BYTE PTR $T276163[ebp]
	mov	BYTE PTR $T276160[ebp], dl
	mov	al, BYTE PTR $T276165[ebp]
	mov	BYTE PTR $T276159[ebp], al
	mov	ecx, DWORD PTR $T276177[ebp]
	mov	DWORD PTR $T276158[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T276157[ebp], edx
	mov	eax, DWORD PTR $T276176[ebp]
	mov	DWORD PTR $T276156[ebp], eax
$LN81@Buffered_r:
	mov	ecx, DWORD PTR $T276156[ebp]
	cmp	ecx, DWORD PTR $T276157[ebp]
	je	SHORT $LN74@Buffered_r
	mov	edx, DWORD PTR $T276157[ebp]
	sub	edx, 8
	mov	DWORD PTR $T276157[ebp], edx
	mov	eax, DWORD PTR $T276158[ebp]
	sub	eax, 8
	mov	DWORD PTR $T276158[ebp], eax
	mov	ecx, DWORD PTR $T276157[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T276158[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN81@Buffered_r
$LN74@Buffered_r:

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T276181[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T276185[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T276225[ebp], edx
	mov	eax, DWORD PTR $T276185[ebp]
	mov	DWORD PTR $T276224[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T276210[ebp], cl
	mov	dl, BYTE PTR __Cat$276214[ebp]
	mov	BYTE PTR $T276211[ebp], dl
	mov	al, BYTE PTR $T276210[ebp]
	mov	BYTE PTR $T276207[ebp], al
	mov	cl, BYTE PTR $T276212[ebp]
	mov	BYTE PTR $T276206[ebp], cl
	mov	edx, DWORD PTR $T276225[ebp]
	mov	DWORD PTR $T276205[ebp], edx
	mov	eax, DWORD PTR $T276224[ebp]
	mov	DWORD PTR $T276204[ebp], eax
	jmp	SHORT $LN96@Buffered_r
$LN95@Buffered_r:
	mov	ecx, DWORD PTR $T276205[ebp]
	add	ecx, 8
	mov	DWORD PTR $T276205[ebp], ecx
	mov	edx, DWORD PTR $T276204[ebp]
	add	edx, 8
	mov	DWORD PTR $T276204[ebp], edx
$LN96@Buffered_r:
	mov	eax, DWORD PTR $T276204[ebp]
	cmp	eax, DWORD PTR $T276181[ebp]
	je	SHORT $LN88@Buffered_r
	mov	ecx, DWORD PTR $T276204[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T276205[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN95@Buffered_r
$LN88@Buffered_r:
	mov	eax, DWORD PTR $T276205[ebp]
	jmp	SHORT $LN5@Buffered_r

; 2696 : 		}
; 2697 : 	else

	jmp	SHORT $LN5@Buffered_r
$LN2@Buffered_r:

; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T276260[ebp], edx
	mov	eax, DWORD PTR $T276260[ebp]
	cmp	eax, DWORD PTR __Mid$[ebp]
	je	SHORT $LN112@Buffered_r
	mov	ecx, DWORD PTR __Mid$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN112@Buffered_r
	mov	dl, BYTE PTR $T276250[ebp]
	mov	BYTE PTR $T276246[ebp], dl
	mov	eax, DWORD PTR $T276260[ebp]
	mov	DWORD PTR $T276245[ebp], eax
	push	0
	push	0
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR $T276245[ebp]
	push	eax
	call	??$_Rotate@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00PAH0@Z ; std::_Rotate<CvHomelandMove *,int,CvHomelandMove>
	add	esp, 20					; 00000014H

; 2700 : 		std::advance(_First, _Count2);

$LN112@Buffered_r:
	mov	ecx, DWORD PTR __Count2$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __First$[ebp], eax

; 2701 : 		return (_First);

	mov	eax, DWORD PTR __First$[ebp]
$LN5@Buffered_r:

; 2702 : 		}
; 2703 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_rotate@PAVCvHomelandMove@@HV1@@std@@YAPAVCvHomelandMove@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ENDP ; std::_Buffered_rotate<CvHomelandMove *,int,CvHomelandMove>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAVCvHomelandTarget@@@Z
_TEXT	SEGMENT
$T276490 = -88						; size = 4
$T276478 = -84						; size = 4
$T276453 = -80						; size = 4
$T276452 = -76						; size = 4
$T276451 = -72						; size = 4
$T276415 = -66						; size = 1
$T276414 = -65						; size = 1
$T276413 = -64						; size = 4
$T276412 = -60						; size = 4
$T276411 = -56						; size = 4
$T276370 = -52						; size = 4
__Cat$276422 = -44					; size = 1
$T276420 = -43						; size = 1
$T276419 = -42						; size = 1
$T276418 = -41						; size = 1
$T276321 = -40						; size = 4
$T276280 = -36						; size = 4
__First1$233739 = -32					; size = 4
__Val$233728 = -28					; size = 20
__Next1$233727 = -8					; size = 4
__Next$233723 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAVCvHomelandTarget@@@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN9@Insertion_@5

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$233723[ebp], ecx
$LN7@Insertion_@5:
	mov	edx, DWORD PTR __Next$233723[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __Next$233723[ebp], edx
	mov	eax, DWORD PTR __Next$233723[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN9@Insertion_@5

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$233723[ebp]
	mov	DWORD PTR __Next1$233727[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$233723[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Val$233728[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Val$233728[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Val$233728[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR __Val$233728[ebp+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR __Val$233728[ebp+16], edx

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T276321[ebp], eax
	mov	ecx, DWORD PTR $T276321[ebp]
	mov	edx, DWORD PTR __Val$233728[ebp+16]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+16]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@Insertion_@5

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	edx, DWORD PTR __Next1$233727[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __Next1$233727[ebp], edx
	mov	eax, DWORD PTR __Next1$233727[ebp]
	mov	DWORD PTR $T276453[ebp], eax
	mov	ecx, DWORD PTR __Next$233723[ebp]
	mov	DWORD PTR $T276452[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T276451[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T276418[ebp], al
	mov	cl, BYTE PTR __Cat$276422[ebp]
	mov	BYTE PTR $T276419[ebp], cl
	mov	dl, BYTE PTR $T276418[ebp]
	mov	BYTE PTR $T276415[ebp], dl
	mov	al, BYTE PTR $T276420[ebp]
	mov	BYTE PTR $T276414[ebp], al
	mov	ecx, DWORD PTR $T276453[ebp]
	mov	DWORD PTR $T276413[ebp], ecx
	mov	edx, DWORD PTR $T276452[ebp]
	mov	DWORD PTR $T276412[ebp], edx
	mov	eax, DWORD PTR $T276451[ebp]
	mov	DWORD PTR $T276411[ebp], eax
$LN47@Insertion_@5:
	mov	ecx, DWORD PTR $T276411[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T276412[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN43@Insertion_@5
	mov	edx, DWORD PTR $T276412[ebp]
	sub	edx, 20					; 00000014H
	mov	DWORD PTR $T276412[ebp], edx
	mov	eax, DWORD PTR $T276412[ebp]
	mov	DWORD PTR $T276370[ebp], eax
	mov	ecx, DWORD PTR $T276413[ebp]
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR $T276413[ebp], ecx
	mov	edx, DWORD PTR $T276370[ebp]
	mov	eax, DWORD PTR $T276413[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	jmp	SHORT $LN47@Insertion_@5
$LN43@Insertion_@5:
	mov	eax, DWORD PTR $T276413[ebp]
	mov	DWORD PTR $T276280[ebp], eax

; 2977 : 				*_First = _Val;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Val$233728[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Val$233728[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Val$233728[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Val$233728[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR __Val$233728[ebp+16]
	mov	DWORD PTR [ecx+16], edx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@5
$LN5@Insertion_@5:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	eax, DWORD PTR __Next1$233727[ebp]
	mov	DWORD PTR __First1$233739[ebp], eax

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_@5
$LN2@Insertion_@5:
	mov	ecx, DWORD PTR __First1$233739[ebp]
	mov	DWORD PTR __Next1$233727[ebp], ecx
$LN3@Insertion_@5:
	mov	edx, DWORD PTR __First1$233739[ebp]
	sub	edx, 20					; 00000014H
	mov	DWORD PTR __First1$233739[ebp], edx
	mov	eax, DWORD PTR __First1$233739[ebp]
	mov	DWORD PTR $T276478[ebp], eax
	mov	ecx, DWORD PTR $T276478[ebp]
	mov	edx, DWORD PTR __Val$233728[ebp+16]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+16]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN89@Insertion_@5

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	edx, DWORD PTR __First1$233739[ebp]
	mov	DWORD PTR $T276490[ebp], edx
	mov	eax, DWORD PTR $T276490[ebp]
	mov	ecx, DWORD PTR __Next1$233727[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN2@Insertion_@5

; 2985 : 				*_Next1 = _Val;	// insert element in hole

$LN89@Insertion_@5:
	mov	ecx, DWORD PTR __Next1$233727[ebp]
	mov	edx, DWORD PTR __Val$233728[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Val$233728[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Val$233728[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Val$233728[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR __Val$233728[ebp+16]
	mov	DWORD PTR [ecx+16], edx
$LN4@Insertion_@5:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_@5
$LN9@Insertion_@5:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAVCvHomelandTarget@@@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V?$_Temp_iterator@VCvHomelandTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,int>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@0V?$_Temp_iterator@VCvHomelandTarget@@@2@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@0V?$_Temp_iterator@VCvHomelandTarget@@@2@HH@Z$0
__ehfuncinfo$??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@0V?$_Temp_iterator@VCvHomelandTarget@@@2@HH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@0V?$_Temp_iterator@VCvHomelandTarget@@@2@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@0V?$_Temp_iterator@VCvHomelandTarget@@@2@HH@Z
_TEXT	SEGMENT
tv92 = -160						; size = 4
$T276702 = -156						; size = 4
__Next$276705 = -152					; size = 4
$T276521 = -24						; size = 4
$T276510 = -20						; size = 4
$T276509 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@0V?$_Temp_iterator@VCvHomelandTarget@@@2@HH@Z PROC ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,int>, COMDAT

; 5252 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@0V?$_Temp_iterator@VCvHomelandTarget@@@2@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T276509[ebp], al
	movzx	ecx, BYTE PTR $T276509[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Chunk$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T276510[ebp], esp
	mov	DWORD PTR $T276521[ebp], ecx
	mov	edx, DWORD PTR $T276521[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T276521[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T276521[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T276521[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T276521[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T276521[ebp]
	mov	DWORD PTR tv92[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V?$_Temp_iterator@VCvHomelandTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,int>
	add	esp, 40					; 00000028H

; 5254 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN1@Unchecked_@4
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$276705[ebp], edx
	jmp	SHORT $LN85@Unchecked_@4
$LN84@Unchecked_@4:
	mov	eax, DWORD PTR __Next$276705[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __Next$276705[ebp], eax
$LN85@Unchecked_@4:
	mov	ecx, DWORD PTR __Next$276705[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN83@Unchecked_@4
	jmp	SHORT $LN84@Unchecked_@4
$LN83@Unchecked_@4:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T276702[ebp], edx
	mov	eax, DWORD PTR $T276702[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Unchecked_@4:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@0V?$_Temp_iterator@VCvHomelandTarget@@@2@HH@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandTarget>::~_Temp_iterator<CvHomelandTarget>
__ehhandler$??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@0V?$_Temp_iterator@VCvHomelandTarget@@@2@HH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-152]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@0V?$_Temp_iterator@VCvHomelandTarget@@@2@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@0V?$_Temp_iterator@VCvHomelandTarget@@@2@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,int>
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,std::forward_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z$0
__ehfuncinfo$??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z
_TEXT	SEGMENT
tv135 = -48						; size = 4
tv134 = -44						; size = 4
$T276755 = -40						; size = 4
__Next$276758 = -36					; size = 4
$T276747 = -32						; size = 4
__Cat$276734 = -25					; size = 1
$T276729 = -24						; size = 4
$T276725 = -20						; size = 4
$T276724 = -15						; size = 1
$T276723 = -14						; size = 1
$T276722 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z PROC ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T276729[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T276722[ebp], al
	mov	cl, BYTE PTR __Cat$276734[ebp]
	mov	BYTE PTR $T276723[ebp], cl
	movzx	edx, BYTE PTR $T276722[ebp]
	push	edx
	movzx	eax, BYTE PTR $T276723[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T276724[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T276725[ebp], esp
	mov	DWORD PTR $T276747[ebp], edx
	mov	eax, DWORD PTR $T276747[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T276747[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T276747[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T276747[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T276747[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T276747[ebp]
	mov	DWORD PTR tv134[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,std::forward_iterator_tag>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv135[ebp], eax
	mov	ecx, DWORD PTR $T276729[ebp]
	or	ecx, 1
	mov	DWORD PTR $T276729[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN19@unchecked_@6
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$276758[ebp], edx
	jmp	SHORT $LN17@unchecked_@6
$LN16@unchecked_@6:
	mov	eax, DWORD PTR __Next$276758[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __Next$276758[ebp], eax
$LN17@unchecked_@6:
	mov	ecx, DWORD PTR __Next$276758[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN15@unchecked_@6
	jmp	SHORT $LN16@unchecked_@6
$LN15@unchecked_@6:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T276755[ebp], edx
	mov	eax, DWORD PTR $T276755[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@unchecked_@6:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3607 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandTarget>::~_Temp_iterator<CvHomelandTarget>
__ehhandler$??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z ENDP ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
PUBLIC	??$_Rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00PAHPAVCvHomelandTarget@@@Z ; std::_Rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
PUBLIC	??$_Copy_backward_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z
_TEXT	SEGMENT
tv180 = -256						; size = 4
tv179 = -252						; size = 4
tv176 = -248						; size = 4
tv175 = -244						; size = 4
$T277120 = -236						; size = 4
$T277119 = -232						; size = 4
$T277118 = -228						; size = 4
$T277096 = -221						; size = 1
$T277095 = -220						; size = 4
$T277094 = -216						; size = 4
$T277093 = -212						; size = 4
$T277098 = -205						; size = 1
$T277057 = -204						; size = 4
$T277056 = -200						; size = 4
$T277031 = -194						; size = 1
$T277030 = -193						; size = 1
$T277029 = -192						; size = 4
$T277028 = -188						; size = 4
__Cat$277037 = -180					; size = 1
$T277035 = -179						; size = 1
$T277034 = -178						; size = 1
$T277033 = -177						; size = 1
$T276985 = -176						; size = 4
$T276981 = -172						; size = 4
$T276977 = -168						; size = 4
$T276976 = -164						; size = 4
__Cat$276970 = -156					; size = 1
$T276968 = -155						; size = 1
$T276967 = -154						; size = 1
$T276966 = -153						; size = 1
$T276941 = -152						; size = 4
__Next$276944 = -148					; size = 4
$T276933 = -144						; size = 4
$T276920 = -132						; size = 4
$T276919 = -128						; size = 4
$T276895 = -122						; size = 1
$T276894 = -121						; size = 1
$T276893 = -120						; size = 4
$T276892 = -116						; size = 4
$T276891 = -112						; size = 4
__Cat$276902 = -104					; size = 1
$T276899 = -103						; size = 1
$T276898 = -102						; size = 1
$T276897 = -101						; size = 1
$T276849 = -100						; size = 4
$T276845 = -96						; size = 4
$T276841 = -92						; size = 4
$T276840 = -88						; size = 4
__Cat$276834 = -80					; size = 1
$T276832 = -79						; size = 1
$T276831 = -78						; size = 1
$T276830 = -77						; size = 1
$T276805 = -76						; size = 4
__Next$276808 = -72					; size = 4
$T276797 = -68						; size = 4
$T276780 = -56						; size = 4
$T276779 = -52						; size = 20
$T276778 = -32						; size = 4
$T276777 = -28						; size = 4
$T276776 = -24						; size = 20
$T276775 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Mid$ = 16						; size = 4
__Last$ = 20						; size = 4
__Count1$ = 24						; size = 4
__Count2$ = 28						; size = 4
__Tempbuf$ = 32						; size = 4
??$_Buffered_rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z PROC ; std::_Buffered_rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	eax, DWORD PTR __Count1$[ebp]
	cmp	eax, DWORD PTR __Count2$[ebp]
	jg	$LN4@Buffered_r@2
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandTarget>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN4@Buffered_r@2

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T276775[ebp], esp
	mov	DWORD PTR $T276797[ebp], eax
	mov	ecx, DWORD PTR $T276797[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T276797[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T276797[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T276797[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T276797[ebp]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T276797[ebp]
	mov	DWORD PTR tv175[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T276776[ebp]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv176[ebp], eax
	cmp	DWORD PTR $T276776[ebp], 0
	je	SHORT $LN24@Buffered_r@2
	mov	eax, DWORD PTR $T276776[ebp]
	mov	DWORD PTR __Next$276808[ebp], eax
	jmp	SHORT $LN22@Buffered_r@2
$LN21@Buffered_r@2:
	mov	ecx, DWORD PTR __Next$276808[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR __Next$276808[ebp], ecx
$LN22@Buffered_r@2:
	mov	edx, DWORD PTR __Next$276808[ebp]
	cmp	edx, DWORD PTR $T276776[ebp+8]
	je	SHORT $LN20@Buffered_r@2
	jmp	SHORT $LN21@Buffered_r@2
$LN20@Buffered_r@2:
	mov	eax, DWORD PTR $T276776[ebp]
	mov	DWORD PTR $T276805[ebp], eax
	mov	ecx, DWORD PTR $T276805[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Buffered_r@2:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T276841[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T276840[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T276830[ebp], cl
	mov	dl, BYTE PTR __Cat$276834[ebp]
	mov	BYTE PTR $T276831[ebp], dl
	movzx	eax, BYTE PTR $T276830[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T276831[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T276832[ebp]
	push	edx
	mov	eax, DWORD PTR $T276841[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T276840[ebp]
	push	edx
	lea	eax, DWORD PTR $T276777[ebp]
	push	eax
	call	??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T276845[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T276849[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T276920[ebp], ecx
	mov	edx, DWORD PTR $T276849[ebp]
	mov	DWORD PTR $T276919[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T276897[ebp], al
	mov	cl, BYTE PTR __Cat$276902[ebp]
	mov	BYTE PTR $T276898[ebp], cl
	mov	dl, BYTE PTR $T276897[ebp]
	mov	BYTE PTR $T276895[ebp], dl
	mov	al, BYTE PTR $T276899[ebp]
	mov	BYTE PTR $T276894[ebp], al
	mov	ecx, DWORD PTR $T276920[ebp]
	mov	DWORD PTR $T276893[ebp], ecx
	mov	edx, DWORD PTR $T276845[ebp]
	mov	DWORD PTR $T276892[ebp], edx
	mov	eax, DWORD PTR $T276919[ebp]
	mov	DWORD PTR $T276891[ebp], eax
$LN47@Buffered_r@2:
	mov	ecx, DWORD PTR $T276891[ebp]
	cmp	ecx, DWORD PTR $T276892[ebp]
	je	SHORT $LN46@Buffered_r@2
	mov	edx, DWORD PTR $T276892[ebp]
	sub	edx, 20					; 00000014H
	mov	DWORD PTR $T276892[ebp], edx
	mov	eax, DWORD PTR $T276893[ebp]
	sub	eax, 20					; 00000014H
	mov	DWORD PTR $T276893[ebp], eax
	mov	ecx, DWORD PTR $T276892[ebp]
	mov	edx, DWORD PTR $T276893[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	jmp	SHORT $LN47@Buffered_r@2
$LN46@Buffered_r@2:
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR $T276893[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN5@Buffered_r@2
	jmp	$LN5@Buffered_r@2
$LN4@Buffered_r@2:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandTarget>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN2@Buffered_r@2

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T276778[ebp], esp
	mov	DWORD PTR $T276933[ebp], eax
	mov	ecx, DWORD PTR $T276933[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T276933[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T276933[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T276933[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T276933[ebp]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T276933[ebp]
	mov	DWORD PTR tv179[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T276779[ebp]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv180[ebp], eax
	cmp	DWORD PTR $T276779[ebp], 0
	je	SHORT $LN71@Buffered_r@2
	mov	eax, DWORD PTR $T276779[ebp]
	mov	DWORD PTR __Next$276944[ebp], eax
	jmp	SHORT $LN69@Buffered_r@2
$LN68@Buffered_r@2:
	mov	ecx, DWORD PTR __Next$276944[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR __Next$276944[ebp], ecx
$LN69@Buffered_r@2:
	mov	edx, DWORD PTR __Next$276944[ebp]
	cmp	edx, DWORD PTR $T276779[ebp+8]
	je	SHORT $LN67@Buffered_r@2
	jmp	SHORT $LN68@Buffered_r@2
$LN67@Buffered_r@2:
	mov	eax, DWORD PTR $T276779[ebp]
	mov	DWORD PTR $T276941[ebp], eax
	mov	ecx, DWORD PTR $T276941[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN71@Buffered_r@2:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T276977[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T276976[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T276966[ebp], cl
	mov	dl, BYTE PTR __Cat$276970[ebp]
	mov	BYTE PTR $T276967[ebp], dl
	movzx	eax, BYTE PTR $T276966[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T276967[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T276968[ebp]
	push	edx
	mov	eax, DWORD PTR $T276977[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T276976[ebp]
	push	edx
	lea	eax, DWORD PTR $T276780[ebp]
	push	eax
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T276981[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T276985[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T277057[ebp], ecx
	mov	edx, DWORD PTR $T276985[ebp]
	mov	DWORD PTR $T277056[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T277033[ebp], al
	mov	cl, BYTE PTR __Cat$277037[ebp]
	mov	BYTE PTR $T277034[ebp], cl
	mov	dl, BYTE PTR $T277033[ebp]
	mov	BYTE PTR $T277031[ebp], dl
	mov	al, BYTE PTR $T277035[ebp]
	mov	BYTE PTR $T277030[ebp], al
	mov	ecx, DWORD PTR $T277057[ebp]
	mov	DWORD PTR $T277029[ebp], ecx
	mov	edx, DWORD PTR $T277056[ebp]
	mov	DWORD PTR $T277028[ebp], edx
	jmp	SHORT $LN95@Buffered_r@2
$LN94@Buffered_r@2:
	mov	eax, DWORD PTR $T277029[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T277029[ebp], eax
	mov	ecx, DWORD PTR $T277028[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T277028[ebp], ecx
$LN95@Buffered_r@2:
	mov	edx, DWORD PTR $T277028[ebp]
	cmp	edx, DWORD PTR $T276981[ebp]
	je	SHORT $LN93@Buffered_r@2
	mov	eax, DWORD PTR $T277028[ebp]
	mov	ecx, DWORD PTR $T277029[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN94@Buffered_r@2
$LN93@Buffered_r@2:
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T277029[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN5@Buffered_r@2

; 2696 : 		}
; 2697 : 	else

	jmp	$LN5@Buffered_r@2
$LN2@Buffered_r@2:

; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T277120[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T277119[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T277118[ebp], edx
	mov	eax, DWORD PTR $T277118[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T277119[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN127@Buffered_r@2
	mov	ecx, DWORD PTR $T277119[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T277120[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN127@Buffered_r@2
	mov	dl, BYTE PTR $T277098[ebp]
	mov	BYTE PTR $T277096[ebp], dl
	mov	eax, DWORD PTR $T277120[ebp]
	mov	DWORD PTR $T277095[ebp], eax
	mov	ecx, DWORD PTR $T277119[ebp]
	mov	DWORD PTR $T277094[ebp], ecx
	mov	edx, DWORD PTR $T277118[ebp]
	mov	DWORD PTR $T277093[ebp], edx
	push	0
	push	0
	mov	eax, DWORD PTR $T277095[ebp]
	push	eax
	mov	ecx, DWORD PTR $T277094[ebp]
	push	ecx
	mov	edx, DWORD PTR $T277093[ebp]
	push	edx
	call	??$_Rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00PAHPAVCvHomelandTarget@@@Z ; std::_Rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
	add	esp, 20					; 00000014H

; 2700 : 		std::advance(_First, _Count2);

$LN127@Buffered_r@2:
	mov	eax, DWORD PTR __Count2$[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 2701 : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@Buffered_r@2:

; 2702 : 		}
; 2703 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ENDP ; std::_Buffered_rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAVCvHomelandUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z0@Z
_TEXT	SEGMENT
$T277194 = -60						; size = 4
$T277193 = -56						; size = 4
$T277177 = -50						; size = 1
$T277176 = -49						; size = 1
$T277175 = -48						; size = 4
$T277174 = -44						; size = 4
$T277173 = -40						; size = 4
__Cat$277183 = -32					; size = 1
$T277181 = -31						; size = 1
$T277180 = -30						; size = 1
$T277179 = -29						; size = 1
__First1$234069 = -28					; size = 4
__Val$234059 = -24					; size = 16
__Next1$234058 = -8					; size = 4
__Next$234054 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Insertion_sort1@PAVCvHomelandUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z0@Z PROC ; std::_Insertion_sort1<CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),CvHomelandUnit>, COMDAT

; 3123 : 	{	// insertion sort [_First, _Last), using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 3124 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_@6

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$234054[ebp], ecx
$LN7@Insertion_@6:
	mov	edx, DWORD PTR __Next$234054[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Next$234054[ebp], edx
	mov	eax, DWORD PTR __Next$234054[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_@6

; 3126 : 			{	// order next element
; 3127 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$234054[ebp]
	mov	DWORD PTR __Next1$234058[ebp], ecx

; 3128 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$234054[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Val$234059[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Val$234059[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Val$234059[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR __Val$234059[ebp+12], ecx

; 3129 : 
; 3130 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

	mov	edx, DWORD PTR __First$[ebp]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	ecx, DWORD PTR __Val$234059[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$234059[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Val$234059[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Val$234059[ebp+12]
	mov	DWORD PTR [eax+12], edx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 32					; 00000020H
	movzx	eax, al
	test	eax, eax
	je	$LN5@Insertion_@6

; 3131 : 				{	// found new earliest element, move to front
; 3132 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	ecx, DWORD PTR __Next1$234058[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Next1$234058[ebp], ecx
	mov	edx, DWORD PTR __Next1$234058[ebp]
	mov	DWORD PTR $T277194[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T277193[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T277179[ebp], cl
	mov	dl, BYTE PTR __Cat$277183[ebp]
	mov	BYTE PTR $T277180[ebp], dl
	mov	al, BYTE PTR $T277179[ebp]
	mov	BYTE PTR $T277177[ebp], al
	mov	cl, BYTE PTR $T277181[ebp]
	mov	BYTE PTR $T277176[ebp], cl
	mov	edx, DWORD PTR $T277194[ebp]
	mov	DWORD PTR $T277175[ebp], edx
	mov	eax, DWORD PTR __Next$234054[ebp]
	mov	DWORD PTR $T277174[ebp], eax
	mov	ecx, DWORD PTR $T277193[ebp]
	mov	DWORD PTR $T277173[ebp], ecx
$LN18@Insertion_@6:
	mov	edx, DWORD PTR $T277173[ebp]
	cmp	edx, DWORD PTR $T277174[ebp]
	je	SHORT $LN11@Insertion_@6
	mov	eax, DWORD PTR $T277174[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR $T277174[ebp], eax
	mov	ecx, DWORD PTR $T277175[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR $T277175[ebp], ecx
	mov	edx, DWORD PTR $T277174[ebp]
	mov	eax, DWORD PTR $T277175[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	jmp	SHORT $LN18@Insertion_@6
$LN11@Insertion_@6:

; 3133 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$234059[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$234059[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Val$234059[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Val$234059[ebp+12]
	mov	DWORD PTR [eax+12], edx

; 3134 : 				}
; 3135 : 			else

	jmp	$LN4@Insertion_@6
$LN5@Insertion_@6:

; 3136 : 				{	// look for insertion point after first
; 3137 : 				for (_BidIt _First1 = _Next1;

	mov	eax, DWORD PTR __Next1$234058[ebp]
	mov	DWORD PTR __First1$234069[ebp], eax

; 3138 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3139 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_@6
$LN2@Insertion_@6:
	mov	ecx, DWORD PTR __First1$234069[ebp]
	mov	DWORD PTR __Next1$234058[ebp], ecx
$LN3@Insertion_@6:
	mov	edx, DWORD PTR __First1$234069[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR __First1$234069[ebp], edx
	mov	eax, DWORD PTR __First1$234069[ebp]
	sub	esp, 16					; 00000010H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	sub	esp, 16					; 00000010H
	mov	ecx, esp
	mov	edx, DWORD PTR __Val$234059[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Val$234059[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Val$234059[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Val$234059[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	call	DWORD PTR __Pred$[ebp]
	add	esp, 32					; 00000020H
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Insertion_@6

; 3140 : 					*_Next1 = *_First1;	// move hole down

	mov	edx, DWORD PTR __First1$234069[ebp]
	mov	eax, DWORD PTR __Next1$234058[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	jmp	SHORT $LN2@Insertion_@6
$LN1@Insertion_@6:

; 3141 : 				*_Next1 = _Val;	// insert element in hole

	mov	eax, DWORD PTR __Next1$234058[ebp]
	mov	ecx, DWORD PTR __Val$234059[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$234059[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Val$234059[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Val$234059[ebp+12]
	mov	DWORD PTR [eax+12], edx
$LN4@Insertion_@6:

; 3142 : 				}
; 3143 : 			}

	jmp	$LN7@Insertion_@6
$LN9@Insertion_@6:

; 3144 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAVCvHomelandUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z0@Z ENDP ; std::_Insertion_sort1<CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),CvHomelandUnit>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z$0
__ehfuncinfo$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z
_TEXT	SEGMENT
tv94 = -160						; size = 4
$T277342 = -156						; size = 4
__Next$277345 = -152					; size = 4
$T277209 = -24						; size = 4
$T277198 = -20						; size = 4
$T277197 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 4
??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z PROC ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 5285 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T277197[ebp], al
	movzx	ecx, BYTE PTR $T277197[ebp]
	push	ecx
	mov	edx, DWORD PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Chunk$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T277198[ebp], esp
	mov	DWORD PTR $T277209[ebp], edx
	mov	eax, DWORD PTR $T277209[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T277209[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T277209[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T277209[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T277209[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T277209[ebp]
	mov	DWORD PTR tv94[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 44					; 0000002cH

; 5287 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN1@Unchecked_@5
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$277345[ebp], eax
	jmp	SHORT $LN73@Unchecked_@5
$LN72@Unchecked_@5:
	mov	ecx, DWORD PTR __Next$277345[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Next$277345[ebp], ecx
$LN73@Unchecked_@5:
	mov	edx, DWORD PTR __Next$277345[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN71@Unchecked_@5
	jmp	SHORT $LN72@Unchecked_@5
$LN71@Unchecked_@5:
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T277342[ebp], eax
	mov	ecx, DWORD PTR $T277342[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Unchecked_@5:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
__ehhandler$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-152]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z ENDP ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
PUBLIC	??$_Copy_opt@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,std::forward_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z$0
__ehfuncinfo$??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z
_TEXT	SEGMENT
tv135 = -48						; size = 4
tv134 = -44						; size = 4
$T277395 = -40						; size = 4
__Next$277398 = -36					; size = 4
$T277387 = -32						; size = 4
__Cat$277374 = -25					; size = 1
$T277369 = -24						; size = 4
$T277365 = -20						; size = 4
$T277364 = -15						; size = 1
$T277363 = -14						; size = 1
$T277362 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z PROC ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T277369[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T277362[ebp], al
	mov	cl, BYTE PTR __Cat$277374[ebp]
	mov	BYTE PTR $T277363[ebp], cl
	movzx	edx, BYTE PTR $T277362[ebp]
	push	edx
	movzx	eax, BYTE PTR $T277363[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T277364[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T277365[ebp], esp
	mov	DWORD PTR $T277387[ebp], edx
	mov	eax, DWORD PTR $T277387[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T277387[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T277387[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T277387[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T277387[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T277387[ebp]
	mov	DWORD PTR tv134[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Copy_opt@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,std::forward_iterator_tag>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv135[ebp], eax
	mov	ecx, DWORD PTR $T277369[ebp]
	or	ecx, 1
	mov	DWORD PTR $T277369[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN19@unchecked_@7
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$277398[ebp], edx
	jmp	SHORT $LN17@unchecked_@7
$LN16@unchecked_@7:
	mov	eax, DWORD PTR __Next$277398[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$277398[ebp], eax
$LN17@unchecked_@7:
	mov	ecx, DWORD PTR __Next$277398[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN15@unchecked_@7
	jmp	SHORT $LN16@unchecked_@7
$LN15@unchecked_@7:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T277395[ebp], edx
	mov	eax, DWORD PTR $T277395[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@unchecked_@7:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3607 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
__ehhandler$??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ENDP ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
PUBLIC	??$_Rotate@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00PAH0@Z ; std::_Rotate<CvHomelandUnit *,int,CvHomelandUnit>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_rotate@PAVCvHomelandUnit@@HV1@@std@@YAPAVCvHomelandUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z
_TEXT	SEGMENT
tv178 = -260						; size = 4
tv177 = -256						; size = 4
tv174 = -252						; size = 4
tv173 = -248						; size = 4
$T277695 = -240						; size = 4
$T277681 = -233						; size = 1
$T277680 = -232						; size = 4
$T277685 = -225						; size = 1
$T277660 = -224						; size = 4
$T277659 = -220						; size = 4
$T277642 = -214						; size = 1
$T277641 = -213						; size = 1
$T277640 = -212						; size = 4
$T277639 = -208						; size = 4
__Cat$277650 = -200					; size = 1
$T277647 = -199						; size = 1
$T277646 = -198						; size = 1
$T277645 = -197						; size = 1
$T277620 = -196						; size = 4
$T277616 = -192						; size = 4
$T277612 = -188						; size = 4
$T277611 = -184						; size = 4
$T277595 = -178						; size = 1
$T277594 = -177						; size = 1
$T277593 = -176						; size = 4
$T277592 = -172						; size = 4
$T277591 = -168						; size = 4
__Cat$277602 = -160					; size = 1
$T277599 = -159						; size = 1
$T277598 = -158						; size = 1
$T277597 = -157						; size = 1
$T277562 = -156						; size = 4
__Next$277565 = -152					; size = 4
$T277554 = -148						; size = 4
$T277541 = -136						; size = 4
$T277540 = -132						; size = 4
$T277524 = -126						; size = 1
$T277523 = -125						; size = 1
$T277522 = -124						; size = 4
$T277521 = -120						; size = 4
$T277520 = -116						; size = 4
__Cat$277530 = -108					; size = 1
$T277527 = -107						; size = 1
$T277526 = -106						; size = 1
$T277525 = -105						; size = 1
$T277502 = -104						; size = 4
$T277498 = -100						; size = 4
$T277494 = -96						; size = 4
$T277493 = -92						; size = 4
$T277476 = -86						; size = 1
$T277475 = -85						; size = 1
$T277474 = -84						; size = 4
$T277473 = -80						; size = 4
__Cat$277483 = -72					; size = 1
$T277481 = -71						; size = 1
$T277480 = -70						; size = 1
$T277479 = -69						; size = 1
$T277443 = -68						; size = 4
__Next$277446 = -64					; size = 4
$T277435 = -60						; size = 4
$T277418 = -48						; size = 20
$T277417 = -28						; size = 4
$T277416 = -24						; size = 20
$T277415 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_rotate@PAVCvHomelandUnit@@HV1@@std@@YAPAVCvHomelandUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z PROC ; std::_Buffered_rotate<CvHomelandUnit *,int,CvHomelandUnit>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	eax, DWORD PTR __Count1$[ebp]
	cmp	eax, DWORD PTR __Count2$[ebp]
	jg	$LN4@Buffered_r@3
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN4@Buffered_r@3

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T277415[ebp], esp
	mov	DWORD PTR $T277435[ebp], eax
	mov	ecx, DWORD PTR $T277435[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T277435[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T277435[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T277435[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T277435[ebp]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T277435[ebp]
	mov	DWORD PTR tv173[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T277416[ebp]
	push	edx
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv174[ebp], eax
	cmp	DWORD PTR $T277416[ebp], 0
	je	SHORT $LN24@Buffered_r@3
	mov	eax, DWORD PTR $T277416[ebp]
	mov	DWORD PTR __Next$277446[ebp], eax
	jmp	SHORT $LN22@Buffered_r@3
$LN21@Buffered_r@3:
	mov	ecx, DWORD PTR __Next$277446[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Next$277446[ebp], ecx
$LN22@Buffered_r@3:
	mov	edx, DWORD PTR __Next$277446[ebp]
	cmp	edx, DWORD PTR $T277416[ebp+8]
	je	SHORT $LN20@Buffered_r@3
	jmp	SHORT $LN21@Buffered_r@3
$LN20@Buffered_r@3:
	mov	eax, DWORD PTR $T277416[ebp]
	mov	DWORD PTR $T277443[ebp], eax
	mov	ecx, DWORD PTR $T277443[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Buffered_r@3:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T277494[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T277493[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T277479[ebp], cl
	mov	dl, BYTE PTR __Cat$277483[ebp]
	mov	BYTE PTR $T277480[ebp], dl
	mov	al, BYTE PTR $T277479[ebp]
	mov	BYTE PTR $T277476[ebp], al
	mov	cl, BYTE PTR $T277481[ebp]
	mov	BYTE PTR $T277475[ebp], cl
	mov	edx, DWORD PTR $T277494[ebp]
	mov	DWORD PTR $T277474[ebp], edx
	mov	eax, DWORD PTR $T277493[ebp]
	mov	DWORD PTR $T277473[ebp], eax
	jmp	SHORT $LN38@Buffered_r@3
$LN37@Buffered_r@3:
	mov	ecx, DWORD PTR $T277474[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T277474[ebp], ecx
	mov	edx, DWORD PTR $T277473[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T277473[ebp], edx
$LN38@Buffered_r@3:
	mov	eax, DWORD PTR $T277473[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN30@Buffered_r@3
	mov	ecx, DWORD PTR $T277473[ebp]
	mov	edx, DWORD PTR $T277474[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	jmp	SHORT $LN37@Buffered_r@3
$LN30@Buffered_r@3:

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T277498[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T277502[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T277541[ebp], edx
	mov	eax, DWORD PTR $T277502[ebp]
	mov	DWORD PTR $T277540[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T277525[ebp], cl
	mov	dl, BYTE PTR __Cat$277530[ebp]
	mov	BYTE PTR $T277526[ebp], dl
	mov	al, BYTE PTR $T277525[ebp]
	mov	BYTE PTR $T277524[ebp], al
	mov	cl, BYTE PTR $T277527[ebp]
	mov	BYTE PTR $T277523[ebp], cl
	mov	edx, DWORD PTR $T277541[ebp]
	mov	DWORD PTR $T277522[ebp], edx
	mov	eax, DWORD PTR $T277498[ebp]
	mov	DWORD PTR $T277521[ebp], eax
	mov	ecx, DWORD PTR $T277540[ebp]
	mov	DWORD PTR $T277520[ebp], ecx
$LN52@Buffered_r@3:
	mov	edx, DWORD PTR $T277520[ebp]
	cmp	edx, DWORD PTR $T277521[ebp]
	je	SHORT $LN45@Buffered_r@3
	mov	eax, DWORD PTR $T277521[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR $T277521[ebp], eax
	mov	ecx, DWORD PTR $T277522[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR $T277522[ebp], ecx
	mov	edx, DWORD PTR $T277521[ebp]
	mov	eax, DWORD PTR $T277522[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	jmp	SHORT $LN52@Buffered_r@3
$LN45@Buffered_r@3:
	mov	eax, DWORD PTR $T277522[ebp]
	jmp	$LN5@Buffered_r@3
	jmp	$LN5@Buffered_r@3
$LN4@Buffered_r@3:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN2@Buffered_r@3

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T277417[ebp], esp
	mov	DWORD PTR $T277554[ebp], edx
	mov	eax, DWORD PTR $T277554[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T277554[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T277554[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T277554[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T277554[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T277554[ebp]
	mov	DWORD PTR tv177[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T277418[ebp]
	push	ecx
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv178[ebp], eax
	cmp	DWORD PTR $T277418[ebp], 0
	je	SHORT $LN68@Buffered_r@3
	mov	edx, DWORD PTR $T277418[ebp]
	mov	DWORD PTR __Next$277565[ebp], edx
	jmp	SHORT $LN66@Buffered_r@3
$LN65@Buffered_r@3:
	mov	eax, DWORD PTR __Next$277565[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$277565[ebp], eax
$LN66@Buffered_r@3:
	mov	ecx, DWORD PTR __Next$277565[ebp]
	cmp	ecx, DWORD PTR $T277418[ebp+8]
	je	SHORT $LN64@Buffered_r@3
	jmp	SHORT $LN65@Buffered_r@3
$LN64@Buffered_r@3:
	mov	edx, DWORD PTR $T277418[ebp]
	mov	DWORD PTR $T277562[ebp], edx
	mov	eax, DWORD PTR $T277562[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN68@Buffered_r@3:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T277612[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T277611[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T277597[ebp], al
	mov	cl, BYTE PTR __Cat$277602[ebp]
	mov	BYTE PTR $T277598[ebp], cl
	mov	dl, BYTE PTR $T277597[ebp]
	mov	BYTE PTR $T277595[ebp], dl
	mov	al, BYTE PTR $T277599[ebp]
	mov	BYTE PTR $T277594[ebp], al
	mov	ecx, DWORD PTR $T277612[ebp]
	mov	DWORD PTR $T277593[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T277592[ebp], edx
	mov	eax, DWORD PTR $T277611[ebp]
	mov	DWORD PTR $T277591[ebp], eax
$LN81@Buffered_r@3:
	mov	ecx, DWORD PTR $T277591[ebp]
	cmp	ecx, DWORD PTR $T277592[ebp]
	je	SHORT $LN74@Buffered_r@3
	mov	edx, DWORD PTR $T277592[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR $T277592[ebp], edx
	mov	eax, DWORD PTR $T277593[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR $T277593[ebp], eax
	mov	ecx, DWORD PTR $T277592[ebp]
	mov	edx, DWORD PTR $T277593[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	jmp	SHORT $LN81@Buffered_r@3
$LN74@Buffered_r@3:

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T277616[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T277620[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T277660[ebp], edx
	mov	eax, DWORD PTR $T277620[ebp]
	mov	DWORD PTR $T277659[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T277645[ebp], cl
	mov	dl, BYTE PTR __Cat$277650[ebp]
	mov	BYTE PTR $T277646[ebp], dl
	mov	al, BYTE PTR $T277645[ebp]
	mov	BYTE PTR $T277642[ebp], al
	mov	cl, BYTE PTR $T277647[ebp]
	mov	BYTE PTR $T277641[ebp], cl
	mov	edx, DWORD PTR $T277660[ebp]
	mov	DWORD PTR $T277640[ebp], edx
	mov	eax, DWORD PTR $T277659[ebp]
	mov	DWORD PTR $T277639[ebp], eax
	jmp	SHORT $LN96@Buffered_r@3
$LN95@Buffered_r@3:
	mov	ecx, DWORD PTR $T277640[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T277640[ebp], ecx
	mov	edx, DWORD PTR $T277639[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T277639[ebp], edx
$LN96@Buffered_r@3:
	mov	eax, DWORD PTR $T277639[ebp]
	cmp	eax, DWORD PTR $T277616[ebp]
	je	SHORT $LN88@Buffered_r@3
	mov	ecx, DWORD PTR $T277639[ebp]
	mov	edx, DWORD PTR $T277640[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	jmp	SHORT $LN95@Buffered_r@3
$LN88@Buffered_r@3:
	mov	eax, DWORD PTR $T277640[ebp]
	jmp	SHORT $LN5@Buffered_r@3

; 2696 : 		}
; 2697 : 	else

	jmp	SHORT $LN5@Buffered_r@3
$LN2@Buffered_r@3:

; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T277695[ebp], edx
	mov	eax, DWORD PTR $T277695[ebp]
	cmp	eax, DWORD PTR __Mid$[ebp]
	je	SHORT $LN112@Buffered_r@3
	mov	ecx, DWORD PTR __Mid$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN112@Buffered_r@3
	mov	dl, BYTE PTR $T277685[ebp]
	mov	BYTE PTR $T277681[ebp], dl
	mov	eax, DWORD PTR $T277695[ebp]
	mov	DWORD PTR $T277680[ebp], eax
	push	0
	push	0
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR $T277680[ebp]
	push	eax
	call	??$_Rotate@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00PAH0@Z ; std::_Rotate<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 20					; 00000014H

; 2700 : 		std::advance(_First, _Count2);

$LN112@Buffered_r@3:
	mov	ecx, DWORD PTR __Count2$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __First$[ebp], ecx

; 2701 : 		return (_First);

	mov	eax, DWORD PTR __First$[ebp]
$LN5@Buffered_r@3:

; 2702 : 		}
; 2703 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_rotate@PAVCvHomelandUnit@@HV1@@std@@YAPAVCvHomelandUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ENDP ; std::_Buffered_rotate<CvHomelandUnit *,int,CvHomelandUnit>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAVCvHomelandUnit@@V1@@std@@YAXPAVCvHomelandUnit@@00@Z
_TEXT	SEGMENT
$T277777 = -76						; size = 4
$T277773 = -72						; size = 4
$T277768 = -68						; size = 4
$T277767 = -64						; size = 4
$T277751 = -58						; size = 1
$T277750 = -57						; size = 1
$T277749 = -56						; size = 4
$T277748 = -52						; size = 4
$T277747 = -48						; size = 4
__Cat$277758 = -40					; size = 1
$T277755 = -39						; size = 1
$T277754 = -38						; size = 1
$T277753 = -37						; size = 1
$T277723 = -36						; size = 4
$T277719 = -32						; size = 4
__First1$234342 = -28					; size = 4
__Val$234339 = -24					; size = 16
__Next1$234338 = -8					; size = 4
__Next$234334 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAVCvHomelandUnit@@V1@@std@@YAXPAVCvHomelandUnit@@00@Z PROC ; std::_Insertion_sort1<CvHomelandUnit *,CvHomelandUnit>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_@7

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$234334[ebp], ecx
$LN7@Insertion_@7:
	mov	edx, DWORD PTR __Next$234334[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Next$234334[ebp], edx
	mov	eax, DWORD PTR __Next$234334[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_@7

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$234334[ebp]
	mov	DWORD PTR __Next1$234338[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$234334[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Val$234339[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Val$234339[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Val$234339[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR __Val$234339[ebp+12], ecx

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	edx, DWORD PTR __Val$234339[ebp+8]
	mov	DWORD PTR $T277719[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T277723[ebp], ecx
	mov	edx, DWORD PTR $T277719[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T277723[ebp]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@Insertion_@7

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	edx, DWORD PTR __Next1$234338[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Next1$234338[ebp], edx
	mov	eax, DWORD PTR __Next1$234338[ebp]
	mov	DWORD PTR $T277768[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T277767[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T277753[ebp], dl
	mov	al, BYTE PTR __Cat$277758[ebp]
	mov	BYTE PTR $T277754[ebp], al
	mov	cl, BYTE PTR $T277753[ebp]
	mov	BYTE PTR $T277751[ebp], cl
	mov	dl, BYTE PTR $T277755[ebp]
	mov	BYTE PTR $T277750[ebp], dl
	mov	eax, DWORD PTR $T277768[ebp]
	mov	DWORD PTR $T277749[ebp], eax
	mov	ecx, DWORD PTR __Next$234334[ebp]
	mov	DWORD PTR $T277748[ebp], ecx
	mov	edx, DWORD PTR $T277767[ebp]
	mov	DWORD PTR $T277747[ebp], edx
$LN24@Insertion_@7:
	mov	eax, DWORD PTR $T277747[ebp]
	cmp	eax, DWORD PTR $T277748[ebp]
	je	SHORT $LN17@Insertion_@7
	mov	ecx, DWORD PTR $T277748[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR $T277748[ebp], ecx
	mov	edx, DWORD PTR $T277749[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR $T277749[ebp], edx
	mov	eax, DWORD PTR $T277748[ebp]
	mov	ecx, DWORD PTR $T277749[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	jmp	SHORT $LN24@Insertion_@7
$LN17@Insertion_@7:

; 2977 : 				*_First = _Val;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Val$234339[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Val$234339[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Val$234339[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Val$234339[ebp+12]
	mov	DWORD PTR [ecx+12], eax

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@7
$LN5@Insertion_@7:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	ecx, DWORD PTR __Next1$234338[ebp]
	mov	DWORD PTR __First1$234342[ebp], ecx

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_@7
$LN2@Insertion_@7:
	mov	edx, DWORD PTR __First1$234342[ebp]
	mov	DWORD PTR __Next1$234338[ebp], edx
$LN3@Insertion_@7:
	mov	eax, DWORD PTR __First1$234342[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR __First1$234342[ebp], eax
	mov	ecx, DWORD PTR __Val$234339[ebp+8]
	mov	DWORD PTR $T277773[ebp], ecx
	mov	edx, DWORD PTR __First1$234342[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T277777[ebp], eax
	mov	ecx, DWORD PTR $T277773[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T277777[ebp]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@Insertion_@7

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ecx, DWORD PTR __First1$234342[ebp]
	mov	edx, DWORD PTR __Next1$234338[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	jmp	SHORT $LN2@Insertion_@7
$LN1@Insertion_@7:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	edx, DWORD PTR __Next1$234338[ebp]
	mov	eax, DWORD PTR __Val$234339[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Val$234339[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Val$234339[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR __Val$234339[ebp+12]
	mov	DWORD PTR [edx+12], ecx
$LN4@Insertion_@7:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_@7
$LN9@Insertion_@7:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAVCvHomelandUnit@@V1@@std@@YAXPAVCvHomelandUnit@@00@Z ENDP ; std::_Insertion_sort1<CvHomelandUnit *,CvHomelandUnit>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HH@Z$0
__ehfuncinfo$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HH@Z
_TEXT	SEGMENT
tv92 = -164						; size = 4
$T277940 = -160						; size = 4
__Next$277943 = -156					; size = 4
$T277798 = -24						; size = 4
$T277787 = -20						; size = 4
$T277786 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int>, COMDAT

; 5252 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T277786[ebp], al
	movzx	ecx, BYTE PTR $T277786[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Chunk$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T277787[ebp], esp
	mov	DWORD PTR $T277798[ebp], ecx
	mov	edx, DWORD PTR $T277798[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T277798[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T277798[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T277798[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T277798[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T277798[ebp]
	mov	DWORD PTR tv92[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int>
	add	esp, 40					; 00000028H

; 5254 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN1@Unchecked_@6
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$277943[ebp], edx
	jmp	SHORT $LN77@Unchecked_@6
$LN76@Unchecked_@6:
	mov	eax, DWORD PTR __Next$277943[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$277943[ebp], eax
$LN77@Unchecked_@6:
	mov	ecx, DWORD PTR __Next$277943[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN75@Unchecked_@6
	jmp	SHORT $LN76@Unchecked_@6
$LN75@Unchecked_@6:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T277940[ebp], edx
	mov	eax, DWORD PTR $T277940[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Unchecked_@6:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HH@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
__ehhandler$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-156]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int>
; Function compile flags: /Odtp
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z
_TEXT	SEGMENT
__Tmp$278024 = -24					; size = 8
__Tmp$278002 = -16					; size = 8
__Tmp$277980 = -8					; size = 8
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>, COMDAT

; 2998 : 	{	// sort median of three elements to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@Med3@2

; 3000 : 		std::iter_swap(_Mid, _First);

	mov	edx, DWORD PTR __Mid$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN15@Med3@2
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$277980[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$277980[ebp+4], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Tmp$277980[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$277980[ebp+4]
	mov	DWORD PTR [edx+4], ecx

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

$LN15@Med3@2:
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN24@Med3@2

; 3002 : 		std::iter_swap(_Last, _Mid);

	mov	ecx, DWORD PTR __Last$[ebp]
	cmp	ecx, DWORD PTR __Mid$[ebp]
	je	SHORT $LN24@Med3@2
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$278002[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$278002[ebp+4], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __Tmp$278002[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$278002[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

$LN24@Med3@2:
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@Med3@2

; 3004 : 		std::iter_swap(_Mid, _First);

	mov	eax, DWORD PTR __Mid$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN4@Med3@2
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$278024[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$278024[ebp+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Tmp$278024[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$278024[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN4@Med3@2:

; 3005 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HHU12@@Z
_TEXT	SEGMENT
$T278049 = -32						; size = 4
$T278048 = -28						; size = 8
__Idx$278041 = -20					; size = 4
$T278035 = -16						; size = 4
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>, COMDAT

; 2055 : 	{	// percolate _Hole to _Bottom, then push _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 2056 : 	_Diff _Top = _Hole;

	mov	eax, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR __Top$[ebp], eax

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;

	mov	ecx, DWORD PTR __Hole$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	DWORD PTR __Idx$[ebp], edx

; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	jmp	SHORT $LN5@Adjust_hea@2
$LN4@Adjust_hea@2:
	mov	eax, DWORD PTR __Idx$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea@2:
	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jge	SHORT $LN3@Adjust_hea@2

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	eax, DWORD PTR __Idx$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Idx$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+edx*8-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Adjust_hea@2

; 2062 : 			--_Idx;

	mov	eax, DWORD PTR __Idx$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Idx$[ebp], eax
$LN2@Adjust_hea@2:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [edx+ecx*8+4]
	mov	edx, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+edx*8], eax
	mov	DWORD PTR [esi+edx*8+4], ecx
	mov	eax, DWORD PTR __Idx$[ebp]
	mov	DWORD PTR __Hole$[ebp], eax

; 2064 : 		}

	jmp	SHORT $LN4@Adjust_hea@2
$LN3@Adjust_hea@2:

; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	mov	ecx, DWORD PTR __Idx$[ebp]
	cmp	ecx, DWORD PTR __Bottom$[ebp]
	jne	SHORT $LN1@Adjust_hea@2

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	edx, DWORD PTR __Bottom$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8-8]
	mov	edx, DWORD PTR [eax+edx*8-4]
	mov	eax, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx

; 2069 : 		_Hole = _Bottom - 1;

	mov	ecx, DWORD PTR __Bottom$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$[ebp], ecx
$LN1@Adjust_hea@2:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	lea	edx, DWORD PTR $T278048[ebp]
	mov	DWORD PTR $T278035[ebp], edx
	mov	eax, DWORD PTR $T278035[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T278035[ebp]
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR $T278049[ebp], ecx
	mov	eax, DWORD PTR $T278049[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$278041[ebp], eax
	jmp	SHORT $LN14@Adjust_hea@2
$LN13@Adjust_hea@2:
	mov	eax, DWORD PTR $T278049[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$278041[ebp], eax
$LN14@Adjust_hea@2:
	mov	edx, DWORD PTR __Top$[ebp]
	cmp	edx, DWORD PTR $T278049[ebp]
	jge	SHORT $LN12@Adjust_hea@2
	mov	eax, DWORD PTR __Idx$278041[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	xor	eax, eax
	cmp	edx, DWORD PTR $T278048[ebp+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@Adjust_hea@2
	mov	edx, DWORD PTR __Idx$278041[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [eax+edx*8+4]
	mov	eax, DWORD PTR $T278049[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx
	mov	ecx, DWORD PTR __Idx$278041[ebp]
	mov	DWORD PTR $T278049[ebp], ecx
	jmp	SHORT $LN13@Adjust_hea@2
$LN12@Adjust_hea@2:
	mov	edx, DWORD PTR $T278049[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR $T278048[ebp]
	mov	DWORD PTR [eax+edx*8], ecx
	mov	ecx, DWORD PTR $T278048[ebp+4]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 2072 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z
_TEXT	SEGMENT
__Tmp$278114 = -24					; size = 8
__Tmp$278091 = -16					; size = 8
__Tmp$278069 = -8					; size = 8
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<CvCity *,64,1>::WeightedElement *>, COMDAT

; 2998 : 	{	// sort median of three elements to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@Med3@3

; 3000 : 		std::iter_swap(_Mid, _First);

	mov	edx, DWORD PTR __Mid$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN15@Med3@3
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$278069[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$278069[ebp+4], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Tmp$278069[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$278069[ebp+4]
	mov	DWORD PTR [edx+4], ecx

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

$LN15@Med3@3:
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN24@Med3@3

; 3002 : 		std::iter_swap(_Last, _Mid);

	mov	ecx, DWORD PTR __Last$[ebp]
	cmp	ecx, DWORD PTR __Mid$[ebp]
	je	SHORT $LN24@Med3@3
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$278091[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$278091[ebp+4], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __Tmp$278091[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$278091[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

$LN24@Med3@3:
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@Med3@3

; 3004 : 		std::iter_swap(_Mid, _First);

	mov	eax, DWORD PTR __Mid$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN4@Med3@3
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$278114[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$278114[ebp+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Tmp$278114[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$278114[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN4@Med3@3:

; 3005 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HHU12@@Z
_TEXT	SEGMENT
$T278141 = -32						; size = 4
$T278140 = -28						; size = 8
__Idx$278133 = -20					; size = 4
$T278127 = -16						; size = 4
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>, COMDAT

; 2055 : 	{	// percolate _Hole to _Bottom, then push _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 2056 : 	_Diff _Top = _Hole;

	mov	eax, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR __Top$[ebp], eax

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;

	mov	ecx, DWORD PTR __Hole$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	DWORD PTR __Idx$[ebp], edx

; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	jmp	SHORT $LN5@Adjust_hea@3
$LN4@Adjust_hea@3:
	mov	eax, DWORD PTR __Idx$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea@3:
	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jge	SHORT $LN3@Adjust_hea@3

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	eax, DWORD PTR __Idx$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Idx$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+edx*8-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Adjust_hea@3

; 2062 : 			--_Idx;

	mov	eax, DWORD PTR __Idx$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Idx$[ebp], eax
$LN2@Adjust_hea@3:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [edx+ecx*8+4]
	mov	edx, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+edx*8], eax
	mov	DWORD PTR [esi+edx*8+4], ecx
	mov	eax, DWORD PTR __Idx$[ebp]
	mov	DWORD PTR __Hole$[ebp], eax

; 2064 : 		}

	jmp	SHORT $LN4@Adjust_hea@3
$LN3@Adjust_hea@3:

; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	mov	ecx, DWORD PTR __Idx$[ebp]
	cmp	ecx, DWORD PTR __Bottom$[ebp]
	jne	SHORT $LN1@Adjust_hea@3

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	edx, DWORD PTR __Bottom$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8-8]
	mov	edx, DWORD PTR [eax+edx*8-4]
	mov	eax, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx

; 2069 : 		_Hole = _Bottom - 1;

	mov	ecx, DWORD PTR __Bottom$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$[ebp], ecx
$LN1@Adjust_hea@3:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	lea	edx, DWORD PTR $T278140[ebp]
	mov	DWORD PTR $T278127[ebp], edx
	mov	eax, DWORD PTR $T278127[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T278127[ebp]
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR $T278141[ebp], ecx
	mov	eax, DWORD PTR $T278141[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$278133[ebp], eax
	jmp	SHORT $LN14@Adjust_hea@3
$LN13@Adjust_hea@3:
	mov	eax, DWORD PTR $T278141[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$278133[ebp], eax
$LN14@Adjust_hea@3:
	mov	edx, DWORD PTR __Top$[ebp]
	cmp	edx, DWORD PTR $T278141[ebp]
	jge	SHORT $LN12@Adjust_hea@3
	mov	eax, DWORD PTR __Idx$278133[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	xor	eax, eax
	cmp	edx, DWORD PTR $T278140[ebp+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@Adjust_hea@3
	mov	edx, DWORD PTR __Idx$278133[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [eax+edx*8+4]
	mov	eax, DWORD PTR $T278141[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx
	mov	ecx, DWORD PTR __Idx$278133[ebp]
	mov	DWORD PTR $T278141[ebp], ecx
	jmp	SHORT $LN13@Adjust_hea@3
$LN12@Adjust_hea@3:
	mov	edx, DWORD PTR $T278141[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR $T278140[ebp]
	mov	DWORD PTR [eax+edx*8], ecx
	mov	ecx, DWORD PTR $T278140[ebp+4]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 2072 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@2

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@2:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@3

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@3:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@000V12@@Z ; stdext::unchecked_merge<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@std@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@0@HHU_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@std@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@0@HHU_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@std@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@0@HHU_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@std@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@0@HHU_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@std@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv183 = -180						; size = 4
tv182 = -176						; size = 4
tv179 = -172						; size = 4
tv178 = -168						; size = 4
tv174 = -164						; size = 4
tv173 = -160						; size = 4
$T278307 = -156						; size = 4
__Next$278310 = -152					; size = 4
$T278288 = -148						; size = 4
__Next$278291 = -144					; size = 4
$T278280 = -140						; size = 4
$T278243 = -132						; size = 4
__Next$278246 = -128					; size = 4
$T278235 = -124						; size = 4
$T278215 = -120						; size = 4
__Next$278218 = -116					; size = 4
$T278207 = -112						; size = 4
$T278203 = -108						; size = 4
$T278153 = -100						; size = 20
$T278152 = -80						; size = 4
$T278151 = -76						; size = 20
$T278150 = -56						; size = 4
$T278149 = -52						; size = 20
$T278148 = -32						; size = 4
__Mid$234875 = -28					; size = 4
__Mid2$234858 = -24					; size = 4
__Mid1$234857 = -20					; size = 4
__Chunk2$234853 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
___formal$ = 44						; size = 1
??$_Chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@std@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@std@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@0@HHU_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 168				; 000000a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$234853[ebp], eax
	jmp	SHORT $LN5@Chunked_me
$LN4@Chunked_me:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$234853[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me:
	mov	edx, DWORD PTR __Chunk2$234853[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	$LN3@Chunked_me

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$234857[ebp], eax

; 3292 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	mov	edx, DWORD PTR __Mid1$234857[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Mid1$234857[ebp], eax

; 3293 : 		_BidIt _Mid2 = _Mid1;

	mov	ecx, DWORD PTR __Mid1$234857[ebp]
	mov	DWORD PTR __Mid2$234858[ebp], ecx

; 3294 : 		std::advance(_Mid2, _Chunk);

	mov	edx, DWORD PTR __Chunk$[ebp]
	mov	eax, DWORD PTR __Mid2$234858[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Mid2$234858[ebp], ecx

; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T278148[ebp], esp
	mov	DWORD PTR $T278203[ebp], edx
	mov	eax, DWORD PTR $T278203[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T278203[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T278203[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T278203[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T278203[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T278203[ebp]
	mov	DWORD PTR tv173[ebp], eax
	mov	ecx, DWORD PTR __Mid2$234858[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid1$234857[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid1$234857[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T278149[ebp]
	push	edx
	call	??$unchecked_merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@000V12@@Z ; stdext::unchecked_merge<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv174[ebp], eax
	mov	eax, DWORD PTR tv174[ebp]
	mov	DWORD PTR $T278207[ebp], eax
	mov	ecx, DWORD PTR $T278207[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Dest$[ebp+16], edx
	cmp	DWORD PTR $T278149[ebp], 0
	je	SHORT $LN37@Chunked_me
	mov	eax, DWORD PTR $T278149[ebp]
	mov	DWORD PTR __Next$278218[ebp], eax
	jmp	SHORT $LN35@Chunked_me
$LN34@Chunked_me:
	mov	ecx, DWORD PTR __Next$278218[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$278218[ebp], ecx
$LN35@Chunked_me:
	mov	edx, DWORD PTR __Next$278218[ebp]
	cmp	edx, DWORD PTR $T278149[ebp+8]
	je	SHORT $LN33@Chunked_me
	jmp	SHORT $LN34@Chunked_me
$LN33@Chunked_me:
	mov	eax, DWORD PTR $T278149[ebp]
	mov	DWORD PTR $T278215[ebp], eax
	mov	ecx, DWORD PTR $T278215[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN37@Chunked_me:

; 3297 : 		_First = _Mid2;

	mov	edx, DWORD PTR __Mid2$234858[ebp]
	mov	DWORD PTR __First$[ebp], edx

; 3298 : 		}

	jmp	$LN4@Chunked_me
$LN3@Chunked_me:

; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Chunk$[ebp]
	jg	$LN2@Chunked_me

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T278150[ebp], esp
	mov	DWORD PTR $T278235[ebp], ecx
	mov	edx, DWORD PTR $T278235[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T278235[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T278235[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T278235[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T278235[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T278235[ebp]
	mov	DWORD PTR tv178[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T278151[ebp]
	push	edx
	call	??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z ; stdext::unchecked_copy<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv179[ebp], eax
	cmp	DWORD PTR $T278151[ebp], 0
	je	SHORT $LN51@Chunked_me
	mov	eax, DWORD PTR $T278151[ebp]
	mov	DWORD PTR __Next$278246[ebp], eax
	jmp	SHORT $LN49@Chunked_me
$LN48@Chunked_me:
	mov	ecx, DWORD PTR __Next$278246[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$278246[ebp], ecx
$LN49@Chunked_me:
	mov	edx, DWORD PTR __Next$278246[ebp]
	cmp	edx, DWORD PTR $T278151[ebp+8]
	je	SHORT $LN47@Chunked_me
	jmp	SHORT $LN48@Chunked_me
$LN47@Chunked_me:
	mov	eax, DWORD PTR $T278151[ebp]
	mov	DWORD PTR $T278243[ebp], eax
	mov	ecx, DWORD PTR $T278243[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN51@Chunked_me:

; 3302 : 	else

	jmp	$LN1@Chunked_me
$LN2@Chunked_me:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$234875[ebp], edx

; 3305 : 		std::advance(_Mid, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	mov	ecx, DWORD PTR __Mid$234875[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$234875[ebp], edx

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T278152[ebp], esp
	mov	DWORD PTR $T278280[ebp], eax
	mov	ecx, DWORD PTR $T278280[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T278280[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T278280[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T278280[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T278280[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T278280[ebp]
	mov	DWORD PTR tv182[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$234875[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$234875[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T278153[ebp]
	push	eax
	call	??$unchecked_merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@000V12@@Z ; stdext::unchecked_merge<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv183[ebp], eax
	cmp	DWORD PTR $T278153[ebp], 0
	je	SHORT $LN1@Chunked_me
	mov	ecx, DWORD PTR $T278153[ebp]
	mov	DWORD PTR __Next$278291[ebp], ecx
	jmp	SHORT $LN69@Chunked_me
$LN68@Chunked_me:
	mov	edx, DWORD PTR __Next$278291[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$278291[ebp], edx
$LN69@Chunked_me:
	mov	eax, DWORD PTR __Next$278291[ebp]
	cmp	eax, DWORD PTR $T278153[ebp+8]
	je	SHORT $LN67@Chunked_me
	jmp	SHORT $LN68@Chunked_me
$LN67@Chunked_me:
	mov	ecx, DWORD PTR $T278153[ebp]
	mov	DWORD PTR $T278288[ebp], ecx
	mov	edx, DWORD PTR $T278288[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Chunked_me:

; 3308 : 		}
; 3309 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN6@Chunked_me
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$278310[ebp], eax
	jmp	SHORT $LN79@Chunked_me
$LN78@Chunked_me:
	mov	ecx, DWORD PTR __Next$278310[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$278310[ebp], ecx
$LN79@Chunked_me:
	mov	edx, DWORD PTR __Next$278310[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN77@Chunked_me
	jmp	SHORT $LN78@Chunked_me
$LN77@Chunked_me:
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T278307[ebp], eax
	mov	ecx, DWORD PTR $T278307[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@Chunked_me:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@std@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@0@HHU_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandMove>::~_Temp_iterator<CvHomelandMove>
__ehhandler$??$_Chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@std@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@0@HHU_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-172]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@std@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@0@HHU_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@std@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,int>
; Function compile flags: /Odtp
;	COMDAT ??$_Chunked_merge@PAVCvHomelandMove@@PAV1@H@std@@YAXPAVCvHomelandMove@@00HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T278592 = -176						; size = 4
$T278591 = -172						; size = 4
$T278590 = -168						; size = 4
$T278589 = -164						; size = 4
$T278585 = -104						; size = 1
$T278584 = -103						; size = 1
$T278473 = -100						; size = 4
$T278472 = -96						; size = 4
$T278455 = -90						; size = 1
$T278454 = -89						; size = 1
$T278453 = -88						; size = 4
$T278452 = -84						; size = 4
__Cat$278462 = -76					; size = 1
$T278460 = -75						; size = 1
$T278459 = -74						; size = 1
$T278458 = -73						; size = 1
$T278433 = -72						; size = 4
$T278432 = -68						; size = 4
$T278431 = -64						; size = 4
$T278430 = -60						; size = 4
$T278429 = -56						; size = 4
$T278425 = -22						; size = 1
$T278424 = -21						; size = 1
__Mid$234887 = -16					; size = 4
__Mid2$234884 = -12					; size = 4
__Mid1$234883 = -8					; size = 4
__Chunk2$234879 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Chunked_merge@PAVCvHomelandMove@@PAV1@H@std@@YAXPAVCvHomelandMove@@00HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvHomelandMove *,CvHomelandMove *,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$234879[ebp], eax
	jmp	SHORT $LN5@Chunked_me@2
$LN4@Chunked_me@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$234879[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me@2:
	mov	edx, DWORD PTR __Chunk2$234879[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	SHORT $LN3@Chunked_me@2

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$234883[ebp], eax

; 3292 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	mov	edx, DWORD PTR __Mid1$234883[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Mid1$234883[ebp], eax

; 3293 : 		_BidIt _Mid2 = _Mid1;

	mov	ecx, DWORD PTR __Mid1$234883[ebp]
	mov	DWORD PTR __Mid2$234884[ebp], ecx

; 3294 : 		std::advance(_Mid2, _Chunk);

	mov	edx, DWORD PTR __Chunk$[ebp]
	mov	eax, DWORD PTR __Mid2$234884[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Mid2$234884[ebp], ecx

; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T278433[ebp], edx
	mov	eax, DWORD PTR __Mid2$234884[ebp]
	mov	DWORD PTR $T278432[ebp], eax
	mov	ecx, DWORD PTR __Mid1$234883[ebp]
	mov	DWORD PTR $T278431[ebp], ecx
	mov	edx, DWORD PTR __Mid1$234883[ebp]
	mov	DWORD PTR $T278430[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T278429[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T278424[ebp], cl
	movzx	edx, BYTE PTR $T278424[ebp]
	push	edx
	movzx	eax, BYTE PTR $T278425[ebp]
	push	eax
	mov	ecx, DWORD PTR $T278433[ebp]
	push	ecx
	mov	edx, DWORD PTR $T278432[ebp]
	push	edx
	mov	eax, DWORD PTR $T278431[ebp]
	push	eax
	mov	ecx, DWORD PTR $T278430[ebp]
	push	ecx
	mov	edx, DWORD PTR $T278429[ebp]
	push	edx
	call	??$_Merge@PAVCvHomelandMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Dest$[ebp], eax

; 3297 : 		_First = _Mid2;

	mov	eax, DWORD PTR __Mid2$234884[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 3298 : 		}

	jmp	$LN4@Chunked_me@2
$LN3@Chunked_me@2:

; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, DWORD PTR __Chunk$[ebp]
	jg	SHORT $LN2@Chunked_me@2

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T278473[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T278472[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T278458[ebp], cl
	mov	dl, BYTE PTR __Cat$278462[ebp]
	mov	BYTE PTR $T278459[ebp], dl
	mov	al, BYTE PTR $T278458[ebp]
	mov	BYTE PTR $T278455[ebp], al
	mov	cl, BYTE PTR $T278460[ebp]
	mov	BYTE PTR $T278454[ebp], cl
	mov	edx, DWORD PTR $T278473[ebp]
	mov	DWORD PTR $T278453[ebp], edx
	mov	eax, DWORD PTR $T278472[ebp]
	mov	DWORD PTR $T278452[ebp], eax
	jmp	SHORT $LN53@Chunked_me@2
$LN52@Chunked_me@2:
	mov	ecx, DWORD PTR $T278453[ebp]
	add	ecx, 8
	mov	DWORD PTR $T278453[ebp], ecx
	mov	edx, DWORD PTR $T278452[ebp]
	add	edx, 8
	mov	DWORD PTR $T278452[ebp], edx
$LN53@Chunked_me@2:
	mov	eax, DWORD PTR $T278452[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN45@Chunked_me@2
	mov	ecx, DWORD PTR $T278452[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T278453[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN52@Chunked_me@2
$LN45@Chunked_me@2:

; 3302 : 	else

	jmp	SHORT $LN6@Chunked_me@2
$LN2@Chunked_me@2:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$234887[ebp], edx

; 3305 : 		std::advance(_Mid, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	mov	ecx, DWORD PTR __Mid$234887[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$234887[ebp], edx

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T278592[ebp], eax
	mov	ecx, DWORD PTR __Mid$234887[ebp]
	mov	DWORD PTR $T278591[ebp], ecx
	mov	edx, DWORD PTR __Mid$234887[ebp]
	mov	DWORD PTR $T278590[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T278589[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T278584[ebp], cl
	movzx	edx, BYTE PTR $T278584[ebp]
	push	edx
	movzx	eax, BYTE PTR $T278585[ebp]
	push	eax
	mov	ecx, DWORD PTR $T278592[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T278591[ebp]
	push	eax
	mov	ecx, DWORD PTR $T278590[ebp]
	push	ecx
	mov	edx, DWORD PTR $T278589[ebp]
	push	edx
	call	??$_Merge@PAVCvHomelandMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
$LN6@Chunked_me@2:

; 3308 : 		}
; 3309 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Chunked_merge@PAVCvHomelandMove@@PAV1@H@std@@YAXPAVCvHomelandMove@@00HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvHomelandMove *,CvHomelandMove *,int>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@ABVCvHomelandMove@@@Z ; std::_Temp_iterator<CvHomelandMove>::operator=
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Copy_opt@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_opt@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Copy_opt@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Copy_opt@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$_Copy_opt@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T278636 = -36						; size = 4
__Next$278639 = -32					; size = 4
$T278597 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Copy_opt@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T278597[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt
$LN9@Copy_opt:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN3@Copy_opt:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@ABVCvHomelandMove@@@Z ; std::_Temp_iterator<CvHomelandMove>::operator=
	jmp	SHORT $LN9@Copy_opt
$LN1@Copy_opt:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T278597[ebp]
	or	eax, 1
	mov	DWORD PTR $T278597[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN31@Copy_opt
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$278639[ebp], ecx
	jmp	SHORT $LN29@Copy_opt
$LN28@Copy_opt:
	mov	edx, DWORD PTR __Next$278639[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$278639[ebp], edx
$LN29@Copy_opt:
	mov	eax, DWORD PTR __Next$278639[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN27@Copy_opt
	jmp	SHORT $LN28@Copy_opt
$LN27@Copy_opt:
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T278636[ebp], ecx
	mov	edx, DWORD PTR $T278636[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN31@Copy_opt:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_opt@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandMove>::~_Temp_iterator<CvHomelandMove>
__ehhandler$??$_Copy_opt@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Copy_opt@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Copy_opt@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAVCvHomelandMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T278738 = -56						; size = 4
$T278737 = -52						; size = 4
$T278720 = -46						; size = 1
$T278719 = -45						; size = 1
$T278718 = -44						; size = 4
$T278717 = -40						; size = 4
__Cat$278727 = -32					; size = 1
$T278724 = -31						; size = 1
$T278723 = -30						; size = 1
$T278722 = -29						; size = 1
$T278698 = -28						; size = 4
$T278697 = -24						; size = 4
$T278680 = -18						; size = 1
$T278679 = -17						; size = 1
$T278678 = -16						; size = 4
$T278677 = -12						; size = 4
__Cat$278687 = -4					; size = 1
$T278684 = -3						; size = 1
$T278683 = -2						; size = 1
$T278682 = -1						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Merge@PAVCvHomelandMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *,std::random_access_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	jmp	SHORT $LN5@Merge
$LN4@Merge:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
$LN5@Merge:
	mov	ecx, DWORD PTR __First1$[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	SHORT $LN3@Merge
	mov	edx, DWORD PTR __First2$[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN3@Merge

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	eax, DWORD PTR __First2$[ebp]
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Merge

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	edx, DWORD PTR __First2$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __First2$[ebp]
	add	eax, 8
	mov	DWORD PTR __First2$[ebp], eax

; 2516 : 		else

	jmp	SHORT $LN1@Merge
$LN2@Merge:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	ecx, DWORD PTR __First1$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __First1$[ebp]
	add	edx, 8
	mov	DWORD PTR __First1$[ebp], edx
$LN1@Merge:
	jmp	SHORT $LN4@Merge
$LN3@Merge:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T278698[ebp], eax
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T278697[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T278682[ebp], dl
	mov	al, BYTE PTR __Cat$278687[ebp]
	mov	BYTE PTR $T278683[ebp], al
	mov	cl, BYTE PTR $T278682[ebp]
	mov	BYTE PTR $T278680[ebp], cl
	mov	dl, BYTE PTR $T278684[ebp]
	mov	BYTE PTR $T278679[ebp], dl
	mov	eax, DWORD PTR $T278698[ebp]
	mov	DWORD PTR $T278678[ebp], eax
	mov	ecx, DWORD PTR $T278697[ebp]
	mov	DWORD PTR $T278677[ebp], ecx
	jmp	SHORT $LN18@Merge
$LN17@Merge:
	mov	edx, DWORD PTR $T278678[ebp]
	add	edx, 8
	mov	DWORD PTR $T278678[ebp], edx
	mov	eax, DWORD PTR $T278677[ebp]
	add	eax, 8
	mov	DWORD PTR $T278677[ebp], eax
$LN18@Merge:
	mov	ecx, DWORD PTR $T278677[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	SHORT $LN10@Merge
	mov	edx, DWORD PTR $T278677[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T278678[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN17@Merge
$LN10@Merge:
	mov	eax, DWORD PTR $T278678[ebp]
	mov	DWORD PTR __Dest$[ebp], eax

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T278738[ebp], ecx
	mov	edx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T278737[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T278722[ebp], al
	mov	cl, BYTE PTR __Cat$278727[ebp]
	mov	BYTE PTR $T278723[ebp], cl
	mov	dl, BYTE PTR $T278722[ebp]
	mov	BYTE PTR $T278720[ebp], dl
	mov	al, BYTE PTR $T278724[ebp]
	mov	BYTE PTR $T278719[ebp], al
	mov	ecx, DWORD PTR $T278738[ebp]
	mov	DWORD PTR $T278718[ebp], ecx
	mov	edx, DWORD PTR $T278737[ebp]
	mov	DWORD PTR $T278717[ebp], edx
	jmp	SHORT $LN29@Merge
$LN28@Merge:
	mov	eax, DWORD PTR $T278718[ebp]
	add	eax, 8
	mov	DWORD PTR $T278718[ebp], eax
	mov	ecx, DWORD PTR $T278717[ebp]
	add	ecx, 8
	mov	DWORD PTR $T278717[ebp], ecx
$LN29@Merge:
	mov	edx, DWORD PTR $T278717[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN21@Merge
	mov	eax, DWORD PTR $T278717[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T278718[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN28@Merge
$LN21@Merge:
	mov	eax, DWORD PTR $T278718[ebp]

; 2521 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge@PAVCvHomelandMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Merge_backward@PAVCvHomelandMove@@PAV1@PAV1@@std@@YAPAVCvHomelandMove@@PAV1@0000U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T278818 = -64						; size = 4
$T278817 = -60						; size = 4
$T278801 = -54						; size = 1
$T278800 = -53						; size = 1
$T278799 = -52						; size = 4
$T278798 = -48						; size = 4
$T278797 = -44						; size = 4
__Cat$278807 = -36					; size = 1
$T278805 = -35						; size = 1
$T278804 = -34						; size = 1
$T278803 = -33						; size = 1
$T278779 = -32						; size = 4
$T278778 = -28						; size = 4
$T278762 = -22						; size = 1
$T278761 = -21						; size = 1
$T278760 = -20						; size = 4
$T278759 = -16						; size = 4
$T278758 = -12						; size = 4
__Cat$278769 = -4					; size = 1
$T278766 = -3						; size = 1
$T278765 = -2						; size = 1
$T278764 = -1						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Merge_backward@PAVCvHomelandMove@@PAV1@PAV1@@std@@YAPAVCvHomelandMove@@PAV1@0000U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *>, COMDAT

; 2710 : 	{	// merge backwards to _Dest, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
$LN8@Merge_back:

; 2711 : 	for (; ; )
; 2712 : 		if (_First1 == _Last1)

	mov	eax, DWORD PTR __First1$[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	jne	SHORT $LN6@Merge_back

; 2713 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T278779[ebp], ecx
	mov	edx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T278778[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T278764[ebp], al
	mov	cl, BYTE PTR __Cat$278769[ebp]
	mov	BYTE PTR $T278765[ebp], cl
	mov	dl, BYTE PTR $T278764[ebp]
	mov	BYTE PTR $T278762[ebp], dl
	mov	al, BYTE PTR $T278766[ebp]
	mov	BYTE PTR $T278761[ebp], al
	mov	ecx, DWORD PTR $T278779[ebp]
	mov	DWORD PTR $T278760[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	mov	DWORD PTR $T278759[ebp], edx
	mov	eax, DWORD PTR $T278778[ebp]
	mov	DWORD PTR $T278758[ebp], eax
$LN18@Merge_back:
	mov	ecx, DWORD PTR $T278758[ebp]
	cmp	ecx, DWORD PTR $T278759[ebp]
	je	SHORT $LN11@Merge_back
	mov	edx, DWORD PTR $T278759[ebp]
	sub	edx, 8
	mov	DWORD PTR $T278759[ebp], edx
	mov	eax, DWORD PTR $T278760[ebp]
	sub	eax, 8
	mov	DWORD PTR $T278760[ebp], eax
	mov	ecx, DWORD PTR $T278759[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T278760[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN18@Merge_back
$LN11@Merge_back:
	mov	eax, DWORD PTR $T278760[ebp]
	jmp	$LN9@Merge_back
	jmp	$LN5@Merge_back
$LN6@Merge_back:

; 2714 : 		else if (_First2 == _Last2)

	mov	edx, DWORD PTR __First2$[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	jne	SHORT $LN4@Merge_back

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T278818[ebp], eax
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T278817[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T278803[ebp], dl
	mov	al, BYTE PTR __Cat$278807[ebp]
	mov	BYTE PTR $T278804[ebp], al
	mov	cl, BYTE PTR $T278803[ebp]
	mov	BYTE PTR $T278801[ebp], cl
	mov	dl, BYTE PTR $T278805[ebp]
	mov	BYTE PTR $T278800[ebp], dl
	mov	eax, DWORD PTR $T278818[ebp]
	mov	DWORD PTR $T278799[ebp], eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	mov	DWORD PTR $T278798[ebp], ecx
	mov	edx, DWORD PTR $T278817[ebp]
	mov	DWORD PTR $T278797[ebp], edx
$LN28@Merge_back:
	mov	eax, DWORD PTR $T278797[ebp]
	cmp	eax, DWORD PTR $T278798[ebp]
	je	SHORT $LN21@Merge_back
	mov	ecx, DWORD PTR $T278798[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T278798[ebp], ecx
	mov	edx, DWORD PTR $T278799[ebp]
	sub	edx, 8
	mov	DWORD PTR $T278799[ebp], edx
	mov	eax, DWORD PTR $T278798[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T278799[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN28@Merge_back
$LN21@Merge_back:
	mov	eax, DWORD PTR $T278799[ebp]
	jmp	SHORT $LN9@Merge_back
	jmp	SHORT $LN5@Merge_back
$LN4@Merge_back:

; 2716 : 		else if (_DEBUG_LT(*--_Last2, *--_Last1))

	mov	ecx, DWORD PTR __Last1$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Last1$[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Last2$[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	mov	ecx, DWORD PTR __Last1$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Merge_back

; 2717 : 			*--_Dest = *_Last1, ++_Last2;

	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Last2$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Last2$[ebp], ecx

; 2718 : 		else

	jmp	SHORT $LN5@Merge_back
$LN2@Merge_back:

; 2719 : 			*--_Dest = *_Last2, ++_Last1;

	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Last1$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Last1$[ebp], ecx
$LN5@Merge_back:
	jmp	$LN8@Merge_back
$LN9@Merge_back:

; 2720 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge_backward@PAVCvHomelandMove@@PAV1@PAV1@@std@@YAPAVCvHomelandMove@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Lower_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
$T278841 = -20						; size = 4
__Count2$234937 = -12					; size = 4
__Mid$234938 = -8					; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Lower_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z PROC ; std::_Lower_bound<CvHomelandMove *,CvHomelandMove,int>, COMDAT

; 2252 : 	{	// find first element not before _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2253 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2254 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2255 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T278841[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR $T278841[ebp]
	sar	ecx, 3
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN4@Lower_boun:

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Lower_boun

; 2258 : 		{	// divide and conquer, find half that contains answer
; 2259 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$234937[ebp], eax

; 2260 : 		_FwdIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$234938[ebp], edx

; 2261 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$234937[ebp]
	mov	ecx, DWORD PTR __Mid$234938[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$234938[ebp], edx

; 2262 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2263 : 
; 2264 : 		if (_DEBUG_LT(*_Mid, _Val))

	mov	eax, DWORD PTR __Mid$234938[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Lower_boun

; 2265 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	edx, DWORD PTR __Mid$234938[ebp]
	add	edx, 8
	mov	DWORD PTR __Mid$234938[ebp], edx
	mov	eax, DWORD PTR __Mid$234938[ebp]
	mov	DWORD PTR __First$[ebp], eax
	mov	ecx, DWORD PTR __Count2$234937[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Count$[ebp], edx

; 2266 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2267 : 			_Count = _Count2;

	mov	eax, DWORD PTR __Count2$234937[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN1@Lower_boun:

; 2268 : 		}

	jmp	SHORT $LN4@Lower_boun
$LN3@Lower_boun:

; 2269 : 	return (_First);

	mov	eax, DWORD PTR __First$[ebp]

; 2270 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Lower_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z ENDP ; std::_Lower_bound<CvHomelandMove *,CvHomelandMove,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Upper_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
$T278881 = -20						; size = 4
__Count2$234946 = -12					; size = 4
__Mid$234947 = -8					; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Upper_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z PROC ; std::_Upper_bound<CvHomelandMove *,CvHomelandMove,int>, COMDAT

; 2324 : 	{	// find first element that _Val is before, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2325 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2326 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2327 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T278881[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR $T278881[ebp]
	sar	ecx, 3
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN4@Upper_boun:

; 2328 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Upper_boun

; 2329 : 		{	// divide and conquer, find half that contains answer
; 2330 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$234946[ebp], eax

; 2331 : 		_FwdIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$234947[ebp], edx

; 2332 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$234946[ebp]
	mov	ecx, DWORD PTR __Mid$234947[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$234947[ebp], edx

; 2333 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2334 : 
; 2335 : 		if (!_DEBUG_LT(_Val, *_Mid))

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR __Mid$234947[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@Upper_boun

; 2336 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	edx, DWORD PTR __Mid$234947[ebp]
	add	edx, 8
	mov	DWORD PTR __Mid$234947[ebp], edx
	mov	eax, DWORD PTR __Mid$234947[ebp]
	mov	DWORD PTR __First$[ebp], eax
	mov	ecx, DWORD PTR __Count2$234946[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Count$[ebp], edx

; 2337 : 		else

	jmp	SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2338 : 			_Count = _Count2;

	mov	eax, DWORD PTR __Count2$234946[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN1@Upper_boun:

; 2339 : 		}

	jmp	SHORT $LN4@Upper_boun
$LN3@Upper_boun:

; 2340 : 	return (_First);

	mov	eax, DWORD PTR __First$[ebp]

; 2341 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Upper_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z ENDP ; std::_Upper_bound<CvHomelandMove *,CvHomelandMove,int>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@000V12@@Z ; stdext::unchecked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V?$_Temp_iterator@VCvHomelandTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V?$_Temp_iterator@VCvHomelandTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V?$_Temp_iterator@VCvHomelandTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V?$_Temp_iterator@VCvHomelandTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V?$_Temp_iterator@VCvHomelandTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv183 = -180						; size = 4
tv182 = -176						; size = 4
tv179 = -172						; size = 4
tv178 = -168						; size = 4
tv174 = -164						; size = 4
tv173 = -160						; size = 4
$T279111 = -156						; size = 4
__Next$279114 = -152					; size = 4
$T279092 = -148						; size = 4
__Next$279095 = -144					; size = 4
$T279084 = -140						; size = 4
$T279031 = -132						; size = 4
__Next$279034 = -128					; size = 4
$T279023 = -124						; size = 4
$T279003 = -120						; size = 4
__Next$279006 = -116					; size = 4
$T278995 = -112						; size = 4
$T278991 = -108						; size = 4
$T278909 = -100						; size = 20
$T278908 = -80						; size = 4
$T278907 = -76						; size = 20
$T278906 = -56						; size = 4
$T278905 = -52						; size = 20
$T278904 = -32						; size = 4
__Mid$235097 = -28					; size = 4
__Mid2$235080 = -24					; size = 4
__Mid1$235079 = -20					; size = 4
__Chunk2$235075 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
___formal$ = 44						; size = 1
??$_Chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V?$_Temp_iterator@VCvHomelandTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V?$_Temp_iterator@VCvHomelandTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 168				; 000000a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$235075[ebp], eax
	jmp	SHORT $LN5@Chunked_me@3
$LN4@Chunked_me@3:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$235075[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me@3:
	mov	edx, DWORD PTR __Chunk2$235075[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	$LN3@Chunked_me@3

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$235079[ebp], eax

; 3292 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR __Mid1$235079[ebp]
	mov	DWORD PTR __Mid1$235079[ebp], ecx

; 3293 : 		_BidIt _Mid2 = _Mid1;

	mov	edx, DWORD PTR __Mid1$235079[ebp]
	mov	DWORD PTR __Mid2$235080[ebp], edx

; 3294 : 		std::advance(_Mid2, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Mid2$235080[ebp]
	mov	DWORD PTR __Mid2$235080[ebp], eax

; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T278904[ebp], esp
	mov	DWORD PTR $T278991[ebp], ecx
	mov	edx, DWORD PTR $T278991[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T278991[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T278991[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T278991[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T278991[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T278991[ebp]
	mov	DWORD PTR tv173[ebp], edx
	mov	eax, DWORD PTR __Mid2$235080[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid1$235079[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid1$235079[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T278905[ebp]
	push	ecx
	call	??$unchecked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@000V12@@Z ; stdext::unchecked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv174[ebp], eax
	mov	edx, DWORD PTR tv174[ebp]
	mov	DWORD PTR $T278995[ebp], edx
	mov	eax, DWORD PTR $T278995[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Dest$[ebp+16], ecx
	cmp	DWORD PTR $T278905[ebp], 0
	je	SHORT $LN45@Chunked_me@3
	mov	edx, DWORD PTR $T278905[ebp]
	mov	DWORD PTR __Next$279006[ebp], edx
	jmp	SHORT $LN43@Chunked_me@3
$LN42@Chunked_me@3:
	mov	eax, DWORD PTR __Next$279006[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __Next$279006[ebp], eax
$LN43@Chunked_me@3:
	mov	ecx, DWORD PTR __Next$279006[ebp]
	cmp	ecx, DWORD PTR $T278905[ebp+8]
	je	SHORT $LN41@Chunked_me@3
	jmp	SHORT $LN42@Chunked_me@3
$LN41@Chunked_me@3:
	mov	edx, DWORD PTR $T278905[ebp]
	mov	DWORD PTR $T279003[ebp], edx
	mov	eax, DWORD PTR $T279003[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN45@Chunked_me@3:

; 3297 : 		_First = _Mid2;

	mov	ecx, DWORD PTR __Mid2$235080[ebp]
	mov	DWORD PTR __First$[ebp], ecx

; 3298 : 		}

	jmp	$LN4@Chunked_me@3
$LN3@Chunked_me@3:

; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	mov	edx, DWORD PTR __Count$[ebp]
	cmp	edx, DWORD PTR __Chunk$[ebp]
	jg	$LN2@Chunked_me@3

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T278906[ebp], esp
	mov	DWORD PTR $T279023[ebp], eax
	mov	ecx, DWORD PTR $T279023[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T279023[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T279023[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T279023[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T279023[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T279023[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T278907[ebp]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv179[ebp], eax
	cmp	DWORD PTR $T278907[ebp], 0
	je	SHORT $LN59@Chunked_me@3
	mov	edx, DWORD PTR $T278907[ebp]
	mov	DWORD PTR __Next$279034[ebp], edx
	jmp	SHORT $LN57@Chunked_me@3
$LN56@Chunked_me@3:
	mov	eax, DWORD PTR __Next$279034[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __Next$279034[ebp], eax
$LN57@Chunked_me@3:
	mov	ecx, DWORD PTR __Next$279034[ebp]
	cmp	ecx, DWORD PTR $T278907[ebp+8]
	je	SHORT $LN55@Chunked_me@3
	jmp	SHORT $LN56@Chunked_me@3
$LN55@Chunked_me@3:
	mov	edx, DWORD PTR $T278907[ebp]
	mov	DWORD PTR $T279031[ebp], edx
	mov	eax, DWORD PTR $T279031[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN59@Chunked_me@3:

; 3302 : 	else

	jmp	$LN1@Chunked_me@3
$LN2@Chunked_me@3:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$235097[ebp], ecx

; 3305 : 		std::advance(_Mid, _Chunk);

	mov	edx, DWORD PTR __Chunk$[ebp]
	imul	edx, 20					; 00000014H
	add	edx, DWORD PTR __Mid$235097[ebp]
	mov	DWORD PTR __Mid$235097[ebp], edx

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T278908[ebp], esp
	mov	DWORD PTR $T279084[ebp], eax
	mov	ecx, DWORD PTR $T279084[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T279084[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T279084[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T279084[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T279084[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T279084[ebp]
	mov	DWORD PTR tv182[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$235097[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$235097[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T278909[ebp]
	push	eax
	call	??$unchecked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@000V12@@Z ; stdext::unchecked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv183[ebp], eax
	cmp	DWORD PTR $T278909[ebp], 0
	je	SHORT $LN1@Chunked_me@3
	mov	ecx, DWORD PTR $T278909[ebp]
	mov	DWORD PTR __Next$279095[ebp], ecx
	jmp	SHORT $LN81@Chunked_me@3
$LN80@Chunked_me@3:
	mov	edx, DWORD PTR __Next$279095[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __Next$279095[ebp], edx
$LN81@Chunked_me@3:
	mov	eax, DWORD PTR __Next$279095[ebp]
	cmp	eax, DWORD PTR $T278909[ebp+8]
	je	SHORT $LN79@Chunked_me@3
	jmp	SHORT $LN80@Chunked_me@3
$LN79@Chunked_me@3:
	mov	ecx, DWORD PTR $T278909[ebp]
	mov	DWORD PTR $T279092[ebp], ecx
	mov	edx, DWORD PTR $T279092[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Chunked_me@3:

; 3308 : 		}
; 3309 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN6@Chunked_me@3
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$279114[ebp], eax
	jmp	SHORT $LN91@Chunked_me@3
$LN90@Chunked_me@3:
	mov	ecx, DWORD PTR __Next$279114[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR __Next$279114[ebp], ecx
$LN91@Chunked_me@3:
	mov	edx, DWORD PTR __Next$279114[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN89@Chunked_me@3
	jmp	SHORT $LN90@Chunked_me@3
$LN89@Chunked_me@3:
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T279111[ebp], eax
	mov	ecx, DWORD PTR $T279111[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@Chunked_me@3:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V?$_Temp_iterator@VCvHomelandTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandTarget>::~_Temp_iterator<CvHomelandTarget>
__ehhandler$??$_Chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V?$_Temp_iterator@VCvHomelandTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-172]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V?$_Temp_iterator@VCvHomelandTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V?$_Temp_iterator@VCvHomelandTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,int>
PUBLIC	??$_Merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
PUBLIC	??$unchecked_merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@000V12@@Z ; stdext::unchecked_merge<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Odtp
;	COMDAT ??$_Chunked_merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXPAVCvHomelandTarget@@0V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T279546 = -180						; size = 4
$T279545 = -176						; size = 4
$T279544 = -172						; size = 4
$T279543 = -168						; size = 4
$T279539 = -100						; size = 1
$T279538 = -99						; size = 1
$T279338 = -96						; size = 4
$T279337 = -92						; size = 4
$T279312 = -86						; size = 1
$T279311 = -85						; size = 1
$T279310 = -84						; size = 4
$T279309 = -80						; size = 4
__Cat$279318 = -74					; size = 1
$T279316 = -73						; size = 1
$T279315 = -72						; size = 1
$T279314 = -71						; size = 1
$T279133 = -28						; size = 4
$T279132 = -24						; size = 4
$T279131 = -20						; size = 4
__Mid$235127 = -16					; size = 4
__Mid2$235112 = -12					; size = 4
__Mid1$235105 = -8					; size = 4
__Chunk2$235101 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Chunked_merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXPAVCvHomelandTarget@@0V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$235101[ebp], eax
	jmp	SHORT $LN5@Chunked_me@4
$LN4@Chunked_me@4:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$235101[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me@4:
	mov	edx, DWORD PTR __Chunk2$235101[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	SHORT $LN3@Chunked_me@4

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$235105[ebp], eax

; 3292 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR __Mid1$235105[ebp]
	mov	DWORD PTR __Mid1$235105[ebp], ecx

; 3293 : 		_BidIt _Mid2 = _Mid1;

	mov	edx, DWORD PTR __Mid1$235105[ebp]
	mov	DWORD PTR __Mid2$235112[ebp], edx

; 3294 : 		std::advance(_Mid2, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Mid2$235112[ebp]
	mov	DWORD PTR __Mid2$235112[ebp], eax

; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid2$235112[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid1$235105[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid1$235105[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T279131[ebp]
	push	eax
	call	??$unchecked_merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@000V12@@Z ; stdext::unchecked_merge<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[ebp], ecx

; 3297 : 		_First = _Mid2;

	mov	edx, DWORD PTR __Mid2$235112[ebp]
	mov	DWORD PTR __First$[ebp], edx

; 3298 : 		}

	jmp	SHORT $LN4@Chunked_me@4
$LN3@Chunked_me@4:

; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Chunk$[ebp]
	jg	SHORT $LN2@Chunked_me@4

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T279338[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T279337[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T279314[ebp], al
	mov	cl, BYTE PTR __Cat$279318[ebp]
	mov	BYTE PTR $T279315[ebp], cl
	mov	dl, BYTE PTR $T279314[ebp]
	mov	BYTE PTR $T279312[ebp], dl
	mov	al, BYTE PTR $T279316[ebp]
	mov	BYTE PTR $T279311[ebp], al
	mov	ecx, DWORD PTR $T279338[ebp]
	mov	DWORD PTR $T279310[ebp], ecx
	mov	edx, DWORD PTR $T279337[ebp]
	mov	DWORD PTR $T279309[ebp], edx
	jmp	SHORT $LN59@Chunked_me@4
$LN58@Chunked_me@4:
	mov	eax, DWORD PTR $T279310[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T279310[ebp], eax
	mov	ecx, DWORD PTR $T279309[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T279309[ebp], ecx
$LN59@Chunked_me@4:
	mov	edx, DWORD PTR $T279309[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN57@Chunked_me@4
	mov	eax, DWORD PTR $T279309[ebp]
	mov	ecx, DWORD PTR $T279310[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN58@Chunked_me@4
$LN57@Chunked_me@4:
	mov	ecx, DWORD PTR $T279310[ebp]
	mov	DWORD PTR $T279132[ebp], ecx

; 3302 : 	else

	jmp	SHORT $LN6@Chunked_me@4
$LN2@Chunked_me@4:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$235127[ebp], edx

; 3305 : 		std::advance(_Mid, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Mid$235127[ebp]
	mov	DWORD PTR __Mid$235127[ebp], eax

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T279546[ebp], ecx
	mov	edx, DWORD PTR __Mid$235127[ebp]
	mov	DWORD PTR $T279545[ebp], edx
	mov	eax, DWORD PTR __Mid$235127[ebp]
	mov	DWORD PTR $T279544[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T279543[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T279538[ebp], dl
	movzx	eax, BYTE PTR $T279538[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T279539[ebp]
	push	ecx
	mov	edx, DWORD PTR $T279546[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T279545[ebp]
	push	ecx
	mov	edx, DWORD PTR $T279544[ebp]
	push	edx
	mov	eax, DWORD PTR $T279543[ebp]
	push	eax
	lea	ecx, DWORD PTR $T279133[ebp]
	push	ecx
	call	??$_Merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
	add	esp, 32					; 00000020H
$LN6@Chunked_me@4:

; 3308 : 		}
; 3309 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Chunked_merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXPAVCvHomelandTarget@@0V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@VCvHomelandTarget@@@std@@YAXAAVCvHomelandTarget@@0@Z
_TEXT	SEGMENT
__Tmp$235131 = -20					; size = 20
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VCvHomelandTarget@@@std@@YAXAAVCvHomelandTarget@@0@Z PROC ; std::swap<CvHomelandTarget>, COMDAT

; 17   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN2@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	ecx, DWORD PTR __Left$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$235131[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$235131[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$235131[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$235131[ebp+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Tmp$235131[ebp+16], ecx

; 21   : 
; 22   : 		_Left = _Right;

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx

; 23   : 		_Right = _Tmp;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Tmp$235131[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$235131[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Tmp$235131[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Tmp$235131[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR __Tmp$235131[ebp+16]
	mov	DWORD PTR [eax+16], ecx
$LN2@swap:

; 24   : 		}
; 25   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@VCvHomelandTarget@@@std@@YAXAAVCvHomelandTarget@@0@Z ENDP ; std::swap<CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@ABVCvHomelandTarget@@@Z ; std::_Temp_iterator<CvHomelandTarget>::operator=
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T279617 = -40						; size = 4
__Next$279620 = -36					; size = 4
$T279582 = -20						; size = 4
$T279553 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T279553[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN15@Copy_opt@2
$LN9@Copy_opt@2:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __First$[ebp], eax
$LN15@Copy_opt@2:
	mov	ecx, DWORD PTR __First$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR __Last$[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Copy_opt@2

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T279582[ebp], edx
	mov	eax, DWORD PTR $T279582[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@ABVCvHomelandTarget@@@Z ; std::_Temp_iterator<CvHomelandTarget>::operator=
	jmp	SHORT $LN9@Copy_opt@2
$LN1@Copy_opt@2:

; 2473 : 	return (_Dest);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T279553[ebp]
	or	ecx, 1
	mov	DWORD PTR $T279553[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN43@Copy_opt@2
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$279620[ebp], edx
	jmp	SHORT $LN41@Copy_opt@2
$LN40@Copy_opt@2:
	mov	eax, DWORD PTR __Next$279620[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __Next$279620[ebp], eax
$LN41@Copy_opt@2:
	mov	ecx, DWORD PTR __Next$279620[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN39@Copy_opt@2
	jmp	SHORT $LN40@Copy_opt@2
$LN39@Copy_opt@2:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T279617[ebp], edx
	mov	eax, DWORD PTR $T279617[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN43@Copy_opt@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandTarget>::~_Temp_iterator<CvHomelandTarget>
__ehhandler$??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V23@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@11Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T279893 = -80						; size = 4
$T279892 = -76						; size = 4
$T279891 = -72						; size = 4
$T279854 = -66						; size = 1
$T279853 = -65						; size = 1
$T279852 = -64						; size = 4
$T279851 = -60						; size = 4
$T279850 = -56						; size = 4
$T279816 = -52						; size = 4
__Cat$279861 = -44					; size = 1
$T279858 = -43						; size = 1
$T279857 = -42						; size = 1
$T279856 = -41						; size = 1
$T279770 = -40						; size = 4
$T279769 = -36						; size = 4
$T279744 = -30						; size = 1
$T279743 = -29						; size = 1
$T279742 = -28						; size = 4
$T279741 = -24						; size = 4
__Cat$279751 = -16					; size = 1
$T279748 = -15						; size = 1
$T279747 = -14						; size = 1
$T279746 = -13						; size = 1
$T279674 = -12						; size = 4
$T279662 = -8						; size = 4
$T279637 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
___formal$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V23@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@11Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	jmp	SHORT $LN5@Merge@2
$LN4@Merge@2:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __Dest$[ebp], eax
$LN5@Merge@2:
	mov	ecx, DWORD PTR __First1$[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	$LN3@Merge@2
	mov	edx, DWORD PTR __First2$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last2$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN3@Merge@2

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T279662[ebp], eax
	mov	ecx, DWORD PTR $T279662[ebp]
	mov	edx, DWORD PTR __First1$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+16]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN34@Merge@2

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T279674[ebp], eax
	mov	ecx, DWORD PTR $T279674[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR __First2$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __First2$[ebp], edx

; 2516 : 		else

	jmp	SHORT $LN1@Merge@2

; 2517 : 			*_Dest = *_First1, ++_First1;

$LN34@Merge@2:
	mov	eax, DWORD PTR __First1$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR __First1$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR __First1$[ebp], ecx
$LN1@Merge@2:
	jmp	$LN4@Merge@2
$LN3@Merge@2:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T279770[ebp], edx
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T279769[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T279746[ebp], cl
	mov	dl, BYTE PTR __Cat$279751[ebp]
	mov	BYTE PTR $T279747[ebp], dl
	mov	al, BYTE PTR $T279746[ebp]
	mov	BYTE PTR $T279744[ebp], al
	mov	cl, BYTE PTR $T279748[ebp]
	mov	BYTE PTR $T279743[ebp], cl
	mov	edx, DWORD PTR $T279770[ebp]
	mov	DWORD PTR $T279742[ebp], edx
	mov	eax, DWORD PTR $T279769[ebp]
	mov	DWORD PTR $T279741[ebp], eax
	jmp	SHORT $LN46@Merge@2
$LN45@Merge@2:
	mov	ecx, DWORD PTR $T279742[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T279742[ebp], ecx
	mov	edx, DWORD PTR $T279741[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T279741[ebp], edx
$LN46@Merge@2:
	mov	eax, DWORD PTR $T279741[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	je	SHORT $LN44@Merge@2
	mov	ecx, DWORD PTR $T279741[ebp]
	mov	edx, DWORD PTR $T279742[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	jmp	SHORT $LN45@Merge@2
$LN44@Merge@2:
	mov	edx, DWORD PTR $T279742[ebp]
	mov	DWORD PTR $T279637[ebp], edx
	mov	eax, DWORD PTR $T279637[ebp]
	mov	DWORD PTR __Dest$[ebp], eax

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T279893[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	mov	DWORD PTR $T279892[ebp], edx
	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T279891[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T279856[ebp], cl
	mov	dl, BYTE PTR __Cat$279861[ebp]
	mov	BYTE PTR $T279857[ebp], dl
	mov	al, BYTE PTR $T279856[ebp]
	mov	BYTE PTR $T279854[ebp], al
	mov	cl, BYTE PTR $T279858[ebp]
	mov	BYTE PTR $T279853[ebp], cl
	mov	edx, DWORD PTR $T279893[ebp]
	mov	DWORD PTR $T279852[ebp], edx
	mov	eax, DWORD PTR $T279892[ebp]
	mov	DWORD PTR $T279851[ebp], eax
	mov	ecx, DWORD PTR $T279891[ebp]
	mov	DWORD PTR $T279850[ebp], ecx
	jmp	SHORT $LN76@Merge@2
$LN64@Merge@2:
	mov	edx, DWORD PTR $T279852[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T279852[ebp], edx
	mov	eax, DWORD PTR $T279850[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T279850[ebp], eax
$LN76@Merge@2:
	mov	ecx, DWORD PTR $T279850[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T279851[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN63@Merge@2
	mov	edx, DWORD PTR $T279850[ebp]
	mov	DWORD PTR $T279816[ebp], edx
	mov	eax, DWORD PTR $T279816[ebp]
	mov	ecx, DWORD PTR $T279852[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN64@Merge@2
$LN63@Merge@2:
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T279852[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2521 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V23@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@11Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Merge_backward@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@V12@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0PAVCvHomelandTarget@@10U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T280119 = -80						; size = 4
$T280107 = -76						; size = 4
$T280090 = -72						; size = 4
$T280089 = -68						; size = 4
$T280088 = -64						; size = 4
$T280052 = -58						; size = 1
$T280051 = -57						; size = 1
$T280050 = -56						; size = 4
$T280049 = -52						; size = 4
$T280048 = -48						; size = 4
$T280007 = -44						; size = 4
__Cat$280058 = -36					; size = 1
$T280056 = -35						; size = 1
$T280055 = -34						; size = 1
$T280054 = -33						; size = 1
$T279969 = -32						; size = 4
$T279968 = -28						; size = 4
$T279944 = -22						; size = 1
$T279943 = -21						; size = 1
$T279942 = -20						; size = 4
$T279941 = -16						; size = 4
$T279940 = -12						; size = 4
__Cat$279951 = -4					; size = 1
$T279948 = -3						; size = 1
$T279947 = -2						; size = 1
$T279946 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
___formal$ = 32						; size = 1
??$_Merge_backward@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@V12@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0PAVCvHomelandTarget@@10U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 2710 : 	{	// merge backwards to _Dest, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 2711 : 	for (; ; )
; 2712 : 		if (_First1 == _Last1)

$LN11@Merge_back@2:
	mov	eax, DWORD PTR __First1$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last1$[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN6@Merge_back@2

; 2713 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T279969[ebp], eax
	mov	ecx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T279968[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T279946[ebp], dl
	mov	al, BYTE PTR __Cat$279951[ebp]
	mov	BYTE PTR $T279947[ebp], al
	mov	cl, BYTE PTR $T279946[ebp]
	mov	BYTE PTR $T279944[ebp], cl
	mov	dl, BYTE PTR $T279948[ebp]
	mov	BYTE PTR $T279943[ebp], dl
	mov	eax, DWORD PTR $T279969[ebp]
	mov	DWORD PTR $T279942[ebp], eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	mov	DWORD PTR $T279941[ebp], ecx
	mov	edx, DWORD PTR $T279968[ebp]
	mov	DWORD PTR $T279940[ebp], edx
$LN20@Merge_back@2:
	mov	eax, DWORD PTR $T279940[ebp]
	cmp	eax, DWORD PTR $T279941[ebp]
	je	SHORT $LN19@Merge_back@2
	mov	ecx, DWORD PTR $T279941[ebp]
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR $T279941[ebp], ecx
	mov	edx, DWORD PTR $T279942[ebp]
	sub	edx, 20					; 00000014H
	mov	DWORD PTR $T279942[ebp], edx
	mov	eax, DWORD PTR $T279941[ebp]
	mov	ecx, DWORD PTR $T279942[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN20@Merge_back@2
$LN19@Merge_back@2:
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T279942[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN9@Merge_back@2
	jmp	$LN5@Merge_back@2
$LN6@Merge_back@2:

; 2714 : 		else if (_First2 == _Last2)

	mov	eax, DWORD PTR __First2$[ebp]
	cmp	eax, DWORD PTR __Last2$[ebp]
	jne	$LN4@Merge_back@2

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T280090[ebp], ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	mov	DWORD PTR $T280089[ebp], edx
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T280088[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T280054[ebp], cl
	mov	dl, BYTE PTR __Cat$280058[ebp]
	mov	BYTE PTR $T280055[ebp], dl
	mov	al, BYTE PTR $T280054[ebp]
	mov	BYTE PTR $T280052[ebp], al
	mov	cl, BYTE PTR $T280056[ebp]
	mov	BYTE PTR $T280051[ebp], cl
	mov	edx, DWORD PTR $T280090[ebp]
	mov	DWORD PTR $T280050[ebp], edx
	mov	eax, DWORD PTR $T280089[ebp]
	mov	DWORD PTR $T280049[ebp], eax
	mov	ecx, DWORD PTR $T280088[ebp]
	mov	DWORD PTR $T280048[ebp], ecx
$LN41@Merge_back@2:
	mov	edx, DWORD PTR $T280048[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T280049[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN37@Merge_back@2
	mov	eax, DWORD PTR $T280049[ebp]
	sub	eax, 20					; 00000014H
	mov	DWORD PTR $T280049[ebp], eax
	mov	ecx, DWORD PTR $T280049[ebp]
	mov	DWORD PTR $T280007[ebp], ecx
	mov	edx, DWORD PTR $T280050[ebp]
	sub	edx, 20					; 00000014H
	mov	DWORD PTR $T280050[ebp], edx
	mov	eax, DWORD PTR $T280007[ebp]
	mov	ecx, DWORD PTR $T280050[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN41@Merge_back@2
$LN37@Merge_back@2:
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T280050[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN9@Merge_back@2
	jmp	$LN5@Merge_back@2
$LN4@Merge_back@2:

; 2716 : 		else if (_DEBUG_LT(*--_Last2, *--_Last1))

	mov	eax, DWORD PTR __Last2$[ebp]
	sub	eax, 20					; 00000014H
	mov	DWORD PTR __Last2$[ebp], eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR __Last1$[ebp], ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	mov	DWORD PTR $T280107[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	mov	ecx, DWORD PTR $T280107[ebp]
	mov	edx, DWORD PTR [eax+16]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+16]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Merge_back@2

; 2717 : 			*--_Dest = *_Last1, ++_Last2;

	mov	edx, DWORD PTR __Last1$[ebp]
	mov	DWORD PTR $T280119[ebp], edx
	mov	eax, DWORD PTR __Dest$[ebp]
	sub	eax, 20					; 00000014H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR $T280119[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __Last2$[ebp], edx

; 2718 : 		else

	jmp	SHORT $LN5@Merge_back@2
$LN2@Merge_back@2:

; 2719 : 			*--_Dest = *_Last2, ++_Last1;

	mov	eax, DWORD PTR __Dest$[ebp]
	sub	eax, 20					; 00000014H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __Last1$[ebp], edx
$LN5@Merge_back@2:
	jmp	$LN11@Merge_back@2
$LN9@Merge_back@2:

; 2720 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge_backward@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@V12@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0PAVCvHomelandTarget@@10U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Lower_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z
_TEXT	SEGMENT
$T280239 = -36						; size = 4
$T280197 = -28						; size = 4
$T280184 = -24						; size = 4
$T280183 = -20						; size = 4
__Count2$235185 = -12					; size = 4
__Mid$235186 = -8					; size = 4
__Count$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Lower_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z PROC ; std::_Lower_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget,int>, COMDAT

; 2252 : 	{	// find first element not before _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 2253 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2254 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2255 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T280197[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T280184[ebp], ecx
	mov	edx, DWORD PTR $T280197[ebp]
	mov	DWORD PTR $T280183[ebp], edx
	mov	eax, DWORD PTR $T280184[ebp]
	sub	eax, DWORD PTR $T280183[ebp]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN4@Lower_boun@2:

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Lower_boun@2

; 2258 : 		{	// divide and conquer, find half that contains answer
; 2259 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$235185[ebp], eax

; 2260 : 		_FwdIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$235186[ebp], edx

; 2261 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$235185[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Mid$235186[ebp]
	mov	DWORD PTR __Mid$235186[ebp], eax

; 2262 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2263 : 
; 2264 : 		if (_DEBUG_LT(*_Mid, _Val))

	mov	ecx, DWORD PTR __Mid$235186[ebp]
	mov	DWORD PTR $T280239[ebp], ecx
	mov	edx, DWORD PTR $T280239[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+16]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@Lower_boun@2

; 2265 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	ecx, DWORD PTR __Mid$235186[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR __Mid$235186[ebp], ecx
	mov	edx, DWORD PTR __Mid$235186[ebp]
	mov	DWORD PTR __First$[ebp], edx
	mov	eax, DWORD PTR __Count2$235185[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Count$[ebp], ecx

; 2266 : 		else

	jmp	SHORT $LN1@Lower_boun@2
$LN2@Lower_boun@2:

; 2267 : 			_Count = _Count2;

	mov	edx, DWORD PTR __Count2$235185[ebp]
	mov	DWORD PTR __Count$[ebp], edx
$LN1@Lower_boun@2:

; 2268 : 		}

	jmp	SHORT $LN4@Lower_boun@2
$LN3@Lower_boun@2:

; 2269 : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2270 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Lower_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z ENDP ; std::_Lower_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Upper_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z
_TEXT	SEGMENT
$T280330 = -36						; size = 4
$T280288 = -28						; size = 4
$T280275 = -24						; size = 4
$T280274 = -20						; size = 4
__Count2$235195 = -12					; size = 4
__Mid$235196 = -8					; size = 4
__Count$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Upper_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z PROC ; std::_Upper_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget,int>, COMDAT

; 2324 : 	{	// find first element that _Val is before, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 2325 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2326 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2327 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T280288[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T280275[ebp], ecx
	mov	edx, DWORD PTR $T280288[ebp]
	mov	DWORD PTR $T280274[ebp], edx
	mov	eax, DWORD PTR $T280275[ebp]
	sub	eax, DWORD PTR $T280274[ebp]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN4@Upper_boun@2:

; 2328 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Upper_boun@2

; 2329 : 		{	// divide and conquer, find half that contains answer
; 2330 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$235195[ebp], eax

; 2331 : 		_FwdIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$235196[ebp], edx

; 2332 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$235195[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Mid$235196[ebp]
	mov	DWORD PTR __Mid$235196[ebp], eax

; 2333 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2334 : 
; 2335 : 		if (!_DEBUG_LT(_Val, *_Mid))

	mov	ecx, DWORD PTR __Mid$235196[ebp]
	mov	DWORD PTR $T280330[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T280330[ebp]
	mov	ecx, DWORD PTR [edx+16]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+16]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN2@Upper_boun@2

; 2336 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	ecx, DWORD PTR __Mid$235196[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR __Mid$235196[ebp], ecx
	mov	edx, DWORD PTR __Mid$235196[ebp]
	mov	DWORD PTR __First$[ebp], edx
	mov	eax, DWORD PTR __Count2$235195[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Count$[ebp], ecx

; 2337 : 		else

	jmp	SHORT $LN1@Upper_boun@2
$LN2@Upper_boun@2:

; 2338 : 			_Count = _Count2;

	mov	edx, DWORD PTR __Count2$235195[ebp]
	mov	DWORD PTR __Count$[ebp], edx
$LN1@Upper_boun@2:

; 2339 : 		}

	jmp	SHORT $LN4@Upper_boun@2
$LN3@Upper_boun@2:

; 2340 : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2341 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Upper_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z ENDP ; std::_Upper_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget,int>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv187 = -180						; size = 4
tv186 = -176						; size = 4
tv182 = -172						; size = 4
tv181 = -168						; size = 4
tv177 = -164						; size = 4
tv176 = -160						; size = 4
$T280503 = -156						; size = 4
__Next$280506 = -152					; size = 4
$T280484 = -148						; size = 4
__Next$280487 = -144					; size = 4
$T280476 = -140						; size = 4
$T280439 = -132						; size = 4
__Next$280442 = -128					; size = 4
$T280431 = -124						; size = 4
$T280411 = -120						; size = 4
__Next$280414 = -116					; size = 4
$T280403 = -112						; size = 4
$T280399 = -108						; size = 4
$T280349 = -100						; size = 20
$T280348 = -80						; size = 4
$T280347 = -76						; size = 20
$T280346 = -56						; size = 4
$T280345 = -52						; size = 20
$T280344 = -32						; size = 4
__Mid1$235450 = -28					; size = 4
__Mid2$235431 = -24					; size = 4
__Mid1$235430 = -20					; size = 4
__Chunk2$235426 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 4
___formal$ = 48						; size = 1
??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 168				; 000000a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$235426[ebp], eax
	jmp	SHORT $LN5@Chunked_me@5
$LN4@Chunked_me@5:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$235426[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me@5:
	mov	edx, DWORD PTR __Chunk2$235426[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	$LN3@Chunked_me@5

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$235430[ebp], eax

; 3438 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Mid1$235430[ebp]
	mov	DWORD PTR __Mid1$235430[ebp], ecx

; 3439 : 		_BidIt _Mid2 = _Mid1;

	mov	edx, DWORD PTR __Mid1$235430[ebp]
	mov	DWORD PTR __Mid2$235431[ebp], edx

; 3440 : 		std::advance(_Mid2, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Mid2$235431[ebp]
	mov	DWORD PTR __Mid2$235431[ebp], eax

; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T280344[ebp], esp
	mov	DWORD PTR $T280399[ebp], edx
	mov	eax, DWORD PTR $T280399[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T280399[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T280399[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T280399[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T280399[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T280399[ebp]
	mov	DWORD PTR tv176[ebp], eax
	mov	ecx, DWORD PTR __Mid2$235431[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid1$235430[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid1$235430[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T280345[ebp]
	push	edx
	call	??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv177[ebp], eax
	mov	eax, DWORD PTR tv177[ebp]
	mov	DWORD PTR $T280403[ebp], eax
	mov	ecx, DWORD PTR $T280403[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Dest$[ebp+16], edx
	cmp	DWORD PTR $T280345[ebp], 0
	je	SHORT $LN37@Chunked_me@5
	mov	eax, DWORD PTR $T280345[ebp]
	mov	DWORD PTR __Next$280414[ebp], eax
	jmp	SHORT $LN35@Chunked_me@5
$LN34@Chunked_me@5:
	mov	ecx, DWORD PTR __Next$280414[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Next$280414[ebp], ecx
$LN35@Chunked_me@5:
	mov	edx, DWORD PTR __Next$280414[ebp]
	cmp	edx, DWORD PTR $T280345[ebp+8]
	je	SHORT $LN33@Chunked_me@5
	jmp	SHORT $LN34@Chunked_me@5
$LN33@Chunked_me@5:
	mov	eax, DWORD PTR $T280345[ebp]
	mov	DWORD PTR $T280411[ebp], eax
	mov	ecx, DWORD PTR $T280411[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN37@Chunked_me@5:

; 3443 : 		_First = _Mid2;

	mov	edx, DWORD PTR __Mid2$235431[ebp]
	mov	DWORD PTR __First$[ebp], edx

; 3444 : 		}

	jmp	$LN4@Chunked_me@5
$LN3@Chunked_me@5:

; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Chunk$[ebp]
	jg	$LN2@Chunked_me@5

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T280346[ebp], esp
	mov	DWORD PTR $T280431[ebp], ecx
	mov	edx, DWORD PTR $T280431[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T280431[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T280431[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T280431[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T280431[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T280431[ebp]
	mov	DWORD PTR tv181[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T280347[ebp]
	push	edx
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv182[ebp], eax
	cmp	DWORD PTR $T280347[ebp], 0
	je	SHORT $LN51@Chunked_me@5
	mov	eax, DWORD PTR $T280347[ebp]
	mov	DWORD PTR __Next$280442[ebp], eax
	jmp	SHORT $LN49@Chunked_me@5
$LN48@Chunked_me@5:
	mov	ecx, DWORD PTR __Next$280442[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Next$280442[ebp], ecx
$LN49@Chunked_me@5:
	mov	edx, DWORD PTR __Next$280442[ebp]
	cmp	edx, DWORD PTR $T280347[ebp+8]
	je	SHORT $LN47@Chunked_me@5
	jmp	SHORT $LN48@Chunked_me@5
$LN47@Chunked_me@5:
	mov	eax, DWORD PTR $T280347[ebp]
	mov	DWORD PTR $T280439[ebp], eax
	mov	ecx, DWORD PTR $T280439[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN51@Chunked_me@5:

; 3448 : 	else

	jmp	$LN1@Chunked_me@5
$LN2@Chunked_me@5:

; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$235450[ebp], edx

; 3451 : 		std::advance(_Mid1, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Mid1$235450[ebp]
	mov	DWORD PTR __Mid1$235450[ebp], eax

; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T280348[ebp], esp
	mov	DWORD PTR $T280476[ebp], edx
	mov	eax, DWORD PTR $T280476[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T280476[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T280476[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T280476[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T280476[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T280476[ebp]
	mov	DWORD PTR tv186[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid1$235450[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid1$235450[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T280349[ebp]
	push	edx
	call	??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv187[ebp], eax
	cmp	DWORD PTR $T280349[ebp], 0
	je	SHORT $LN1@Chunked_me@5
	mov	eax, DWORD PTR $T280349[ebp]
	mov	DWORD PTR __Next$280487[ebp], eax
	jmp	SHORT $LN69@Chunked_me@5
$LN68@Chunked_me@5:
	mov	ecx, DWORD PTR __Next$280487[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Next$280487[ebp], ecx
$LN69@Chunked_me@5:
	mov	edx, DWORD PTR __Next$280487[ebp]
	cmp	edx, DWORD PTR $T280349[ebp+8]
	je	SHORT $LN67@Chunked_me@5
	jmp	SHORT $LN68@Chunked_me@5
$LN67@Chunked_me@5:
	mov	eax, DWORD PTR $T280349[ebp]
	mov	DWORD PTR $T280484[ebp], eax
	mov	ecx, DWORD PTR $T280484[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Chunked_me@5:

; 3454 : 		}
; 3455 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN6@Chunked_me@5
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$280506[ebp], edx
	jmp	SHORT $LN79@Chunked_me@5
$LN78@Chunked_me@5:
	mov	eax, DWORD PTR __Next$280506[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$280506[ebp], eax
$LN79@Chunked_me@5:
	mov	ecx, DWORD PTR __Next$280506[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN77@Chunked_me@5
	jmp	SHORT $LN78@Chunked_me@5
$LN77@Chunked_me@5:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T280503[ebp], edx
	mov	eax, DWORD PTR $T280503[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@Chunked_me@5:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
__ehhandler$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-172]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
; Function compile flags: /Odtp
;	COMDAT ??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHP6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T280782 = -176						; size = 4
$T280781 = -172						; size = 4
$T280780 = -168						; size = 4
$T280779 = -164						; size = 4
$T280774 = -104						; size = 1
$T280773 = -103						; size = 1
$T280666 = -100						; size = 4
$T280665 = -96						; size = 4
$T280648 = -90						; size = 1
$T280647 = -89						; size = 1
$T280646 = -88						; size = 4
$T280645 = -84						; size = 4
__Cat$280656 = -76					; size = 1
$T280653 = -75						; size = 1
$T280652 = -74						; size = 1
$T280651 = -73						; size = 1
$T280626 = -72						; size = 4
$T280625 = -68						; size = 4
$T280624 = -64						; size = 4
$T280623 = -60						; size = 4
$T280622 = -56						; size = 4
$T280618 = -22						; size = 1
$T280617 = -21						; size = 1
__Mid1$235462 = -16					; size = 4
__Mid2$235459 = -12					; size = 4
__Mid1$235458 = -8					; size = 4
__Chunk2$235454 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 4
___formal$ = 32						; size = 1
??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHP6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$235454[ebp], eax
	jmp	SHORT $LN5@Chunked_me@6
$LN4@Chunked_me@6:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$235454[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me@6:
	mov	edx, DWORD PTR __Chunk2$235454[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	SHORT $LN3@Chunked_me@6

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$235458[ebp], eax

; 3438 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Mid1$235458[ebp]
	mov	DWORD PTR __Mid1$235458[ebp], ecx

; 3439 : 		_BidIt _Mid2 = _Mid1;

	mov	edx, DWORD PTR __Mid1$235458[ebp]
	mov	DWORD PTR __Mid2$235459[ebp], edx

; 3440 : 		std::advance(_Mid2, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Mid2$235459[ebp]
	mov	DWORD PTR __Mid2$235459[ebp], eax

; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T280626[ebp], ecx
	mov	edx, DWORD PTR __Mid2$235459[ebp]
	mov	DWORD PTR $T280625[ebp], edx
	mov	eax, DWORD PTR __Mid1$235458[ebp]
	mov	DWORD PTR $T280624[ebp], eax
	mov	ecx, DWORD PTR __Mid1$235458[ebp]
	mov	DWORD PTR $T280623[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T280622[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T280617[ebp], al
	movzx	ecx, BYTE PTR $T280617[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T280618[ebp]
	push	edx
	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T280626[ebp]
	push	ecx
	mov	edx, DWORD PTR $T280625[ebp]
	push	edx
	mov	eax, DWORD PTR $T280624[ebp]
	push	eax
	mov	ecx, DWORD PTR $T280623[ebp]
	push	ecx
	mov	edx, DWORD PTR $T280622[ebp]
	push	edx
	call	??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),std::random_access_iterator_tag>
	add	esp, 32					; 00000020H
	mov	DWORD PTR __Dest$[ebp], eax

; 3443 : 		_First = _Mid2;

	mov	eax, DWORD PTR __Mid2$235459[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 3444 : 		}

	jmp	$LN4@Chunked_me@6
$LN3@Chunked_me@6:

; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, DWORD PTR __Chunk$[ebp]
	jg	SHORT $LN2@Chunked_me@6

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T280666[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T280665[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T280651[ebp], cl
	mov	dl, BYTE PTR __Cat$280656[ebp]
	mov	BYTE PTR $T280652[ebp], dl
	mov	al, BYTE PTR $T280651[ebp]
	mov	BYTE PTR $T280648[ebp], al
	mov	cl, BYTE PTR $T280653[ebp]
	mov	BYTE PTR $T280647[ebp], cl
	mov	edx, DWORD PTR $T280666[ebp]
	mov	DWORD PTR $T280646[ebp], edx
	mov	eax, DWORD PTR $T280665[ebp]
	mov	DWORD PTR $T280645[ebp], eax
	jmp	SHORT $LN51@Chunked_me@6
$LN50@Chunked_me@6:
	mov	ecx, DWORD PTR $T280646[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T280646[ebp], ecx
	mov	edx, DWORD PTR $T280645[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T280645[ebp], edx
$LN51@Chunked_me@6:
	mov	eax, DWORD PTR $T280645[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN43@Chunked_me@6
	mov	ecx, DWORD PTR $T280645[ebp]
	mov	edx, DWORD PTR $T280646[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	jmp	SHORT $LN50@Chunked_me@6
$LN43@Chunked_me@6:

; 3448 : 	else

	jmp	SHORT $LN6@Chunked_me@6
$LN2@Chunked_me@6:

; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$235462[ebp], edx

; 3451 : 		std::advance(_Mid1, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Mid1$235462[ebp]
	mov	DWORD PTR __Mid1$235462[ebp], eax

; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T280782[ebp], ecx
	mov	edx, DWORD PTR __Mid1$235462[ebp]
	mov	DWORD PTR $T280781[ebp], edx
	mov	eax, DWORD PTR __Mid1$235462[ebp]
	mov	DWORD PTR $T280780[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T280779[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T280773[ebp], dl
	movzx	eax, BYTE PTR $T280773[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T280774[ebp]
	push	ecx
	mov	edx, DWORD PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR $T280782[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T280781[ebp]
	push	edx
	mov	eax, DWORD PTR $T280780[ebp]
	push	eax
	mov	ecx, DWORD PTR $T280779[ebp]
	push	ecx
	call	??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),std::random_access_iterator_tag>
	add	esp, 32					; 00000020H
$LN6@Chunked_me@6:

; 3454 : 		}
; 3455 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHP6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABVCvHomelandUnit@@@Z ; std::_Temp_iterator<CvHomelandUnit>::operator=
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Copy_opt@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_opt@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Copy_opt@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Copy_opt@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$_Copy_opt@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T280826 = -36						; size = 4
__Next$280829 = -32					; size = 4
$T280787 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Copy_opt@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T280787[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@3
$LN9@Copy_opt@3:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Copy_opt@3:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@3

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABVCvHomelandUnit@@@Z ; std::_Temp_iterator<CvHomelandUnit>::operator=
	jmp	SHORT $LN9@Copy_opt@3
$LN1@Copy_opt@3:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T280787[ebp]
	or	eax, 1
	mov	DWORD PTR $T280787[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN31@Copy_opt@3
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$280829[ebp], ecx
	jmp	SHORT $LN29@Copy_opt@3
$LN28@Copy_opt@3:
	mov	edx, DWORD PTR __Next$280829[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Next$280829[ebp], edx
$LN29@Copy_opt@3:
	mov	eax, DWORD PTR __Next$280829[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN27@Copy_opt@3
	jmp	SHORT $LN28@Copy_opt@3
$LN27@Copy_opt@3:
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T280826[ebp], ecx
	mov	edx, DWORD PTR $T280826[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN31@Copy_opt@3:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_opt@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
__ehhandler$??$_Copy_opt@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Copy_opt@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Copy_opt@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T280925 = -56						; size = 4
$T280924 = -52						; size = 4
$T280907 = -46						; size = 1
$T280906 = -45						; size = 1
$T280905 = -44						; size = 4
$T280904 = -40						; size = 4
__Cat$280915 = -32					; size = 1
$T280912 = -31						; size = 1
$T280911 = -30						; size = 1
$T280910 = -29						; size = 1
$T280885 = -28						; size = 4
$T280884 = -24						; size = 4
$T280867 = -18						; size = 1
$T280866 = -17						; size = 1
$T280865 = -16						; size = 4
$T280864 = -12						; size = 4
__Cat$280875 = -4					; size = 1
$T280872 = -3						; size = 1
$T280871 = -2						; size = 1
$T280870 = -1						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
__Pred$ = 28						; size = 4
___formal$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),std::random_access_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	jmp	SHORT $LN5@Merge@3
$LN4@Merge@3:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], eax
$LN5@Merge@3:
	mov	ecx, DWORD PTR __First1$[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	$LN3@Merge@3
	mov	edx, DWORD PTR __First2$[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	je	$LN3@Merge@3

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	eax, DWORD PTR __First1$[ebp]
	sub	esp, 16					; 00000010H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR __First2$[ebp]
	sub	esp, 16					; 00000010H
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 32					; 00000020H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@Merge@3

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	eax, DWORD PTR __First2$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR __First2$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __First2$[ebp], ecx

; 2600 : 		else

	jmp	SHORT $LN1@Merge@3
$LN2@Merge@3:

; 2601 : 			*_Dest = *_First1, ++_First1;

	mov	edx, DWORD PTR __First1$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR __First1$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __First1$[ebp], eax
$LN1@Merge@3:
	jmp	$LN4@Merge@3
$LN3@Merge@3:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T280885[ebp], ecx
	mov	edx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T280884[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T280870[ebp], al
	mov	cl, BYTE PTR __Cat$280875[ebp]
	mov	BYTE PTR $T280871[ebp], cl
	mov	dl, BYTE PTR $T280870[ebp]
	mov	BYTE PTR $T280867[ebp], dl
	mov	al, BYTE PTR $T280872[ebp]
	mov	BYTE PTR $T280866[ebp], al
	mov	ecx, DWORD PTR $T280885[ebp]
	mov	DWORD PTR $T280865[ebp], ecx
	mov	edx, DWORD PTR $T280884[ebp]
	mov	DWORD PTR $T280864[ebp], edx
	jmp	SHORT $LN16@Merge@3
$LN15@Merge@3:
	mov	eax, DWORD PTR $T280865[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T280865[ebp], eax
	mov	ecx, DWORD PTR $T280864[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T280864[ebp], ecx
$LN16@Merge@3:
	mov	edx, DWORD PTR $T280864[ebp]
	cmp	edx, DWORD PTR __Last1$[ebp]
	je	SHORT $LN8@Merge@3
	mov	eax, DWORD PTR $T280864[ebp]
	mov	ecx, DWORD PTR $T280865[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	jmp	SHORT $LN15@Merge@3
$LN8@Merge@3:
	mov	ecx, DWORD PTR $T280865[ebp]
	mov	DWORD PTR __Dest$[ebp], ecx

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T280925[ebp], edx
	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T280924[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T280910[ebp], cl
	mov	dl, BYTE PTR __Cat$280915[ebp]
	mov	BYTE PTR $T280911[ebp], dl
	mov	al, BYTE PTR $T280910[ebp]
	mov	BYTE PTR $T280907[ebp], al
	mov	cl, BYTE PTR $T280912[ebp]
	mov	BYTE PTR $T280906[ebp], cl
	mov	edx, DWORD PTR $T280925[ebp]
	mov	DWORD PTR $T280905[ebp], edx
	mov	eax, DWORD PTR $T280924[ebp]
	mov	DWORD PTR $T280904[ebp], eax
	jmp	SHORT $LN27@Merge@3
$LN26@Merge@3:
	mov	ecx, DWORD PTR $T280905[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T280905[ebp], ecx
	mov	edx, DWORD PTR $T280904[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T280904[ebp], edx
$LN27@Merge@3:
	mov	eax, DWORD PTR $T280904[ebp]
	cmp	eax, DWORD PTR __Last2$[ebp]
	je	SHORT $LN19@Merge@3
	mov	ecx, DWORD PTR $T280904[ebp]
	mov	edx, DWORD PTR $T280905[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	jmp	SHORT $LN26@Merge@3
$LN19@Merge@3:
	mov	eax, DWORD PTR $T280905[ebp]

; 2605 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T281005 = -64						; size = 4
$T281004 = -60						; size = 4
$T280988 = -54						; size = 1
$T280987 = -53						; size = 1
$T280986 = -52						; size = 4
$T280985 = -48						; size = 4
$T280984 = -44						; size = 4
__Cat$280995 = -36					; size = 1
$T280992 = -35						; size = 1
$T280991 = -34						; size = 1
$T280990 = -33						; size = 1
$T280966 = -32						; size = 4
$T280965 = -28						; size = 4
$T280949 = -22						; size = 1
$T280948 = -21						; size = 1
$T280947 = -20						; size = 4
$T280946 = -16						; size = 4
$T280945 = -12						; size = 4
__Cat$280956 = -4					; size = 1
$T280953 = -3						; size = 1
$T280952 = -2						; size = 1
$T280951 = -1						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
__Pred$ = 28						; size = 4
___formal$ = 32						; size = 1
??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 2839 : 	{	// merge backwards to _Dest, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
$LN8@Merge_back@3:

; 2840 : 	for (; ; )
; 2841 : 		if (_First1 == _Last1)

	mov	eax, DWORD PTR __First1$[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	jne	SHORT $LN6@Merge_back@3

; 2842 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T280966[ebp], ecx
	mov	edx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T280965[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T280951[ebp], al
	mov	cl, BYTE PTR __Cat$280956[ebp]
	mov	BYTE PTR $T280952[ebp], cl
	mov	dl, BYTE PTR $T280951[ebp]
	mov	BYTE PTR $T280949[ebp], dl
	mov	al, BYTE PTR $T280953[ebp]
	mov	BYTE PTR $T280948[ebp], al
	mov	ecx, DWORD PTR $T280966[ebp]
	mov	DWORD PTR $T280947[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	mov	DWORD PTR $T280946[ebp], edx
	mov	eax, DWORD PTR $T280965[ebp]
	mov	DWORD PTR $T280945[ebp], eax
$LN18@Merge_back@3:
	mov	ecx, DWORD PTR $T280945[ebp]
	cmp	ecx, DWORD PTR $T280946[ebp]
	je	SHORT $LN11@Merge_back@3
	mov	edx, DWORD PTR $T280946[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR $T280946[ebp], edx
	mov	eax, DWORD PTR $T280947[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR $T280947[ebp], eax
	mov	ecx, DWORD PTR $T280946[ebp]
	mov	edx, DWORD PTR $T280947[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	jmp	SHORT $LN18@Merge_back@3
$LN11@Merge_back@3:
	mov	eax, DWORD PTR $T280947[ebp]
	jmp	$LN9@Merge_back@3
	jmp	$LN5@Merge_back@3
$LN6@Merge_back@3:

; 2843 : 		else if (_First2 == _Last2)

	mov	edx, DWORD PTR __First2$[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	jne	SHORT $LN4@Merge_back@3

; 2844 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T281005[ebp], eax
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T281004[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T280990[ebp], dl
	mov	al, BYTE PTR __Cat$280995[ebp]
	mov	BYTE PTR $T280991[ebp], al
	mov	cl, BYTE PTR $T280990[ebp]
	mov	BYTE PTR $T280988[ebp], cl
	mov	dl, BYTE PTR $T280992[ebp]
	mov	BYTE PTR $T280987[ebp], dl
	mov	eax, DWORD PTR $T281005[ebp]
	mov	DWORD PTR $T280986[ebp], eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	mov	DWORD PTR $T280985[ebp], ecx
	mov	edx, DWORD PTR $T281004[ebp]
	mov	DWORD PTR $T280984[ebp], edx
$LN28@Merge_back@3:
	mov	eax, DWORD PTR $T280984[ebp]
	cmp	eax, DWORD PTR $T280985[ebp]
	je	SHORT $LN21@Merge_back@3
	mov	ecx, DWORD PTR $T280985[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR $T280985[ebp], ecx
	mov	edx, DWORD PTR $T280986[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR $T280986[ebp], edx
	mov	eax, DWORD PTR $T280985[ebp]
	mov	ecx, DWORD PTR $T280986[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	jmp	SHORT $LN28@Merge_back@3
$LN21@Merge_back@3:
	mov	eax, DWORD PTR $T280986[ebp]
	jmp	$LN9@Merge_back@3
	jmp	$LN5@Merge_back@3
$LN4@Merge_back@3:

; 2845 : 		else if (_DEBUG_LT_PRED(_Pred, *--_Last2, *--_Last1))

	mov	ecx, DWORD PTR __Last1$[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR __Last1$[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR __Last2$[ebp], edx
	mov	eax, DWORD PTR __Last1$[ebp]
	sub	esp, 16					; 00000010H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	sub	esp, 16					; 00000010H
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 32					; 00000020H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@Merge_back@3

; 2846 : 			*--_Dest = *_Last1, ++_Last2;

	mov	eax, DWORD PTR __Dest$[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Last2$[ebp], edx

; 2847 : 		else

	jmp	SHORT $LN5@Merge_back@3
$LN2@Merge_back@3:

; 2848 : 			*--_Dest = *_Last2, ++_Last1;

	mov	eax, DWORD PTR __Dest$[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Last1$[ebp], edx
$LN5@Merge_back@3:
	jmp	$LN8@Merge_back@3
$LN9@Merge_back@3:

; 2849 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Lower_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z
_TEXT	SEGMENT
$T281025 = -20						; size = 4
__Count2$235512 = -12					; size = 4
__Mid$235513 = -8					; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Lower_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z PROC ; std::_Lower_bound<CvHomelandUnit *,CvHomelandUnit,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 2288 : 	{	// find first element not before _Val, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2289 : 	_DEBUG_POINTER(_Pred);
; 2290 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2291 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2292 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T281025[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR $T281025[ebp]
	sar	ecx, 4
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN4@Lower_boun@3:

; 2293 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	$LN3@Lower_boun@3

; 2294 : 		{	// divide and conquer, find half that contains answer
; 2295 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$235512[ebp], eax

; 2296 : 		_FwdIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$235513[ebp], edx

; 2297 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$235512[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Mid$235513[ebp]
	mov	DWORD PTR __Mid$235513[ebp], eax

; 2298 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2299 : 
; 2300 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))

	mov	ecx, DWORD PTR __Val$[ebp]
	sub	esp, 16					; 00000010H
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR __Mid$235513[ebp]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 32					; 00000020H
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Lower_boun@3

; 2301 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	ecx, DWORD PTR __Mid$235513[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Mid$235513[ebp], ecx
	mov	edx, DWORD PTR __Mid$235513[ebp]
	mov	DWORD PTR __First$[ebp], edx
	mov	eax, DWORD PTR __Count2$235512[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Count$[ebp], ecx

; 2302 : 		else

	jmp	SHORT $LN1@Lower_boun@3
$LN2@Lower_boun@3:

; 2303 : 			_Count = _Count2;

	mov	edx, DWORD PTR __Count2$235512[ebp]
	mov	DWORD PTR __Count$[ebp], edx
$LN1@Lower_boun@3:

; 2304 : 		}

	jmp	$LN4@Lower_boun@3
$LN3@Lower_boun@3:

; 2305 : 	return (_First);

	mov	eax, DWORD PTR __First$[ebp]

; 2306 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Lower_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ENDP ; std::_Lower_bound<CvHomelandUnit *,CvHomelandUnit,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Upper_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z
_TEXT	SEGMENT
$T281062 = -20						; size = 4
__Count2$235521 = -12					; size = 4
__Mid$235522 = -8					; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Upper_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z PROC ; std::_Upper_bound<CvHomelandUnit *,CvHomelandUnit,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 2359 : 	{	// find first element that _Val is before, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2360 : 	_DEBUG_POINTER(_Pred);
; 2361 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2362 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2363 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T281062[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR $T281062[ebp]
	sar	ecx, 4
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN4@Upper_boun@3:

; 2364 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	$LN3@Upper_boun@3

; 2365 : 		{	// divide and conquer, find half that contains answer
; 2366 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$235521[ebp], eax

; 2367 : 		_FwdIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$235522[ebp], edx

; 2368 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$235521[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Mid$235522[ebp]
	mov	DWORD PTR __Mid$235522[ebp], eax

; 2369 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2370 : 
; 2371 : 		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))

	mov	ecx, DWORD PTR __Mid$235522[ebp]
	sub	esp, 16					; 00000010H
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 32					; 00000020H
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Upper_boun@3

; 2372 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	ecx, DWORD PTR __Mid$235522[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Mid$235522[ebp], ecx
	mov	edx, DWORD PTR __Mid$235522[ebp]
	mov	DWORD PTR __First$[ebp], edx
	mov	eax, DWORD PTR __Count2$235521[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Count$[ebp], ecx

; 2373 : 		else

	jmp	SHORT $LN1@Upper_boun@3
$LN2@Upper_boun@3:

; 2374 : 			_Count = _Count2;

	mov	edx, DWORD PTR __Count2$235521[ebp]
	mov	DWORD PTR __Count$[ebp], edx
$LN1@Upper_boun@3:

; 2375 : 		}

	jmp	$LN4@Upper_boun@3
$LN3@Upper_boun@3:

; 2376 : 	return (_First);

	mov	eax, DWORD PTR __First$[ebp]

; 2377 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Upper_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ENDP ; std::_Upper_bound<CvHomelandUnit *,CvHomelandUnit,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@@Z ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv183 = -180						; size = 4
tv182 = -176						; size = 4
tv179 = -172						; size = 4
tv178 = -168						; size = 4
tv174 = -164						; size = 4
tv173 = -160						; size = 4
$T281241 = -156						; size = 4
__Next$281244 = -152					; size = 4
$T281222 = -148						; size = 4
__Next$281225 = -144					; size = 4
$T281214 = -140						; size = 4
$T281177 = -132						; size = 4
__Next$281180 = -128					; size = 4
$T281169 = -124						; size = 4
$T281149 = -120						; size = 4
__Next$281152 = -116					; size = 4
$T281141 = -112						; size = 4
$T281137 = -108						; size = 4
$T281087 = -100						; size = 20
$T281086 = -80						; size = 4
$T281085 = -76						; size = 20
$T281084 = -56						; size = 4
$T281083 = -52						; size = 20
$T281082 = -32						; size = 4
__Mid$235598 = -28					; size = 4
__Mid2$235581 = -24					; size = 4
__Mid1$235580 = -20					; size = 4
__Chunk2$235576 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
___formal$ = 44						; size = 1
??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 168				; 000000a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$235576[ebp], eax
	jmp	SHORT $LN5@Chunked_me@7
$LN4@Chunked_me@7:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$235576[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me@7:
	mov	edx, DWORD PTR __Chunk2$235576[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	$LN3@Chunked_me@7

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$235580[ebp], eax

; 3292 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Mid1$235580[ebp]
	mov	DWORD PTR __Mid1$235580[ebp], ecx

; 3293 : 		_BidIt _Mid2 = _Mid1;

	mov	edx, DWORD PTR __Mid1$235580[ebp]
	mov	DWORD PTR __Mid2$235581[ebp], edx

; 3294 : 		std::advance(_Mid2, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Mid2$235581[ebp]
	mov	DWORD PTR __Mid2$235581[ebp], eax

; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T281082[ebp], esp
	mov	DWORD PTR $T281137[ebp], ecx
	mov	edx, DWORD PTR $T281137[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T281137[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T281137[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T281137[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T281137[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T281137[ebp]
	mov	DWORD PTR tv173[ebp], edx
	mov	eax, DWORD PTR __Mid2$235581[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid1$235580[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid1$235580[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T281083[ebp]
	push	ecx
	call	??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@@Z ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv174[ebp], eax
	mov	edx, DWORD PTR tv174[ebp]
	mov	DWORD PTR $T281141[ebp], edx
	mov	eax, DWORD PTR $T281141[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Dest$[ebp+16], ecx
	cmp	DWORD PTR $T281083[ebp], 0
	je	SHORT $LN37@Chunked_me@7
	mov	edx, DWORD PTR $T281083[ebp]
	mov	DWORD PTR __Next$281152[ebp], edx
	jmp	SHORT $LN35@Chunked_me@7
$LN34@Chunked_me@7:
	mov	eax, DWORD PTR __Next$281152[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$281152[ebp], eax
$LN35@Chunked_me@7:
	mov	ecx, DWORD PTR __Next$281152[ebp]
	cmp	ecx, DWORD PTR $T281083[ebp+8]
	je	SHORT $LN33@Chunked_me@7
	jmp	SHORT $LN34@Chunked_me@7
$LN33@Chunked_me@7:
	mov	edx, DWORD PTR $T281083[ebp]
	mov	DWORD PTR $T281149[ebp], edx
	mov	eax, DWORD PTR $T281149[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN37@Chunked_me@7:

; 3297 : 		_First = _Mid2;

	mov	ecx, DWORD PTR __Mid2$235581[ebp]
	mov	DWORD PTR __First$[ebp], ecx

; 3298 : 		}

	jmp	$LN4@Chunked_me@7
$LN3@Chunked_me@7:

; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	mov	edx, DWORD PTR __Count$[ebp]
	cmp	edx, DWORD PTR __Chunk$[ebp]
	jg	$LN2@Chunked_me@7

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T281084[ebp], esp
	mov	DWORD PTR $T281169[ebp], eax
	mov	ecx, DWORD PTR $T281169[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T281169[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T281169[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T281169[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T281169[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T281169[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T281085[ebp]
	push	ecx
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv179[ebp], eax
	cmp	DWORD PTR $T281085[ebp], 0
	je	SHORT $LN51@Chunked_me@7
	mov	edx, DWORD PTR $T281085[ebp]
	mov	DWORD PTR __Next$281180[ebp], edx
	jmp	SHORT $LN49@Chunked_me@7
$LN48@Chunked_me@7:
	mov	eax, DWORD PTR __Next$281180[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$281180[ebp], eax
$LN49@Chunked_me@7:
	mov	ecx, DWORD PTR __Next$281180[ebp]
	cmp	ecx, DWORD PTR $T281085[ebp+8]
	je	SHORT $LN47@Chunked_me@7
	jmp	SHORT $LN48@Chunked_me@7
$LN47@Chunked_me@7:
	mov	edx, DWORD PTR $T281085[ebp]
	mov	DWORD PTR $T281177[ebp], edx
	mov	eax, DWORD PTR $T281177[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN51@Chunked_me@7:

; 3302 : 	else

	jmp	$LN1@Chunked_me@7
$LN2@Chunked_me@7:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$235598[ebp], ecx

; 3305 : 		std::advance(_Mid, _Chunk);

	mov	edx, DWORD PTR __Chunk$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Mid$235598[ebp]
	mov	DWORD PTR __Mid$235598[ebp], edx

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T281086[ebp], esp
	mov	DWORD PTR $T281214[ebp], eax
	mov	ecx, DWORD PTR $T281214[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T281214[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T281214[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T281214[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T281214[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T281214[ebp]
	mov	DWORD PTR tv182[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$235598[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$235598[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T281087[ebp]
	push	eax
	call	??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@@Z ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv183[ebp], eax
	cmp	DWORD PTR $T281087[ebp], 0
	je	SHORT $LN1@Chunked_me@7
	mov	ecx, DWORD PTR $T281087[ebp]
	mov	DWORD PTR __Next$281225[ebp], ecx
	jmp	SHORT $LN69@Chunked_me@7
$LN68@Chunked_me@7:
	mov	edx, DWORD PTR __Next$281225[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Next$281225[ebp], edx
$LN69@Chunked_me@7:
	mov	eax, DWORD PTR __Next$281225[ebp]
	cmp	eax, DWORD PTR $T281087[ebp+8]
	je	SHORT $LN67@Chunked_me@7
	jmp	SHORT $LN68@Chunked_me@7
$LN67@Chunked_me@7:
	mov	ecx, DWORD PTR $T281087[ebp]
	mov	DWORD PTR $T281222[ebp], ecx
	mov	edx, DWORD PTR $T281222[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Chunked_me@7:

; 3308 : 		}
; 3309 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN6@Chunked_me@7
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$281244[ebp], eax
	jmp	SHORT $LN79@Chunked_me@7
$LN78@Chunked_me@7:
	mov	ecx, DWORD PTR __Next$281244[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Next$281244[ebp], ecx
$LN79@Chunked_me@7:
	mov	edx, DWORD PTR __Next$281244[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN77@Chunked_me@7
	jmp	SHORT $LN78@Chunked_me@7
$LN77@Chunked_me@7:
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T281241[ebp], eax
	mov	ecx, DWORD PTR $T281241[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@Chunked_me@7:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
__ehhandler$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-172]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int>
; Function compile flags: /Odtp
;	COMDAT ??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@H@std@@YAXPAVCvHomelandUnit@@00HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T281550 = -200						; size = 4
$T281549 = -196						; size = 4
$T281548 = -192						; size = 4
$T281547 = -188						; size = 4
$T281542 = -116						; size = 1
$T281541 = -115						; size = 1
$T281419 = -112						; size = 4
$T281418 = -108						; size = 4
$T281401 = -102						; size = 1
$T281400 = -101						; size = 1
$T281399 = -100						; size = 4
$T281398 = -96						; size = 4
__Cat$281408 = -88					; size = 1
$T281406 = -87						; size = 1
$T281405 = -86						; size = 1
$T281404 = -85						; size = 1
$T281379 = -84						; size = 4
$T281378 = -80						; size = 4
$T281377 = -76						; size = 4
$T281376 = -72						; size = 4
$T281375 = -68						; size = 4
$T281370 = -22						; size = 1
$T281369 = -21						; size = 1
__Mid$235610 = -16					; size = 4
__Mid2$235607 = -12					; size = 4
__Mid1$235606 = -8					; size = 4
__Chunk2$235602 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@H@std@@YAXPAVCvHomelandUnit@@00HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$235602[ebp], eax
	jmp	SHORT $LN5@Chunked_me@8
$LN4@Chunked_me@8:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$235602[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me@8:
	mov	edx, DWORD PTR __Chunk2$235602[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	SHORT $LN3@Chunked_me@8

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$235606[ebp], eax

; 3292 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Mid1$235606[ebp]
	mov	DWORD PTR __Mid1$235606[ebp], ecx

; 3293 : 		_BidIt _Mid2 = _Mid1;

	mov	edx, DWORD PTR __Mid1$235606[ebp]
	mov	DWORD PTR __Mid2$235607[ebp], edx

; 3294 : 		std::advance(_Mid2, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Mid2$235607[ebp]
	mov	DWORD PTR __Mid2$235607[ebp], eax

; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T281379[ebp], ecx
	mov	edx, DWORD PTR __Mid2$235607[ebp]
	mov	DWORD PTR $T281378[ebp], edx
	mov	eax, DWORD PTR __Mid1$235606[ebp]
	mov	DWORD PTR $T281377[ebp], eax
	mov	ecx, DWORD PTR __Mid1$235606[ebp]
	mov	DWORD PTR $T281376[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T281375[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T281369[ebp], al
	movzx	ecx, BYTE PTR $T281369[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T281370[ebp]
	push	edx
	mov	eax, DWORD PTR $T281379[ebp]
	push	eax
	mov	ecx, DWORD PTR $T281378[ebp]
	push	ecx
	mov	edx, DWORD PTR $T281377[ebp]
	push	edx
	mov	eax, DWORD PTR $T281376[ebp]
	push	eax
	mov	ecx, DWORD PTR $T281375[ebp]
	push	ecx
	call	??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Dest$[ebp], eax

; 3297 : 		_First = _Mid2;

	mov	edx, DWORD PTR __Mid2$235607[ebp]
	mov	DWORD PTR __First$[ebp], edx

; 3298 : 		}

	jmp	$LN4@Chunked_me@8
$LN3@Chunked_me@8:

; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Chunk$[ebp]
	jg	SHORT $LN2@Chunked_me@8

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T281419[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T281418[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T281404[ebp], al
	mov	cl, BYTE PTR __Cat$281408[ebp]
	mov	BYTE PTR $T281405[ebp], cl
	mov	dl, BYTE PTR $T281404[ebp]
	mov	BYTE PTR $T281401[ebp], dl
	mov	al, BYTE PTR $T281406[ebp]
	mov	BYTE PTR $T281400[ebp], al
	mov	ecx, DWORD PTR $T281419[ebp]
	mov	DWORD PTR $T281399[ebp], ecx
	mov	edx, DWORD PTR $T281418[ebp]
	mov	DWORD PTR $T281398[ebp], edx
	jmp	SHORT $LN57@Chunked_me@8
$LN56@Chunked_me@8:
	mov	eax, DWORD PTR $T281399[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T281399[ebp], eax
	mov	ecx, DWORD PTR $T281398[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T281398[ebp], ecx
$LN57@Chunked_me@8:
	mov	edx, DWORD PTR $T281398[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN49@Chunked_me@8
	mov	eax, DWORD PTR $T281398[ebp]
	mov	ecx, DWORD PTR $T281399[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	jmp	SHORT $LN56@Chunked_me@8
$LN49@Chunked_me@8:

; 3302 : 	else

	jmp	SHORT $LN6@Chunked_me@8
$LN2@Chunked_me@8:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$235610[ebp], ecx

; 3305 : 		std::advance(_Mid, _Chunk);

	mov	edx, DWORD PTR __Chunk$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Mid$235610[ebp]
	mov	DWORD PTR __Mid$235610[ebp], edx

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T281550[ebp], eax
	mov	ecx, DWORD PTR __Mid$235610[ebp]
	mov	DWORD PTR $T281549[ebp], ecx
	mov	edx, DWORD PTR __Mid$235610[ebp]
	mov	DWORD PTR $T281548[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T281547[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T281541[ebp], cl
	movzx	edx, BYTE PTR $T281541[ebp]
	push	edx
	movzx	eax, BYTE PTR $T281542[ebp]
	push	eax
	mov	ecx, DWORD PTR $T281550[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T281549[ebp]
	push	eax
	mov	ecx, DWORD PTR $T281548[ebp]
	push	ecx
	mov	edx, DWORD PTR $T281547[ebp]
	push	edx
	call	??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
$LN6@Chunked_me@8:

; 3308 : 		}
; 3309 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@H@std@@YAXPAVCvHomelandUnit@@00HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T281647 = -64						; size = 4
$T281646 = -60						; size = 4
$T281629 = -54						; size = 1
$T281628 = -53						; size = 1
$T281627 = -52						; size = 4
$T281626 = -48						; size = 4
__Cat$281637 = -40					; size = 1
$T281634 = -39						; size = 1
$T281633 = -38						; size = 1
$T281632 = -37						; size = 1
$T281607 = -36						; size = 4
$T281606 = -32						; size = 4
$T281589 = -26						; size = 1
$T281588 = -25						; size = 1
$T281587 = -24						; size = 4
$T281586 = -20						; size = 4
__Cat$281596 = -12					; size = 1
$T281594 = -11						; size = 1
$T281593 = -10						; size = 1
$T281592 = -9						; size = 1
$T281561 = -8						; size = 4
$T281557 = -4						; size = 4
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,std::random_access_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	jmp	SHORT $LN5@Merge@4
$LN4@Merge@4:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], eax
$LN5@Merge@4:
	mov	ecx, DWORD PTR __First1$[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	SHORT $LN3@Merge@4
	mov	edx, DWORD PTR __First2$[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN3@Merge@4

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	eax, DWORD PTR __First2$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T281557[ebp], ecx
	mov	edx, DWORD PTR __First1$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T281561[ebp], eax
	mov	ecx, DWORD PTR $T281557[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T281561[ebp]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@Merge@4

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	ecx, DWORD PTR __First2$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR __First2$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First2$[ebp], edx

; 2516 : 		else

	jmp	SHORT $LN1@Merge@4
$LN2@Merge@4:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	eax, DWORD PTR __First1$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR __First1$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __First1$[ebp], ecx
$LN1@Merge@4:
	jmp	$LN4@Merge@4
$LN3@Merge@4:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T281607[ebp], edx
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T281606[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T281592[ebp], cl
	mov	dl, BYTE PTR __Cat$281596[ebp]
	mov	BYTE PTR $T281593[ebp], dl
	mov	al, BYTE PTR $T281592[ebp]
	mov	BYTE PTR $T281589[ebp], al
	mov	cl, BYTE PTR $T281594[ebp]
	mov	BYTE PTR $T281588[ebp], cl
	mov	edx, DWORD PTR $T281607[ebp]
	mov	DWORD PTR $T281587[ebp], edx
	mov	eax, DWORD PTR $T281606[ebp]
	mov	DWORD PTR $T281586[ebp], eax
	jmp	SHORT $LN22@Merge@4
$LN21@Merge@4:
	mov	ecx, DWORD PTR $T281587[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T281587[ebp], ecx
	mov	edx, DWORD PTR $T281586[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T281586[ebp], edx
$LN22@Merge@4:
	mov	eax, DWORD PTR $T281586[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	je	SHORT $LN14@Merge@4
	mov	ecx, DWORD PTR $T281586[ebp]
	mov	edx, DWORD PTR $T281587[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	jmp	SHORT $LN21@Merge@4
$LN14@Merge@4:
	mov	edx, DWORD PTR $T281587[ebp]
	mov	DWORD PTR __Dest$[ebp], edx

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T281647[ebp], eax
	mov	ecx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T281646[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T281632[ebp], dl
	mov	al, BYTE PTR __Cat$281637[ebp]
	mov	BYTE PTR $T281633[ebp], al
	mov	cl, BYTE PTR $T281632[ebp]
	mov	BYTE PTR $T281629[ebp], cl
	mov	dl, BYTE PTR $T281634[ebp]
	mov	BYTE PTR $T281628[ebp], dl
	mov	eax, DWORD PTR $T281647[ebp]
	mov	DWORD PTR $T281627[ebp], eax
	mov	ecx, DWORD PTR $T281646[ebp]
	mov	DWORD PTR $T281626[ebp], ecx
	jmp	SHORT $LN33@Merge@4
$LN32@Merge@4:
	mov	edx, DWORD PTR $T281627[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T281627[ebp], edx
	mov	eax, DWORD PTR $T281626[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T281626[ebp], eax
$LN33@Merge@4:
	mov	ecx, DWORD PTR $T281626[ebp]
	cmp	ecx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN25@Merge@4
	mov	edx, DWORD PTR $T281626[ebp]
	mov	eax, DWORD PTR $T281627[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	jmp	SHORT $LN32@Merge@4
$LN25@Merge@4:
	mov	eax, DWORD PTR $T281627[ebp]

; 2521 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@@std@@YAPAVCvHomelandUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T281736 = -72						; size = 4
$T281732 = -68						; size = 4
$T281727 = -64						; size = 4
$T281726 = -60						; size = 4
$T281710 = -54						; size = 1
$T281709 = -53						; size = 1
$T281708 = -52						; size = 4
$T281707 = -48						; size = 4
$T281706 = -44						; size = 4
__Cat$281717 = -36					; size = 1
$T281714 = -35						; size = 1
$T281713 = -34						; size = 1
$T281712 = -33						; size = 1
$T281688 = -32						; size = 4
$T281687 = -28						; size = 4
$T281671 = -22						; size = 1
$T281670 = -21						; size = 1
$T281669 = -20						; size = 4
$T281668 = -16						; size = 4
$T281667 = -12						; size = 4
__Cat$281678 = -4					; size = 1
$T281675 = -3						; size = 1
$T281674 = -2						; size = 1
$T281673 = -1						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@@std@@YAPAVCvHomelandUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *>, COMDAT

; 2710 : 	{	// merge backwards to _Dest, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
$LN8@Merge_back@4:

; 2711 : 	for (; ; )
; 2712 : 		if (_First1 == _Last1)

	mov	eax, DWORD PTR __First1$[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	jne	SHORT $LN6@Merge_back@4

; 2713 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T281688[ebp], ecx
	mov	edx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T281687[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T281673[ebp], al
	mov	cl, BYTE PTR __Cat$281678[ebp]
	mov	BYTE PTR $T281674[ebp], cl
	mov	dl, BYTE PTR $T281673[ebp]
	mov	BYTE PTR $T281671[ebp], dl
	mov	al, BYTE PTR $T281675[ebp]
	mov	BYTE PTR $T281670[ebp], al
	mov	ecx, DWORD PTR $T281688[ebp]
	mov	DWORD PTR $T281669[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	mov	DWORD PTR $T281668[ebp], edx
	mov	eax, DWORD PTR $T281687[ebp]
	mov	DWORD PTR $T281667[ebp], eax
$LN18@Merge_back@4:
	mov	ecx, DWORD PTR $T281667[ebp]
	cmp	ecx, DWORD PTR $T281668[ebp]
	je	SHORT $LN11@Merge_back@4
	mov	edx, DWORD PTR $T281668[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR $T281668[ebp], edx
	mov	eax, DWORD PTR $T281669[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR $T281669[ebp], eax
	mov	ecx, DWORD PTR $T281668[ebp]
	mov	edx, DWORD PTR $T281669[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	jmp	SHORT $LN18@Merge_back@4
$LN11@Merge_back@4:
	mov	eax, DWORD PTR $T281669[ebp]
	jmp	$LN9@Merge_back@4
	jmp	$LN5@Merge_back@4
$LN6@Merge_back@4:

; 2714 : 		else if (_First2 == _Last2)

	mov	edx, DWORD PTR __First2$[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	jne	SHORT $LN4@Merge_back@4

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T281727[ebp], eax
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T281726[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T281712[ebp], dl
	mov	al, BYTE PTR __Cat$281717[ebp]
	mov	BYTE PTR $T281713[ebp], al
	mov	cl, BYTE PTR $T281712[ebp]
	mov	BYTE PTR $T281710[ebp], cl
	mov	dl, BYTE PTR $T281714[ebp]
	mov	BYTE PTR $T281709[ebp], dl
	mov	eax, DWORD PTR $T281727[ebp]
	mov	DWORD PTR $T281708[ebp], eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	mov	DWORD PTR $T281707[ebp], ecx
	mov	edx, DWORD PTR $T281726[ebp]
	mov	DWORD PTR $T281706[ebp], edx
$LN28@Merge_back@4:
	mov	eax, DWORD PTR $T281706[ebp]
	cmp	eax, DWORD PTR $T281707[ebp]
	je	SHORT $LN21@Merge_back@4
	mov	ecx, DWORD PTR $T281707[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR $T281707[ebp], ecx
	mov	edx, DWORD PTR $T281708[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR $T281708[ebp], edx
	mov	eax, DWORD PTR $T281707[ebp]
	mov	ecx, DWORD PTR $T281708[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	jmp	SHORT $LN28@Merge_back@4
$LN21@Merge_back@4:
	mov	eax, DWORD PTR $T281708[ebp]
	jmp	$LN9@Merge_back@4
	jmp	$LN5@Merge_back@4
$LN4@Merge_back@4:

; 2716 : 		else if (_DEBUG_LT(*--_Last2, *--_Last1))

	mov	ecx, DWORD PTR __Last1$[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR __Last1$[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR __Last2$[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T281732[ebp], ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T281736[ebp], eax
	mov	ecx, DWORD PTR $T281732[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T281736[ebp]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@Merge_back@4

; 2717 : 			*--_Dest = *_Last1, ++_Last2;

	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Last2$[ebp], eax

; 2718 : 		else

	jmp	SHORT $LN5@Merge_back@4
$LN2@Merge_back@4:

; 2719 : 			*--_Dest = *_Last2, ++_Last1;

	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR __Last1$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Last1$[ebp], eax
$LN5@Merge_back@4:
	jmp	$LN8@Merge_back@4
$LN9@Merge_back@4:

; 2720 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@@std@@YAPAVCvHomelandUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Lower_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
$T281788 = -32						; size = 4
$T281784 = -28						; size = 4
$T281762 = -20						; size = 4
__Count2$235632 = -12					; size = 4
__Mid$235633 = -8					; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Lower_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z PROC ; std::_Lower_bound<CvHomelandUnit *,CvHomelandUnit,int>, COMDAT

; 2252 : 	{	// find first element not before _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 2253 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2254 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2255 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T281762[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR $T281762[ebp]
	sar	ecx, 4
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN4@Lower_boun@4:

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Lower_boun@4

; 2258 : 		{	// divide and conquer, find half that contains answer
; 2259 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$235632[ebp], eax

; 2260 : 		_FwdIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$235633[ebp], edx

; 2261 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$235632[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Mid$235633[ebp]
	mov	DWORD PTR __Mid$235633[ebp], eax

; 2262 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2263 : 
; 2264 : 		if (_DEBUG_LT(*_Mid, _Val))

	mov	ecx, DWORD PTR __Mid$235633[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T281784[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T281788[ebp], ecx
	mov	edx, DWORD PTR $T281784[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T281788[ebp]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Lower_boun@4

; 2265 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	edx, DWORD PTR __Mid$235633[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Mid$235633[ebp], edx
	mov	eax, DWORD PTR __Mid$235633[ebp]
	mov	DWORD PTR __First$[ebp], eax
	mov	ecx, DWORD PTR __Count2$235632[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Count$[ebp], edx

; 2266 : 		else

	jmp	SHORT $LN1@Lower_boun@4
$LN2@Lower_boun@4:

; 2267 : 			_Count = _Count2;

	mov	eax, DWORD PTR __Count2$235632[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN1@Lower_boun@4:

; 2268 : 		}

	jmp	SHORT $LN4@Lower_boun@4
$LN3@Lower_boun@4:

; 2269 : 	return (_First);

	mov	eax, DWORD PTR __First$[ebp]

; 2270 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Lower_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z ENDP ; std::_Lower_bound<CvHomelandUnit *,CvHomelandUnit,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Upper_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
$T281840 = -32						; size = 4
$T281836 = -28						; size = 4
$T281814 = -20						; size = 4
__Count2$235641 = -12					; size = 4
__Mid$235642 = -8					; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Upper_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z PROC ; std::_Upper_bound<CvHomelandUnit *,CvHomelandUnit,int>, COMDAT

; 2324 : 	{	// find first element that _Val is before, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 2325 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2326 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2327 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T281814[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR $T281814[ebp]
	sar	ecx, 4
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN4@Upper_boun@4:

; 2328 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Upper_boun@4

; 2329 : 		{	// divide and conquer, find half that contains answer
; 2330 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$235641[ebp], eax

; 2331 : 		_FwdIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$235642[ebp], edx

; 2332 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$235641[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Mid$235642[ebp]
	mov	DWORD PTR __Mid$235642[ebp], eax

; 2333 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2334 : 
; 2335 : 		if (!_DEBUG_LT(_Val, *_Mid))

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T281836[ebp], edx
	mov	eax, DWORD PTR __Mid$235642[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T281840[ebp], ecx
	mov	edx, DWORD PTR $T281836[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T281840[ebp]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@Upper_boun@4

; 2336 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	edx, DWORD PTR __Mid$235642[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Mid$235642[ebp], edx
	mov	eax, DWORD PTR __Mid$235642[ebp]
	mov	DWORD PTR __First$[ebp], eax
	mov	ecx, DWORD PTR __Count2$235641[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Count$[ebp], edx

; 2337 : 		else

	jmp	SHORT $LN1@Upper_boun@4
$LN2@Upper_boun@4:

; 2338 : 			_Count = _Count2;

	mov	eax, DWORD PTR __Count2$235641[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN1@Upper_boun@4:

; 2339 : 		}

	jmp	SHORT $LN4@Upper_boun@4
$LN3@Upper_boun@4:

; 2340 : 	return (_First);

	mov	eax, DWORD PTR __First$[ebp]

; 2341 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Upper_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z ENDP ; std::_Upper_bound<CvHomelandUnit *,CvHomelandUnit,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z
_TEXT	SEGMENT
$T281892 = -60						; size = 8
$T281863 = -20						; size = 4
$T281857 = -12						; size = 4
$T281856 = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement>, COMDAT

; 2087 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	mov	DWORD PTR $T281857[ebp], eax
	lea	ecx, DWORD PTR $T281892[ebp]
	mov	DWORD PTR $T281856[ebp], ecx
	mov	edx, DWORD PTR $T281856[ebp]
	mov	eax, DWORD PTR $T281857[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T281856[ebp]
	mov	eax, DWORD PTR $T281857[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [edx-8], eax
	mov	DWORD PTR [edx-4], ecx
	sub	esp, 8
	mov	DWORD PTR $T281863[ebp], esp
	mov	eax, DWORD PTR $T281863[ebp]
	mov	ecx, DWORD PTR $T281892[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T281863[ebp]
	mov	eax, DWORD PTR $T281892[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	push	ecx
	push	0
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z
_TEXT	SEGMENT
$T281938 = -60						; size = 8
$T281909 = -20						; size = 4
$T281903 = -12						; size = 4
$T281902 = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement>, COMDAT

; 2087 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	mov	DWORD PTR $T281903[ebp], eax
	lea	ecx, DWORD PTR $T281938[ebp]
	mov	DWORD PTR $T281902[ebp], ecx
	mov	edx, DWORD PTR $T281902[ebp]
	mov	eax, DWORD PTR $T281903[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T281902[ebp]
	mov	eax, DWORD PTR $T281903[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [edx-8], eax
	mov	DWORD PTR [edx-4], ecx
	sub	esp, 8
	mov	DWORD PTR $T281909[ebp], esp
	mov	eax, DWORD PTR $T281909[ebp]
	mov	ecx, DWORD PTR $T281938[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T281909[ebp]
	mov	eax, DWORD PTR $T281938[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	push	ecx
	push	0
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??4?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@ABVCvHomelandMove@@@Z
_TEXT	SEGMENT
tv128 = -20						; size = 4
_this$ = -16						; size = 4
$T281949 = -12						; size = 4
__Vptr$281955 = -8					; size = 4
__Ptr$235727 = -4					; size = 4
__Val$ = 8						; size = 4
??4?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@ABVCvHomelandMove@@@Z PROC ; std::_Temp_iterator<CvHomelandMove>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN2@operator@3

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+16]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+4], edx

; 565  : 		else

	jmp	SHORT $LN1@operator@3
$LN2@operator@3:

; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Ptr$235727[ebp], ecx

; 569  : 			_Construct(_Ptr, _Val);

	mov	edx, DWORD PTR __Ptr$235727[ebp]
	mov	DWORD PTR __Vptr$281955[ebp], edx
	mov	eax, DWORD PTR __Vptr$281955[ebp]
	mov	DWORD PTR $T281949[ebp], eax
	cmp	DWORD PTR $T281949[ebp], 0
	je	SHORT $LN7@operator@3
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T281949[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T281949[ebp]
	mov	DWORD PTR tv128[ebp], edx
	jmp	SHORT $LN5@operator@3
$LN7@operator@3:
	mov	DWORD PTR tv128[ebp], 0
$LN5@operator@3:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], eax
$LN1@operator@3:

; 571  : 			}
; 572  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 573  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@ABVCvHomelandMove@@@Z ENDP ; std::_Temp_iterator<CvHomelandMove>::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??4?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@ABVCvHomelandTarget@@@Z
_TEXT	SEGMENT
tv128 = -20						; size = 4
_this$ = -16						; size = 4
$T281966 = -12						; size = 4
__Vptr$281972 = -8					; size = 4
__Ptr$235742 = -4					; size = 4
__Val$ = 8						; size = 4
??4?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@ABVCvHomelandTarget@@@Z PROC ; std::_Temp_iterator<CvHomelandTarget>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN2@operator@4

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+4], edx

; 565  : 		else

	jmp	SHORT $LN1@operator@4
$LN2@operator@4:

; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Ptr$235742[ebp], ecx

; 569  : 			_Construct(_Ptr, _Val);

	mov	edx, DWORD PTR __Ptr$235742[ebp]
	mov	DWORD PTR __Vptr$281972[ebp], edx
	mov	eax, DWORD PTR __Vptr$281972[ebp]
	mov	DWORD PTR $T281966[ebp], eax
	cmp	DWORD PTR $T281966[ebp], 0
	je	SHORT $LN7@operator@4
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR $T281966[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T281966[ebp]
	mov	DWORD PTR tv128[ebp], edx
	jmp	SHORT $LN5@operator@4
$LN7@operator@4:
	mov	DWORD PTR tv128[ebp], 0
$LN5@operator@4:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], eax
$LN1@operator@4:

; 571  : 			}
; 572  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 573  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@ABVCvHomelandTarget@@@Z ENDP ; std::_Temp_iterator<CvHomelandTarget>::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABVCvHomelandUnit@@@Z
_TEXT	SEGMENT
tv128 = -20						; size = 4
_this$ = -16						; size = 4
$T281983 = -12						; size = 4
__Vptr$281989 = -8					; size = 4
__Ptr$235751 = -4					; size = 4
__Val$ = 8						; size = 4
??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABVCvHomelandUnit@@@Z PROC ; std::_Temp_iterator<CvHomelandUnit>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN2@operator@5

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+4], edx

; 565  : 		else

	jmp	SHORT $LN1@operator@5
$LN2@operator@5:

; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Ptr$235751[ebp], ecx

; 569  : 			_Construct(_Ptr, _Val);

	mov	edx, DWORD PTR __Ptr$235751[ebp]
	mov	DWORD PTR __Vptr$281989[ebp], edx
	mov	eax, DWORD PTR __Vptr$281989[ebp]
	mov	DWORD PTR $T281983[ebp], eax
	cmp	DWORD PTR $T281983[ebp], 0
	je	SHORT $LN7@operator@5
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR $T281983[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR $T281983[ebp]
	mov	DWORD PTR tv128[ebp], edx
	jmp	SHORT $LN5@operator@5
$LN7@operator@5:
	mov	DWORD PTR tv128[ebp], 0
$LN5@operator@5:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], eax
$LN1@operator@5:

; 571  : 			}
; 572  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 573  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABVCvHomelandUnit@@@Z ENDP ; std::_Temp_iterator<CvHomelandUnit>::operator=
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,std::forward_iterator_tag>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$unchecked_merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@000V12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@000V12@@Z$0
__ehfuncinfo$??$unchecked_merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@000V12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@000V12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$unchecked_merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@000V12@@Z
_TEXT	SEGMENT
tv133 = -48						; size = 4
tv132 = -44						; size = 4
$T282020 = -40						; size = 4
__Next$282023 = -36					; size = 4
$T282012 = -32						; size = 4
$T281998 = -24						; size = 4
$T281994 = -20						; size = 4
$T281993 = -14						; size = 1
$T281992 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
??$unchecked_merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@000V12@@Z PROC ; stdext::unchecked_merge<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@000V12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T281998[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T281992[ebp], al
	movzx	ecx, BYTE PTR $T281992[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T281993[ebp]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T281994[ebp], esp
	mov	DWORD PTR $T282012[ebp], eax
	mov	ecx, DWORD PTR $T282012[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T282012[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T282012[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T282012[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T282012[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T282012[ebp]
	mov	DWORD PTR tv132[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,std::forward_iterator_tag>
	add	esp, 48					; 00000030H
	mov	DWORD PTR tv133[ebp], eax
	mov	ecx, DWORD PTR $T281998[ebp]
	or	ecx, 1
	mov	DWORD PTR $T281998[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN17@unchecked_@8
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$282023[ebp], edx
	jmp	SHORT $LN15@unchecked_@8
$LN14@unchecked_@8:
	mov	eax, DWORD PTR __Next$282023[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$282023[ebp], eax
$LN15@unchecked_@8:
	mov	ecx, DWORD PTR __Next$282023[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN13@unchecked_@8
	jmp	SHORT $LN14@unchecked_@8
$LN13@unchecked_@8:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T282020[ebp], edx
	mov	eax, DWORD PTR $T282020[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@unchecked_@8:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5117 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@000V12@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandMove>::~_Temp_iterator<CvHomelandMove>
__ehhandler$??$unchecked_merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@000V12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@000V12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@000V12@@Z ENDP ; stdext::unchecked_merge<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T282064 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	ecx

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

$LN5@Copy_backw:
	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@Copy_backw

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T282064[ebp], edx
	mov	eax, DWORD PTR __Dest$[ebp]
	sub	eax, 20					; 00000014H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR $T282064[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	jmp	SHORT $LN5@Copy_backw
$LN1@Copy_backw:

; 2677 : 	return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2678 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,std::forward_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@000V12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@000V12@@Z$0
__ehfuncinfo$??$unchecked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@000V12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@000V12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$unchecked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@000V12@@Z
_TEXT	SEGMENT
tv133 = -48						; size = 4
tv132 = -44						; size = 4
$T282111 = -40						; size = 4
__Next$282114 = -36					; size = 4
$T282103 = -32						; size = 4
$T282089 = -24						; size = 4
$T282085 = -20						; size = 4
$T282084 = -14						; size = 1
$T282083 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
??$unchecked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@000V12@@Z PROC ; stdext::unchecked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@000V12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T282089[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T282083[ebp], al
	movzx	ecx, BYTE PTR $T282083[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T282084[ebp]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T282085[ebp], esp
	mov	DWORD PTR $T282103[ebp], eax
	mov	ecx, DWORD PTR $T282103[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T282103[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T282103[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T282103[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T282103[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T282103[ebp]
	mov	DWORD PTR tv132[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,std::forward_iterator_tag>
	add	esp, 48					; 00000030H
	mov	DWORD PTR tv133[ebp], eax
	mov	ecx, DWORD PTR $T282089[ebp]
	or	ecx, 1
	mov	DWORD PTR $T282089[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN17@unchecked_@9
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$282114[ebp], edx
	jmp	SHORT $LN15@unchecked_@9
$LN14@unchecked_@9:
	mov	eax, DWORD PTR __Next$282114[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __Next$282114[ebp], eax
$LN15@unchecked_@9:
	mov	ecx, DWORD PTR __Next$282114[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN13@unchecked_@9
	jmp	SHORT $LN14@unchecked_@9
$LN13@unchecked_@9:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T282111[ebp], edx
	mov	eax, DWORD PTR $T282111[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@unchecked_@9:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5117 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@000V12@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandTarget>::~_Temp_iterator<CvHomelandTarget>
__ehhandler$??$unchecked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@000V12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@000V12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@000V12@@Z ENDP ; stdext::unchecked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@000V12@@Z
_TEXT	SEGMENT
$T282132 = -2						; size = 1
$T282131 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
??$unchecked_merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@000V12@@Z PROC ; stdext::unchecked_merge<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T282131[ebp], al
	movzx	ecx, BYTE PTR $T282131[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T282132[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last1$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First1$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??$_Merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
	add	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5117 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@000V12@@Z ENDP ; stdext::unchecked_merge<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T282344 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	ecx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN14@Copy_opt@4
$LN2@Copy_opt@4:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR __First$[ebp], ecx
$LN14@Copy_opt@4:
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@Copy_opt@4

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T282344[ebp], eax
	mov	ecx, DWORD PTR $T282344[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	jmp	SHORT $LN2@Copy_opt@4
$LN1@Copy_opt@4:

; 2473 : 	return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),std::forward_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z$0
__ehfuncinfo$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z
_TEXT	SEGMENT
tv135 = -48						; size = 4
tv134 = -44						; size = 4
$T282383 = -40						; size = 4
__Next$282386 = -36					; size = 4
$T282375 = -32						; size = 4
$T282361 = -24						; size = 4
$T282357 = -20						; size = 4
$T282356 = -14						; size = 1
$T282355 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
__Pred$ = 48						; size = 4
??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z PROC ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T282361[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T282355[ebp], al
	movzx	ecx, BYTE PTR $T282355[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T282356[ebp]
	push	edx
	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T282357[ebp], esp
	mov	DWORD PTR $T282375[ebp], ecx
	mov	edx, DWORD PTR $T282375[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T282375[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T282375[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T282375[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T282375[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T282375[ebp]
	mov	DWORD PTR tv134[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),std::forward_iterator_tag>
	add	esp, 52					; 00000034H
	mov	DWORD PTR tv135[ebp], eax
	mov	edx, DWORD PTR $T282361[ebp]
	or	edx, 1
	mov	DWORD PTR $T282361[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN17@unchecked_@10
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$282386[ebp], eax
	jmp	SHORT $LN15@unchecked_@10
$LN14@unchecked_@10:
	mov	ecx, DWORD PTR __Next$282386[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Next$282386[ebp], ecx
$LN15@unchecked_@10:
	mov	edx, DWORD PTR __Next$282386[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN13@unchecked_@10
	jmp	SHORT $LN14@unchecked_@10
$LN13@unchecked_@10:
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T282383[ebp], eax
	mov	ecx, DWORD PTR $T282383[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@unchecked_@10:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5160 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
__ehhandler$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z ENDP ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
PUBLIC	??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,std::forward_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@@Z$0
__ehfuncinfo$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@@Z
_TEXT	SEGMENT
tv133 = -48						; size = 4
tv132 = -44						; size = 4
$T282431 = -40						; size = 4
__Next$282434 = -36					; size = 4
$T282423 = -32						; size = 4
$T282409 = -24						; size = 4
$T282405 = -20						; size = 4
$T282404 = -14						; size = 1
$T282403 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@@Z PROC ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T282409[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T282403[ebp], al
	movzx	ecx, BYTE PTR $T282403[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T282404[ebp]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T282405[ebp], esp
	mov	DWORD PTR $T282423[ebp], eax
	mov	ecx, DWORD PTR $T282423[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T282423[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T282423[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T282423[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T282423[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T282423[ebp]
	mov	DWORD PTR tv132[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,std::forward_iterator_tag>
	add	esp, 48					; 00000030H
	mov	DWORD PTR tv133[ebp], eax
	mov	ecx, DWORD PTR $T282409[ebp]
	or	ecx, 1
	mov	DWORD PTR $T282409[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN17@unchecked_@11
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$282434[ebp], edx
	jmp	SHORT $LN15@unchecked_@11
$LN14@unchecked_@11:
	mov	eax, DWORD PTR __Next$282434[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$282434[ebp], eax
$LN15@unchecked_@11:
	mov	ecx, DWORD PTR __Next$282434[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN13@unchecked_@11
	jmp	SHORT $LN14@unchecked_@11
$LN13@unchecked_@11:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T282431[ebp], edx
	mov	eax, DWORD PTR $T282431[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@unchecked_@11:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5117 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
__ehhandler$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@@Z ENDP ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv164 = -112						; size = 4
tv163 = -108						; size = 4
tv159 = -104						; size = 4
tv158 = -100						; size = 4
$T282553 = -96						; size = 4
__Next$282556 = -92					; size = 4
$T282545 = -88						; size = 4
$T282525 = -84						; size = 4
__Next$282528 = -80					; size = 4
$T282517 = -76						; size = 4
$T282513 = -72						; size = 4
$T282459 = -44						; size = 4
$T282453 = -40						; size = 4
$T282452 = -36						; size = 20
$T282451 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
??$_Merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,std::forward_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T282459[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
$LN5@Merge@5:

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	je	SHORT $LN3@Merge@5
	mov	ecx, DWORD PTR __First2$[ebp]
	cmp	ecx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN3@Merge@5

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	edx, DWORD PTR __First2$[ebp]
	mov	eax, DWORD PTR __First1$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN30@Merge@5

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@ABVCvHomelandMove@@@Z ; std::_Temp_iterator<CvHomelandMove>::operator=
	mov	edx, DWORD PTR __First2$[ebp]
	add	edx, 8
	mov	DWORD PTR __First2$[ebp], edx

; 2516 : 		else

	jmp	SHORT $LN1@Merge@5

; 2517 : 			*_Dest = *_First1, ++_First1;

$LN30@Merge@5:
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@ABVCvHomelandMove@@@Z ; std::_Temp_iterator<CvHomelandMove>::operator=
	mov	ecx, DWORD PTR __First1$[ebp]
	add	ecx, 8
	mov	DWORD PTR __First1$[ebp], ecx
$LN1@Merge@5:
	jmp	SHORT $LN5@Merge@5
$LN3@Merge@5:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T282451[ebp], esp
	mov	DWORD PTR $T282513[ebp], edx
	mov	eax, DWORD PTR $T282513[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T282513[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T282513[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T282513[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T282513[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T282513[ebp]
	mov	DWORD PTR tv158[ebp], eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	lea	eax, DWORD PTR $T282452[ebp]
	push	eax
	call	??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z ; stdext::unchecked_copy<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv159[ebp], eax
	mov	ecx, DWORD PTR tv159[ebp]
	mov	DWORD PTR $T282517[ebp], ecx
	mov	edx, DWORD PTR $T282517[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Dest$[ebp+16], eax
	cmp	DWORD PTR $T282452[ebp], 0
	je	SHORT $LN52@Merge@5
	mov	ecx, DWORD PTR $T282452[ebp]
	mov	DWORD PTR __Next$282528[ebp], ecx
	jmp	SHORT $LN50@Merge@5
$LN49@Merge@5:
	mov	edx, DWORD PTR __Next$282528[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$282528[ebp], edx
$LN50@Merge@5:
	mov	eax, DWORD PTR __Next$282528[ebp]
	cmp	eax, DWORD PTR $T282452[ebp+8]
	je	SHORT $LN48@Merge@5
	jmp	SHORT $LN49@Merge@5
$LN48@Merge@5:
	mov	ecx, DWORD PTR $T282452[ebp]
	mov	DWORD PTR $T282525[ebp], ecx
	mov	edx, DWORD PTR $T282525[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN52@Merge@5:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T282453[ebp], esp
	mov	DWORD PTR $T282545[ebp], eax
	mov	ecx, DWORD PTR $T282545[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T282545[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T282545[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T282545[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T282545[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T282545[ebp]
	mov	DWORD PTR tv163[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z ; stdext::unchecked_copy<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv164[ebp], eax
	mov	edx, DWORD PTR $T282459[ebp]
	or	edx, 1
	mov	DWORD PTR $T282459[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN66@Merge@5
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$282556[ebp], eax
	jmp	SHORT $LN64@Merge@5
$LN63@Merge@5:
	mov	ecx, DWORD PTR __Next$282556[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$282556[ebp], ecx
$LN64@Merge@5:
	mov	edx, DWORD PTR __Next$282556[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN62@Merge@5
	jmp	SHORT $LN63@Merge@5
$LN62@Merge@5:
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T282553[ebp], eax
	mov	ecx, DWORD PTR $T282553[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN66@Merge@5:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2521 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandMove>::~_Temp_iterator<CvHomelandMove>
__ehhandler$??$_Merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Rotate@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00PAH0@Z
_TEXT	SEGMENT
tv128 = -44						; size = 4
tv83 = -40						; size = 4
__Hole$236124 = -36					; size = 4
__Holeval$236126 = -32					; size = 8
__Next1$236127 = -24					; size = 4
__Next$236125 = -20					; size = 4
__Tmp$236119 = -16					; size = 4
__Factor$236115 = -12					; size = 4
__Shift$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00PAH0@Z PROC ; std::_Rotate<CvHomelandMove *,int,CvHomelandMove>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	eax, DWORD PTR __Mid$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Shift$[ebp], eax

; 1683 : 	_Diff _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	mov	DWORD PTR __Count$[ebp], ecx

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	edx, DWORD PTR __Shift$[ebp]
	mov	DWORD PTR __Factor$236115[ebp], edx
$LN8@Rotate:
	cmp	DWORD PTR __Factor$236115[ebp], 0
	je	SHORT $LN7@Rotate

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	idiv	DWORD PTR __Factor$236115[ebp]
	mov	DWORD PTR __Tmp$236119[ebp], edx

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	eax, DWORD PTR __Factor$236115[ebp]
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __Tmp$236119[ebp]
	mov	DWORD PTR __Factor$236115[ebp], ecx

; 1689 : 		}

	jmp	SHORT $LN8@Rotate
$LN7@Rotate:

; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	DWORD PTR __Count$[ebp], edx
	jge	$LN9@Rotate

; 1692 : 		for (; 0 < _Count; --_Count)

	jmp	SHORT $LN5@Rotate
$LN4@Rotate:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN5@Rotate:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	$LN9@Rotate

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Hole$236124[ebp], eax

; 1695 : 			_RanIt _Next = _Hole;

	mov	ecx, DWORD PTR __Hole$236124[ebp]
	mov	DWORD PTR __Next$236125[ebp], ecx

; 1696 : 			_Ty _Holeval = *_Hole;

	mov	edx, DWORD PTR __Hole$236124[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Holeval$236126[ebp], eax
	mov	DWORD PTR __Holeval$236126[ebp+4], ecx

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	mov	edx, DWORD PTR __Shift$[ebp]
	mov	eax, DWORD PTR __Next$236125[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN11@Rotate
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN12@Rotate
$LN11@Rotate:
	mov	eax, DWORD PTR __Shift$[ebp]
	mov	ecx, DWORD PTR __Next$236125[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR tv83[ebp], edx
$LN12@Rotate:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR __Next1$236127[ebp], eax
$LN2@Rotate:

; 1698 : 			while (_Next1 != _Hole)

	mov	ecx, DWORD PTR __Next1$236127[ebp]
	cmp	ecx, DWORD PTR __Hole$236124[ebp]
	je	SHORT $LN1@Rotate

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	edx, DWORD PTR __Next1$236127[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Next$236125[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx

; 1701 : 				_Next = _Next1;

	mov	eax, DWORD PTR __Next1$236127[ebp]
	mov	DWORD PTR __Next$236125[ebp], eax

; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR __Next1$236127[ebp]
	sar	ecx, 3
	cmp	DWORD PTR __Shift$[ebp], ecx
	jge	SHORT $LN13@Rotate
	mov	edx, DWORD PTR __Shift$[ebp]
	mov	eax, DWORD PTR __Next1$236127[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR tv128[ebp], ecx
	jmp	SHORT $LN14@Rotate
$LN13@Rotate:
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Next1$236127[ebp]
	sar	edx, 3
	mov	eax, DWORD PTR __Shift$[ebp]
	sub	eax, edx
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR tv128[ebp], edx
$LN14@Rotate:
	mov	eax, DWORD PTR tv128[ebp]
	mov	DWORD PTR __Next1$236127[ebp], eax

; 1704 : 				}

	jmp	SHORT $LN2@Rotate
$LN1@Rotate:

; 1705 : 			*_Next = _Holeval;

	mov	ecx, DWORD PTR __Next$236125[ebp]
	mov	edx, DWORD PTR __Holeval$236126[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Holeval$236126[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 1706 : 			}

	jmp	$LN4@Rotate
$LN9@Rotate:

; 1707 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rotate@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00PAH0@Z ENDP ; std::_Rotate<CvHomelandMove *,int,CvHomelandMove>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv196 = -128						; size = 4
tv195 = -124						; size = 4
tv191 = -120						; size = 4
tv190 = -116						; size = 4
$T282749 = -112						; size = 4
__Next$282752 = -108					; size = 4
$T282741 = -104						; size = 4
$T282721 = -100						; size = 4
__Next$282724 = -96					; size = 4
$T282713 = -92						; size = 4
$T282709 = -88						; size = 4
$T282673 = -72						; size = 4
$T282637 = -56						; size = 4
$T282625 = -52						; size = 4
$T282616 = -48						; size = 4
$T282587 = -44						; size = 4
$T282581 = -40						; size = 4
$T282580 = -36						; size = 20
$T282579 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
??$_Merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,std::forward_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T282587[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

$LN16@Merge@6:
	mov	eax, DWORD PTR __First1$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last1$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN3@Merge@6
	mov	ecx, DWORD PTR __First2$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR __Last2$[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@Merge@6

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	edx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T282616[ebp], edx
	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T282625[ebp], eax
	mov	ecx, DWORD PTR $T282625[ebp]
	mov	edx, DWORD PTR $T282616[ebp]
	mov	eax, DWORD PTR [ecx+16]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+16]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN56@Merge@6

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T282637[ebp], eax
	mov	ecx, DWORD PTR $T282637[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@ABVCvHomelandTarget@@@Z ; std::_Temp_iterator<CvHomelandTarget>::operator=
	mov	edx, DWORD PTR __First2$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __First2$[ebp], edx

; 2516 : 		else

	jmp	SHORT $LN1@Merge@6

; 2517 : 			*_Dest = *_First1, ++_First1;

$LN56@Merge@6:
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T282673[ebp], eax
	mov	ecx, DWORD PTR $T282673[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@ABVCvHomelandTarget@@@Z ; std::_Temp_iterator<CvHomelandTarget>::operator=
	mov	edx, DWORD PTR __First1$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __First1$[ebp], edx
$LN1@Merge@6:
	jmp	$LN16@Merge@6
$LN3@Merge@6:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T282579[ebp], esp
	mov	DWORD PTR $T282709[ebp], eax
	mov	ecx, DWORD PTR $T282709[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T282709[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T282709[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T282709[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T282709[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T282709[ebp]
	mov	DWORD PTR tv190[ebp], ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T282580[ebp]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv191[ebp], eax
	mov	edx, DWORD PTR tv191[ebp]
	mov	DWORD PTR $T282713[ebp], edx
	mov	eax, DWORD PTR $T282713[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Dest$[ebp+16], ecx
	cmp	DWORD PTR $T282580[ebp], 0
	je	SHORT $LN84@Merge@6
	mov	edx, DWORD PTR $T282580[ebp]
	mov	DWORD PTR __Next$282724[ebp], edx
	jmp	SHORT $LN82@Merge@6
$LN81@Merge@6:
	mov	eax, DWORD PTR __Next$282724[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __Next$282724[ebp], eax
$LN82@Merge@6:
	mov	ecx, DWORD PTR __Next$282724[ebp]
	cmp	ecx, DWORD PTR $T282580[ebp+8]
	je	SHORT $LN80@Merge@6
	jmp	SHORT $LN81@Merge@6
$LN80@Merge@6:
	mov	edx, DWORD PTR $T282580[ebp]
	mov	DWORD PTR $T282721[ebp], edx
	mov	eax, DWORD PTR $T282721[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN84@Merge@6:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T282581[ebp], esp
	mov	DWORD PTR $T282741[ebp], ecx
	mov	edx, DWORD PTR $T282741[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T282741[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T282741[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T282741[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T282741[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T282741[ebp]
	mov	DWORD PTR tv195[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv196[ebp], eax
	mov	eax, DWORD PTR $T282587[ebp]
	or	eax, 1
	mov	DWORD PTR $T282587[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN98@Merge@6
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$282752[ebp], ecx
	jmp	SHORT $LN96@Merge@6
$LN95@Merge@6:
	mov	edx, DWORD PTR __Next$282752[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __Next$282752[ebp], edx
$LN96@Merge@6:
	mov	eax, DWORD PTR __Next$282752[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN94@Merge@6
	jmp	SHORT $LN95@Merge@6
$LN94@Merge@6:
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T282749[ebp], ecx
	mov	edx, DWORD PTR $T282749[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN98@Merge@6:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2521 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandTarget>::~_Temp_iterator<CvHomelandTarget>
__ehhandler$??$_Merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-120]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T282940 = -60						; size = 4
$T282939 = -56						; size = 4
$T282914 = -50						; size = 1
$T282913 = -49						; size = 1
$T282912 = -48						; size = 4
$T282911 = -44						; size = 4
__Cat$282921 = -36					; size = 1
$T282918 = -35						; size = 1
$T282917 = -34						; size = 1
$T282916 = -33						; size = 1
$T282868 = -32						; size = 4
$T282867 = -28						; size = 4
$T282842 = -22						; size = 1
$T282841 = -21						; size = 1
$T282840 = -20						; size = 4
$T282839 = -16						; size = 4
__Cat$282849 = -8					; size = 1
$T282846 = -7						; size = 1
$T282845 = -6						; size = 1
$T282844 = -5						; size = 1
$T282769 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
___formal$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	jmp	SHORT $LN5@Merge@7
$LN4@Merge@7:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __Dest$[ebp], eax
$LN5@Merge@7:
	mov	ecx, DWORD PTR __First1$[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	SHORT $LN3@Merge@7
	mov	edx, DWORD PTR __First2$[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN3@Merge@7

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	eax, DWORD PTR __First2$[ebp]
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	edx, DWORD PTR [eax+16]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+16]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN18@Merge@7

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	edx, DWORD PTR __First2$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __First2$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __First2$[ebp], eax

; 2516 : 		else

	jmp	SHORT $LN1@Merge@7

; 2517 : 			*_Dest = *_First1, ++_First1;

$LN18@Merge@7:
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR __First1$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __First1$[ebp], edx
$LN1@Merge@7:
	jmp	$LN4@Merge@7
$LN3@Merge@7:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T282868[ebp], eax
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T282867[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T282844[ebp], dl
	mov	al, BYTE PTR __Cat$282849[ebp]
	mov	BYTE PTR $T282845[ebp], al
	mov	cl, BYTE PTR $T282844[ebp]
	mov	BYTE PTR $T282842[ebp], cl
	mov	dl, BYTE PTR $T282846[ebp]
	mov	BYTE PTR $T282841[ebp], dl
	mov	eax, DWORD PTR $T282868[ebp]
	mov	DWORD PTR $T282840[ebp], eax
	mov	ecx, DWORD PTR $T282867[ebp]
	mov	DWORD PTR $T282839[ebp], ecx
	jmp	SHORT $LN30@Merge@7
$LN29@Merge@7:
	mov	edx, DWORD PTR $T282840[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T282840[ebp], edx
	mov	eax, DWORD PTR $T282839[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T282839[ebp], eax
$LN30@Merge@7:
	mov	ecx, DWORD PTR $T282839[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	SHORT $LN28@Merge@7
	mov	edx, DWORD PTR $T282839[ebp]
	mov	eax, DWORD PTR $T282840[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	jmp	SHORT $LN29@Merge@7
$LN28@Merge@7:
	mov	eax, DWORD PTR $T282840[ebp]
	mov	DWORD PTR $T282769[ebp], eax
	mov	ecx, DWORD PTR $T282769[ebp]
	mov	DWORD PTR __Dest$[ebp], ecx

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T282940[ebp], edx
	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T282939[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T282916[ebp], cl
	mov	dl, BYTE PTR __Cat$282921[ebp]
	mov	BYTE PTR $T282917[ebp], dl
	mov	al, BYTE PTR $T282916[ebp]
	mov	BYTE PTR $T282914[ebp], al
	mov	cl, BYTE PTR $T282918[ebp]
	mov	BYTE PTR $T282913[ebp], cl
	mov	edx, DWORD PTR $T282940[ebp]
	mov	DWORD PTR $T282912[ebp], edx
	mov	eax, DWORD PTR $T282939[ebp]
	mov	DWORD PTR $T282911[ebp], eax
	jmp	SHORT $LN49@Merge@7
$LN48@Merge@7:
	mov	ecx, DWORD PTR $T282912[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T282912[ebp], ecx
	mov	edx, DWORD PTR $T282911[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T282911[ebp], edx
$LN49@Merge@7:
	mov	eax, DWORD PTR $T282911[ebp]
	cmp	eax, DWORD PTR __Last2$[ebp]
	je	SHORT $LN47@Merge@7
	mov	ecx, DWORD PTR $T282911[ebp]
	mov	edx, DWORD PTR $T282912[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	jmp	SHORT $LN48@Merge@7
$LN47@Merge@7:
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR $T282912[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2521 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00PAHPAVCvHomelandTarget@@@Z
_TEXT	SEGMENT
tv193 = -108						; size = 4
tv149 = -104						; size = 4
__Tmp$283104 = -100					; size = 4
$T283093 = -96						; size = 4
__Tmp$283079 = -92					; size = 4
$T283052 = -88						; size = 4
__Tmp$283030 = -84					; size = 4
__Tmp$283011 = -80					; size = 4
__Tmp$282987 = -76					; size = 4
$T282950 = -72						; size = 4
$T282949 = -68						; size = 4
$T282948 = -64						; size = 4
$T282945 = -60						; size = 4
$T282944 = -56						; size = 4
$T282943 = -52						; size = 4
__Hole$236186 = -48					; size = 4
__Holeval$236189 = -44					; size = 20
__Next1$236190 = -24					; size = 4
__Next$236188 = -20					; size = 4
__Tmp$236181 = -16					; size = 4
__Factor$236177 = -12					; size = 4
__Shift$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00PAHPAVCvHomelandTarget@@@Z PROC ; std::_Rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	eax, DWORD PTR __Mid$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR __Shift$[ebp], eax

; 1683 : 	_Diff _Count = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR __Count$[ebp], eax

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	edx, DWORD PTR __Shift$[ebp]
	mov	DWORD PTR __Factor$236177[ebp], edx
$LN8@Rotate@2:
	cmp	DWORD PTR __Factor$236177[ebp], 0
	je	SHORT $LN23@Rotate@2

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	idiv	DWORD PTR __Factor$236177[ebp]
	mov	DWORD PTR __Tmp$236181[ebp], edx

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	eax, DWORD PTR __Factor$236177[ebp]
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __Tmp$236181[ebp]
	mov	DWORD PTR __Factor$236177[ebp], ecx

; 1689 : 		}

	jmp	SHORT $LN8@Rotate@2

; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

$LN23@Rotate@2:
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	cmp	DWORD PTR __Count$[ebp], eax
	jge	$LN9@Rotate@2

; 1692 : 		for (; 0 < _Count; --_Count)

	jmp	SHORT $LN5@Rotate@2
$LN4@Rotate@2:
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Count$[ebp], edx
$LN5@Rotate@2:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	$LN9@Rotate@2

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$282987[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR __Tmp$282987[ebp]
	mov	DWORD PTR __Tmp$282987[ebp], ecx
	mov	edx, DWORD PTR __Tmp$282987[ebp]
	mov	DWORD PTR __Hole$236186[ebp], edx

; 1695 : 			_RanIt _Next = _Hole;

	mov	eax, DWORD PTR __Hole$236186[ebp]
	mov	DWORD PTR __Next$236188[ebp], eax

; 1696 : 			_Ty _Holeval = *_Hole;

	mov	ecx, DWORD PTR __Hole$236186[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Holeval$236189[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Holeval$236189[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Holeval$236189[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Holeval$236189[ebp+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Holeval$236189[ebp+16], ecx

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	mov	edx, DWORD PTR __Next$236188[ebp]
	mov	DWORD PTR __Tmp$283011[ebp], edx
	mov	eax, DWORD PTR __Shift$[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Tmp$283011[ebp]
	mov	DWORD PTR __Tmp$283011[ebp], eax
	mov	ecx, DWORD PTR __Tmp$283011[ebp]
	mov	DWORD PTR $T282944[ebp], ecx
	mov	edx, DWORD PTR $T282944[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@Rotate@2
	lea	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN12@Rotate@2
$LN11@Rotate@2:
	mov	eax, DWORD PTR __Next$236188[ebp]
	mov	DWORD PTR __Tmp$283030[ebp], eax
	mov	ecx, DWORD PTR __Shift$[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR __Tmp$283030[ebp]
	mov	DWORD PTR __Tmp$283030[ebp], ecx
	mov	edx, DWORD PTR __Tmp$283030[ebp]
	mov	DWORD PTR $T282945[ebp], edx
	lea	eax, DWORD PTR $T282945[ebp]
	mov	DWORD PTR tv149[ebp], eax
$LN12@Rotate@2:
	mov	ecx, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T282943[ebp], ecx
	mov	edx, DWORD PTR $T282943[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Next1$236190[ebp], eax

; 1698 : 			while (_Next1 != _Hole)

$LN51@Rotate@2:
	mov	ecx, DWORD PTR __Next1$236190[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR __Hole$236186[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN83@Rotate@2

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	edx, DWORD PTR __Next1$236190[ebp]
	mov	DWORD PTR $T283052[ebp], edx
	mov	eax, DWORD PTR $T283052[ebp]
	mov	ecx, DWORD PTR __Next$236188[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax

; 1701 : 				_Next = _Next1;

	mov	ecx, DWORD PTR __Next1$236190[ebp]
	mov	DWORD PTR __Next$236188[ebp], ecx

; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __Next1$236190[ebp]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	cmp	DWORD PTR __Shift$[ebp], eax
	jge	SHORT $LN75@Rotate@2
	mov	edx, DWORD PTR __Next1$236190[ebp]
	mov	DWORD PTR __Tmp$283079[ebp], edx
	mov	eax, DWORD PTR __Shift$[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Tmp$283079[ebp]
	mov	DWORD PTR __Tmp$283079[ebp], eax
	mov	ecx, DWORD PTR __Tmp$283079[ebp]
	mov	DWORD PTR $T282949[ebp], ecx
	lea	edx, DWORD PTR $T282949[ebp]
	mov	DWORD PTR tv193[ebp], edx
	jmp	SHORT $LN14@Rotate@2
$LN75@Rotate@2:
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __Next1$236190[ebp]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR $T283093[ebp], eax
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$283104[ebp], edx
	mov	eax, DWORD PTR __Shift$[ebp]
	sub	eax, DWORD PTR $T283093[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Tmp$283104[ebp]
	mov	DWORD PTR __Tmp$283104[ebp], eax
	mov	ecx, DWORD PTR __Tmp$283104[ebp]
	mov	DWORD PTR $T282950[ebp], ecx
	lea	edx, DWORD PTR $T282950[ebp]
	mov	DWORD PTR tv193[ebp], edx
$LN14@Rotate@2:
	mov	eax, DWORD PTR tv193[ebp]
	mov	DWORD PTR $T282948[ebp], eax
	mov	ecx, DWORD PTR $T282948[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Next1$236190[ebp], edx

; 1704 : 				}

	jmp	$LN51@Rotate@2

; 1705 : 			*_Next = _Holeval;

$LN83@Rotate@2:
	mov	eax, DWORD PTR __Next$236188[ebp]
	mov	ecx, DWORD PTR __Holeval$236189[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Holeval$236189[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Holeval$236189[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Holeval$236189[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR __Holeval$236189[ebp+16]
	mov	DWORD PTR [eax+16], ecx

; 1706 : 			}

	jmp	$LN4@Rotate@2
$LN9@Rotate@2:

; 1707 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00PAHPAVCvHomelandTarget@@@Z ENDP ; std::_Rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv164 = -112						; size = 4
tv163 = -108						; size = 4
tv159 = -104						; size = 4
tv158 = -100						; size = 4
$T283219 = -96						; size = 4
__Next$283222 = -92					; size = 4
$T283211 = -88						; size = 4
$T283191 = -84						; size = 4
__Next$283194 = -80					; size = 4
$T283183 = -76						; size = 4
$T283179 = -72						; size = 4
$T283128 = -44						; size = 4
$T283122 = -40						; size = 4
$T283121 = -36						; size = 20
$T283120 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
__Pred$ = 48						; size = 4
___formal$ = 52						; size = 1
___formal$ = 56						; size = 1
??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),std::forward_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T283128[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
$LN5@Merge@8:

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	je	$LN3@Merge@8
	mov	ecx, DWORD PTR __First2$[ebp]
	cmp	ecx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN3@Merge@8

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	edx, DWORD PTR __First1$[ebp]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR __First2$[ebp]
	sub	esp, 16					; 00000010H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	call	DWORD PTR __Pred$[ebp]
	add	esp, 32					; 00000020H
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN28@Merge@8

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABVCvHomelandUnit@@@Z ; std::_Temp_iterator<CvHomelandUnit>::operator=
	mov	eax, DWORD PTR __First2$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __First2$[ebp], eax

; 2600 : 		else

	jmp	SHORT $LN1@Merge@8

; 2601 : 			*_Dest = *_First1, ++_First1;

$LN28@Merge@8:
	mov	ecx, DWORD PTR __First1$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABVCvHomelandUnit@@@Z ; std::_Temp_iterator<CvHomelandUnit>::operator=
	mov	edx, DWORD PTR __First1$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First1$[ebp], edx
$LN1@Merge@8:
	jmp	$LN5@Merge@8
$LN3@Merge@8:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T283120[ebp], esp
	mov	DWORD PTR $T283179[ebp], eax
	mov	ecx, DWORD PTR $T283179[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T283179[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T283179[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T283179[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T283179[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T283179[ebp]
	mov	DWORD PTR tv158[ebp], ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T283121[ebp]
	push	ecx
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv159[ebp], eax
	mov	edx, DWORD PTR tv159[ebp]
	mov	DWORD PTR $T283183[ebp], edx
	mov	eax, DWORD PTR $T283183[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Dest$[ebp+16], ecx
	cmp	DWORD PTR $T283121[ebp], 0
	je	SHORT $LN50@Merge@8
	mov	edx, DWORD PTR $T283121[ebp]
	mov	DWORD PTR __Next$283194[ebp], edx
	jmp	SHORT $LN48@Merge@8
$LN47@Merge@8:
	mov	eax, DWORD PTR __Next$283194[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$283194[ebp], eax
$LN48@Merge@8:
	mov	ecx, DWORD PTR __Next$283194[ebp]
	cmp	ecx, DWORD PTR $T283121[ebp+8]
	je	SHORT $LN46@Merge@8
	jmp	SHORT $LN47@Merge@8
$LN46@Merge@8:
	mov	edx, DWORD PTR $T283121[ebp]
	mov	DWORD PTR $T283191[ebp], edx
	mov	eax, DWORD PTR $T283191[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN50@Merge@8:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T283122[ebp], esp
	mov	DWORD PTR $T283211[ebp], ecx
	mov	edx, DWORD PTR $T283211[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T283211[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T283211[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T283211[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T283211[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T283211[ebp]
	mov	DWORD PTR tv163[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv164[ebp], eax
	mov	eax, DWORD PTR $T283128[ebp]
	or	eax, 1
	mov	DWORD PTR $T283128[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN64@Merge@8
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$283222[ebp], ecx
	jmp	SHORT $LN62@Merge@8
$LN61@Merge@8:
	mov	edx, DWORD PTR __Next$283222[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Next$283222[ebp], edx
$LN62@Merge@8:
	mov	eax, DWORD PTR __Next$283222[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN60@Merge@8
	jmp	SHORT $LN61@Merge@8
$LN60@Merge@8:
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T283219[ebp], ecx
	mov	edx, DWORD PTR $T283219[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN64@Merge@8:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2605 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
__ehhandler$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Rotate@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00PAH0@Z
_TEXT	SEGMENT
tv128 = -52						; size = 4
tv83 = -48						; size = 4
__Hole$236232 = -44					; size = 4
__Holeval$236234 = -40					; size = 16
__Next1$236235 = -24					; size = 4
__Next$236233 = -20					; size = 4
__Tmp$236227 = -16					; size = 4
__Factor$236223 = -12					; size = 4
__Shift$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00PAH0@Z PROC ; std::_Rotate<CvHomelandUnit *,int,CvHomelandUnit>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	eax, DWORD PTR __Mid$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	mov	DWORD PTR __Shift$[ebp], eax

; 1683 : 	_Diff _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 4
	mov	DWORD PTR __Count$[ebp], ecx

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	edx, DWORD PTR __Shift$[ebp]
	mov	DWORD PTR __Factor$236223[ebp], edx
$LN8@Rotate@3:
	cmp	DWORD PTR __Factor$236223[ebp], 0
	je	SHORT $LN7@Rotate@3

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	idiv	DWORD PTR __Factor$236223[ebp]
	mov	DWORD PTR __Tmp$236227[ebp], edx

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	eax, DWORD PTR __Factor$236223[ebp]
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __Tmp$236227[ebp]
	mov	DWORD PTR __Factor$236223[ebp], ecx

; 1689 : 		}

	jmp	SHORT $LN8@Rotate@3
$LN7@Rotate@3:

; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 4
	cmp	DWORD PTR __Count$[ebp], edx
	jge	$LN9@Rotate@3

; 1692 : 		for (; 0 < _Count; --_Count)

	jmp	SHORT $LN5@Rotate@3
$LN4@Rotate@3:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN5@Rotate@3:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	$LN9@Rotate@3

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Hole$236232[ebp], ecx

; 1695 : 			_RanIt _Next = _Hole;

	mov	edx, DWORD PTR __Hole$236232[ebp]
	mov	DWORD PTR __Next$236233[ebp], edx

; 1696 : 			_Ty _Holeval = *_Hole;

	mov	eax, DWORD PTR __Hole$236232[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Holeval$236234[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Holeval$236234[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Holeval$236234[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR __Holeval$236234[ebp+12], edx

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	mov	eax, DWORD PTR __Shift$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Next$236233[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	SHORT $LN11@Rotate@3
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN12@Rotate@3
$LN11@Rotate@3:
	mov	edx, DWORD PTR __Shift$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Next$236233[ebp]
	mov	DWORD PTR tv83[ebp], edx
$LN12@Rotate@3:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR __Next1$236235[ebp], eax
$LN2@Rotate@3:

; 1698 : 			while (_Next1 != _Hole)

	mov	ecx, DWORD PTR __Next1$236235[ebp]
	cmp	ecx, DWORD PTR __Hole$236232[ebp]
	je	SHORT $LN1@Rotate@3

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	edx, DWORD PTR __Next1$236235[ebp]
	mov	eax, DWORD PTR __Next$236233[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx

; 1701 : 				_Next = _Next1;

	mov	eax, DWORD PTR __Next1$236235[ebp]
	mov	DWORD PTR __Next$236233[ebp], eax

; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR __Next1$236235[ebp]
	sar	ecx, 4
	cmp	DWORD PTR __Shift$[ebp], ecx
	jge	SHORT $LN13@Rotate@3
	mov	edx, DWORD PTR __Shift$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Next1$236235[ebp]
	mov	DWORD PTR tv128[ebp], edx
	jmp	SHORT $LN14@Rotate@3
$LN13@Rotate@3:
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __Next1$236235[ebp]
	sar	eax, 4
	mov	ecx, DWORD PTR __Shift$[ebp]
	sub	ecx, eax
	shl	ecx, 4
	add	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR tv128[ebp], ecx
$LN14@Rotate@3:
	mov	edx, DWORD PTR tv128[ebp]
	mov	DWORD PTR __Next1$236235[ebp], edx

; 1704 : 				}

	jmp	SHORT $LN2@Rotate@3
$LN1@Rotate@3:

; 1705 : 			*_Next = _Holeval;

	mov	eax, DWORD PTR __Next$236233[ebp]
	mov	ecx, DWORD PTR __Holeval$236234[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Holeval$236234[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Holeval$236234[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Holeval$236234[ebp+12]
	mov	DWORD PTR [eax+12], edx

; 1706 : 			}

	jmp	$LN4@Rotate@3
$LN9@Rotate@3:

; 1707 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rotate@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00PAH0@Z ENDP ; std::_Rotate<CvHomelandUnit *,int,CvHomelandUnit>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv164 = -120						; size = 4
tv163 = -116						; size = 4
tv159 = -112						; size = 4
tv158 = -108						; size = 4
$T283359 = -104						; size = 4
__Next$283362 = -100					; size = 4
$T283351 = -96						; size = 4
$T283331 = -92						; size = 4
__Next$283334 = -88					; size = 4
$T283323 = -84						; size = 4
$T283319 = -80						; size = 4
$T283266 = -52						; size = 4
$T283262 = -48						; size = 4
$T283253 = -44						; size = 4
$T283247 = -40						; size = 4
$T283246 = -36						; size = 20
$T283245 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,std::forward_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T283253[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
$LN5@Merge@9:

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	je	SHORT $LN3@Merge@9
	mov	ecx, DWORD PTR __First2$[ebp]
	cmp	ecx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN3@Merge@9

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	edx, DWORD PTR __First2$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T283262[ebp], eax
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T283266[ebp], edx
	mov	eax, DWORD PTR $T283262[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T283266[ebp]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN34@Merge@9

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABVCvHomelandUnit@@@Z ; std::_Temp_iterator<CvHomelandUnit>::operator=
	mov	ecx, DWORD PTR __First2$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __First2$[ebp], ecx

; 2516 : 		else

	jmp	SHORT $LN1@Merge@9

; 2517 : 			*_Dest = *_First1, ++_First1;

$LN34@Merge@9:
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABVCvHomelandUnit@@@Z ; std::_Temp_iterator<CvHomelandUnit>::operator=
	mov	eax, DWORD PTR __First1$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __First1$[ebp], eax
$LN1@Merge@9:
	jmp	SHORT $LN5@Merge@9
$LN3@Merge@9:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T283245[ebp], esp
	mov	DWORD PTR $T283319[ebp], ecx
	mov	edx, DWORD PTR $T283319[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T283319[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T283319[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T283319[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T283319[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T283319[ebp]
	mov	DWORD PTR tv158[ebp], edx
	mov	eax, DWORD PTR __Last1$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First1$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T283246[ebp]
	push	edx
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv159[ebp], eax
	mov	eax, DWORD PTR tv159[ebp]
	mov	DWORD PTR $T283323[ebp], eax
	mov	ecx, DWORD PTR $T283323[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Dest$[ebp+16], edx
	cmp	DWORD PTR $T283246[ebp], 0
	je	SHORT $LN56@Merge@9
	mov	eax, DWORD PTR $T283246[ebp]
	mov	DWORD PTR __Next$283334[ebp], eax
	jmp	SHORT $LN54@Merge@9
$LN53@Merge@9:
	mov	ecx, DWORD PTR __Next$283334[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Next$283334[ebp], ecx
$LN54@Merge@9:
	mov	edx, DWORD PTR __Next$283334[ebp]
	cmp	edx, DWORD PTR $T283246[ebp+8]
	je	SHORT $LN52@Merge@9
	jmp	SHORT $LN53@Merge@9
$LN52@Merge@9:
	mov	eax, DWORD PTR $T283246[ebp]
	mov	DWORD PTR $T283331[ebp], eax
	mov	ecx, DWORD PTR $T283331[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN56@Merge@9:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T283247[ebp], esp
	mov	DWORD PTR $T283351[ebp], edx
	mov	eax, DWORD PTR $T283351[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T283351[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T283351[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T283351[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T283351[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T283351[ebp]
	mov	DWORD PTR tv163[ebp], eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv164[ebp], eax
	mov	ecx, DWORD PTR $T283253[ebp]
	or	ecx, 1
	mov	DWORD PTR $T283253[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN70@Merge@9
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$283362[ebp], edx
	jmp	SHORT $LN68@Merge@9
$LN67@Merge@9:
	mov	eax, DWORD PTR __Next$283362[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$283362[ebp], eax
$LN68@Merge@9:
	mov	ecx, DWORD PTR __Next$283362[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN66@Merge@9
	jmp	SHORT $LN67@Merge@9
$LN66@Merge@9:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T283359[ebp], edx
	mov	eax, DWORD PTR $T283359[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN70@Merge@9:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2521 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
__ehhandler$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,std::forward_iterator_tag>
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T283387 = -4						; size = 4
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 244  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@isCity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T283387[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T283387[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN2@isCity
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al
$LN2@isCity:

; 249  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T283393 = -4						; size = 4
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 532  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@getPlotCit
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T283393[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T283393[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN2@getPlotCit
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax
$LN2@getPlotCit:

; 537  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 87   : {

	push	ebp
	mov	ebp, esp

; 88   : 	if(bWrap)

	movzx	eax, BYTE PTR _bWrap$[ebp]
	test	eax, eax
	je	SHORT $LN4@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)

	cmp	DWORD PTR _iCoord$[ebp], 0
	jge	SHORT $LN3@coordRange

; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	add	edx, DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
	jmp	SHORT $LN4@coordRange
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	mov	ecx, DWORD PTR _iCoord$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jl	SHORT $LN4@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
$LN4@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;

	mov	eax, DWORD PTR _iCoord$[ebp]
$LN5@coordRange:

; 101  : }

	pop	ebp
	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T283407 = -8						; size = 4
$T283403 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T283403[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T283403[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T283407[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T283407[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
