; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvWonderProductionAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??1?$CvWeightedVector@H$0IH@$00@@QAE@XZ		; CvWeightedVector<int,135,1>::~CvWeightedVector<int,135,1>
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>::FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>
PUBLIC	??_7CvWonderProductionAI@@6B@			; CvWonderProductionAI::`vftable'
PUBLIC	??0CvWonderProductionAI@@QAE@PAVCvPlayer@@PAVCvBuildingXMLEntries@@@Z ; CvWonderProductionAI::CvWonderProductionAI
PUBLIC	?FlavorUpdate@CvWonderProductionAI@@UAEXXZ	; CvWonderProductionAI::FlavorUpdate
PUBLIC	?LogFlavors@CvWonderProductionAI@@UAEXW4FlavorTypes@@@Z ; CvWonderProductionAI::LogFlavors
EXTRN	??1CvFlavorRecipient@@QAE@XZ:PROC		; CvFlavorRecipient::~CvFlavorRecipient
EXTRN	??0CvFlavorRecipient@@QAE@XZ:PROC		; CvFlavorRecipient::CvFlavorRecipient
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	?Init@CvFlavorRecipient@@UAEXXZ:PROC		; CvFlavorRecipient::Init
EXTRN	?Uninit@CvFlavorRecipient@@UAEXXZ:PROC		; CvFlavorRecipient::Uninit
;	COMDAT ??_7CvWonderProductionAI@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_7CvWonderProductionAI@@6B@ DD FLAT:?Init@CvFlavorRecipient@@UAEXXZ ; CvWonderProductionAI::`vftable'
	DD	FLAT:?Uninit@CvFlavorRecipient@@UAEXXZ
	DD	FLAT:?FlavorUpdate@CvWonderProductionAI@@UAEXXZ
	DD	FLAT:?LogFlavors@CvWonderProductionAI@@UAEXW4FlavorTypes@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvWonderProductionAI@@QAE@PAVCvPlayer@@PAVCvBuildingXMLEntries@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvWonderProductionAI@@QAE@PAVCvPlayer@@PAVCvBuildingXMLEntries@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvWonderProductionAI@@QAE@PAVCvPlayer@@PAVCvBuildingXMLEntries@@@Z$1
__ehfuncinfo$??0CvWonderProductionAI@@QAE@PAVCvPlayer@@PAVCvBuildingXMLEntries@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CvWonderProductionAI@@QAE@PAVCvPlayer@@PAVCvBuildingXMLEntries@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvwonderproductionai.cpp
xdata$x	ENDS
;	COMDAT ??0CvWonderProductionAI@@QAE@PAVCvPlayer@@PAVCvBuildingXMLEntries@@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T224202 = -36						; size = 4
$T224185 = -24						; size = 4
__$EHRec$ = -12						; size = 12
_pPlayer$ = 8						; size = 4
_pBuildings$ = 12					; size = 4
??0CvWonderProductionAI@@QAE@PAVCvPlayer@@PAVCvBuildingXMLEntries@@@Z PROC ; CvWonderProductionAI::CvWonderProductionAI, COMDAT
; _this$ = ecx

; 25   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvWonderProductionAI@@QAE@PAVCvPlayer@@PAVCvBuildingXMLEntries@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvFlavorRecipient@@QAE@XZ		; CvFlavorRecipient::CvFlavorRecipient
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvWonderProductionAI@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pBuildings$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T224185[ebp], edx
	mov	ecx, DWORD PTR $T224185[ebp]
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1116				; 0000045cH
	mov	DWORD PTR $T224202[ebp], eax
	mov	ecx, DWORD PTR $T224202[ebp]
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>::FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>

; 26   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvWonderProductionAI@@QAE@PAVCvPlayer@@PAVCvBuildingXMLEntries@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvFlavorRecipient@@QAE@XZ		; CvFlavorRecipient::~CvFlavorRecipient
__unwindfunclet$??0CvWonderProductionAI@@QAE@PAVCvPlayer@@PAVCvBuildingXMLEntries@@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$CvWeightedVector@H$0IH@$00@@QAE@XZ	; CvWeightedVector<int,135,1>::~CvWeightedVector<int,135,1>
__ehhandler$??0CvWonderProductionAI@@QAE@PAVCvPlayer@@PAVCvBuildingXMLEntries@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvWonderProductionAI@@QAE@PAVCvPlayer@@PAVCvBuildingXMLEntries@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvWonderProductionAI@@QAE@PAVCvPlayer@@PAVCvBuildingXMLEntries@@@Z ENDP ; CvWonderProductionAI::CvWonderProductionAI
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::~FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>::~FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>
PUBLIC	??1CvWonderProductionAI@@QAE@XZ			; CvWonderProductionAI::~CvWonderProductionAI
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvWonderProductionAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvWonderProductionAI@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvWonderProductionAI@@QAE@XZ$1
__ehfuncinfo$??1CvWonderProductionAI@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvWonderProductionAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvwonderproductionai.cpp
xdata$x	ENDS
;	COMDAT ??1CvWonderProductionAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T224282 = -44						; size = 4
$T224250 = -28						; size = 4
__$EHRec$ = -12						; size = 12
??1CvWonderProductionAI@@QAE@XZ PROC			; CvWonderProductionAI::~CvWonderProductionAI, COMDAT
; _this$ = ecx

; 30   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvWonderProductionAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvWonderProductionAI@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 31   : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1116				; 0000045cH
	mov	DWORD PTR $T224250[ebp], ecx
	mov	ecx, DWORD PTR $T224250[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>::~FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T224282[ebp], edx
	mov	ecx, DWORD PTR $T224282[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::~FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvFlavorRecipient@@QAE@XZ		; CvFlavorRecipient::~CvFlavorRecipient
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvWonderProductionAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvFlavorRecipient@@QAE@XZ		; CvFlavorRecipient::~CvFlavorRecipient
__unwindfunclet$??1CvWonderProductionAI@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$CvWeightedVector@H$0IH@$00@@QAE@XZ	; CvWeightedVector<int,135,1>::~CvWeightedVector<int,135,1>
__ehhandler$??1CvWonderProductionAI@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvWonderProductionAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvWonderProductionAI@@QAE@XZ ENDP			; CvWonderProductionAI::~CvWonderProductionAI
PUBLIC	?Reset@CvWonderProductionAI@@QAEXXZ		; CvWonderProductionAI::Reset
PUBLIC	?Init@CvWonderProductionAI@@QAEXPAVCvBuildingXMLEntries@@PAVCvPlayer@@_N@Z ; CvWonderProductionAI::Init
; Function compile flags: /Odtp
;	COMDAT ?Init@CvWonderProductionAI@@QAEXPAVCvBuildingXMLEntries@@PAVCvPlayer@@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pBuildings$ = 8					; size = 4
_pPlayer$ = 12						; size = 4
_bIsCity$ = 16						; size = 1
?Init@CvWonderProductionAI@@QAEXPAVCvBuildingXMLEntries@@PAVCvPlayer@@_N@Z PROC ; CvWonderProductionAI::Init, COMDAT
; _this$ = ecx

; 35   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 36   : 	// Init base class
; 37   : 	CvFlavorRecipient::Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Init@CvFlavorRecipient@@UAEXXZ		; CvFlavorRecipient::Init

; 38   : 
; 39   : 	// Store off the pointer to the buildings for this game
; 40   : 	m_pBuildings = pBuildings;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pBuildings$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 41   : 	m_pPlayer = pPlayer;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [edx+12], eax

; 42   : 	m_bIsCity = bIsCity;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _bIsCity$[ebp]
	mov	BYTE PTR [ecx+4], dl

; 43   : 
; 44   : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvWonderProductionAI@@QAEXXZ	; CvWonderProductionAI::Reset

; 45   : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Init@CvWonderProductionAI@@QAEXPAVCvBuildingXMLEntries@@PAVCvPlayer@@_N@Z ENDP ; CvWonderProductionAI::Init
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@Z ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::push_back
EXTRN	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ:PROC ; CvBuildingXMLEntries::GetNumBuildings
; Function compile flags: /Odtp
;	COMDAT ?Reset@CvWonderProductionAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -64						; size = 4
_weightedElem$224364 = -20				; size = 8
$T224323 = -12						; size = 4
_i$224318 = -8						; size = 4
_i$222706 = -4						; size = 4
?Reset@CvWonderProductionAI@@QAEXXZ PROC		; CvWonderProductionAI::Reset, COMDAT
; _this$ = ecx

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 	CvAssertMsg(m_pBuildings != NULL, "Wonder Production AI init failure: building entries are NULL");
; 51   : 
; 52   : 	// Reset vector
; 53   : 	m_WonderAIWeights.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T224323[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN15@Reset
	mov	DWORD PTR _i$224318[ebp], 0
	jmp	SHORT $LN13@Reset
$LN12@Reset:
	mov	edx, DWORD PTR _i$224318[ebp]
	add	edx, 1
	mov	DWORD PTR _i$224318[ebp], edx
$LN13@Reset:
	mov	eax, DWORD PTR $T224323[ebp]
	mov	ecx, DWORD PTR _i$224318[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN15@Reset
	jmp	SHORT $LN12@Reset
$LN15@Reset:
	mov	edx, DWORD PTR $T224323[ebp]
	mov	DWORD PTR [edx+4], 0

; 54   : 
; 55   : 	// Loop through reading each one and adding it to our vector
; 56   : 	if(m_pBuildings)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN5@Reset

; 57   : 	{
; 58   : #ifdef AUI_WARNING_FIXES
; 59   : 		for (uint i = 0; i < m_pBuildings->GetNumBuildings(); i++)
; 60   : #else
; 61   : 		for(int i = 0; i < m_pBuildings->GetNumBuildings(); i++)

	mov	DWORD PTR _i$222706[ebp], 0
	jmp	SHORT $LN3@Reset
$LN2@Reset:
	mov	ecx, DWORD PTR _i$222706[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$222706[ebp], ecx
$LN3@Reset:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	cmp	DWORD PTR _i$222706[ebp], eax
	jge	SHORT $LN5@Reset

; 62   : #endif
; 63   : 		{
; 64   : 			m_WonderAIWeights.push_back(i, 0);

	mov	DWORD PTR _weightedElem$224364[ebp], 0
	mov	DWORD PTR _weightedElem$224364[ebp+4], 0
	mov	eax, DWORD PTR _i$222706[ebp]
	mov	DWORD PTR _weightedElem$224364[ebp], eax
	mov	DWORD PTR _weightedElem$224364[ebp+4], 0
	lea	ecx, DWORD PTR _weightedElem$224364[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@Z ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::push_back

; 65   : 		}

	jmp	SHORT $LN2@Reset
$LN5@Reset:

; 66   : 	}
; 67   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@CvWonderProductionAI@@QAEXXZ ENDP		; CvWonderProductionAI::Reset
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
PUBLIC	??_C@_0CE@MEGFIFOL@LOAD?5ERROR?3?5Building?5Type?5not?5fo@ ; `string'
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
PUBLIC	__$ArrayPad$
PUBLIC	?Read@CvWonderProductionAI@@QAEXAAVFDataStream@@@Z ; CvWonderProductionAI::Read
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?LogMessage@CvGlobals@@QAEXPBD@Z:PROC		; CvGlobals::LogMessage
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
;	COMDAT ??_C@_0CE@MEGFIFOL@LOAD?5ERROR?3?5Building?5Type?5not?5fo@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CE@MEGFIFOL@LOAD?5ERROR?3?5Building?5Type?5not?5fo@ DB 'LOAD ERROR'
	DB	': Building Type not found', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Read@CvWonderProductionAI@@QAEXAAVFDataStream@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Read@CvWonderProductionAI@@QAEXAAVFDataStream@@@Z$0
__ehfuncinfo$?Read@CvWonderProductionAI@@QAEXAAVFDataStream@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Read@CvWonderProductionAI@@QAEXAAVFDataStream@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvwonderproductionai.cpp
xdata$x	ENDS
;	COMDAT ?Read@CvWonderProductionAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
tv164 = -120						; size = 4
_this$ = -116						; size = 4
$T224434 = -112						; size = 4
_weightedElem$224419 = -108				; size = 8
$T224410 = -100						; size = 4
_i$224404 = -96						; size = 4
$T224379 = -92						; size = 4
$T224378 = -88						; size = 4
_szError$222766 = -84					; size = 28
__$ArrayPad$ = -56					; size = 4
_bValid$222761 = -49					; size = 1
_iI$222757 = -48					; size = 4
_i$222751 = -44						; size = 4
_iType$222756 = -40					; size = 4
_iNumEntries$222755 = -36				; size = 4
_wrapm_piLatestFlavorValues$ = -32			; size = 8
_uiVersion$ = -24					; size = 4
_iWeight$ = -20						; size = 4
_iNumFlavors$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_kStream$ = 8						; size = 4
?Read@CvWonderProductionAI@@QAEXAAVFDataStream@@@Z PROC	; CvWonderProductionAI::Read, COMDAT
; _this$ = ecx

; 71   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Read@CvWonderProductionAI@@QAEXAAVFDataStream@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 	// Version number to maintain backwards compatibility
; 73   : 	uint uiVersion;
; 74   : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 75   : 
; 76   : 	int iWeight;
; 77   : 
; 78   : 	CvAssertMsg(m_piLatestFlavorValues != NULL && GC.getNumFlavorTypes() > 0, "Number of flavor values to serialize is expected to greater than 0");
; 79   : 
; 80   : 	int iNumFlavors;
; 81   : 	kStream >> iNumFlavors;

	lea	ecx, DWORD PTR _iNumFlavors$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 82   : 
; 83   : 	ArrayWrapper<int> wrapm_piLatestFlavorValues(iNumFlavors, m_piLatestFlavorValues);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T224379[ebp], eax
	mov	ecx, DWORD PTR _iNumFlavors$[ebp]
	mov	DWORD PTR $T224378[ebp], ecx
	mov	edx, DWORD PTR $T224379[ebp]
	mov	DWORD PTR _wrapm_piLatestFlavorValues$[ebp], edx
	mov	eax, DWORD PTR $T224378[ebp]
	mov	DWORD PTR _wrapm_piLatestFlavorValues$[ebp+4], eax

; 84   : 	kStream >> wrapm_piLatestFlavorValues;

	lea	ecx, DWORD PTR _wrapm_piLatestFlavorValues$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 85   : 
; 86   : 	CvAssertMsg(m_pBuildings != NULL, "Wonder Production AI init failure: building entries are NULL");
; 87   : 
; 88   : 	// Reset vector
; 89   : 	m_WonderAIWeights.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T224410[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN29@Read
	mov	DWORD PTR _i$224404[ebp], 0
	jmp	SHORT $LN27@Read
$LN26@Read:
	mov	edx, DWORD PTR _i$224404[ebp]
	add	edx, 1
	mov	DWORD PTR _i$224404[ebp], edx
$LN27@Read:
	mov	eax, DWORD PTR $T224410[ebp]
	mov	ecx, DWORD PTR _i$224404[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN29@Read
	jmp	SHORT $LN26@Read
$LN29@Read:
	mov	edx, DWORD PTR $T224410[ebp]
	mov	DWORD PTR [edx+4], 0

; 90   : 
; 91   : 	// Loop through reading each one and adding it to our vector
; 92   : 	if(m_pBuildings)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	$LN12@Read

; 93   : 	{
; 94   : #ifdef AUI_WARNING_FIXES
; 95   : 		for (uint i = 0; i < m_pBuildings->GetNumBuildings(); i++)
; 96   : #else
; 97   : 		for(int i = 0; i < m_pBuildings->GetNumBuildings(); i++)

	mov	DWORD PTR _i$222751[ebp], 0
	jmp	SHORT $LN10@Read
$LN9@Read:
	mov	ecx, DWORD PTR _i$222751[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$222751[ebp], ecx
$LN10@Read:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	cmp	DWORD PTR _i$222751[ebp], eax
	jge	SHORT $LN8@Read

; 98   : #endif
; 99   : 		{
; 100  : 			m_WonderAIWeights.push_back(i, 0);

	mov	DWORD PTR _weightedElem$224419[ebp], 0
	mov	DWORD PTR _weightedElem$224419[ebp+4], 0
	mov	eax, DWORD PTR _i$222751[ebp]
	mov	DWORD PTR _weightedElem$224419[ebp], eax
	mov	DWORD PTR _weightedElem$224419[ebp+4], 0
	lea	ecx, DWORD PTR _weightedElem$224419[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@Z ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::push_back

; 101  : 		}

	jmp	SHORT $LN9@Read
$LN8@Read:

; 102  : 
; 103  : 		int iNumEntries;
; 104  : 		int iType;
; 105  : 
; 106  : 		kStream >> iNumEntries;

	lea	edx, DWORD PTR _iNumEntries$222755[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 107  : 
; 108  : 		for(int iI = 0; iI < iNumEntries; iI++)

	mov	DWORD PTR _iI$222757[ebp], 0
	jmp	SHORT $LN7@Read
$LN6@Read:
	mov	eax, DWORD PTR _iI$222757[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$222757[ebp], eax
$LN7@Read:
	mov	ecx, DWORD PTR _iI$222757[ebp]
	cmp	ecx, DWORD PTR _iNumEntries$222755[ebp]
	jge	$LN12@Read

; 109  : 		{
; 110  : 			bool bValid = true;

	mov	BYTE PTR _bValid$222761[ebp], 1

; 111  : 			iType = CvInfosSerializationHelper::ReadHashed(kStream, &bValid);

	lea	edx, DWORD PTR _bValid$222761[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iType$222756[ebp], eax

; 112  : 			if(iType != -1 || !bValid)

	cmp	DWORD PTR _iType$222756[ebp], -1
	jne	SHORT $LN3@Read
	movzx	ecx, BYTE PTR _bValid$222761[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@Read
$LN3@Read:

; 113  : 			{
; 114  : 				kStream >> iWeight;

	lea	edx, DWORD PTR _iWeight$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 115  : 				if(iType != -1)

	cmp	DWORD PTR _iType$222756[ebp], -1
	je	SHORT $LN2@Read

; 116  : 				{
; 117  : 					m_WonderAIWeights.IncreaseWeight(iType, iWeight);

	mov	eax, DWORD PTR _iWeight$[ebp]
	mov	DWORD PTR $T224434[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _iType$222756[ebp]
	lea	ecx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR tv164[ebp], ecx
	mov	edx, DWORD PTR tv164[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR $T224434[ebp]
	mov	ecx, DWORD PTR tv164[ebp]
	mov	DWORD PTR [ecx], eax

; 118  : 				}
; 119  : 				else

	jmp	SHORT $LN4@Read
$LN2@Read:

; 120  : 				{
; 121  : 					CvString szError;

	lea	ecx, DWORD PTR _szError$222766[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 122  : 					szError.Format("LOAD ERROR: Building Type not found");

	push	OFFSET ??_C@_0CE@MEGFIFOL@LOAD?5ERROR?3?5Building?5Type?5not?5fo@
	lea	edx, DWORD PTR _szError$222766[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 123  : 					GC.LogMessage(szError.GetCString());

	lea	ecx, DWORD PTR _szError$222766[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?LogMessage@CvGlobals@@QAEXPBD@Z	; CvGlobals::LogMessage

; 124  : 					CvAssertMsg(false, szError);
; 125  : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _szError$222766[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@Read:

; 126  : 			}
; 127  : 		}

	jmp	$LN6@Read
$LN12@Read:

; 128  : 	}
; 129  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Read@CvWonderProductionAI@@QAEXAAVFDataStream@@@Z$0:
	lea	ecx, DWORD PTR _szError$222766[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?Read@CvWonderProductionAI@@QAEXAAVFDataStream@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Read@CvWonderProductionAI@@QAEXAAVFDataStream@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Read@CvWonderProductionAI@@QAEXAAVFDataStream@@@Z ENDP	; CvWonderProductionAI::Read
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
PUBLIC	?Write@CvWonderProductionAI@@QBEXAAVFDataStream@@@Z ; CvWonderProductionAI::Write
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvWonderProductionAI@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -64						; size = 4
_elem$224492 = -60					; size = 8
$T224475 = -52						; size = 4
$T224471 = -48						; size = 4
$T224464 = -44						; size = 4
$T224457 = -40						; size = 4
$T224456 = -36						; size = 4
$T224455 = -32						; size = 8
$T224454 = -24						; size = 4
_eBuilding$222797 = -20					; size = 4
_pkBuildingInfo$222799 = -16				; size = 4
_iI$222793 = -12					; size = 4
_iNumBuildings$222792 = -8				; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvWonderProductionAI@@QBEXAAVFDataStream@@@Z PROC ; CvWonderProductionAI::Write, COMDAT
; _this$ = ecx

; 133  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 134  : 	// Current version number
; 135  : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 136  : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 137  : 
; 138  : 	CvAssertMsg(m_piLatestFlavorValues != NULL && GC.getNumFlavorTypes() > 0, "Number of flavor values to serialize is expected to greater than 0");
; 139  : 	kStream << GC.getNumFlavorTypes();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T224464[ebp], ecx
	mov	edx, DWORD PTR $T224464[ebp]
	mov	DWORD PTR $T224454[ebp], edx
	lea	eax, DWORD PTR $T224454[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 140  : 	kStream << ArrayWrapper<int>(GC.getNumFlavorTypes(), m_piLatestFlavorValues);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T224471[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T224475[ebp], eax
	mov	ecx, DWORD PTR $T224475[ebp]
	mov	DWORD PTR $T224455[ebp], ecx
	mov	edx, DWORD PTR $T224471[ebp]
	mov	DWORD PTR $T224455[ebp+4], edx
	lea	eax, DWORD PTR $T224455[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
	add	esp, 8

; 141  : 
; 142  : 	if(m_pBuildings)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	$LN8@Write

; 143  : 	{
; 144  : 		int iNumBuildings = m_pBuildings->GetNumBuildings();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	mov	DWORD PTR _iNumBuildings$222792[ebp], eax

; 145  : 		kStream << iNumBuildings;

	lea	ecx, DWORD PTR _iNumBuildings$222792[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 146  : 
; 147  : 		// Loop through writing each entry
; 148  : 		for(int iI = 0; iI < iNumBuildings; iI++)

	mov	DWORD PTR _iI$222793[ebp], 0
	jmp	SHORT $LN6@Write
$LN5@Write:
	mov	edx, DWORD PTR _iI$222793[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$222793[ebp], edx
$LN6@Write:
	mov	eax, DWORD PTR _iI$222793[ebp]
	cmp	eax, DWORD PTR _iNumBuildings$222792[ebp]
	jge	SHORT $LN8@Write

; 149  : 		{
; 150  : 			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);

	mov	ecx, DWORD PTR _iI$222793[ebp]
	mov	DWORD PTR _eBuilding$222797[ebp], ecx

; 151  : 			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	mov	edx, DWORD PTR _eBuilding$222797[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkBuildingInfo$222799[ebp], eax

; 152  : 			if(pkBuildingInfo)

	cmp	DWORD PTR _pkBuildingInfo$222799[ebp], 0
	je	SHORT $LN3@Write

; 153  : 			{
; 154  : 				CvInfosSerializationHelper::WriteHashed(kStream, pkBuildingInfo);

	mov	eax, DWORD PTR _pkBuildingInfo$222799[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 155  : 				kStream << m_WonderAIWeights.GetWeight(iI);

	mov	DWORD PTR _elem$224492[ebp], 0
	mov	DWORD PTR _elem$224492[ebp+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _iI$222793[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$224492[ebp], edx
	mov	DWORD PTR _elem$224492[ebp+4], eax
	mov	ecx, DWORD PTR _elem$224492[ebp+4]
	mov	DWORD PTR $T224456[ebp], ecx
	lea	edx, DWORD PTR $T224456[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 156  : 			}
; 157  : 			else

	jmp	SHORT $LN2@Write
$LN3@Write:

; 158  : 			{
; 159  : 				kStream << (int)0;

	mov	DWORD PTR $T224457[ebp], 0
	lea	eax, DWORD PTR $T224457[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN2@Write:

; 160  : 			}
; 161  : 		}

	jmp	$LN5@Write
$LN8@Write:

; 162  : 	}
; 163  : 	else
; 164  : 	{
; 165  : 		CvAssertMsg(m_pBuildings != NULL, "Wonder Production AI init failure: building entries are NULL");
; 166  : 	}
; 167  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvWonderProductionAI@@QBEXAAVFDataStream@@@Z ENDP ; CvWonderProductionAI::Write
_TEXT	ENDS
PUBLIC	?AddFlavorWeights@CvWonderProductionAI@@QAEXW4FlavorTypes@@H@Z ; CvWonderProductionAI::AddFlavorWeights
EXTRN	?GetLatestFlavorValue@CvFlavorRecipient@@QAEHW4FlavorTypes@@_N@Z:PROC ; CvFlavorRecipient::GetLatestFlavorValue
; Function compile flags: /Odtp
;	COMDAT ?FlavorUpdate@CvWonderProductionAI@@UAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T224504 = -12						; size = 4
_iFlavorValue$222813 = -8				; size = 4
_iFlavor$222809 = -4					; size = 4
?FlavorUpdate@CvWonderProductionAI@@UAEXXZ PROC		; CvWonderProductionAI::FlavorUpdate, COMDAT
; _this$ = ecx

; 171  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 172  : 	// Broadcast to our sub AI objects
; 173  : 	for(int iFlavor = 0; iFlavor < GC.getNumFlavorTypes(); iFlavor++)

	mov	DWORD PTR _iFlavor$222809[ebp], 0
	jmp	SHORT $LN3@FlavorUpda
$LN2@FlavorUpda:
	mov	eax, DWORD PTR _iFlavor$222809[ebp]
	add	eax, 1
	mov	DWORD PTR _iFlavor$222809[ebp], eax
$LN3@FlavorUpda:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T224504[ebp], ecx
	mov	edx, DWORD PTR _iFlavor$222809[ebp]
	cmp	edx, DWORD PTR $T224504[ebp]
	jge	SHORT $LN4@FlavorUpda

; 174  : 	{
; 175  : 		int iFlavorValue = GetLatestFlavorValue((FlavorTypes)iFlavor);

	push	0
	mov	eax, DWORD PTR _iFlavor$222809[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLatestFlavorValue@CvFlavorRecipient@@QAEHW4FlavorTypes@@_N@Z ; CvFlavorRecipient::GetLatestFlavorValue
	mov	DWORD PTR _iFlavorValue$222813[ebp], eax

; 176  : 		AddFlavorWeights((FlavorTypes)iFlavor, iFlavorValue);

	mov	ecx, DWORD PTR _iFlavorValue$222813[ebp]
	push	ecx
	mov	edx, DWORD PTR _iFlavor$222809[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddFlavorWeights@CvWonderProductionAI@@QAEXW4FlavorTypes@@H@Z ; CvWonderProductionAI::AddFlavorWeights
	jmp	SHORT $LN2@FlavorUpda
$LN4@FlavorUpda:

; 177  : 	}
; 178  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FlavorUpdate@CvWonderProductionAI@@UAEXXZ ENDP		; CvWonderProductionAI::FlavorUpdate
_TEXT	ENDS
PUBLIC	?IsWonder@CvWonderProductionAI@@QBE_NABVCvBuildingEntry@@@Z ; CvWonderProductionAI::IsWonder
EXTRN	?GetFlavorValue@CvBuildingEntry@@QBEHH@Z:PROC	; CvBuildingEntry::GetFlavorValue
EXTRN	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z:PROC ; CvBuildingXMLEntries::GetEntry
; Function compile flags: /Odtp
;	COMDAT ?AddFlavorWeights@CvWonderProductionAI@@QAEXW4FlavorTypes@@H@Z
_TEXT	SEGMENT
tv95 = -24						; size = 4
_this$ = -20						; size = 4
$T224515 = -16						; size = 4
_kBuilding$222827 = -12					; size = 4
_entry$222825 = -8					; size = 4
_iBldg$222821 = -4					; size = 4
_eFlavor$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?AddFlavorWeights@CvWonderProductionAI@@QAEXW4FlavorTypes@@H@Z PROC ; CvWonderProductionAI::AddFlavorWeights, COMDAT
; _this$ = ecx

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 183  : #ifdef AUI_PER_CITY_WONDER_PRODUCTION_AI
; 184  : #ifdef AUI_POLICY_BUILDING_CLASS_FLAVOR_MODIFIERS
; 185  : 	CvPlayer* pPlayer = m_pCity->GetPlayer();
; 186  : 	CvPlayerPolicies* pPlayerPolicies = NULL;
; 187  : 	if (pPlayer)
; 188  : 		pPlayerPolicies = pPlayer->GetPlayerPolicies();
; 189  : #endif
; 190  : #ifdef AUI_BELIEF_BUILDING_CLASS_FLAVOR_MODIFIERS
; 191  : 	const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(m_pCity->GetCityReligions()->GetReligiousMajority(), m_pCity->getOwner());
; 192  : #endif
; 193  : #else
; 194  : #ifdef AUI_POLICY_BUILDING_CLASS_FLAVOR_MODIFIERS
; 195  : 	CvPlayer* pPlayer = m_pPlayer;
; 196  : 	CvPlayerPolicies* pPlayerPolicies = NULL;
; 197  : 	if (pPlayer)
; 198  : 		pPlayerPolicies = pPlayer->GetPlayerPolicies();
; 199  : #endif
; 200  : #ifdef AUI_BELIEF_BUILDING_CLASS_FLAVOR_MODIFIERS
; 201  : 	CvCity* pCapitol = m_pPlayer->getCapitalCity();
; 202  : 	const CvReligion* pReligion = NULL;
; 203  : 	if (pCapitol)
; 204  : 		pReligion = GC.getGame().GetGameReligions()->GetReligion(pCapitol->GetCityReligions()->GetReligiousMajority(), m_pPlayer->GetID());
; 205  : #endif
; 206  : #endif
; 207  : 	// Loop through all buildings (even though we're only go to do anything on wonders)
; 208  : #ifdef AUI_WARNING_FIXES
; 209  : 	for (uint iBldg = 0; iBldg < m_pBuildings->GetNumBuildings(); iBldg++)
; 210  : #else
; 211  : 	for(int iBldg = 0; iBldg < m_pBuildings->GetNumBuildings(); iBldg++)

	mov	DWORD PTR _iBldg$222821[ebp], 0
	jmp	SHORT $LN5@AddFlavorW
$LN4@AddFlavorW:
	mov	eax, DWORD PTR _iBldg$222821[ebp]
	add	eax, 1
	mov	DWORD PTR _iBldg$222821[ebp], eax
$LN5@AddFlavorW:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+16]
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	cmp	DWORD PTR _iBldg$222821[ebp], eax
	jge	SHORT $LN6@AddFlavorW

; 212  : #endif
; 213  : 	{
; 214  : 		CvBuildingEntry* entry = m_pBuildings->GetEntry(iBldg);

	mov	edx, DWORD PTR _iBldg$222821[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	DWORD PTR _entry$222825[ebp], eax

; 215  : 		if(entry)

	cmp	DWORD PTR _entry$222825[ebp], 0
	je	SHORT $LN2@AddFlavorW

; 216  : 		{
; 217  : 			CvBuildingEntry& kBuilding = *entry;

	mov	ecx, DWORD PTR _entry$222825[ebp]
	mov	DWORD PTR _kBuilding$222827[ebp], ecx

; 218  : 			if(IsWonder(kBuilding))

	mov	edx, DWORD PTR _kBuilding$222827[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsWonder@CvWonderProductionAI@@QBE_NABVCvBuildingEntry@@@Z ; CvWonderProductionAI::IsWonder
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@AddFlavorW

; 219  : 			{
; 220  : 				// Set its weight by looking at wonder's weight for this flavor and using iWeight multiplier passed in
; 221  : #if defined(AUI_POLICY_BUILDING_CLASS_FLAVOR_MODIFIERS) || defined(AUI_BELIEF_BUILDING_CLASS_FLAVOR_MODIFIERS) || defined(AUI_BUILDING_PRODUCTION_AI_LUA_FLAVOR_WEIGHTS) || (defined(AUI_BUILDING_PRODUCTION_AI_CONSIDER_FREE_STUFF) && defined(AUI_PER_CITY_WONDER_PRODUCTION_AI))
; 222  : 				int iFlavorValue = entry->GetFlavorValue(eFlavor);
; 223  : #endif
; 224  : #ifdef AUI_POLICY_BUILDING_CLASS_FLAVOR_MODIFIERS
; 225  : 				if (pPlayerPolicies)
; 226  : 				{
; 227  : 					for (int iI = 0; iI < GC.getNumPolicyInfos(); iI++)
; 228  : 					{
; 229  : 						PolicyTypes ePolicy = static_cast<PolicyTypes>(iI);
; 230  : 						CvPolicyEntry* pPolicy = GC.getPolicyInfo(ePolicy);
; 231  : 						if (pPolicy && pPlayerPolicies->HasPolicy(ePolicy))
; 232  : 						{
; 233  : 							iFlavorValue += pPolicy->GetBuildingClassFlavorChanges(entry->GetBuildingClassType(), eFlavor);
; 234  : 						}
; 235  : 					}
; 236  : 				}
; 237  : #endif
; 238  : #ifdef AUI_BELIEF_BUILDING_CLASS_FLAVOR_MODIFIERS
; 239  : 				if (pReligion)
; 240  : 				{
; 241  : 					pReligion->m_Beliefs.GetBuildingClassFlavorChange(static_cast<BuildingClassTypes>(entry->GetBuildingClassType()), eFlavor);
; 242  : 				}
; 243  : #endif
; 244  : #if defined(AUI_BUILDING_PRODUCTION_AI_CONSIDER_FREE_STUFF) && defined(AUI_PER_CITY_WONDER_PRODUCTION_AI)
; 245  : #ifdef AUI_WARNING_FIXES
; 246  : 				for (uint iI = 0; iI < GC.getNumUnitInfos(); iI++)
; 247  : #else
; 248  : 				for (int iI = 0; iI < GC.getNumUnitInfos(); iI++)
; 249  : #endif
; 250  : 				{
; 251  : 					int iNumFreeUnits = entry->GetNumFreeUnits(iI);
; 252  : 					if (iNumFreeUnits > 0)
; 253  : 					{
; 254  : 						iWeight += iNumFreeUnits * m_pCity->GetCityStrategyAI()->GetUnitProductionAI()->GetWeight((UnitTypes)iI);
; 255  : 					}
; 256  : 				}
; 257  : #endif
; 258  : #if defined(AUI_POLICY_BUILDING_CLASS_FLAVOR_MODIFIERS) || defined(AUI_BELIEF_BUILDING_CLASS_FLAVOR_MODIFIERS) || defined(AUI_BUILDING_PRODUCTION_AI_LUA_FLAVOR_WEIGHTS) || (defined(AUI_BUILDING_PRODUCTION_AI_CONSIDER_FREE_STUFF) && defined(AUI_PER_CITY_WONDER_PRODUCTION_AI))
; 259  : 				m_WonderAIWeights.IncreaseWeight(iBldg, iFlavorValue * iWeight);
; 260  : #else
; 261  : 				m_WonderAIWeights.IncreaseWeight(iBldg, kBuilding.GetFlavorValue(eFlavor) * iWeight);

	mov	ecx, DWORD PTR _eFlavor$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kBuilding$222827[ebp]
	call	?GetFlavorValue@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetFlavorValue
	imul	eax, DWORD PTR _iWeight$[ebp]
	mov	DWORD PTR $T224515[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _iBldg$222821[ebp]
	lea	edx, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR tv95[ebp], edx
	mov	eax, DWORD PTR tv95[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR $T224515[ebp]
	mov	edx, DWORD PTR tv95[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@AddFlavorW:

; 262  : #endif
; 263  : 			}
; 264  : 		}

	jmp	SHORT $LN4@AddFlavorW
$LN6@AddFlavorW:

; 265  : 	}
; 266  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?AddFlavorWeights@CvWonderProductionAI@@QAEXW4FlavorTypes@@H@Z ENDP ; CvWonderProductionAI::AddFlavorWeights
_TEXT	ENDS
PUBLIC	?GetWeight@CvWonderProductionAI@@QAEHW4BuildingTypes@@@Z ; CvWonderProductionAI::GetWeight
; Function compile flags: /Odtp
;	COMDAT ?GetWeight@CvWonderProductionAI@@QAEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_elem$224531 = -8					; size = 8
_eBldg$ = 8						; size = 4
?GetWeight@CvWonderProductionAI@@QAEHW4BuildingTypes@@@Z PROC ; CvWonderProductionAI::GetWeight, COMDAT
; _this$ = ecx

; 270  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 271  : #if defined(AUI_BUILDING_PRODUCTION_AI_CONSIDER_FREE_STUFF) && defined(AUI_PER_CITY_WONDER_PRODUCTION_AI)
; 272  : 	int iWeight = m_WonderAIWeights.GetWeight(eBldg);
; 273  : 	CvBuildingEntry* entry = m_pBuildings->GetEntry(eBldg);
; 274  : 	if (entry)
; 275  : 	{
; 276  : 		CvPlayer* pPlayer = m_pCity->GetPlayer();
; 277  : 		int iLoop = 0;
; 278  : 
; 279  : 		BuildingTypes eFreeBuildingThisCity = static_cast<BuildingTypes>(entry->GetFreeBuildingThisCity());
; 280  : 		if (eFreeBuildingThisCity != NO_BUILDING)
; 281  : 		{
; 282  : 			if (m_pCity->GetCityBuildings()->GetNumBuilding(eFreeBuildingThisCity) == 0)
; 283  : 				iWeight += m_pCity->GetCityStrategyAI()->GetBuildingProductionAI()->GetWeight(eFreeBuildingThisCity);
; 284  : 		}
; 285  : 
; 286  : 		BuildingClassTypes eFreeBuildingClassAllCities = static_cast<BuildingClassTypes>(entry->GetFreeBuildingClass());
; 287  : 		if (eFreeBuildingClassAllCities != NO_BUILDINGCLASS)
; 288  : 		{
; 289  : 			BuildingTypes eFreeBuilding = static_cast<BuildingTypes>(m_pCity->getCivilizationInfo().getCivilizationBuildings(eFreeBuildingClassAllCities));
; 290  : 			for (CvCity* pLoopCity = pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iLoop))
; 291  : 			{
; 292  : 				if (pLoopCity->GetCityBuildings()->GetNumBuilding(eFreeBuilding) == 0)
; 293  : 					iWeight += pLoopCity->GetCityStrategyAI()->GetBuildingProductionAI()->GetWeight(eFreeBuilding);
; 294  : 			}
; 295  : 		}
; 296  : 
; 297  : 		if (entry->GetInstantMilitaryIncrease())
; 298  : 		{
; 299  : 			FFastVector<UnitTypes, true, c_eCiv5GameplayDLL> aExtraUnits;
; 300  : 			for (CvUnit* pLoopUnit = pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iLoop))
; 301  : 			{
; 302  : 				if (pLoopUnit->getDomainType() == DOMAIN_LAND && pLoopUnit->IsCombatUnit())
; 303  : 				{
; 304  : 					UnitTypes eCurrentUnitType = pLoopUnit->getUnitType();
; 305  : 
; 306  : 					// check for duplicate unit
; 307  : 					bool bAddUnit = true;
; 308  : 					for (uint ui = 0; ui < aExtraUnits.size(); ui++)
; 309  : 					{
; 310  : 						if (aExtraUnits[ui] == eCurrentUnitType)
; 311  : 						{
; 312  : 							bAddUnit = false;
; 313  : 							break;
; 314  : 						}
; 315  : 					}
; 316  : 					if (bAddUnit)
; 317  : 					{
; 318  : 						aExtraUnits.push_back(eCurrentUnitType);
; 319  : 					}
; 320  : 				}
; 321  : 			}
; 322  : 			for (uint ui = 0; ui < aExtraUnits.size(); ui++)
; 323  : 			{
; 324  : 				iWeight += m_pCity->GetCityStrategyAI()->GetUnitProductionAI()->GetWeight(aExtraUnits[ui]);
; 325  : 			}
; 326  : 		}
; 327  : 	}
; 328  : 	return iWeight;
; 329  : #else
; 330  : 	return m_WonderAIWeights.GetWeight(eBldg);

	mov	DWORD PTR _elem$224531[ebp], 0
	mov	DWORD PTR _elem$224531[ebp+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _eBldg$[ebp]
	mov	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR [ecx+edx*8+4]
	mov	DWORD PTR _elem$224531[ebp], eax
	mov	DWORD PTR _elem$224531[ebp+4], ecx
	mov	eax, DWORD PTR _elem$224531[ebp+4]

; 331  : #endif
; 332  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetWeight@CvWonderProductionAI@@QAEHW4BuildingTypes@@@Z ENDP ; CvWonderProductionAI::GetWeight
_TEXT	ENDS
PUBLIC	?ChooseFromTopChoices@?$CvWeightedVector@H$0DC@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<int,50,1>::ChooseFromTopChoices
PUBLIC	??_C@_0CB@NGOAAMEE@Choosing?5wonder?5from?5Top?5Choices@ ; `string'
PUBLIC	?GetTotalWeight@?$CvWeightedVector@H$0DC@$00@@QAEHXZ ; CvWeightedVector<int,50,1>::GetTotalWeight
PUBLIC	?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ ; CvWonderProductionAI::LogPossibleWonders
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,50,1>::WeightedElement *,int>
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@Z ; FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>::push_back
PUBLIC	?HaveCityToBuild@CvWonderProductionAI@@ABE_NW4BuildingTypes@@@Z ; CvWonderProductionAI::HaveCityToBuild
PUBLIC	??_C@_0CD@DIPKFMBK@GAMEOPTION_AI_GIMP_NO_WORLD_WOND@ ; `string'
PUBLIC	??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@	; `string'
PUBLIC	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
PUBLIC	?ChooseWonder@CvWonderProductionAI@@QAE?AW4BuildingTypes@@_N0AAH@Z ; CvWonderProductionAI::ChooseWonder
EXTRN	?GetCityProductionNumOptions@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::GetCityProductionNumOptions
EXTRN	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvGame::getHandicapInfo
EXTRN	?getBuildingClassMaking@CvPlayer@@QBEHW4BuildingClassTypes@@@Z:PROC ; CvPlayer::getBuildingClassMaking
EXTRN	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetBuildingClassType
EXTRN	?ReweightByTurnsLeft@CityStrategyAIHelpers@@YAHHH@Z:PROC ; CityStrategyAIHelpers::ReweightByTurnsLeft
EXTRN	?GetGold@CvTreasury@@QBEHXZ:PROC		; CvTreasury::GetGold
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?IsGoingForDiploVictory@CvDiplomacyAI@@QAE_NXZ:PROC ; CvDiplomacyAI::IsGoingForDiploVictory
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ:PROC ; CvMinorCivAI::GetAlly
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ:PROC ; CvTeam::GetLiberatedByTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
EXTRN	?GetVotesNeededForDiploVictory@CvGame@@QBEHXZ:PROC ; CvGame::GetVotesNeededForDiploVictory
EXTRN	?IsDiplomaticVoting@CvBuildingEntry@@QBE_NXZ:PROC ; CvBuildingEntry::IsDiplomaticVoting
EXTRN	?GetBuildingProduction@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetBuildingProduction
EXTRN	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ:PROC ; CvCity::GetCityBuildings
EXTRN	?GetProductionCost@CvBuildingEntry@@QBEHXZ:PROC	; CvBuildingEntry::GetProductionCost
EXTRN	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isWorldWonderClass
EXTRN	?isOption@CvGame@@QBE_NPBD@Z:PROC		; CvGame::isOption
EXTRN	?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ:PROC ; CvBuildingEntry::GetBuildingClassInfo
EXTRN	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ:PROC ; CvGlobals::GetGameBuildings
EXTRN	?getCurrentProductionDifference@CvCity@@QBEH_N0@Z:PROC ; CvCity::getCurrentProductionDifference
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?GetWonderBuildCity@CvCitySpecializationAI@@QBEPAVCvCity@@XZ:PROC ; CvCitySpecializationAI::GetWonderBuildCity
EXTRN	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ:PROC ; CvPlayer::GetCitySpecializationAI
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?getAsyncRandNum@CvGame@@QAEHHPBD@Z:PROC	; CvGame::getAsyncRandNum
;	COMDAT ??_C@_0CB@NGOAAMEE@Choosing?5wonder?5from?5Top?5Choices@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
CONST	SEGMENT
??_C@_0CB@NGOAAMEE@Choosing?5wonder?5from?5Top?5Choices@ DB 'Choosing won'
	DB	'der from Top Choices', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DIPKFMBK@GAMEOPTION_AI_GIMP_NO_WORLD_WOND@
CONST	SEGMENT
??_C@_0CD@DIPKFMBK@GAMEOPTION_AI_GIMP_NO_WORLD_WOND@ DB 'GAMEOPTION_AI_GI'
	DB	'MP_NO_WORLD_WONDER', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
CONST	SEGMENT
??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@ DB 'GAMEOPTION_AI_TWEAKS', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvwonderproductionai.cpp
CONST	ENDS
;	COMDAT ?ChooseWonder@CvWonderProductionAI@@QAE?AW4BuildingTypes@@_N0AAH@Z
_TEXT	SEGMENT
tv437 = -388						; size = 4
tv200 = -384						; size = 4
tv78 = -380						; size = 4
_this$ = -376						; size = 4
$T224850 = -312						; size = 4
$T224834 = -284						; size = 4
$T224796 = -268						; size = 4
$T224792 = -264						; size = 4
$T224783 = -260						; size = 4
_weightedElem$224778 = -248				; size = 8
$T224757 = -240						; size = 4
$T224751 = -236						; size = 4
$T224744 = -232						; size = 4
$T224740 = -228						; size = 4
$T224736 = -224						; size = 4
$T224724 = -220						; size = 4
$T224720 = -213						; size = 1
$T224711 = -212						; size = 4
$T224699 = -208						; size = 4
$T224690 = -204						; size = 4
$T224686 = -200						; size = 4
_elem$224685 = -196					; size = 8
$T224671 = -188						; size = 4
_elem$224670 = -184					; size = 8
$T224654 = -176						; size = 4
$T224647 = -172						; size = 4
$T224643 = -168						; size = 4
$T224639 = -164						; size = 4
_i$224633 = -160					; size = 4
$T224608 = -156						; size = 4
$T224592 = -152						; size = 4
$T224588 = -148						; size = 4
$T224572 = -144						; size = 4
$T224541 = -140						; size = 4
$T224540 = -136						; size = 4
$T224537 = -132						; size = 4
$T224536 = -128						; size = 4
$T224535 = -124						; size = 8
$T224534 = -116						; size = 8
_iNumChoices$223058 = -108				; size = 4
_eLoopPlayer$223052 = -104				; size = 4
_iPlayerLoop$223048 = -100				; size = 4
_iNumOthersConstructing$223047 = -96			; size = 4
_iPlayerLoop$223031 = -92				; size = 4
_iVotesNeededToWin$223025 = -88				; size = 4
_eLoopPlayer$223029 = -84				; size = 4
_iSecuredVotes$223026 = -80				; size = 4
_iNumberOfPlayersWeNeedToBuyOff$223041 = -76		; size = 4
_myTeamID$223027 = -72					; size = 4
_eLoopTeam$223030 = -68					; size = 4
_myPlayerID$223028 = -64				; size = 4
_bAlreadyStarted$223022 = -57				; size = 1
_iTempWeight$223023 = -56				; size = 4
_kBuilding$223012 = -52					; size = 4
_kBuildingClassInfo$223013 = -48			; size = 4
_eBuilding$223008 = -44					; size = 4
_pkBuildingInfo$223010 = -40				; size = 4
_fcn$ = -36						; size = 8
_iEstimatedProductionPerTurn$ = -28			; size = 4
_iCityLoop$ = -24					; size = 4
_iWeight$ = -20						; size = 4
_iBldgLoop$ = -16					; size = 4
_pWonderCity$ = -12					; size = 4
_iTurnsRequired$ = -8					; size = 4
_eSelection$ = -4					; size = 4
_bUseAsyncRandom$ = 8					; size = 1
_bAdjustForOtherPlayers$ = 12				; size = 1
_iWonderWeight$ = 16					; size = 4
?ChooseWonder@CvWonderProductionAI@@QAE?AW4BuildingTypes@@_N0AAH@Z PROC ; CvWonderProductionAI::ChooseWonder, COMDAT
; _this$ = ecx

; 336  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	mov	DWORD PTR _this$[ebp], ecx

; 337  : #ifdef AUI_WARNING_FIXES
; 338  : 	uint iBldgLoop;
; 339  : #else
; 340  : 	int iBldgLoop;
; 341  : #endif
; 342  : 	int iWeight;
; 343  : 	int iTurnsRequired;
; 344  : 	int iEstimatedProductionPerTurn;
; 345  : 	int iCityLoop;
; 346  : 	RandomNumberDelegate fcn;

	mov	DWORD PTR _fcn$[ebp], 0
	mov	DWORD PTR _fcn$[ebp+4], 0
	mov	DWORD PTR _fcn$[ebp], 0
	mov	DWORD PTR _fcn$[ebp+4], 0

; 347  : 	BuildingTypes eSelection;
; 348  : 
; 349  : 	// Use the asynchronous random number generate if "no random" is set
; 350  : 	if(bUseAsyncRandom)

	movzx	eax, BYTE PTR _bUseAsyncRandom$[ebp]
	test	eax, eax
	je	SHORT $LN32@ChooseWond

; 351  : 	{
; 352  : 		fcn = MakeDelegate(&GC.getGame(), &CvGame::getAsyncRandNum);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224572[ebp], ecx
	push	OFFSET ?getAsyncRandNum@CvGame@@QAEHHPBD@Z ; CvGame::getAsyncRandNum
	mov	edx, DWORD PTR $T224572[ebp]
	push	edx
	lea	eax, DWORD PTR $T224534[ebp]
	push	eax
	call	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T224588[ebp], eax
	mov	ecx, DWORD PTR $T224588[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _fcn$[ebp+4], edx
	mov	eax, DWORD PTR $T224588[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _fcn$[ebp], ecx

; 353  : 	}
; 354  : 	else

	jmp	SHORT $LN31@ChooseWond
$LN32@ChooseWond:

; 355  : 	{
; 356  : 		fcn = MakeDelegate(&GC.getGame(), &CvGame::getJonRandNum);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224592[ebp], edx
	push	OFFSET ?getJonRandNum@CvGame@@QAEHHPBD@Z ; CvGame::getJonRandNum
	mov	eax, DWORD PTR $T224592[ebp]
	push	eax
	lea	ecx, DWORD PTR $T224535[ebp]
	push	ecx
	call	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T224608[ebp], eax
	mov	edx, DWORD PTR $T224608[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _fcn$[ebp+4], eax
	mov	ecx, DWORD PTR $T224608[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _fcn$[ebp], edx
$LN31@ChooseWond:

; 357  : 	}
; 358  : 
; 359  : 	// Reset list of all the possible wonders
; 360  : 	m_Buildables.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1116				; 0000045cH
	mov	DWORD PTR $T224639[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN71@ChooseWond
	mov	DWORD PTR _i$224633[ebp], 0
	jmp	SHORT $LN69@ChooseWond
$LN68@ChooseWond:
	mov	edx, DWORD PTR _i$224633[ebp]
	add	edx, 1
	mov	DWORD PTR _i$224633[ebp], edx
$LN69@ChooseWond:
	mov	eax, DWORD PTR $T224639[ebp]
	mov	ecx, DWORD PTR _i$224633[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN71@ChooseWond
	jmp	SHORT $LN68@ChooseWond
$LN71@ChooseWond:
	mov	edx, DWORD PTR $T224639[ebp]
	mov	DWORD PTR [edx+4], 0

; 361  : 
; 362  : 	// Guess which city will be producing this (doesn't matter that much since weights are all relative)
; 363  : 	CvCity* pWonderCity = m_pPlayer->GetCitySpecializationAI()->GetWonderBuildCity();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ ; CvPlayer::GetCitySpecializationAI
	mov	ecx, eax
	call	?GetWonderBuildCity@CvCitySpecializationAI@@QBEPAVCvCity@@XZ ; CvCitySpecializationAI::GetWonderBuildCity
	mov	DWORD PTR _pWonderCity$[ebp], eax

; 364  : 	if(pWonderCity == NULL)

	cmp	DWORD PTR _pWonderCity$[ebp], 0
	jne	SHORT $LN30@ChooseWond

; 365  : 	{
; 366  : 		pWonderCity = m_pPlayer->firstCity(&iCityLoop);

	push	0
	lea	ecx, DWORD PTR _iCityLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pWonderCity$[ebp], eax
$LN30@ChooseWond:

; 367  : 	}
; 368  : 
; 369  : 	CvAssertMsg(pWonderCity, "Trying to choose the next wonder to build and the player has no cities!");
; 370  : 	if(pWonderCity == NULL)

	cmp	DWORD PTR _pWonderCity$[ebp], 0
	jne	SHORT $LN29@ChooseWond

; 371  : 		return NO_BUILDING;

	or	eax, -1
	jmp	$LN33@ChooseWond
$LN29@ChooseWond:

; 372  : 
; 373  : 	iEstimatedProductionPerTurn = pWonderCity->getCurrentProductionDifference(true, false);

	push	0
	push	1
	mov	ecx, DWORD PTR _pWonderCity$[ebp]
	call	?getCurrentProductionDifference@CvCity@@QBEH_N0@Z ; CvCity::getCurrentProductionDifference
	mov	DWORD PTR _iEstimatedProductionPerTurn$[ebp], eax

; 374  : 	if(iEstimatedProductionPerTurn < 1)

	cmp	DWORD PTR _iEstimatedProductionPerTurn$[ebp], 1
	jge	SHORT $LN28@ChooseWond

; 375  : 	{
; 376  : 		iEstimatedProductionPerTurn = 1;

	mov	DWORD PTR _iEstimatedProductionPerTurn$[ebp], 1
$LN28@ChooseWond:

; 377  : 	}
; 378  : 
; 379  : 	// Loop through adding the available wonders
; 380  : 	for(iBldgLoop = 0; iBldgLoop < GC.GetGameBuildings()->GetNumBuildings(); iBldgLoop++)

	mov	DWORD PTR _iBldgLoop$[ebp], 0
	jmp	SHORT $LN27@ChooseWond
$LN26@ChooseWond:
	mov	eax, DWORD PTR _iBldgLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iBldgLoop$[ebp], eax
$LN27@ChooseWond:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	cmp	DWORD PTR _iBldgLoop$[ebp], eax
	jge	$LN25@ChooseWond

; 381  : 	{
; 382  : 		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBldgLoop);

	mov	ecx, DWORD PTR _iBldgLoop$[ebp]
	mov	DWORD PTR _eBuilding$223008[ebp], ecx

; 383  : 		CvBuildingEntry* pkBuildingInfo = m_pBuildings->GetEntry(eBuilding);

	mov	edx, DWORD PTR _eBuilding$223008[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	DWORD PTR _pkBuildingInfo$223010[ebp], eax

; 384  : 		if(pkBuildingInfo)

	cmp	DWORD PTR _pkBuildingInfo$223010[ebp], 0
	je	$LN24@ChooseWond

; 385  : 		{
; 386  : 			CvBuildingEntry& kBuilding = *pkBuildingInfo;

	mov	ecx, DWORD PTR _pkBuildingInfo$223010[ebp]
	mov	DWORD PTR _kBuilding$223012[ebp], ecx

; 387  : 			const CvBuildingClassInfo& kBuildingClassInfo = kBuilding.GetBuildingClassInfo();

	mov	ecx, DWORD PTR _kBuilding$223012[ebp]
	call	?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ ; CvBuildingEntry::GetBuildingClassInfo
	mov	DWORD PTR _kBuildingClassInfo$223013[ebp], eax

; 388  : #ifdef NQM_AI_GIMP_NO_WORLD_WONDERS
; 389  : 			if ((GC.getGame().isOption("GAMEOPTION_AI_TWEAKS") || GC.getGame().isOption("GAMEOPTION_AI_GIMP_NO_WORLD_WONDER")) && isWorldWonderClass(kBuildingClassInfo))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224643[ebp], edx
	push	OFFSET ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
	mov	ecx, DWORD PTR $T224643[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN22@ChooseWond
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224647[ebp], ecx
	push	OFFSET ??_C@_0CD@DIPKFMBK@GAMEOPTION_AI_GIMP_NO_WORLD_WOND@
	mov	ecx, DWORD PTR $T224647[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN23@ChooseWond
$LN22@ChooseWond:
	mov	eax, DWORD PTR _kBuildingClassInfo$223013[ebp]
	push	eax
	call	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isWorldWonderClass
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN23@ChooseWond

; 390  : 			{
; 391  : 				continue;

	jmp	$LN26@ChooseWond
$LN23@ChooseWond:

; 392  : 			}
; 393  : #endif
; 394  : 
; 395  : 			// Make sure this wonder can be built now
; 396  : 			if(IsWonder(kBuilding) && HaveCityToBuild((BuildingTypes)iBldgLoop))

	mov	edx, DWORD PTR _kBuilding$223012[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsWonder@CvWonderProductionAI@@QBE_NABVCvBuildingEntry@@@Z ; CvWonderProductionAI::IsWonder
	movzx	eax, al
	test	eax, eax
	je	$LN24@ChooseWond
	mov	ecx, DWORD PTR _iBldgLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HaveCityToBuild@CvWonderProductionAI@@ABE_NW4BuildingTypes@@@Z ; CvWonderProductionAI::HaveCityToBuild
	movzx	edx, al
	test	edx, edx
	je	$LN24@ChooseWond

; 397  : 			{
; 398  : 				iTurnsRequired = std::max(1, kBuilding.GetProductionCost() / iEstimatedProductionPerTurn);

	mov	ecx, DWORD PTR _kBuilding$223012[ebp]
	call	?GetProductionCost@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetProductionCost
	cdq
	idiv	DWORD PTR _iEstimatedProductionPerTurn$[ebp]
	mov	DWORD PTR $T224536[ebp], eax
	mov	DWORD PTR $T224537[ebp], 1
	mov	eax, DWORD PTR $T224537[ebp]
	cmp	eax, DWORD PTR $T224536[ebp]
	jge	SHORT $LN79@ChooseWond
	lea	ecx, DWORD PTR $T224536[ebp]
	mov	DWORD PTR tv78[ebp], ecx
	jmp	SHORT $LN80@ChooseWond
$LN79@ChooseWond:
	lea	edx, DWORD PTR $T224537[ebp]
	mov	DWORD PTR tv78[ebp], edx
$LN80@ChooseWond:
	mov	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR $T224654[ebp], eax
	mov	ecx, DWORD PTR $T224654[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iTurnsRequired$[ebp], edx

; 399  : 
; 400  : 				// if we are forced to restart a wonder, give one that has been started already a huge bump
; 401  : 				bool bAlreadyStarted = pWonderCity->GetCityBuildings()->GetBuildingProduction(eBuilding) > 0;

	mov	eax, DWORD PTR _eBuilding$223008[ebp]
	push	eax
	mov	ecx, DWORD PTR _pWonderCity$[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetBuildingProduction@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetBuildingProduction
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	BYTE PTR _bAlreadyStarted$223022[ebp], cl

; 402  : 				int iTempWeight = bAlreadyStarted ? m_WonderAIWeights.GetWeight(iBldgLoop) * 25 : m_WonderAIWeights.GetWeight(iBldgLoop);

	movzx	edx, BYTE PTR _bAlreadyStarted$223022[ebp]
	test	edx, edx
	je	SHORT $LN35@ChooseWond
	mov	eax, DWORD PTR _iBldgLoop$[ebp]
	mov	DWORD PTR $T224671[ebp], eax
	mov	DWORD PTR _elem$224670[ebp], 0
	mov	DWORD PTR _elem$224670[ebp+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR $T224671[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR _elem$224670[ebp], ecx
	mov	DWORD PTR _elem$224670[ebp+4], edx
	mov	eax, DWORD PTR _elem$224670[ebp+4]
	imul	eax, 25					; 00000019H
	mov	DWORD PTR tv200[ebp], eax
	jmp	SHORT $LN36@ChooseWond
$LN35@ChooseWond:
	mov	ecx, DWORD PTR _iBldgLoop$[ebp]
	mov	DWORD PTR $T224686[ebp], ecx
	mov	DWORD PTR _elem$224685[ebp], 0
	mov	DWORD PTR _elem$224685[ebp+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR $T224686[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$224685[ebp], edx
	mov	DWORD PTR _elem$224685[ebp+4], eax
	mov	ecx, DWORD PTR _elem$224685[ebp+4]
	mov	DWORD PTR tv200[ebp], ecx
$LN36@ChooseWond:
	mov	edx, DWORD PTR tv200[ebp]
	mov	DWORD PTR _iTempWeight$223023[ebp], edx

; 403  : 
; 404  : 				// Don't build the UN if you aren't going for the diplo victory
; 405  : 				if(pkBuildingInfo->IsDiplomaticVoting())

	mov	ecx, DWORD PTR _pkBuildingInfo$223010[ebp]
	call	?IsDiplomaticVoting@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsDiplomaticVoting
	movzx	eax, al
	test	eax, eax
	je	$LN20@ChooseWond

; 406  : 				{
; 407  : 					int iVotesNeededToWin = GC.getGame().GetVotesNeededForDiploVictory();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224690[ebp], ecx
	mov	ecx, DWORD PTR $T224690[ebp]
	call	?GetVotesNeededForDiploVictory@CvGame@@QBEHXZ ; CvGame::GetVotesNeededForDiploVictory
	mov	DWORD PTR _iVotesNeededToWin$223025[ebp], eax

; 408  : 					int iSecuredVotes = 0;

	mov	DWORD PTR _iSecuredVotes$223026[ebp], 0

; 409  : 					TeamTypes myTeamID = m_pPlayer->getTeam();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR $T224699[ebp], eax
	mov	ecx, DWORD PTR $T224699[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _myTeamID$223027[ebp], eax

; 410  : 					PlayerTypes myPlayerID = m_pPlayer->GetID();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _myPlayerID$223028[ebp], edx

; 411  : 
; 412  : 					// Loop through Players to see if they'll vote for this player
; 413  : 					PlayerTypes eLoopPlayer;
; 414  : 					TeamTypes eLoopTeam;
; 415  : 					for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$223031[ebp], 0
	jmp	SHORT $LN19@ChooseWond
$LN18@ChooseWond:
	mov	eax, DWORD PTR _iPlayerLoop$223031[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayerLoop$223031[ebp], eax
$LN19@ChooseWond:
	cmp	DWORD PTR _iPlayerLoop$223031[ebp], 63	; 0000003fH
	jge	$LN17@ChooseWond

; 416  : 					{
; 417  : 						eLoopPlayer = (PlayerTypes) iPlayerLoop;

	mov	ecx, DWORD PTR _iPlayerLoop$223031[ebp]
	mov	DWORD PTR _eLoopPlayer$223029[ebp], ecx

; 418  : 
; 419  : 						if(GET_PLAYER(eLoopPlayer).isAlive())

	mov	edx, DWORD PTR _eLoopPlayer$223029[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T224711[ebp], edx
	mov	eax, DWORD PTR $T224711[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T224720[ebp], cl
	movzx	edx, BYTE PTR $T224720[ebp]
	test	edx, edx
	je	$LN16@ChooseWond

; 420  : 						{
; 421  : 							eLoopTeam = GET_PLAYER(eLoopPlayer).getTeam();

	mov	eax, DWORD PTR _eLoopPlayer$223029[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T224724[ebp], eax
	mov	ecx, DWORD PTR $T224724[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eLoopTeam$223030[ebp], eax

; 422  : 
; 423  : 							// Liberated?
; 424  : 							if(GET_TEAM(eLoopTeam).GetLiberatedByTeam() == myTeamID)

	mov	eax, DWORD PTR _eLoopTeam$223030[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T224736[ebp], eax
	mov	ecx, DWORD PTR $T224736[ebp]
	call	?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetLiberatedByTeam
	cmp	eax, DWORD PTR _myTeamID$223027[ebp]
	jne	SHORT $LN15@ChooseWond

; 425  : 							{
; 426  : 								iSecuredVotes++;

	mov	ecx, DWORD PTR _iSecuredVotes$223026[ebp]
	add	ecx, 1
	mov	DWORD PTR _iSecuredVotes$223026[ebp], ecx
	jmp	SHORT $LN16@ChooseWond
$LN15@ChooseWond:

; 427  : 							}
; 428  : 
; 429  : 							// Minor civ?
; 430  : 							else if(GET_PLAYER(eLoopPlayer).isMinorCiv())

	mov	edx, DWORD PTR _eLoopPlayer$223029[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T224740[ebp], edx
	mov	ecx, DWORD PTR $T224740[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@ChooseWond

; 431  : 							{
; 432  : 								// Best Relations?
; 433  : 								if(GET_PLAYER(eLoopPlayer).GetMinorCivAI()->GetAlly() == myPlayerID)

	mov	ecx, DWORD PTR _eLoopPlayer$223029[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T224744[ebp], ecx
	mov	ecx, DWORD PTR $T224744[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	cmp	eax, DWORD PTR _myPlayerID$223028[ebp]
	jne	SHORT $LN16@ChooseWond

; 434  : 								{
; 435  : 									iSecuredVotes++;

	mov	edx, DWORD PTR _iSecuredVotes$223026[ebp]
	add	edx, 1
	mov	DWORD PTR _iSecuredVotes$223026[ebp], edx
$LN16@ChooseWond:

; 436  : 								}
; 437  : 							}
; 438  : 						}
; 439  : 					}

	jmp	$LN18@ChooseWond
$LN17@ChooseWond:

; 440  : 
; 441  : 					int iNumberOfPlayersWeNeedToBuyOff = MAX(0, iVotesNeededToWin - iSecuredVotes);

	mov	eax, DWORD PTR _iVotesNeededToWin$223025[ebp]
	sub	eax, DWORD PTR _iSecuredVotes$223026[ebp]
	mov	DWORD PTR $T224540[ebp], eax
	mov	DWORD PTR $T224541[ebp], 0
	mov	ecx, DWORD PTR $T224541[ebp]
	cmp	ecx, DWORD PTR $T224540[ebp]
	jge	SHORT $LN123@ChooseWond
	lea	edx, DWORD PTR $T224540[ebp]
	mov	DWORD PTR tv437[ebp], edx
	jmp	SHORT $LN124@ChooseWond
$LN123@ChooseWond:
	lea	eax, DWORD PTR $T224541[ebp]
	mov	DWORD PTR tv437[ebp], eax
$LN124@ChooseWond:
	mov	ecx, DWORD PTR tv437[ebp]
	mov	DWORD PTR $T224751[ebp], ecx
	mov	edx, DWORD PTR $T224751[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _iNumberOfPlayersWeNeedToBuyOff$223041[ebp], eax

; 442  : 
; 443  : 					if(!m_pPlayer->GetDiplomacyAI() || !m_pPlayer->GetDiplomacyAI()->IsGoingForDiploVictory() || m_pPlayer->GetTreasury()->GetGold() < iNumberOfPlayersWeNeedToBuyOff * 500 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	test	eax, eax
	je	SHORT $LN10@ChooseWond
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForDiploVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForDiploVictory
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@ChooseWond
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	mov	edx, DWORD PTR _iNumberOfPlayersWeNeedToBuyOff$223041[ebp]
	imul	edx, 500				; 000001f4H
	cmp	eax, edx
	jge	SHORT $LN20@ChooseWond
$LN10@ChooseWond:

; 444  : 					{
; 445  : 						iTempWeight = 0;

	mov	DWORD PTR _iTempWeight$223023[ebp], 0
$LN20@ChooseWond:

; 446  : 					}
; 447  : 				}
; 448  : 
; 449  : 				iWeight = CityStrategyAIHelpers::ReweightByTurnsLeft(iTempWeight, iTurnsRequired);

	mov	eax, DWORD PTR _iTurnsRequired$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iTempWeight$223023[ebp]
	push	ecx
	call	?ReweightByTurnsLeft@CityStrategyAIHelpers@@YAHHH@Z ; CityStrategyAIHelpers::ReweightByTurnsLeft
	add	esp, 8
	mov	DWORD PTR _iWeight$[ebp], eax

; 450  : 
; 451  : 				if(bAdjustForOtherPlayers && ::isWorldWonderClass(kBuildingClassInfo))

	movzx	edx, BYTE PTR _bAdjustForOtherPlayers$[ebp]
	test	edx, edx
	je	SHORT $LN9@ChooseWond
	mov	eax, DWORD PTR _kBuildingClassInfo$223013[ebp]
	push	eax
	call	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isWorldWonderClass
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@ChooseWond

; 452  : 				{
; 453  : 					// Adjust weight for this wonder down based on number of other players currently working on it
; 454  : 					int iNumOthersConstructing = 0;

	mov	DWORD PTR _iNumOthersConstructing$223047[ebp], 0

; 455  : 					for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$223048[ebp], 0
	jmp	SHORT $LN8@ChooseWond
$LN7@ChooseWond:
	mov	edx, DWORD PTR _iPlayerLoop$223048[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlayerLoop$223048[ebp], edx
$LN8@ChooseWond:
	cmp	DWORD PTR _iPlayerLoop$223048[ebp], 22	; 00000016H
	jge	SHORT $LN6@ChooseWond

; 456  : 					{
; 457  : 						PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

	mov	eax, DWORD PTR _iPlayerLoop$223048[ebp]
	mov	DWORD PTR _eLoopPlayer$223052[ebp], eax

; 458  : 						if(GET_PLAYER(eLoopPlayer).getBuildingClassMaking((BuildingClassTypes)kBuilding.GetBuildingClassType()) > 0)

	mov	ecx, DWORD PTR _eLoopPlayer$223052[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T224757[ebp], ecx
	mov	ecx, DWORD PTR _kBuilding$223012[ebp]
	call	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingClassType
	push	eax
	mov	ecx, DWORD PTR $T224757[ebp]
	call	?getBuildingClassMaking@CvPlayer@@QBEHW4BuildingClassTypes@@@Z ; CvPlayer::getBuildingClassMaking
	test	eax, eax
	jle	SHORT $LN5@ChooseWond

; 459  : 						{
; 460  : 							iNumOthersConstructing++;

	mov	edx, DWORD PTR _iNumOthersConstructing$223047[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumOthersConstructing$223047[ebp], edx
$LN5@ChooseWond:

; 461  : 						}
; 462  : 					}

	jmp	SHORT $LN7@ChooseWond
$LN6@ChooseWond:

; 463  : 					iWeight = iWeight / (1 + iNumOthersConstructing);

	mov	ecx, DWORD PTR _iNumOthersConstructing$223047[ebp]
	add	ecx, 1
	mov	eax, DWORD PTR _iWeight$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _iWeight$[ebp], eax
$LN9@ChooseWond:

; 464  : 				}
; 465  : 
; 466  : 				m_Buildables.push_back(iBldgLoop, iWeight);

	mov	DWORD PTR _weightedElem$224778[ebp], 0
	mov	DWORD PTR _weightedElem$224778[ebp+4], 0
	mov	edx, DWORD PTR _iBldgLoop$[ebp]
	mov	DWORD PTR _weightedElem$224778[ebp], edx
	mov	eax, DWORD PTR _iWeight$[ebp]
	mov	DWORD PTR _weightedElem$224778[ebp+4], eax
	lea	ecx, DWORD PTR _weightedElem$224778[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1116				; 0000045cH
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@Z ; FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>::push_back
$LN24@ChooseWond:

; 467  : 			}
; 468  : 		}
; 469  : 	}

	jmp	$LN26@ChooseWond
$LN25@ChooseWond:

; 470  : 
; 471  : 	// Sort items and grab the first one
; 472  : 	if(m_Buildables.size() > 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1120]
	mov	DWORD PTR $T224783[ebp], eax
	cmp	DWORD PTR $T224783[ebp], 0
	jle	$LN4@ChooseWond

; 473  : 	{
; 474  : 		m_Buildables.SortItems();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1116				; 0000045cH
	mov	DWORD PTR $T224834[ebp], ecx
	mov	edx, DWORD PTR $T224834[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR $T224834[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T224792[ebp], eax
	mov	ecx, DWORD PTR $T224834[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T224796[ebp], edx
	mov	eax, DWORD PTR $T224792[ebp]
	sub	eax, DWORD PTR $T224796[ebp]
	sar	eax, 3
	push	eax
	mov	ecx, DWORD PTR $T224792[ebp]
	push	ecx
	mov	edx, DWORD PTR $T224796[ebp]
	push	edx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,50,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 475  : 		LogPossibleWonders();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ ; CvWonderProductionAI::LogPossibleWonders

; 476  : 
; 477  : 		if(m_Buildables.GetTotalWeight() > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1116				; 0000045cH
	call	?GetTotalWeight@?$CvWeightedVector@H$0DC@$00@@QAEHXZ ; CvWeightedVector<int,50,1>::GetTotalWeight
	test	eax, eax
	jle	SHORT $LN3@ChooseWond

; 478  : 		{
; 479  : 			int iNumChoices = GC.getGame().getHandicapInfo().GetCityProductionNumOptions();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224850[ebp], eax
	mov	ecx, DWORD PTR $T224850[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	ecx, eax
	call	?GetCityProductionNumOptions@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::GetCityProductionNumOptions
	mov	DWORD PTR _iNumChoices$223058[ebp], eax

; 480  : 			eSelection = (BuildingTypes)m_Buildables.ChooseFromTopChoices(iNumChoices, &fcn, "Choosing wonder from Top Choices");

	push	OFFSET ??_C@_0CB@NGOAAMEE@Choosing?5wonder?5from?5Top?5Choices@
	lea	ecx, DWORD PTR _fcn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iNumChoices$223058[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1116				; 0000045cH
	call	?ChooseFromTopChoices@?$CvWeightedVector@H$0DC@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<int,50,1>::ChooseFromTopChoices
	mov	DWORD PTR _eSelection$[ebp], eax

; 481  : 			iWonderWeight = m_Buildables.GetTotalWeight();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1116				; 0000045cH
	call	?GetTotalWeight@?$CvWeightedVector@H$0DC@$00@@QAEHXZ ; CvWeightedVector<int,50,1>::GetTotalWeight
	mov	ecx, DWORD PTR _iWonderWeight$[ebp]
	mov	DWORD PTR [ecx], eax

; 482  : 			return eSelection;

	mov	eax, DWORD PTR _eSelection$[ebp]
	jmp	SHORT $LN33@ChooseWond

; 483  : 		}
; 484  : 
; 485  : 		// Nothing with any weight
; 486  : 		else

	jmp	SHORT $LN2@ChooseWond
$LN3@ChooseWond:

; 487  : 		{
; 488  : 			return NO_BUILDING;

	or	eax, -1
	jmp	SHORT $LN33@ChooseWond
$LN2@ChooseWond:

; 489  : 		}
; 490  : 	}
; 491  : 
; 492  : 	// Unless we didn't find any
; 493  : 	else

	jmp	SHORT $LN33@ChooseWond
$LN4@ChooseWond:

; 494  : 	{
; 495  : 		return NO_BUILDING;

	or	eax, -1
$LN33@ChooseWond:

; 496  : 	}
; 497  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ChooseWonder@CvWonderProductionAI@@QAE?AW4BuildingTypes@@_N0AAH@Z ENDP ; CvWonderProductionAI::ChooseWonder
_TEXT	ENDS
PUBLIC	?ChooseWonderForGreatEngineer@CvWonderProductionAI@@QAE?AW4BuildingTypes@@_NAAHAAPAVCvCity@@@Z ; CvWonderProductionAI::ChooseWonderForGreatEngineer
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?canConstruct@CvCity@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z:PROC ; CvCity::canConstruct
; Function compile flags: /Odtp
;	COMDAT ?ChooseWonderForGreatEngineer@CvWonderProductionAI@@QAE?AW4BuildingTypes@@_NAAHAAPAVCvCity@@@Z
_TEXT	SEGMENT
tv400 = -328						; size = 4
_this$ = -324						; size = 4
$T225178 = -236						; size = 4
$T225128 = -216						; size = 4
$T225124 = -212						; size = 4
$T225115 = -208						; size = 4
_weightedElem$225110 = -196				; size = 8
$T225087 = -188						; size = 4
$T225080 = -184						; size = 4
$T225076 = -180						; size = 4
$T225072 = -176						; size = 4
$T225060 = -172						; size = 4
$T225056 = -165						; size = 1
$T225047 = -164						; size = 4
$T225035 = -160						; size = 4
$T225026 = -156						; size = 4
$T225022 = -152						; size = 4
_elem$225021 = -148					; size = 8
$T225007 = -140						; size = 4
$T225003 = -136						; size = 4
$T224999 = -132						; size = 4
_i$224993 = -128					; size = 4
$T224968 = -124						; size = 4
$T224952 = -120						; size = 4
$T224948 = -116						; size = 4
$T224932 = -112						; size = 4
$T224901 = -108						; size = 4
$T224900 = -104						; size = 4
$T224899 = -100						; size = 8
$T224898 = -92						; size = 8
_pLoopCity$223122 = -84					; size = 4
_iLoop$223123 = -80					; size = 4
_iNumChoices$223118 = -76				; size = 4
_iPlayerLoop$223101 = -72				; size = 4
_iVotesNeededToWin$223095 = -68				; size = 4
_eLoopPlayer$223099 = -64				; size = 4
_iSecuredVotes$223096 = -60				; size = 4
_iNumberOfPlayersWeNeedToBuyOff$223111 = -56		; size = 4
_myTeamID$223097 = -52					; size = 4
_eLoopTeam$223100 = -48					; size = 4
_myPlayerID$223098 = -44				; size = 4
_kBuilding$223088 = -40					; size = 4
_eBuilding$223084 = -36					; size = 4
_pkBuildingInfo$223086 = -32				; size = 4
_fcn$ = -28						; size = 8
_iCityLoop$ = -20					; size = 4
_iWeight$ = -16						; size = 4
_iBldgLoop$ = -12					; size = 4
_pWonderCity$ = -8					; size = 4
_eSelection$ = -4					; size = 4
_bUseAsyncRandom$ = 8					; size = 1
_iWonderWeight$ = 12					; size = 4
_pCityToBuildAt$ = 16					; size = 4
?ChooseWonderForGreatEngineer@CvWonderProductionAI@@QAE?AW4BuildingTypes@@_NAAHAAPAVCvCity@@@Z PROC ; CvWonderProductionAI::ChooseWonderForGreatEngineer, COMDAT
; _this$ = ecx

; 502  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 328				; 00000148H
	mov	DWORD PTR _this$[ebp], ecx

; 503  : #ifdef AUI_WARNING_FIXES
; 504  : 	uint iBldgLoop;
; 505  : #else
; 506  : 	int iBldgLoop;
; 507  : #endif
; 508  : 	int iWeight;
; 509  : 	int iCityLoop;
; 510  : 	RandomNumberDelegate fcn;

	mov	DWORD PTR _fcn$[ebp], 0
	mov	DWORD PTR _fcn$[ebp+4], 0
	mov	DWORD PTR _fcn$[ebp], 0
	mov	DWORD PTR _fcn$[ebp+4], 0

; 511  : 	BuildingTypes eSelection;
; 512  : 
; 513  : 	pCityToBuildAt = 0;

	mov	eax, DWORD PTR _pCityToBuildAt$[ebp]
	mov	DWORD PTR [eax], 0

; 514  : 	iWonderWeight = 0;

	mov	ecx, DWORD PTR _iWonderWeight$[ebp]
	mov	DWORD PTR [ecx], 0

; 515  : 
; 516  : 	// Use the asynchronous random number generate if "no random" is set
; 517  : 	if (bUseAsyncRandom)

	movzx	edx, BYTE PTR _bUseAsyncRandom$[ebp]
	test	edx, edx
	je	SHORT $LN32@ChooseWond@2

; 518  : 	{
; 519  : 		fcn = MakeDelegate(&GC.getGame(), &CvGame::getAsyncRandNum);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224932[ebp], eax
	push	OFFSET ?getAsyncRandNum@CvGame@@QAEHHPBD@Z ; CvGame::getAsyncRandNum
	mov	ecx, DWORD PTR $T224932[ebp]
	push	ecx
	lea	edx, DWORD PTR $T224898[ebp]
	push	edx
	call	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T224948[ebp], eax
	mov	eax, DWORD PTR $T224948[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _fcn$[ebp+4], ecx
	mov	edx, DWORD PTR $T224948[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _fcn$[ebp], eax

; 520  : 	}
; 521  : 	else

	jmp	SHORT $LN31@ChooseWond@2
$LN32@ChooseWond@2:

; 522  : 	{
; 523  : 		fcn = MakeDelegate(&GC.getGame(), &CvGame::getJonRandNum);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224952[ebp], ecx
	push	OFFSET ?getJonRandNum@CvGame@@QAEHHPBD@Z ; CvGame::getJonRandNum
	mov	edx, DWORD PTR $T224952[ebp]
	push	edx
	lea	eax, DWORD PTR $T224899[ebp]
	push	eax
	call	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T224968[ebp], eax
	mov	ecx, DWORD PTR $T224968[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _fcn$[ebp+4], edx
	mov	eax, DWORD PTR $T224968[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _fcn$[ebp], ecx
$LN31@ChooseWond@2:

; 524  : 	}
; 525  : 
; 526  : 	// Reset list of all the possible wonders
; 527  : 	m_Buildables.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1116				; 0000045cH
	mov	DWORD PTR $T224999[ebp], edx
	xor	eax, eax
	je	SHORT $LN69@ChooseWond@2
	mov	DWORD PTR _i$224993[ebp], 0
	jmp	SHORT $LN67@ChooseWond@2
$LN66@ChooseWond@2:
	mov	ecx, DWORD PTR _i$224993[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$224993[ebp], ecx
$LN67@ChooseWond@2:
	mov	edx, DWORD PTR $T224999[ebp]
	mov	eax, DWORD PTR _i$224993[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN69@ChooseWond@2
	jmp	SHORT $LN66@ChooseWond@2
$LN69@ChooseWond@2:
	mov	ecx, DWORD PTR $T224999[ebp]
	mov	DWORD PTR [ecx+4], 0

; 528  : 
; 529  : 	// Guess which city will be producing this
; 530  : 	CvCity* pWonderCity = m_pPlayer->GetCitySpecializationAI()->GetWonderBuildCity();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ ; CvPlayer::GetCitySpecializationAI
	mov	ecx, eax
	call	?GetWonderBuildCity@CvCitySpecializationAI@@QBEPAVCvCity@@XZ ; CvCitySpecializationAI::GetWonderBuildCity
	mov	DWORD PTR _pWonderCity$[ebp], eax

; 531  : 	if (pWonderCity == NULL)

	cmp	DWORD PTR _pWonderCity$[ebp], 0
	jne	SHORT $LN30@ChooseWond@2

; 532  : 	{
; 533  : 		pWonderCity = m_pPlayer->firstCity(&iCityLoop);

	push	0
	lea	eax, DWORD PTR _iCityLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pWonderCity$[ebp], eax
$LN30@ChooseWond@2:

; 534  : 	}
; 535  : 
; 536  : 	CvAssertMsg(pWonderCity, "Trying to choose the next wonder to build and the player has no cities!");
; 537  : 	if (pWonderCity == NULL)

	cmp	DWORD PTR _pWonderCity$[ebp], 0
	jne	SHORT $LN29@ChooseWond@2

; 538  : 		return NO_BUILDING;

	or	eax, -1
	jmp	$LN33@ChooseWond@2
$LN29@ChooseWond@2:

; 539  : 
; 540  : 	// Loop through adding the available wonders
; 541  : 	for (iBldgLoop = 0; iBldgLoop < GC.GetGameBuildings()->GetNumBuildings(); iBldgLoop++)

	mov	DWORD PTR _iBldgLoop$[ebp], 0
	jmp	SHORT $LN28@ChooseWond@2
$LN27@ChooseWond@2:
	mov	edx, DWORD PTR _iBldgLoop$[ebp]
	add	edx, 1
	mov	DWORD PTR _iBldgLoop$[ebp], edx
$LN28@ChooseWond@2:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	cmp	DWORD PTR _iBldgLoop$[ebp], eax
	jge	$LN26@ChooseWond@2

; 542  : 	{
; 543  : 		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBldgLoop);

	mov	eax, DWORD PTR _iBldgLoop$[ebp]
	mov	DWORD PTR _eBuilding$223084[ebp], eax

; 544  : 		CvBuildingEntry* pkBuildingInfo = m_pBuildings->GetEntry(eBuilding);

	mov	ecx, DWORD PTR _eBuilding$223084[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	DWORD PTR _pkBuildingInfo$223086[ebp], eax

; 545  : 		if (pkBuildingInfo)

	cmp	DWORD PTR _pkBuildingInfo$223086[ebp], 0
	je	$LN25@ChooseWond@2

; 546  : 		{
; 547  : 			CvBuildingEntry& kBuilding = *pkBuildingInfo;

	mov	eax, DWORD PTR _pkBuildingInfo$223086[ebp]
	mov	DWORD PTR _kBuilding$223088[ebp], eax

; 548  : #ifdef NQM_AI_GIMP_NO_WORLD_WONDERS
; 549  : 			if ((GC.getGame().isOption("GAMEOPTION_AI_TWEAKS") || GC.getGame().isOption("GAMEOPTION_AI_GIMP_NO_WORLD_WONDER")) && isWorldWonderClass(kBuilding.GetBuildingClassInfo()))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T225003[ebp], ecx
	push	OFFSET ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
	mov	ecx, DWORD PTR $T225003[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN23@ChooseWond@2
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T225007[ebp], eax
	push	OFFSET ??_C@_0CD@DIPKFMBK@GAMEOPTION_AI_GIMP_NO_WORLD_WOND@
	mov	ecx, DWORD PTR $T225007[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN24@ChooseWond@2
$LN23@ChooseWond@2:
	mov	ecx, DWORD PTR _kBuilding$223088[ebp]
	call	?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ ; CvBuildingEntry::GetBuildingClassInfo
	push	eax
	call	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isWorldWonderClass
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN24@ChooseWond@2

; 550  : 			{
; 551  : 				continue;

	jmp	$LN27@ChooseWond@2
$LN24@ChooseWond@2:

; 552  : 			}
; 553  : #endif
; 554  : 			// Make sure this wonder can be built now
; 555  : 			if (IsWonder(kBuilding) && HaveCityToBuild((BuildingTypes)iBldgLoop))

	mov	eax, DWORD PTR _kBuilding$223088[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsWonder@CvWonderProductionAI@@QBE_NABVCvBuildingEntry@@@Z ; CvWonderProductionAI::IsWonder
	movzx	ecx, al
	test	ecx, ecx
	je	$LN25@ChooseWond@2
	mov	edx, DWORD PTR _iBldgLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HaveCityToBuild@CvWonderProductionAI@@ABE_NW4BuildingTypes@@@Z ; CvWonderProductionAI::HaveCityToBuild
	movzx	eax, al
	test	eax, eax
	je	$LN25@ChooseWond@2

; 556  : 			{
; 557  : 				iWeight = m_WonderAIWeights.GetWeight((UnitTypes)iBldgLoop); // use raw weight since this wonder is essentially free

	mov	ecx, DWORD PTR _iBldgLoop$[ebp]
	mov	DWORD PTR $T225022[ebp], ecx
	mov	DWORD PTR _elem$225021[ebp], 0
	mov	DWORD PTR _elem$225021[ebp+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR $T225022[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$225021[ebp], edx
	mov	DWORD PTR _elem$225021[ebp+4], eax
	mov	ecx, DWORD PTR _elem$225021[ebp+4]
	mov	DWORD PTR _iWeight$[ebp], ecx

; 558  : 				// Don't build the UN if you aren't going for the diplo victory and have a chance of winning it
; 559  : 				if(pkBuildingInfo->IsDiplomaticVoting())

	mov	ecx, DWORD PTR _pkBuildingInfo$223086[ebp]
	call	?IsDiplomaticVoting@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsDiplomaticVoting
	movzx	edx, al
	test	edx, edx
	je	$LN21@ChooseWond@2

; 560  : 				{
; 561  : 					int iVotesNeededToWin = GC.getGame().GetVotesNeededForDiploVictory();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T225026[ebp], eax
	mov	ecx, DWORD PTR $T225026[ebp]
	call	?GetVotesNeededForDiploVictory@CvGame@@QBEHXZ ; CvGame::GetVotesNeededForDiploVictory
	mov	DWORD PTR _iVotesNeededToWin$223095[ebp], eax

; 562  : 					int iSecuredVotes = 0;

	mov	DWORD PTR _iSecuredVotes$223096[ebp], 0

; 563  : 					TeamTypes myTeamID = m_pPlayer->getTeam();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR $T225035[ebp], edx
	mov	eax, DWORD PTR $T225035[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _myTeamID$223097[ebp], eax

; 564  : 					PlayerTypes myPlayerID = m_pPlayer->GetID();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _myPlayerID$223098[ebp], ecx

; 565  : 
; 566  : 					// Loop through Players to see if they'll vote for this player
; 567  : 					PlayerTypes eLoopPlayer;
; 568  : 					TeamTypes eLoopTeam;
; 569  : 					for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$223101[ebp], 0
	jmp	SHORT $LN20@ChooseWond@2
$LN19@ChooseWond@2:
	mov	edx, DWORD PTR _iPlayerLoop$223101[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlayerLoop$223101[ebp], edx
$LN20@ChooseWond@2:
	cmp	DWORD PTR _iPlayerLoop$223101[ebp], 63	; 0000003fH
	jge	$LN18@ChooseWond@2

; 570  : 					{
; 571  : 						eLoopPlayer = (PlayerTypes) iPlayerLoop;

	mov	eax, DWORD PTR _iPlayerLoop$223101[ebp]
	mov	DWORD PTR _eLoopPlayer$223099[ebp], eax

; 572  : 
; 573  : 						if(GET_PLAYER(eLoopPlayer).isAlive())

	mov	ecx, DWORD PTR _eLoopPlayer$223099[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T225047[ebp], ecx
	mov	edx, DWORD PTR $T225047[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T225056[ebp], al
	movzx	ecx, BYTE PTR $T225056[ebp]
	test	ecx, ecx
	je	$LN17@ChooseWond@2

; 574  : 						{
; 575  : 							eLoopTeam = GET_PLAYER(eLoopPlayer).getTeam();

	mov	edx, DWORD PTR _eLoopPlayer$223099[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T225060[ebp], edx
	mov	eax, DWORD PTR $T225060[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eLoopTeam$223100[ebp], eax

; 576  : 
; 577  : 							// Liberated?
; 578  : 							if(GET_TEAM(eLoopTeam).GetLiberatedByTeam() == myTeamID)

	mov	edx, DWORD PTR _eLoopTeam$223100[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T225072[ebp], edx
	mov	ecx, DWORD PTR $T225072[ebp]
	call	?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetLiberatedByTeam
	cmp	eax, DWORD PTR _myTeamID$223097[ebp]
	jne	SHORT $LN16@ChooseWond@2

; 579  : 							{
; 580  : 								iSecuredVotes++;

	mov	eax, DWORD PTR _iSecuredVotes$223096[ebp]
	add	eax, 1
	mov	DWORD PTR _iSecuredVotes$223096[ebp], eax
	jmp	SHORT $LN17@ChooseWond@2
$LN16@ChooseWond@2:

; 581  : 							}
; 582  : 
; 583  : 							// Minor civ?
; 584  : 							else if(GET_PLAYER(eLoopPlayer).isMinorCiv())

	mov	ecx, DWORD PTR _eLoopPlayer$223099[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T225076[ebp], ecx
	mov	ecx, DWORD PTR $T225076[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN17@ChooseWond@2

; 585  : 							{
; 586  : 								// Best Relations?
; 587  : 								if(GET_PLAYER(eLoopPlayer).GetMinorCivAI()->GetAlly() == myPlayerID)

	mov	eax, DWORD PTR _eLoopPlayer$223099[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T225080[ebp], eax
	mov	ecx, DWORD PTR $T225080[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	cmp	eax, DWORD PTR _myPlayerID$223098[ebp]
	jne	SHORT $LN17@ChooseWond@2

; 588  : 								{
; 589  : 									iSecuredVotes++;

	mov	ecx, DWORD PTR _iSecuredVotes$223096[ebp]
	add	ecx, 1
	mov	DWORD PTR _iSecuredVotes$223096[ebp], ecx
$LN17@ChooseWond@2:

; 590  : 								}
; 591  : 							}
; 592  : 						}
; 593  : 					}

	jmp	$LN19@ChooseWond@2
$LN18@ChooseWond@2:

; 594  : 
; 595  : 					int iNumberOfPlayersWeNeedToBuyOff = MAX(0, iVotesNeededToWin - iSecuredVotes);

	mov	edx, DWORD PTR _iVotesNeededToWin$223095[ebp]
	sub	edx, DWORD PTR _iSecuredVotes$223096[ebp]
	mov	DWORD PTR $T224900[ebp], edx
	mov	DWORD PTR $T224901[ebp], 0
	mov	eax, DWORD PTR $T224901[ebp]
	cmp	eax, DWORD PTR $T224900[ebp]
	jge	SHORT $LN111@ChooseWond@2
	lea	ecx, DWORD PTR $T224900[ebp]
	mov	DWORD PTR tv400[ebp], ecx
	jmp	SHORT $LN112@ChooseWond@2
$LN111@ChooseWond@2:
	lea	edx, DWORD PTR $T224901[ebp]
	mov	DWORD PTR tv400[ebp], edx
$LN112@ChooseWond@2:
	mov	eax, DWORD PTR tv400[ebp]
	mov	DWORD PTR $T225087[ebp], eax
	mov	ecx, DWORD PTR $T225087[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iNumberOfPlayersWeNeedToBuyOff$223111[ebp], edx

; 596  : 
; 597  : 					if(!m_pPlayer->GetDiplomacyAI() || !m_pPlayer->GetDiplomacyAI()->IsGoingForDiploVictory() || m_pPlayer->GetTreasury()->GetGold() < iNumberOfPlayersWeNeedToBuyOff * 500 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	test	eax, eax
	je	SHORT $LN11@ChooseWond@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForDiploVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForDiploVictory
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN11@ChooseWond@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	mov	ecx, DWORD PTR _iNumberOfPlayersWeNeedToBuyOff$223111[ebp]
	imul	ecx, 500				; 000001f4H
	cmp	eax, ecx
	jge	SHORT $LN21@ChooseWond@2
$LN11@ChooseWond@2:

; 598  : 					{
; 599  : 						iWeight = 0;

	mov	DWORD PTR _iWeight$[ebp], 0
$LN21@ChooseWond@2:

; 600  : 					}
; 601  : 				}
; 602  : 				// ??? do we want to weight it more for more expensive wonders?
; 603  : 				m_Buildables.push_back(iBldgLoop, iWeight);

	mov	DWORD PTR _weightedElem$225110[ebp], 0
	mov	DWORD PTR _weightedElem$225110[ebp+4], 0
	mov	edx, DWORD PTR _iBldgLoop$[ebp]
	mov	DWORD PTR _weightedElem$225110[ebp], edx
	mov	eax, DWORD PTR _iWeight$[ebp]
	mov	DWORD PTR _weightedElem$225110[ebp+4], eax
	lea	ecx, DWORD PTR _weightedElem$225110[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1116				; 0000045cH
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@Z ; FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>::push_back
$LN25@ChooseWond@2:

; 604  : 			}
; 605  : 		}
; 606  : 	}

	jmp	$LN27@ChooseWond@2
$LN26@ChooseWond@2:

; 607  : 
; 608  : 	// Sort items and grab the first one
; 609  : 	if(m_Buildables.size() > 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1120]
	mov	DWORD PTR $T225115[ebp], eax
	cmp	DWORD PTR $T225115[ebp], 0
	jle	$LN10@ChooseWond@2

; 610  : 	{
; 611  : 		m_Buildables.SortItems();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1116				; 0000045cH
	mov	DWORD PTR $T225178[ebp], ecx
	mov	edx, DWORD PTR $T225178[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR $T225178[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T225124[ebp], eax
	mov	ecx, DWORD PTR $T225178[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T225128[ebp], edx
	mov	eax, DWORD PTR $T225124[ebp]
	sub	eax, DWORD PTR $T225128[ebp]
	sar	eax, 3
	push	eax
	mov	ecx, DWORD PTR $T225124[ebp]
	push	ecx
	mov	edx, DWORD PTR $T225128[ebp]
	push	edx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,50,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 612  : 		LogPossibleWonders();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ ; CvWonderProductionAI::LogPossibleWonders

; 613  : 
; 614  : 		if(m_Buildables.GetTotalWeight() > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1116				; 0000045cH
	call	?GetTotalWeight@?$CvWeightedVector@H$0DC@$00@@QAEHXZ ; CvWeightedVector<int,50,1>::GetTotalWeight
	test	eax, eax
	jle	$LN9@ChooseWond@2

; 615  : 		{
; 616  : 			int iNumChoices = 1;

	mov	DWORD PTR _iNumChoices$223118[ebp], 1

; 617  : 			eSelection = (BuildingTypes)m_Buildables.ChooseFromTopChoices(iNumChoices, &fcn, "Choosing wonder from Top Choices");

	push	OFFSET ??_C@_0CB@NGOAAMEE@Choosing?5wonder?5from?5Top?5Choices@
	lea	eax, DWORD PTR _fcn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNumChoices$223118[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1116				; 0000045cH
	call	?ChooseFromTopChoices@?$CvWeightedVector@H$0DC@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<int,50,1>::ChooseFromTopChoices
	mov	DWORD PTR _eSelection$[ebp], eax

; 618  : 			iWonderWeight = m_Buildables.GetTotalWeight();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1116				; 0000045cH
	call	?GetTotalWeight@?$CvWeightedVector@H$0DC@$00@@QAEHXZ ; CvWeightedVector<int,50,1>::GetTotalWeight
	mov	edx, DWORD PTR _iWonderWeight$[ebp]
	mov	DWORD PTR [edx], eax

; 619  : 
; 620  : 			// first check if the wonder city can build it
; 621  : 			if (pWonderCity->canConstruct(eSelection))

	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _eSelection$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pWonderCity$[ebp]
	call	?canConstruct@CvCity@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z ; CvCity::canConstruct
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@ChooseWond@2

; 622  : 			{
; 623  : 				pCityToBuildAt = pWonderCity;

	mov	edx, DWORD PTR _pCityToBuildAt$[ebp]
	mov	eax, DWORD PTR _pWonderCity$[ebp]
	mov	DWORD PTR [edx], eax

; 624  : 			}
; 625  : 			// if it can't then check for other cities
; 626  : 			else

	jmp	SHORT $LN7@ChooseWond@2
$LN8@ChooseWond@2:

; 627  : 			{
; 628  : 				CvCity* pLoopCity;
; 629  : 				int iLoop;
; 630  : 				for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$223123[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$223122[ebp], eax
	jmp	SHORT $LN6@ChooseWond@2
$LN5@ChooseWond@2:
	push	0
	lea	eax, DWORD PTR _iLoop$223123[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$223122[ebp], eax
$LN6@ChooseWond@2:
	cmp	DWORD PTR _pLoopCity$223122[ebp], 0
	je	SHORT $LN7@ChooseWond@2

; 631  : 				{
; 632  : 					if(pLoopCity->canConstruct(eSelection))

	push	0
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _eSelection$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopCity$223122[ebp]
	call	?canConstruct@CvCity@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z ; CvCity::canConstruct
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@ChooseWond@2

; 633  : 					{
; 634  : 						pCityToBuildAt = pLoopCity;

	mov	ecx, DWORD PTR _pCityToBuildAt$[ebp]
	mov	edx, DWORD PTR _pLoopCity$223122[ebp]
	mov	DWORD PTR [ecx], edx

; 635  : 						break; // todo: find the best city 

	jmp	SHORT $LN7@ChooseWond@2
$LN3@ChooseWond@2:

; 636  : 					}
; 637  : 				}

	jmp	SHORT $LN5@ChooseWond@2
$LN7@ChooseWond@2:

; 638  : 			}
; 639  : 
; 640  : 			return eSelection;

	mov	eax, DWORD PTR _eSelection$[ebp]
	jmp	SHORT $LN33@ChooseWond@2

; 641  : 		}
; 642  : 
; 643  : 		// Nothing with any weight
; 644  : 		else

	jmp	SHORT $LN2@ChooseWond@2
$LN9@ChooseWond@2:

; 645  : 		{
; 646  : 			return NO_BUILDING;

	or	eax, -1
	jmp	SHORT $LN33@ChooseWond@2
$LN2@ChooseWond@2:

; 647  : 		}
; 648  : 	}
; 649  : 
; 650  : 	// Unless we didn't find any
; 651  : 	else

	jmp	SHORT $LN33@ChooseWond@2
$LN10@ChooseWond@2:

; 652  : 	{
; 653  : 		return NO_BUILDING;

	or	eax, -1
$LN33@ChooseWond@2:

; 654  : 	}
; 655  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ChooseWonderForGreatEngineer@CvWonderProductionAI@@QAE?AW4BuildingTypes@@_NAAHAAPAVCvCity@@@Z ENDP ; CvWonderProductionAI::ChooseWonderForGreatEngineer
_TEXT	ENDS
PUBLIC	??_C@_0P@PNBHPPIP@Wonder?0?5?$CFs?0?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_06NHKAIDD@?$CF03d?0?5?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetLogFileName@CvCitySpecializationAI@@QBE?AVCvString@@AAV2@@Z:PROC ; CvCitySpecializationAI::GetLogFileName
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT ??_C@_0P@PNBHPPIP@Wonder?0?5?$CFs?0?5?$CFd?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0P@PNBHPPIP@Wonder?0?5?$CFs?0?5?$CFd?$AA@ DB 'Wonder, %s, %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
CONST	SEGMENT
??_C@_06NHKAIDD@?$CF03d?0?5?$AA@ DB '%03d, ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ$3
	DD	02H
	DD	FLAT:__unwindfunclet$?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ$6
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvwonderproductionai.cpp
xdata$x	ENDS
;	COMDAT ?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ
_TEXT	SEGMENT
tv296 = -296						; size = 4
tv220 = -292						; size = 4
tv294 = -288						; size = 4
tv307 = -284						; size = 4
tv81 = -280						; size = 4
tv231 = -276						; size = 4
_this$ = -272						; size = 4
$T225341 = -268						; size = 4
$T225326 = -264						; size = 4
_elem$225325 = -260					; size = 8
$T225299 = -252						; size = 4
$T225295 = -248						; size = 4
$T225278 = -244						; size = 4
$T225273 = -240						; size = 4
$T225261 = -236						; size = 4
$T225260 = -232						; size = 4
$T225256 = -228						; size = 4
$T225240 = -224						; size = 28
$T225239 = -196						; size = 28
_strDesc$223148 = -168					; size = 28
_strTemp$223149 = -140					; size = 28
_strOutBuf$223145 = -112				; size = 28
_pEntry$223146 = -84					; size = 4
_iI$223141 = -80					; size = 4
_playerName$223134 = -76				; size = 28
_pLog$223135 = -48					; size = 4
_strBaseString$223137 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ PROC	; CvWonderProductionAI::LogPossibleWonders, COMDAT
; _this$ = ecx

; 660  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 284				; 0000011cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN6@LogPossibl
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@LogPossibl

; 662  : 	{
; 663  : 		// Find the name of this civ
; 664  : 		CvString playerName = m_pPlayer->getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T225256[ebp], eax
	cmp	DWORD PTR $T225256[ebp], 0
	je	SHORT $LN17@LogPossibl
	mov	eax, DWORD PTR $T225256[ebp]
	mov	DWORD PTR tv231[ebp], eax
	jmp	SHORT $LN18@LogPossibl
$LN17@LogPossibl:
	mov	DWORD PTR tv231[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN18@LogPossibl:
	mov	ecx, DWORD PTR tv231[ebp]
	push	ecx
	lea	ecx, DWORD PTR _playerName$223134[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 665  : 
; 666  : 		// Open the log file
; 667  : 		FILogFile* pLog = LOGFILEMGR.GetLog(m_pPlayer->GetCitySpecializationAI()->GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv81[ebp], eax
	lea	edx, DWORD PTR _playerName$223134[ebp]
	push	edx
	lea	eax, DWORD PTR $T225239[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ ; CvPlayer::GetCitySpecializationAI
	mov	ecx, eax
	call	?GetLogFileName@CvCitySpecializationAI@@QBE?AVCvString@@AAV2@@Z ; CvCitySpecializationAI::GetLogFileName
	mov	DWORD PTR tv307[ebp], eax
	mov	edx, DWORD PTR tv307[ebp]
	mov	DWORD PTR $T225260[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T225260[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T225261[ebp], eax
	push	0
	push	1
	mov	eax, DWORD PTR $T225261[ebp]
	push	eax
	mov	ecx, DWORD PTR tv81[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv81[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$223135[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T225239[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 668  : 
; 669  : 		// Get the leading info for this line
; 670  : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$223137[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 671  : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T225273[ebp], ecx
	mov	ecx, DWORD PTR $T225273[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$223137[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 672  : 		strBaseString += playerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR _playerName$223134[ebp]
	push	eax
	lea	ecx, DWORD PTR $T225240[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv294[ebp], eax
	mov	edx, DWORD PTR tv294[ebp]
	mov	DWORD PTR tv220[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR tv220[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$223137[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T225240[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 673  : 
; 674  : 
; 675  : 
; 676  : 		// Dump out the weight of each buildable item
; 677  : 		for(int iI = 0; iI < m_Buildables.size(); iI++)

	mov	DWORD PTR _iI$223141[ebp], 0
	jmp	SHORT $LN4@LogPossibl
$LN3@LogPossibl:
	mov	ecx, DWORD PTR _iI$223141[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$223141[ebp], ecx
$LN4@LogPossibl:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1120]
	mov	DWORD PTR $T225278[ebp], eax
	mov	ecx, DWORD PTR _iI$223141[ebp]
	cmp	ecx, DWORD PTR $T225278[ebp]
	jge	$LN2@LogPossibl

; 678  : 		{
; 679  : 			CvString strOutBuf = strBaseString;

	lea	edx, DWORD PTR _strBaseString$223137[ebp]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$223145[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 680  : 
; 681  : 			CvBuildingEntry* pEntry = GC.GetGameBuildings()->GetEntry(m_Buildables.GetElement(iI));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1116]
	mov	edx, DWORD PTR _iI$223141[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR $T225295[ebp], eax
	mov	ecx, DWORD PTR $T225295[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	DWORD PTR _pEntry$223146[ebp], eax

; 682  : 			if(pEntry != NULL)

	cmp	DWORD PTR _pEntry$223146[ebp], 0
	je	$LN1@LogPossibl

; 683  : 			{
; 684  : 				CvString strDesc = pEntry->GetDescription();

	mov	ecx, DWORD PTR _pEntry$223146[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T225299[ebp], eax
	cmp	DWORD PTR $T225299[ebp], 0
	je	SHORT $LN45@LogPossibl
	mov	eax, DWORD PTR $T225299[ebp]
	mov	DWORD PTR tv296[ebp], eax
	jmp	SHORT $LN46@LogPossibl
$LN45@LogPossibl:
	mov	DWORD PTR tv296[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN46@LogPossibl:
	mov	ecx, DWORD PTR tv296[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strDesc$223148[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 685  : 				CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$223149[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 686  : 				strTemp.Format("Wonder, %s, %d", strDesc.GetCString(), m_Buildables.GetWeight(iI));

	mov	DWORD PTR _elem$225325[ebp], 0
	mov	DWORD PTR _elem$225325[ebp+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1116]
	mov	ecx, DWORD PTR _iI$223141[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$225325[ebp], edx
	mov	DWORD PTR _elem$225325[ebp+4], eax
	mov	ecx, DWORD PTR _elem$225325[ebp+4]
	mov	DWORD PTR $T225326[ebp], ecx
	mov	edx, DWORD PTR $T225326[ebp]
	push	edx
	lea	ecx, DWORD PTR _strDesc$223148[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0P@PNBHPPIP@Wonder?0?5?$CFs?0?5?$CFd?$AA@
	lea	eax, DWORD PTR _strTemp$223149[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 687  : 				strOutBuf += strTemp;

	lea	ecx, DWORD PTR _strTemp$223149[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strOutBuf$223145[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 688  : 
; 689  : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR _strTemp$223149[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _strDesc$223148[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@LogPossibl:

; 690  : 
; 691  : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$223145[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T225341[ebp], eax
	mov	edx, DWORD PTR $T225341[ebp]
	push	edx
	mov	eax, DWORD PTR _pLog$223135[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pLog$223135[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 692  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strOutBuf$223145[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN3@LogPossibl
$LN2@LogPossibl:

; 693  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$223137[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _playerName$223134[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@LogPossibl:

; 694  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _playerName$223134[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR $T225239[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ$2:
	lea	ecx, DWORD PTR _strBaseString$223137[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ$3:
	lea	ecx, DWORD PTR $T225240[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ$4:
	lea	ecx, DWORD PTR _strOutBuf$223145[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ$5:
	lea	ecx, DWORD PTR _strDesc$223148[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ$6:
	lea	ecx, DWORD PTR _strTemp$223149[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-288]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogPossibleWonders@CvWonderProductionAI@@QAEXXZ ENDP	; CvWonderProductionAI::LogPossibleWonders
; Function compile flags: /Odtp
;	COMDAT ?LogFlavors@CvWonderProductionAI@@UAEXW4FlavorTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?LogFlavors@CvWonderProductionAI@@UAEXW4FlavorTypes@@@Z PROC ; CvWonderProductionAI::LogFlavors, COMDAT
; _this$ = ecx

; 698  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 699  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?LogFlavors@CvWonderProductionAI@@UAEXW4FlavorTypes@@@Z ENDP ; CvWonderProductionAI::LogFlavors
_TEXT	ENDS
EXTRN	?isNationalWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isNationalWonderClass
EXTRN	?isTeamWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isTeamWonderClass
; Function compile flags: /Odtp
;	COMDAT ?IsWonder@CvWonderProductionAI@@QBE_NABVCvBuildingEntry@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_kBuildingClass$ = -4					; size = 4
_kBuilding$ = 8						; size = 4
?IsWonder@CvWonderProductionAI@@QBE_NABVCvBuildingEntry@@@Z PROC ; CvWonderProductionAI::IsWonder, COMDAT
; _this$ = ecx

; 703  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 704  : 	const CvBuildingClassInfo& kBuildingClass = kBuilding.GetBuildingClassInfo();

	mov	ecx, DWORD PTR _kBuilding$[ebp]
	call	?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ ; CvBuildingEntry::GetBuildingClassInfo
	mov	DWORD PTR _kBuildingClass$[ebp], eax

; 705  : 
; 706  : 	if(::isWorldWonderClass(kBuildingClass) ||
; 707  : 	        ::isTeamWonderClass(kBuildingClass) ||
; 708  : 	        ::isNationalWonderClass(kBuildingClass))

	mov	eax, DWORD PTR _kBuildingClass$[ebp]
	push	eax
	call	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isWorldWonderClass
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@IsWonder
	mov	edx, DWORD PTR _kBuildingClass$[ebp]
	push	edx
	call	?isTeamWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isTeamWonderClass
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@IsWonder
	mov	ecx, DWORD PTR _kBuildingClass$[ebp]
	push	ecx
	call	?isNationalWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isNationalWonderClass
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@IsWonder
$LN1@IsWonder:

; 709  : 	{
; 710  : 		return true;

	mov	al, 1
	jmp	SHORT $LN3@IsWonder
$LN2@IsWonder:

; 711  : 	}
; 712  : 	return false;

	xor	al, al
$LN3@IsWonder:

; 713  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsWonder@CvWonderProductionAI@@QBE_NABVCvBuildingEntry@@@Z ENDP ; CvWonderProductionAI::IsWonder
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?HaveCityToBuild@CvWonderProductionAI@@ABE_NW4BuildingTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pLoopCity$ = -8					; size = 4
_iLoop$ = -4						; size = 4
_eBuilding$ = 8						; size = 4
?HaveCityToBuild@CvWonderProductionAI@@ABE_NW4BuildingTypes@@@Z PROC ; CvWonderProductionAI::HaveCityToBuild, COMDAT
; _this$ = ecx

; 719  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 720  : 	CvCity* pLoopCity;
; 721  : 	int iLoop;
; 722  : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN4@HaveCityTo
$LN3@HaveCityTo:
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN4@HaveCityTo:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN2@HaveCityTo

; 723  : 	{
; 724  : 		if(pLoopCity->canConstruct(eBuilding))

	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _eBuilding$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?canConstruct@CvCity@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z ; CvCity::canConstruct
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@HaveCityTo

; 725  : 		{
; 726  : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@HaveCityTo
$LN1@HaveCityTo:

; 727  : 		}
; 728  : 	}

	jmp	SHORT $LN3@HaveCityTo
$LN2@HaveCityTo:

; 729  : 	return false;

	xor	al, al
$LN5@HaveCityTo:

; 730  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HaveCityToBuild@CvWonderProductionAI@@ABE_NW4BuildingTypes@@@Z ENDP ; CvWonderProductionAI::HaveCityToBuild
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
_TEXT	ENDS
;	COMDAT ??1?$CvWeightedVector@H$0IH@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1?$CvWeightedVector@H$0IH@$00@@QAE@XZ PROC		; CvWeightedVector<int,135,1>::~CvWeightedVector<int,135,1>, COMDAT
; _this$ = ecx

; 58   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 	};

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::~FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CvWeightedVector@H$0IH@$00@@QAE@XZ ENDP		; CvWeightedVector<int,135,1>::~CvWeightedVector<int,135,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetTotalWeight@?$CvWeightedVector@H$0DC@$00@@QAEHXZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T225408 = -24						; size = 4
$T225401 = -20						; size = 4
_elem$223205 = -16					; size = 8
_i$223201 = -8						; size = 4
_rtnValue$ = -4						; size = 4
?GetTotalWeight@?$CvWeightedVector@H$0DC@$00@@QAEHXZ PROC ; CvWeightedVector<int,50,1>::GetTotalWeight, COMDAT
; _this$ = ecx

; 89   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 90   : 		int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 91   : 
; 92   : 		for (unsigned int i = 0; i < m_pItems.size(); i++)

	mov	DWORD PTR _i$223201[ebp], 0
	jmp	SHORT $LN3@GetTotalWe
$LN2@GetTotalWe:
	mov	eax, DWORD PTR _i$223201[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223201[ebp], eax
$LN3@GetTotalWe:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T225401[ebp], edx
	mov	eax, DWORD PTR _i$223201[ebp]
	cmp	eax, DWORD PTR $T225401[ebp]
	jae	SHORT $LN1@GetTotalWe

; 93   : 		{
; 94   : 			WeightedElement elem = m_pItems[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$223201[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T225408[ebp], ecx
	mov	edx, DWORD PTR $T225408[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _elem$223205[ebp], eax
	mov	ecx, DWORD PTR $T225408[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _elem$223205[ebp+4], edx

; 95   : 			rtnValue += elem.m_iWeight;

	mov	eax, DWORD PTR _rtnValue$[ebp]
	add	eax, DWORD PTR _elem$223205[ebp+4]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 96   : 		}

	jmp	SHORT $LN2@GetTotalWe
$LN1@GetTotalWe:

; 97   : 
; 98   : 		return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 99   : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTotalWeight@?$CvWeightedVector@H$0DC@$00@@QAEHXZ ENDP ; CvWeightedVector<int,50,1>::GetTotalWeight
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ChooseFromTopChoices@?$CvWeightedVector@H$0DC@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T225433 = -36						; size = 4
$T225429 = -32						; size = 4
$T225418 = -28						; size = 4
$T225414 = -24						; size = 4
_iTotalTopChoicesWeight$ = -20				; size = 4
_iChoice$ = -16						; size = 4
_i$ = -12						; size = 4
_elem$ = -8						; size = 8
_iNumChoices$ = 8					; size = 4
_rndFcn$ = 12						; size = 4
_szRollName$ = 16					; size = 4
?ChooseFromTopChoices@?$CvWeightedVector@H$0DC@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z PROC ; CvWeightedVector<int,50,1>::ChooseFromTopChoices, COMDAT
; _this$ = ecx

; 223  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 224  : 		// Loop through the top choices, or the total vector size, whichever is smaller
; 225  : 		if (iNumChoices > (int) m_pItems.size())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T225414[ebp], ecx
	mov	edx, DWORD PTR _iNumChoices$[ebp]
	cmp	edx, DWORD PTR $T225414[ebp]
	jle	SHORT $LN8@ChooseFrom

; 226  : 		{
; 227  : 			iNumChoices = (int) m_pItems.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T225418[ebp], ecx
	mov	edx, DWORD PTR $T225418[ebp]
	mov	DWORD PTR _iNumChoices$[ebp], edx
$LN8@ChooseFrom:

; 228  : 		}
; 229  : 
; 230  : 		WeightedElement elem;

	mov	DWORD PTR _elem$[ebp], 0
	mov	DWORD PTR _elem$[ebp+4], 0

; 231  : 		int i;
; 232  : 		int iChoice;
; 233  : 		int iTotalTopChoicesWeight = 0;

	mov	DWORD PTR _iTotalTopChoicesWeight$[ebp], 0

; 234  : 
; 235  : 		// Get the total weight
; 236  : 		for (i = 0; i < iNumChoices; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@ChooseFrom
$LN6@ChooseFrom:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@ChooseFrom:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _iNumChoices$[ebp]
	jge	SHORT $LN5@ChooseFrom

; 237  : 		{
; 238  : 			elem = m_pItems[i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$[ebp], edx
	mov	DWORD PTR _elem$[ebp+4], eax

; 239  : 			iTotalTopChoicesWeight += elem.m_iWeight;

	mov	ecx, DWORD PTR _iTotalTopChoicesWeight$[ebp]
	add	ecx, DWORD PTR _elem$[ebp+4]
	mov	DWORD PTR _iTotalTopChoicesWeight$[ebp], ecx

; 240  : 		}

	jmp	SHORT $LN6@ChooseFrom
$LN5@ChooseFrom:

; 241  : 
; 242  : 		// Random roll up to total weight
; 243  : 		iChoice = (*rndFcn)(iTotalTopChoicesWeight, szRollName);

	mov	edx, DWORD PTR _rndFcn$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T225429[ebp], eax
	mov	ecx, DWORD PTR _rndFcn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T225433[ebp], edx
	mov	eax, DWORD PTR _szRollName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iTotalTopChoicesWeight$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T225433[ebp]
	call	DWORD PTR $T225429[ebp]
	mov	DWORD PTR _iChoice$[ebp], eax

; 244  : 
; 245  : 		// Find out which element was chosen
; 246  : 		for (i = 0; i < iNumChoices; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@ChooseFrom
$LN3@ChooseFrom:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@ChooseFrom:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _iNumChoices$[ebp]
	jge	SHORT $LN2@ChooseFrom

; 247  : 		{
; 248  : 			elem = m_pItems[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR _elem$[ebp], ecx
	mov	DWORD PTR _elem$[ebp+4], edx

; 249  : 			iChoice -= elem.m_iWeight;

	mov	eax, DWORD PTR _iChoice$[ebp]
	sub	eax, DWORD PTR _elem$[ebp+4]
	mov	DWORD PTR _iChoice$[ebp], eax

; 250  : 			if (iChoice < 0)

	jns	SHORT $LN1@ChooseFrom

; 251  : 			{
; 252  : 				return elem.m_Element;

	mov	eax, DWORD PTR _elem$[ebp]
	jmp	SHORT $LN9@ChooseFrom
$LN1@ChooseFrom:

; 253  : 			}
; 254  : 		}

	jmp	SHORT $LN3@ChooseFrom
$LN2@ChooseFrom:

; 255  : 
; 256  : 		// We should have found something, so reaching here is an error
; 257  : 		//    Just return last thing accessed
; 258  : 		CvAssertMsg (false, "Internal error in CvWeightedVector.");
; 259  : 		return elem.m_Element;

	mov	eax, DWORD PTR _elem$[ebp]
$LN9@ChooseFrom:

; 260  : 	};

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ChooseFromTopChoices@?$CvWeightedVector@H$0DC@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ENDP ; CvWeightedVector<int,50,1>::ChooseFromTopChoices
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T225455 = -20						; size = 4
_pRet$225451 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 135			; 00000087H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T225455[ebp], edx
	cmp	DWORD PTR $T225455[ebp], 135		; 00000087H
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T225455[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$225451[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T225455[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$225451[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 135			; 00000087H
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$225451[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>
__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T225486 = -24						; size = 4
$T225485 = -20						; size = 4
_i$225480 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::~FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T225486[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T225485[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@2
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@2
	mov	DWORD PTR _i$225480[ebp], 0
	jmp	SHORT $LN10@FStaticVec@2
$LN9@FStaticVec@2:
	mov	eax, DWORD PTR _i$225480[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225480[ebp], eax
$LN10@FStaticVec@2:
	mov	ecx, DWORD PTR _i$225480[ebp]
	cmp	ecx, DWORD PTR $T225486[ebp]
	jae	SHORT $LN5@FStaticVec@2
	jmp	SHORT $LN9@FStaticVec@2
$LN5@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T225485[ebp], edx
	je	SHORT $LN1@FStaticVec@2
	mov	eax, DWORD PTR $T225485[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@2:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>
__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::~FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@Z
_TEXT	SEGMENT
tv157 = -64						; size = 4
tv149 = -60						; size = 4
_this$ = -56						; size = 4
$T225499 = -8						; size = 4
$T225498 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@Z PROC ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1092], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN39@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T225499[ebp], ecx
	cmp	DWORD PTR $T225499[ebp], 0
	je	SHORT $LN4@push_back
	mov	edx, DWORD PTR $T225499[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T225499[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR $T225499[ebp]
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN5@push_back
$LN4@push_back:
	mov	DWORD PTR tv149[ebp], 0
$LN5@push_back:
	mov	eax, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T225498[ebp], eax

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv157[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv157[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,50,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,50,1>::WeightedElement,1>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T225563 = -20						; size = 4
_pRet$225559 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>::FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 50			; 00000032H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T225563[ebp], edx
	cmp	DWORD PTR $T225563[ebp], 50		; 00000032H
	jbe	SHORT $LN7@FStaticVec@3
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T225563[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$225559[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T225563[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@3
$LN7@FStaticVec@3:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$225559[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 50			; 00000032H
$LN8@FStaticVec@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$225559[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,50,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,50,1>::WeightedElement,1>
__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>::FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T225594 = -24						; size = 4
$T225593 = -20						; size = 4
_i$225588 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>::~FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T225594[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T225593[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@4
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@4
	mov	DWORD PTR _i$225588[ebp], 0
	jmp	SHORT $LN10@FStaticVec@4
$LN9@FStaticVec@4:
	mov	eax, DWORD PTR _i$225588[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225588[ebp], eax
$LN10@FStaticVec@4:
	mov	ecx, DWORD PTR _i$225588[ebp]
	cmp	ecx, DWORD PTR $T225594[ebp]
	jae	SHORT $LN5@FStaticVec@4
	jmp	SHORT $LN9@FStaticVec@4
$LN5@FStaticVec@4:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T225593[ebp], edx
	je	SHORT $LN1@FStaticVec@4
	mov	eax, DWORD PTR $T225593[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@4:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,50,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,50,1>::WeightedElement,1>
__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>::~FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@Z
_TEXT	SEGMENT
tv157 = -64						; size = 4
tv149 = -60						; size = 4
_this$ = -56						; size = 4
$T225607 = -8						; size = 4
$T225606 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@Z PROC ; FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+412], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN39@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T225607[ebp], ecx
	cmp	DWORD PTR $T225607[ebp], 0
	je	SHORT $LN4@push_back@2
	mov	edx, DWORD PTR $T225607[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T225607[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR $T225607[ebp]
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN5@push_back@2
$LN4@push_back@2:
	mov	DWORD PTR tv149[ebp], 0
$LN5@push_back@2:
	mov	eax, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T225606[ebp], eax

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv157[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv157[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>::push_back
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv186 = -52						; size = 4
_this$ = -48						; size = 4
$T225701 = -44						; size = 4
$T225700 = -40						; size = 4
_i$225695 = -36						; size = 4
$T225679 = -32						; size = 4
$T225672 = -28						; size = 4
_pRet$225668 = -24					; size = 4
$T225662 = -20						; size = 4
$T225661 = -16						; size = 4
_i$223316 = -12						; size = 4
_uiNewSize$223308 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$223308[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$223308[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$223308[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T225672[ebp], ecx
	cmp	DWORD PTR $T225672[ebp], 135		; 00000087H
	jbe	SHORT $LN16@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T225672[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$225668[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T225672[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN17@GrowSize
$LN16@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$225668[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 135			; 00000087H
$LN17@GrowSize:
	mov	ecx, DWORD PTR _pRet$225668[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$223316[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$223316[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223316[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$223316[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$223316[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T225662[ebp], ecx
	cmp	DWORD PTR $T225662[ebp], 0
	je	SHORT $LN12@GrowSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$223316[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T225679[ebp], edx
	mov	eax, DWORD PTR $T225662[ebp]
	mov	ecx, DWORD PTR $T225679[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T225662[ebp]
	mov	ecx, DWORD PTR $T225679[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR $T225662[ebp]
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv186[ebp], 0
$LN13@GrowSize:
	mov	ecx, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T225661[ebp], ecx
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T225701[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T225700[ebp], edx
	xor	eax, eax
	je	SHORT $LN24@GrowSize
	xor	ecx, ecx
	je	SHORT $LN24@GrowSize
	mov	DWORD PTR _i$225695[ebp], 0
	jmp	SHORT $LN29@GrowSize
$LN28@GrowSize:
	mov	edx, DWORD PTR _i$225695[ebp]
	add	edx, 1
	mov	DWORD PTR _i$225695[ebp], edx
$LN29@GrowSize:
	mov	eax, DWORD PTR _i$225695[ebp]
	cmp	eax, DWORD PTR $T225701[ebp]
	jae	SHORT $LN24@GrowSize
	jmp	SHORT $LN28@GrowSize
$LN24@GrowSize:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T225700[ebp], ecx
	je	SHORT $LN25@GrowSize
	mov	edx, DWORD PTR $T225700[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN25@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1092], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv186 = -52						; size = 4
_this$ = -48						; size = 4
$T225747 = -44						; size = 4
$T225746 = -40						; size = 4
_i$225741 = -36						; size = 4
$T225725 = -32						; size = 4
$T225718 = -28						; size = 4
_pRet$225714 = -24					; size = 4
$T225708 = -20						; size = 4
$T225707 = -16						; size = 4
_i$223368 = -12						; size = 4
_uiNewSize$223360 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@2

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$223360[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$223360[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@2

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@2
$LN6@GrowSize@2:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$223360[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@2
$LN7@GrowSize@2:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T225718[ebp], ecx
	cmp	DWORD PTR $T225718[ebp], 50		; 00000032H
	jbe	SHORT $LN16@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T225718[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$225714[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T225718[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN17@GrowSize@2
$LN16@GrowSize@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$225714[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 50			; 00000032H
$LN17@GrowSize@2:
	mov	ecx, DWORD PTR _pRet$225714[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize@2

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@2
$LN5@GrowSize@2:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$223368[ebp], 0
	jmp	SHORT $LN3@GrowSize@2
$LN2@GrowSize@2:
	mov	edx, DWORD PTR _i$223368[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223368[ebp], edx
$LN3@GrowSize@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$223368[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@2

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$223368[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T225708[ebp], ecx
	cmp	DWORD PTR $T225708[ebp], 0
	je	SHORT $LN12@GrowSize@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$223368[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T225725[ebp], edx
	mov	eax, DWORD PTR $T225708[ebp]
	mov	ecx, DWORD PTR $T225725[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T225708[ebp]
	mov	ecx, DWORD PTR $T225725[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR $T225708[ebp]
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN13@GrowSize@2
$LN12@GrowSize@2:
	mov	DWORD PTR tv186[ebp], 0
$LN13@GrowSize@2:
	mov	ecx, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T225707[ebp], ecx
	jmp	SHORT $LN2@GrowSize@2
$LN4@GrowSize@2:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T225747[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T225746[ebp], edx
	xor	eax, eax
	je	SHORT $LN24@GrowSize@2
	xor	ecx, ecx
	je	SHORT $LN24@GrowSize@2
	mov	DWORD PTR _i$225741[ebp], 0
	jmp	SHORT $LN29@GrowSize@2
$LN28@GrowSize@2:
	mov	edx, DWORD PTR _i$225741[ebp]
	add	edx, 1
	mov	DWORD PTR _i$225741[ebp], edx
$LN29@GrowSize@2:
	mov	eax, DWORD PTR _i$225741[ebp]
	cmp	eax, DWORD PTR $T225747[ebp]
	jae	SHORT $LN24@GrowSize@2
	jmp	SHORT $LN28@GrowSize@2
$LN24@GrowSize@2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T225746[ebp], ecx
	je	SHORT $LN25@GrowSize@2
	mov	edx, DWORD PTR $T225746[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN25@GrowSize@2:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+412], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<int,50,1>::WeightedElement,50,1,0,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<int,50,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,50,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0DC@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<int,50,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,50,1>::WeightedElement,1>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
_TEXT	ENDS
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z PROC ; operator>><int>, COMDAT

; 515  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 516  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 518  : 	ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 519  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator
$LN2@operator:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 522  : 	}

	jmp	SHORT $LN2@operator
$LN1@operator:

; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 524  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ENDP ; operator>><int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z PROC ; operator<<<int>, COMDAT

; 502  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 503  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 505  : 	const ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 506  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@2
$LN2@operator@2:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@2:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@2

; 507  : 	{
; 508  : 		saveTo << values[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 509  : 	}

	jmp	SHORT $LN2@operator@2
$LN1@operator@2:

; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 511  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ENDP ; operator<<<int>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
_TEXT	ENDS
;	COMDAT ??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_x$ = 12						; size = 4
_func$ = 16						; size = 4
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z PROC ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>, COMDAT

; 2030 : FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2)) { 

	push	ebp
	mov	ebp, esp

; 2031 : 	return FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE>(x, func);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _func$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2032 : }

	pop	ebp
	ret	0
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ENDP ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,50,1>::WeightedElement *,CvWeightedVector<int,50,1>::WeightedElement>
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<int,50,1>::WeightedElement *,CvWeightedVector<int,50,1>::WeightedElement>
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,50,1>::WeightedElement *,int,CvWeightedVector<int,50,1>::WeightedElement>
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,50,1>::WeightedElement *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@0H@Z
_TEXT	SEGMENT
$T225932 = -128						; size = 4
__Mid$223509 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<int,50,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
$LN7@Sort:

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Count$[ebp], eax
	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN6@Sort
	cmp	DWORD PTR __Ideal$[ebp], 0
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR __Mid$223509[ebp]
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,50,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Ideal$[ebp], eax
	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR __Ideal$[ebp]
	mov	DWORD PTR __Ideal$[ebp], eax

; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ecx, DWORD PTR __Mid$223509[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Mid$223509[ebp+4]
	sar	edx, 3
	cmp	ecx, edx
	jge	SHORT $LN5@Sort

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	mov	eax, DWORD PTR __Ideal$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$223509[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,50,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3093 : 			_First = _Mid.second;

	mov	eax, DWORD PTR __Mid$223509[ebp+4]
	mov	DWORD PTR __First$[ebp], eax

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN4@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	mov	ecx, DWORD PTR __Ideal$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$223509[ebp+4]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,50,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3098 : 			_Last = _Mid.first;

	mov	ecx, DWORD PTR __Mid$223509[ebp]
	mov	DWORD PTR __Last$[ebp], ecx
$LN4@Sort:

; 3099 : 			}
; 3100 : 		}

	jmp	$LN7@Sort
$LN6@Sort:

; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	SHORT $LN3@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN76@Sort
	push	0
	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,50,1>::WeightedElement *,int,CvWeightedVector<int,50,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN76@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T225932[ebp], edx
	jmp	SHORT $LN92@Sort
$LN91@Sort:
	mov	eax, DWORD PTR $T225932[ebp]
	sub	eax, 8
	mov	DWORD PTR $T225932[ebp], eax
$LN92@Sort:
	mov	ecx, DWORD PTR $T225932[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	cmp	ecx, 1
	jle	SHORT $LN88@Sort
	mov	edx, DWORD PTR $T225932[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN96@Sort
	push	0
	mov	eax, DWORD PTR $T225932[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<int,50,1>::WeightedElement *,CvWeightedVector<int,50,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN96@Sort:
	jmp	SHORT $LN91@Sort
$LN88@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	jmp	SHORT $LN8@Sort
$LN3@Sort:
	cmp	DWORD PTR __Count$[ebp], 1
	jle	SHORT $LN8@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,50,1>::WeightedElement *,CvWeightedVector<int,50,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN8@Sort:

; 3109 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<int,50,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z ; std::_Median<CvWeightedVector<int,50,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@0@Z
_TEXT	SEGMENT
$T226175 = -124						; size = 4
__Tmp$226171 = -120					; size = 8
$T226155 = -112						; size = 4
$T226154 = -108						; size = 4
__Tmp$226150 = -104					; size = 8
$T226134 = -96						; size = 4
__Tmp$226130 = -92					; size = 8
$T226114 = -84						; size = 4
$T226113 = -80						; size = 4
__Tmp$226109 = -76					; size = 8
$T226093 = -68						; size = 4
$T226092 = -64						; size = 4
__Tmp$226088 = -60					; size = 8
$T226069 = -52						; size = 4
$T226068 = -48						; size = 4
__Tmp$226064 = -44					; size = 8
$T226042 = -36						; size = 4
__Tmp$226038 = -32					; size = 8
__Plast$ = -20						; size = 4
__Glast$ = -16						; size = 4
__Pfirst$ = -12						; size = 4
__Gfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<int,50,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$[ebp], edx

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z ; std::_Median<CvWeightedVector<int,50,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Pfirst$[ebp], eax

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
$LN27@Unguarded_:

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Pfirst$[ebp]
	jae	SHORT $LN25@Unguarded_
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax-4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN25@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax-4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN25@Unguarded_

; 3033 : 		--_Pfirst;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	jmp	SHORT $LN27@Unguarded_
$LN25@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	mov	edx, DWORD PTR __Plast$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	SHORT $LN24@Unguarded_
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
	jmp	SHORT $LN25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Gfirst$[ebp], edx

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Glast$[ebp], eax
$LN23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	jmp	SHORT $LN21@Unguarded_
$LN20@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN21@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	$LN19@Unguarded_

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN44@Unguarded_
	jmp	SHORT $LN17@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

$LN44@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN16@Unguarded_

; 3048 : 				break;

	jmp	SHORT $LN19@Unguarded_

; 3049 : 			else

	jmp	SHORT $LN17@Unguarded_
$LN16@Unguarded_:

; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T226042[ebp], ecx
	mov	edx, DWORD PTR __Plast$[ebp]
	add	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR $T226042[ebp]
	cmp	eax, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN17@Unguarded_
	mov	ecx, DWORD PTR $T226042[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$226038[ebp], edx
	mov	eax, DWORD PTR $T226042[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$226038[ebp+4], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T226042[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	ecx, DWORD PTR __Tmp$226038[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$226038[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN17@Unguarded_:
	jmp	$LN20@Unguarded_
$LN19@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	jmp	SHORT $LN14@Unguarded_
$LN13@Unguarded_:
	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Glast$[ebp], eax
$LN14@Unguarded_:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	jae	$LN12@Unguarded_

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx-4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN55@Unguarded_
	jmp	SHORT $LN10@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

$LN55@Unguarded_:
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN9@Unguarded_

; 3055 : 				break;

	jmp	SHORT $LN12@Unguarded_

; 3056 : 			else

	jmp	SHORT $LN10@Unguarded_
$LN9@Unguarded_:

; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	mov	eax, DWORD PTR __Pfirst$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Pfirst$[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T226069[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T226068[ebp], edx
	mov	eax, DWORD PTR $T226068[ebp]
	cmp	eax, DWORD PTR $T226069[ebp]
	je	SHORT $LN10@Unguarded_
	mov	ecx, DWORD PTR $T226068[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$226064[ebp], edx
	mov	eax, DWORD PTR $T226068[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$226064[ebp+4], ecx
	mov	edx, DWORD PTR $T226069[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T226068[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T226069[ebp]
	mov	ecx, DWORD PTR __Tmp$226064[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$226064[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN10@Unguarded_:
	jmp	$LN13@Unguarded_
$LN12@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	SHORT $LN7@Unguarded_
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN7@Unguarded_

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN28@Unguarded_
$LN7@Unguarded_:

; 3060 : 
; 3061 : 		if (_Glast == _First)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	$LN6@Unguarded_

; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	mov	ecx, DWORD PTR __Plast$[ebp]
	cmp	ecx, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN5@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T226093[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T226092[ebp], eax
	mov	ecx, DWORD PTR $T226092[ebp]
	cmp	ecx, DWORD PTR $T226093[ebp]
	je	SHORT $LN5@Unguarded_
	mov	edx, DWORD PTR $T226092[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$226088[ebp], eax
	mov	ecx, DWORD PTR $T226092[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$226088[ebp+4], edx
	mov	eax, DWORD PTR $T226093[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T226092[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T226093[ebp]
	mov	edx, DWORD PTR __Tmp$226088[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$226088[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN5@Unguarded_:

; 3065 : 			++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx

; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T226114[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T226113[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	add	edx, 8
	mov	DWORD PTR __Gfirst$[ebp], edx
	mov	eax, DWORD PTR $T226113[ebp]
	cmp	eax, DWORD PTR $T226114[ebp]
	je	SHORT $LN73@Unguarded_
	mov	ecx, DWORD PTR $T226113[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$226109[ebp], edx
	mov	eax, DWORD PTR $T226113[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$226109[ebp+4], ecx
	mov	edx, DWORD PTR $T226114[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T226113[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T226114[ebp]
	mov	ecx, DWORD PTR __Tmp$226109[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$226109[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN73@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)

	jmp	$LN4@Unguarded_
$LN6@Unguarded_:
	mov	eax, DWORD PTR __Gfirst$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	$LN3@Unguarded_

; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Glast$[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Pfirst$[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __Pfirst$[ebp]
	je	SHORT $LN2@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T226134[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	cmp	edx, DWORD PTR $T226134[ebp]
	je	SHORT $LN2@Unguarded_
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$226130[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$226130[ebp+4], eax
	mov	ecx, DWORD PTR $T226134[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T226134[ebp]
	mov	eax, DWORD PTR __Tmp$226130[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$226130[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN2@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T226155[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T226154[ebp], ecx
	mov	edx, DWORD PTR $T226154[ebp]
	cmp	edx, DWORD PTR $T226155[ebp]
	je	SHORT $LN87@Unguarded_
	mov	eax, DWORD PTR $T226154[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$226150[ebp], ecx
	mov	edx, DWORD PTR $T226154[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$226150[ebp+4], eax
	mov	ecx, DWORD PTR $T226155[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T226154[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T226155[ebp]
	mov	eax, DWORD PTR __Tmp$226150[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$226150[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN87@Unguarded_:

; 3073 : 			}
; 3074 : 		else

	jmp	SHORT $LN4@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Glast$[ebp], edx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T226175[ebp], eax
	mov	ecx, DWORD PTR $T226175[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	je	SHORT $LN94@Unguarded_
	mov	edx, DWORD PTR $T226175[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$226171[ebp], eax
	mov	ecx, DWORD PTR $T226175[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$226171[ebp+4], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T226175[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	edx, DWORD PTR __Tmp$226171[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$226171[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN94@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN4@Unguarded_:

; 3076 : 		}

	jmp	$LN23@Unguarded_
$LN28@Unguarded_:

; 3077 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<int,50,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z ; std::_Med3<CvWeightedVector<int,50,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z
_TEXT	SEGMENT
__Step$223666 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z PROC ; std::_Median<CvWeightedVector<int,50,1>::WeightedElement *>, COMDAT

; 3009 : 	{	// sort median element to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 3010 : 	if (40 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	add	eax, 1
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR __Step$223666[ebp], eax

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	ecx, DWORD PTR __Step$223666[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __Step$223666[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z ; std::_Med3<CvWeightedVector<int,50,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	edx, DWORD PTR __Step$223666[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$223666[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Mid$[ebp]
	sub	ecx, eax
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z ; std::_Med3<CvWeightedVector<int,50,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$223666[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Step$223666[ebp]
	shl	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, edx
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z ; std::_Med3<CvWeightedVector<int,50,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	ecx, DWORD PTR __Step$223666[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Step$223666[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z ; std::_Med3<CvWeightedVector<int,50,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3017 : 		}
; 3018 : 	else

	jmp	SHORT $LN3@Median
$LN2@Median:

; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z ; std::_Med3<CvWeightedVector<int,50,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
$LN3@Median:

; 3020 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<int,50,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,50,1>::WeightedElement *,int,CvWeightedVector<int,50,1>::WeightedElement>
; Function compile flags: /Odtp
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@0PAH0@Z
_TEXT	SEGMENT
$T226488 = -20						; size = 4
$T226487 = -16						; size = 4
__Hole$223684 = -8					; size = 4
__Bottom$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<int,50,1>::WeightedElement *,int,CvWeightedVector<int,50,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Bottom$[ebp], eax

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, DWORD PTR __Bottom$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Hole$223684[ebp], eax
$LN2@Make_heap:
	cmp	DWORD PTR __Hole$223684[ebp], 0
	jle	SHORT $LN3@Make_heap

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;

	mov	ecx, DWORD PTR __Hole$223684[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$223684[ebp], ecx

; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	edx, DWORD PTR __Hole$223684[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T226488[ebp], ecx
	sub	esp, 8
	mov	DWORD PTR $T226487[ebp], esp
	mov	edx, DWORD PTR $T226487[ebp]
	mov	eax, DWORD PTR $T226488[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T226487[ebp]
	mov	eax, DWORD PTR $T226488[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __Bottom$[ebp]
	push	edx
	mov	eax, DWORD PTR __Hole$223684[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,50,1>::WeightedElement *,int,CvWeightedVector<int,50,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2172 : 		}

	jmp	SHORT $LN2@Make_heap
$LN3@Make_heap:

; 2173 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<int,50,1>::WeightedElement *,int,CvWeightedVector<int,50,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z
_TEXT	SEGMENT
$T226558 = -52						; size = 4
$T226557 = -48						; size = 4
$T226541 = -42						; size = 1
$T226540 = -41						; size = 1
$T226539 = -40						; size = 4
$T226538 = -36						; size = 4
$T226537 = -32						; size = 4
__Cat$226548 = -24					; size = 1
$T226545 = -23						; size = 1
$T226544 = -22						; size = 1
$T226543 = -21						; size = 1
__First1$223725 = -20					; size = 4
__Val$223715 = -16					; size = 8
__Next1$223714 = -8					; size = 4
__Next$223710 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<int,50,1>::WeightedElement *,CvWeightedVector<int,50,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$223710[ebp], ecx
$LN7@Insertion_:
	mov	edx, DWORD PTR __Next$223710[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$223710[ebp], edx
	mov	eax, DWORD PTR __Next$223710[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$223710[ebp]
	mov	DWORD PTR __Next1$223714[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$223710[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Val$223715[ebp], eax
	mov	ecx, DWORD PTR __Next$223710[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Val$223715[ebp+4], edx

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$223715[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	ecx, DWORD PTR __Next1$223714[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next1$223714[ebp], ecx
	mov	edx, DWORD PTR __Next1$223714[ebp]
	mov	DWORD PTR $T226558[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T226557[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T226543[ebp], cl
	mov	dl, BYTE PTR __Cat$226548[ebp]
	mov	BYTE PTR $T226544[ebp], dl
	mov	al, BYTE PTR $T226543[ebp]
	mov	BYTE PTR $T226541[ebp], al
	mov	cl, BYTE PTR $T226545[ebp]
	mov	BYTE PTR $T226540[ebp], cl
	mov	edx, DWORD PTR $T226558[ebp]
	mov	DWORD PTR $T226539[ebp], edx
	mov	eax, DWORD PTR __Next$223710[ebp]
	mov	DWORD PTR $T226538[ebp], eax
	mov	ecx, DWORD PTR $T226557[ebp]
	mov	DWORD PTR $T226537[ebp], ecx
$LN22@Insertion_:
	mov	edx, DWORD PTR $T226537[ebp]
	cmp	edx, DWORD PTR $T226538[ebp]
	je	SHORT $LN15@Insertion_
	mov	eax, DWORD PTR $T226538[ebp]
	sub	eax, 8
	mov	DWORD PTR $T226538[ebp], eax
	mov	ecx, DWORD PTR $T226539[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T226539[ebp], ecx
	mov	edx, DWORD PTR $T226538[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T226539[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN22@Insertion_
$LN15@Insertion_:

; 2977 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$223715[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$223715[ebp+4]
	mov	DWORD PTR [eax+4], edx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	eax, DWORD PTR __Next1$223714[ebp]
	mov	DWORD PTR __First1$223725[ebp], eax

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_
$LN2@Insertion_:
	mov	ecx, DWORD PTR __First1$223725[ebp]
	mov	DWORD PTR __Next1$223714[ebp], ecx
$LN3@Insertion_:
	mov	edx, DWORD PTR __First1$223725[ebp]
	sub	edx, 8
	mov	DWORD PTR __First1$223725[ebp], edx
	mov	eax, DWORD PTR __First1$223725[ebp]
	mov	ecx, DWORD PTR __Val$223715[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@Insertion_

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ecx, DWORD PTR __First1$223725[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Next1$223714[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN2@Insertion_
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	edx, DWORD PTR __Next1$223714[ebp]
	mov	eax, DWORD PTR __Val$223715[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Val$223715[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN4@Insertion_:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_
$LN9@Insertion_:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<int,50,1>::WeightedElement *,CvWeightedVector<int,50,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z
_TEXT	SEGMENT
__Tmp$226628 = -24					; size = 8
__Tmp$226606 = -16					; size = 8
__Tmp$226584 = -8					; size = 8
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<int,50,1>::WeightedElement *>, COMDAT

; 2998 : 	{	// sort median of three elements to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	mov	edx, DWORD PTR __Mid$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN15@Med3
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$226584[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$226584[ebp+4], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Tmp$226584[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$226584[ebp+4]
	mov	DWORD PTR [edx+4], ecx

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

$LN15@Med3:
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN24@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	mov	ecx, DWORD PTR __Last$[ebp]
	cmp	ecx, DWORD PTR __Mid$[ebp]
	je	SHORT $LN24@Med3
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$226606[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$226606[ebp+4], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __Tmp$226606[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$226606[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

$LN24@Med3:
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	mov	eax, DWORD PTR __Mid$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN4@Med3
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$226628[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$226628[ebp+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Tmp$226628[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$226628[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN4@Med3:

; 3005 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<int,50,1>::WeightedElement *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@HHU12@@Z
_TEXT	SEGMENT
$T226653 = -32						; size = 4
$T226652 = -28						; size = 8
__Idx$226648 = -20					; size = 4
$T226639 = -16						; size = 4
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<int,50,1>::WeightedElement *,int,CvWeightedVector<int,50,1>::WeightedElement>, COMDAT

; 2055 : 	{	// percolate _Hole to _Bottom, then push _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 2056 : 	_Diff _Top = _Hole;

	mov	eax, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR __Top$[ebp], eax

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;

	mov	ecx, DWORD PTR __Hole$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	DWORD PTR __Idx$[ebp], edx

; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	jmp	SHORT $LN5@Adjust_hea
$LN4@Adjust_hea:
	mov	eax, DWORD PTR __Idx$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea:
	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jge	SHORT $LN3@Adjust_hea

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	eax, DWORD PTR __Idx$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Idx$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+edx*8-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	mov	eax, DWORD PTR __Idx$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Idx$[ebp], eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [edx+ecx*8+4]
	mov	edx, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+edx*8], eax
	mov	DWORD PTR [esi+edx*8+4], ecx
	mov	eax, DWORD PTR __Idx$[ebp]
	mov	DWORD PTR __Hole$[ebp], eax

; 2064 : 		}

	jmp	SHORT $LN4@Adjust_hea
$LN3@Adjust_hea:

; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	mov	ecx, DWORD PTR __Idx$[ebp]
	cmp	ecx, DWORD PTR __Bottom$[ebp]
	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	edx, DWORD PTR __Bottom$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8-8]
	mov	edx, DWORD PTR [eax+edx*8-4]
	mov	eax, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx

; 2069 : 		_Hole = _Bottom - 1;

	mov	ecx, DWORD PTR __Bottom$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$[ebp], ecx
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	lea	edx, DWORD PTR $T226652[ebp]
	mov	DWORD PTR $T226639[ebp], edx
	mov	eax, DWORD PTR $T226639[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T226639[ebp]
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR $T226653[ebp], ecx
	mov	eax, DWORD PTR $T226653[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$226648[ebp], eax
	jmp	SHORT $LN14@Adjust_hea
$LN13@Adjust_hea:
	mov	eax, DWORD PTR $T226653[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$226648[ebp], eax
$LN14@Adjust_hea:
	mov	edx, DWORD PTR __Top$[ebp]
	cmp	edx, DWORD PTR $T226653[ebp]
	jge	SHORT $LN12@Adjust_hea
	mov	eax, DWORD PTR __Idx$226648[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	xor	eax, eax
	cmp	edx, DWORD PTR $T226652[ebp+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@Adjust_hea
	mov	edx, DWORD PTR __Idx$226648[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [eax+edx*8+4]
	mov	eax, DWORD PTR $T226653[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx
	mov	ecx, DWORD PTR __Idx$226648[ebp]
	mov	DWORD PTR $T226653[ebp], ecx
	jmp	SHORT $LN13@Adjust_hea
$LN12@Adjust_hea:
	mov	edx, DWORD PTR $T226653[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR $T226652[ebp]
	mov	DWORD PTR [eax+edx*8], ecx
	mov	ecx, DWORD PTR $T226652[ebp+4]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 2072 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<int,50,1>::WeightedElement *,int,CvWeightedVector<int,50,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z
_TEXT	SEGMENT
$T226699 = -60						; size = 8
$T226670 = -20						; size = 4
$T226664 = -12						; size = 4
$T226663 = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<int,50,1>::WeightedElement *,CvWeightedVector<int,50,1>::WeightedElement>, COMDAT

; 2087 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	mov	DWORD PTR $T226664[ebp], eax
	lea	ecx, DWORD PTR $T226699[ebp]
	mov	DWORD PTR $T226663[ebp], ecx
	mov	edx, DWORD PTR $T226663[ebp]
	mov	eax, DWORD PTR $T226664[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T226663[ebp]
	mov	eax, DWORD PTR $T226664[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [edx-8], eax
	mov	DWORD PTR [edx-4], ecx
	sub	esp, 8
	mov	DWORD PTR $T226670[ebp], esp
	mov	eax, DWORD PTR $T226670[ebp]
	mov	ecx, DWORD PTR $T226699[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T226670[ebp]
	mov	eax, DWORD PTR $T226699[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	push	ecx
	push	0
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,50,1>::WeightedElement *,int,CvWeightedVector<int,50,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0DC@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<int,50,1>::WeightedElement *,CvWeightedVector<int,50,1>::WeightedElement>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_TEXT	ENDS
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);

	lea	eax, DWORD PTR _lpszFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Odtp
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T226730 = -2092					; size = 4
$T226729 = -2088					; size = 4
$T226728 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T226728[ebp], eax
	mov	ecx, DWORD PTR $T226728[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T226729[ebp], eax
	mov	eax, DWORD PTR $T226729[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T226730[ebp], eax
	mov	ecx, DWORD PTR $T226730[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
END
