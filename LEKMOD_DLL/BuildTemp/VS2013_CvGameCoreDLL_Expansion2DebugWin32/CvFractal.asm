; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvFractal.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_7CvFractal@@6B@				; CvFractal::`vftable'
PUBLIC	??0CvFractal@@QAE@XZ				; CvFractal::CvFractal
EXTRN	??_ECvFractal@@UAEPAXI@Z:PROC			; CvFractal::`vector deleting destructor'
;	COMDAT ??_7CvFractal@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvfractal.cpp
CONST	SEGMENT
??_7CvFractal@@6B@ DD FLAT:??_ECvFractal@@UAEPAXI@Z	; CvFractal::`vftable'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvFractal@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvFractal@@QAE@XZ PROC				; CvFractal::CvFractal, COMDAT
; _this$ = ecx

; 29   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvFractal@@6B@

; 30   : 	m_iFracXExp = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], -1

; 31   : 	m_iFracYExp = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], -1

; 32   : 	m_iXs = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], -1

; 33   : 	m_iYs = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], -1

; 34   : 	m_iFlags = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 35   : 	m_iFracX = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], -1

; 36   : 	m_iFracY = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], -1

; 37   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvFractal@@QAE@XZ ENDP				; CvFractal::CvFractal
_TEXT	ENDS
PUBLIC	??1CvFractal@@UAE@XZ				; CvFractal::~CvFractal
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GCvFractal@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvFractal@@UAEPAXI@Z PROC				; CvFractal::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvFractal@@UAE@XZ			; CvFractal::~CvFractal
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvFractal@@UAEPAXI@Z ENDP				; CvFractal::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?uninit@CvFractal@@QAEXXZ			; CvFractal::uninit
; Function compile flags: /Odtp
;	COMDAT ??1CvFractal@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvFractal@@UAE@XZ PROC				; CvFractal::~CvFractal, COMDAT
; _this$ = ecx

; 40   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvFractal@@6B@

; 41   : 	uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?uninit@CvFractal@@QAEXXZ		; CvFractal::uninit

; 42   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CvFractal@@UAE@XZ ENDP				; CvFractal::~CvFractal
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?uninit@CvFractal@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?uninit@CvFractal@@QAEXXZ PROC				; CvFractal::uninit, COMDAT
; _this$ = ecx

; 45   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 46   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?uninit@CvFractal@@QAEXXZ ENDP				; CvFractal::uninit
_TEXT	ENDS
PUBLIC	?reset@CvFractal@@QAEXXZ			; CvFractal::reset
; Function compile flags: /Odtp
;	COMDAT ?reset@CvFractal@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?reset@CvFractal@@QAEXXZ PROC				; CvFractal::reset, COMDAT
; _this$ = ecx

; 49   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 	uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?uninit@CvFractal@@QAEXXZ		; CvFractal::uninit

; 51   : 	m_iFracXExp = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], -1

; 52   : 	m_iFracYExp = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], -1

; 53   : 	m_iXs = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], -1

; 54   : 	m_iYs = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], -1

; 55   : 	m_iFlags = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 56   : 	m_iFracX = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], -1

; 57   : 	m_iFracY = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], -1

; 58   : #ifdef AUI_WARNING_FIXES
; 59   : 	m_iXInc = 0;
; 60   : 	m_iYInc = 0;
; 61   : #endif
; 62   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?reset@CvFractal@@QAEXXZ ENDP				; CvFractal::reset
_TEXT	ENDS
PUBLIC	?fracInitInternal@CvFractal@@IAEXHHHAAVCvRandom@@PAEHHPAV1@HH@Z ; CvFractal::fracInitInternal
PUBLIC	?fracInit@CvFractal@@QAEXHHHAAVCvRandom@@HPAV1@HH@Z ; CvFractal::fracInit
; Function compile flags: /Odtp
;	COMDAT ?fracInit@CvFractal@@QAEXHHHAAVCvRandom@@HPAV1@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iNewXs$ = 8						; size = 4
_iNewYs$ = 12						; size = 4
_iGrain$ = 16						; size = 4
_random$ = 20						; size = 4
_iFlags$ = 24						; size = 4
_pRifts$ = 28						; size = 4
_iFracXExp$ = 32					; size = 4
_iFracYExp$ = 36					; size = 4
?fracInit@CvFractal@@QAEXHHHAAVCvRandom@@HPAV1@HH@Z PROC ; CvFractal::fracInit, COMDAT
; _this$ = ecx

; 65   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 	fracInitInternal(iNewXs, iNewYs, iGrain, random, NULL, -1, iFlags, pRifts, iFracXExp, iFracYExp);

	mov	eax, DWORD PTR _iFracYExp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iFracXExp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pRifts$[ebp]
	push	edx
	mov	eax, DWORD PTR _iFlags$[ebp]
	push	eax
	push	-1
	push	0
	mov	ecx, DWORD PTR _random$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iGrain$[ebp]
	push	edx
	mov	eax, DWORD PTR _iNewYs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNewXs$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?fracInitInternal@CvFractal@@IAEXHHHAAVCvRandom@@PAEHHPAV1@HH@Z ; CvFractal::fracInitInternal

; 67   : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?fracInit@CvFractal@@QAEXHHHAAVCvRandom@@HPAV1@HH@Z ENDP ; CvFractal::fracInit
_TEXT	ENDS
PUBLIC	?fracInitHinted@CvFractal@@QAEXHHHAAVCvRandom@@PAEHHPAV1@HH@Z ; CvFractal::fracInitHinted
; Function compile flags: /Odtp
;	COMDAT ?fracInitHinted@CvFractal@@QAEXHHHAAVCvRandom@@PAEHHPAV1@HH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iFlagsNonPolar$ = -4					; size = 4
_iNewXs$ = 8						; size = 4
_iNewYs$ = 12						; size = 4
_iGrain$ = 16						; size = 4
_random$ = 20						; size = 4
_pbyHints$ = 24						; size = 4
_iHintsLength$ = 28					; size = 4
_iFlags$ = 32						; size = 4
_pRifts$ = 36						; size = 4
_iFracXExp$ = 40					; size = 4
_iFracYExp$ = 44					; size = 4
?fracInitHinted@CvFractal@@QAEXHHHAAVCvRandom@@PAEHHPAV1@HH@Z PROC ; CvFractal::fracInitHinted, COMDAT
; _this$ = ecx

; 76   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 77   : 	int iFlagsNonPolar = iFlags & (~FRAC_POLAR);

	mov	eax, DWORD PTR _iFlags$[ebp]
	and	eax, -9					; fffffff7H
	mov	DWORD PTR _iFlagsNonPolar$[ebp], eax

; 78   : 	fracInitInternal(iNewXs, iNewYs, iGrain, random, pbyHints, iHintsLength, iFlagsNonPolar, pRifts, iFracXExp, iFracYExp);

	mov	ecx, DWORD PTR _iFracYExp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iFracXExp$[ebp]
	push	edx
	mov	eax, DWORD PTR _pRifts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iFlagsNonPolar$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iHintsLength$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbyHints$[ebp]
	push	eax
	mov	ecx, DWORD PTR _random$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iGrain$[ebp]
	push	edx
	mov	eax, DWORD PTR _iNewYs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNewXs$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?fracInitInternal@CvFractal@@IAEXHHHAAVCvRandom@@PAEHHPAV1@HH@Z ; CvFractal::fracInitInternal

; 79   : }

	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
?fracInitHinted@CvFractal@@QAEXHHHAAVCvRandom@@PAEHHPAV1@HH@Z ENDP ; CvFractal::fracInitHinted
_TEXT	ENDS
PUBLIC	?tectonicAction@CvFractal@@IAEXPAV1@@Z		; CvFractal::tectonicAction
PUBLIC	??_C@_0O@NAAEOIEN@Fractal?5Gen?54?$AA@		; `string'
PUBLIC	??_C@_0O@JPEFHOIK@Fractal?5Gen?53?$AA@		; `string'
PUBLIC	??_C@_0O@IGFOEPML@Fractal?5Gen?52?$AA@		; `string'
PUBLIC	??_C@_0M@KOHMAFOF@Fractal?5Gen?$AA@		; `string'
EXTRN	?get@CvRandom@@QAEGGPBD@Z:PROC			; CvRandom::get
;	COMDAT ??_C@_0O@NAAEOIEN@Fractal?5Gen?54?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
CONST	SEGMENT
??_C@_0O@NAAEOIEN@Fractal?5Gen?54?$AA@ DB 'Fractal Gen 4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JPEFHOIK@Fractal?5Gen?53?$AA@
CONST	SEGMENT
??_C@_0O@JPEFHOIK@Fractal?5Gen?53?$AA@ DB 'Fractal Gen 3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IGFOEPML@Fractal?5Gen?52?$AA@
CONST	SEGMENT
??_C@_0O@IGFOEPML@Fractal?5Gen?52?$AA@ DB 'Fractal Gen 2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KOHMAFOF@Fractal?5Gen?$AA@
CONST	SEGMENT
??_C@_0M@KOHMAFOF@Fractal?5Gen?$AA@ DB 'Fractal Gen', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvfractal.cpp
CONST	ENDS
;	COMDAT ?fracInitInternal@CvFractal@@IAEXHHHAAVCvRandom@@PAEHHPAV1@HH@Z
_TEXT	SEGMENT
tv567 = -76						; size = 4
_this$ = -72						; size = 4
$T217889 = -68						; size = 4
$T217881 = -64						; size = 4
$T217880 = -60						; size = 4
$T217877 = -56						; size = 4
_iXX$217299 = -52					; size = 4
_iYY$217300 = -48					; size = 4
_iHintsI$217301 = -44					; size = 4
_iSmooth$ = -40						; size = 4
_iHintsWidth$ = -36					; size = 4
_iHintsHeight$ = -32					; size = 4
_iPass$ = -28						; size = 4
_iX$ = -24						; size = 4
_iSum$ = -20						; size = 4
_iI$ = -16						; size = 4
_iY$ = -12						; size = 4
_iScreen$ = -8						; size = 4
_iMinExp$ = -4						; size = 4
_iNewXs$ = 8						; size = 4
_iNewYs$ = 12						; size = 4
_iGrain$ = 16						; size = 4
_random$ = 20						; size = 4
_pbyHints$ = 24						; size = 4
___formal$ = 28						; size = 4
_iFlags$ = 32						; size = 4
_pRifts$ = 36						; size = 4
_iFracXExp$ = 40					; size = 4
_iFracYExp$ = 44					; size = 4
?fracInitInternal@CvFractal@@IAEXHHHAAVCvRandom@@PAEHHPAV1@HH@Z PROC ; CvFractal::fracInitInternal, COMDAT
; _this$ = ecx

; 86   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 87   : 	FAssert(iNewXs < FRACTAL_MAX_DIMS);
; 88   : 	FAssert(iNewYs < FRACTAL_MAX_DIMS);
; 89   : 
; 90   : 	int iSmooth;
; 91   : 	int iScreen;  // This screens out already marked spots in m_aaiFrac[][];
; 92   : 	int iPass;
; 93   : 	int iSum;
; 94   : 	int iX, iY;
; 95   : 	int iI;
; 96   : 
; 97   : 	reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@CvFractal@@QAEXXZ		; CvFractal::reset

; 98   : 
; 99   : 	if(iFracXExp < 0)

	cmp	DWORD PTR _iFracXExp$[ebp], 0
	jge	SHORT $LN71@fracInitIn

; 100  : 	{
; 101  : 		iFracXExp = DEFAULT_FRAC_X_EXP;

	mov	DWORD PTR _iFracXExp$[ebp], 7
$LN71@fracInitIn:

; 102  : 	}
; 103  : 	if(iFracYExp < 0)

	cmp	DWORD PTR _iFracYExp$[ebp], 0
	jge	SHORT $LN70@fracInitIn

; 104  : 	{
; 105  : 		iFracYExp = DEFAULT_FRAC_Y_EXP;

	mov	DWORD PTR _iFracYExp$[ebp], 6
$LN70@fracInitIn:

; 106  : 	}
; 107  : 
; 108  : 	m_iFracXExp = iFracXExp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iFracXExp$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 109  : 	m_iFracYExp = iFracYExp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iFracYExp$[ebp]
	mov	DWORD PTR [edx+28], eax

; 110  : 	m_iFracX = 1 << iFracXExp;

	mov	edx, 1
	mov	ecx, DWORD PTR _iFracXExp$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], edx

; 111  : 	m_iFracY = 1 << iFracYExp;

	mov	edx, 1
	mov	ecx, DWORD PTR _iFracYExp$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 112  : 
; 113  : 	// Init m_aaiFrac to all zeroes:
; 114  : 	for(iX = 0; iX < m_iFracX + 1; iX++)

	mov	DWORD PTR _iX$[ebp], 0
	jmp	SHORT $LN69@fracInitIn
$LN68@fracInitIn:
	mov	ecx, DWORD PTR _iX$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iX$[ebp], ecx
$LN69@fracInitIn:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 1
	cmp	DWORD PTR _iX$[ebp], eax
	jge	SHORT $LN67@fracInitIn

; 115  : 	{
; 116  : 		for(iY = 0; iY < m_iFracY + 1; iY++)

	mov	DWORD PTR _iY$[ebp], 0
	jmp	SHORT $LN66@fracInitIn
$LN65@fracInitIn:
	mov	ecx, DWORD PTR _iY$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iY$[ebp], ecx
$LN66@fracInitIn:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	cmp	DWORD PTR _iY$[ebp], eax
	jge	SHORT $LN64@fracInitIn

; 117  : 		{
; 118  : 			m_aaiFrac[iX][iY] = 0;

	mov	ecx, DWORD PTR _iX$[ebp]
	shl	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+40]
	mov	ecx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 119  : 		}

	jmp	SHORT $LN65@fracInitIn
$LN64@fracInitIn:

; 120  : 	}

	jmp	SHORT $LN68@fracInitIn
$LN67@fracInitIn:

; 121  : 
; 122  : 	m_iXs = iNewXs;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iNewXs$[ebp]
	mov	DWORD PTR [edx+4], eax

; 123  : 	m_iYs = iNewYs;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iNewYs$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 124  : 	m_iFlags = iFlags;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iFlags$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 125  : 	m_iXInc = ((m_iFracX * FLOAT_PRECISION) / m_iXs);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	imul	eax, 1000				; 000003e8H
	mov	ecx, DWORD PTR _this$[ebp]
	cdq
	idiv	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], eax

; 126  : 	m_iYInc = ((m_iFracY * FLOAT_PRECISION) / m_iYs);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	imul	eax, 1000				; 000003e8H
	mov	ecx, DWORD PTR _this$[ebp]
	cdq
	idiv	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], eax

; 127  : 
; 128  : #ifdef NQM_FAST_COMP
; 129  : 	int iMinExp = MIN(m_iFracXExp, m_iFracYExp);
; 130  : #else
; 131  : 	int iMinExp = std::min(m_iFracXExp, m_iFracYExp);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR $T217881[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T217880[ebp], ecx
	mov	edx, DWORD PTR $T217881[ebp]
	mov	eax, DWORD PTR $T217880[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN76@fracInitIn
	mov	edx, DWORD PTR $T217881[ebp]
	mov	DWORD PTR tv567[ebp], edx
	jmp	SHORT $LN77@fracInitIn
$LN76@fracInitIn:
	mov	eax, DWORD PTR $T217880[ebp]
	mov	DWORD PTR tv567[ebp], eax
$LN77@fracInitIn:
	mov	ecx, DWORD PTR tv567[ebp]
	mov	DWORD PTR $T217877[ebp], ecx
	mov	edx, DWORD PTR $T217877[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _iMinExp$[ebp], eax

; 132  : #endif
; 133  : 	iSmooth = range(iMinExp - iGrain, 0, iMinExp);

	mov	ecx, DWORD PTR _iMinExp$[ebp]
	sub	ecx, DWORD PTR _iGrain$[ebp]
	mov	DWORD PTR $T217889[ebp], ecx
	jns	SHORT $LN81@fracInitIn
	mov	DWORD PTR _iSmooth$[ebp], 0
	jmp	SHORT $LN82@fracInitIn
	jmp	SHORT $LN82@fracInitIn
$LN81@fracInitIn:
	mov	edx, DWORD PTR $T217889[ebp]
	cmp	edx, DWORD PTR _iMinExp$[ebp]
	jle	SHORT $LN79@fracInitIn
	mov	eax, DWORD PTR _iMinExp$[ebp]
	mov	DWORD PTR _iSmooth$[ebp], eax
	jmp	SHORT $LN82@fracInitIn
	jmp	SHORT $LN82@fracInitIn
$LN79@fracInitIn:
	mov	ecx, DWORD PTR $T217889[ebp]
	mov	DWORD PTR _iSmooth$[ebp], ecx
$LN82@fracInitIn:

; 134  : 
; 135  : 	int iHintsWidth = (1 << (m_iFracXExp - iSmooth)) + ((m_iFlags & FRAC_WRAP_X) ? 0 : 1);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	sub	ecx, DWORD PTR _iSmooth$[ebp]
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 1
	neg	edx
	sbb	edx, edx
	add	edx, 1
	add	eax, edx
	mov	DWORD PTR _iHintsWidth$[ebp], eax

; 136  : 	int iHintsHeight = (1 << (m_iFracYExp - iSmooth)) + ((m_iFlags & FRAC_WRAP_Y) ? 0 : 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	sub	ecx, DWORD PTR _iSmooth$[ebp]
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 2
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	add	edx, ecx
	mov	DWORD PTR _iHintsHeight$[ebp], edx

; 137  : #ifdef CVASSERT_ENABLE
; 138  : 	if(pbyHints != NULL)
; 139  : 	{
; 140  : 		CvAssertMsg(iHintsLength == iHintsWidth*iHintsHeight, "pbyHints is the wrong size!")
; 141  : 	}
; 142  : #endif
; 143  : 
; 144  : 	for(iPass = iSmooth; iPass >= 0; iPass--)

	mov	edx, DWORD PTR _iSmooth$[ebp]
	mov	DWORD PTR _iPass$[ebp], edx
	jmp	SHORT $LN63@fracInitIn
$LN62@fracInitIn:
	mov	eax, DWORD PTR _iPass$[ebp]
	sub	eax, 1
	mov	DWORD PTR _iPass$[ebp], eax
$LN63@fracInitIn:
	cmp	DWORD PTR _iPass$[ebp], 0
	jl	$LN61@fracInitIn

; 145  : 	{
; 146  : 		iScreen = 0;

	mov	DWORD PTR _iScreen$[ebp], 0

; 147  : 
; 148  : 		for(iI = 0; iI <= iPass; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN60@fracInitIn
$LN59@fracInitIn:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN60@fracInitIn:
	mov	edx, DWORD PTR _iI$[ebp]
	cmp	edx, DWORD PTR _iPass$[ebp]
	jg	SHORT $LN58@fracInitIn

; 149  : 		{
; 150  : 			iScreen |= (1 << iI);

	mov	eax, 1
	mov	ecx, DWORD PTR _iI$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _iScreen$[ebp]
	mov	DWORD PTR _iScreen$[ebp], eax

; 151  : 		}

	jmp	SHORT $LN59@fracInitIn
$LN58@fracInitIn:

; 152  : 
; 153  : 		if(m_iFlags & FRAC_WRAP_Y)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 2
	je	SHORT $LN57@fracInitIn

; 154  : 		{
; 155  : 			for(iX = 0; iX < m_iFracX + 1; iX++)

	mov	DWORD PTR _iX$[ebp], 0
	jmp	SHORT $LN56@fracInitIn
$LN55@fracInitIn:
	mov	eax, DWORD PTR _iX$[ebp]
	add	eax, 1
	mov	DWORD PTR _iX$[ebp], eax
$LN56@fracInitIn:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 1
	cmp	DWORD PTR _iX$[ebp], edx
	jge	SHORT $LN54@fracInitIn

; 156  : 			{
; 157  : 				m_aaiFrac[iX][m_iFracY] = m_aaiFrac[iX][0];

	mov	eax, DWORD PTR _iX$[ebp]
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _iX$[ebp]
	shl	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+20]
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+40]
	mov	DWORD PTR [ecx+edx*4], eax

; 158  : 			}

	jmp	SHORT $LN55@fracInitIn
$LN54@fracInitIn:

; 159  : 		}
; 160  : 		else if(m_iFlags & FRAC_POLAR)

	jmp	SHORT $LN53@fracInitIn
$LN57@fracInitIn:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 8
	je	SHORT $LN53@fracInitIn

; 161  : 		{
; 162  : 			for(iX = 0; iX < m_iFracX + 1; iX++)

	mov	DWORD PTR _iX$[ebp], 0
	jmp	SHORT $LN51@fracInitIn
$LN50@fracInitIn:
	mov	eax, DWORD PTR _iX$[ebp]
	add	eax, 1
	mov	DWORD PTR _iX$[ebp], eax
$LN51@fracInitIn:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 1
	cmp	DWORD PTR _iX$[ebp], edx
	jge	SHORT $LN53@fracInitIn

; 163  : 			{
; 164  : 				m_aaiFrac[iX][   0    ] = 0;

	mov	eax, DWORD PTR _iX$[ebp]
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], 0

; 165  : 				m_aaiFrac[iX][m_iFracY] = 0;

	mov	edx, DWORD PTR _iX$[ebp]
	shl	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+eax*4], 0

; 166  : 			}

	jmp	SHORT $LN50@fracInitIn
$LN53@fracInitIn:

; 167  : 		}
; 168  : 
; 169  : 		if(m_iFlags & FRAC_WRAP_X)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 1
	je	SHORT $LN48@fracInitIn

; 170  : 		{
; 171  : 			for(iY = 0; iY < m_iFracY + 1; iY++)

	mov	DWORD PTR _iY$[ebp], 0
	jmp	SHORT $LN47@fracInitIn
$LN46@fracInitIn:
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, 1
	mov	DWORD PTR _iY$[ebp], eax
$LN47@fracInitIn:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, 1
	cmp	DWORD PTR _iY$[ebp], edx
	jge	SHORT $LN45@fracInitIn

; 172  : 			{
; 173  : 				m_aaiFrac[m_iFracX][iY] = m_aaiFrac[0][iY];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	shl	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+40]
	mov	ecx, DWORD PTR _iY$[ebp]
	mov	edx, DWORD PTR _iY$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+40]
	mov	DWORD PTR [eax+ecx*4], edx

; 174  : 			}

	jmp	SHORT $LN46@fracInitIn
$LN45@fracInitIn:

; 175  : 		}
; 176  : 		else if(m_iFlags & FRAC_POLAR)

	jmp	SHORT $LN44@fracInitIn
$LN48@fracInitIn:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 8
	je	SHORT $LN44@fracInitIn

; 177  : 		{
; 178  : 			for(iY = 0; iY < m_iFracY + 1; iY++)

	mov	DWORD PTR _iY$[ebp], 0
	jmp	SHORT $LN42@fracInitIn
$LN41@fracInitIn:
	mov	edx, DWORD PTR _iY$[ebp]
	add	edx, 1
	mov	DWORD PTR _iY$[ebp], edx
$LN42@fracInitIn:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	cmp	DWORD PTR _iY$[ebp], ecx
	jge	SHORT $LN44@fracInitIn

; 179  : 			{
; 180  : 				m_aaiFrac[   0    ][iY] = 0;

	mov	edx, DWORD PTR _iY$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+40], 0

; 181  : 				m_aaiFrac[m_iFracX][iY] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	shl	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+40]
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0

; 182  : 			}

	jmp	SHORT $LN41@fracInitIn
$LN44@fracInitIn:

; 183  : 		}
; 184  : 
; 185  : 		if(m_iFlags & FRAC_CENTER_RIFT)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 16					; 00000010H
	je	$LN39@fracInitIn

; 186  : 		{
; 187  : 			if(m_iFlags & FRAC_WRAP_Y)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 2
	je	$LN38@fracInitIn

; 188  : 			{
; 189  : 				for(iX = 0; iX < m_iFracX + 1; iX++)

	mov	DWORD PTR _iX$[ebp], 0
	jmp	SHORT $LN37@fracInitIn
$LN36@fracInitIn:
	mov	ecx, DWORD PTR _iX$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iX$[ebp], ecx
$LN37@fracInitIn:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 1
	cmp	DWORD PTR _iX$[ebp], eax
	jge	$LN38@fracInitIn

; 190  : 				{
; 191  : 					for(iY = 0; iY < (m_iFracY / 6); iY++)

	mov	DWORD PTR _iY$[ebp], 0
	jmp	SHORT $LN34@fracInitIn
$LN33@fracInitIn:
	mov	ecx, DWORD PTR _iY$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iY$[ebp], ecx
$LN34@fracInitIn:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	cdq
	mov	ecx, 6
	idiv	ecx
	cmp	DWORD PTR _iY$[ebp], eax
	jge	$LN32@fracInitIn

; 192  : 					{
; 193  : 						m_aaiFrac[iX][        iY         ] /= (abs((m_iFracY / 12) - iY) + 1);

	mov	edx, DWORD PTR _iX$[ebp]
	shl	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	cdq
	mov	esi, 12					; 0000000cH
	idiv	esi
	sub	eax, DWORD PTR _iY$[ebp]
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	add	esi, 1
	mov	eax, DWORD PTR _iY$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	cdq
	idiv	esi
	mov	ecx, DWORD PTR _iX$[ebp]
	shl	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+40]
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 194  : 						m_aaiFrac[iX][(m_iFracY / 2) + iY] /= (abs((m_iFracY / 12) - iY) + 1);

	mov	eax, DWORD PTR _iX$[ebp]
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	add	esi, DWORD PTR _iY$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	cdq
	mov	edi, 12					; 0000000cH
	idiv	edi
	sub	eax, DWORD PTR _iY$[ebp]
	cdq
	mov	edi, eax
	xor	edi, edx
	sub	edi, edx
	add	edi, 1
	mov	eax, DWORD PTR [ecx+esi*4]
	cdq
	idiv	edi
	mov	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _iY$[ebp]
	mov	edx, DWORD PTR _iX$[ebp]
	shl	edx, 10					; 0000000aH
	mov	esi, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [esi+edx+40]
	mov	DWORD PTR [edx+eax*4], ecx

; 195  : 					}

	jmp	$LN33@fracInitIn
$LN32@fracInitIn:

; 196  : 				}

	jmp	$LN36@fracInitIn
$LN38@fracInitIn:

; 197  : 			}
; 198  : 
; 199  : 			if(m_iFlags & FRAC_WRAP_X)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 1
	je	$LN39@fracInitIn

; 200  : 			{
; 201  : 				for(iY = 0; iY < m_iFracY + 1; iY++)

	mov	DWORD PTR _iY$[ebp], 0
	jmp	SHORT $LN30@fracInitIn
$LN29@fracInitIn:
	mov	edx, DWORD PTR _iY$[ebp]
	add	edx, 1
	mov	DWORD PTR _iY$[ebp], edx
$LN30@fracInitIn:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	cmp	DWORD PTR _iY$[ebp], ecx
	jge	$LN39@fracInitIn

; 202  : 				{
; 203  : 					for(iX = 0; iX < (m_iFracX / 6); iX++)

	mov	DWORD PTR _iX$[ebp], 0
	jmp	SHORT $LN27@fracInitIn
$LN26@fracInitIn:
	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, 1
	mov	DWORD PTR _iX$[ebp], edx
$LN27@fracInitIn:
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	cdq
	mov	ecx, 6
	idiv	ecx
	cmp	DWORD PTR _iX$[ebp], eax
	jge	$LN25@fracInitIn

; 204  : 					{
; 205  : 						m_aaiFrac[        iX         ][iY] /= (abs((m_iFracX / 12) - iX) + 1);

	mov	edx, DWORD PTR _iX$[ebp]
	shl	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cdq
	mov	esi, 12					; 0000000cH
	idiv	esi
	sub	eax, DWORD PTR _iX$[ebp]
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	add	esi, 1
	mov	eax, DWORD PTR _iY$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	cdq
	idiv	esi
	mov	ecx, DWORD PTR _iX$[ebp]
	shl	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+40]
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 206  : 						m_aaiFrac[(m_iFracX / 2) + iX][iY] /= (abs((m_iFracX / 12) - iX) + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _iX$[ebp]
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cdq
	mov	esi, 12					; 0000000cH
	idiv	esi
	sub	eax, DWORD PTR _iX$[ebp]
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	add	esi, 1
	mov	eax, DWORD PTR _iY$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	cdq
	idiv	esi
	mov	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _iX$[ebp]
	shl	eax, 10					; 0000000aH
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+eax+40]
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 207  : 					}

	jmp	$LN26@fracInitIn
$LN25@fracInitIn:

; 208  : 				}

	jmp	$LN29@fracInitIn
$LN39@fracInitIn:

; 209  : 			}
; 210  : 		}
; 211  : 
; 212  : 		for(iX = 0; iX < (m_iFracX >> iPass) + ((m_iFlags & FRAC_WRAP_X) ? 0 : 1); iX++)

	mov	DWORD PTR _iX$[ebp], 0
	jmp	SHORT $LN24@fracInitIn
$LN23@fracInitIn:
	mov	eax, DWORD PTR _iX$[ebp]
	add	eax, 1
	mov	DWORD PTR _iX$[ebp], eax
$LN24@fracInitIn:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _iPass$[ebp]
	sar	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	add	edx, ecx
	cmp	DWORD PTR _iX$[ebp], edx
	jge	$LN22@fracInitIn

; 213  : 		{
; 214  : 			for(iY = 0; iY < (m_iFracY >> iPass) + ((m_iFlags & FRAC_WRAP_Y) ? 0 : 1); iY++)

	mov	DWORD PTR _iY$[ebp], 0
	jmp	SHORT $LN21@fracInitIn
$LN20@fracInitIn:
	mov	edx, DWORD PTR _iY$[ebp]
	add	edx, 1
	mov	DWORD PTR _iY$[ebp], edx
$LN21@fracInitIn:
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _iPass$[ebp]
	sar	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 2
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	add	edx, ecx
	cmp	DWORD PTR _iY$[ebp], edx
	jge	$LN19@fracInitIn

; 215  : 			{
; 216  : 				if((iPass == iSmooth)) // If this is the first, pass, set the initial random spots

	mov	edx, DWORD PTR _iPass$[ebp]
	cmp	edx, DWORD PTR _iSmooth$[ebp]
	jne	$LN18@fracInitIn

; 217  : 				{
; 218  : 					if(pbyHints == NULL)

	cmp	DWORD PTR _pbyHints$[ebp], 0
	jne	SHORT $LN17@fracInitIn

; 219  : 					{
; 220  : 						m_aaiFrac[iX << iPass][iY << iPass] = random.get(256, "Fractal Gen");

	push	OFFSET ??_C@_0M@KOHMAFOF@Fractal?5Gen?$AA@
	push	256					; 00000100H
	mov	ecx, DWORD PTR _random$[ebp]
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	eax, ax
	mov	edx, DWORD PTR _iX$[ebp]
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	edx, cl
	shl	edx, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+edx+40]
	mov	esi, DWORD PTR _iY$[ebp]
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	esi, cl
	mov	DWORD PTR [edx+esi*4], eax

; 221  : 					}
; 222  : 					else

	jmp	SHORT $LN16@fracInitIn
$LN17@fracInitIn:

; 223  : 					{
; 224  : 						int iXX = iX % iHintsWidth;  // wrap

	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR _iHintsWidth$[ebp]
	mov	DWORD PTR _iXX$217299[ebp], edx

; 225  : 						int iYY = iY % iHintsHeight; // wrap

	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR _iHintsHeight$[ebp]
	mov	DWORD PTR _iYY$217300[ebp], edx

; 226  : 						int iHintsI = iYY*iHintsWidth + iXX;

	mov	eax, DWORD PTR _iYY$217300[ebp]
	imul	eax, DWORD PTR _iHintsWidth$[ebp]
	add	eax, DWORD PTR _iXX$217299[ebp]
	mov	DWORD PTR _iHintsI$217301[ebp], eax

; 227  : 
; 228  : #ifdef CVASSERT_ENABLE
; 229  : 						DEBUG_VARIABLE(iHintsLength);
; 230  : 						CvAssertMsg(iHintsI < iHintsLength, "iHintsI out of range");
; 231  : #endif
; 232  : 						m_aaiFrac[iX << iPass][iY << iPass] = pbyHints[iHintsI];

	mov	ecx, DWORD PTR _pbyHints$[ebp]
	add	ecx, DWORD PTR _iHintsI$217301[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _iX$[ebp]
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	eax, cl
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax+40]
	mov	esi, DWORD PTR _iY$[ebp]
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	esi, cl
	mov	DWORD PTR [eax+esi*4], edx
$LN16@fracInitIn:

; 233  : 					}
; 234  : 				}
; 235  : 				else  // Interpolate

	jmp	$LN15@fracInitIn
$LN18@fracInitIn:

; 236  : 				{
; 237  : 					iSum = 0;

	mov	DWORD PTR _iSum$[ebp], 0

; 238  : 					if((iX << iPass) & iScreen)

	mov	edx, DWORD PTR _iX$[ebp]
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	edx, cl
	and	edx, DWORD PTR _iScreen$[ebp]
	je	$LN14@fracInitIn

; 239  : 					{
; 240  : 						if((iY << iPass) & iScreen)   // (center)

	mov	eax, DWORD PTR _iY$[ebp]
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR _iScreen$[ebp]
	je	$LN13@fracInitIn

; 241  : 						{
; 242  : 							iSum += m_aaiFrac[(iX-1) << iPass][(iY-1) << iPass];

	mov	edx, DWORD PTR _iX$[ebp]
	sub	edx, 1
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	edx, cl
	shl	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [eax+edx+40]
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _iSum$[ebp]
	add	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _iSum$[ebp], ecx

; 243  : 							iSum += m_aaiFrac[(iX+1) << iPass][(iY-1) << iPass];

	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, 1
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	edx, cl
	shl	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [eax+edx+40]
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _iSum$[ebp]
	add	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _iSum$[ebp], ecx

; 244  : 							iSum += m_aaiFrac[(iX-1) << iPass][(iY+1) << iPass];

	mov	edx, DWORD PTR _iX$[ebp]
	sub	edx, 1
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	edx, cl
	shl	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [eax+edx+40]
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _iSum$[ebp]
	add	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _iSum$[ebp], ecx

; 245  : 							iSum += m_aaiFrac[(iX+1) << iPass][(iY+1) << iPass];

	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, 1
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	edx, cl
	shl	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [eax+edx+40]
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _iSum$[ebp]
	add	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _iSum$[ebp], ecx

; 246  : 							iSum >>= 2;

	mov	edx, DWORD PTR _iSum$[ebp]
	sar	edx, 2
	mov	DWORD PTR _iSum$[ebp], edx

; 247  : 							iSum += random.get(1 << (8 - iSmooth + iPass), "Fractal Gen 2");

	push	OFFSET ??_C@_0O@IGFOEPML@Fractal?5Gen?52?$AA@
	mov	ecx, 8
	sub	ecx, DWORD PTR _iSmooth$[ebp]
	add	ecx, DWORD PTR _iPass$[ebp]
	mov	eax, 1
	shl	eax, cl
	push	eax
	mov	ecx, DWORD PTR _random$[ebp]
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	ecx, ax
	add	ecx, DWORD PTR _iSum$[ebp]
	mov	DWORD PTR _iSum$[ebp], ecx

; 248  : 							iSum -= 1 << (7 - iSmooth + iPass);

	mov	ecx, 7
	sub	ecx, DWORD PTR _iSmooth$[ebp]
	add	ecx, DWORD PTR _iPass$[ebp]
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _iSum$[ebp]
	sub	eax, edx
	mov	DWORD PTR _iSum$[ebp], eax

; 249  : 							iSum = range(iSum, 0, 255);

	jns	SHORT $LN87@fracInitIn
	mov	DWORD PTR _iSum$[ebp], 0
	jmp	SHORT $LN88@fracInitIn
	jmp	SHORT $LN88@fracInitIn
$LN87@fracInitIn:
	cmp	DWORD PTR _iSum$[ebp], 255		; 000000ffH
	jle	SHORT $LN85@fracInitIn
	mov	DWORD PTR _iSum$[ebp], 255		; 000000ffH
	jmp	SHORT $LN88@fracInitIn
	jmp	SHORT $LN88@fracInitIn
$LN85@fracInitIn:
	mov	ecx, DWORD PTR _iSum$[ebp]
	mov	DWORD PTR _iSum$[ebp], ecx
$LN88@fracInitIn:

; 250  : 							m_aaiFrac[iX << iPass][iY << iPass] = iSum;

	mov	edx, DWORD PTR _iX$[ebp]
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	edx, cl
	shl	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [eax+edx+40]
	mov	eax, DWORD PTR _iY$[ebp]
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _iSum$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 251  : 						}
; 252  : 						else  // (horizontal)

	jmp	$LN12@fracInitIn
$LN13@fracInitIn:

; 253  : 						{
; 254  : 							iSum += m_aaiFrac[(iX-1) << iPass][iY << iPass];

	mov	edx, DWORD PTR _iX$[ebp]
	sub	edx, 1
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	edx, cl
	shl	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [eax+edx+40]
	mov	eax, DWORD PTR _iY$[ebp]
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _iSum$[ebp]
	add	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _iSum$[ebp], ecx

; 255  : 							iSum += m_aaiFrac[(iX+1) << iPass][iY << iPass];

	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, 1
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	edx, cl
	shl	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [eax+edx+40]
	mov	eax, DWORD PTR _iY$[ebp]
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _iSum$[ebp]
	add	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _iSum$[ebp], ecx

; 256  : 							iSum >>= 1;

	mov	edx, DWORD PTR _iSum$[ebp]
	sar	edx, 1
	mov	DWORD PTR _iSum$[ebp], edx

; 257  : 							iSum += random.get(1 << (8 - iSmooth + iPass), "Fractal Gen 3");

	push	OFFSET ??_C@_0O@JPEFHOIK@Fractal?5Gen?53?$AA@
	mov	ecx, 8
	sub	ecx, DWORD PTR _iSmooth$[ebp]
	add	ecx, DWORD PTR _iPass$[ebp]
	mov	eax, 1
	shl	eax, cl
	push	eax
	mov	ecx, DWORD PTR _random$[ebp]
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	ecx, ax
	add	ecx, DWORD PTR _iSum$[ebp]
	mov	DWORD PTR _iSum$[ebp], ecx

; 258  : 							iSum -= 1 << (7 - iSmooth + iPass);

	mov	ecx, 7
	sub	ecx, DWORD PTR _iSmooth$[ebp]
	add	ecx, DWORD PTR _iPass$[ebp]
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _iSum$[ebp]
	sub	eax, edx
	mov	DWORD PTR _iSum$[ebp], eax

; 259  : 							iSum = range(iSum, 0, 255);

	jns	SHORT $LN93@fracInitIn
	mov	DWORD PTR _iSum$[ebp], 0
	jmp	SHORT $LN94@fracInitIn
	jmp	SHORT $LN94@fracInitIn
$LN93@fracInitIn:
	cmp	DWORD PTR _iSum$[ebp], 255		; 000000ffH
	jle	SHORT $LN91@fracInitIn
	mov	DWORD PTR _iSum$[ebp], 255		; 000000ffH
	jmp	SHORT $LN94@fracInitIn
	jmp	SHORT $LN94@fracInitIn
$LN91@fracInitIn:
	mov	ecx, DWORD PTR _iSum$[ebp]
	mov	DWORD PTR _iSum$[ebp], ecx
$LN94@fracInitIn:

; 260  : 							m_aaiFrac[iX << iPass][iY << iPass] = iSum;

	mov	edx, DWORD PTR _iX$[ebp]
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	edx, cl
	shl	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [eax+edx+40]
	mov	eax, DWORD PTR _iY$[ebp]
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _iSum$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
$LN12@fracInitIn:

; 261  : 						}
; 262  : 					}
; 263  : 					else

	jmp	$LN15@fracInitIn
$LN14@fracInitIn:

; 264  : 					{
; 265  : 						if((iY << iPass) & iScreen)   // (vertical)

	mov	edx, DWORD PTR _iY$[ebp]
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	edx, cl
	and	edx, DWORD PTR _iScreen$[ebp]
	je	$LN10@fracInitIn

; 266  : 						{
; 267  : 							iSum += m_aaiFrac[iX << iPass][(iY-1) << iPass];

	mov	eax, DWORD PTR _iX$[ebp]
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	eax, cl
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _iSum$[ebp]
	add	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _iSum$[ebp], ecx

; 268  : 							iSum += m_aaiFrac[iX << iPass][(iY+1) << iPass];

	mov	edx, DWORD PTR _iX$[ebp]
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	edx, cl
	shl	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [eax+edx+40]
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _iSum$[ebp]
	add	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _iSum$[ebp], ecx

; 269  : 							iSum >>= 1;

	mov	edx, DWORD PTR _iSum$[ebp]
	sar	edx, 1
	mov	DWORD PTR _iSum$[ebp], edx

; 270  : 							iSum += random.get(1 << (8 - iSmooth + iPass), "Fractal Gen 4");

	push	OFFSET ??_C@_0O@NAAEOIEN@Fractal?5Gen?54?$AA@
	mov	ecx, 8
	sub	ecx, DWORD PTR _iSmooth$[ebp]
	add	ecx, DWORD PTR _iPass$[ebp]
	mov	eax, 1
	shl	eax, cl
	push	eax
	mov	ecx, DWORD PTR _random$[ebp]
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	ecx, ax
	add	ecx, DWORD PTR _iSum$[ebp]
	mov	DWORD PTR _iSum$[ebp], ecx

; 271  : 							iSum -= 1 << (7 - iSmooth + iPass);

	mov	ecx, 7
	sub	ecx, DWORD PTR _iSmooth$[ebp]
	add	ecx, DWORD PTR _iPass$[ebp]
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _iSum$[ebp]
	sub	eax, edx
	mov	DWORD PTR _iSum$[ebp], eax

; 272  : 							iSum = range(iSum, 0, 255);

	jns	SHORT $LN99@fracInitIn
	mov	DWORD PTR _iSum$[ebp], 0
	jmp	SHORT $LN100@fracInitIn
	jmp	SHORT $LN100@fracInitIn
$LN99@fracInitIn:
	cmp	DWORD PTR _iSum$[ebp], 255		; 000000ffH
	jle	SHORT $LN97@fracInitIn
	mov	DWORD PTR _iSum$[ebp], 255		; 000000ffH
	jmp	SHORT $LN100@fracInitIn
	jmp	SHORT $LN100@fracInitIn
$LN97@fracInitIn:
	mov	ecx, DWORD PTR _iSum$[ebp]
	mov	DWORD PTR _iSum$[ebp], ecx
$LN100@fracInitIn:

; 273  : #ifdef AUI_WARNING_FIXES
; 274  : 							m_aaiFrac[iX << iPass][iY << iPass] = iSum;
; 275  : #else
; 276  : 							m_aaiFrac[iX << iPass][iY << iPass] = (BYTE) iSum;

	movzx	edx, BYTE PTR _iSum$[ebp]
	mov	eax, DWORD PTR _iX$[ebp]
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	eax, cl
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax+40]
	mov	esi, DWORD PTR _iY$[ebp]
	mov	ecx, DWORD PTR _iPass$[ebp]
	shl	esi, cl
	mov	DWORD PTR [eax+esi*4], edx

; 277  : #endif
; 278  : 						}
; 279  : 						else

	jmp	SHORT $LN15@fracInitIn
$LN10@fracInitIn:

; 280  : 						{
; 281  : 							continue;  // (corner) This was already set in an earlier iPass.

	jmp	$LN20@fracInitIn
$LN15@fracInitIn:

; 282  : 						}
; 283  : 					}
; 284  : 				}
; 285  : 			}

	jmp	$LN20@fracInitIn
$LN19@fracInitIn:

; 286  : 		}

	jmp	$LN23@fracInitIn
$LN22@fracInitIn:

; 287  : 	}

	jmp	$LN62@fracInitIn
$LN61@fracInitIn:

; 288  : 
; 289  : 	if(pRifts)

	cmp	DWORD PTR _pRifts$[ebp], 0
	je	SHORT $LN8@fracInitIn

; 290  : 	{
; 291  : 		tectonicAction(pRifts);  //  Assumes FRAC_WRAP_X is on.

	mov	ecx, DWORD PTR _pRifts$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?tectonicAction@CvFractal@@IAEXPAV1@@Z	; CvFractal::tectonicAction
$LN8@fracInitIn:

; 292  : 	}
; 293  : 
; 294  : 	if(m_iFlags & FRAC_INVERT_HEIGHTS)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 32					; 00000020H
	je	SHORT $LN72@fracInitIn

; 295  : 	{
; 296  : 		for(iX = 0; iX < m_iFracX; iX++)

	mov	DWORD PTR _iX$[ebp], 0
	jmp	SHORT $LN6@fracInitIn
$LN5@fracInitIn:
	mov	ecx, DWORD PTR _iX$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iX$[ebp], ecx
$LN6@fracInitIn:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jge	SHORT $LN72@fracInitIn

; 297  : 		{
; 298  : 			for(iY = 0; iY < m_iFracY; iY++)

	mov	DWORD PTR _iY$[ebp], 0
	jmp	SHORT $LN3@fracInitIn
$LN2@fracInitIn:
	mov	ecx, DWORD PTR _iY$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iY$[ebp], ecx
$LN3@fracInitIn:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iY$[ebp]
	cmp	eax, DWORD PTR [edx+20]
	jge	SHORT $LN1@fracInitIn

; 299  : 			{
; 300  : 				m_aaiFrac[iX][iY] = (255 - m_aaiFrac[iX][iY]);

	mov	ecx, DWORD PTR _iX$[ebp]
	shl	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+40]
	mov	ecx, DWORD PTR _iY$[ebp]
	mov	edx, 255				; 000000ffH
	sub	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _iX$[ebp]
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax+40]
	mov	ecx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 301  : 			}

	jmp	SHORT $LN2@fracInitIn
$LN1@fracInitIn:

; 302  : 		}

	jmp	SHORT $LN5@fracInitIn
$LN72@fracInitIn:

; 303  : 	}
; 304  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
?fracInitInternal@CvFractal@@IAEXHHHAAVCvRandom@@PAEHHPAV1@HH@Z ENDP ; CvFractal::fracInitInternal
_TEXT	ENDS
PUBLIC	?getHeight@CvFractal@@QAEHHH@Z			; CvFractal::getHeight
; Function compile flags: /Odtp
;	COMDAT ?getHeight@CvFractal@@QAEHHH@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_iLowX$ = -24						; size = 4
_iErrY$ = -20						; size = 4
_iErrX$ = -16						; size = 4
_iSum$ = -12						; size = 4
_iHeight$ = -8						; size = 4
_iLowY$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?getHeight@CvFractal@@QAEHHH@Z PROC			; CvFractal::getHeight, COMDAT
; _this$ = ecx

; 308  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 309  : 	int iErrX = 0;

	mov	DWORD PTR _iErrX$[ebp], 0

; 310  : 	int iErrY = 0;

	mov	DWORD PTR _iErrY$[ebp], 0

; 311  : 	int iSum = 0;

	mov	DWORD PTR _iSum$[ebp], 0

; 312  : 	int iHeight = 0;

	mov	DWORD PTR _iHeight$[ebp], 0

; 313  : 	int iLowX = 0;

	mov	DWORD PTR _iLowX$[ebp], 0

; 314  : 	int iLowY = 0;

	mov	DWORD PTR _iLowY$[ebp], 0

; 315  : 
; 316  : 	CvAssertMsg(0 <= iX && iX < m_iXs, "iX out of range");
; 317  : 	if(!(0 <= iX && iX < m_iXs)) return 0;

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN11@getHeight
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN12@getHeight
$LN11@getHeight:
	xor	eax, eax
	jmp	$LN13@getHeight
$LN12@getHeight:

; 318  : 
; 319  : 	CvAssertMsg(0 <= iY && iY < m_iYs, "iY out of range");
; 320  : 	if(!(0 <= iY && iY < m_iYs)) return 0;

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN9@getHeight
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iY$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jl	SHORT $LN10@getHeight
$LN9@getHeight:
	xor	eax, eax
	jmp	$LN13@getHeight
$LN10@getHeight:

; 321  : 
; 322  : 	iLowX = ((m_iXInc * iX) / FLOAT_PRECISION);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	imul	eax, DWORD PTR _iX$[ebp]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	mov	DWORD PTR _iLowX$[ebp], eax

; 323  : 	if(iLowX > m_iFracX - 1)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, 1
	cmp	DWORD PTR _iLowX$[ebp], eax
	jle	SHORT $LN8@getHeight

; 324  : 	{
; 325  : 		iLowX = m_iFracX - 1;	// clamp so that iLowX+1 doesn't overrun array

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, 1
	mov	DWORD PTR _iLowX$[ebp], edx
$LN8@getHeight:

; 326  : 	}
; 327  : 
; 328  : 	iLowY = ((m_iYInc * iY) / FLOAT_PRECISION);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]
	imul	eax, DWORD PTR _iY$[ebp]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	mov	DWORD PTR _iLowY$[ebp], eax

; 329  : 	if(iLowY > m_iFracY - 1)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, 1
	cmp	DWORD PTR _iLowY$[ebp], eax
	jle	SHORT $LN7@getHeight

; 330  : 	{
; 331  : 		iLowY = m_iFracY - 1;	// clamp so that iLowY+1 doesn't overrun array

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, 1
	mov	DWORD PTR _iLowY$[ebp], edx
$LN7@getHeight:

; 332  : 	}
; 333  : 	iErrX = ((m_iXInc * iX) - (iLowX * FLOAT_PRECISION));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	imul	ecx, DWORD PTR _iX$[ebp]
	mov	edx, DWORD PTR _iLowX$[ebp]
	imul	edx, 1000				; 000003e8H
	sub	ecx, edx
	mov	DWORD PTR _iErrX$[ebp], ecx

; 334  : 	iErrY = ((m_iYInc * iY) - (iLowY * FLOAT_PRECISION));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	imul	ecx, DWORD PTR _iY$[ebp]
	mov	edx, DWORD PTR _iLowY$[ebp]
	imul	edx, 1000				; 000003e8H
	sub	ecx, edx
	mov	DWORD PTR _iErrY$[ebp], ecx

; 335  : 
; 336  : 	if(iLowX < 0 || iLowX > FRACTAL_MAX_DIMS) return 0; // array is defined as FRACTAL_MAX_DIMS+1

	cmp	DWORD PTR _iLowX$[ebp], 0
	jl	SHORT $LN5@getHeight
	cmp	DWORD PTR _iLowX$[ebp], 255		; 000000ffH
	jle	SHORT $LN6@getHeight
$LN5@getHeight:
	xor	eax, eax
	jmp	$LN13@getHeight
$LN6@getHeight:

; 337  : 	if(iLowY < 0 || iLowY > FRACTAL_MAX_DIMS) return 0; // array is defined as FRACTAL_MAX_DIMS+1

	cmp	DWORD PTR _iLowY$[ebp], 0
	jl	SHORT $LN3@getHeight
	cmp	DWORD PTR _iLowY$[ebp], 255		; 000000ffH
	jle	SHORT $LN4@getHeight
$LN3@getHeight:
	xor	eax, eax
	jmp	$LN13@getHeight
$LN4@getHeight:

; 338  : 
; 339  : 	iSum = 0;

	mov	DWORD PTR _iSum$[ebp], 0

; 340  : 	iSum += ((FLOAT_PRECISION - iErrX) * (FLOAT_PRECISION - iErrY) * m_aaiFrac[iLowX    ][iLowY    ]);

	mov	eax, 1000				; 000003e8H
	sub	eax, DWORD PTR _iErrX$[ebp]
	mov	ecx, 1000				; 000003e8H
	sub	ecx, DWORD PTR _iErrY$[ebp]
	imul	eax, ecx
	mov	edx, DWORD PTR _iLowX$[ebp]
	shl	edx, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+edx+40]
	mov	ecx, DWORD PTR _iLowY$[ebp]
	imul	eax, DWORD PTR [edx+ecx*4]
	add	eax, DWORD PTR _iSum$[ebp]
	mov	DWORD PTR _iSum$[ebp], eax

; 341  : 	iSum += ((iErrX) * (FLOAT_PRECISION - iErrY) * m_aaiFrac[iLowX + 1][iLowY    ]);

	mov	edx, 1000				; 000003e8H
	sub	edx, DWORD PTR _iErrY$[ebp]
	imul	edx, DWORD PTR _iErrX$[ebp]
	mov	eax, DWORD PTR _iLowX$[ebp]
	add	eax, 1
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax+40]
	mov	ecx, DWORD PTR _iLowY$[ebp]
	imul	edx, DWORD PTR [eax+ecx*4]
	add	edx, DWORD PTR _iSum$[ebp]
	mov	DWORD PTR _iSum$[ebp], edx

; 342  : 	iSum += ((FLOAT_PRECISION - iErrX) * (iErrY) * m_aaiFrac[iLowX    ][iLowY + 1]);

	mov	edx, 1000				; 000003e8H
	sub	edx, DWORD PTR _iErrX$[ebp]
	imul	edx, DWORD PTR _iErrY$[ebp]
	mov	eax, DWORD PTR _iLowX$[ebp]
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax+40]
	mov	ecx, DWORD PTR _iLowY$[ebp]
	imul	edx, DWORD PTR [eax+ecx*4+4]
	add	edx, DWORD PTR _iSum$[ebp]
	mov	DWORD PTR _iSum$[ebp], edx

; 343  : 	iSum += ((iErrX) * (iErrY) * m_aaiFrac[iLowX + 1][iLowY + 1]);

	mov	edx, DWORD PTR _iErrX$[ebp]
	imul	edx, DWORD PTR _iErrY$[ebp]
	mov	eax, DWORD PTR _iLowX$[ebp]
	add	eax, 1
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax+40]
	mov	ecx, DWORD PTR _iLowY$[ebp]
	imul	edx, DWORD PTR [eax+ecx*4+4]
	add	edx, DWORD PTR _iSum$[ebp]
	mov	DWORD PTR _iSum$[ebp], edx

; 344  : 
; 345  : 	iSum /= (FLOAT_PRECISION * FLOAT_PRECISION);

	mov	eax, DWORD PTR _iSum$[ebp]
	cdq
	mov	ecx, 1000000				; 000f4240H
	idiv	ecx
	mov	DWORD PTR _iSum$[ebp], eax

; 346  : 
; 347  : 	iHeight = range(iSum, 0, 255);

	cmp	DWORD PTR _iSum$[ebp], 0
	jge	SHORT $LN18@getHeight
	mov	DWORD PTR _iHeight$[ebp], 0
	jmp	SHORT $LN19@getHeight
	jmp	SHORT $LN19@getHeight
$LN18@getHeight:
	cmp	DWORD PTR _iSum$[ebp], 255		; 000000ffH
	jle	SHORT $LN16@getHeight
	mov	DWORD PTR _iHeight$[ebp], 255		; 000000ffH
	jmp	SHORT $LN19@getHeight
	jmp	SHORT $LN19@getHeight
$LN16@getHeight:
	mov	edx, DWORD PTR _iSum$[ebp]
	mov	DWORD PTR _iHeight$[ebp], edx
$LN19@getHeight:

; 348  : 
; 349  : 	if(m_iFlags & FRAC_PERCENT)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 4
	je	SHORT $LN2@getHeight

; 350  : 	{
; 351  : 		return ((iHeight * 100) >> 8);

	mov	eax, DWORD PTR _iHeight$[ebp]
	imul	eax, 100				; 00000064H
	sar	eax, 8
	jmp	SHORT $LN13@getHeight

; 352  : 	}
; 353  : 	else

	jmp	SHORT $LN13@getHeight
$LN2@getHeight:

; 354  : 	{
; 355  : 		return iHeight;

	mov	eax, DWORD PTR _iHeight$[ebp]
$LN13@getHeight:

; 356  : 	}
; 357  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?getHeight@CvFractal@@QAEHHH@Z ENDP			; CvFractal::getHeight
_TEXT	ENDS
PUBLIC	?getHeightFromPercent@CvFractal@@QAEHH@Z	; CvFractal::getHeightFromPercent
; Function compile flags: /Odtp
;	COMDAT ?getHeightFromPercent@CvFractal@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_iEstimate$ = -24					; size = 4
_iX$ = -20						; size = 4
_iLowerBound$ = -16					; size = 4
_iSum$ = -12						; size = 4
_iY$ = -8						; size = 4
_iUpperBound$ = -4					; size = 4
_iPercent$ = 8						; size = 4
?getHeightFromPercent@CvFractal@@QAEHH@Z PROC		; CvFractal::getHeightFromPercent, COMDAT
; _this$ = ecx

; 361  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 362  : 	int iEstimate;
; 363  : 	int iLowerBound;
; 364  : 	int iUpperBound;
; 365  : 	int iSum;
; 366  : 	int iX, iY;
; 367  : 
; 368  : 	iLowerBound = 0;

	mov	DWORD PTR _iLowerBound$[ebp], 0

; 369  : 	iUpperBound = 255;

	mov	DWORD PTR _iUpperBound$[ebp], 255	; 000000ffH

; 370  : 
; 371  : 	iPercent = range(iPercent, 0, 100);

	cmp	DWORD PTR _iPercent$[ebp], 0
	jge	SHORT $LN17@getHeightF
	mov	DWORD PTR _iPercent$[ebp], 0
	jmp	SHORT $LN18@getHeightF
	jmp	SHORT $LN18@getHeightF
$LN17@getHeightF:
	cmp	DWORD PTR _iPercent$[ebp], 100		; 00000064H
	jle	SHORT $LN15@getHeightF
	mov	DWORD PTR _iPercent$[ebp], 100		; 00000064H
	jmp	SHORT $LN18@getHeightF
	jmp	SHORT $LN18@getHeightF
$LN15@getHeightF:
	mov	eax, DWORD PTR _iPercent$[ebp]
	mov	DWORD PTR _iPercent$[ebp], eax
$LN18@getHeightF:

; 372  : 	iEstimate = 255 * iPercent / 100;

	mov	eax, DWORD PTR _iPercent$[ebp]
	imul	eax, 255				; 000000ffH
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iEstimate$[ebp], eax
$LN11@getHeightF:

; 373  : 
; 374  : 	while(iEstimate != iLowerBound)

	mov	edx, DWORD PTR _iEstimate$[ebp]
	cmp	edx, DWORD PTR _iLowerBound$[ebp]
	je	$LN10@getHeightF

; 375  : 	{
; 376  : 		iSum = 0;

	mov	DWORD PTR _iSum$[ebp], 0

; 377  : 
; 378  : 		for(iX = 0; iX < m_iFracX; iX++)

	mov	DWORD PTR _iX$[ebp], 0
	jmp	SHORT $LN9@getHeightF
$LN8@getHeightF:
	mov	eax, DWORD PTR _iX$[ebp]
	add	eax, 1
	mov	DWORD PTR _iX$[ebp], eax
$LN9@getHeightF:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR [ecx+16]
	jge	SHORT $LN7@getHeightF

; 379  : 		{
; 380  : 			for(iY = 0; iY < m_iFracY; iY++)

	mov	DWORD PTR _iY$[ebp], 0
	jmp	SHORT $LN6@getHeightF
$LN5@getHeightF:
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, 1
	mov	DWORD PTR _iY$[ebp], eax
$LN6@getHeightF:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	SHORT $LN4@getHeightF

; 381  : 			{
; 382  : 				if(m_aaiFrac[iX][iY] < iEstimate)

	mov	eax, DWORD PTR _iX$[ebp]
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	mov	eax, DWORD PTR _iY$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	ecx, DWORD PTR _iEstimate$[ebp]
	jge	SHORT $LN3@getHeightF

; 383  : 				{
; 384  : 					iSum++;

	mov	edx, DWORD PTR _iSum$[ebp]
	add	edx, 1
	mov	DWORD PTR _iSum$[ebp], edx
$LN3@getHeightF:

; 385  : 				}
; 386  : 			}

	jmp	SHORT $LN5@getHeightF
$LN4@getHeightF:

; 387  : 		}

	jmp	SHORT $LN8@getHeightF
$LN7@getHeightF:

; 388  : 		if(((100 * iSum) / (m_iFracX * m_iFracY)) > iPercent)

	mov	eax, DWORD PTR _iSum$[ebp]
	imul	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+16]
	imul	ecx, DWORD PTR [edx+20]
	cdq
	idiv	ecx
	cmp	eax, DWORD PTR _iPercent$[ebp]
	jle	SHORT $LN2@getHeightF

; 389  : 		{
; 390  : 			iUpperBound = iEstimate;

	mov	edx, DWORD PTR _iEstimate$[ebp]
	mov	DWORD PTR _iUpperBound$[ebp], edx

; 391  : 			iEstimate = (iUpperBound + iLowerBound) / 2;

	mov	eax, DWORD PTR _iUpperBound$[ebp]
	add	eax, DWORD PTR _iLowerBound$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iEstimate$[ebp], eax

; 392  : 		}
; 393  : 		else

	jmp	SHORT $LN1@getHeightF
$LN2@getHeightF:

; 394  : 		{
; 395  : 			iLowerBound = iEstimate;

	mov	eax, DWORD PTR _iEstimate$[ebp]
	mov	DWORD PTR _iLowerBound$[ebp], eax

; 396  : 			iEstimate = (iUpperBound + iLowerBound) / 2;

	mov	eax, DWORD PTR _iUpperBound$[ebp]
	add	eax, DWORD PTR _iLowerBound$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iEstimate$[ebp], eax
$LN1@getHeightF:

; 397  : 		}
; 398  : 	}

	jmp	$LN11@getHeightF
$LN10@getHeightF:

; 399  : 
; 400  : 	return iEstimate;

	mov	eax, DWORD PTR _iEstimate$[ebp]

; 401  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getHeightFromPercent@CvFractal@@QAEHH@Z ENDP		; CvFractal::getHeightFromPercent
_TEXT	ENDS
PUBLIC	?yieldX@CvFractal@@IAEHH@Z			; CvFractal::yieldX
; Function compile flags: /Odtp
;	COMDAT ?tectonicAction@CvFractal@@IAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
_iY$217383 = -32					; size = 4
_iDeep$217380 = -28					; size = 4
_iLx$217382 = -24					; size = 4
_iRx$217381 = -20					; size = 4
_iX$217376 = -16					; size = 4
_iY$217372 = -12					; size = 4
_iRift2x$ = -8						; size = 4
_iWidth$ = -4						; size = 4
_pRifts$ = 8						; size = 4
?tectonicAction@CvFractal@@IAEXPAV1@@Z PROC		; CvFractal::tectonicAction, COMDAT
; _this$ = ecx

; 406  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 407  : 	//int iRift1x = (m_iFracX / 4);
; 408  : 	const int iRift2x = ((m_iFracX / 4) * 3);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	imul	eax, 3
	mov	DWORD PTR _iRift2x$[ebp], eax

; 409  : 	const int iWidth = 16;

	mov	DWORD PTR _iWidth$[ebp], 16		; 00000010H

; 410  : 
; 411  : 	for(int iY = 0; iY < m_iFracY + 1; iY++)

	mov	DWORD PTR _iY$217372[ebp], 0
	jmp	SHORT $LN9@tectonicAc
$LN8@tectonicAc:
	mov	ecx, DWORD PTR _iY$217372[ebp]
	add	ecx, 1
	mov	DWORD PTR _iY$217372[ebp], ecx
$LN9@tectonicAc:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	cmp	DWORD PTR _iY$217372[ebp], eax
	jge	$LN7@tectonicAc

; 412  : 	{
; 413  : 		for(int iX = 0; iX < iWidth; iX++)

	mov	DWORD PTR _iX$217376[ebp], 0
	jmp	SHORT $LN6@tectonicAc
$LN5@tectonicAc:
	mov	ecx, DWORD PTR _iX$217376[ebp]
	add	ecx, 1
	mov	DWORD PTR _iX$217376[ebp], ecx
$LN6@tectonicAc:
	cmp	DWORD PTR _iX$217376[ebp], 16		; 00000010H
	jge	$LN4@tectonicAc

; 414  : 		{
; 415  : 			//  Rift along edge of map.
; 416  : 			int iDeep = 0;

	mov	DWORD PTR _iDeep$217380[ebp], 0

; 417  : 			int iRx = yieldX(((((pRifts->m_aaiFrac[iRift2x][iY] - 128) * m_iFracX) / 128) / 8) + iX);

	mov	edx, DWORD PTR _iRift2x$[ebp]
	shl	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _pRifts$[ebp]
	lea	ecx, DWORD PTR [eax+edx+40]
	mov	edx, DWORD PTR _iY$217372[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	sub	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [ecx+16]
	cdq
	and	edx, 127				; 0000007fH
	add	eax, edx
	sar	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	add	eax, DWORD PTR _iX$217376[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?yieldX@CvFractal@@IAEHH@Z		; CvFractal::yieldX
	mov	DWORD PTR _iRx$217381[ebp], eax

; 418  : 			int iLx = yieldX(((((pRifts->m_aaiFrac[iRift2x][iY] - 128) * m_iFracX) / 128) / 8) - iX);

	mov	edx, DWORD PTR _iRift2x$[ebp]
	shl	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _pRifts$[ebp]
	lea	ecx, DWORD PTR [eax+edx+40]
	mov	edx, DWORD PTR _iY$217372[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	sub	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [ecx+16]
	cdq
	and	edx, 127				; 0000007fH
	add	eax, edx
	sar	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	sub	eax, DWORD PTR _iX$217376[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?yieldX@CvFractal@@IAEHH@Z		; CvFractal::yieldX
	mov	DWORD PTR _iLx$217382[ebp], eax

; 419  : 			m_aaiFrac[iRx][iY] = (((m_aaiFrac[iRx][iY] * iX) + iDeep * (iWidth - iX)) / iWidth);

	mov	edx, DWORD PTR _iRx$217381[ebp]
	shl	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+40]
	mov	edx, DWORD PTR _iY$217372[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	imul	eax, DWORD PTR _iX$217376[ebp]
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR _iX$217376[ebp]
	imul	ecx, DWORD PTR _iDeep$217380[ebp]
	add	eax, ecx
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	edx, DWORD PTR _iRx$217381[ebp]
	shl	edx, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+edx+40]
	mov	ecx, DWORD PTR _iY$217372[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 420  : 			m_aaiFrac[iLx][iY] = (((m_aaiFrac[iLx][iY] * iX) + iDeep * (iWidth - iX)) / iWidth);

	mov	edx, DWORD PTR _iLx$217382[ebp]
	shl	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+40]
	mov	edx, DWORD PTR _iY$217372[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	imul	eax, DWORD PTR _iX$217376[ebp]
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR _iX$217376[ebp]
	imul	ecx, DWORD PTR _iDeep$217380[ebp]
	add	eax, ecx
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	edx, DWORD PTR _iLx$217382[ebp]
	shl	edx, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+edx+40]
	mov	ecx, DWORD PTR _iY$217372[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 421  : 		}

	jmp	$LN5@tectonicAc
$LN4@tectonicAc:

; 422  : 	}

	jmp	$LN8@tectonicAc
$LN7@tectonicAc:

; 423  : 
; 424  : 	for(int iY = 0; iY < m_iFracY + 1; iY++)

	mov	DWORD PTR _iY$217383[ebp], 0
	jmp	SHORT $LN3@tectonicAc
$LN2@tectonicAc:
	mov	edx, DWORD PTR _iY$217383[ebp]
	add	edx, 1
	mov	DWORD PTR _iY$217383[ebp], edx
$LN3@tectonicAc:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	cmp	DWORD PTR _iY$217383[ebp], ecx
	jge	SHORT $LN10@tectonicAc

; 425  : 	{
; 426  : 		m_aaiFrac[m_iFracX][iY] = m_aaiFrac[0][iY];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	mov	eax, DWORD PTR _iY$217383[ebp]
	mov	ecx, DWORD PTR _iY$217383[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+40]
	mov	DWORD PTR [edx+eax*4], ecx
	jmp	SHORT $LN2@tectonicAc
$LN10@tectonicAc:

; 427  : 	}
; 428  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?tectonicAction@CvFractal@@IAEXPAV1@@Z ENDP		; CvFractal::tectonicAction
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?yieldX@CvFractal@@IAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iBadX$ = 8						; size = 4
?yieldX@CvFractal@@IAEHH@Z PROC				; CvFractal::yieldX, COMDAT
; _this$ = ecx

; 432  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 433  : 	if(iBadX < 0)

	cmp	DWORD PTR _iBadX$[ebp], 0
	jge	SHORT $LN2@yieldX

; 434  : 	{
; 435  : 		return (iBadX + m_iFracX);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iBadX$[ebp]
	add	ecx, DWORD PTR [eax+16]
	mov	eax, ecx
	jmp	SHORT $LN3@yieldX
$LN2@yieldX:

; 436  : 	}
; 437  : 
; 438  : 	if(iBadX >= m_iFracX)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iBadX$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jl	SHORT $LN1@yieldX

; 439  : 	{
; 440  : 		return (iBadX - m_iFracX);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iBadX$[ebp]
	sub	eax, DWORD PTR [ecx+16]
	jmp	SHORT $LN3@yieldX
$LN1@yieldX:

; 441  : 	}
; 442  : 
; 443  : 	return iBadX;

	mov	eax, DWORD PTR _iBadX$[ebp]
$LN3@yieldX:

; 444  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?yieldX@CvFractal@@IAEHH@Z ENDP				; CvFractal::yieldX
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<VoronoiSeed,256,1,297,0>::~FStaticVector<VoronoiSeed,256,1,297,0>
PUBLIC	??_C@_0M@HPOPDCFI@Ridge?5Gen?58?$AA@		; `string'
PUBLIC	?push_back@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAEIABUVoronoiSeed@@@Z ; FStaticVector<VoronoiSeed,256,1,297,0>::push_back
PUBLIC	??_C@_0M@PIHHCOJH@Ridge?5Gen?57?$AA@		; `string'
PUBLIC	??_C@_0M@OBGMBPNG@Ridge?5Gen?56?$AA@		; `string'
PUBLIC	?hexDistance@@YAHHH@Z				; hexDistance
PUBLIC	??_C@_0M@MKEBEMBF@Ridge?5Gen?55?$AA@		; `string'
PUBLIC	??_C@_0M@NDFKHNFE@Ridge?5Gen?54?$AA@		; `string'
PUBLIC	??_C@_0M@JMBLOLJD@Ridge?5Gen?53?$AA@		; `string'
PUBLIC	??_C@_0M@IFAANKNC@Ridge?5Gen?52?$AA@		; `string'
PUBLIC	??_C@_0M@KOCNIJBB@Ridge?5Gen?51?$AA@		; `string'
PUBLIC	?GrowSizeToFit@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<VoronoiSeed,256,1,297,0>::GrowSizeToFit
PUBLIC	??0?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<VoronoiSeed,256,1,297,0>::FStaticVector<VoronoiSeed,256,1,297,0>
PUBLIC	__$ArrayPad$
PUBLIC	?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z ; CvFractal::ridgeBuilder
EXTRN	?estimateDirection@@YA?AW4DirectionTypes@@HH@Z:PROC ; estimateDirection
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
;	COMDAT ??_C@_0M@HPOPDCFI@Ridge?5Gen?58?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0M@HPOPDCFI@Ridge?5Gen?58?$AA@ DB 'Ridge Gen 8', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PIHHCOJH@Ridge?5Gen?57?$AA@
CONST	SEGMENT
??_C@_0M@PIHHCOJH@Ridge?5Gen?57?$AA@ DB 'Ridge Gen 7', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OBGMBPNG@Ridge?5Gen?56?$AA@
CONST	SEGMENT
??_C@_0M@OBGMBPNG@Ridge?5Gen?56?$AA@ DB 'Ridge Gen 6', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MKEBEMBF@Ridge?5Gen?55?$AA@
CONST	SEGMENT
??_C@_0M@MKEBEMBF@Ridge?5Gen?55?$AA@ DB 'Ridge Gen 5', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NDFKHNFE@Ridge?5Gen?54?$AA@
CONST	SEGMENT
??_C@_0M@NDFKHNFE@Ridge?5Gen?54?$AA@ DB 'Ridge Gen 4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JMBLOLJD@Ridge?5Gen?53?$AA@
CONST	SEGMENT
??_C@_0M@JMBLOLJD@Ridge?5Gen?53?$AA@ DB 'Ridge Gen 3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IFAANKNC@Ridge?5Gen?52?$AA@
CONST	SEGMENT
??_C@_0M@IFAANKNC@Ridge?5Gen?52?$AA@ DB 'Ridge Gen 2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KOCNIJBB@Ridge?5Gen?51?$AA@
CONST	SEGMENT
??_C@_0M@KOCNIJBB@Ridge?5Gen?51?$AA@ DB 'Ridge Gen 1', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z$0
__ehfuncinfo$?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvfractal.cpp
xdata$x	ENDS
;	COMDAT ?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z
_TEXT	SEGMENT
tv322 = -5400						; size = 4
tv315 = -5396						; size = 4
tv411 = -5392						; size = 4
tv129 = -5388						; size = 4
tv88 = -5384						; size = 4
tv357 = -5380						; size = 4
tv347 = -5376						; size = 4
_this$ = -5372						; size = 4
$T218080 = -5356					; size = 4
$T218071 = -5352					; size = 4
$T218052 = -5348					; size = 4
$T218048 = -5344					; size = 4
$T218030 = -5324					; size = 4
$T218026 = -5320					; size = 4
$T217997 = -5296					; size = 4
$T217993 = -5292					; size = 4
$T217987 = -5288					; size = 4
$T217978 = -5284					; size = 4
$T217971 = -5280					; size = 4
$T217970 = -5276					; size = 4
$T217962 = -5272					; size = 4
$T217951 = -5268					; size = 4
$T217943 = -5264					; size = 4
$T217942 = -5260					; size = 4
$T217941 = -5256					; size = 4
$T217940 = -5252					; size = 4
$T217939 = -5248					; size = 4
$T217938 = -5244					; size = 4
$T217937 = -5240					; size = 4
$T217936 = -5236					; size = 4
_eRelativeDirection$217607 = -5232			; size = 4
_iModifiedHexspaceDistance$217604 = -5228		; size = 4
_iThisVoronoiSeedIndex$217600 = -5224			; size = 4
_iNextClosestSeed$217599 = -5220			; size = 4
_iThisHexY$217597 = -5216				; size = 4
_iThisHexX$217596 = -5212				; size = 4
_iRidgeHeight$217615 = -5208				; size = 4
_iClosestSeed$217598 = -5204				; size = 4
_iY$217592 = -5200					; size = 4
_iX$217588 = -5196					; size = 4
_iDistanceBetweenVoronoiSeeds$217584 = -5192		; size = 4
_iThatVoronoiSeedIndex$217580 = -5188			; size = 4
_thisVoronoiSeed$217566 = -5184				; size = 20
_bNeedToRecheck$217576 = -5161				; size = 1
_iThisVoronoiSeedIndex$217562 = -5160			; size = 4
_vVoronoiSeeds$ = -5156					; size = 5136
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_random$ = 8						; size = 4
_iNumVoronoiSeeds$ = 12					; size = 4
_iRidgeFlags$ = 16					; size = 4
_iBlendRidge$ = 20					; size = 4
_iBlendFract$ = 24					; size = 4
?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z PROC	; CvFractal::ridgeBuilder, COMDAT
; _this$ = ecx

; 458  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, 5388				; 0000150cH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 459  : 	// this will use a modified Voronoi system to give the appearance of mountain ranges
; 460  : 
; 461  : #ifdef NQM_FAST_COMP
; 462  : 	iNumVoronoiSeeds = MAX(iNumVoronoiSeeds, 3); // make sure that we have at least 3
; 463  : #else
; 464  : 	iNumVoronoiSeeds = std::max(iNumVoronoiSeeds,3); // make sure that we have at least 3

	mov	DWORD PTR $T217936[ebp], 3
	mov	eax, DWORD PTR _iNumVoronoiSeeds$[ebp]
	cmp	eax, DWORD PTR $T217936[ebp]
	jge	SHORT $LN32@ridgeBuild
	lea	ecx, DWORD PTR $T217936[ebp]
	mov	DWORD PTR tv347[ebp], ecx
	jmp	SHORT $LN33@ridgeBuild
$LN32@ridgeBuild:
	lea	edx, DWORD PTR _iNumVoronoiSeeds$[ebp]
	mov	DWORD PTR tv347[ebp], edx
$LN33@ridgeBuild:
	mov	eax, DWORD PTR tv347[ebp]
	mov	DWORD PTR $T217951[ebp], eax
	mov	ecx, DWORD PTR $T217951[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iNumVoronoiSeeds$[ebp], edx

; 465  : #endif
; 466  : 
; 467  : 	// randomly place the seed points of each region ??? do we want a way for an advanced script to pass this in ???
; 468  : 	FStaticVector<VoronoiSeed,256, true, c_eCiv5GameplayDLL, 0> vVoronoiSeeds;

	lea	ecx, DWORD PTR _vVoronoiSeeds$[ebp]
	call	??0?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<VoronoiSeed,256,1,297,0>::FStaticVector<VoronoiSeed,256,1,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 469  : 	vVoronoiSeeds.reserve(iNumVoronoiSeeds);

	mov	eax, DWORD PTR _iNumVoronoiSeeds$[ebp]
	mov	DWORD PTR $T217962[ebp], eax
	mov	ecx, DWORD PTR $T217962[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vVoronoiSeeds$[ebp]
	call	?GrowSizeToFit@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<VoronoiSeed,256,1,297,0>::GrowSizeToFit

; 470  : 
; 471  : 	for(int iThisVoronoiSeedIndex = 0; iThisVoronoiSeedIndex < iNumVoronoiSeeds; iThisVoronoiSeedIndex++)

	mov	DWORD PTR _iThisVoronoiSeedIndex$217562[ebp], 0
	jmp	SHORT $LN26@ridgeBuild
$LN25@ridgeBuild:
	mov	edx, DWORD PTR _iThisVoronoiSeedIndex$217562[ebp]
	add	edx, 1
	mov	DWORD PTR _iThisVoronoiSeedIndex$217562[ebp], edx
$LN26@ridgeBuild:
	mov	eax, DWORD PTR _iThisVoronoiSeedIndex$217562[ebp]
	cmp	eax, DWORD PTR _iNumVoronoiSeeds$[ebp]
	jge	$LN24@ridgeBuild

; 472  : 	{
; 473  : 		VoronoiSeed thisVoronoiSeed;
; 474  : 		thisVoronoiSeed.m_iHexspaceY = random.get(m_iFracY, "Ridge Gen 1");

	push	OFFSET ??_C@_0M@KOCNIJBB@Ridge?5Gen?51?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+20]
	push	edx
	mov	ecx, DWORD PTR _random$[ebp]
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	eax, ax
	mov	DWORD PTR _thisVoronoiSeed$217566[ebp+4], eax

; 475  : 		thisVoronoiSeed.m_iHexspaceX =  xToHexspaceX(random.get(m_iFracX, "Ridge Gen 2"), thisVoronoiSeed.m_iHexspaceY);

	mov	ecx, DWORD PTR _thisVoronoiSeed$217566[ebp+4]
	mov	DWORD PTR $T217971[ebp], ecx
	push	OFFSET ??_C@_0M@IFAANKNC@Ridge?5Gen?52?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _random$[ebp]
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	ecx, ax
	mov	DWORD PTR $T217970[ebp], ecx
	cmp	DWORD PTR $T217971[ebp], 0
	jl	SHORT $LN43@ridgeBuild
	mov	edx, DWORD PTR $T217971[ebp]
	sar	edx, 1
	mov	DWORD PTR tv357[ebp], edx
	jmp	SHORT $LN41@ridgeBuild
$LN43@ridgeBuild:
	mov	eax, DWORD PTR $T217971[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv357[ebp], eax
$LN41@ridgeBuild:
	mov	eax, DWORD PTR $T217970[ebp]
	sub	eax, DWORD PTR tv357[ebp]
	mov	DWORD PTR _thisVoronoiSeed$217566[ebp], eax

; 476  : #ifdef AUI_FRACTAL_RIDGE_USE_BINOM_RNG
; 477  : 		thisVoronoiSeed.m_iWeakness = MAX(0, int(random.getBinom(7, "Ridge Gen 3")) - 3); // ??? do we want to parameterize this???
; 478  : #elif defined(AUI_USE_SFMT_RNG) || defined(AUI_WARNING_FIXES)
; 479  : 		thisVoronoiSeed.m_iWeakness = MAX(0, int(random.get(7, "Ridge Gen 3")) - 3); // ??? do we want to parameterize this???
; 480  : #elif defined(NQM_FAST_COMP)
; 481  : 		thisVoronoiSeed.m_iWeakness = MAX(0, random.get(7, "Ridge Gen 3") - 3); // ??? do we want to parameterize this???
; 482  : #else
; 483  : 		thisVoronoiSeed.m_iWeakness = std::max(0,random.get(7, "Ridge Gen 3")-3); // ??? do we want to parameterize this???

	push	OFFSET ??_C@_0M@JMBLOLJD@Ridge?5Gen?53?$AA@
	push	7
	mov	ecx, DWORD PTR _random$[ebp]
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	ecx, ax
	sub	ecx, 3
	mov	DWORD PTR $T217937[ebp], ecx
	mov	DWORD PTR $T217938[ebp], 0
	mov	edx, DWORD PTR $T217938[ebp]
	cmp	edx, DWORD PTR $T217937[ebp]
	jge	SHORT $LN47@ridgeBuild
	lea	eax, DWORD PTR $T217937[ebp]
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $LN48@ridgeBuild
$LN47@ridgeBuild:
	lea	ecx, DWORD PTR $T217938[ebp]
	mov	DWORD PTR tv88[ebp], ecx
$LN48@ridgeBuild:
	mov	edx, DWORD PTR tv88[ebp]
	mov	DWORD PTR $T217978[ebp], edx
	mov	eax, DWORD PTR $T217978[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _thisVoronoiSeed$217566[ebp+8], ecx

; 484  : #endif
; 485  : 		thisVoronoiSeed.m_eBiasDirection = random.get(NUM_DIRECTION_TYPES, "Ridge Gen 4");

	push	OFFSET ??_C@_0M@NDFKHNFE@Ridge?5Gen?54?$AA@
	push	6
	mov	ecx, DWORD PTR _random$[ebp]
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	edx, ax
	mov	DWORD PTR _thisVoronoiSeed$217566[ebp+12], edx

; 486  : #ifdef AUI_FRACTAL_RIDGE_USE_BINOM_RNG
; 487  : 		thisVoronoiSeed.m_iDirectionalBiasStrength = MAX(0, int(random.getBinom(8, "Ridge Gen 5")) - 4); // ??? do we want to parameterize this???
; 488  : #elif defined(AUI_USE_SFMT_RNG) || defined(AUI_WARNING_FIXES)
; 489  : 		thisVoronoiSeed.m_iDirectionalBiasStrength = MAX(0, int(random.get(8, "Ridge Gen 5")) - 4); // ??? do we want to parameterize this???
; 490  : #elif defined(NQM_FAST_COMP)
; 491  : 		thisVoronoiSeed.m_iDirectionalBiasStrength = MAX(0, random.get(8, "Ridge Gen 5") - 4); // ??? do we want to parameterize this???
; 492  : #else
; 493  : 		thisVoronoiSeed.m_iDirectionalBiasStrength = std::max(0,random.get(8, "Ridge Gen 5") - 4); // ??? do we want to parameterize this???

	push	OFFSET ??_C@_0M@MKEBEMBF@Ridge?5Gen?55?$AA@
	push	8
	mov	ecx, DWORD PTR _random$[ebp]
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	eax, ax
	sub	eax, 4
	mov	DWORD PTR $T217939[ebp], eax
	mov	DWORD PTR $T217940[ebp], 0
	mov	ecx, DWORD PTR $T217940[ebp]
	cmp	ecx, DWORD PTR $T217939[ebp]
	jge	SHORT $LN51@ridgeBuild
	lea	edx, DWORD PTR $T217939[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN52@ridgeBuild
$LN51@ridgeBuild:
	lea	eax, DWORD PTR $T217940[ebp]
	mov	DWORD PTR tv129[ebp], eax
$LN52@ridgeBuild:
	mov	ecx, DWORD PTR tv129[ebp]
	mov	DWORD PTR $T217987[ebp], ecx
	mov	edx, DWORD PTR $T217987[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _thisVoronoiSeed$217566[ebp+16], eax
$LN23@ridgeBuild:

; 494  : #endif
; 495  : 
; 496  : 		// check to see if we are too close to an existing seed
; 497  : 		bool bNeedToRecheck;
; 498  : 		do
; 499  : 		{
; 500  : 			bNeedToRecheck = false;

	mov	BYTE PTR _bNeedToRecheck$217576[ebp], 0

; 501  : 			for(int iThatVoronoiSeedIndex = 0; iThatVoronoiSeedIndex < iThisVoronoiSeedIndex; iThatVoronoiSeedIndex++)

	mov	DWORD PTR _iThatVoronoiSeedIndex$217580[ebp], 0
	jmp	SHORT $LN20@ridgeBuild
$LN19@ridgeBuild:
	mov	ecx, DWORD PTR _iThatVoronoiSeedIndex$217580[ebp]
	add	ecx, 1
	mov	DWORD PTR _iThatVoronoiSeedIndex$217580[ebp], ecx
$LN20@ridgeBuild:
	mov	edx, DWORD PTR _iThatVoronoiSeedIndex$217580[ebp]
	cmp	edx, DWORD PTR _iThisVoronoiSeedIndex$217562[ebp]
	jge	$LN22@ridgeBuild

; 502  : 			{
; 503  : 				int iDistanceBetweenVoronoiSeeds = hexDistance(thisVoronoiSeed.m_iHexspaceX-vVoronoiSeeds[iThatVoronoiSeedIndex].m_iHexspaceX,thisVoronoiSeed.m_iHexspaceY-vVoronoiSeeds[iThatVoronoiSeedIndex].m_iHexspaceY);

	mov	eax, DWORD PTR _iThatVoronoiSeedIndex$217580[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR _vVoronoiSeeds$[ebp]
	mov	DWORD PTR $T217993[ebp], eax
	mov	ecx, DWORD PTR _iThatVoronoiSeedIndex$217580[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR _vVoronoiSeeds$[ebp]
	mov	DWORD PTR $T217997[ebp], ecx
	mov	edx, DWORD PTR $T217993[ebp]
	mov	eax, DWORD PTR _thisVoronoiSeed$217566[ebp+4]
	sub	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR $T217997[ebp]
	mov	edx, DWORD PTR _thisVoronoiSeed$217566[ebp]
	sub	edx, DWORD PTR [ecx]
	push	edx
	call	?hexDistance@@YAHHH@Z			; hexDistance
	add	esp, 8
	mov	DWORD PTR _iDistanceBetweenVoronoiSeeds$217584[ebp], eax

; 504  : 
; 505  : 				if(iDistanceBetweenVoronoiSeeds < 7)  // ??? parameterize ???

	cmp	DWORD PTR _iDistanceBetweenVoronoiSeeds$217584[ebp], 7
	jge	SHORT $LN17@ridgeBuild

; 506  : 				{
; 507  : 					thisVoronoiSeed.m_iHexspaceX = random.get(m_iFracX, "Ridge Gen 6");

	push	OFFSET ??_C@_0M@OBGMBPNG@Ridge?5Gen?56?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _random$[ebp]
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	edx, ax
	mov	DWORD PTR _thisVoronoiSeed$217566[ebp], edx

; 508  : 					thisVoronoiSeed.m_iHexspaceY = random.get(m_iFracY, "Ridge Gen 7");

	push	OFFSET ??_C@_0M@PIHHCOJH@Ridge?5Gen?57?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR _random$[ebp]
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	edx, ax
	mov	DWORD PTR _thisVoronoiSeed$217566[ebp+4], edx

; 509  : 					bNeedToRecheck = true;

	mov	BYTE PTR _bNeedToRecheck$217576[ebp], 1

; 510  : 					break;

	jmp	SHORT $LN22@ridgeBuild
$LN17@ridgeBuild:

; 511  : 				}
; 512  : 			}

	jmp	$LN19@ridgeBuild
$LN22@ridgeBuild:

; 513  : 
; 514  : 		}
; 515  : 		while(bNeedToRecheck);

	movzx	eax, BYTE PTR _bNeedToRecheck$217576[ebp]
	test	eax, eax
	jne	$LN23@ridgeBuild

; 516  : 
; 517  : 		vVoronoiSeeds.push_back(thisVoronoiSeed);

	lea	ecx, DWORD PTR _thisVoronoiSeed$217566[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vVoronoiSeeds$[ebp]
	call	?push_back@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAEIABUVoronoiSeed@@@Z ; FStaticVector<VoronoiSeed,256,1,297,0>::push_back

; 518  : 	}

	jmp	$LN25@ridgeBuild
$LN24@ridgeBuild:

; 519  : 
; 520  : 	//std::vector<int> vDistances;
; 521  : 	//vDistances.reserve(iNumVoronoiSeeds);
; 522  : 
; 523  : 	for(int iX = 0; iX < m_iFracX; iX++)

	mov	DWORD PTR _iX$217588[ebp], 0
	jmp	SHORT $LN16@ridgeBuild
$LN15@ridgeBuild:
	mov	edx, DWORD PTR _iX$217588[ebp]
	add	edx, 1
	mov	DWORD PTR _iX$217588[ebp], edx
$LN16@ridgeBuild:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iX$217588[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	$LN14@ridgeBuild

; 524  : 	{
; 525  : 		for(int iY = 0; iY < m_iFracY; iY++)

	mov	DWORD PTR _iY$217592[ebp], 0
	jmp	SHORT $LN13@ridgeBuild
$LN12@ridgeBuild:
	mov	edx, DWORD PTR _iY$217592[ebp]
	add	edx, 1
	mov	DWORD PTR _iY$217592[ebp], edx
$LN13@ridgeBuild:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iY$217592[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jge	$LN11@ridgeBuild

; 526  : 		{
; 527  : 			// get the hexspace coordinate for this position
; 528  : 			int iThisHexX = xToHexspaceX(iX,iY);

	cmp	DWORD PTR _iY$217592[ebp], 0
	jl	SHORT $LN80@ridgeBuild
	mov	edx, DWORD PTR _iY$217592[ebp]
	sar	edx, 1
	mov	DWORD PTR tv411[ebp], edx
	jmp	SHORT $LN78@ridgeBuild
$LN80@ridgeBuild:
	mov	eax, DWORD PTR _iY$217592[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv411[ebp], eax
$LN78@ridgeBuild:
	mov	eax, DWORD PTR _iX$217588[ebp]
	sub	eax, DWORD PTR tv411[ebp]
	mov	DWORD PTR _iThisHexX$217596[ebp], eax

; 529  : 			int iThisHexY = iY; // not really needed except for clarity

	mov	ecx, DWORD PTR _iY$217592[ebp]
	mov	DWORD PTR _iThisHexY$217597[ebp], ecx

; 530  : 
; 531  : 			// find the distance to each of the seeds (with modifiers for strength of the seed, directional bias, and random factors)
; 532  : 			//vDistances.clear();
; 533  : 			int iClosestSeed = INT_MAX;

	mov	DWORD PTR _iClosestSeed$217598[ebp], 2147483647 ; 7fffffffH

; 534  : 			int iNextClosestSeed = INT_MAX;

	mov	DWORD PTR _iNextClosestSeed$217599[ebp], 2147483647 ; 7fffffffH

; 535  : 			for(int iThisVoronoiSeedIndex= 0; iThisVoronoiSeedIndex < iNumVoronoiSeeds; iThisVoronoiSeedIndex++)

	mov	DWORD PTR _iThisVoronoiSeedIndex$217600[ebp], 0
	jmp	SHORT $LN10@ridgeBuild
$LN9@ridgeBuild:
	mov	edx, DWORD PTR _iThisVoronoiSeedIndex$217600[ebp]
	add	edx, 1
	mov	DWORD PTR _iThisVoronoiSeedIndex$217600[ebp], edx
$LN10@ridgeBuild:
	mov	eax, DWORD PTR _iThisVoronoiSeedIndex$217600[ebp]
	cmp	eax, DWORD PTR _iNumVoronoiSeeds$[ebp]
	jge	$LN8@ridgeBuild

; 536  : 			{
; 537  : 				int iModifiedHexspaceDistance = hexDistance(iThisHexX-vVoronoiSeeds[iThisVoronoiSeedIndex].m_iHexspaceX,iThisHexY-vVoronoiSeeds[iThisVoronoiSeedIndex].m_iHexspaceY);

	mov	ecx, DWORD PTR _iThisVoronoiSeedIndex$217600[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR _vVoronoiSeeds$[ebp]
	mov	DWORD PTR $T218026[ebp], ecx
	mov	edx, DWORD PTR _iThisVoronoiSeedIndex$217600[ebp]
	imul	edx, 20					; 00000014H
	add	edx, DWORD PTR _vVoronoiSeeds$[ebp]
	mov	DWORD PTR $T218030[ebp], edx
	mov	eax, DWORD PTR $T218026[ebp]
	mov	ecx, DWORD PTR _iThisHexY$217597[ebp]
	sub	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR $T218030[ebp]
	mov	eax, DWORD PTR _iThisHexX$217596[ebp]
	sub	eax, DWORD PTR [edx]
	push	eax
	call	?hexDistance@@YAHHH@Z			; hexDistance
	add	esp, 8
	mov	DWORD PTR _iModifiedHexspaceDistance$217604[ebp], eax

; 538  : 				if(iRidgeFlags)  // we may decide to add more control later

	cmp	DWORD PTR _iRidgeFlags$[ebp], 0
	je	$LN7@ridgeBuild

; 539  : 				{
; 540  : 					iModifiedHexspaceDistance += vVoronoiSeeds[iThisVoronoiSeedIndex].m_iWeakness;

	mov	ecx, DWORD PTR _iThisVoronoiSeedIndex$217600[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _vVoronoiSeeds$[ebp]
	mov	eax, DWORD PTR _iModifiedHexspaceDistance$217604[ebp]
	add	eax, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR _iModifiedHexspaceDistance$217604[ebp], eax

; 541  : #ifdef AUI_FRACTAL_RIDGE_USE_BINOM_RNG
; 542  : 					iModifiedHexspaceDistance += random.getBinom(3, "Ridge Gen 8");
; 543  : #else
; 544  : 					iModifiedHexspaceDistance += random.get(3, "Ridge Gen 8");

	push	OFFSET ??_C@_0M@HPOPDCFI@Ridge?5Gen?58?$AA@
	push	3
	mov	ecx, DWORD PTR _random$[ebp]
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	ecx, ax
	add	ecx, DWORD PTR _iModifiedHexspaceDistance$217604[ebp]
	mov	DWORD PTR _iModifiedHexspaceDistance$217604[ebp], ecx

; 545  : #endif
; 546  : 					DirectionTypes eRelativeDirection = estimateDirection(vVoronoiSeeds[iThisVoronoiSeedIndex].m_iHexspaceX-iThisHexX,vVoronoiSeeds[iThisVoronoiSeedIndex].m_iHexspaceY-iThisHexY);

	mov	edx, DWORD PTR _iThisVoronoiSeedIndex$217600[ebp]
	imul	edx, 20					; 00000014H
	add	edx, DWORD PTR _vVoronoiSeeds$[ebp]
	mov	DWORD PTR $T218048[ebp], edx
	mov	eax, DWORD PTR _iThisVoronoiSeedIndex$217600[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR _vVoronoiSeeds$[ebp]
	mov	DWORD PTR $T218052[ebp], eax
	mov	ecx, DWORD PTR $T218048[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, DWORD PTR _iThisHexY$217597[ebp]
	push	edx
	mov	eax, DWORD PTR $T218052[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR _iThisHexX$217596[ebp]
	push	ecx
	call	?estimateDirection@@YA?AW4DirectionTypes@@HH@Z ; estimateDirection
	add	esp, 8
	mov	DWORD PTR _eRelativeDirection$217607[ebp], eax

; 547  : 					if(eRelativeDirection == vVoronoiSeeds[iThisVoronoiSeedIndex].m_eBiasDirection)

	mov	edx, DWORD PTR _iThisVoronoiSeedIndex$217600[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _vVoronoiSeeds$[ebp]
	mov	ecx, DWORD PTR _eRelativeDirection$217607[ebp]
	cmp	ecx, DWORD PTR [eax+edx+12]
	jne	SHORT $LN110@ridgeBuild

; 548  : 					{
; 549  : 						iModifiedHexspaceDistance -= vVoronoiSeeds[iThisVoronoiSeedIndex].m_iDirectionalBiasStrength;

	mov	edx, DWORD PTR _iThisVoronoiSeedIndex$217600[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _vVoronoiSeeds$[ebp]
	mov	ecx, DWORD PTR _iModifiedHexspaceDistance$217604[ebp]
	sub	ecx, DWORD PTR [eax+edx+16]
	mov	DWORD PTR _iModifiedHexspaceDistance$217604[ebp], ecx
	jmp	SHORT $LN5@ridgeBuild

; 550  : 					}
; 551  : 					else if(eRelativeDirection == (vVoronoiSeeds[iThisVoronoiSeedIndex].m_eBiasDirection + 3) % NUM_DIRECTION_TYPES)

$LN110@ridgeBuild:
	mov	edx, DWORD PTR _iThisVoronoiSeedIndex$217600[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _vVoronoiSeeds$[ebp]
	mov	eax, DWORD PTR [eax+edx+12]
	add	eax, 3
	cdq
	mov	ecx, 6
	idiv	ecx
	cmp	DWORD PTR _eRelativeDirection$217607[ebp], edx
	jne	SHORT $LN5@ridgeBuild

; 552  : 					{
; 553  : 						iModifiedHexspaceDistance += vVoronoiSeeds[iThisVoronoiSeedIndex].m_iDirectionalBiasStrength;

	mov	edx, DWORD PTR _iThisVoronoiSeedIndex$217600[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _vVoronoiSeeds$[ebp]
	mov	ecx, DWORD PTR _iModifiedHexspaceDistance$217604[ebp]
	add	ecx, DWORD PTR [eax+edx+16]
	mov	DWORD PTR _iModifiedHexspaceDistance$217604[ebp], ecx
$LN5@ridgeBuild:

; 554  : 					}
; 555  : #ifdef AUI_FAST_COMP
; 556  : 					iModifiedHexspaceDistance = MAX(1, iModifiedHexspaceDistance);
; 557  : #else
; 558  : 					iModifiedHexspaceDistance = std::max(1,iModifiedHexspaceDistance);

	mov	DWORD PTR $T217941[ebp], 1
	mov	edx, DWORD PTR $T217941[ebp]
	cmp	edx, DWORD PTR _iModifiedHexspaceDistance$217604[ebp]
	jge	SHORT $LN116@ridgeBuild
	lea	eax, DWORD PTR _iModifiedHexspaceDistance$217604[ebp]
	mov	DWORD PTR tv315[ebp], eax
	jmp	SHORT $LN117@ridgeBuild
$LN116@ridgeBuild:
	lea	ecx, DWORD PTR $T217941[ebp]
	mov	DWORD PTR tv315[ebp], ecx
$LN117@ridgeBuild:
	mov	edx, DWORD PTR tv315[ebp]
	mov	DWORD PTR $T218071[ebp], edx
	mov	eax, DWORD PTR $T218071[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iModifiedHexspaceDistance$217604[ebp], ecx
$LN7@ridgeBuild:

; 559  : #endif
; 560  : 				}
; 561  : 				//vDistances.push_back(iModifiedHexspaceDistance);
; 562  : 				if(iModifiedHexspaceDistance < iClosestSeed)

	mov	edx, DWORD PTR _iModifiedHexspaceDistance$217604[ebp]
	cmp	edx, DWORD PTR _iClosestSeed$217598[ebp]
	jge	SHORT $LN3@ridgeBuild

; 563  : 				{
; 564  : 					iNextClosestSeed = iClosestSeed;

	mov	eax, DWORD PTR _iClosestSeed$217598[ebp]
	mov	DWORD PTR _iNextClosestSeed$217599[ebp], eax

; 565  : 					iClosestSeed = iModifiedHexspaceDistance;

	mov	ecx, DWORD PTR _iModifiedHexspaceDistance$217604[ebp]
	mov	DWORD PTR _iClosestSeed$217598[ebp], ecx
	jmp	SHORT $LN2@ridgeBuild
$LN3@ridgeBuild:

; 566  : 				}
; 567  : 				else if(iModifiedHexspaceDistance < iNextClosestSeed)

	mov	edx, DWORD PTR _iModifiedHexspaceDistance$217604[ebp]
	cmp	edx, DWORD PTR _iNextClosestSeed$217599[ebp]
	jge	SHORT $LN2@ridgeBuild

; 568  : 				{
; 569  : 					iNextClosestSeed = iModifiedHexspaceDistance;

	mov	eax, DWORD PTR _iModifiedHexspaceDistance$217604[ebp]
	mov	DWORD PTR _iNextClosestSeed$217599[ebp], eax
$LN2@ridgeBuild:

; 570  : 				}
; 571  : 			}

	jmp	$LN9@ridgeBuild
$LN8@ridgeBuild:

; 572  : 
; 573  : 			// use the modified distance between the two closest seeds to determine the ridge height
; 574  : 			// ??? are there any other fudge factors I want to add in here???
; 575  : 			//std::sort(vDistances.begin(),vDistances.end());
; 576  : 
; 577  : 			int iRidgeHeight = (255 * iClosestSeed) / iNextClosestSeed;

	mov	eax, DWORD PTR _iClosestSeed$217598[ebp]
	imul	eax, 255				; 000000ffH
	cdq
	idiv	DWORD PTR _iNextClosestSeed$217599[ebp]
	mov	DWORD PTR _iRidgeHeight$217615[ebp], eax

; 578  : 
; 579  : 			// blend the new ridge height with the previous fractal height
; 580  : #ifdef AUI_FAST_COMP
; 581  : 			m_aaiFrac[iX][iY] = (iRidgeHeight * iBlendRidge + m_aaiFrac[iX][iY] * iBlendFract) / MAX(iBlendRidge + iBlendFract, 1);
; 582  : #else
; 583  : 			m_aaiFrac[iX][iY] = (iRidgeHeight * iBlendRidge + m_aaiFrac[iX][iY] * iBlendFract) / std::max(iBlendRidge + iBlendFract, 1);

	mov	DWORD PTR $T217942[ebp], 1
	mov	ecx, DWORD PTR _iBlendRidge$[ebp]
	add	ecx, DWORD PTR _iBlendFract$[ebp]
	mov	DWORD PTR $T217943[ebp], ecx
	mov	edx, DWORD PTR $T217943[ebp]
	cmp	edx, DWORD PTR $T217942[ebp]
	jge	SHORT $LN120@ridgeBuild
	lea	eax, DWORD PTR $T217942[ebp]
	mov	DWORD PTR tv322[ebp], eax
	jmp	SHORT $LN121@ridgeBuild
$LN120@ridgeBuild:
	lea	ecx, DWORD PTR $T217943[ebp]
	mov	DWORD PTR tv322[ebp], ecx
$LN121@ridgeBuild:
	mov	edx, DWORD PTR tv322[ebp]
	mov	DWORD PTR $T218080[ebp], edx
	mov	eax, DWORD PTR _iRidgeHeight$217615[ebp]
	imul	eax, DWORD PTR _iBlendRidge$[ebp]
	mov	ecx, DWORD PTR _iX$217588[ebp]
	shl	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+40]
	mov	edx, DWORD PTR _iY$217592[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	imul	ecx, DWORD PTR _iBlendFract$[ebp]
	add	eax, ecx
	mov	ecx, DWORD PTR $T218080[ebp]
	cdq
	idiv	DWORD PTR [ecx]
	mov	edx, DWORD PTR _iX$217588[ebp]
	shl	edx, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+edx+40]
	mov	ecx, DWORD PTR _iY$217592[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 584  : #endif
; 585  : 		}

	jmp	$LN12@ridgeBuild
$LN11@ridgeBuild:

; 586  : 	}

	jmp	$LN15@ridgeBuild
$LN14@ridgeBuild:

; 587  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _vVoronoiSeeds$[ebp]
	call	??1?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<VoronoiSeed,256,1,297,0>::~FStaticVector<VoronoiSeed,256,1,297,0>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z$0:
	lea	ecx, DWORD PTR _vVoronoiSeeds$[ebp]
	jmp	??1?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<VoronoiSeed,256,1,297,0>::~FStaticVector<VoronoiSeed,256,1,297,0>
__ehhandler$?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-5392]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z ENDP	; CvFractal::ridgeBuilder
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?hexDistance@@YAHHH@Z
_TEXT	SEGMENT
tv83 = -36						; size = 4
tv81 = -32						; size = 4
tv78 = -28						; size = 4
tv74 = -24						; size = 4
tv71 = -20						; size = 4
_iAbsDY$216796 = -16					; size = 4
_iAbsDX$216795 = -12					; size = 4
_iAbsDY$216793 = -8					; size = 4
_iAbsDX$216792 = -4					; size = 4
_iDX$ = 8						; size = 4
_iDY$ = 12						; size = 4
?hexDistance@@YAHHH@Z PROC				; hexDistance, COMDAT

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 96   : 	// I'm assuming iDX and iDY are in hex-space
; 97   : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 98   : 	// Delnar: Using abs() because I trust the compiler to generate more efficient code than if I'd write an abs(int) function myself, especially if the CPU has an abs(int) operation
; 99   : 	if ((iDX ^ iDY) >= 0)  // the signs match
; 100  : 	{
; 101  : 		return abs(iDX) + abs(iDY);
; 102  : 	}
; 103  : 	else
; 104  : 	{
; 105  : 		return MAX(abs(iDX), abs(iDY));
; 106  : 	}
; 107  : #else
; 108  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	xor	eax, eax
	cmp	DWORD PTR _iDX$[ebp], 0
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@hexDistanc

; 109  : 	{
; 110  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN5@hexDistanc
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN6@hexDistanc
$LN5@hexDistanc:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv71[ebp], eax
$LN6@hexDistanc:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _iAbsDX$216792[ebp], ecx

; 111  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN7@hexDistanc
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN8@hexDistanc
$LN7@hexDistanc:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv74[ebp], eax
$LN8@hexDistanc:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _iAbsDY$216793[ebp], ecx

; 112  : 		return iAbsDX + iAbsDY;

	mov	eax, DWORD PTR _iAbsDX$216792[ebp]
	add	eax, DWORD PTR _iAbsDY$216793[ebp]
	jmp	SHORT $LN3@hexDistanc

; 113  : 	}
; 114  : 	else

	jmp	SHORT $LN3@hexDistanc
$LN2@hexDistanc:

; 115  : 	{
; 116  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN9@hexDistanc
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv78[ebp], edx
	jmp	SHORT $LN10@hexDistanc
$LN9@hexDistanc:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv78[ebp], eax
$LN10@hexDistanc:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _iAbsDX$216795[ebp], ecx

; 117  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN11@hexDistanc
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv81[ebp], edx
	jmp	SHORT $LN12@hexDistanc
$LN11@hexDistanc:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv81[ebp], eax
$LN12@hexDistanc:
	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _iAbsDY$216796[ebp], ecx

; 118  : 		return iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	mov	edx, DWORD PTR _iAbsDX$216795[ebp]
	cmp	edx, DWORD PTR _iAbsDY$216796[ebp]
	jl	SHORT $LN13@hexDistanc
	mov	eax, DWORD PTR _iAbsDX$216795[ebp]
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN14@hexDistanc
$LN13@hexDistanc:
	mov	ecx, DWORD PTR _iAbsDY$216796[ebp]
	mov	DWORD PTR tv83[ebp], ecx
$LN14@hexDistanc:
	mov	eax, DWORD PTR tv83[ebp]
$LN3@hexDistanc:

; 119  : 	}
; 120  : #endif
; 121  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?hexDistance@@YAHHH@Z ENDP				; hexDistance
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UVoronoiSeed@@$00@@QAE@XZ	; BaseVector<VoronoiSeed,1>::~BaseVector<VoronoiSeed,1>
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T218146 = -20						; size = 4
_pRet$218143 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<VoronoiSeed,256,1,297,0>::FStaticVector<VoronoiSeed,256,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 256			; 00000100H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T218146[ebp], edx
	cmp	DWORD PTR $T218146[ebp], 256		; 00000100H
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T218146[ebp]
	imul	eax, 20					; 00000014H
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$218143[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T218146[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$218143[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 256			; 00000100H
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$218143[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UVoronoiSeed@@$00@@QAE@XZ ; BaseVector<VoronoiSeed,1>::~BaseVector<VoronoiSeed,1>
__ehhandler$??0?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<VoronoiSeed,256,1,297,0>::FStaticVector<VoronoiSeed,256,1,297,0>
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T218177 = -24						; size = 4
$T218176 = -20						; size = 4
_i$218169 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<VoronoiSeed,256,1,297,0>::~FStaticVector<VoronoiSeed,256,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T218177[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T218176[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@2
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@2
	mov	DWORD PTR _i$218169[ebp], 0
	jmp	SHORT $LN10@FStaticVec@2
$LN9@FStaticVec@2:
	mov	eax, DWORD PTR _i$218169[ebp]
	add	eax, 1
	mov	DWORD PTR _i$218169[ebp], eax
$LN10@FStaticVec@2:
	mov	ecx, DWORD PTR _i$218169[ebp]
	cmp	ecx, DWORD PTR $T218177[ebp]
	jae	SHORT $LN5@FStaticVec@2
	jmp	SHORT $LN9@FStaticVec@2
$LN5@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T218176[ebp], edx
	je	SHORT $LN1@FStaticVec@2
	mov	eax, DWORD PTR $T218176[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@2:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UVoronoiSeed@@$00@@QAE@XZ ; BaseVector<VoronoiSeed,1>::~BaseVector<VoronoiSeed,1>
__ehhandler$??1?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<VoronoiSeed,256,1,297,0>::~FStaticVector<VoronoiSeed,256,1,297,0>
PUBLIC	?GrowSize@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<VoronoiSeed,256,1,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAEIABUVoronoiSeed@@@Z
_TEXT	SEGMENT
tv141 = -52						; size = 4
tv132 = -48						; size = 4
_this$ = -44						; size = 4
$T218189 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAEIABUVoronoiSeed@@@Z PROC ; FStaticVector<VoronoiSeed,256,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+5132], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<VoronoiSeed,256,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T218189[ebp], ecx
	je	SHORT $LN4@push_back
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR $T218189[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T218189[ebp]
	mov	DWORD PTR tv132[ebp], ecx
	jmp	SHORT $LN5@push_back
$LN4@push_back:
	mov	DWORD PTR tv132[ebp], 0
$LN5@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv141[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR tv141[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAEIABUVoronoiSeed@@@Z ENDP ; FStaticVector<VoronoiSeed,256,1,297,0>::push_back
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT ?GrowSize@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv179 = -44						; size = 4
_this$ = -40						; size = 4
$T218267 = -36						; size = 4
$T218266 = -32						; size = 4
_i$218259 = -28						; size = 4
$T218242 = -24						; size = 4
_pRet$218239 = -20					; size = 4
$T218233 = -16						; size = 4
_i$217646 = -12						; size = 4
_uiNewSize$217638 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<VoronoiSeed,256,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$217638[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$217638[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$217638[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T218242[ebp], ecx
	cmp	DWORD PTR $T218242[ebp], 256		; 00000100H
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T218242[ebp]
	imul	edx, 20					; 00000014H
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$218239[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T218242[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize
$LN15@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$218239[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 256			; 00000100H
$LN16@GrowSize:
	mov	ecx, DWORD PTR _pRet$218239[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$217646[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$217646[ebp]
	add	edx, 1
	mov	DWORD PTR _i$217646[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$217646[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$217646[ebp]
	imul	edx, 20					; 00000014H
	add	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR $T218233[ebp], edx
	je	SHORT $LN12@GrowSize
	mov	eax, DWORD PTR _i$217646[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR $T218233[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR $T218233[ebp]
	mov	DWORD PTR tv179[ebp], eax
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv179[ebp], 0
$LN13@GrowSize:
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T218267[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T218266[ebp], ecx
	xor	edx, edx
	je	SHORT $LN21@GrowSize
	xor	eax, eax
	je	SHORT $LN21@GrowSize
	mov	DWORD PTR _i$218259[ebp], 0
	jmp	SHORT $LN26@GrowSize
$LN25@GrowSize:
	mov	ecx, DWORD PTR _i$218259[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$218259[ebp], ecx
$LN26@GrowSize:
	mov	edx, DWORD PTR _i$218259[ebp]
	cmp	edx, DWORD PTR $T218267[ebp]
	jae	SHORT $LN21@GrowSize
	jmp	SHORT $LN25@GrowSize
$LN21@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	cmp	DWORD PTR $T218266[ebp], eax
	je	SHORT $LN22@GrowSize
	mov	ecx, DWORD PTR $T218266[ebp]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], eax

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+5132], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<VoronoiSeed,256,1,297,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSizeToFit@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv151 = -40						; size = 4
_this$ = -36						; size = 4
$T218305 = -32						; size = 4
$T218304 = -28						; size = 4
_i$218297 = -24						; size = 4
$T218280 = -20						; size = 4
_pRet$218277 = -16					; size = 4
$T218271 = -12						; size = 4
_i$217662 = -8						; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSizeToFit@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<VoronoiSeed,256,1,297,0>::GrowSizeToFit, COMDAT
; _this$ = ecx

; 776  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 777  : 		if( uiFit <= m_uiCurrMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiFit$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	ja	SHORT $LN6@GrowSizeTo

; 778  : 			return;

	jmp	$LN7@GrowSizeTo
$LN6@GrowSizeTo:

; 779  : 
; 780  : 		m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 781  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T218280[ebp], edx
	cmp	DWORD PTR $T218280[ebp], 256		; 00000100H
	jbe	SHORT $LN12@GrowSizeTo
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T218280[ebp]
	imul	eax, 20					; 00000014H
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$218277[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T218280[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN13@GrowSizeTo
$LN12@GrowSizeTo:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$218277[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 256			; 00000100H
$LN13@GrowSizeTo:
	mov	edx, DWORD PTR _pRet$218277[ebp]
	mov	DWORD PTR _pTemp$[ebp], edx

; 782  : 		if( bPODType ){

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@GrowSizeTo

; 783  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 20					; 00000014H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pTemp$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 784  : 		}else{

	jmp	SHORT $LN4@GrowSizeTo
$LN5@GrowSizeTo:

; 785  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$217662[ebp], 0
	jmp	SHORT $LN3@GrowSizeTo
$LN2@GrowSizeTo:
	mov	eax, DWORD PTR _i$217662[ebp]
	add	eax, 1
	mov	DWORD PTR _i$217662[ebp], eax
$LN3@GrowSizeTo:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$217662[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN4@GrowSizeTo

; 786  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	eax, DWORD PTR _i$217662[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR $T218271[ebp], eax
	je	SHORT $LN9@GrowSizeTo
	mov	ecx, DWORD PTR _i$217662[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR $T218271[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T218271[ebp]
	mov	DWORD PTR tv151[ebp], ecx
	jmp	SHORT $LN10@GrowSizeTo
$LN9@GrowSizeTo:
	mov	DWORD PTR tv151[ebp], 0
$LN10@GrowSizeTo:
	jmp	SHORT $LN2@GrowSizeTo
$LN4@GrowSizeTo:

; 787  : 		}
; 788  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T218305[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T218304[ebp], edx
	xor	eax, eax
	je	SHORT $LN18@GrowSizeTo
	xor	ecx, ecx
	je	SHORT $LN18@GrowSizeTo
	mov	DWORD PTR _i$218297[ebp], 0
	jmp	SHORT $LN23@GrowSizeTo
$LN22@GrowSizeTo:
	mov	edx, DWORD PTR _i$218297[ebp]
	add	edx, 1
	mov	DWORD PTR _i$218297[ebp], edx
$LN23@GrowSizeTo:
	mov	eax, DWORD PTR _i$218297[ebp]
	cmp	eax, DWORD PTR $T218305[ebp]
	jae	SHORT $LN18@GrowSizeTo
	jmp	SHORT $LN22@GrowSizeTo
$LN18@GrowSizeTo:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T218304[ebp], ecx
	je	SHORT $LN19@GrowSizeTo
	mov	edx, DWORD PTR $T218304[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN19@GrowSizeTo:

; 789  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 790  : 
; 791  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+5132], 1
$LN7@GrowSizeTo:

; 792  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSizeToFit@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<VoronoiSeed,256,1,297,0>::GrowSizeToFit
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UVoronoiSeed@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UVoronoiSeed@@$00@@QAE@XZ PROC		; BaseVector<VoronoiSeed,1>::~BaseVector<VoronoiSeed,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UVoronoiSeed@@$00@@QAE@XZ ENDP		; BaseVector<VoronoiSeed,1>::~BaseVector<VoronoiSeed,1>
_TEXT	ENDS
END
