; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvPlayerAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
PUBLIC	?m_aPlayers@CvPlayerAI@@1PAV1@A			; CvPlayerAI::m_aPlayers
_BSS	SEGMENT
?m_aPlayers@CvPlayerAI@@1PAV1@A DD 01H DUP (?)		; CvPlayerAI::m_aPlayers
_BSS	ENDS
CONST	SEGMENT
$SG226239 DB	'PlayerPreAIUnitUpdate', 00H
	ORG $+2
$SG226304 DB	'UNIT_ENGINEER', 00H
	ORG $+2
$SG226309 DB	'AIGRANDSTRATEGY_CONQUEST', 00H
	ORG $+3
$SG226311 DB	'UNIT_GREAT_GENERAL', 00H
	ORG $+1
$SG226315 DB	'AIGRANDSTRATEGY_CULTURE', 00H
$SG226317 DB	'UNIT_ARTIST', 00H
$SG226321 DB	'AIGRANDSTRATEGY_UNITED_NATIONS', 00H
	ORG $+1
$SG226323 DB	'UNIT_MERCHANT', 00H
	ORG $+2
$SG226327 DB	'AIGRANDSTRATEGY_SPACESHIP', 00H
	ORG $+2
$SG226329 DB	'UNIT_SCIENTIST', 00H
	ORG $+1
$SG227049 DB	'SPECIALUNIT_PEOPLE', 00H
	ORG $+1
$SG227079 DB	'MILITARYAISTRATEGY_WAR_MOBILIZATION', 00H
$SG227091 DB	'MILITARYAISTRATEGY_AT_WAR', 00H
	ORG $+2
$SG227172 DB	'SPECIALUNIT_PEOPLE', 00H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	?AI_init@CvPlayerAI@@UAEXXZ			; CvPlayerAI::AI_init
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
;	COMDAT ?AI_init@CvPlayerAI@@UAEXXZ
_TEXT	SEGMENT
?AI_init@CvPlayerAI@@UAEXXZ PROC			; CvPlayerAI::AI_init, COMDAT
; _this$ = ecx

; 72   : 	AI_reset();

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	jmp	edx
?AI_init@CvPlayerAI@@UAEXXZ ENDP			; CvPlayerAI::AI_init
_TEXT	ENDS
PUBLIC	?AI_uninit@CvPlayerAI@@QAEXXZ			; CvPlayerAI::AI_uninit
; Function compile flags: /Ogtpy
;	COMDAT ?AI_uninit@CvPlayerAI@@QAEXXZ
_TEXT	SEGMENT
?AI_uninit@CvPlayerAI@@QAEXXZ PROC			; CvPlayerAI::AI_uninit, COMDAT
; _this$ = ecx

; 78   : }

	ret	0
?AI_uninit@CvPlayerAI@@QAEXXZ ENDP			; CvPlayerAI::AI_uninit
_TEXT	ENDS
PUBLIC	?AI_reset@CvPlayerAI@@UAEXXZ			; CvPlayerAI::AI_reset
; Function compile flags: /Ogtpy
;	COMDAT ?AI_reset@CvPlayerAI@@UAEXXZ
_TEXT	SEGMENT
?AI_reset@CvPlayerAI@@UAEXXZ PROC			; CvPlayerAI::AI_reset, COMDAT
; _this$ = ecx

; 83   : 	AI_uninit();
; 84   : }

	ret	0
?AI_reset@CvPlayerAI@@UAEXXZ ENDP			; CvPlayerAI::AI_reset
_TEXT	ENDS
PUBLIC	?AI_doTurnUnitsPre@CvPlayerAI@@UAEXXZ		; CvPlayerAI::AI_doTurnUnitsPre
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?InitializeQueuedAttacks@CvTacticalAI@@QAEXXZ:PROC ; CvTacticalAI::InitializeQueuedAttacks
EXTRN	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ:PROC ; CvPlayer::GetTacticalAI
; Function compile flags: /Ogtpy
;	COMDAT ?AI_doTurnUnitsPre@CvPlayerAI@@UAEXXZ
_TEXT	SEGMENT
?AI_doTurnUnitsPre@CvPlayerAI@@UAEXXZ PROC		; CvPlayerAI::AI_doTurnUnitsPre, COMDAT
; _this$ = ecx

; 139  : {

	push	esi
	mov	esi, ecx

; 140  : 	GetTacticalAI()->InitializeQueuedAttacks();

	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?InitializeQueuedAttacks@CvTacticalAI@@QAEXXZ ; CvTacticalAI::InitializeQueuedAttacks

; 141  : 
; 142  : 	if(isHuman())

	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN1@AI_doTurnU

; 143  : 	{
; 144  : 		return;
; 145  : 	}
; 146  : 
; 147  : 	if(isBarbarian())

	mov	ecx, esi
	pop	esi
	jmp	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
$LN1@AI_doTurnU:
	pop	esi

; 148  : 	{
; 149  : 		return;
; 150  : 	}
; 151  : }

	ret	0
?AI_doTurnUnitsPre@CvPlayerAI@@UAEXXZ ENDP		; CvPlayerAI::AI_doTurnUnitsPre
_TEXT	ENDS
PUBLIC	?AI_doTurnUnitsPost@CvPlayerAI@@UAEXXZ		; CvPlayerAI::AI_doTurnUnitsPost
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?AI_promote@CvUnit@@QAEXXZ:PROC			; CvUnit::AI_promote
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
; Function compile flags: /Ogtpy
;	COMDAT ?AI_doTurnUnitsPost@CvPlayerAI@@UAEXXZ
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
?AI_doTurnUnitsPost@CvPlayerAI@@UAEXXZ PROC		; CvPlayerAI::AI_doTurnUnitsPost, COMDAT
; _this$ = ecx

; 155  : {

	push	ecx
	push	esi
	mov	esi, ecx

; 156  : 	CvUnit* pLoopUnit;
; 157  : 	int iLoop;
; 158  : 
; 159  : 	if(!isHuman())

	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN1@AI_doTurnU@2

; 160  : 	{
; 161  : 		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[esp+12]
	push	eax
	mov	ecx, esi
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	test	eax, eax
	je	SHORT $LN1@AI_doTurnU@2
	npad	1
$LL3@AI_doTurnU@2:

; 162  : 		{
; 163  : 			pLoopUnit->AI_promote();

	mov	ecx, eax
	call	?AI_promote@CvUnit@@QAEXXZ		; CvUnit::AI_promote
	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+12]
	push	ecx
	mov	ecx, esi
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	test	eax, eax
	jne	SHORT $LL3@AI_doTurnU@2
$LN1@AI_doTurnU@2:
	pop	esi

; 164  : 		}
; 165  : 	}
; 166  : }

	pop	ecx
	ret	0
?AI_doTurnUnitsPost@CvPlayerAI@@UAEXXZ ENDP		; CvPlayerAI::AI_doTurnUnitsPost
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??RCityAndProductionEval@@QBE_NABUCityAndProduction@@0@Z ; CityAndProductionEval::operator()
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
;	COMDAT ??RCityAndProductionEval@@QBE_NABUCityAndProduction@@0@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??RCityAndProductionEval@@QBE_NABUCityAndProduction@@0@Z PROC ; CityAndProductionEval::operator(), COMDAT
; _this$ = ecx

; 549  : 		return (a.iProduction > b.iProduction);

	mov	eax, DWORD PTR _a$[esp-4]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _b$[esp-4]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx+4]
	setg	al

; 550  : 	}

	ret	8
??RCityAndProductionEval@@QBE_NABUCityAndProduction@@0@Z ENDP ; CityAndProductionEval::operator()
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?AI_doResearch@CvPlayerAI@@IAEXXZ		; CvPlayerAI::AI_doResearch
EXTRN	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ:PROC ; CvPlayerTechs::GetCurrentResearch
EXTRN	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ:PROC ; CvPlayer::GetPlayerTechs
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
;	COMDAT ?AI_doResearch@CvPlayerAI@@IAEXXZ
_TEXT	SEGMENT
?AI_doResearch@CvPlayerAI@@IAEXXZ PROC			; CvPlayerAI::AI_doResearch, COMDAT
; _this$ = ecx

; 691  : {

	push	esi
	mov	esi, ecx

; 692  : 	CvAssertMsg(!isHuman(), "isHuman did not return false as expected");
; 693  : 
; 694  : 	if(GetPlayerTechs()->GetCurrentResearch() == NO_TECH)

	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
	cmp	eax, -1
	jne	SHORT $LN1@AI_doResea

; 695  : 	{
; 696  : 		AI_chooseResearch();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+60]
	mov	ecx, esi
	pop	esi
	jmp	edx
$LN1@AI_doResea:
	pop	esi

; 697  : 		//AI_forceUpdateStrategies(); //to account for current research.
; 698  : 	}
; 699  : }

	ret	0
?AI_doResearch@CvPlayerAI@@IAEXXZ ENDP			; CvPlayerAI::AI_doResearch
_TEXT	ENDS
PUBLIC	?CityUncommitToBuildUnitForOperationSlot@CvPlayerAI@@UAEXUOperationSlot@@@Z ; CvPlayerAI::CityUncommitToBuildUnitForOperationSlot
EXTRN	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z:PROC ; CvPlayer::getAIOperation
; Function compile flags: /Ogtpy
;	COMDAT ?CityUncommitToBuildUnitForOperationSlot@CvPlayerAI@@UAEXUOperationSlot@@@Z
_TEXT	SEGMENT
_thisSlot$ = 8						; size = 12
?CityUncommitToBuildUnitForOperationSlot@CvPlayerAI@@UAEXUOperationSlot@@@Z PROC ; CvPlayerAI::CityUncommitToBuildUnitForOperationSlot, COMDAT
; _this$ = ecx

; 795  : 	// find this operation
; 796  : 	CvAIOperation* pThisOperation = getAIOperation(thisSlot.m_iOperationID);

	mov	eax, DWORD PTR _thisSlot$[esp-4]
	push	esi
	push	eax
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation

; 797  : 	if(pThisOperation)

	test	eax, eax
	je	SHORT $LN1@CityUncomm

; 798  : 	{
; 799  : 		pThisOperation->UncommitToBuild(thisSlot);

	mov	ecx, DWORD PTR _thisSlot$[esp]
	mov	esi, DWORD PTR [eax]
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR _thisSlot$[esp+16]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _thisSlot$[esp+20]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR [esi+104]
	mov	ecx, eax
	call	edx
$LN1@CityUncomm:

; 800  : 	}
; 801  : }

	pop	esi
	ret	12					; 0000000cH
?CityUncommitToBuildUnitForOperationSlot@CvPlayerAI@@UAEXUOperationSlot@@@Z ENDP ; CvPlayerAI::CityUncommitToBuildUnitForOperationSlot
_TEXT	ENDS
PUBLIC	?PreparingForWar@@YA_NPAVCvPlayerAI@@@Z		; PreparingForWar
EXTRN	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z:PROC ; CvMilitaryAI::IsUsingStrategy
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ:PROC ; CvPlayer::GetMilitaryAI
; Function compile flags: /Ogtpy
;	COMDAT ?PreparingForWar@@YA_NPAVCvPlayerAI@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?PreparingForWar@@YA_NPAVCvPlayerAI@@@Z PROC		; PreparingForWar, COMDAT

; 891  : 	CvAssertMsg(pPlayer, "Need a player");
; 892  : 	if(!pPlayer)

	mov	ecx, DWORD PTR _pPlayer$[esp-4]
	test	ecx, ecx
	jne	SHORT $LN3@PreparingF

; 893  : 	{
; 894  : 		return false;

	xor	al, al

; 905  : 	{
; 906  : 		return true;
; 907  : 	}
; 908  : 
; 909  : 	return false;
; 910  : }

	ret	0
$LN3@PreparingF:
	push	esi

; 895  : 	}
; 896  : 	CvMilitaryAI* pMilitaryAI = pPlayer->GetMilitaryAI();

	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	esi, eax

; 897  : 	CvAssertMsg(pMilitaryAI, "No military AI");
; 898  : 	if(!pMilitaryAI)

	test	esi, esi
	jne	SHORT $LN2@PreparingF

; 899  : 	{
; 900  : 		return false;

	xor	al, al
	pop	esi

; 905  : 	{
; 906  : 		return true;
; 907  : 	}
; 908  : 
; 909  : 	return false;
; 910  : }

	ret	0
$LN2@PreparingF:

; 901  : 	}
; 902  : 
; 903  : 	MilitaryAIStrategyTypes eWarMobilizationStrategy = (MilitaryAIStrategyTypes)GC.getInfoTypeForString("MILITARYAISTRATEGY_WAR_MOBILIZATION");

	push	0
	push	OFFSET $SG227079
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 904  : 	if(pMilitaryAI->IsUsingStrategy(eWarMobilizationStrategy))

	push	eax
	mov	ecx, esi
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	test	al, al
	setne	al
	pop	esi

; 905  : 	{
; 906  : 		return true;
; 907  : 	}
; 908  : 
; 909  : 	return false;
; 910  : }

	ret	0
?PreparingForWar@@YA_NPAVCvPlayerAI@@@Z ENDP		; PreparingForWar
_TEXT	ENDS
PUBLIC	?IsSafe@@YA_NPAVCvPlayerAI@@@Z			; IsSafe
EXTRN	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ:PROC ; CvDiplomacyAI::GetStateAllWars
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
; Function compile flags: /Ogtpy
;	COMDAT ?IsSafe@@YA_NPAVCvPlayerAI@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsSafe@@YA_NPAVCvPlayerAI@@@Z PROC			; IsSafe, COMDAT

; 913  : {

	push	esi

; 914  : 	CvAssertMsg(pPlayer, "Need a player");
; 915  : 	if(!pPlayer)

	mov	esi, DWORD PTR _pPlayer$[esp]
	test	esi, esi
	jne	SHORT $LN5@IsSafe
$LN8@IsSafe:

; 916  : 	{
; 917  : 		return false;

	xor	al, al
	pop	esi

; 935  : 		{
; 936  : 			return true;
; 937  : 		}
; 938  : 
; 939  : 		return false;
; 940  : 	}
; 941  : }

	ret	0
$LN5@IsSafe:

; 918  : 	}
; 919  : 
; 920  : 	if(pPlayer->GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_WINNING)

	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 1
	jne	SHORT $LN4@IsSafe

; 921  : 	{
; 922  : 		return true;

	mov	al, al
	pop	esi

; 935  : 		{
; 936  : 			return true;
; 937  : 		}
; 938  : 
; 939  : 		return false;
; 940  : 	}
; 941  : }

	ret	0
$LN4@IsSafe:

; 923  : 	}
; 924  : 	else
; 925  : 	{
; 926  : 		CvMilitaryAI* pMilitaryAI = pPlayer->GetMilitaryAI();

	mov	ecx, esi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	esi, eax

; 927  : 		CvAssertMsg(pMilitaryAI, "No military AI");
; 928  : 		if(!pMilitaryAI)

	test	esi, esi

; 929  : 		{
; 930  : 			return false;

	je	SHORT $LN8@IsSafe

; 931  : 		}
; 932  : 
; 933  : 		MilitaryAIStrategyTypes eAtWarStrategy = (MilitaryAIStrategyTypes)GC.getInfoTypeForString("MILITARYAISTRATEGY_AT_WAR");

	push	0
	push	OFFSET $SG227091
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 934  : 		if(!pMilitaryAI->IsUsingStrategy(eAtWarStrategy))

	push	eax
	mov	ecx, esi
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	test	al, al
	sete	al
	pop	esi

; 935  : 		{
; 936  : 			return true;
; 937  : 		}
; 938  : 
; 939  : 		return false;
; 940  : 	}
; 941  : }

	ret	0
?IsSafe@@YA_NPAVCvPlayerAI@@@Z ENDP			; IsSafe
_TEXT	ENDS
PUBLIC	?GetDirectiveWriter@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveWriter
EXTRN	?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z:PROC ; CvEconomicAI::GetBestGreatWorkCity
EXTRN	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ:PROC ; CvPlayer::GetEconomicAI
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	?GetGreatWork@CvUnit@@QBE?AW4GreatWorkType@@XZ:PROC ; CvUnit::GetGreatWork
EXTRN	?CanGetAdvancedTenet@CvPlayerPolicies@@QBE_NXZ:PROC ; CvPlayerPolicies::CanGetAdvancedTenet
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
EXTRN	?GetPublicOpinionUnhappiness@CvPlayerCulture@@QBEHXZ:PROC ; CvPlayerCulture::GetPublicOpinionUnhappiness
EXTRN	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ:PROC ; CvPlayer::GetCulture
EXTRN	?IsGoingForCultureVictory@CvDiplomacyAI@@QAE_NXZ:PROC ; CvDiplomacyAI::IsGoingForCultureVictory
; Function compile flags: /Ogtpy
;	COMDAT ?GetDirectiveWriter@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_pGreatWriter$ = 8					; size = 4
?GetDirectiveWriter@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z PROC ; CvPlayerAI::GetDirectiveWriter, COMDAT
; _this$ = ecx

; 944  : {

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 945  : 	GreatPeopleDirectiveTypes eDirective = NO_GREAT_PEOPLE_DIRECTIVE_TYPE;

	or	esi, -1

; 946  : 
; 947  : 	// Defend against ideology pressure if not going for culture win
; 948  : #ifdef AUI_WARNING_FIXES
; 949  : 	if (!GetDiplomacyAI()->IsGoingForCultureVictory() && GetCulture()->GetPublicOpinionUnhappiness() > 10)
; 950  : #else
; 951  : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && !GetDiplomacyAI()->IsGoingForCultureVictory() && GetCulture()->GetPublicOpinionUnhappiness() > 10)

	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForCultureVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForCultureVictory
	test	al, al
	jne	SHORT $LN7@GetDirecti
	mov	ecx, edi
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetPublicOpinionUnhappiness@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetPublicOpinionUnhappiness
	cmp	eax, 10					; 0000000aH

; 952  : #endif
; 953  : 	{
; 954  : 		eDirective = GREAT_PEOPLE_DIRECTIVE_CULTURE_BLAST;
; 955  : 	}
; 956  : 
; 957  : 	// If not going for culture win and a Level 2 or 3 Tenet is available, try to snag it
; 958  : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && !GetDiplomacyAI()->IsGoingForCultureVictory() && GetPlayerPolicies()->CanGetAdvancedTenet())

	jg	SHORT $LN8@GetDirecti
$LN7@GetDirecti:
	mov	ecx, edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForCultureVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForCultureVictory
	test	al, al
	jne	SHORT $LN3@GetDirecti
	mov	ecx, edi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?CanGetAdvancedTenet@CvPlayerPolicies@@QBE_NXZ ; CvPlayerPolicies::CanGetAdvancedTenet
	test	al, al
	je	SHORT $LN3@GetDirecti
$LN8@GetDirecti:

; 959  : 	{
; 960  : 		eDirective = GREAT_PEOPLE_DIRECTIVE_CULTURE_BLAST;

	mov	esi, 4
$LN3@GetDirecti:

; 961  : 	}
; 962  : 
; 963  : 	// Create Great Work if there is a slot
; 964  : 	GreatWorkType eGreatWork = pGreatWriter->GetGreatWork();

	mov	ebx, DWORD PTR _pGreatWriter$[esp+8]
	mov	ecx, ebx
	call	?GetGreatWork@CvUnit@@QBE?AW4GreatWorkType@@XZ ; CvUnit::GetGreatWork

; 965  : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && GetEconomicAI()->GetBestGreatWorkCity(pGreatWriter->plot(), eGreatWork))

	cmp	esi, -1
	jne	SHORT $LN2@GetDirecti
	push	eax
	mov	ecx, ebx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, edi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z ; CvEconomicAI::GetBestGreatWorkCity
	test	eax, eax

; 966  : 	{
; 967  : 		eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;

	lea	eax, DWORD PTR [esi+2]
	jne	SHORT $LN1@GetDirecti
$LN2@GetDirecti:

; 968  : 	}
; 969  : 	else
; 970  : 	{
; 971  : 		eDirective = GREAT_PEOPLE_DIRECTIVE_CULTURE_BLAST;

	mov	eax, 4
$LN1@GetDirecti:
	pop	edi
	pop	esi
	pop	ebx

; 972  : 	}
; 973  : 
; 974  : 	return eDirective;
; 975  : }

	ret	4
?GetDirectiveWriter@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ENDP ; CvPlayerAI::GetDirectiveWriter
_TEXT	ENDS
PUBLIC	?GetDirectiveAdmiral@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveAdmiral
; Function compile flags: /Ogtpy
;	COMDAT ?GetDirectiveAdmiral@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?GetDirectiveAdmiral@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z PROC ; CvPlayerAI::GetDirectiveAdmiral, COMDAT
; _this$ = ecx

; 1264 : 	GreatPeopleDirectiveTypes eDirective = NO_GREAT_PEOPLE_DIRECTIVE_TYPE;
; 1265 : 
; 1266 : 	return eDirective;

	or	eax, -1

; 1267 : }

	ret	4
?GetDirectiveAdmiral@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ENDP ; CvPlayerAI::GetDirectiveAdmiral
_TEXT	ENDS
PUBLIC	??A?$BaseVector@H$00@@QAEAAHI@Z			; BaseVector<int,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@H$00@@QAEAAHI@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@H$00@@QAEAAHI@Z PROC			; BaseVector<int,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@H$00@@QAEAAHI@Z ENDP			; BaseVector<int,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@H$00@@QBEIXZ			; BaseVector<int,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@H$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@H$00@@QBEIXZ PROC			; BaseVector<int,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@H$00@@QBEIXZ ENDP			; BaseVector<int,1>::size
_TEXT	ENDS
PUBLIC	?size@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEIXZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEIXZ PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 3

; 727  : 		}

	ret	0
?size@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEIXZ ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAUCityAndProduction@@I@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAUCityAndProduction@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAUCityAndProduction@@I@Z PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 786  : 		}

	ret	4
??A?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAUCityAndProduction@@I@Z ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::operator[]
_TEXT	ENDS
PUBLIC	?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget, COMDAT
; _this$ = ecx

; 52   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 53   : 		m_targets.insert(&target);
; 54   : #endif
; 55   : 	}

	ret	4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
_TEXT	ENDS
PUBLIC	?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
; Function compile flags: /Ogtpy
;	COMDAT ?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget, COMDAT
; _this$ = ecx

; 63   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 64   : 		m_targets.erase(&target);
; 65   : #endif
; 66   : 	}

	ret	4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 217  : 			{	// construct with null node pointer

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 218  : 			}

	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEIXZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEIXZ PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 3

; 636  : 		}

	ret	0
?capacity@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEIXZ ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@UCityAndProduction@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CityAndProduction> >::~_Container_base_aux_alloc_empty<std::allocator<CityAndProduction> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@UCityAndProduction@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@UCityAndProduction@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CityAndProduction> >::~_Container_base_aux_alloc_empty<std::allocator<CityAndProduction> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@UCityAndProduction@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CityAndProduction> >::~_Container_base_aux_alloc_empty<std::allocator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UCityAndProduction@@@std@@QAE@XZ	; std::allocator<CityAndProduction>::allocator<CityAndProduction>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UCityAndProduction@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UCityAndProduction@@@std@@QAE@XZ PROC	; std::allocator<CityAndProduction>::allocator<CityAndProduction>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@UCityAndProduction@@@std@@QAE@XZ ENDP	; std::allocator<CityAndProduction>::allocator<CityAndProduction>
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Left
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Left, COMDAT

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Left
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 244  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 245  : 			}

	ret	4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T230046 = -80						; size = 28
$T230045 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T230046[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T230045[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T230046[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T230045[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T230045[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T230045[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T230045[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T230046[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T230045[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@UCityAndProduction@@@std@@@std@@IAE@V?$allocator@UCityAndProduction@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CityAndProduction> >::_Container_base_aux_alloc_empty<std::allocator<CityAndProduction> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@UCityAndProduction@@@std@@@std@@IAE@V?$allocator@UCityAndProduction@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@UCityAndProduction@@@std@@@std@@IAE@V?$allocator@UCityAndProduction@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CityAndProduction> >::_Container_base_aux_alloc_empty<std::allocator<CityAndProduction> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@UCityAndProduction@@@std@@@std@@IAE@V?$allocator@UCityAndProduction@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CityAndProduction> >::_Container_base_aux_alloc_empty<std::allocator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UCityAndProduction@@@std@@QAE@ABV01@@Z ; std::allocator<CityAndProduction>::allocator<CityAndProduction>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UCityAndProduction@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UCityAndProduction@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CityAndProduction>::allocator<CityAndProduction>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@UCityAndProduction@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CityAndProduction>::allocator<CityAndProduction>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UCityAndProduction@@@std@@QAEXPAUCityAndProduction@@I@Z ; std::allocator<CityAndProduction>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@UCityAndProduction@@@std@@QAEXPAUCityAndProduction@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UCityAndProduction@@@std@@QAEXPAUCityAndProduction@@I@Z PROC ; std::allocator<CityAndProduction>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@UCityAndProduction@@@std@@QAEXPAUCityAndProduction@@I@Z ENDP ; std::allocator<CityAndProduction>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@PAUCityAndProduction@@@Z ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@PAUCityAndProduction@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@PAUCityAndProduction@@@Z PROC ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@PAUCityAndProduction@@@Z ENDP ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator-
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Isnil
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Isnil, COMDAT

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 21					; 00000015H

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Parent
; Function compile flags: /Ogtpy
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Parent, COMDAT

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Right
; Function compile flags: /Ogtpy
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Right, COMDAT

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVCvAIOperation@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Myval
; Function compile flags: /Ogtpy
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVCvAIOperation@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVCvAIOperation@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Myval, COMDAT

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVCvAIOperation@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Min
; Function compile flags: /Ogtpy
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Min, COMDAT

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN1@Min
	npad	4
$LL2@Min:

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL2@Min
$LN1@Min:

; 1315 : 		return (_Pnode);
; 1316 : 		}

	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Min
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UCityAndProduction@@@std@@QBEIXZ ; std::allocator<CityAndProduction>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@UCityAndProduction@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UCityAndProduction@@@std@@QBEIXZ PROC ; std::allocator<CityAndProduction>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@UCityAndProduction@@@std@@QBEIXZ ENDP ; std::allocator<CityAndProduction>::max_size
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator+=
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@VCvPlayerAI@@@@YAXAAPAVCvPlayerAI@@@Z ; SAFE_DELETE_ARRAY<CvPlayerAI>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@VCvPlayerAI@@@@YAXAAPAVCvPlayerAI@@@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@VCvPlayerAI@@@@YAXAAPAVCvPlayerAI@@@Z PROC ; SAFE_DELETE_ARRAY<CvPlayerAI>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN7@SAFE_DELET
	cmp	DWORD PTR [ecx-4], 0
	lea	eax, DWORD PTR [ecx-4]
	je	SHORT $LN3@SAFE_DELET
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	3
	call	edx

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
$LN3@SAFE_DELET:

; 312  : 	delete[] pkInstanceArray;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN7@SAFE_DELET:

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@VCvPlayerAI@@@@YAXAAPAVCvPlayerAI@@@Z ENDP ; SAFE_DELETE_ARRAY<CvPlayerAI>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@UCityAndProduction@@@std@@YAPAUCityAndProduction@@IPAU1@@Z ; std::_Allocate<CityAndProduction>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@UCityAndProduction@@@std@@YAPAUCityAndProduction@@IPAU1@@Z
_TEXT	SEGMENT
$T230138 = -12						; size = 12
$T230142 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UCityAndProduction@@@std@@YAPAUCityAndProduction@@IPAU1@@Z PROC ; std::_Allocate<CityAndProduction>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 8
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T230142[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T230138[esp+16]
	mov	DWORD PTR $T230142[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T230138[esp+16]
	push	ecx
	mov	DWORD PTR $T230138[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@UCityAndProduction@@@std@@YAPAUCityAndProduction@@IPAU1@@Z ENDP ; std::_Allocate<CityAndProduction>
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator==
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator==
_TEXT	ENDS
PUBLIC	??$_Dist_type@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z ; std::_Dist_type<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Dist_type@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z PROC ; std::_Dist_type<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z ENDP ; std::_Dist_type<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
_TEXT	ENDS
PUBLIC	??$_Val_type@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YAPAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z ; std::_Val_type<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YAPAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YAPAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z PROC ; std::_Val_type<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YAPAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z ENDP ; std::_Val_type<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUCityAndProduction@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCityAndProduction@@0@Z ; std::_Ptr_cat<CityAndProduction *,CityAndProduction *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUCityAndProduction@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCityAndProduction@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUCityAndProduction@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCityAndProduction@@0@Z PROC ; std::_Ptr_cat<CityAndProduction *,CityAndProduction *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUCityAndProduction@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCityAndProduction@@0@Z ENDP ; std::_Ptr_cat<CityAndProduction *,CityAndProduction *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUCityAndProduction@@U1@@std@@YAXPAUCityAndProduction@@0ABU1@@Z ; std::_Fill<CityAndProduction *,CityAndProduction>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAUCityAndProduction@@U1@@std@@YAXPAUCityAndProduction@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUCityAndProduction@@U1@@std@@YAXPAUCityAndProduction@@0ABU1@@Z PROC ; std::_Fill<CityAndProduction *,CityAndProduction>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAUCityAndProduction@@U1@@std@@YAXPAUCityAndProduction@@0ABU1@@Z ENDP ; std::_Fill<CityAndProduction *,CityAndProduction>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUCityAndProduction@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCityAndProduction@@0@Z ; std::_Iter_random<CityAndProduction *,CityAndProduction *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUCityAndProduction@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCityAndProduction@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUCityAndProduction@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCityAndProduction@@0@Z PROC ; std::_Iter_random<CityAndProduction *,CityAndProduction *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUCityAndProduction@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCityAndProduction@@0@Z ENDP ; std::_Iter_random<CityAndProduction *,CityAndProduction *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAUCityAndProduction@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCityAndProduction@@@Z ; std::_Move_cat<CityAndProduction *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAUCityAndProduction@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCityAndProduction@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUCityAndProduction@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCityAndProduction@@@Z PROC ; std::_Move_cat<CityAndProduction *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAUCityAndProduction@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCityAndProduction@@@Z ENDP ; std::_Move_cat<CityAndProduction *>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@UCityAndProduction@@@std@@QAE@H@Z ; std::_Temp_iterator<CityAndProduction>::_Temp_iterator<CityAndProduction>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$_Temp_iterator@UCityAndProduction@@@std@@QAE@H@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$_Temp_iterator@UCityAndProduction@@@std@@QAE@H@Z PROC ; std::_Temp_iterator<CityAndProduction>::_Temp_iterator<CityAndProduction>, COMDAT
; _this$ = ecx

; 526  : 	_Temp_iterator(_PDFT _Count = 0)

	mov	eax, ecx

; 527  : 		{	// construct from desired temporary buffer size
; 528  : 		_Buf._Begin = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 529  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 530  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 531  : 		_Buf._Size = _Count;	// memorize size for lazy allocation

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	DWORD PTR [eax+12], ecx

; 532  : 		_Pbuf = &_Buf;

	mov	DWORD PTR [eax+16], eax

; 533  : 		}

	ret	4
??0?$_Temp_iterator@UCityAndProduction@@@std@@QAE@H@Z ENDP ; std::_Temp_iterator<CityAndProduction>::_Temp_iterator<CityAndProduction>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUCityAndProduction@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUCityAndProduction@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CityAndProduction *,CityAndProduction *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUCityAndProduction@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUCityAndProduction@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUCityAndProduction@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUCityAndProduction@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CityAndProduction *,CityAndProduction *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUCityAndProduction@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUCityAndProduction@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CityAndProduction *,CityAndProduction *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@UCityAndProduction@@U1@@std@@YAXPAUCityAndProduction@@ABU1@@Z ; std::_Construct<CityAndProduction,CityAndProduction>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@UCityAndProduction@@U1@@std@@YAXPAUCityAndProduction@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UCityAndProduction@@U1@@std@@YAXPAUCityAndProduction@@ABU1@@Z PROC ; std::_Construct<CityAndProduction,CityAndProduction>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@UCityAndProduction@@U1@@std@@YAXPAUCityAndProduction@@ABU1@@Z ENDP ; std::_Construct<CityAndProduction,CityAndProduction>
_TEXT	ENDS
PUBLIC	??$_Destroy@UCityAndProduction@@@std@@YAXPAUCityAndProduction@@@Z ; std::_Destroy<CityAndProduction>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@UCityAndProduction@@@std@@YAXPAUCityAndProduction@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UCityAndProduction@@@std@@YAXPAUCityAndProduction@@@Z PROC ; std::_Destroy<CityAndProduction>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@UCityAndProduction@@@std@@YAXPAUCityAndProduction@@@Z ENDP ; std::_Destroy<CityAndProduction>
_TEXT	ENDS
PUBLIC	??$return_temporary_buffer@UCityAndProduction@@@std@@YAXPAUCityAndProduction@@@Z ; std::return_temporary_buffer<CityAndProduction>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$return_temporary_buffer@UCityAndProduction@@@std@@YAXPAUCityAndProduction@@@Z
_TEXT	SEGMENT
__Pbuf$ = 8						; size = 4
??$return_temporary_buffer@UCityAndProduction@@@std@@YAXPAUCityAndProduction@@@Z PROC ; std::return_temporary_buffer<CityAndProduction>, COMDAT

; 39   : 	operator delete(_Pbuf);

	jmp	??3@YAXPAX@Z				; operator delete
??$return_temporary_buffer@UCityAndProduction@@@std@@YAXPAUCityAndProduction@@@Z ENDP ; std::return_temporary_buffer<CityAndProduction>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z ; std::_Iter_cat<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEHABV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@1@@Z ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator-
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEHABV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEHABV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@1@@Z PROC ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator-, COMDAT
; _this$ = ecx

; 398  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 399  : 		}

	ret	4
??G?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEHABV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@1@@Z ENDP ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator-
_TEXT	ENDS
PUBLIC	?_Init@?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV12@XZ ; std::_Temp_iterator<CityAndProduction>::_Init
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Init@?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?_Init@?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV12@XZ PROC ; std::_Temp_iterator<CityAndProduction>::_Init, COMDAT
; _this$ = ecx

; 591  : 		{	// set pointer at beginning of buffer

	mov	eax, ecx

; 592  : 		_Pbuf->_Current = _Pbuf->_Begin;

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], edx

; 593  : 		return (*this);
; 594  : 		}

	ret	0
?_Init@?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV12@XZ ENDP ; std::_Temp_iterator<CityAndProduction>::_Init
_TEXT	ENDS
PUBLIC	?_First@?$_Temp_iterator@UCityAndProduction@@@std@@QBEPAUCityAndProduction@@XZ ; std::_Temp_iterator<CityAndProduction>::_First
; Function compile flags: /Ogtpy
;	COMDAT ?_First@?$_Temp_iterator@UCityAndProduction@@@std@@QBEPAUCityAndProduction@@XZ
_TEXT	SEGMENT
?_First@?$_Temp_iterator@UCityAndProduction@@@std@@QBEPAUCityAndProduction@@XZ PROC ; std::_Temp_iterator<CityAndProduction>::_First, COMDAT
; _this$ = ecx

; 598  : 		return (_Pbuf->_Begin);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]

; 599  : 		}

	ret	0
?_First@?$_Temp_iterator@UCityAndProduction@@@std@@QBEPAUCityAndProduction@@XZ ENDP ; std::_Temp_iterator<CityAndProduction>::_First
_TEXT	ENDS
PUBLIC	?_Last@?$_Temp_iterator@UCityAndProduction@@@std@@QBEPAUCityAndProduction@@XZ ; std::_Temp_iterator<CityAndProduction>::_Last
; Function compile flags: /Ogtpy
;	COMDAT ?_Last@?$_Temp_iterator@UCityAndProduction@@@std@@QBEPAUCityAndProduction@@XZ
_TEXT	SEGMENT
?_Last@?$_Temp_iterator@UCityAndProduction@@@std@@QBEPAUCityAndProduction@@XZ PROC ; std::_Temp_iterator<CityAndProduction>::_Last, COMDAT
; _this$ = ecx

; 603  : 		return (_Pbuf->_Current);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]

; 604  : 		}

	ret	0
?_Last@?$_Temp_iterator@UCityAndProduction@@@std@@QBEPAUCityAndProduction@@XZ ENDP ; std::_Temp_iterator<CityAndProduction>::_Last
_TEXT	ENDS
PUBLIC	??0?$pair@PAUCityAndProduction@@H@std@@QAE@ABQAUCityAndProduction@@ABH@Z ; std::pair<CityAndProduction *,int>::pair<CityAndProduction *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAUCityAndProduction@@H@std@@QAE@ABQAUCityAndProduction@@ABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUCityAndProduction@@H@std@@QAE@ABQAUCityAndProduction@@ABH@Z PROC ; std::pair<CityAndProduction *,int>::pair<CityAndProduction *,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUCityAndProduction@@H@std@@QAE@ABQAUCityAndProduction@@ABH@Z ENDP ; std::pair<CityAndProduction *,int>::pair<CityAndProduction *,int>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	mov	eax, ecx

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEABUCityAndProduction@@XZ ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEABUCityAndProduction@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEABUCityAndProduction@@XZ PROC ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEABUCityAndProduction@@XZ ENDP ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator*
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@ABV01@@Z ; std::_Temp_iterator<CityAndProduction>::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Temp_iterator<CityAndProduction>::operator=, COMDAT
; _this$ = ecx

; 556  : 		{	// assign _Right (share active buffer)

	mov	eax, ecx

; 557  : 		_Pbuf = _Right._Pbuf;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 558  : 		return (*this);
; 559  : 		}

	ret	4
??4?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Temp_iterator<CityAndProduction>::operator=
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 8

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator++
_TEXT	ENDS
PUBLIC	??F?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??F?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator--, COMDAT
; _this$ = ecx

; 137  : 		{	// predecrement

	mov	eax, ecx

; 138  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 139  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr > ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 140  : 
; 141  :  #if _HAS_ITERATOR_DEBUGGING
; 142  : 		if (this->_Mycont == 0
; 143  : 			|| _Myptr == ((_Myvec *)this->_Mycont)->_Myfirst)
; 144  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 145  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 146  : 
; 147  : 		--_Myptr;

	add	DWORD PTR [eax], -8			; fffffff8H

; 148  : 		return (*this);
; 149  : 		}

	ret	0
??F?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator--
_TEXT	ENDS
PUBLIC	??$swap@UCityAndProduction@@@std@@YAXAAUCityAndProduction@@0@Z ; std::swap<CityAndProduction>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@UCityAndProduction@@@std@@YAXAAUCityAndProduction@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UCityAndProduction@@@std@@YAXAAUCityAndProduction@@0@Z PROC ; std::swap<CityAndProduction>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@UCityAndProduction@@@std@@YAXAAUCityAndProduction@@0@Z ENDP ; std::swap<CityAndProduction>
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@ABV?$_Temp_iterator@UCityAndProduction@@@0@@Z ; std::_Iter_random<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@ABV?$_Temp_iterator@UCityAndProduction@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@ABV?$_Temp_iterator@UCityAndProduction@@@0@@Z PROC ; std::_Iter_random<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@ABV?$_Temp_iterator@UCityAndProduction@@@0@@Z ENDP ; std::_Iter_random<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@AAV?$_Temp_iterator@UCityAndProduction@@@0@@Z ; std::_Ptr_cat<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@AAV?$_Temp_iterator@UCityAndProduction@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@AAV?$_Temp_iterator@UCityAndProduction@@@0@@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@AAV?$_Temp_iterator@UCityAndProduction@@@0@@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCityAndProduction@@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@1@Z ; std::_Iter_random<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCityAndProduction@@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCityAndProduction@@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@1@Z PROC ; std::_Iter_random<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCityAndProduction@@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@1@Z ENDP ; std::_Iter_random<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@ABUCityAndProduction@@@Z ; std::_Temp_iterator<CityAndProduction>::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@ABUCityAndProduction@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??4?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@ABUCityAndProduction@@@Z PROC ; std::_Temp_iterator<CityAndProduction>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	mov	eax, ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	ecx, DWORD PTR [ecx+4]
	push	esi
	jae	SHORT $LN2@operator
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 8
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
$LN2@operator:

; 565  : 		else
; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;
; 569  : 			_Construct(_Ptr, _Val);

	test	ecx, ecx
	je	SHORT $LN7@operator
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edx
$LN7@operator:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 8
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+8], edx
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
??4?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@ABUCityAndProduction@@@Z ENDP ; std::_Temp_iterator<CityAndProduction>::operator=
_TEXT	ENDS
PUBLIC	??D?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CityAndProduction>::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CityAndProduction>::operator*, COMDAT
; _this$ = ecx

; 576  : 		{	// pretend to return designated value

	mov	eax, ecx

; 577  : 		return (*this);
; 578  : 		}

	ret	0
??D?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CityAndProduction>::operator*
_TEXT	ENDS
PUBLIC	??E?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CityAndProduction>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CityAndProduction>::operator++, COMDAT
; _this$ = ecx

; 581  : 		{	// pretend to preincrement

	mov	eax, ecx

; 582  : 		return (*this);
; 583  : 		}

	ret	0
??E?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CityAndProduction>::operator++
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0@Z ; std::_Iter_random<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCityAndProduction@@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z ; std::_Iter_random<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCityAndProduction@@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCityAndProduction@@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z PROC ; std::_Iter_random<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCityAndProduction@@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z ENDP ; std::_Iter_random<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCityAndProduction@@AAV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z ; std::_Ptr_cat<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCityAndProduction@@AAV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCityAndProduction@@AAV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z PROC ; std::_Ptr_cat<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCityAndProduction@@AAV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z ENDP ; std::_Ptr_cat<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0ABV?$_Temp_iterator@UCityAndProduction@@@0@@Z ; std::_Iter_random<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0ABV?$_Temp_iterator@UCityAndProduction@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0ABV?$_Temp_iterator@UCityAndProduction@@@0@@Z PROC ; std::_Iter_random<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0ABV?$_Temp_iterator@UCityAndProduction@@@0@@Z ENDP ; std::_Iter_random<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAUCityAndProduction@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCityAndProduction@@@Z ; std::_Iter_cat<CityAndProduction *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAUCityAndProduction@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCityAndProduction@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAUCityAndProduction@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCityAndProduction@@@Z PROC ; std::_Iter_cat<CityAndProduction *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAUCityAndProduction@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCityAndProduction@@@Z ENDP ; std::_Iter_cat<CityAndProduction *>
_TEXT	ENDS
PUBLIC	??$_Advance@PAUCityAndProduction@@H@std@@YAXAAPAUCityAndProduction@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<CityAndProduction *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Advance@PAUCityAndProduction@@H@std@@YAXAAPAUCityAndProduction@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@PAUCityAndProduction@@H@std@@YAXAAPAUCityAndProduction@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<CityAndProduction *,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@PAUCityAndProduction@@H@std@@YAXAAPAUCityAndProduction@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<CityAndProduction *,int>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCityAndProduction@@0ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z ; std::_Iter_random<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCityAndProduction@@0ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCityAndProduction@@0ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z PROC ; std::_Iter_random<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCityAndProduction@@0ABV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@@Z ENDP ; std::_Iter_random<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::operator->
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
;	COMDAT ??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::operator->, COMDAT
; _this$ = ecx

; 40   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 41   : }

	ret	0
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::operator->
_TEXT	ENDS
PUBLIC	?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::get, COMDAT
; _this$ = ecx

; 45   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 46   : }

	ret	0
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::get
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getPlotDirectionX@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionX
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionX@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionX@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionX, COMDAT
; _this$ = ecx

; 191  : 		return m_aiPlotDirectionX;

	lea	eax, DWORD PTR [ecx+112]

; 192  : 	}

	ret	0
?getPlotDirectionX@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionX
_TEXT	ENDS
PUBLIC	?getPlotDirectionY@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionY
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionY@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionY@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionY, COMDAT
; _this$ = ecx

; 195  : 		return m_aiPlotDirectionY;

	lea	eax, DWORD PTR [ecx+136]

; 196  : 	}

	ret	0
?getPlotDirectionY@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionY
_TEXT	ENDS
PUBLIC	?getAI_STRATEGY_MINIMUM_SETTLE_FERTILITY@CvGlobals@@QAEHXZ ; CvGlobals::getAI_STRATEGY_MINIMUM_SETTLE_FERTILITY
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_STRATEGY_MINIMUM_SETTLE_FERTILITY@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_STRATEGY_MINIMUM_SETTLE_FERTILITY@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_STRATEGY_MINIMUM_SETTLE_FERTILITY, COMDAT
; _this$ = ecx

; 1093 : 		return m_iAI_STRATEGY_MINIMUM_SETTLE_FERTILITY;

	mov	eax, DWORD PTR [ecx+2028]

; 1094 : 	}

	ret	0
?getAI_STRATEGY_MINIMUM_SETTLE_FERTILITY@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_STRATEGY_MINIMUM_SETTLE_FERTILITY
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_GREAT_PERSON_TURNS_TO_WAIT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_GREAT_PERSON_TURNS_TO_WAIT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_GREAT_PERSON_TURNS_TO_WAIT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_GREAT_PERSON_TURNS_TO_WAIT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_GREAT_PERSON_TURNS_TO_WAIT, COMDAT
; _this$ = ecx

; 1765 : 		return m_iAI_HOMELAND_GREAT_PERSON_TURNS_TO_WAIT;

	mov	eax, DWORD PTR [ecx+2700]

; 1766 : 	}

	ret	0
?getAI_HOMELAND_GREAT_PERSON_TURNS_TO_WAIT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_GREAT_PERSON_TURNS_TO_WAIT
_TEXT	ENDS
PUBLIC	?getNORMAL_ANNEX@CvGlobals@@QAEMXZ		; CvGlobals::getNORMAL_ANNEX
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
;	COMDAT ?getNORMAL_ANNEX@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getNORMAL_ANNEX@CvGlobals@@QAEMXZ PROC			; CvGlobals::getNORMAL_ANNEX, COMDAT
; _this$ = ecx

; 2505 : 		return m_fNORMAL_ANNEX;

	fld	DWORD PTR [ecx+8192]

; 2506 : 	}

	ret	0
?getNORMAL_ANNEX@CvGlobals@@QAEMXZ ENDP			; CvGlobals::getNORMAL_ANNEX
_TEXT	ENDS
PUBLIC	?getAGGRESIVE_ANNEX@CvGlobals@@QAEMXZ		; CvGlobals::getAGGRESIVE_ANNEX
; Function compile flags: /Ogtpy
;	COMDAT ?getAGGRESIVE_ANNEX@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAGGRESIVE_ANNEX@CvGlobals@@QAEMXZ PROC		; CvGlobals::getAGGRESIVE_ANNEX, COMDAT
; _this$ = ecx

; 2509 : 		return m_fAGGRESSIVE_ANNEX;

	fld	DWORD PTR [ecx+8196]

; 2510 : 	}

	ret	0
?getAGGRESIVE_ANNEX@CvGlobals@@QAEMXZ ENDP		; CvGlobals::getAGGRESIVE_ANNEX
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	??0OperationSlot@@QAE@XZ			; OperationSlot::OperationSlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
;	COMDAT ??0OperationSlot@@QAE@XZ
_TEXT	SEGMENT
??0OperationSlot@@QAE@XZ PROC				; OperationSlot::OperationSlot, COMDAT
; _this$ = ecx

; 94   : 	OperationSlot()

	mov	eax, ecx

; 95   : 	{
; 96   : 		m_iOperationID = -1;

	or	ecx, -1
	mov	DWORD PTR [eax], ecx

; 97   : 		m_iArmyID = FFreeList::INVALID_INDEX;

	mov	DWORD PTR [eax+4], ecx

; 98   : 		m_iSlotID = -1;

	mov	DWORD PTR [eax+8], ecx

; 99   : 	}

	ret	0
??0OperationSlot@@QAE@XZ ENDP				; OperationSlot::OperationSlot
_TEXT	ENDS
PUBLIC	?IsValid@OperationSlot@@QBE_NXZ			; OperationSlot::IsValid
; Function compile flags: /Ogtpy
;	COMDAT ?IsValid@OperationSlot@@QBE_NXZ
_TEXT	SEGMENT
?IsValid@OperationSlot@@QBE_NXZ PROC			; OperationSlot::IsValid, COMDAT
; _this$ = ecx

; 108  : 		return (m_iArmyID != FFreeList::INVALID_INDEX && m_iSlotID != -1 && m_iOperationID != -1);

	or	eax, -1
	cmp	DWORD PTR [ecx+4], eax
	je	SHORT $LN3@IsValid
	cmp	DWORD PTR [ecx+8], eax
	je	SHORT $LN3@IsValid
	cmp	DWORD PTR [ecx], eax
	je	SHORT $LN3@IsValid
	mov	eax, 1

; 109  : 	}

	ret	0
$LN3@IsValid:

; 108  : 		return (m_iArmyID != FFreeList::INVALID_INDEX && m_iSlotID != -1 && m_iOperationID != -1);

	xor	eax, eax

; 109  : 	}

	ret	0
?IsValid@OperationSlot@@QBE_NXZ ENDP			; OperationSlot::IsValid
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getArea@CvPlot@@QBEHXZ				; CvPlot::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?getArea@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getArea@CvPlot@@QBEHXZ PROC				; CvPlot::getArea, COMDAT
; _this$ = ecx

; 324  : 		return m_iArea;

	mov	eax, DWORD PTR [ecx+356]

; 325  : 	}

	ret	0
?getArea@CvPlot@@QBEHXZ ENDP				; CvPlot::getArea
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@getPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 537  : 	}

	ret	0
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax

; 537  : 	}

	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z		; CvPlot::PlotBoolField::GetBit
; Function compile flags: /Ogtpy
;	COMDAT ?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z
_TEXT	SEGMENT
_uiEntry$ = 8						; size = 4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z PROC		; CvPlot::PlotBoolField::GetBit, COMDAT
; _this$ = ecx

; 767  : 		{

	mov	edx, ecx

; 768  : 			const uint uiOffset = uiEntry/eSize;

	mov	ecx, DWORD PTR _uiEntry$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5

; 769  : 			return m_dwBits[uiOffset] & 1<<(uiEntry-(eSize*uiOffset));

	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4]
	pop	esi
	setne	al

; 770  : 		}

	ret	4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z ENDP		; CvPlot::PlotBoolField::GetBit
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?numPlots@CvMap@@QBEHXZ				; CvMap::numPlots
; Function compile flags: /Ogtpy
;	COMDAT ?numPlots@CvMap@@QBEHXZ
_TEXT	SEGMENT
?numPlots@CvMap@@QBEHXZ PROC				; CvMap::numPlots, COMDAT
; _this$ = ecx

; 170  : 		return m_iGridSize;

	mov	eax, DWORD PTR [ecx+4028]

; 171  : 	}

	ret	0
?numPlots@CvMap@@QBEHXZ ENDP				; CvMap::numPlots
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z		; CvMap::plotByIndex
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z PROC		; CvMap::plotByIndex, COMDAT
; _this$ = ecx

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	mov	eax, DWORD PTR _iIndex$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@plotByInde
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN3@plotByInde
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 264  : 	}

	ret	4
$LN3@plotByInde:

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	xor	eax, eax

; 264  : 	}

	ret	4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z ENDP		; CvMap::plotByIndex
_TEXT	ENDS
PUBLIC	?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z	; CvMap::plotByIndexUnchecked
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z PROC	; CvMap::plotByIndexUnchecked, COMDAT
; _this$ = ecx

; 268  : 		return &m_pMapPlots[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp-4]
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 269  : 	}

	ret	4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z ENDP	; CvMap::plotByIndexUnchecked
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	?GetGoldenAgeMoveChange@CvPlayerTraits@@QBEHXZ	; CvPlayerTraits::GetGoldenAgeMoveChange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
;	COMDAT ?GetGoldenAgeMoveChange@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeMoveChange@CvPlayerTraits@@QBEHXZ PROC	; CvPlayerTraits::GetGoldenAgeMoveChange, COMDAT
; _this$ = ecx

; 585  : 		return m_iGoldenAgeMoveChange;

	mov	eax, DWORD PTR [ecx+176]

; 586  : 	};

	ret	0
?GetGoldenAgeMoveChange@CvPlayerTraits@@QBEHXZ ENDP	; CvPlayerTraits::GetGoldenAgeMoveChange
_TEXT	ENDS
PUBLIC	?GetGoldenAgeTourismModifier@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetGoldenAgeTourismModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldenAgeTourismModifier@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeTourismModifier@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetGoldenAgeTourismModifier, COMDAT
; _this$ = ecx

; 593  : 		return m_iGoldenAgeTourismModifier;

	mov	eax, DWORD PTR [ecx+184]

; 594  : 	};

	ret	0
?GetGoldenAgeTourismModifier@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetGoldenAgeTourismModifier
_TEXT	ENDS
PUBLIC	?GetRazeSpeedModifier@CvPlayerTraits@@QBEHXZ	; CvPlayerTraits::GetRazeSpeedModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetRazeSpeedModifier@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetRazeSpeedModifier@CvPlayerTraits@@QBEHXZ PROC	; CvPlayerTraits::GetRazeSpeedModifier, COMDAT
; _this$ = ecx

; 672  : 		return m_iRazeSpeedModifier;

	mov	eax, DWORD PTR [ecx+256]

; 673  : 	};

	ret	0
?GetRazeSpeedModifier@CvPlayerTraits@@QBEHXZ ENDP	; CvPlayerTraits::GetRazeSpeedModifier
_TEXT	ENDS
PUBLIC	?IsNoAnnexing@CvPlayerTraits@@QBE_NXZ		; CvPlayerTraits::IsNoAnnexing
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoAnnexing@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
?IsNoAnnexing@CvPlayerTraits@@QBE_NXZ PROC		; CvPlayerTraits::IsNoAnnexing, COMDAT
; _this$ = ecx

; 841  : 		return m_bNoAnnexing;

	mov	al, BYTE PTR [ecx+351]

; 842  : 	};

	ret	0
?IsNoAnnexing@CvPlayerTraits@@QBE_NXZ ENDP		; CvPlayerTraits::IsNoAnnexing
_TEXT	ENDS
PUBLIC	?ForceReset@CvAStar@@QAEXXZ			; CvAStar::ForceReset
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.h
;	COMDAT ?ForceReset@CvAStar@@QAEXXZ
_TEXT	SEGMENT
?ForceReset@CvAStar@@QAEXXZ PROC			; CvAStar::ForceReset, COMDAT
; _this$ = ecx

; 178  : 		m_bForceReset = true;

	mov	BYTE PTR [ecx+78], 1

; 179  : 	}

	ret	0
?ForceReset@CvAStar@@QAEXXZ ENDP			; CvAStar::ForceReset
_TEXT	ENDS
PUBLIC	?SetMPCacheSafe@CvAStar@@QAE_N_N@Z		; CvAStar::SetMPCacheSafe
; Function compile flags: /Ogtpy
;	COMDAT ?SetMPCacheSafe@CvAStar@@QAE_N_N@Z
_TEXT	SEGMENT
_bState$ = 8						; size = 1
?SetMPCacheSafe@CvAStar@@QAE_N_N@Z PROC			; CvAStar::SetMPCacheSafe, COMDAT
; _this$ = ecx

; 218  : 		bool bOldState = m_bIsMPCacheSafe;

	mov	al, BYTE PTR [ecx+79]

; 219  : 		if(bState != m_bIsMPCacheSafe)

	mov	dl, BYTE PTR _bState$[esp-4]
	cmp	dl, al
	je	SHORT $LN1@SetMPCache

; 220  : 		{
; 221  : 			m_bForceReset = true;

	mov	BYTE PTR [ecx+78], 1

; 222  : 			m_bIsMPCacheSafe = bState;

	mov	BYTE PTR [ecx+79], dl
$LN1@SetMPCache:

; 223  : 		}
; 224  : 
; 225  : 		return bOldState;
; 226  : 	}

	ret	4
?SetMPCacheSafe@CvAStar@@QAE_N_N@Z ENDP			; CvAStar::SetMPCacheSafe
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEIXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEIXZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEIXZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::size
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Isnil
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Isnil, COMDAT

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 17					; 00000011H

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Left
; Function compile flags: /Ogtpy
;	COMDAT ?_Left@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Left, COMDAT

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Right
; Function compile flags: /Ogtpy
;	COMDAT ?_Right@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Right, COMDAT

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@SAABQAVFAutoVariableBase@@ABQAV3@@Z ; std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\set
;	COMDAT ?_Kfn@?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@SAABQAVFAutoVariableBase@@ABQAV3@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@SAABQAVFAutoVariableBase@@ABQAV3@@Z PROC ; std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0>::_Kfn, COMDAT

; 45   : 		return (_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 46   : 		}

	ret	0
?_Kfn@?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@SAABQAVFAutoVariableBase@@ABQAV3@@Z ENDP ; std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0>::_Kfn
_TEXT	ENDS
PUBLIC	??R?$less@PAVFAutoVariableBase@@@std@@QBE_NABQAVFAutoVariableBase@@0@Z ; std::less<FAutoVariableBase *>::operator()
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\functional
;	COMDAT ??R?$less@PAVFAutoVariableBase@@@std@@QBE_NABQAVFAutoVariableBase@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@PAVFAutoVariableBase@@@std@@QBE_NABQAVFAutoVariableBase@@0@Z PROC ; std::less<FAutoVariableBase *>::operator(), COMDAT
; _this$ = ecx

; 143  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[esp-4]
	cmp	ecx, DWORD PTR [edx]
	sbb	eax, eax
	neg	eax

; 144  : 		}

	ret	8
??R?$less@PAVFAutoVariableBase@@@std@@QBE_NABQAVFAutoVariableBase@@0@Z ENDP ; std::less<FAutoVariableBase *>::operator()
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+4], dl

; 51   : 		}

	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	4
??8const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Color
; Function compile flags: /Ogtpy
;	COMDAT ?_Color@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Color, COMDAT

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 16					; 00000010H

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Parent
; Function compile flags: /Ogtpy
;	COMDAT ?_Parent@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Parent, COMDAT

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Myval
; Function compile flags: /Ogtpy
;	COMDAT ?_Myval@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Myval, COMDAT

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Lmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [ecx+4]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Rmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rmost
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 244  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 245  : 			}

	ret	4
??0const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVFAutoVariableBase@@@std@@QBEIXZ ; std::allocator<FAutoVariableBase *>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVFAutoVariableBase@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVFAutoVariableBase@@@std@@QBEIXZ PROC ; std::allocator<FAutoVariableBase *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVFAutoVariableBase@@@std@@QBEIXZ ENDP ; std::allocator<FAutoVariableBase *>::max_size
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU012@00ABQAVFAutoVariableBase@@D@Z ; std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node::_Node
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU012@00ABQAVFAutoVariableBase@@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU012@00ABQAVFAutoVariableBase@@D@Z PROC ; std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+12], ecx
	mov	BYTE PTR [eax+16], dl
	mov	BYTE PTR [eax+17], 0

; 39   : 			}

	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU012@00ABQAVFAutoVariableBase@@D@Z ENDP ; std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Max
; Function compile flags: /Ogtpy
;	COMDAT ?_Max@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Max, COMDAT

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+17], 0
	jne	SHORT $LN1@Max
	npad	3
$LL2@Max:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+17], 0
	je	SHORT $LL2@Max
$LN1@Max:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Max
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvUnit>::get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvUnit>::get
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ		; FAutoVariable<int,CvUnit>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ		; FAutoVariable<char,CvPlot>::operator char const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ
_TEXT	SEGMENT
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ PROC		; FAutoVariable<char,CvPlot>::operator char const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ ENDP		; FAutoVariable<char,CvPlot>::operator char const &
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T230528 = -12						; size = 12
$T230532 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*4]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 20					; 00000014H
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T230532[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T230528[esp+16]
	mov	DWORD PTR $T230532[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T230528[esp+16]
	push	ecx
	mov	DWORD PTR $T230528[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iDY$ = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[esp-4]
	sub	eax, DWORD PTR _iX1$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	edx, DWORD PTR [ebx+4020]
	push	ebp
	push	esi
	je	SHORT $LN13@plotDistan
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN15@plotDistan
	sub	eax, edx
	jmp	SHORT $LN13@plotDistan
$LN15@plotDistan:
	neg	ecx
	cmp	eax, ecx
	lea	ecx, DWORD PTR [edx+eax]
	jl	SHORT $LN17@plotDistan
$LN13@plotDistan:
	mov	ecx, eax
$LN17@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	eax, DWORD PTR _iY2$[esp+8]
	mov	esi, DWORD PTR [ebx+4024]
	push	edi
	mov	edi, DWORD PTR _iY1$[esp+12]
	sub	eax, edi
	cmp	BYTE PTR [ebx+4057], 0
	je	SHORT $LN27@plotDistan
	mov	edx, esi
	shr	edx, 1
	cmp	eax, edx
	jle	SHORT $LN29@plotDistan
	sub	eax, esi
	jmp	SHORT $LN27@plotDistan
$LN29@plotDistan:
	neg	edx
	cmp	eax, edx
	lea	ebp, DWORD PTR [esi+eax]
	jl	SHORT $LN31@plotDistan
$LN27@plotDistan:
	mov	ebp, eax
$LN31@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[esp+12], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	test	edi, edi
	jl	SHORT $LN35@plotDistan
	mov	eax, edi
	jmp	SHORT $LN59@plotDistan
$LN35@plotDistan:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN59@plotDistan:
	mov	esi, DWORD PTR _iX1$[esp+12]
	sar	eax, 1
	sub	esi, eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	lea	eax, DWORD PTR [edi+ebp]
	pop	edi
	test	eax, eax
	jge	SHORT $LN60@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN60@plotDistan:

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	edx, DWORD PTR [ebx+4020]
	sar	eax, 1
	sub	ecx, eax
	add	ecx, DWORD PTR _iX1$[esp+8]
	sub	ecx, esi
	cmp	BYTE PTR [ebx+4056], 0
	je	SHORT $LN49@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN51@plotDistan
	mov	eax, ecx
	sub	eax, edx
	jmp	SHORT $LN53@plotDistan
$LN51@plotDistan:
	neg	eax
	cmp	ecx, eax
	lea	eax, DWORD PTR [edx+ecx]
	jl	SHORT $LN53@plotDistan
$LN49@plotDistan:
	mov	eax, ecx
$LN53@plotDistan:
	cdq
	xor	eax, edx
	sub	eax, edx

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebp, ebp
	setge	cl
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp-4]
	add	eax, edx

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
$LN2@plotDistan:

; 163  : 	}
; 164  : 	else
; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp-4]
	lea	eax, DWORD PTR _iDY$[esp-4]
	jl	SHORT $LN58@plotDistan
	lea	eax, DWORD PTR _iDX$[esp-4]
$LN58@plotDistan:
	mov	eax, DWORD PTR [eax]

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	?freeStatics@CvPlayerAI@@SAXXZ			; CvPlayerAI::freeStatics
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
;	COMDAT ?freeStatics@CvPlayerAI@@SAXXZ
_TEXT	SEGMENT
?freeStatics@CvPlayerAI@@SAXXZ PROC			; CvPlayerAI::freeStatics, COMDAT

; 54   : 	SAFE_DELETE_ARRAY(m_aPlayers);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	test	ecx, ecx
	je	SHORT $LN9@freeStatic
	cmp	DWORD PTR [ecx-4], 0
	lea	eax, DWORD PTR [ecx-4]
	je	SHORT $LN5@freeStatic
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	3
	call	edx
	mov	DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A, 0 ; CvPlayerAI::m_aPlayers

; 55   : }

	ret	0

; 54   : 	SAFE_DELETE_ARRAY(m_aPlayers);

$LN5@freeStatic:
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN9@freeStatic:
	mov	DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A, 0 ; CvPlayerAI::m_aPlayers

; 55   : }

	ret	0
?freeStatics@CvPlayerAI@@SAXXZ ENDP			; CvPlayerAI::freeStatics
_TEXT	ENDS
PUBLIC	??_7CvPlayerAI@@6B@				; CvPlayerAI::`vftable'
PUBLIC	??0CvPlayerAI@@QAE@XZ				; CvPlayerAI::CvPlayerAI
PUBLIC	??_R4CvPlayerAI@@6B@				; CvPlayerAI::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvPlayerAI@@@8				; CvPlayerAI `RTTI Type Descriptor'
PUBLIC	??_R3CvPlayerAI@@8				; CvPlayerAI::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvPlayerAI@@8				; CvPlayerAI::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvPlayerAI@@8			; CvPlayerAI::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvPlayer@@8			; CvPlayer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvPlayer@@@8				; CvPlayer `RTTI Type Descriptor'
PUBLIC	??_R3CvPlayer@@8				; CvPlayer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvPlayer@@8				; CvPlayer::`RTTI Base Class Array'
PUBLIC	??_ECvPlayerAI@@UAEPAXI@Z			; CvPlayerAI::`vector deleting destructor'
PUBLIC	?Read@CvPlayerAI@@UAEXAAVFDataStream@@@Z	; CvPlayerAI::Read
PUBLIC	?Write@CvPlayerAI@@UBEXAAVFDataStream@@@Z	; CvPlayerAI::Write
PUBLIC	?AI_doTurnPre@CvPlayerAI@@UAEXXZ		; CvPlayerAI::AI_doTurnPre
PUBLIC	?AI_doTurnPost@CvPlayerAI@@UAEXXZ		; CvPlayerAI::AI_doTurnPost
PUBLIC	?AI_updateFoundValues@CvPlayerAI@@UAEX_N@Z	; CvPlayerAI::AI_updateFoundValues
PUBLIC	?AI_unitUpdate@CvPlayerAI@@UAEXXZ		; CvPlayerAI::AI_unitUpdate
PUBLIC	?AI_conquerCity@CvPlayerAI@@UAEXPAVCvCity@@W4PlayerTypes@@@Z ; CvPlayerAI::AI_conquerCity
PUBLIC	?AI_foundValue@CvPlayerAI@@UAEHHHH_N@Z		; CvPlayerAI::AI_foundValue
PUBLIC	?AI_chooseFreeGreatPerson@CvPlayerAI@@UAEXXZ	; CvPlayerAI::AI_chooseFreeGreatPerson
PUBLIC	?AI_chooseFreeTech@CvPlayerAI@@UAEXXZ		; CvPlayerAI::AI_chooseFreeTech
PUBLIC	?AI_chooseResearch@CvPlayerAI@@UAEXXZ		; CvPlayerAI::AI_chooseResearch
PUBLIC	?AI_plotTargetMissionAIs@CvPlayerAI@@UAEHPAVCvPlot@@W4MissionAITypes@@H@Z ; CvPlayerAI::AI_plotTargetMissionAIs
PUBLIC	?AI_launch@CvPlayerAI@@UAEXW4VictoryTypes@@@Z	; CvPlayerAI::AI_launch
PUBLIC	?PeekAtNextUnitToBuildForOperationSlot@CvPlayerAI@@UAE?AUOperationSlot@@H@Z ; CvPlayerAI::PeekAtNextUnitToBuildForOperationSlot
PUBLIC	?CityCommitToBuildUnitForOperationSlot@CvPlayerAI@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z ; CvPlayerAI::CityCommitToBuildUnitForOperationSlot
PUBLIC	?CityFinishedBuildingUnitForOperationSlot@CvPlayerAI@@UAEXUOperationSlot@@PAVCvUnit@@@Z ; CvPlayerAI::CityFinishedBuildingUnitForOperationSlot
PUBLIC	?GetNumUnitsNeededToBeBuilt@CvPlayerAI@@UAEHXZ	; CvPlayerAI::GetNumUnitsNeededToBeBuilt
EXTRN	??0CvPlayer@@QAE@XZ:PROC			; CvPlayer::CvPlayer
;	COMDAT ??_R2CvPlayer@@8
rdata$r	SEGMENT
??_R2CvPlayer@@8 DD FLAT:??_R1A@?0A@EA@CvPlayer@@8	; CvPlayer::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvPlayer@@8
rdata$r	SEGMENT
??_R3CvPlayer@@8 DD 00H					; CvPlayer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvPlayer@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvPlayer@@@8
_DATA	SEGMENT
??_R0?AVCvPlayer@@@8 DD FLAT:??_7type_info@@6B@		; CvPlayer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvPlayer@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvPlayer@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvPlayer@@8 DD FLAT:??_R0?AVCvPlayer@@@8	; CvPlayer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvPlayer@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvPlayerAI@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvPlayerAI@@8 DD FLAT:??_R0?AVCvPlayerAI@@@8 ; CvPlayerAI::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvPlayerAI@@8
rdata$r	ENDS
;	COMDAT ??_R2CvPlayerAI@@8
rdata$r	SEGMENT
??_R2CvPlayerAI@@8 DD FLAT:??_R1A@?0A@EA@CvPlayerAI@@8	; CvPlayerAI::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvPlayer@@8
rdata$r	ENDS
;	COMDAT ??_R3CvPlayerAI@@8
rdata$r	SEGMENT
??_R3CvPlayerAI@@8 DD 00H				; CvPlayerAI::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvPlayerAI@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvPlayerAI@@@8
_DATA	SEGMENT
??_R0?AVCvPlayerAI@@@8 DD FLAT:??_7type_info@@6B@	; CvPlayerAI `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvPlayerAI@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvPlayerAI@@6B@
rdata$r	SEGMENT
??_R4CvPlayerAI@@6B@ DD 00H				; CvPlayerAI::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvPlayerAI@@@8
	DD	FLAT:??_R3CvPlayerAI@@8
rdata$r	ENDS
;	COMDAT ??_7CvPlayerAI@@6B@
CONST	SEGMENT
??_7CvPlayerAI@@6B@ DD FLAT:??_R4CvPlayerAI@@6B@	; CvPlayerAI::`vftable'
	DD	FLAT:??_ECvPlayerAI@@UAEPAXI@Z
	DD	FLAT:?Read@CvPlayerAI@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvPlayerAI@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?AI_init@CvPlayerAI@@UAEXXZ
	DD	FLAT:?AI_reset@CvPlayerAI@@UAEXXZ
	DD	FLAT:?AI_doTurnPre@CvPlayerAI@@UAEXXZ
	DD	FLAT:?AI_doTurnPost@CvPlayerAI@@UAEXXZ
	DD	FLAT:?AI_doTurnUnitsPre@CvPlayerAI@@UAEXXZ
	DD	FLAT:?AI_doTurnUnitsPost@CvPlayerAI@@UAEXXZ
	DD	FLAT:?AI_updateFoundValues@CvPlayerAI@@UAEX_N@Z
	DD	FLAT:?AI_unitUpdate@CvPlayerAI@@UAEXXZ
	DD	FLAT:?AI_conquerCity@CvPlayerAI@@UAEXPAVCvCity@@W4PlayerTypes@@@Z
	DD	FLAT:?AI_foundValue@CvPlayerAI@@UAEHHHH_N@Z
	DD	FLAT:?AI_chooseFreeGreatPerson@CvPlayerAI@@UAEXXZ
	DD	FLAT:?AI_chooseFreeTech@CvPlayerAI@@UAEXXZ
	DD	FLAT:?AI_chooseResearch@CvPlayerAI@@UAEXXZ
	DD	FLAT:?AI_plotTargetMissionAIs@CvPlayerAI@@UAEHPAVCvPlot@@W4MissionAITypes@@H@Z
	DD	FLAT:?AI_launch@CvPlayerAI@@UAEXW4VictoryTypes@@@Z
	DD	FLAT:?PeekAtNextUnitToBuildForOperationSlot@CvPlayerAI@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CityCommitToBuildUnitForOperationSlot@CvPlayerAI@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?CityUncommitToBuildUnitForOperationSlot@CvPlayerAI@@UAEXUOperationSlot@@@Z
	DD	FLAT:?CityFinishedBuildingUnitForOperationSlot@CvPlayerAI@@UAEXUOperationSlot@@PAVCvUnit@@@Z
	DD	FLAT:?GetNumUnitsNeededToBeBuilt@CvPlayerAI@@UAEHXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvPlayerAI@@QAE@XZ
_TEXT	SEGMENT
??0CvPlayerAI@@QAE@XZ PROC				; CvPlayerAI::CvPlayerAI, COMDAT
; _this$ = ecx

; 59   : {

	push	esi
	mov	esi, ecx
	call	??0CvPlayer@@QAE@XZ			; CvPlayer::CvPlayer
	mov	DWORD PTR [esi], OFFSET ??_7CvPlayerAI@@6B@

; 60   : 	AI_reset();
; 61   : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvPlayerAI@@QAE@XZ ENDP				; CvPlayerAI::CvPlayerAI
_TEXT	ENDS
PUBLIC	??1CvPlayerAI@@UAE@XZ				; CvPlayerAI::~CvPlayerAI
EXTRN	??1CvPlayer@@UAE@XZ:PROC			; CvPlayer::~CvPlayer
; Function compile flags: /Ogtpy
;	COMDAT ??1CvPlayerAI@@UAE@XZ
_TEXT	SEGMENT
??1CvPlayerAI@@UAE@XZ PROC				; CvPlayerAI::~CvPlayerAI, COMDAT
; _this$ = ecx

; 65   : {

	mov	DWORD PTR [ecx], OFFSET ??_7CvPlayerAI@@6B@

; 66   : 	AI_uninit();
; 67   : }

	jmp	??1CvPlayer@@UAE@XZ			; CvPlayer::~CvPlayer
??1CvPlayerAI@@UAE@XZ ENDP				; CvPlayerAI::~CvPlayerAI
_TEXT	ENDS
EXTRN	?ChangeNumFreeGreatPeople@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::ChangeNumFreeGreatPeople
EXTRN	?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z:PROC ; CvCityCitizens::DoSpawnGreatPerson
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
EXTRN	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ:PROC ; CvGrandStrategyAI::GetActiveGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?getEstimateEndTurn@CvGame@@QBEHXZ:PROC		; CvGame::getEstimateEndTurn
EXTRN	?GetWonderCompetitiveness@CvDiplomacyAI@@QBEHXZ:PROC ; CvDiplomacyAI::GetWonderCompetitiveness
EXTRN	?GetNumFreeGreatPeople@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetNumFreeGreatPeople
; Function compile flags: /Ogtpy
;	COMDAT ?AI_chooseFreeGreatPerson@CvPlayerAI@@UAEXXZ
_TEXT	SEGMENT
?AI_chooseFreeGreatPerson@CvPlayerAI@@UAEXXZ PROC	; CvPlayerAI::AI_chooseFreeGreatPerson, COMDAT
; _this$ = ecx

; 420  : {

	push	ebx
	mov	ebx, ecx

; 421  : 	while(GetNumFreeGreatPeople() > 0)

	call	?GetNumFreeGreatPeople@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreeGreatPeople
	test	eax, eax
	jle	$LN3@AI_chooseF
	push	esi
	push	edi
$LL14@AI_chooseF:

; 422  : 	{
; 423  : 		UnitTypes eDesiredGreatPerson = NO_UNIT;
; 424  : 
; 425  : 		// Highly wonder competitive and still early in game?
; 426  : 		if(GetDiplomacyAI()->GetWonderCompetitiveness() >= 8 && GC.getGame().getGameTurn() <= (GC.getGame().getEstimateEndTurn() / 2))

	mov	ecx, ebx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetWonderCompetitiveness@CvDiplomacyAI@@QBEHXZ ; CvDiplomacyAI::GetWonderCompetitiveness
	cmp	eax, 8
	jl	SHORT $LN12@AI_chooseF
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, ecx
	call	?getEstimateEndTurn@CvGame@@QBEHXZ	; CvGame::getEstimateEndTurn
	cdq
	sub	eax, edx
	mov	esi, eax
	mov	ecx, edi
	sar	esi, 1
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	eax, esi
	jg	SHORT $LN12@AI_chooseF

; 427  : 		{
; 428  : 			eDesiredGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_ENGINEER");

	push	0
	push	OFFSET $SG226304

; 429  : 		}
; 430  : 		else

	jmp	$LN24@AI_chooseF
$LN12@AI_chooseF:

; 431  : 		{
; 432  : 			// Pick the person based on our victory method
; 433  : 			AIGrandStrategyTypes eVictoryStrategy = GetGrandStrategyAI()->GetActiveGrandStrategy();

	mov	ecx, ebx
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy

; 434  : 			if(eVictoryStrategy == (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST"))

	push	0
	push	OFFSET $SG226309
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	esi, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 435  : 			{
; 436  : 				eDesiredGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_GREAT_GENERAL");

	push	0
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	cmp	esi, eax
	jne	SHORT $LN10@AI_chooseF
	push	OFFSET $SG226311
	jmp	SHORT $LN25@AI_chooseF
$LN10@AI_chooseF:

; 437  : 			}
; 438  : 			else if(eVictoryStrategy == (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE"))

	push	OFFSET $SG226315
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 439  : 			{
; 440  : 				eDesiredGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_ARTIST");

	push	0
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	cmp	esi, eax
	jne	SHORT $LN8@AI_chooseF
	push	OFFSET $SG226317
	jmp	SHORT $LN25@AI_chooseF
$LN8@AI_chooseF:

; 441  : 			}
; 442  : 			else if(eVictoryStrategy == (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_UNITED_NATIONS"))

	push	OFFSET $SG226321
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 443  : 			{
; 444  : 				eDesiredGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_MERCHANT");

	push	0
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	cmp	esi, eax
	jne	SHORT $LN6@AI_chooseF
	push	OFFSET $SG226323
	jmp	SHORT $LN25@AI_chooseF
$LN6@AI_chooseF:

; 445  : 			}
; 446  : 			else if(eVictoryStrategy == (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_SPACESHIP"))

	push	OFFSET $SG226327
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	esi, eax
	jne	SHORT $LN22@AI_chooseF

; 447  : 			{
; 448  : 				eDesiredGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_SCIENTIST");

	push	0
	push	OFFSET $SG226329
$LN24@AI_chooseF:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
$LN25@AI_chooseF:
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	esi, eax

; 449  : 			}
; 450  : 		}
; 451  : 
; 452  : 		if(eDesiredGreatPerson != NO_UNIT)

	cmp	esi, -1
	je	SHORT $LN22@AI_chooseF

; 453  : 		{
; 454  : 			CvCity* pCapital = getCapitalCity();

	mov	ecx, ebx
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 455  : 			if(pCapital)

	test	eax, eax
	je	SHORT $LN2@AI_chooseF

; 456  : 			{
; 457  : 				// NQMP GJS: AI should also get truly "free" Great People when the player would as well. Changed 2nd parameter below from true to false.
; 458  : 				pCapital->GetCityCitizens()->DoSpawnGreatPerson(eDesiredGreatPerson, false, false);

	push	0
	push	0
	push	esi
	mov	ecx, eax
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z ; CvCityCitizens::DoSpawnGreatPerson
$LN2@AI_chooseF:

; 459  : 			}
; 460  : 			ChangeNumFreeGreatPeople(-1);

	push	-1
	mov	ecx, ebx
	call	?ChangeNumFreeGreatPeople@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeNumFreeGreatPeople
	mov	ecx, ebx
	call	?GetNumFreeGreatPeople@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreeGreatPeople
	test	eax, eax
	jg	$LL14@AI_chooseF
$LN22@AI_chooseF:
	pop	edi
	pop	esi
$LN3@AI_chooseF:
	pop	ebx

; 461  : 		}
; 462  : 		else
; 463  : 		{
; 464  : 			break;
; 465  : 		}
; 466  : 	}
; 467  : }

	ret	0
?AI_chooseFreeGreatPerson@CvPlayerAI@@UAEXXZ ENDP	; CvPlayerAI::AI_chooseFreeGreatPerson
_TEXT	ENDS
EXTRN	?GetMissionAIType@CvUnit@@QAE?AW4MissionAITypes@@XZ:PROC ; CvUnit::GetMissionAIType
EXTRN	?GetMissionAIPlot@CvUnit@@QAEPAVCvPlot@@XZ:PROC	; CvUnit::GetMissionAIPlot
; Function compile flags: /Ogtpy
;	COMDAT ?AI_plotTargetMissionAIs@CvPlayerAI@@UAEHPAVCvPlot@@W4MissionAITypes@@H@Z
_TEXT	SEGMENT
_iCount$ = -8						; size = 4
_iLoop$ = -4						; size = 4
_pPlot$ = 8						; size = 4
_eMissionAI$ = 12					; size = 4
_iRange$ = 16						; size = 4
?AI_plotTargetMissionAIs@CvPlayerAI@@UAEHPAVCvPlot@@W4MissionAITypes@@H@Z PROC ; CvPlayerAI::AI_plotTargetMissionAIs, COMDAT
; _this$ = ecx

; 660  : {

	sub	esp, 8
	push	ebp
	push	esi
	push	edi

; 661  : 	int iCount = 0;

	xor	edi, edi

; 662  : 
; 663  : 	int iLoop;
; 664  : 	for(CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))

	push	edi
	lea	eax, DWORD PTR _iLoop$[esp+24]
	push	eax
	mov	ebp, ecx
	mov	DWORD PTR _iCount$[esp+28], edi
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN19@AI_plotTar
	push	ebx
	mov	ebx, DWORD PTR _pPlot$[esp+20]
$LL6@AI_plotTar:

; 665  : 	{
; 666  : 		CvPlot* pMissionPlot = pLoopUnit->GetMissionAIPlot();

	mov	ecx, esi
	call	?GetMissionAIPlot@CvUnit@@QAEPAVCvPlot@@XZ ; CvUnit::GetMissionAIPlot
	mov	edi, eax

; 667  : 		if(!pMissionPlot)

	test	edi, edi
	je	SHORT $LN5@AI_plotTar

; 668  : 		{
; 669  : 			continue;
; 670  : 		}
; 671  : 
; 672  : 		MissionAITypes eGroupMissionAI = pLoopUnit->GetMissionAIType();

	mov	ecx, esi
	call	?GetMissionAIType@CvUnit@@QAE?AW4MissionAITypes@@XZ ; CvUnit::GetMissionAIType

; 673  : 		if(eGroupMissionAI != eMissionAI)

	cmp	eax, DWORD PTR _eMissionAI$[esp+20]
	jne	SHORT $LN5@AI_plotTar

; 674  : 		{
; 675  : 			continue;
; 676  : 		}
; 677  : 
; 678  : 		int iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pMissionPlot->getX(), pMissionPlot->getY());
; 679  : 		if(iDistance == iRange)

	movsx	ecx, WORD PTR [edi+2]
	movsx	edx, WORD PTR [edi]
	movsx	eax, WORD PTR [ebx+2]
	push	ecx
	movsx	ecx, WORD PTR [ebx]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _iRange$[esp+20]
	jne	SHORT $LN5@AI_plotTar

; 680  : 		{
; 681  : 			iCount++;

	inc	DWORD PTR _iCount$[esp+24]
$LN5@AI_plotTar:

; 662  : 
; 663  : 	int iLoop;
; 664  : 	for(CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$[esp+28]
	push	edx
	mov	ecx, ebp
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL6@AI_plotTar

; 682  : 		}
; 683  : 	}
; 684  : 
; 685  : 	return iCount;

	mov	eax, DWORD PTR _iCount$[esp+24]
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 686  : }

	add	esp, 8
	ret	12					; 0000000cH
$LN19@AI_plotTar:

; 682  : 		}
; 683  : 	}
; 684  : 
; 685  : 	return iCount;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp

; 686  : }

	add	esp, 8
	ret	12					; 0000000cH
?AI_plotTargetMissionAIs@CvPlayerAI@@UAEHPAVCvPlot@@W4MissionAITypes@@H@Z ENDP ; CvPlayerAI::AI_plotTargetMissionAIs
_TEXT	ENDS
EXTRN	?Read@CvPlayer@@UAEXAAVFDataStream@@@Z:PROC	; CvPlayer::Read
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvPlayerAI@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvPlayerAI@@UAEXAAVFDataStream@@@Z PROC		; CvPlayerAI::Read, COMDAT
; _this$ = ecx

; 707  : {

	push	esi

; 708  : 	CvPlayer::Read(kStream);	// read base class data first

	mov	esi, DWORD PTR _kStream$[esp]
	push	esi
	call	?Read@CvPlayer@@UAEXAAVFDataStream@@@Z	; CvPlayer::Read

; 709  : 
; 710  : 	// Version number to maintain backwards compatibility
; 711  : 	uint uiVersion;
; 712  : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read
	pop	esi

; 713  : }

	ret	4
?Read@CvPlayerAI@@UAEXAAVFDataStream@@@Z ENDP		; CvPlayerAI::Read
_TEXT	ENDS
EXTRN	?Write@CvPlayer@@UBEXAAVFDataStream@@@Z:PROC	; CvPlayer::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvPlayerAI@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvPlayerAI@@UBEXAAVFDataStream@@@Z PROC		; CvPlayerAI::Write, COMDAT
; _this$ = ecx

; 721  : {

	push	esi

; 722  : 	CvPlayer::Write(kStream);	// write base class data first

	mov	esi, DWORD PTR _kStream$[esp]
	push	esi
	call	?Write@CvPlayer@@UBEXAAVFDataStream@@@Z	; CvPlayer::Write

; 723  : 
; 724  : 	// Current version number
; 725  : 	uint uiVersion = 1;
; 726  : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+4], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	pop	esi

; 727  : }

	ret	4
?Write@CvPlayerAI@@UBEXAAVFDataStream@@@Z ENDP		; CvPlayerAI::Write
_TEXT	ENDS
PUBLIC	?GetDirectiveArtist@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveArtist
EXTRN	?GetNumCivsInfluentialOn@CvPlayerCulture@@QBEHXZ:PROC ; CvPlayerCulture::GetNumCivsInfluentialOn
EXTRN	?isGoldenAge@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isGoldenAge
EXTRN	?GetNumberCivsAtWarWith@CvMilitaryAI@@QBEHXZ:PROC ; CvMilitaryAI::GetNumberCivsAtWarWith
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?IsTestStrategy_GS_SpaceshipHomestretch@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z:PROC ; EconomicAIHelpers::IsTestStrategy_GS_SpaceshipHomestretch
EXTRN	?IsGoingForSpaceshipVictory@CvDiplomacyAI@@QAE_NXZ:PROC ; CvDiplomacyAI::IsGoingForSpaceshipVictory
; Function compile flags: /Ogtpy
;	COMDAT ?GetDirectiveArtist@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_pGreatArtist$ = 8					; size = 4
?GetDirectiveArtist@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z PROC ; CvPlayerAI::GetDirectiveArtist, COMDAT
; _this$ = ecx

; 978  : {

	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 979  : 	GreatPeopleDirectiveTypes eDirective = NO_GREAT_PEOPLE_DIRECTIVE_TYPE;

	or	edi, -1

; 980  : 
; 981  : 	// Defend against ideology pressure if not going for culture win
; 982  : #ifdef AUI_WARNING_FIXES
; 983  : 	if (!GetDiplomacyAI()->IsGoingForCultureVictory() && GetCulture()->GetPublicOpinionUnhappiness() > 10)
; 984  : #else
; 985  : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && !GetDiplomacyAI()->IsGoingForCultureVictory() && GetCulture()->GetPublicOpinionUnhappiness() > 10)

	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForCultureVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForCultureVictory
	test	al, al
	jne	SHORT $LN14@GetDirecti@2
	mov	ecx, esi
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetPublicOpinionUnhappiness@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetPublicOpinionUnhappiness
	cmp	eax, 10					; 0000000aH

; 986  : #endif
; 987  : 	{
; 988  : 		eDirective = GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE;
; 989  : 	}
; 990  : 
; 991  : 	// If prepping for war, Golden Age will build units quickly
; 992  : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && !GetDiplomacyAI()->IsGoingForCultureVictory() && PreparingForWar(this))

	jg	$LN21@GetDirecti@2
$LN14@GetDirecti@2:
	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForCultureVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForCultureVictory
	test	al, al
	jne	SHORT $LN15@GetDirecti@2
	push	esi
	call	?PreparingForWar@@YA_NPAVCvPlayerAI@@@Z	; PreparingForWar
	add	esp, 4
	test	al, al

; 993  : 	{
; 994  : 		eDirective = GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE;
; 995  : 	}
; 996  : 
; 997  : 	// If finishing up spaceship parts, Golden Age will help build those quickly
; 998  : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && GetDiplomacyAI()->IsGoingForSpaceshipVictory() && EconomicAIHelpers::IsTestStrategy_GS_SpaceshipHomestretch(this))

	jne	SHORT $LN21@GetDirecti@2
$LN15@GetDirecti@2:
	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForSpaceshipVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForSpaceshipVictory
	test	al, al
	je	SHORT $LN16@GetDirecti@2
	push	esi
	call	?IsTestStrategy_GS_SpaceshipHomestretch@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_SpaceshipHomestretch
	add	esp, 4
	test	al, al

; 999  : 	{
; 1000 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE;
; 1001 : 	}
; 1002 : 
; 1003 : 	// If Persia and I'm at war, get a Golden Age going
; 1004 : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && GetPlayerTraits()->GetGoldenAgeMoveChange() > 0 && GetMilitaryAI()->GetNumberCivsAtWarWith() > 1 && !isGoldenAge())

	jne	SHORT $LN21@GetDirecti@2
$LN16@GetDirecti@2:
	mov	ecx, esi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	DWORD PTR [eax+176], 0
	jle	SHORT $LN17@GetDirecti@2
	mov	ecx, esi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetNumberCivsAtWarWith@CvMilitaryAI@@QBEHXZ ; CvMilitaryAI::GetNumberCivsAtWarWith
	cmp	eax, 1
	jle	SHORT $LN17@GetDirecti@2
	mov	ecx, esi
	call	?isGoldenAge@CvPlayer@@QBE_NXZ		; CvPlayer::isGoldenAge
	test	al, al

; 1005 : 	{
; 1006 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE;
; 1007 : 	}
; 1008 : 
; 1009 : 	// If Brazil and we're closing in on Culture Victory
; 1010 : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && GetPlayerTraits()->GetGoldenAgeTourismModifier() > 0 && GetCulture()->GetNumCivsInfluentialOn() > 0)

	je	SHORT $LN21@GetDirecti@2
$LN17@GetDirecti@2:
	mov	ecx, esi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	DWORD PTR [eax+184], 0
	jle	SHORT $LN3@GetDirecti@2
	mov	ecx, esi
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetNumCivsInfluentialOn@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetNumCivsInfluentialOn
	test	eax, eax
	jle	SHORT $LN3@GetDirecti@2
$LN21@GetDirecti@2:

; 1011 : 	{
; 1012 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE;

	xor	edi, edi
$LN3@GetDirecti@2:

; 1013 : 	}
; 1014 : 
; 1015 : 	// Create Great Work if there is a slot
; 1016 : 	GreatWorkType eGreatWork = pGreatArtist->GetGreatWork();

	mov	ebx, DWORD PTR _pGreatArtist$[esp+8]
	mov	ecx, ebx
	call	?GetGreatWork@CvUnit@@QBE?AW4GreatWorkType@@XZ ; CvUnit::GetGreatWork

; 1017 : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && GetEconomicAI()->GetBestGreatWorkCity(pGreatArtist->plot(), eGreatWork))

	cmp	edi, -1
	jne	SHORT $LN20@GetDirecti@2
	push	eax
	mov	ecx, ebx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, esi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z ; CvEconomicAI::GetBestGreatWorkCity
	test	eax, eax
	je	SHORT $LN18@GetDirecti@2

; 1018 : 	{
; 1019 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;

	lea	eax, DWORD PTR [edi+2]
	pop	edi
	pop	esi
	pop	ebx

; 1028 : }

	ret	4
$LN18@GetDirecti@2:

; 1020 : 	}
; 1021 : 
; 1022 : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && !isGoldenAge())

	mov	ecx, esi
	call	?isGoldenAge@CvPlayer@@QBE_NXZ		; CvPlayer::isGoldenAge
	test	al, al
	jne	SHORT $LN20@GetDirecti@2
	pop	edi
	pop	esi

; 1023 : 	{
; 1024 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE;

	xor	eax, eax
	pop	ebx

; 1028 : }

	ret	4
$LN20@GetDirecti@2:

; 1025 : 	}
; 1026 : 
; 1027 : 	return eDirective;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 1028 : }

	ret	4
?GetDirectiveArtist@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ENDP ; CvPlayerAI::GetDirectiveArtist
_TEXT	ENDS
PUBLIC	?GetDirectiveEngineer@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveEngineer
EXTRN	?getGameTurnCreated@CvUnit@@QBEHXZ:PROC		; CvUnit::getGameTurnCreated
EXTRN	?IsGoingForWorldConquest@CvDiplomacyAI@@QAE_NXZ:PROC ; CvDiplomacyAI::IsGoingForWorldConquest
EXTRN	?ChooseWonder@CvWonderProductionAI@@QAE?AW4BuildingTypes@@_N0AAH@Z:PROC ; CvWonderProductionAI::ChooseWonder
EXTRN	?GetWonderProductionAI@CvPlayer@@QBEPAVCvWonderProductionAI@@XZ:PROC ; CvPlayer::GetWonderProductionAI
; Function compile flags: /Ogtpy
;	COMDAT ?GetDirectiveEngineer@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_iNextWonderWeight$227136 = -4				; size = 4
_pGreatEngineer$ = 8					; size = 4
?GetDirectiveEngineer@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z PROC ; CvPlayerAI::GetDirectiveEngineer, COMDAT
; _this$ = ecx

; 1069 : {

	push	ecx
	push	ebx
	push	ebp

; 1070 : 	GreatPeopleDirectiveTypes eDirective = NO_GREAT_PEOPLE_DIRECTIVE_TYPE;
; 1071 : 
; 1072 : 	// look for a wonder to rush
; 1073 : 	if(eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE)
; 1074 : 	{
; 1075 : 		int iNextWonderWeight;
; 1076 : 		BuildingTypes eNextWonderDesired = GetWonderProductionAI()->ChooseWonder(false /*bUseAsyncRandom*/, false /*bAdjustForOtherPlayers*/, iNextWonderWeight);

	lea	eax, DWORD PTR _iNextWonderWeight$227136[esp+12]
	push	eax
	push	0
	push	0
	mov	ebx, ecx
	or	ebp, -1
	call	?GetWonderProductionAI@CvPlayer@@QBEPAVCvWonderProductionAI@@XZ ; CvPlayer::GetWonderProductionAI
	mov	ecx, eax
	call	?ChooseWonder@CvWonderProductionAI@@QAE?AW4BuildingTypes@@_N0AAH@Z ; CvWonderProductionAI::ChooseWonder

; 1077 : 		if(eNextWonderDesired != NO_BUILDING)

	cmp	eax, ebp
	je	SHORT $LN16@GetDirecti@3

; 1078 : 		{
; 1079 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;

	lea	eax, DWORD PTR [ebp+2]
	pop	ebp
	pop	ebx

; 1097 : }

	pop	ecx
	ret	4
$LN16@GetDirecti@3:

; 1080 : 		}
; 1081 : 	}
; 1082 : 
; 1083 : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && GC.getGame().getGameTurn() <= ((GC.getGame().getEstimateEndTurn() * 3) / 4))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	push	edi
	mov	edi, ecx
	call	?getEstimateEndTurn@CvGame@@QBEHXZ	; CvGame::getEstimateEndTurn
	lea	eax, DWORD PTR [eax+eax*2]
	cdq
	and	edx, 3
	add	eax, edx
	mov	esi, eax
	mov	ecx, edi
	sar	esi, 2
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	eax, esi
	jg	SHORT $LN17@GetDirecti@3

; 1084 : 	{
; 1085 : 		if (GetDiplomacyAI()->IsGoingForWorldConquest())

	mov	ecx, ebx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForWorldConquest@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForWorldConquest
	test	al, al
	je	SHORT $LN17@GetDirecti@3
	pop	edi
	pop	esi
	pop	ebp

; 1086 : 		{
; 1087 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT;

	mov	eax, 2
	pop	ebx

; 1097 : }

	pop	ecx
	ret	4
$LN17@GetDirecti@3:

; 1088 : 		}
; 1089 : 	}
; 1090 : 
; 1091 : 	if(eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && (GC.getGame().getGameTurn() - pGreatEngineer->getGameTurnCreated()) >= GC.getAI_HOMELAND_GREAT_PERSON_TURNS_TO_WAIT())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2700
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR _pGreatEngineer$[esp+16]
	mov	edi, eax
	call	?getGameTurnCreated@CvUnit@@QBEHXZ	; CvUnit::getGameTurnCreated
	sub	edi, eax
	cmp	edi, esi

; 1092 : 	{
; 1093 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT;

	mov	eax, 2
	jge	SHORT $LN19@GetDirecti@3

; 1094 : 	}
; 1095 : 
; 1096 : 	return eDirective;

	mov	eax, ebp
$LN19@GetDirecti@3:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1097 : }

	pop	ecx
	ret	4
?GetDirectiveEngineer@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ENDP ; CvPlayerAI::GetDirectiveEngineer
_TEXT	ENDS
PUBLIC	?GetDirectiveScientist@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveScientist
; Function compile flags: /Ogtpy
;	COMDAT ?GetDirectiveScientist@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?GetDirectiveScientist@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z PROC ; CvPlayerAI::GetDirectiveScientist, COMDAT
; _this$ = ecx

; 1146 : {

	push	ebx
	mov	ebx, ecx

; 1147 : 	GreatPeopleDirectiveTypes eDirective = NO_GREAT_PEOPLE_DIRECTIVE_TYPE;
; 1148 : 
; 1149 : 	// If I'm in danger, use great person to get a tech boost
; 1150 : #ifdef AUI_WARNING_FIXES
; 1151 : 	if (!IsSafe(this))
; 1152 : #else
; 1153 : 	if(eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && !IsSafe(this))

	push	ebx
	call	?IsSafe@@YA_NPAVCvPlayerAI@@@Z		; IsSafe
	add	esp, 4
	test	al, al

; 1154 : #endif
; 1155 : 	{
; 1156 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;
; 1157 : 	}
; 1158 : 
; 1159 : 	if(eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && GC.getGame().getGameTurn() <= ((GC.getGame().getEstimateEndTurn() * 1) / 4))

	je	SHORT $LN12@GetDirecti@4
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	push	edi
	mov	edi, ecx
	call	?getEstimateEndTurn@CvGame@@QBEHXZ	; CvGame::getEstimateEndTurn
	cdq
	and	edx, 3
	add	eax, edx
	mov	esi, eax
	mov	ecx, edi
	sar	esi, 2
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	pop	edi
	cmp	eax, esi
	pop	esi
	jg	SHORT $LN12@GetDirecti@4

; 1160 : 	{
; 1161 : 		if(GetDiplomacyAI()->IsGoingForSpaceshipVictory())

	mov	ecx, ebx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForSpaceshipVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForSpaceshipVictory
	test	al, al

; 1162 : 		{
; 1163 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT;

	mov	eax, 2
	jne	SHORT $LN1@GetDirecti@4
$LN12@GetDirecti@4:

; 1164 : 		}
; 1165 : 	}
; 1166 : 
; 1167 : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE)
; 1168 : 	{
; 1169 : 		// a tech boost is never bad
; 1170 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;

	mov	eax, 1
$LN1@GetDirecti@4:
	pop	ebx

; 1171 : 	}
; 1172 : 
; 1173 : 	return eDirective;
; 1174 : }

	ret	4
?GetDirectiveScientist@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ENDP ; CvPlayerAI::GetDirectiveScientist
_TEXT	ENDS
PUBLIC	?GreatMerchantWantsCash@CvPlayerAI@@QAE_NXZ	; CvPlayerAI::GreatMerchantWantsCash
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
; Function compile flags: /Ogtpy
;	COMDAT ?GreatMerchantWantsCash@CvPlayerAI@@QAE_NXZ
_TEXT	SEGMENT
?GreatMerchantWantsCash@CvPlayerAI@@QAE_NXZ PROC	; CvPlayerAI::GreatMerchantWantsCash, COMDAT
; _this$ = ecx

; 1270 : {

	push	esi
	mov	esi, ecx

; 1271 : 	// slewis - everybody wants cash . . .
; 1272 : 	// slewis - . . . except Venice. Venice wants to buy city states, unless it already has enough cities, then it doesn't want city states.
; 1273 : 	bool bIsVenice = GetPlayerTraits()->IsNoAnnexing();

	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits

; 1274 : 	if (bIsVenice)

	cmp	BYTE PTR [eax+351], 0
	je	SHORT $LN1@GreatMerch

; 1275 : 	{
; 1276 : 		if (getNumCities() >= 4)

	mov	ecx, esi
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, 4
	setge	al
	pop	esi

; 1287 : }

	ret	0
$LN1@GreatMerch:

; 1277 : 		{
; 1278 : 			return true;
; 1279 : 		}
; 1280 : 		else
; 1281 : 		{
; 1282 : 			return false;
; 1283 : 		}
; 1284 : 	}
; 1285 : 
; 1286 : 	return true;

	mov	al, 1
	pop	esi

; 1287 : }

	ret	0
?GreatMerchantWantsCash@CvPlayerAI@@QAE_NXZ ENDP	; CvPlayerAI::GreatMerchantWantsCash
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 147  : 		if(m_target) 

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	jmp	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@FObjectHan:

; 150  : 		}
; 151  : 	}

	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z PROC	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 156  : 	{

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx
	mov	BYTE PTR [esi+4], 0

; 157  : 		OBJECT_HANDLE_STACK;
; 158  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@2

; 159  : 		{
; 160  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@2:

; 161  : 		}
; 162  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ENDP	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 222  : 	{

	mov	eax, DWORD PTR _source$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx
	mov	dl, BYTE PTR [eax+4]
	mov	BYTE PTR [esi+4], dl

; 223  : 		OBJECT_HANDLE_STACK;
; 224  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@3

; 225  : 		{
; 226  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@3:

; 227  : 		}
; 228  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::iterator::iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 434  : 		iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 435  : 			{	// construct with null node pointer
; 436  : 			}

	ret	0
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 317  : 			}

	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ ; std::_Vector_val<CityAndProduction,std::allocator<CityAndProduction> >::~_Vector_val<CityAndProduction,std::allocator<CityAndProduction> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CityAndProduction,std::allocator<CityAndProduction> >::~_Vector_val<CityAndProduction,std::allocator<CityAndProduction> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CityAndProduction,std::allocator<CityAndProduction> >::~_Vector_val<CityAndProduction,std::allocator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Lmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [ecx+4]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::iterator::iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 459  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 460  : 			}

	ret	4
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAE@V?$allocator@UCityAndProduction@@@1@@Z ; std::_Vector_val<CityAndProduction,std::allocator<CityAndProduction> >::_Vector_val<CityAndProduction,std::allocator<CityAndProduction> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAE@V?$allocator@UCityAndProduction@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAE@V?$allocator@UCityAndProduction@@@1@@Z PROC ; std::_Vector_val<CityAndProduction,std::allocator<CityAndProduction> >::_Vector_val<CityAndProduction,std::allocator<CityAndProduction> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAE@V?$allocator@UCityAndProduction@@@1@@Z ENDP ; std::_Vector_val<CityAndProduction,std::allocator<CityAndProduction> >::_Vector_val<CityAndProduction,std::allocator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@PAUCityAndProduction@@@Z ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@PAUCityAndProduction@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@PAUCityAndProduction@@@Z PROC ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@PAUCityAndProduction@@@Z ENDP ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVCvAIOperation@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVCvAIOperation@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVCvAIOperation@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 265  : 			}

	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVCvAIOperation@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogtpy
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN3@Inc

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN34@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN17@Inc
	npad	7
$LL18@Inc:
	mov	edx, eax
	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL18@Inc
$LN17@Inc:
	mov	DWORD PTR [ecx], edx

; 405  : 				}
; 406  : 			}

	ret	0
$LN34@Inc:

; 398  : 			else
; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN1@Inc
$LL2@Inc:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL2@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [ecx], eax
$LN3@Inc:

; 405  : 				}
; 406  : 			}

	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEIXZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEIXZ PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEIXZ ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UCityAndProduction@@@std@@QAEPAUCityAndProduction@@I@Z ; std::allocator<CityAndProduction>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UCityAndProduction@@@std@@QAEPAUCityAndProduction@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UCityAndProduction@@@std@@QAEPAUCityAndProduction@@I@Z PROC ; std::allocator<CityAndProduction>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@UCityAndProduction@@@std@@YAPAUCityAndProduction@@IPAU1@@Z ; std::_Allocate<CityAndProduction>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@UCityAndProduction@@@std@@QAEPAUCityAndProduction@@I@Z ENDP ; std::allocator<CityAndProduction>::allocate
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator+=
_TEXT	ENDS
PUBLIC	??$fill@PAUCityAndProduction@@U1@@std@@YAXPAUCityAndProduction@@0ABU1@@Z ; std::fill<CityAndProduction *,CityAndProduction>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAUCityAndProduction@@U1@@std@@YAXPAUCityAndProduction@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUCityAndProduction@@U1@@std@@YAXPAUCityAndProduction@@0ABU1@@Z PROC ; std::fill<CityAndProduction *,CityAndProduction>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN3@fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAUCityAndProduction@@U1@@std@@YAXPAUCityAndProduction@@0ABU1@@Z ENDP ; std::fill<CityAndProduction *,CityAndProduction>
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator!=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator!=
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUCityAndProduction@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUCityAndProduction@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CityAndProduction *,CityAndProduction *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Move_backward_opt@PAUCityAndProduction@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUCityAndProduction@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUCityAndProduction@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUCityAndProduction@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CityAndProduction *,CityAndProduction *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw
	push	esi
$LL6@Move_backw:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw
	pop	esi
$LN5@Move_backw:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAUCityAndProduction@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUCityAndProduction@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CityAndProduction *,CityAndProduction *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UCityAndProduction@@@std@@QAEXPAUCityAndProduction@@ABU3@@Z ; std::allocator<CityAndProduction>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@UCityAndProduction@@@std@@QAEXPAUCityAndProduction@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UCityAndProduction@@@std@@QAEXPAUCityAndProduction@@ABU3@@Z PROC ; std::allocator<CityAndProduction>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@UCityAndProduction@@@std@@QAEXPAUCityAndProduction@@ABU3@@Z ENDP ; std::allocator<CityAndProduction>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UCityAndProduction@@@std@@QAEXPAUCityAndProduction@@@Z ; std::allocator<CityAndProduction>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@UCityAndProduction@@@std@@QAEXPAUCityAndProduction@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UCityAndProduction@@@std@@QAEXPAUCityAndProduction@@@Z PROC ; std::allocator<CityAndProduction>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@UCityAndProduction@@@std@@QAEXPAUCityAndProduction@@@Z ENDP ; std::allocator<CityAndProduction>::destroy
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@UCityAndProduction@@@std@@QAE@XZ ; std::_Temp_iterator<CityAndProduction>::~_Temp_iterator<CityAndProduction>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$_Temp_iterator@UCityAndProduction@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Temp_iterator@UCityAndProduction@@@std@@QAE@XZ PROC ; std::_Temp_iterator<CityAndProduction>::~_Temp_iterator<CityAndProduction>, COMDAT
; _this$ = ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN9@Temp_itera

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;
; 549  : 				_Next != _Buf._Hiwater; ++_Next)
; 550  : 				_Destroy(&*_Next);
; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN9@Temp_itera:

; 552  : 			}
; 553  : 		}

	ret	0
??1?$_Temp_iterator@UCityAndProduction@@@std@@QAE@XZ ENDP ; std::_Temp_iterator<CityAndProduction>::~_Temp_iterator<CityAndProduction>
_TEXT	ENDS
PUBLIC	??$_Distance2@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance2@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int>, COMDAT

; 1867 : 
; 1868 :  #if _HAS_ITERATOR_DEBUGGING
; 1869 : 	if (_First != _Last)
; 1870 : 		{	// check for null pointers
; 1871 : 		_DEBUG_POINTER(_First);
; 1872 : 		_DEBUG_POINTER(_Last);
; 1873 : 		}
; 1874 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1875 : 
; 1876 : 	_Off += _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	ecx, 3
	add	DWORD PTR [eax], ecx

; 1877 : 	}

	ret	0
??$_Distance2@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int>
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@UCityAndProduction@@@std@@YA?AU?$pair@PAUCityAndProduction@@H@0@H@Z ; std::get_temporary_buffer<CityAndProduction>
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$get_temporary_buffer@UCityAndProduction@@@std@@YA?AU?$pair@PAUCityAndProduction@@H@0@H@Z
_TEXT	SEGMENT
$T231109 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T231113 = 12						; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@UCityAndProduction@@@std@@YA?AU?$pair@PAUCityAndProduction@@H@0@H@Z PROC ; std::get_temporary_buffer<CityAndProduction>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	sub	esp, 12					; 0000000cH
	push	esi

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	mov	esi, DWORD PTR __Count$[esp+12]
	test	esi, esi
	jg	SHORT $LN7@get_tempor

; 23   : 		_Count = 0;

	xor	esi, esi
$LN5@get_tempor:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN15@get_tempor
	npad	12
$LL4@get_tempor:

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	lea	edx, DWORD PTR [esi*8]
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	ecx, eax
	add	esp, 8
	test	ecx, ecx
	jne	SHORT $LN15@get_tempor
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	test	esi, esi
	jg	SHORT $LL4@get_tempor
$LN15@get_tempor:

; 30   : 			break;
; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 33   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN7@get_tempor:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	esi
	cmp	eax, 8
	jae	SHORT $LN5@get_tempor

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T231113[esp+12]
	push	eax
	lea	ecx, DWORD PTR $T231109[esp+20]
	mov	DWORD PTR $T231113[esp+16], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T231109[esp+20]
	push	ecx
	mov	DWORD PTR $T231109[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN18@get_tempor:
$LN17@get_tempor:
	int	3
??$get_temporary_buffer@UCityAndProduction@@@std@@YA?AU?$pair@PAUCityAndProduction@@H@0@H@Z ENDP ; std::get_temporary_buffer<CityAndProduction>
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >, COMDAT
; _this$ = ecx

; 314  : 	_Vector_iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 315  : 		{	// construct with null vector pointer
; 316  : 		}

	ret	0
??0?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEAAUCityAndProduction@@XZ ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEAAUCityAndProduction@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEAAUCityAndProduction@@XZ PROC ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBEAAUCityAndProduction@@XZ ENDP ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator*
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@UCityAndProduction@@@std@@QAE@ABV01@@Z ; std::_Temp_iterator<CityAndProduction>::_Temp_iterator<CityAndProduction>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$_Temp_iterator@UCityAndProduction@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Temp_iterator@UCityAndProduction@@@std@@QAE@ABV01@@Z PROC ; std::_Temp_iterator<CityAndProduction>::_Temp_iterator<CityAndProduction>, COMDAT
; _this$ = ecx

; 535  : 	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)

	mov	eax, ecx

; 536  : 		{	// construct from _Right (share active buffer)
; 537  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 538  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 539  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 540  : 		_Buf._Size = 0;

	mov	DWORD PTR [eax+12], ecx

; 541  : 		*this = _Right;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 542  : 		}

	ret	4
??0?$_Temp_iterator@UCityAndProduction@@@std@@QAE@ABV01@@Z ENDP ; std::_Temp_iterator<CityAndProduction>::_Temp_iterator<CityAndProduction>
_TEXT	ENDS
PUBLIC	??$_Advance@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Advance@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int>
_TEXT	ENDS
PUBLIC	??$iter_swap@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0@Z ; std::iter_swap<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0@Z PROC ; std::iter_swap<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	eax, DWORD PTR __Left$[esp-4]
	push	esi
	mov	edx, ecx
	mov	esi, eax
	cmp	eax, ecx
	je	SHORT $LN11@iter_swap
	push	ebx
	mov	ebx, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi], ebx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [edx], edi
	pop	edi
	mov	DWORD PTR [edx+4], eax
	pop	ebx
$LN11@iter_swap:
	pop	esi

; 595  : 	}

	ret	0
??$iter_swap@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0@Z ENDP ; std::iter_swap<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop
	push	esi
$LL6@Uninit_cop:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@Uninit_cop:
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop
	pop	esi
$LN4@Uninit_cop:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 8

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator++
_TEXT	ENDS
PUBLIC	??F?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??F?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator--, COMDAT
; _this$ = ecx

; 361  : 		{	// predecrement

	mov	eax, ecx

; 362  : 		--(*(_Mybase *)this);

	add	DWORD PTR [eax], -8			; fffffff8H

; 363  : 		return (*this);
; 364  : 		}

	ret	0
??F?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator--
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T231234 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ecx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp]
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T231234[esp+12], edi
	cmp	ecx, DWORD PTR __Last$[esp+8]
	je	SHORT $LN1@Copy_opt
	lea	esi, DWORD PTR [edi+8]
$LL13@Copy_opt:

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __Dest$[esp+24]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN26@Copy_opt
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR __Dest$[esp+24]
	add	DWORD PTR [eax+4], esi
	jmp	SHORT $LN2@Copy_opt
$LN26@Copy_opt:
	cmp	eax, edi
	je	SHORT $LN31@Copy_opt
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR __Dest$[esp+24]
$LN31@Copy_opt:
	add	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR __Dest$[esp+24]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
$LN2@Copy_opt:
	mov	ecx, DWORD PTR __First$[esp+8]
	add	ecx, esi
	mov	DWORD PTR __First$[esp+8], ecx
	cmp	ecx, DWORD PTR __Last$[esp+8]
	jne	SHORT $LL13@Copy_opt
$LN1@Copy_opt:

; 2473 : 	return (_Dest);

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	eax, DWORD PTR __Dest$[esp+24]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	cmp	eax, edi
	je	SHORT $LN53@Copy_opt
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN53@Copy_opt:
	pop	edi
	mov	eax, esi
	pop	esi

; 2474 : 	}

	pop	ecx
	ret	0
??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	je	SHORT $LN27@Copy_backw@2
	npad	6
$LL2@Copy_backw@2:

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Dest$[esp-4]
	sub	eax, 8
	sub	ecx, 8
	mov	DWORD PTR __Last$[esp-4], eax
	mov	DWORD PTR __Dest$[esp-4], ecx
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	jne	SHORT $LL2@Copy_backw@2

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2678 : 	}

	ret	0
$LN27@Copy_backw@2:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], ecx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$advance@PAUCityAndProduction@@H@std@@YAXAAPAUCityAndProduction@@H@Z ; std::advance<CityAndProduction *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$advance@PAUCityAndProduction@@H@std@@YAXAAPAUCityAndProduction@@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAUCityAndProduction@@H@std@@YAXAAPAUCityAndProduction@@H@Z PROC ; std::advance<CityAndProduction *,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@PAUCityAndProduction@@H@std@@YAXAAPAUCityAndProduction@@H@Z ENDP ; std::advance<CityAndProduction *,int>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	cmp	eax, DWORD PTR __Last$[esp-4]
	je	SHORT $LN28@Copy_opt@2
	mov	ecx, 8
	push	esi
$LL12@Copy_opt@2:

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi], edx
	mov	eax, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR __First$[esp]
	add	DWORD PTR __Dest$[esp], ecx
	add	eax, ecx
	mov	DWORD PTR __First$[esp], eax
	cmp	eax, DWORD PTR __Last$[esp]
	jne	SHORT $LL12@Copy_opt@2

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	ecx, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 2474 : 	}

	ret	0
$LN28@Copy_opt@2:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2474 : 	}

	ret	0
??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	edx, eax
	je	SHORT $LN15@Copy_backw@3
	push	esi
	npad	3
$LL2@Copy_backw@3:

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Dest$[esp]
	mov	esi, DWORD PTR [eax-8]
	sub	eax, 8
	sub	ecx, 8
	mov	DWORD PTR __Dest$[esp], ecx
	mov	DWORD PTR [ecx], esi
	mov	ecx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+4], ecx
	cmp	eax, edx
	jne	SHORT $LL2@Copy_backw@3

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [eax], edx
	pop	esi

; 2678 : 	}

	ret	0
$LN15@Copy_backw@3:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], ecx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_opt@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN16@Copy_opt@3
	push	esi
	mov	edx, 8
	push	edi
$LL3@Copy_opt@3:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi], esi
	mov	esi, DWORD PTR [eax+4]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi+4], esi
	add	DWORD PTR __Dest$[esp+4], edx
	add	eax, edx
	cmp	eax, ecx
	jne	SHORT $LL3@Copy_opt@3

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 2474 : 	}

	ret	0
$LN16@Copy_opt@3:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2474 : 	}

	ret	0
??$_Copy_opt@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	?GetID@CvUnit@@QBEHXZ				; CvUnit::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?GetID@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvUnit@@QBEHXZ PROC				; CvUnit::GetID, COMDAT
; _this$ = ecx

; 662  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+100]

; 663  : 	}

	ret	0
?GetID@CvUnit@@QBEHXZ ENDP				; CvUnit::GetID
_TEXT	ENDS
PUBLIC	?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ	; CvUnit::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ PROC		; CvUnit::getOwner, COMDAT
; _this$ = ecx

; 1046 : 		return m_eOwner.get();

	mov	eax, DWORD PTR [ecx+40]

; 1047 : 	}

	ret	0
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ENDP		; CvUnit::getOwner
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?GetNumUnitsNeededToBeBuilt@CvAIOperation@@QAEIXZ ; CvAIOperation::GetNumUnitsNeededToBeBuilt
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
;	COMDAT ?GetNumUnitsNeededToBeBuilt@CvAIOperation@@QAEIXZ
_TEXT	SEGMENT
?GetNumUnitsNeededToBeBuilt@CvAIOperation@@QAEIXZ PROC	; CvAIOperation::GetNumUnitsNeededToBeBuilt, COMDAT
; _this$ = ecx

; 237  : 		return m_viListOfUnitsWeStillNeedToBuild.size();

	mov	edx, DWORD PTR [ecx+28]
	sub	edx, DWORD PTR [ecx+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 238  : 	}

	ret	0
?GetNumUnitsNeededToBeBuilt@CvAIOperation@@QAEIXZ ENDP	; CvAIOperation::GetNumUnitsNeededToBeBuilt
_TEXT	ENDS
PUBLIC	?GetID@CvCity@@QBEHXZ				; CvCity::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?GetID@CvCity@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvCity@@QBEHXZ PROC				; CvCity::GetID, COMDAT
; _this$ = ecx

; 331  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+120]

; 332  : 	}

	ret	0
?GetID@CvCity@@QBEHXZ ENDP				; CvCity::GetID
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1092 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1093 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayerID$ = 8						; size = 4
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPlayer::getTeam, COMDAT

; 1173 : 		return CvPreGame::teamType(ePlayerID);

	mov	eax, DWORD PTR _ePlayerID$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN3@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1174 : 	}

	ret	0

; 1173 : 		return CvPreGame::teamType(ePlayerID);

$LN3@getTeam:
	or	eax, -1

; 1174 : 	}

	ret	0
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam@2:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ		; CvPlot::getTeam
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ PROC		; CvPlot::getTeam, COMDAT
; _this$ = ecx

; 232  : 		PlayerTypes playerID = getOwner();

	movsx	eax, BYTE PTR [ecx+4]

; 233  : 		if(playerID != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN2@getTeam@3

; 234  : 		{
; 235  : 			return CvPlayer::getTeam(playerID);

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN2@getTeam@3
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 240  : 		}
; 241  : 	}

	ret	0
$LN2@getTeam@3:

; 236  : 		}
; 237  : 		else
; 238  : 		{
; 239  : 			return NO_TEAM;

	or	eax, -1

; 240  : 		}
; 241  : 	}

	ret	0
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlot::getTeam
_TEXT	ENDS
PUBLIC	?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ	; CvPlot::getFeatureType
; Function compile flags: /Ogtpy
;	COMDAT ?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ
_TEXT	SEGMENT
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ PROC	; CvPlot::getFeatureType, COMDAT
; _this$ = ecx

; 435  : #ifdef AUI_WARNING_FIXES
; 436  : 		int f = m_eFeatureType;
; 437  : #else
; 438  : 		char f = m_eFeatureType;
; 439  : #endif
; 440  : 		return (FeatureTypes)f;

	movsx	eax, BYTE PTR [ecx+432]

; 441  : 	}

	ret	0
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ ENDP	; CvPlot::getFeatureType
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 620  : 	{

	mov	edx, ecx

; 621  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 622  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 623  : 		return m_bfRevealed.GetBit(eTeam);

	mov	ecx, DWORD PTR _eTeam$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5
	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4+8]
	pop	esi
	setne	al

; 624  : 	}

	ret	4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAABQAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Key
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAABQAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAABQAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Key, COMDAT

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAABQAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Key
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Root
; Function compile flags: /Ogtpy
;	COMDAT ?_Root@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Root, COMDAT
; _this$ = ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Root
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 459  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 460  : 			}

	ret	4
??0iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::max_size, COMDAT
; _this$ = ecx

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::max_size
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx+8]
	push	esi

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], esi

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	esi, DWORD PTR [eax]
	cmp	BYTE PTR [esi+17], 0
	jne	SHORT $LN5@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Lrotate:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx]
	push	esi

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], esi

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	esi, DWORD PTR [eax+8]
	cmp	BYTE PTR [esi+17], 0
	jne	SHORT $LN5@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Rrotate:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN2@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax

; 373  : 				}
; 374  : 			}

	ret	0
$LN9@Dec:

; 336  :    				if (_Isnil(_Ptr))
; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+17], 0
	jne	SHORT $LN43@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN24@Dec
	npad	1
$LL25@Dec:
	mov	edx, eax
	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL25@Dec
$LN24@Dec:
	mov	DWORD PTR [ecx], edx

; 373  : 				}
; 374  : 			}

	ret	0
$LN43@Dec:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN3@Dec
$LL4@Dec:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL4@Dec
$LN3@Dec:

; 358  : 				if (_Isnil(_Ptr))

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+17], 0
	jne	SHORT $LN1@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax
$LN1@Dec:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 194  : 	if(eDirection == NO_DIRECTION)

	mov	ecx, DWORD PTR _eDirection$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	ecx, -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebx, DWORD PTR _iY$[esp+12]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN99@plotDirect
	test	eax, eax
	jge	SHORT $LN19@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@plotDirect
$LN19@plotDirect:
	cmp	eax, ecx
	jl	SHORT $LN99@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@plotDirect
$LN99@plotDirect:
	mov	esi, eax
$LN21@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN101@plotDirect
	test	ebx, ebx
	jge	SHORT $LN29@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@plotDirect
$LN29@plotDirect:
	cmp	ebx, edi
	jl	SHORT $LN101@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@plotDirect
$LN101@plotDirect:
	mov	edx, ebx
$LN31@plotDirect:
	test	esi, esi
	jl	$LN59@plotDirect
	cmp	esi, ecx
	jge	$LN59@plotDirect
	test	edx, edx
	jl	$LN59@plotDirect
	cmp	edx, edi
	jge	$LN59@plotDirect
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
$LN2@plotDirect:

; 197  : 	}
; 198  : 	else
; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	mov	esi, DWORD PTR _iY$[esp+12]
	test	esi, esi
	jl	SHORT $LN47@plotDirect
	mov	eax, esi
	jmp	SHORT $LN103@plotDirect
$LN47@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN103@plotDirect:

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	mov	edi, DWORD PTR _iX$[esp+12]
	sar	eax, 1
	sub	edx, eax
	add	edi, edx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN55@plotDirect
	mov	eax, esi
	jmp	SHORT $LN104@plotDirect
$LN55@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN104@plotDirect:
	sar	eax, 1
	add	edi, eax

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	cmp	edi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	cmp	esi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN69@plotDirect
	test	edi, edi
	jge	SHORT $LN71@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN69@plotDirect
$LN71@plotDirect:
	cmp	edi, ecx
	jl	SHORT $LN69@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN69@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN100@plotDirect
	test	esi, esi
	jge	SHORT $LN81@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN83@plotDirect
$LN81@plotDirect:
	cmp	esi, ebx
	jl	SHORT $LN100@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN83@plotDirect
$LN100@plotDirect:
	mov	edx, esi
$LN83@plotDirect:
	test	edi, edi
	jl	SHORT $LN59@plotDirect
	cmp	edi, ecx
	jge	SHORT $LN59@plotDirect
	test	edx, edx
	jl	SHORT $LN59@plotDirect
	cmp	edx, ebx
	jge	SHORT $LN59@plotDirect
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

$LN59@plotDirect:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Ogtpy
;	COMDAT ??_ECvPlayerAI@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_ECvPlayerAI@@UAEPAXI@Z PROC				; CvPlayerAI::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1CvPlayerAI@@UAE@XZ		; CvPlayerAI::~CvPlayerAI
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	63236					; 0000f704H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector:
	mov	DWORD PTR [esi], OFFSET ??_7CvPlayerAI@@6B@
	call	??1CvPlayer@@UAE@XZ			; CvPlayer::~CvPlayer
	test	bl, 1
	je	SHORT $LN1@vector
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_ECvPlayerAI@@UAEPAXI@Z ENDP				; CvPlayerAI::`vector deleting destructor'
_TEXT	ENDS
EXTRN	?getTotalFoundValue@CvArea@@QBEHXZ:PROC		; CvArea::getTotalFoundValue
EXTRN	?isWater@CvArea@@QBE_NXZ:PROC			; CvArea::isWater
EXTRN	?getArea@CvMap@@QAEPAVCvArea@@H@Z:PROC		; CvMap::getArea
EXTRN	?GetSettlerSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForSettler@@XZ:PROC ; CvGame::GetSettlerSiteEvaluator
EXTRN	?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z:PROC ; CvPlot::setFoundValue
EXTRN	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z:PROC	; CvMap::nextArea
EXTRN	?setTotalFoundValue@CvArea@@QAEXH@Z:PROC	; CvArea::setTotalFoundValue
EXTRN	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z:PROC	; CvMap::firstArea
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
;	COMDAT ?AI_updateFoundValues@CvPlayerAI@@UAEX_N@Z
_TEXT	SEGMENT
tv256 = -20						; size = 4
_iLoop$ = -16						; size = 4
tv403 = -12						; size = 4
_this$ = -8						; size = 4
_iGoodEnoughToBeWorthOurTime$ = -4			; size = 4
tv435 = 8						; size = 4
_bStartingLoc$ = 8					; size = 1
?AI_updateFoundValues@CvPlayerAI@@UAEX_N@Z PROC		; CvPlayerAI::AI_updateFoundValues, COMDAT
; _this$ = ecx

; 169  : {

	sub	esp, 20					; 00000014H

; 170  : 	int iGoodEnoughToBeWorthOurTime = GC.getAI_STRATEGY_MINIMUM_SETTLE_FERTILITY();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2028
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebx, ecx

; 171  : 	int iLoop;
; 172  : 	const int iNumPlots = GC.getMap().numPlots();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	edi, DWORD PTR [ecx+4028]

; 173  : 	for(CvArea* pLoopArea = GC.getMap().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMap().nextArea(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$[esp+40]
	push	edx
	mov	DWORD PTR _this$[esp+44], ebx
	mov	DWORD PTR _iGoodEnoughToBeWorthOurTime$[esp+44], eax
	call	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::firstArea
	test	eax, eax
	je	SHORT $LN13@AI_updateF
$LL15@AI_updateF:

; 174  : 	{
; 175  : 		pLoopArea->setTotalFoundValue(0);

	push	0
	mov	ecx, eax
	call	?setTotalFoundValue@CvArea@@QAEXH@Z	; CvArea::setTotalFoundValue
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+40]
	push	eax
	call	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::nextArea
	test	eax, eax
	jne	SHORT $LL15@AI_updateF
$LN13@AI_updateF:

; 176  : 	}
; 177  : 
; 178  : 	const PlayerTypes eID = GetID();
; 179  : 	if(bStartingLoc)

	cmp	BYTE PTR _bStartingLoc$[esp+32], 0
	mov	ebp, DWORD PTR [ebx+44]
	je	SHORT $LN12@AI_updateF

; 180  : 	{
; 181  : 		for(int iI = 0; iI < iNumPlots; iI++)

	test	edi, edi
	jle	$LN5@AI_updateF
	xor	esi, esi
	npad	11
$LL11@AI_updateF:

; 182  : 		{
; 183  : 			GC.getMap().plotByIndexUnchecked(iI)->setFoundValue(eID, -1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [ecx+4068]
	push	-1
	push	ebp
	add	ecx, esi
	call	?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z ; CvPlot::setFoundValue
	add	esi, 484				; 000001e4H
	sub	edi, 1
	jne	SHORT $LL11@AI_updateF
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 210  : 			}
; 211  : 		}
; 212  : 	}
; 213  : }

	add	esp, 20					; 00000014H
	ret	4
$LN12@AI_updateF:

; 184  : 		}
; 185  : 	}
; 186  : 	else
; 187  : 	{
; 188  : 		const TeamTypes eTeam = getTeam();

	cmp	ebp, 63					; 0000003fH
	ja	SHORT $LN40@AI_updateF
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	eax, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [eax+ebp*4]
	jmp	SHORT $LN41@AI_updateF
$LN40@AI_updateF:
	or	esi, -1
$LN41@AI_updateF:

; 189  : 		GC.getGame().GetSettlerSiteEvaluator()->ComputeFlavorMultipliers(this);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetSettlerSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForSettler@@XZ ; CvGame::GetSettlerSiteEvaluator
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	push	ebx
	call	eax

; 190  : 		for (int iI = 0; iI < iNumPlots; iI++)

	test	edi, edi
	jle	$LN5@AI_updateF
	mov	ebx, esi
	shr	ebx, 5

; 193  : 
; 194  : 			if (pLoopPlot->isRevealed(eTeam))

	mov	ecx, ebx
	shl	ecx, 5
	mov	edx, ecx
	mov	ecx, esi
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR tv435[esp+32], 0
	mov	DWORD PTR tv256[esp+36], edi
	mov	DWORD PTR tv403[esp+36], eax
	jmp	SHORT $LN7@AI_updateF
	npad	9
$LL67@AI_updateF:

; 189  : 		GC.getGame().GetSettlerSiteEvaluator()->ComputeFlavorMultipliers(this);

	mov	eax, DWORD PTR tv403[esp+36]
$LN7@AI_updateF:

; 191  : 		{
; 192  : 			CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	esi, DWORD PTR [ecx+4068]
	add	esi, DWORD PTR tv435[esp+32]

; 193  : 
; 194  : 			if (pLoopPlot->isRevealed(eTeam))

	test	DWORD PTR [esi+ebx*4+8], eax
	je	SHORT $LN4@AI_updateF

; 195  : 			{
; 196  : 				const int iValue = GC.getGame().GetSettlerSiteEvaluator()->PlotFoundValue(pLoopPlot, this, NO_YIELD, false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetSettlerSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForSettler@@XZ ; CvGame::GetSettlerSiteEvaluator
	mov	ecx, DWORD PTR _this$[esp+36]
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+12]
	push	0
	push	-1
	push	ecx
	push	esi
	mov	ecx, eax
	call	edx
	mov	edi, eax

; 197  : 				pLoopPlot->setFoundValue(eID, iValue);

	push	edi
	push	ebp
	mov	ecx, esi
	call	?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z ; CvPlot::setFoundValue

; 198  : 				if (iValue >= iGoodEnoughToBeWorthOurTime)

	cmp	edi, DWORD PTR _iGoodEnoughToBeWorthOurTime$[esp+36]
	jl	SHORT $LN6@AI_updateF

; 199  : 				{
; 200  : 					CvArea* pLoopArea = GC.getMap().getArea(pLoopPlot->getArea());

	mov	esi, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	esi
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	esi, eax

; 201  : 					if(pLoopArea && !pLoopArea->isWater())

	test	esi, esi
	je	SHORT $LN6@AI_updateF
	mov	ecx, esi
	call	?isWater@CvArea@@QBE_NXZ		; CvArea::isWater
	test	al, al
	jne	SHORT $LN6@AI_updateF

; 202  : 					{
; 203  : 						pLoopArea->setTotalFoundValue(pLoopArea->getTotalFoundValue() + iValue);

	mov	ecx, esi
	call	?getTotalFoundValue@CvArea@@QBEHXZ	; CvArea::getTotalFoundValue
	add	eax, edi
	push	eax
	mov	ecx, esi
	call	?setTotalFoundValue@CvArea@@QAEXH@Z	; CvArea::setTotalFoundValue

; 204  : 					}
; 205  : 				}
; 206  : 			}
; 207  : 			else

	jmp	SHORT $LN6@AI_updateF
$LN4@AI_updateF:

; 208  : 			{
; 209  : 				pLoopPlot->setFoundValue(eID, -1);

	push	-1
	push	ebp
	mov	ecx, esi
	call	?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z ; CvPlot::setFoundValue
$LN6@AI_updateF:
	add	DWORD PTR tv435[esp+32], 484		; 000001e4H
	sub	DWORD PTR tv256[esp+36], 1
	jne	$LL67@AI_updateF
$LN5@AI_updateF:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 210  : 			}
; 211  : 		}
; 212  : 	}
; 213  : }

	add	esp, 20					; 00000014H
	ret	4
?AI_updateFoundValues@CvPlayerAI@@UAEX_N@Z ENDP		; CvPlayerAI::AI_updateFoundValues
_TEXT	ENDS
EXTRN	?RecruitUnits@CvHomelandAI@@QAEXXZ:PROC		; CvHomelandAI::RecruitUnits
EXTRN	?Update@CvTacticalAI@@QAEXXZ:PROC		; CvTacticalAI::Update
EXTRN	?CommandeerUnits@CvTacticalAI@@QAEXXZ:PROC	; CvTacticalAI::CommandeerUnits
EXTRN	?Update@CvHomelandAI@@QAEXXZ:PROC		; CvHomelandAI::Update
EXTRN	?FindAutomatedUnits@CvHomelandAI@@QAEXXZ:PROC	; CvHomelandAI::FindAutomatedUnits
EXTRN	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ:PROC ; CvPlayer::GetHomelandAI
EXTRN	?dispatchingNetMessage@CvUnit@@SAX_N@Z:PROC	; CvUnit::dispatchingNetMessage
EXTRN	?hasBusyUnitOrCity@CvPlayer@@QBE_NXZ:PROC	; CvPlayer::hasBusyUnitOrCity
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallHook
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	?getInfluenceFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::getInfluenceFinder
EXTRN	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ:PROC ; CvGlobals::GetTacticalAnalysisMapFinder
EXTRN	?GetWaterRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::GetWaterRouteFinder
EXTRN	?getRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::getRouteFinder
EXTRN	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ:PROC ; CvGlobals::getIgnoreUnitsPathFinder
EXTRN	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ:PROC ; CvGlobals::getPathFinder
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.h
xdata$x	SEGMENT
__unwindtable$?AI_unitUpdate@CvPlayerAI@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AI_unitUpdate@CvPlayerAI@@UAEXXZ$0
__ehfuncinfo$?AI_unitUpdate@CvPlayerAI@@UAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AI_unitUpdate@CvPlayerAI@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
xdata$x	ENDS
;	COMDAT ?AI_unitUpdate@CvPlayerAI@@UAEXXZ
_TEXT	SEGMENT
tv426 = -23						; size = 1
tv432 = -22						; size = 1
tv438 = -21						; size = 1
tv444 = -20						; size = 1
tv450 = -19						; size = 1
tv456 = -18						; size = 1
_bResult$226238 = -17					; size = 1
_args$226237 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?AI_unitUpdate@CvPlayerAI@@UAEXXZ PROC			; CvPlayerAI::AI_unitUpdate, COMDAT
; _this$ = ecx

; 217  : {

	push	-1
	push	__ehhandler$?AI_unitUpdate@CvPlayerAI@@UAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	edi
	mov	edi, ecx

; 218  : 	GC.getPathFinder().ForceReset();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	ebx, 1

; 219  : 	GC.getIgnoreUnitsPathFinder().ForceReset();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR [eax+78], bl
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder

; 220  : 	GC.getRouteFinder().ForceReset();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR [eax+78], bl
	call	?getRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getRouteFinder

; 221  : 	GC.GetWaterRouteFinder().ForceReset();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR [eax+78], bl
	call	?GetWaterRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetWaterRouteFinder

; 222  : 
; 223  : 	// Set individual pathers as MP cache safe.  A global for all pathers might be simpler,
; 224  : 	// but this will allow selective control in case one type of pather is causing out-of-syncs.
; 225  : 	bool bCommonPathFinderMPCaching = GC.getPathFinder().SetMPCacheSafe(true);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR [eax+78], bl
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	cl, BYTE PTR [eax+79]
	mov	BYTE PTR tv426[esp+32], cl
	cmp	cl, bl
	je	SHORT $LN17@AI_unitUpd
	mov	BYTE PTR [eax+78], bl
	mov	BYTE PTR [eax+79], bl
$LN17@AI_unitUpd:

; 226  : 	bool bIgnoreUnitsPathFinderMPCaching = GC.getIgnoreUnitsPathFinder().SetMPCacheSafe(true);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	cl, BYTE PTR [eax+79]
	mov	BYTE PTR tv432[esp+32], cl
	cmp	cl, bl
	je	SHORT $LN20@AI_unitUpd
	mov	BYTE PTR [eax+78], bl
	mov	BYTE PTR [eax+79], bl
$LN20@AI_unitUpd:

; 227  : 	bool bTacticalPathFinderMPCaching = GC.GetTacticalAnalysisMapFinder().SetMPCacheSafe(true);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::GetTacticalAnalysisMapFinder
	mov	cl, BYTE PTR [eax+79]
	mov	BYTE PTR tv438[esp+32], cl
	cmp	cl, bl
	je	SHORT $LN23@AI_unitUpd
	mov	BYTE PTR [eax+78], bl
	mov	BYTE PTR [eax+79], bl
$LN23@AI_unitUpd:

; 228  : 	bool bInfluencePathFinderMPCaching = GC.getInfluenceFinder().SetMPCacheSafe(true);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfluenceFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getInfluenceFinder
	mov	cl, BYTE PTR [eax+79]
	mov	BYTE PTR tv444[esp+32], cl
	cmp	cl, bl
	je	SHORT $LN26@AI_unitUpd
	mov	BYTE PTR [eax+78], bl
	mov	BYTE PTR [eax+79], bl
$LN26@AI_unitUpd:

; 229  : 	bool bRoutePathFinderMPCaching = GC.getRouteFinder().SetMPCacheSafe(true);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getRouteFinder
	mov	cl, BYTE PTR [eax+79]
	mov	BYTE PTR tv450[esp+32], cl
	cmp	cl, bl
	je	SHORT $LN29@AI_unitUpd
	mov	BYTE PTR [eax+78], bl
	mov	BYTE PTR [eax+79], bl
$LN29@AI_unitUpd:

; 230  : 	bool bWaterRoutePathFinderMPCaching = GC.GetWaterRouteFinder().SetMPCacheSafe(true);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetWaterRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetWaterRouteFinder
	mov	cl, BYTE PTR [eax+79]
	mov	BYTE PTR tv456[esp+32], cl
	cmp	cl, bl
	je	SHORT $LN32@AI_unitUpd
	mov	BYTE PTR [eax+78], bl
	mov	BYTE PTR [eax+79], bl
$LN32@AI_unitUpd:

; 231  : 
; 232  : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	push	esi
	call	edx
	mov	esi, eax

; 233  : 	if(pkScriptSystem)

	test	esi, esi
	je	SHORT $LN5@AI_unitUpd

; 234  : 	{
; 235  : 		CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$226237[esp+36]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 236  : 		args->Push(GetID());

	mov	eax, DWORD PTR [edi+44]
	mov	ecx, DWORD PTR _args$226237[esp+36]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __$EHRec$[esp+48], 0
	call	eax

; 237  : 
; 238  : 		bool bResult;
; 239  : 		LuaSupport::CallHook(pkScriptSystem, "PlayerPreAIUnitUpdate", args.get(), bResult);

	mov	edx, DWORD PTR _args$226237[esp+36]
	lea	ecx, DWORD PTR _bResult$226238[esp+36]
	push	ecx
	push	edx
	push	OFFSET $SG226239
	push	esi
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 240  : 	}

	lea	ecx, DWORD PTR _args$226237[esp+36]
	mov	DWORD PTR __$EHRec$[esp+44], -1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN5@AI_unitUpd:

; 241  : 
; 242  : 	//GC.getGame().GetTacticalAnalysisMap()->RefreshDataForNextPlayer(this);
; 243  : 
; 244  : 	// this was a !hasBusyUnit around the entire rest of the function, so I tried to make it a bit flatter.
; 245  : 	if(hasBusyUnitOrCity())

	mov	ecx, edi
	call	?hasBusyUnitOrCity@CvPlayer@@QBE_NXZ	; CvPlayer::hasBusyUnitOrCity
	pop	esi
	test	al, al
	jne	$LN62@AI_unitUpd

; 246  : 	{
; 247  : 		return;
; 248  : 	}
; 249  : 
; 250  : 	if(isHuman())

	mov	ecx, edi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN3@AI_unitUpd

; 251  : 	{
; 252  : 		CvUnit::dispatchingNetMessage(true);

	push	ebx
	call	?dispatchingNetMessage@CvUnit@@SAX_N@Z	; CvUnit::dispatchingNetMessage
	add	esp, 4

; 253  : 		// The homeland AI goes first.
; 254  : 		GetHomelandAI()->FindAutomatedUnits();

	mov	ecx, edi
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?FindAutomatedUnits@CvHomelandAI@@QAEXXZ ; CvHomelandAI::FindAutomatedUnits

; 255  : 		GetHomelandAI()->Update();

	mov	ecx, edi
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?Update@CvHomelandAI@@QAEXXZ		; CvHomelandAI::Update

; 256  : 		CvUnit::dispatchingNetMessage(false);

	push	0
	call	?dispatchingNetMessage@CvUnit@@SAX_N@Z	; CvUnit::dispatchingNetMessage
	add	esp, 4

; 257  : 	}
; 258  : 	else

	jmp	SHORT $LN1@AI_unitUpd
$LN3@AI_unitUpd:

; 259  : 	{
; 260  : 		// Update tactical AI
; 261  : 		GetTacticalAI()->CommandeerUnits();

	mov	ecx, edi
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?CommandeerUnits@CvTacticalAI@@QAEXXZ	; CvTacticalAI::CommandeerUnits

; 262  : 
; 263  : 		// Now let the tactical AI run.  Putting it after the operations update allows units who have
; 264  : 		// just been handed off to the tactical AI to get a move in the same turn they switch between
; 265  : 		// AI subsystems
; 266  : 		GetTacticalAI()->Update();

	mov	ecx, edi
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?Update@CvTacticalAI@@QAEXXZ		; CvTacticalAI::Update

; 267  : 
; 268  : 		// Skip homeland AI processing if a barbarian
; 269  : 		if(m_eID != BARBARIAN_PLAYER)

	cmp	DWORD PTR [edi+44], 63			; 0000003fH
	je	SHORT $LN1@AI_unitUpd

; 270  : 		{
; 271  : 			// Now its the homeland AI's turn.
; 272  : 			GetHomelandAI()->RecruitUnits();

	mov	ecx, edi
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?RecruitUnits@CvHomelandAI@@QAEXXZ	; CvHomelandAI::RecruitUnits

; 273  : 			GetHomelandAI()->Update();

	mov	ecx, edi
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?Update@CvHomelandAI@@QAEXXZ		; CvHomelandAI::Update
$LN1@AI_unitUpd:

; 274  : 		}
; 275  : 	}
; 276  : 
; 277  : 	GC.getPathFinder().SetMPCacheSafe(bCommonPathFinderMPCaching);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	cl, BYTE PTR tv426[esp+32]
	cmp	cl, BYTE PTR [eax+79]
	je	SHORT $LN47@AI_unitUpd
	mov	BYTE PTR [eax+78], bl
	mov	BYTE PTR [eax+79], cl
$LN47@AI_unitUpd:

; 278  : 	GC.getIgnoreUnitsPathFinder().SetMPCacheSafe(bIgnoreUnitsPathFinderMPCaching);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	cl, BYTE PTR tv432[esp+32]
	cmp	cl, BYTE PTR [eax+79]
	je	SHORT $LN50@AI_unitUpd
	mov	BYTE PTR [eax+78], bl
	mov	BYTE PTR [eax+79], cl
$LN50@AI_unitUpd:

; 279  : 	GC.GetTacticalAnalysisMapFinder().SetMPCacheSafe(bTacticalPathFinderMPCaching);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::GetTacticalAnalysisMapFinder
	mov	cl, BYTE PTR tv438[esp+32]
	cmp	cl, BYTE PTR [eax+79]
	je	SHORT $LN53@AI_unitUpd
	mov	BYTE PTR [eax+78], bl
	mov	BYTE PTR [eax+79], cl
$LN53@AI_unitUpd:

; 280  : 	GC.getInfluenceFinder().SetMPCacheSafe(bInfluencePathFinderMPCaching);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfluenceFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getInfluenceFinder
	mov	cl, BYTE PTR tv444[esp+32]
	cmp	cl, BYTE PTR [eax+79]
	je	SHORT $LN56@AI_unitUpd
	mov	BYTE PTR [eax+78], bl
	mov	BYTE PTR [eax+79], cl
$LN56@AI_unitUpd:

; 281  : 	GC.getRouteFinder().SetMPCacheSafe(bRoutePathFinderMPCaching);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getRouteFinder
	mov	cl, BYTE PTR tv450[esp+32]
	cmp	cl, BYTE PTR [eax+79]
	je	SHORT $LN59@AI_unitUpd
	mov	BYTE PTR [eax+78], bl
	mov	BYTE PTR [eax+79], cl
$LN59@AI_unitUpd:

; 282  : 	GC.GetWaterRouteFinder().SetMPCacheSafe(bWaterRoutePathFinderMPCaching);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetWaterRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetWaterRouteFinder
	mov	cl, BYTE PTR tv456[esp+32]
	cmp	cl, BYTE PTR [eax+79]
	je	SHORT $LN62@AI_unitUpd
	mov	BYTE PTR [eax+78], bl
	mov	BYTE PTR [eax+79], cl
$LN62@AI_unitUpd:

; 283  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AI_unitUpdate@CvPlayerAI@@UAEXXZ$0:
	lea	ecx, DWORD PTR _args$226237[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?AI_unitUpdate@CvPlayerAI@@UAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?AI_unitUpdate@CvPlayerAI@@UAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?AI_unitUpdate@CvPlayerAI@@UAEXXZ ENDP			; CvPlayerAI::AI_unitUpdate
EXTRN	?DoCreatePuppet@CvCity@@QAEXXZ:PROC		; CvCity::DoCreatePuppet
EXTRN	?DoLiberatePlayer@CvPlayer@@QAEXW4PlayerTypes@@H@Z:PROC ; CvPlayer::DoLiberatePlayer
EXTRN	?IsGoingForDiploVictory@CvDiplomacyAI@@QAE_NXZ:PROC ; CvDiplomacyAI::IsGoingForDiploVictory
EXTRN	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsDoFAccepted
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::IsHasDefensivePact
EXTRN	?doTask@CvCity@@QAE?AW4CityTaskResult@@W4TaskTypes@@HH_N111@Z:PROC ; CvCity::doTask
EXTRN	?GetAIMapHint@CvMap@@QAEHXZ:PROC		; CvMap::GetAIMapHint
EXTRN	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::IsEmpireUnhappy
EXTRN	?canRaze@CvPlayer@@QBE_NPAVCvCity@@_N@Z:PROC	; CvPlayer::canRaze
EXTRN	?DoPossibleMinorLiberation@CvDiplomacyAI@@QAE_NW4PlayerTypes@@H@Z:PROC ; CvDiplomacyAI::DoPossibleMinorLiberation
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?CanLiberatePlayerCity@CvPlayer@@QAE_NW4PlayerTypes@@@Z:PROC ; CvPlayer::CanLiberatePlayerCity
EXTRN	?getOriginalOwner@CvCity@@QBE?AW4PlayerTypes@@XZ:PROC ; CvCity::getOriginalOwner
; Function compile flags: /Ogtpy
;	COMDAT ?AI_conquerCity@CvPlayerAI@@UAEXPAVCvCity@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
_eOldOwner$ = 12					; size = 4
?AI_conquerCity@CvPlayerAI@@UAEXPAVCvCity@@W4PlayerTypes@@@Z PROC ; CvPlayerAI::AI_conquerCity, COMDAT
; _this$ = ecx

; 287  : {

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 288  : 	PlayerTypes eOriginalOwner = pCity->getOriginalOwner();

	mov	ecx, DWORD PTR _pCity$[esp+8]
	push	edi
	call	?getOriginalOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ; CvCity::getOriginalOwner

; 289  : 	TeamTypes eOldOwnerTeam = GET_PLAYER(eOldOwner).getTeam();

	mov	ecx, DWORD PTR _eOldOwner$[esp+12]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ebx, eax
	mov	eax, ecx
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN25@AI_conquer
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN26@AI_conquer
$LN25@AI_conquer:
	or	ebp, -1
$LN26@AI_conquer:

; 290  : 
; 291  : 	// Liberate a city?
; 292  : 	if(eOriginalOwner != eOldOwner && eOriginalOwner != GetID() && CanLiberatePlayerCity(eOriginalOwner))

	cmp	ebx, ecx
	je	SHORT $LN77@AI_conquer
	cmp	ebx, DWORD PTR [esi+44]
	je	SHORT $LN77@AI_conquer
	push	ebx
	mov	ecx, esi
	call	?CanLiberatePlayerCity@CvPlayer@@QAE_NW4PlayerTypes@@@Z ; CvPlayer::CanLiberatePlayerCity
	test	al, al
	je	SHORT $LN77@AI_conquer

; 293  : 	{
; 294  : 		// minor civ
; 295  : 		if(GET_PLAYER(eOriginalOwner).isMinorCiv())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edi, ebx
	imul	edi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [edi+eax]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	$LN15@AI_conquer

; 296  : 		{
; 297  : 			if(GetDiplomacyAI()->DoPossibleMinorLiberation(eOriginalOwner, pCity->GetID()))

	mov	ecx, DWORD PTR _pCity$[esp+12]
	mov	eax, DWORD PTR [ecx+120]
	push	eax
	push	ebx
	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?DoPossibleMinorLiberation@CvDiplomacyAI@@QAE_NW4PlayerTypes@@H@Z ; CvDiplomacyAI::DoPossibleMinorLiberation
	test	al, al
	jne	$LN2@AI_conquer
$LN77@AI_conquer:

; 328  : 				return;
; 329  : 			}
; 330  : 		}
; 331  : 	}
; 332  : 
; 333  : 	// Do we want to burn this city down?
; 334  : 	if(canRaze(pCity))

	mov	edx, DWORD PTR _pCity$[esp+12]
	push	0
	push	edx
	mov	ecx, esi
	call	?canRaze@CvPlayer@@QBE_NPAVCvCity@@_N@Z	; CvPlayer::canRaze
	test	al, al
	je	$LN4@AI_conquer

; 335  : 	{
; 336  : 		// Burn the city if the empire is unhappy - keeping the city will only make things worse or if map hint dictates
; 337  : 		// Huns will burn down everything possible once they have a core of a few cities (was 3, but this put Attila out of the running long term as a conqueror)
; 338  : 		if (IsEmpireUnhappy() || (GC.getMap().GetAIMapHint() & 2) || (GetPlayerTraits()->GetRazeSpeedModifier() > 0 && getNumCities() >= 3 + (GC.getGame().getGameTurn() / 100)) )

	mov	ecx, esi
	call	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ	; CvPlayer::IsEmpireUnhappy
	test	al, al
	jne	SHORT $LN3@AI_conquer
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	test	al, 2
	jne	SHORT $LN3@AI_conquer
	mov	ecx, esi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	DWORD PTR [eax+256], 0
	jle	$LN4@AI_conquer
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	mov	ecx, esi
	lea	edi, DWORD PTR [edx+eax+3]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, edi
	jl	$LN4@AI_conquer
$LN3@AI_conquer:

; 339  : 		{
; 340  : 			pCity->doTask(TASK_RAZE);

	mov	ecx, DWORD PTR _pCity$[esp+12]
	push	0
	push	0
	push	0
	push	0
	push	-1
	push	-1
	push	0
	call	?doTask@CvCity@@QAE?AW4CityTaskResult@@W4TaskTypes@@HH_N111@Z ; CvCity::doTask
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 352  : #endif
; 353  : 	}
; 354  : }

	ret	8
$LN15@AI_conquer:

; 298  : 				return;
; 299  : 		}
; 300  : 		else // major civ
; 301  : 		{
; 302  : 			bool bLiberate = false;
; 303  : 			if (GET_PLAYER(eOriginalOwner).isAlive())

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [edi+edx+2256], 0
	lea	ecx, DWORD PTR [edi+edx]
	je	SHORT $LN12@AI_conquer

; 304  : 			{
; 305  : 				// If the original owner and this player have a defensive pact
; 306  : 				// and both the original owner and the player are at war with the old owner of this city
; 307  : 				// give the city back to the original owner
; 308  : 				TeamTypes eOriginalOwnerTeam = GET_PLAYER(eOriginalOwner).getTeam();

	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam

; 309  : 				if (GET_TEAM(getTeam()).IsHasDefensivePact(eOriginalOwnerTeam) && GET_TEAM(getTeam()).isAtWar(eOldOwnerTeam) && GET_TEAM(eOriginalOwnerTeam).isAtWar(eOldOwnerTeam))

	mov	ecx, esi
	mov	edi, eax
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	mov	ecx, eax
	call	?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasDefensivePact
	test	al, al
	je	SHORT $LN11@AI_conquer
	mov	ecx, esi
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebp
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN11@AI_conquer
	imul	edi, 2984				; 00000ba8H
	add	edi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebp
	mov	ecx, edi
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	SHORT $LN76@AI_conquer
$LN11@AI_conquer:

; 310  : 				{
; 311  : 					bLiberate = true;
; 312  : 				}
; 313  : 				// if the player is a friend and we're going for diplo victory, then liberate to score some friend points
; 314  : 				else if (GetDiplomacyAI()->IsDoFAccepted(eOriginalOwner) && GetDiplomacyAI()->IsGoingForDiploVictory())

	push	ebx
	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDoFAccepted
	test	al, al
	je	$LN77@AI_conquer

; 315  : 				{
; 316  : 					bLiberate = true;
; 317  : 				}
; 318  : 			}

	jmp	SHORT $LN79@AI_conquer
$LN12@AI_conquer:

; 319  : 			// if the player isn't human and we're going for diplo victory, resurrect players to get super diplo bonuses
; 320  : 			else if (!GET_PLAYER(eOriginalOwner).isHuman() && GetDiplomacyAI()->IsGoingForDiploVictory())

	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	$LN77@AI_conquer
$LN79@AI_conquer:
	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForDiploVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForDiploVictory
	test	al, al
	je	$LN77@AI_conquer
$LN76@AI_conquer:

; 321  : 			{
; 322  : 				bLiberate = true;
; 323  : 			}
; 324  : 
; 325  : 			if (bLiberate)
; 326  : 			{
; 327  : 				DoLiberatePlayer(eOriginalOwner, pCity->GetID());

	mov	eax, DWORD PTR _pCity$[esp+12]
	mov	ecx, DWORD PTR [eax+120]
	push	ecx
	push	ebx
	mov	ecx, esi
	call	?DoLiberatePlayer@CvPlayer@@QAEXW4PlayerTypes@@H@Z ; CvPlayer::DoLiberatePlayer
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 352  : #endif
; 353  : 	}
; 354  : }

	ret	8
$LN4@AI_conquer:

; 341  : 			return;
; 342  : 		}
; 343  : 	}
; 344  : 
; 345  : 	// Puppet the city
; 346  : 	if(pCity->getOriginalOwner() != GetID() || GET_PLAYER(m_eID).GetPlayerTraits()->IsNoAnnexing())

	mov	ebx, DWORD PTR _pCity$[esp+12]
	mov	edi, DWORD PTR [esi+44]
	mov	ecx, ebx
	call	?getOriginalOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ; CvCity::getOriginalOwner
	cmp	eax, edi
	jne	SHORT $LN1@AI_conquer
	mov	ecx, DWORD PTR [esi+44]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+351], 0
	je	SHORT $LN2@AI_conquer
$LN1@AI_conquer:

; 347  : 	{
; 348  : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 349  : 		pCity->DoCreatePuppet(false);
; 350  : #else
; 351  : 		pCity->DoCreatePuppet();

	mov	ecx, ebx
	call	?DoCreatePuppet@CvCity@@QAEXXZ		; CvCity::DoCreatePuppet
$LN2@AI_conquer:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 352  : #endif
; 353  : 	}
; 354  : }

	ret	8
?AI_conquerCity@CvPlayerAI@@UAEXPAVCvCity@@W4PlayerTypes@@@Z ENDP ; CvPlayerAI::AI_conquerCity
_TEXT	ENDS
PUBLIC	?AI_captureUnit@CvPlayerAI@@QAE_NW4UnitTypes@@PAVCvPlot@@@Z ; CvPlayerAI::AI_captureUnit
EXTRN	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z:PROC ; CvMap::findCity
EXTRN	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::IsFriendlyTerritory
; Function compile flags: /Ogtpy
;	COMDAT ?AI_captureUnit@CvPlayerAI@@QAE_NW4UnitTypes@@PAVCvPlot@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_pPlot$ = 12						; size = 4
?AI_captureUnit@CvPlayerAI@@QAE_NW4UnitTypes@@PAVCvPlot@@@Z PROC ; CvPlayerAI::AI_captureUnit, COMDAT
; _this$ = ecx

; 357  : {

	push	ebp
	mov	ebp, ecx

; 358  : 	CvCity* pNearestCity;
; 359  : 
; 360  : 	CvAssert(!isHuman());
; 361  : 
; 362  : 	// Barbs always capture
; 363  : 	if (isBarbarian())

	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	je	SHORT $LN8@AI_capture

; 364  : 		return true;

	mov	al, 1
	pop	ebp

; 396  : }

	ret	8
$LN8@AI_capture:
	push	ebx

; 365  : 
; 366  : 	// we own it
; 367  : 	if (pPlot->getTeam() == getTeam())

	mov	ebx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	push	esi
	mov	esi, DWORD PTR _pPlot$[esp+8]
	movsx	eax, BYTE PTR [esi+4]
	push	edi
	cmp	eax, -1
	je	SHORT $LN12@AI_capture
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN19@AI_capture
	mov	ecx, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	edi, ecx
	jmp	SHORT $LN11@AI_capture
$LN19@AI_capture:
	or	ecx, -1
	mov	edi, ecx
	jmp	SHORT $LN11@AI_capture
$LN12@AI_capture:
	or	edi, -1
$LN11@AI_capture:
	mov	edx, DWORD PTR [ebp+44]
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN28@AI_capture
	mov	ecx, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN29@AI_capture
$LN28@AI_capture:
	or	ecx, -1
$LN29@AI_capture:
	cmp	edi, ecx

; 368  : 		return true;

	je	$LN1@AI_capture

; 369  : 
; 370  : 	// no man's land - may as well
; 371  : 	if (pPlot->getTeam() == NO_TEAM)

	cmp	eax, -1
	je	$LN1@AI_capture
	cmp	eax, 63					; 0000003fH
	ja	$LN1@AI_capture
	mov	ecx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ecx+eax*4], -1

; 372  : 		return true;

	je	$LN1@AI_capture

; 373  : 
; 374  : 	// friendly, sure (okay, this is pretty much just means open borders)
; 375  : 	if (pPlot->IsFriendlyTerritory(GetID()))

	push	edx
	mov	ecx, esi
	call	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsFriendlyTerritory
	test	al, al

; 376  : 		return true;

	jne	$LN1@AI_capture

; 377  : 
; 378  : 	// not friendly, but "near" us
; 379  : 	pNearestCity = GC.getMap().findCity(pPlot->getX(), pPlot->getY(), NO_PLAYER, getTeam());

	mov	eax, DWORD PTR [ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN54@AI_capture
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN55@AI_capture
$LN54@AI_capture:
	or	edx, -1
$LN55@AI_capture:
	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	0
	push	-1
	push	-1
	push	0
	push	1
	push	edx
	push	-1
	push	eax
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ; CvMap::findCity

; 380  : 	if (pNearestCity != NULL)

	test	eax, eax
	je	SHORT $LN3@AI_capture

; 381  : 	{
; 382  : 		if (plotDistance(pPlot->getX(), pPlot->getY(), pNearestCity->getX(), pNearestCity->getY()) <= 7)

	mov	edx, DWORD PTR [eax+108]
	mov	eax, DWORD PTR [eax+96]
	movsx	ecx, WORD PTR [esi+2]
	push	edx
	movsx	edx, WORD PTR [esi]
	push	eax
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 7

; 383  : 			return true;

	jle	SHORT $LN1@AI_capture
$LN3@AI_capture:

; 384  : 	}
; 385  : 
; 386  : 	// very near someone we aren't friends with (and far from our nearest city)
; 387  : 	pNearestCity = GC.getMap().findCity(pPlot->getX(), pPlot->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	0
	push	-1
	push	-1
	push	0
	push	1
	push	-1
	push	-1
	push	eax
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ; CvMap::findCity

; 388  : 	if (pNearestCity != NULL)

	test	eax, eax
	je	SHORT $LN1@AI_capture

; 389  : 	{
; 390  : 		if (plotDistance(pPlot->getX(), pPlot->getY(), pNearestCity->getX(), pNearestCity->getY()) <= 4)

	mov	ecx, DWORD PTR [eax+108]
	mov	edx, DWORD PTR [eax+96]
	movsx	eax, WORD PTR [esi+2]
	push	ecx
	movsx	ecx, WORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 4
	jg	SHORT $LN1@AI_capture
	pop	edi
	pop	esi
	pop	ebx

; 391  : 			return false;

	xor	al, al
	pop	ebp

; 396  : }

	ret	8
$LN1@AI_capture:
	pop	edi
	pop	esi
	pop	ebx

; 392  : 	}
; 393  : 
; 394  : 	// I'd rather we grab it and run than destroy it
; 395  : 	return true;

	mov	al, 1
	pop	ebp

; 396  : }

	ret	8
?AI_captureUnit@CvPlayerAI@@QAE_NW4UnitTypes@@PAVCvPlot@@@Z ENDP ; CvPlayerAI::AI_captureUnit
_TEXT	ENDS
EXTRN	?GetStartSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForStart@@XZ:PROC ; CvGame::GetStartSiteEvaluator
; Function compile flags: /Ogtpy
;	COMDAT ?AI_foundValue@CvPlayerAI@@UAEHHHH_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
___formal$ = 16						; size = 4
_bStartingLoc$ = 20					; size = 1
?AI_foundValue@CvPlayerAI@@UAEHHHH_N@Z PROC		; CvPlayerAI::AI_foundValue, COMDAT
; _this$ = ecx

; 399  : {

	push	ecx

; 400  : 
; 401  : 	CvPlot* pPlot;
; 402  : 	int rtnValue = 0;
; 403  : 
; 404  : 	pPlot = GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+20], edi
	cmp	eax, -2147483647			; 80000001H
	je	$LN7@AI_foundVa
	mov	ebx, DWORD PTR _iY$[esp+16]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN7@AI_foundVa
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN52@AI_foundVa
	test	eax, eax
	jge	SHORT $LN19@AI_foundVa
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@AI_foundVa
$LN19@AI_foundVa:
	cmp	eax, ecx
	jl	SHORT $LN52@AI_foundVa
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@AI_foundVa
$LN52@AI_foundVa:
	mov	esi, eax
$LN21@AI_foundVa:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN53@AI_foundVa
	test	ebx, ebx
	jge	SHORT $LN29@AI_foundVa
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@AI_foundVa
$LN29@AI_foundVa:
	cmp	ebx, edi
	jl	SHORT $LN53@AI_foundVa
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@AI_foundVa
$LN53@AI_foundVa:
	mov	edx, ebx
$LN31@AI_foundVa:
	test	esi, esi
	jl	SHORT $LN11@AI_foundVa
	cmp	esi, ecx
	jge	SHORT $LN11@AI_foundVa
	test	edx, edx
	jl	SHORT $LN11@AI_foundVa
	cmp	edx, edi
	jge	SHORT $LN11@AI_foundVa
	mov	edi, DWORD PTR _this$[esp+20]
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	mov	esi, ecx
	jmp	SHORT $LN9@AI_foundVa
$LN11@AI_foundVa:
	mov	edi, DWORD PTR _this$[esp+20]
$LN7@AI_foundVa:
	xor	esi, esi
$LN9@AI_foundVa:

; 405  : 
; 406  : 	if(bStartingLoc)

	cmp	BYTE PTR _bStartingLoc$[esp+16], 0

; 407  : 	{
; 408  : 		rtnValue =  GC.getGame().GetStartSiteEvaluator()->PlotFoundValue(pPlot, this);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	je	SHORT $LN2@AI_foundVa
	call	?GetStartSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForStart@@XZ ; CvGame::GetStartSiteEvaluator
	push	1

; 409  : 	}
; 410  : 	else

	jmp	SHORT $LN54@AI_foundVa
$LN2@AI_foundVa:

; 411  : 	{
; 412  : 		GC.getGame().GetSettlerSiteEvaluator()->ComputeFlavorMultipliers(this);

	call	?GetSettlerSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForSettler@@XZ ; CvGame::GetSettlerSiteEvaluator
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	push	edi
	call	eax

; 413  : 		rtnValue =  GC.getGame().GetSettlerSiteEvaluator()->PlotFoundValue(pPlot, this, NO_YIELD, false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetSettlerSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForSettler@@XZ ; CvGame::GetSettlerSiteEvaluator
	push	0
$LN54@AI_foundVa:
	mov	edx, DWORD PTR [eax]
	push	-1
	push	edi
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+12]
	push	esi
	call	eax
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 414  : 	}
; 415  : 
; 416  : 	return rtnValue;
; 417  : }

	pop	ecx
	ret	16					; 00000010H
?AI_foundValue@CvPlayerAI@@UAEHHHH_N@Z ENDP		; CvPlayerAI::AI_foundValue
_TEXT	ENDS
EXTRN	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z:PROC ; CvTeam::setHasTech
EXTRN	?ChooseNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@_N@Z:PROC ; CvTechAI::ChooseNextTech
EXTRN	?GetTechAI@CvPlayerTechs@@QAEPAVCvTechAI@@XZ:PROC ; CvPlayerTechs::GetTechAI
EXTRN	?clearResearchQueue@CvPlayer@@QAEXXZ:PROC	; CvPlayer::clearResearchQueue
; Function compile flags: /Ogtpy
;	COMDAT ?AI_chooseFreeTech@CvPlayerAI@@UAEXXZ
_TEXT	SEGMENT
?AI_chooseFreeTech@CvPlayerAI@@UAEXXZ PROC		; CvPlayerAI::AI_chooseFreeTech, COMDAT
; _this$ = ecx

; 470  : {

	push	esi
	mov	esi, ecx

; 471  : 	TechTypes eBestTech = NO_TECH;
; 472  : 
; 473  : 	clearResearchQueue();

	call	?clearResearchQueue@CvPlayer@@QAEXXZ	; CvPlayer::clearResearchQueue

; 474  : 
; 475  : 	// TODO: script override
; 476  : 
; 477  : 	if(eBestTech == NO_TECH)
; 478  : 	{
; 479  : 		eBestTech = GetPlayerTechs()->GetTechAI()->ChooseNextTech(this, /*bFreeTech*/ true);

	push	1
	push	esi
	mov	ecx, esi
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetTechAI@CvPlayerTechs@@QAEPAVCvTechAI@@XZ ; CvPlayerTechs::GetTechAI
	mov	ecx, eax
	call	?ChooseNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@_N@Z ; CvTechAI::ChooseNextTech

; 480  : 	}
; 481  : 
; 482  : 	if(eBestTech != NO_TECH)

	cmp	eax, -1
	je	SHORT $LN1@AI_chooseF@2

; 483  : 	{
; 484  : 		GET_TEAM(getTeam()).setHasTech(eBestTech, true, GetID(), true, true);

	mov	esi, DWORD PTR [esi+44]
	cmp	esi, 63					; 0000003fH
	ja	SHORT $LN13@AI_chooseF@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+esi*4]
	jmp	SHORT $LN14@AI_chooseF@2
$LN13@AI_chooseF@2:
	or	ecx, -1
$LN14@AI_chooseF@2:
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	1
	push	1
	push	esi
	push	1
	push	eax
	call	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ; CvTeam::setHasTech
$LN1@AI_chooseF@2:
	pop	esi

; 485  : 	}
; 486  : }

	ret	0
?AI_chooseFreeTech@CvPlayerAI@@UAEXXZ ENDP		; CvPlayerAI::AI_chooseFreeTech
_TEXT	ENDS
EXTRN	?pushResearch@CvPlayer@@QAE_NW4TechTypes@@_N@Z:PROC ; CvPlayer::pushResearch
EXTRN	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z:PROC ; CvPlayerTechs::CanResearch
; Function compile flags: /Ogtpy
;	COMDAT ?AI_chooseResearch@CvPlayerAI@@UAEXXZ
_TEXT	SEGMENT
_iI$ = -4						; size = 4
?AI_chooseResearch@CvPlayerAI@@UAEXXZ PROC		; CvPlayerAI::AI_chooseResearch, COMDAT
; _this$ = ecx

; 490  : {

	push	ecx
	push	edi
	mov	edi, ecx

; 491  : #ifdef AUI_PERF_LOGGING_FORMATTING_TWEAKS
; 492  : 	AI_PERF_FORMAT("AI-perf.csv", ("AI_chooseResearch, Turn %03d, %s", GC.getGame().getGameTurn(), getCivilizationShortDescription()));
; 493  : #else
; 494  : 	AI_PERF("AI-perf.csv", "AI_chooseResearch");
; 495  : #endif
; 496  : 
; 497  : 	TechTypes eBestTech = NO_TECH;
; 498  : 	int iI;
; 499  : 
; 500  : 	clearResearchQueue();

	call	?clearResearchQueue@CvPlayer@@QAEXXZ	; CvPlayer::clearResearchQueue

; 501  : 
; 502  : 	if(GetPlayerTechs()->GetCurrentResearch() == NO_TECH)

	mov	ecx, edi
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
	cmp	eax, -1
	jne	$LN46@AI_chooseR
	push	ebx
	push	ebp
	push	esi

; 503  : 	{
; 504  : 		for(iI = 0; iI < MAX_PLAYERS; iI++)

	xor	esi, esi
	mov	DWORD PTR _iI$[esp+20], esi
	npad	7
$LL48@AI_chooseR:

; 505  : 		{
; 506  : 			if(GET_PLAYER((PlayerTypes)iI).isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [esi+eax+2256], 0
	lea	ebx, DWORD PTR [esi+eax]
	je	$LN9@AI_chooseR

; 507  : 			{
; 508  : 				if((iI != GetID()) && (GET_PLAYER((PlayerTypes)iI).getTeam() == getTeam()))

	mov	ecx, DWORD PTR _iI$[esp+20]
	cmp	ecx, DWORD PTR [edi+44]
	je	$LN9@AI_chooseR
	mov	eax, DWORD PTR [ebx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN30@AI_chooseR
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN31@AI_chooseR
$LN30@AI_chooseR:
	or	ebp, -1
$LN31@AI_chooseR:
	mov	ecx, edi
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	cmp	ebp, eax
	jne	SHORT $LN9@AI_chooseR

; 509  : 				{
; 510  : 					if(GET_PLAYER((PlayerTypes)iI).GetPlayerTechs()->GetCurrentResearch() != NO_TECH)

	mov	ecx, ebx
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
	cmp	eax, -1
	je	SHORT $LN9@AI_chooseR

; 511  : 					{
; 512  : 						if(GetPlayerTechs()->CanResearch(GET_PLAYER((PlayerTypes)iI).GetPlayerTechs()->GetCurrentResearch()))

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+edx]
	push	0
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
	push	eax
	mov	ecx, edi
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
	test	al, al
	je	SHORT $LN9@AI_chooseR

; 513  : 						{
; 514  : 							pushResearch(GET_PLAYER((PlayerTypes)iI).GetPlayerTechs()->GetCurrentResearch());

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	push	0
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
	push	eax
	mov	ecx, edi
	call	?pushResearch@CvPlayer@@QAE_NW4TechTypes@@_N@Z ; CvPlayer::pushResearch
$LN9@AI_chooseR:
	inc	DWORD PTR _iI$[esp+20]
	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	jl	$LL48@AI_chooseR
	pop	esi
	pop	ebp
	pop	ebx
$LN46@AI_chooseR:

; 515  : 						}
; 516  : 					}
; 517  : 				}
; 518  : 			}
; 519  : 		}
; 520  : 	}
; 521  : 
; 522  : 	if(GetPlayerTechs()->GetCurrentResearch() == NO_TECH)

	mov	ecx, edi
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
	cmp	eax, -1
	jne	SHORT $LN1@AI_chooseR

; 523  : 	{
; 524  : 		//todo: script override
; 525  : 
; 526  : 		if(eBestTech == NO_TECH)
; 527  : 		{
; 528  : 			eBestTech = GetPlayerTechs()->GetTechAI()->ChooseNextTech(this);

	push	0
	push	edi
	mov	ecx, edi
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetTechAI@CvPlayerTechs@@QAEPAVCvTechAI@@XZ ; CvPlayerTechs::GetTechAI
	mov	ecx, eax
	call	?ChooseNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@_N@Z ; CvTechAI::ChooseNextTech

; 529  : 		}
; 530  : 
; 531  : 		if(eBestTech != NO_TECH)

	cmp	eax, -1
	je	SHORT $LN1@AI_chooseR

; 532  : 		{
; 533  : 			pushResearch(eBestTech);

	push	0
	push	eax
	mov	ecx, edi
	call	?pushResearch@CvPlayer@@QAE_NW4TechTypes@@_N@Z ; CvPlayer::pushResearch
$LN1@AI_chooseR:
	pop	edi

; 534  : 		}
; 535  : 	}
; 536  : }

	pop	ecx
	ret	0
?AI_chooseResearch@CvPlayerAI@@UAEXXZ ENDP		; CvPlayerAI::AI_chooseResearch
_TEXT	ENDS
EXTRN	?launch@CvPlayer@@QAEXW4VictoryTypes@@@Z:PROC	; CvPlayer::launch
EXTRN	?canLaunch@CvTeam@@QBE_NW4VictoryTypes@@@Z:PROC	; CvTeam::canLaunch
EXTRN	?isHuman@CvTeam@@QBE_NXZ:PROC			; CvTeam::isHuman
; Function compile flags: /Ogtpy
;	COMDAT ?AI_launch@CvPlayerAI@@UAEXW4VictoryTypes@@@Z
_TEXT	SEGMENT
_eVictory$ = 8						; size = 4
?AI_launch@CvPlayerAI@@UAEXW4VictoryTypes@@@Z PROC	; CvPlayerAI::AI_launch, COMDAT
; _this$ = ecx

; 730  : {

	push	esi
	mov	esi, ecx

; 731  : 	if(GET_TEAM(getTeam()).isHuman())

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN9@AI_launch
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN10@AI_launch
$LN9@AI_launch:
	or	eax, -1
$LN10@AI_launch:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	test	al, al
	jne	SHORT $LN3@AI_launch

; 732  : 	{
; 733  : 		return;
; 734  : 	}
; 735  : 
; 736  : 	if(!GET_TEAM(getTeam()).canLaunch(eVictory))

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN20@AI_launch
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN21@AI_launch
$LN20@AI_launch:
	or	eax, -1
$LN21@AI_launch:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	mov	edi, DWORD PTR _eVictory$[esp+4]
	push	edi
	mov	ecx, eax
	call	?canLaunch@CvTeam@@QBE_NW4VictoryTypes@@@Z ; CvTeam::canLaunch
	test	al, al
	je	SHORT $LN27@AI_launch

; 737  : 	{
; 738  : 		return;
; 739  : 	}
; 740  : 
; 741  : 	launch(eVictory);

	push	edi
	mov	ecx, esi
	call	?launch@CvPlayer@@QAEXW4VictoryTypes@@@Z ; CvPlayer::launch
$LN27@AI_launch:
	pop	edi
$LN3@AI_launch:
	pop	esi

; 742  : }

	ret	4
?AI_launch@CvPlayerAI@@UAEXW4VictoryTypes@@@Z ENDP	; CvPlayerAI::AI_launch
_TEXT	ENDS
EXTRN	?AddUnit@CvArmyAI@@QAEXHH@Z:PROC		; CvArmyAI::AddUnit
EXTRN	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z:PROC	; CvPlayer::getArmyAI
; Function compile flags: /Ogtpy
;	COMDAT ?CityFinishedBuildingUnitForOperationSlot@CvPlayerAI@@UAEXUOperationSlot@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_thisSlot$ = 8						; size = 12
_pThisUnit$ = 20					; size = 4
?CityFinishedBuildingUnitForOperationSlot@CvPlayerAI@@UAEXUOperationSlot@@PAVCvUnit@@@Z PROC ; CvPlayerAI::CityFinishedBuildingUnitForOperationSlot, COMDAT
; _this$ = ecx

; 809  : 	// find this operation
; 810  : 	CvAIOperation* pThisOperation = getAIOperation(thisSlot.m_iOperationID);

	mov	eax, DWORD PTR _thisSlot$[esp-4]
	push	esi
	push	edi
	push	eax
	mov	edi, ecx
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation

; 811  : 	CvArmyAI* pThisArmy = getArmyAI(thisSlot.m_iArmyID);

	mov	ecx, DWORD PTR _thisSlot$[esp+8]
	push	ecx
	mov	ecx, edi
	mov	esi, eax
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI

; 812  : 	if(pThisOperation && pThisArmy && pThisUnit)

	test	esi, esi
	je	SHORT $LN1@CityFinish
	test	eax, eax
	je	SHORT $LN1@CityFinish
	mov	ecx, DWORD PTR _pThisUnit$[esp+4]
	test	ecx, ecx
	je	SHORT $LN1@CityFinish

; 813  : 	{
; 814  : 		pThisArmy->AddUnit(pThisUnit->GetID(), thisSlot.m_iSlotID);

	mov	edx, DWORD PTR _thisSlot$[esp+12]
	mov	ecx, DWORD PTR [ecx+100]
	push	edx
	push	ecx
	mov	ecx, eax
	call	?AddUnit@CvArmyAI@@QAEXHH@Z		; CvArmyAI::AddUnit

; 815  : 		pThisOperation->FinishedBuilding(thisSlot);

	mov	ecx, DWORD PTR _thisSlot$[esp+4]
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+108]
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _thisSlot$[esp+20]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR _thisSlot$[esp+24]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, esi
	call	edx
$LN1@CityFinish:

; 816  : 	}
; 817  : }

	pop	edi
	pop	esi
	ret	16					; 00000010H
?CityFinishedBuildingUnitForOperationSlot@CvPlayerAI@@UAEXUOperationSlot@@PAVCvUnit@@@Z ENDP ; CvPlayerAI::CityFinishedBuildingUnitForOperationSlot
_TEXT	ENDS
PUBLIC	?GetDirectiveGeneral@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveGeneral
EXTRN	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ:PROC ; CvUnit::GetGreatPeopleDirective
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
EXTRN	?getSpecialUnitType@CvUnit@@QBE?AW4SpecialUnitTypes@@XZ:PROC ; CvUnit::getSpecialUnitType
; Function compile flags: /Ogtpy
;	COMDAT ?GetDirectiveGeneral@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
_pGreatGeneral$ = 8					; size = 4
?GetDirectiveGeneral@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z PROC ; CvPlayerAI::GetDirectiveGeneral, COMDAT
; _this$ = ecx

; 1177 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1178 : 	GreatPeopleDirectiveTypes eDirective = NO_GREAT_PEOPLE_DIRECTIVE_TYPE;
; 1179 : 
; 1180 : 	SpecialUnitTypes eSpecialUnitGreatPerson = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_PEOPLE");

	push	0
	mov	edi, ecx
	push	OFFSET $SG227172
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ebp, eax

; 1181 : 
; 1182 : 	int iGreatGeneralCount = 0;

	xor	ebx, ebx

; 1183 : 
; 1184 : 	int iLoop;
; 1185 : 	for(CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))

	push	ebx
	lea	eax, DWORD PTR _iLoop$[esp+24]
	push	eax
	mov	ecx, edi
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN19@GetDirecti@5
	npad	1
$LL6@GetDirecti@5:

; 1186 : 	{
; 1187 : 		if(pLoopUnit->getSpecialUnitType() != eSpecialUnitGreatPerson)

	mov	ecx, esi
	call	?getSpecialUnitType@CvUnit@@QBE?AW4SpecialUnitTypes@@XZ ; CvUnit::getSpecialUnitType
	cmp	eax, ebp
	jne	SHORT $LN5@GetDirecti@5

; 1188 : 		{
; 1189 : 			continue;
; 1190 : 		}
; 1191 : 
; 1192 : 		if(pLoopUnit->AI_getUnitAIType() == UNITAI_GENERAL && pLoopUnit->GetGreatPeopleDirective() != GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE)

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN5@GetDirecti@5
	mov	ecx, esi
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective
	test	eax, eax
	je	SHORT $LN5@GetDirecti@5

; 1193 : 		{
; 1194 : 			iGreatGeneralCount++;

	inc	ebx
$LN5@GetDirecti@5:

; 1183 : 
; 1184 : 	int iLoop;
; 1185 : 	for(CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+24]
	push	ecx
	mov	ecx, edi
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL6@GetDirecti@5

; 1195 : 		}
; 1196 : 	}
; 1197 : 
; 1198 : 	if(iGreatGeneralCount > 2 && pGreatGeneral->plot()->getOwner() == pGreatGeneral->getOwner())

	cmp	ebx, 2
	jle	SHORT $LN19@GetDirecti@5
	mov	esi, DWORD PTR _pGreatGeneral$[esp+16]
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	edx, BYTE PTR [eax+4]
	cmp	edx, DWORD PTR [esi+40]
	jne	SHORT $LN19@GetDirecti@5
	pop	edi
	pop	esi
	pop	ebp

; 1199 : 	{
; 1200 : 		// we're using a power at this point because constructing the improvement goes through different code
; 1201 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;

	mov	eax, 1
	pop	ebx

; 1205 : }

	pop	ecx
	ret	4
$LN19@GetDirecti@5:
	pop	edi
	pop	esi
	pop	ebp

; 1202 : 	}
; 1203 : 
; 1204 : 	return eDirective;

	or	eax, -1
	pop	ebx

; 1205 : }

	pop	ecx
	ret	4
?GetDirectiveGeneral@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ENDP ; CvPlayerAI::GetDirectiveGeneral
_TEXT	ENDS
PUBLIC	?GetDirectiveProphet@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveProphet
EXTRN	?GetNumReligionsStillToFound@CvGameReligions@@QBEHXZ:PROC ; CvGameReligions::GetNumReligionsStillToFound
EXTRN	?ChooseProphetConversionCity@CvReligionAI@@QBEPAVCvCity@@_N@Z:PROC ; CvReligionAI::ChooseProphetConversionCity
EXTRN	?GetReligionAI@CvPlayer@@QBEPAVCvReligionAI@@XZ:PROC ; CvPlayer::GetReligionAI
EXTRN	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligion
EXTRN	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ:PROC ; CvGame::GetGameReligions
EXTRN	?GetReligionCreatedByPlayer@CvPlayerReligions@@QBE?AW4ReligionTypes@@XZ:PROC ; CvPlayerReligions::GetReligionCreatedByPlayer
EXTRN	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ:PROC ; CvPlayer::GetReligions
; Function compile flags: /Ogtpy
;	COMDAT ?GetDirectiveProphet@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?GetDirectiveProphet@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z PROC ; CvPlayerAI::GetDirectiveProphet, COMDAT
; _this$ = ecx

; 1208 : {

	push	esi
	mov	esi, ecx

; 1209 : 	GreatPeopleDirectiveTypes eDirective = NO_GREAT_PEOPLE_DIRECTIVE_TYPE;
; 1210 : 
; 1211 : 	ReligionTypes eReligion = GetReligions()->GetReligionCreatedByPlayer();

	call	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ ; CvPlayer::GetReligions
	mov	ecx, eax
	call	?GetReligionCreatedByPlayer@CvPlayerReligions@@QBE?AW4ReligionTypes@@XZ ; CvPlayerReligions::GetReligionCreatedByPlayer

; 1212 : 	const CvReligion* pMyReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, GetID());

	mov	ecx, DWORD PTR [esi+44]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion

; 1213 : 
; 1214 : 	// CASE 1: I have an enhanced religion
; 1215 : 	if (pMyReligion && pMyReligion->m_bEnhanced)

	test	eax, eax
	je	SHORT $LN6@GetDirecti@6
	cmp	BYTE PTR [eax+21], 0

; 1216 : 	{
; 1217 : 		// Spread religion if there is any city that needs it
; 1218 : 		if (GetReligionAI()->ChooseProphetConversionCity(false/*bOnlyBetterThanEnhancingReligion*/))

	mov	ecx, esi
	je	SHORT $LN10@GetDirecti@6
	push	0
	call	?GetReligionAI@CvPlayer@@QBEPAVCvReligionAI@@XZ ; CvPlayer::GetReligionAI
	mov	ecx, eax
	call	?ChooseProphetConversionCity@CvReligionAI@@QBEPAVCvCity@@_N@Z ; CvReligionAI::ChooseProphetConversionCity
	neg	eax
	sbb	eax, eax
	neg	eax
	add	eax, 2
	pop	esi

; 1248 : 		{
; 1249 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT;
; 1250 : 		}
; 1251 : 
; 1252 : 		// Not locked out
; 1253 : 		else
; 1254 : 		{
; 1255 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;
; 1256 : 		}
; 1257 : 	}
; 1258 : 
; 1259 : 	return eDirective;
; 1260 : }

	ret	4
$LN10@GetDirecti@6:

; 1219 : 		{
; 1220 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_SPREAD_RELIGION;
; 1221 : 		}
; 1222 : 		else
; 1223 : 		{
; 1224 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT;
; 1225 : 		}
; 1226 : 	}
; 1227 : 
; 1228 : 
; 1229 : 	// CASE 2: I have a religion that hasn't yet been enhanced
; 1230 : 	else if (pMyReligion)
; 1231 : 	{
; 1232 : 		// Spread religion if there is a city that needs it CRITICALLY
; 1233 : 		if (GetReligionAI()->ChooseProphetConversionCity(true/*bOnlyBetterThanEnhancingReligion*/))

	push	1
	call	?GetReligionAI@CvPlayer@@QBEPAVCvReligionAI@@XZ ; CvPlayer::GetReligionAI
	mov	ecx, eax
	call	?ChooseProphetConversionCity@CvReligionAI@@QBEPAVCvCity@@_N@Z ; CvReligionAI::ChooseProphetConversionCity
	neg	eax
	sbb	eax, eax
	and	eax, 2
	inc	eax
	pop	esi

; 1248 : 		{
; 1249 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT;
; 1250 : 		}
; 1251 : 
; 1252 : 		// Not locked out
; 1253 : 		else
; 1254 : 		{
; 1255 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;
; 1256 : 		}
; 1257 : 	}
; 1258 : 
; 1259 : 	return eDirective;
; 1260 : }

	ret	4
$LN6@GetDirecti@6:

; 1234 : 		{
; 1235 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_SPREAD_RELIGION;
; 1236 : 		}
; 1237 : 		else
; 1238 : 		{
; 1239 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;
; 1240 : 		}
; 1241 : 	}
; 1242 : 
; 1243 : 	// CASE 3: No religion for me yet
; 1244 : 	else
; 1245 : 	{
; 1246 : 		// Locked out?
; 1247 : 		if (GC.getGame().GetGameReligions()->GetNumReligionsStillToFound() <= 0)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetNumReligionsStillToFound@CvGameReligions@@QBEHXZ ; CvGameReligions::GetNumReligionsStillToFound
	xor	ecx, ecx
	test	eax, eax
	setle	cl
	pop	esi
	inc	ecx
	mov	eax, ecx

; 1248 : 		{
; 1249 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT;
; 1250 : 		}
; 1251 : 
; 1252 : 		// Not locked out
; 1253 : 		else
; 1254 : 		{
; 1255 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;
; 1256 : 		}
; 1257 : 	}
; 1258 : 
; 1259 : 	return eDirective;
; 1260 : }

	ret	4
?GetDirectiveProphet@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ENDP ; CvPlayerAI::GetDirectiveProphet
_TEXT	ENDS
PUBLIC	?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvPlayerAI::FindBestMerchantTargetPlot
EXTRN	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z:PROC ; TurnsToReachTarget
EXTRN	?GetWarGoal@CvDiplomacyAI@@QBE?AW4WarGoalTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetWarGoal
EXTRN	?GetMinorCivApproach@CvDiplomacyAI@@QBE?AW4MinorCivApproachTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetMinorCivApproach
EXTRN	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ:PROC ; CvPlayer::getStartingPlot
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z$0
__ehfuncinfo$?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
xdata$x	ENDS
;	COMDAT ?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z
_TEXT	SEGMENT
_bNotAtWar$227234 = -49					; size = 1
_iI$227223 = -48					; size = 4
_iBestTurnsToReach$ = -44				; size = 4
tv530 = -40						; size = 4
_pBestTargetPlot$ = -36					; size = 4
tv503 = -32						; size = 4
tv501 = -32						; size = 4
$T233092 = -32						; size = 4
_kTeam$ = -28						; size = 4
_pCSPlot$227230 = -24					; size = 4
_pMerchant$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
_pGreatMerchant$ = 8					; size = 4
_bOnlySafePaths$ = 12					; size = 1
?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z PROC ; CvPlayerAI::FindBestMerchantTargetPlot, COMDAT
; _this$ = ecx

; 1290 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 1291 : 	CvAssertMsg(pGreatMerchant, "pGreatMerchant is null");
; 1292 : 	if(!pGreatMerchant)

	mov	ecx, DWORD PTR _pGreatMerchant$[esp+64]
	xor	ebp, ebp
	cmp	ecx, ebp
	jne	SHORT $LN14@FindBestMe

; 1293 : 	{
; 1294 : 		return NULL;

	xor	eax, eax

; 1371 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 52					; 00000034H
	ret	8
$LN14@FindBestMe:

; 1295 : 	}
; 1296 : 
; 1297 : 	int iBestTurnsToReach = MAX_INT;

	mov	DWORD PTR _iBestTurnsToReach$[esp+68], 2147483647 ; 7fffffffH

; 1298 : 	CvPlot* pBestTargetPlot = NULL;

	mov	DWORD PTR _pBestTargetPlot$[esp+68], ebp

; 1299 : 	int iPathTurns;
; 1300 : 	UnitHandle pMerchant = UnitHandle(pGreatMerchant);

	mov	DWORD PTR _pMerchant$[esp+68], ecx
	mov	BYTE PTR _pMerchant$[esp+72], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 1301 : 	CvTeam& kTeam = GET_TEAM(getTeam());

	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR __$EHRec$[esp+76], ebp
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN28@FindBestMe
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN29@FindBestMe
$LN28@FindBestMe:
	or	eax, -1
$LN29@FindBestMe:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 1302 : 
; 1303 : 	//bool bIsVenice = GetPlayerTraits()->IsNoAnnexing();
; 1304 : 	//bool bWantsCash = GreatMerchantWantsCash();
; 1305 : 
; 1306 : 	// Loop through each city state
; 1307 : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$227223[esp+68], ebp
	mov	DWORD PTR _kTeam$[esp+68], eax
	mov	DWORD PTR tv530[esp+68], ebp
	npad	2
$LL13@FindBestMe:

; 1308 : 	{
; 1309 : 		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	esi, DWORD PTR [eax+ebp]

; 1310 : 		if (!kPlayer.isMinorCiv())

	mov	ecx, esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	$LN12@FindBestMe

; 1311 : 		{
; 1312 : 			continue;
; 1313 : 		}
; 1314 : 
; 1315 : 		// if I'm Venice, I don't want to send a Merchant of Venice to a buy a city that I have trade routes 
; 1316 : 		// with because it's probably more valuable as a trade partner than as an owned entity
; 1317 : 		//if (!bWantsCash)
; 1318 : 		//{
; 1319 : 		//	if (bIsVenice)
; 1320 : 		//	{
; 1321 : 		//		if (GetTrade()->IsConnectedToPlayer(kPlayer.GetID()))
; 1322 : 		//		{
; 1323 : 		//			continue;
; 1324 : 		//		}
; 1325 : 		//	}
; 1326 : 		//}
; 1327 : 
; 1328 : 		CvPlot* pCSPlot = kPlayer.getStartingPlot();

	mov	ecx, esi
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	mov	ebx, eax
	mov	DWORD PTR _pCSPlot$227230[esp+68], ebx

; 1329 : 		if (!pCSPlot)

	test	ebx, ebx
	je	$LN12@FindBestMe

; 1330 : 		{
; 1331 : 			continue;
; 1332 : 		}
; 1333 : 
; 1334 : 		if (!pCSPlot->isRevealed(getTeam()))

	mov	ecx, edi
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	edx, eax
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	DWORD PTR tv503[esp+68], ecx
	mov	ecx, eax
	mov	eax, DWORD PTR tv503[esp+68]
	sub	ecx, eax
	mov	eax, 1
	shl	eax, cl
	test	eax, DWORD PTR [ebx+edx*4+8]
	je	$LN12@FindBestMe

; 1335 : 		{
; 1336 : 			continue;
; 1337 : 		}
; 1338 : 
; 1339 : 		// Is this a minor we are friendly with?
; 1340 : 		bool bMinorCivApproachIsCorrect = (GetDiplomacyAI()->GetMinorCivApproach(kPlayer.GetID()) != MINOR_CIV_APPROACH_CONQUEST);

	mov	eax, DWORD PTR [esi+44]
	push	eax
	mov	ecx, edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMinorCivApproach@CvDiplomacyAI@@QBE?AW4MinorCivApproachTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMinorCivApproach
	cmp	eax, 3

; 1341 : 		bool bNotAtWar = !kTeam.isAtWar(kPlayer.getTeam());

	mov	eax, DWORD PTR [esi+44]
	setne	bl
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN49@FindBestMe
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN50@FindBestMe
$LN49@FindBestMe:
	or	eax, -1
$LN50@FindBestMe:
	mov	ecx, DWORD PTR _kTeam$[esp+68]
	push	eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar

; 1342 : 		bool bNotPlanningAWar = GetDiplomacyAI()->GetWarGoal(kPlayer.GetID()) == NO_WAR_GOAL_TYPE;

	mov	esi, DWORD PTR [esi+44]
	test	al, al
	push	esi
	mov	ecx, edi
	sete	BYTE PTR _bNotAtWar$227234[esp+72]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetWarGoal@CvDiplomacyAI@@QBE?AW4WarGoalTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarGoal
	cmp	eax, -1
	sete	al

; 1343 : 
; 1344 : 		if(bMinorCivApproachIsCorrect && bNotAtWar && bNotPlanningAWar)

	test	bl, bl
	je	$LN12@FindBestMe
	cmp	BYTE PTR _bNotAtWar$227234[esp+68], 0
	je	$LN12@FindBestMe
	test	al, al
	je	$LN12@FindBestMe

; 1345 : 		{
; 1346 : 			// Search all the plots adjacent to this city (since can't enter the minor city plot itself)
; 1347 : 			for(int jJ = 0; jJ < NUM_DIRECTION_TYPES; jJ++)

	xor	ebp, ebp
$LL6@FindBestMe:

; 1348 : 			{
; 1349 : 				CvPlot* pAdjacentPlot = plotDirection(pCSPlot->getX(), pCSPlot->getY(), ((DirectionTypes)jJ));

	mov	eax, DWORD PTR _pCSPlot$227230[esp+68]
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	push	ebp
	push	ecx
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 1350 : 				if(pAdjacentPlot != NULL)

	test	esi, esi
	je	SHORT $LN5@FindBestMe

; 1351 : 				{
; 1352 : 					// Make sure this is still owned by the city state and is revealed to us and isn't a water tile
; 1353 : 					//if(pAdjacentPlot->getOwner() == (PlayerTypes)iI && pAdjacentPlot->isRevealed(getTeam()) && !pAdjacentPlot->isWater())
; 1354 : 					bool bRightOwner = (pAdjacentPlot->getOwner() == (PlayerTypes)iI);

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, DWORD PTR _iI$227223[esp+68]

; 1355 : 					bool bIsRevealed = pAdjacentPlot->isRevealed(getTeam());

	mov	ecx, edi
	sete	bl
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	edx, eax
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	DWORD PTR tv501[esp+68], ecx
	mov	ecx, eax
	mov	eax, DWORD PTR tv501[esp+68]
	sub	ecx, eax
	mov	eax, 1
	shl	eax, cl
	test	eax, DWORD PTR [esi+edx*4+8]
	setne	al

; 1356 : 					if(bRightOwner && bIsRevealed)

	test	bl, bl
	je	SHORT $LN5@FindBestMe
	test	al, al
	je	SHORT $LN5@FindBestMe

; 1357 : 					{
; 1358 : 						iPathTurns = TurnsToReachTarget(pMerchant, pAdjacentPlot, true /*bReusePaths*/, !bOnlySafePaths/*bIgnoreUnits*/);

	cmp	BYTE PTR _bOnlySafePaths$[esp+64], 0
	push	0
	sete	cl
	movzx	edx, cl
	push	edx
	push	1
	push	esi
	sub	esp, 8
	lea	eax, DWORD PTR _pMerchant$[esp+92]
	mov	ecx, esp
	mov	DWORD PTR $T233092[esp+92], esp
	push	eax
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 1359 : 						if(iPathTurns < iBestTurnsToReach)

	cmp	eax, DWORD PTR _iBestTurnsToReach$[esp+68]
	jge	SHORT $LN5@FindBestMe

; 1360 : 						{
; 1361 : 							iBestTurnsToReach = iPathTurns;

	mov	DWORD PTR _iBestTurnsToReach$[esp+68], eax

; 1362 : 							pBestTargetPlot = pAdjacentPlot;

	mov	DWORD PTR _pBestTargetPlot$[esp+68], esi
$LN5@FindBestMe:
	inc	ebp
	cmp	ebp, 6
	jl	$LL6@FindBestMe

; 1345 : 		{
; 1346 : 			// Search all the plots adjacent to this city (since can't enter the minor city plot itself)
; 1347 : 			for(int jJ = 0; jJ < NUM_DIRECTION_TYPES; jJ++)

	mov	ebp, DWORD PTR tv530[esp+68]
$LN12@FindBestMe:

; 1302 : 
; 1303 : 	//bool bIsVenice = GetPlayerTraits()->IsNoAnnexing();
; 1304 : 	//bool bWantsCash = GreatMerchantWantsCash();
; 1305 : 
; 1306 : 	// Loop through each city state
; 1307 : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	inc	DWORD PTR _iI$227223[esp+68]
	add	ebp, 63236				; 0000f704H
	cmp	ebp, 4047104				; 003dc100H
	mov	DWORD PTR tv530[esp+68], ebp
	jl	$LL13@FindBestMe

; 1363 : 						}
; 1364 : 					}
; 1365 : 				}
; 1366 : 			}
; 1367 : 		}
; 1368 : 	}
; 1369 : 
; 1370 : 	return pBestTargetPlot;

	mov	ecx, DWORD PTR _pGreatMerchant$[esp+64]
	mov	DWORD PTR __$EHRec$[esp+76], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 1371 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	eax, DWORD PTR _pBestTargetPlot$[esp+68]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 52					; 00000034H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z$0:
	lea	ecx, DWORD PTR _pMerchant$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z ENDP ; CvPlayerAI::FindBestMerchantTargetPlot
PUBLIC	?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvPlayerAI::FindBestMusicianTargetPlot
EXTRN	?plotCity@@YAPAVCvPlot@@HHH@Z:PROC		; plotCity
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?GetCivLowestInfluence@CvPlayerCulture@@QBE?AW4PlayerTypes@@_N@Z:PROC ; CvPlayerCulture::GetCivLowestInfluence
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z$0
__ehfuncinfo$?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
xdata$x	ENDS
;	COMDAT ?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z
_TEXT	SEGMENT
_iBestTurnsToReach$ = -52				; size = 4
_iJ$227286 = -48					; size = 4
_jJ$227272 = -48					; size = 4
_eTargetPlayer$ = -44					; size = 4
_this$ = -40						; size = 4
_pBestTargetPlot$ = -36					; size = 4
tv503 = -32						; size = 4
$T233235 = -32						; size = 4
_iLoop$ = -28						; size = 4
tv501 = -24						; size = 4
$T233236 = -24						; size = 4
_kTargetPlayer$ = -24					; size = 4
_pMusician$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
_pBestTargetCity$ = 8					; size = 4
_pGreatMusician$ = 8					; size = 4
_bOnlySafePaths$ = 12					; size = 1
?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z PROC ; CvPlayerAI::FindBestMusicianTargetPlot, COMDAT
; _this$ = ecx

; 1374 : {

	push	-1
	push	__ehhandler$?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1375 : 	CvAssertMsg(pGreatMusician, "pGreatMusician is null");
; 1376 : 	if(!pGreatMusician)

	mov	edi, DWORD PTR _pGreatMusician$[esp+64]
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+68], esi
	test	edi, edi

; 1377 : 	{
; 1378 : 		return NULL;

	je	SHORT $LN92@FindBestMu

; 1379 : 	}
; 1380 : 
; 1381 : 	int iBestTurnsToReach = MAX_INT;
; 1382 : 	CvPlot* pBestTargetPlot = NULL;
; 1383 : 	CvCity* pBestTargetCity = NULL;
; 1384 : 	int iPathTurns;
; 1385 : 	UnitHandle pMusician = UnitHandle(pGreatMusician);

	mov	ecx, edi
	mov	DWORD PTR _iBestTurnsToReach$[esp+68], 2147483647 ; 7fffffffH
	mov	DWORD PTR _pBestTargetPlot$[esp+68], 0
	mov	DWORD PTR _pBestTargetCity$[esp+64], 0
	mov	DWORD PTR _pMusician$[esp+68], edi
	mov	BYTE PTR _pMusician$[esp+72], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 1386 : 
; 1387 : 	// Find target civ
; 1388 : 	PlayerTypes eTargetPlayer = GetCulture()->GetCivLowestInfluence(true /*bCheckOpenBorders*/);

	push	1
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+80], 0
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetCivLowestInfluence@CvPlayerCulture@@QBE?AW4PlayerTypes@@_N@Z ; CvPlayerCulture::GetCivLowestInfluence
	mov	DWORD PTR _eTargetPlayer$[esp+68], eax

; 1389 : 	if (eTargetPlayer == NO_PLAYER)

	cmp	eax, -1
	jne	SHORT $LN17@FindBestMu

; 1390 : 	{
; 1391 : 		return NULL;

	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+76], eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN92@FindBestMu:
	xor	eax, eax

; 1450 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 52					; 00000034H
	ret	8
$LN17@FindBestMu:

; 1392 : 	}
; 1393 : 
; 1394 : 	CvPlayer &kTargetPlayer = GET_PLAYER(eTargetPlayer);

	mov	ecx, eax
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 1395 : 
; 1396 : 	// Loop through each of that player's cities
; 1397 : 	int iLoop;
; 1398 : 	CvCity *pLoopCity;
; 1399 : 	for(pLoopCity = kTargetPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kTargetPlayer.nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[esp+72]
	push	eax
	mov	DWORD PTR _kTargetPlayer$[esp+76], ecx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebp, eax
	test	ebp, ebp
	je	$LN4@FindBestMu
$LN16@FindBestMu:

; 1400 : 	{
; 1401 : 		// Search all the plots adjacent to this city
; 1402 : 		for(int jJ = 0; jJ < NUM_DIRECTION_TYPES; jJ++)

	xor	edx, edx
	mov	DWORD PTR _jJ$227272[esp+68], edx
$LN13@FindBestMu:

; 1403 : 		{
; 1404 : 			CvPlot* pAdjacentPlot = plotDirection(pLoopCity->getX(), pLoopCity->getY(), ((DirectionTypes)jJ));

	mov	eax, DWORD PTR [ebp+108]
	mov	ecx, DWORD PTR [ebp+96]
	push	edx
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 1405 : 			if(pAdjacentPlot != NULL)

	test	esi, esi
	je	SHORT $LN12@FindBestMu

; 1406 : 			{
; 1407 : 				// Make sure this is still owned by target and is revealed to us
; 1408 : 				bool bRightOwner = (pAdjacentPlot->getOwner() == eTargetPlayer);

	movsx	ecx, BYTE PTR [esi+4]
	cmp	ecx, DWORD PTR _eTargetPlayer$[esp+68]

; 1409 : 				bool bIsRevealed = pAdjacentPlot->isRevealed(getTeam());

	mov	ecx, DWORD PTR _this$[esp+68]
	sete	bl
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	edx, eax
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	DWORD PTR tv503[esp+68], ecx
	mov	ecx, eax
	mov	eax, DWORD PTR tv503[esp+68]
	sub	ecx, eax
	mov	eax, 1
	shl	eax, cl
	test	eax, DWORD PTR [esi+edx*4+8]
	setne	al

; 1410 : 				if(bRightOwner && bIsRevealed)

	test	bl, bl
	je	SHORT $LN12@FindBestMu
	test	al, al
	je	SHORT $LN12@FindBestMu

; 1411 : 				{
; 1412 : 					iPathTurns = TurnsToReachTarget(pMusician, pAdjacentPlot, true /*bReusePaths*/, !bOnlySafePaths/*bIgnoreUnits*/);

	cmp	BYTE PTR _bOnlySafePaths$[esp+64], 0
	push	0
	sete	cl
	movzx	edx, cl
	push	edx
	push	1
	push	esi
	sub	esp, 8
	mov	eax, esp
	mov	ecx, edi
	mov	DWORD PTR $T233235[esp+92], esp
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 1413 : 					if(iPathTurns < iBestTurnsToReach)

	cmp	eax, DWORD PTR _iBestTurnsToReach$[esp+68]
	jge	SHORT $LN12@FindBestMu

; 1414 : 					{
; 1415 : 						iBestTurnsToReach = iPathTurns;

	mov	DWORD PTR _iBestTurnsToReach$[esp+68], eax

; 1416 : 						pBestTargetCity = pLoopCity;

	mov	DWORD PTR _pBestTargetCity$[esp+64], ebp
$LN12@FindBestMu:
	mov	edx, DWORD PTR _jJ$227272[esp+68]
	inc	edx
	cmp	edx, 6
	mov	DWORD PTR _jJ$227272[esp+68], edx
	jl	$LN13@FindBestMu
	mov	ecx, DWORD PTR _kTargetPlayer$[esp+68]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+72]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebp, eax
	test	ebp, ebp
	jne	$LN16@FindBestMu

; 1417 : 					}
; 1418 : 				}
; 1419 : 			}
; 1420 : 		}
; 1421 : 	}
; 1422 : 
; 1423 : 	// Found a city now look at ALL the plots owned by that player near that city
; 1424 : 	if (pBestTargetCity)

	mov	ecx, DWORD PTR _pBestTargetCity$[esp+64]
	test	ecx, ecx
	je	$LN4@FindBestMu

; 1425 : 	{
; 1426 : 		iBestTurnsToReach = MAX_INT;
; 1427 : 		CvPlot *pLoopPlot;
; 1428 : 		for(int iJ = 0; iJ < NUM_CITY_PLOTS; iJ++)

	xor	edx, edx
	mov	ebp, 2147483647				; 7fffffffH
	mov	DWORD PTR _iJ$227286[esp+68], edx
	jmp	SHORT $LN6@FindBestMu
	npad	4
$LL89@FindBestMu:
	mov	ecx, DWORD PTR _pBestTargetCity$[esp+64]
$LN6@FindBestMu:

; 1429 : 		{
; 1430 : 			pLoopPlot = plotCity(pBestTargetCity->getX(), pBestTargetCity->getY(), iJ);

	mov	eax, DWORD PTR [ecx+108]
	mov	ecx, DWORD PTR [ecx+96]
	push	edx
	push	eax
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 1431 : 			if(pLoopPlot != NULL)

	test	esi, esi
	je	SHORT $LN5@FindBestMu

; 1432 : 			{
; 1433 : 				// Make sure this is still owned by target and is revealed to us
; 1434 : 				bool bRightOwner = (pLoopPlot->getOwner() == eTargetPlayer);

	movsx	ecx, BYTE PTR [esi+4]
	cmp	ecx, DWORD PTR _eTargetPlayer$[esp+68]

; 1435 : 				bool bIsRevealed = pLoopPlot->isRevealed(getTeam());

	mov	ecx, DWORD PTR _this$[esp+68]
	sete	bl
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	edx, eax
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	DWORD PTR tv501[esp+68], ecx
	mov	ecx, eax
	mov	eax, DWORD PTR tv501[esp+68]
	sub	ecx, eax
	mov	eax, 1
	shl	eax, cl
	test	eax, DWORD PTR [esi+edx*4+8]
	setne	al

; 1436 : 				if(bRightOwner && bIsRevealed)

	test	bl, bl
	je	SHORT $LN5@FindBestMu
	test	al, al
	je	SHORT $LN5@FindBestMu

; 1437 : 				{
; 1438 : 					iPathTurns = TurnsToReachTarget(pMusician, pLoopPlot, true /*bReusePaths*/, !bOnlySafePaths/*bIgnoreUnits*/);

	cmp	BYTE PTR _bOnlySafePaths$[esp+64], 0
	push	0
	sete	cl
	movzx	edx, cl
	push	edx
	push	1
	push	esi
	sub	esp, 8
	mov	eax, esp
	mov	ecx, edi
	mov	DWORD PTR $T233236[esp+92], esp
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 1439 : 					if(iPathTurns < iBestTurnsToReach)

	cmp	eax, ebp
	jge	SHORT $LN5@FindBestMu

; 1440 : 					{
; 1441 : 						iBestTurnsToReach = iPathTurns;

	mov	ebp, eax

; 1442 : 						pBestTargetPlot = pLoopPlot;

	mov	DWORD PTR _pBestTargetPlot$[esp+68], esi
$LN5@FindBestMu:
	mov	edx, DWORD PTR _iJ$227286[esp+68]
	inc	edx
	cmp	edx, 37					; 00000025H
	mov	DWORD PTR _iJ$227286[esp+68], edx
	jl	$LL89@FindBestMu
$LN4@FindBestMu:

; 1443 : 					}
; 1444 : 				}
; 1445 : 			}	
; 1446 : 		}
; 1447 : 	}
; 1448 : 
; 1449 : 	return pBestTargetPlot;

	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+76], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 1450 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	eax, DWORD PTR _pBestTargetPlot$[esp+68]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 52					; 00000034H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z$0:
	lea	ecx, DWORD PTR _pMusician$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z ENDP ; CvPlayerAI::FindBestMusicianTargetPlot
PUBLIC	?FindBestArtistTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@AAH@Z ; CvPlayerAI::FindBestArtistTargetPlot
EXTRN	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z:PROC	; CvPlot::getYield
EXTRN	?GetResourceWeight@CvBuilderTaskingAI@@QAEHW4ResourceTypes@@W4ImprovementTypes@@H@Z:PROC ; CvBuilderTaskingAI::GetResourceWeight
EXTRN	?GetBuilderTaskingAI@CvPlayer@@QBEPAVCvBuilderTaskingAI@@XZ:PROC ; CvPlayer::GetBuilderTaskingAI
EXTRN	?getNumResource@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumResource
EXTRN	?GetLandDisputeLevel@CvDiplomacyAI@@QBE?AW4DisputeLevelTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetLandDisputeLevel
EXTRN	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z:PROC ; CvDiplomacyAI::GetMajorCivApproach
EXTRN	?GetCultureBombRadius@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetCultureBombRadius
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?isNoImprovement@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::isNoImprovement
EXTRN	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z:PROC ; CvGlobals::getFeatureInfo
EXTRN	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ:PROC ; CvResourceInfo::getResourceUsage
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?IsAdjacentOwnedByOtherTeam@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::IsAdjacentOwnedByOtherTeam
EXTRN	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ:PROC ; CvPlayer::GetPlots
; Function compile flags: /Ogtpy
;	COMDAT ?FindBestArtistTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@AAH@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_iBestScore$ = -24					; size = 4
_iI$227329 = -20					; size = 4
_ui$227307 = -16					; size = 4
_pBestPlot$ = -12					; size = 4
_m_aiPlots$ = -8					; size = 4
_nPlots$ = -4						; size = 4
_pPlot$227312 = 8					; size = 4
_pGreatArtist$ = 8					; size = 4
_iResultScore$ = 12					; size = 4
?FindBestArtistTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@AAH@Z PROC ; CvPlayerAI::FindBestArtistTargetPlot, COMDAT
; _this$ = ecx

; 1453 : {

	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi

; 1454 : 	CvAssertMsg(pGreatArtist, "pGreatArtist is null");
; 1455 : 	if(!pGreatArtist)

	xor	ebx, ebx
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+36], esi
	cmp	DWORD PTR _pGreatArtist$[esp+32], ebx
	jne	SHORT $LN31@FindBestAr
	pop	esi

; 1456 : 	{
; 1457 : 		return NULL;

	xor	eax, eax
	pop	ebx

; 1598 : }

	add	esp, 28					; 0000001cH
	ret	8
$LN31@FindBestAr:

; 1458 : 	}
; 1459 : 
; 1460 : 	iResultScore = 0;

	mov	eax, DWORD PTR _iResultScore$[esp+32]
	mov	DWORD PTR [eax], ebx

; 1461 : 
; 1462 : #ifndef AUI_WARNING_FIXES
; 1463 : 	CvPlotsVector& m_aiPlots = GetPlots();

	call	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ ; CvPlayer::GetPlots

; 1464 : #endif
; 1465 : 
; 1466 : 	CvPlot* pBestPlot = NULL;
; 1467 : 	int iBestScore = 0;
; 1468 : 
; 1469 : 	// loop through plots and wipe out ones that are invalid
; 1470 : 	const uint nPlots = m_aiPlots.size();

	mov	edx, DWORD PTR [eax+4]

; 1471 : 	for(uint ui = 0; ui < nPlots; ui++)

	xor	ecx, ecx
	mov	DWORD PTR _m_aiPlots$[esp+36], eax
	mov	DWORD PTR _pBestPlot$[esp+36], ebx
	mov	DWORD PTR _iBestScore$[esp+36], ebx
	mov	DWORD PTR _nPlots$[esp+36], edx
	mov	DWORD PTR _ui$227307[esp+36], ecx
	cmp	edx, ebx
	jbe	$LN28@FindBestAr
	push	ebp
	push	edi
	jmp	SHORT $LN30@FindBestAr
	npad	3
$LL107@FindBestAr:
	mov	eax, DWORD PTR _m_aiPlots$[esp+44]
	mov	esi, DWORD PTR _this$[esp+44]
	xor	ebx, ebx
$LN30@FindBestAr:

; 1472 : 	{
; 1473 : 		if(m_aiPlots[ui] == -1)

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+ecx*4]
	cmp	eax, -1
	je	$LN29@FindBestAr

; 1474 : 		{
; 1475 : 			continue;
; 1476 : 		}
; 1477 : 
; 1478 : 		CvPlot* pPlot = GC.getMap().plotByIndex(m_aiPlots[ui]);

	cmp	eax, ebx
	jl	SHORT $LN47@FindBestAr
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN47@FindBestAr
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	mov	edi, eax
	mov	DWORD PTR _pPlot$227312[esp+40], edi
	jmp	SHORT $LN48@FindBestAr
$LN47@FindBestAr:
	mov	DWORD PTR _pPlot$227312[esp+40], ebx
	mov	edi, ebx
$LN48@FindBestAr:

; 1479 : 
; 1480 : 		if(pPlot->isWater())

	cmp	BYTE PTR [edi+5], 3
	je	$LN29@FindBestAr

; 1481 : 		{
; 1482 : 			continue;
; 1483 : 		}
; 1484 : 
; 1485 : 		if(!pPlot->IsAdjacentOwnedByOtherTeam(getTeam()))

	mov	ecx, esi
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, edi
	call	?IsAdjacentOwnedByOtherTeam@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::IsAdjacentOwnedByOtherTeam
	test	al, al
	je	$LN29@FindBestAr

; 1486 : 		{
; 1487 : 			continue;
; 1488 : 		}
; 1489 : 
; 1490 : 		// don't build over luxury resources
; 1491 : 		ResourceTypes eResource = pPlot->getResourceType();

	push	-1
	mov	ecx, edi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType

; 1492 : 		if(eResource != NO_RESOURCE)

	cmp	eax, -1
	je	SHORT $LN101@FindBestAr

; 1493 : 		{
; 1494 : 			CvResourceInfo* pkResource = GC.getResourceInfo(eResource);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 1495 : 			if(pkResource != NULL)

	cmp	eax, ebx
	je	SHORT $LN101@FindBestAr

; 1496 : 			{
; 1497 : 				if (pkResource->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	je	$LN29@FindBestAr
$LN101@FindBestAr:

; 1498 : 				{
; 1499 : 					continue;
; 1500 : 				}
; 1501 : 			}
; 1502 : 		}
; 1503 : 
; 1504 : 		// if no improvement can be built on this plot, then don't consider it
; 1505 : 		FeatureTypes eFeature = pPlot->getFeatureType();

	movsx	eax, BYTE PTR [edi+432]

; 1506 : 		if (eFeature != NO_FEATURE && GC.getFeatureInfo(eFeature)->isNoImprovement())

	cmp	eax, -1
	je	SHORT $LN108@FindBestAr
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?isNoImprovement@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isNoImprovement
	test	al, al
	jne	$LN29@FindBestAr
$LN108@FindBestAr:

; 1507 : 		{
; 1508 : 			continue;
; 1509 : 		}
; 1510 : 
; 1511 : 		// Improvement already here?
; 1512 : 		ImprovementTypes eImprovement = (ImprovementTypes)pPlot->getImprovementType();

	mov	ecx, edi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType

; 1513 : 		if (eImprovement != NO_IMPROVEMENT)

	cmp	eax, -1
	je	SHORT $LN18@FindBestAr

; 1514 : 		{
; 1515 : 			CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo

; 1516 : 			if(pkImprovementInfo)

	cmp	eax, ebx
	je	SHORT $LN18@FindBestAr

; 1517 : 			{
; 1518 : 				if (pkImprovementInfo->GetCultureBombRadius() > 0)

	mov	ecx, eax
	call	?GetCultureBombRadius@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureBombRadius
	test	eax, eax
	jg	$LN29@FindBestAr
$LN18@FindBestAr:

; 1519 : 				{
; 1520 : 					continue;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		}
; 1524 : 
; 1525 : 		int iScore = 0;
; 1526 : 
; 1527 : 		for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	xor	eax, eax
	mov	DWORD PTR _iI$227329[esp+44], eax
$LL17@FindBestAr:

; 1528 : 		{
; 1529 : 			CvPlot* pAdjacentPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iI));

	movsx	ecx, WORD PTR [edi]
	push	eax
	movsx	eax, WORD PTR [edi+2]
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	ebp, eax
	add	esp, 12					; 0000000cH

; 1530 : 			// if there's no plot, bail
; 1531 : 			if(pAdjacentPlot == NULL)

	test	ebp, ebp
	je	$LN16@FindBestAr

; 1532 : 			{
; 1533 : 				continue;
; 1534 : 			}
; 1535 : 
; 1536 : 			// if the plot is ours or no one's, bail
; 1537 : 			if(pAdjacentPlot->getTeam() == NO_TEAM || pAdjacentPlot->getTeam() == getTeam())

	movsx	eax, BYTE PTR [ebp+4]
	cmp	eax, -1
	je	$LN16@FindBestAr
	cmp	eax, 63					; 0000003fH
	ja	$LN16@FindBestAr
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	cmp	DWORD PTR [ecx+eax*4], -1
	je	$LN16@FindBestAr
	cmp	eax, -1
	je	SHORT $LN75@FindBestAr
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN82@FindBestAr
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	esi, eax
	jmp	SHORT $LN74@FindBestAr
$LN82@FindBestAr:
	or	eax, -1
	mov	esi, eax
	jmp	SHORT $LN74@FindBestAr
$LN75@FindBestAr:
	or	esi, -1
$LN74@FindBestAr:
	mov	ecx, DWORD PTR _this$[esp+44]
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	cmp	esi, eax
	je	$LN16@FindBestAr

; 1538 : 			{
; 1539 : 				continue;
; 1540 : 			}
; 1541 : 
; 1542 : 			// don't evaluate city plots since we don't get ownership of them with the bomb
; 1543 : 			if(pAdjacentPlot->getPlotCity())

	mov	ecx, ebp
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	test	eax, eax
	jne	$LN16@FindBestAr

; 1544 : 			{
; 1545 : 				continue;
; 1546 : 			}
; 1547 : 
; 1548 : 			const PlayerTypes eOtherPlayer = pAdjacentPlot->getOwner();

	movsx	esi, BYTE PTR [ebp+4]

; 1549 : 			if(GET_PLAYER(eOtherPlayer).isMinorCiv())

	mov	ecx, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv

; 1550 : 			{
; 1551 : 				MinorCivApproachTypes eMinorApproach = GetDiplomacyAI()->GetMinorCivApproach(eOtherPlayer);

	mov	ecx, DWORD PTR _this$[esp+44]
	test	al, al
	je	SHORT $LN10@FindBestAr
	push	esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMinorCivApproach@CvDiplomacyAI@@QBE?AW4MinorCivApproachTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMinorCivApproach

; 1552 : 				// if we're friendly or protective, don't be a jerk. Bail out.
; 1553 : 				if(eMinorApproach != MINOR_CIV_APPROACH_CONQUEST && eMinorApproach != MINOR_CIV_APPROACH_IGNORE)

	cmp	eax, 3
	je	SHORT $LN7@FindBestAr
	test	eax, eax
	jne	$LN94@FindBestAr

; 1554 : 				{
; 1555 : 					iScore = 0;
; 1556 : 					break;
; 1557 : 				}
; 1558 : 			}
; 1559 : 			else

	jmp	SHORT $LN7@FindBestAr
$LN10@FindBestAr:

; 1560 : 			{
; 1561 : 				MajorCivApproachTypes eMajorApproach = GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, true);

	push	1
	push	esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach

; 1562 : 				DisputeLevelTypes eLandDisputeLevel = GetDiplomacyAI()->GetLandDisputeLevel(eOtherPlayer);

	mov	ecx, DWORD PTR _this$[esp+44]
	push	esi
	mov	edi, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetLandDisputeLevel@CvDiplomacyAI@@QBE?AW4DisputeLevelTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetLandDisputeLevel

; 1563 : 
; 1564 : 				bool bTicked = eMajorApproach == MAJOR_CIV_APPROACH_HOSTILE;

	cmp	edi, 1
	sete	cl

; 1565 : 				bool bTickedAboutLand = eMajorApproach == MAJOR_CIV_APPROACH_NEUTRAL && (eLandDisputeLevel == DISPUTE_LEVEL_STRONG || eLandDisputeLevel == DISPUTE_LEVEL_FIERCE);

	cmp	edi, 6
	jne	SHORT $LN35@FindBestAr
	cmp	eax, 2
	je	SHORT $LN34@FindBestAr
	cmp	eax, 3
	jne	SHORT $LN35@FindBestAr
$LN34@FindBestAr:
	mov	al, 1
	jmp	SHORT $LN36@FindBestAr
$LN35@FindBestAr:
	xor	al, al
$LN36@FindBestAr:

; 1566 : 
; 1567 : 				// only bomb if we're hostile
; 1568 : 				if(!bTicked && !bTickedAboutLand)

	test	cl, cl
	jne	SHORT $LN102@FindBestAr
	test	al, al
	je	SHORT $LN95@FindBestAr
$LN102@FindBestAr:
	mov	edi, DWORD PTR _pPlot$227312[esp+40]
$LN7@FindBestAr:

; 1571 : 					break;
; 1572 : 				}
; 1573 : 			}
; 1574 : 
; 1575 : 			eResource = pAdjacentPlot->getResourceType();

	push	-1
	mov	ecx, ebp
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	esi, eax

; 1576 : 			if(eResource != NO_RESOURCE)

	cmp	esi, -1
	je	SHORT $LN6@FindBestAr

; 1577 : 			{
; 1578 : 				iScore += GetBuilderTaskingAI()->GetResourceWeight(eResource, NO_IMPROVEMENT, pAdjacentPlot->getNumResource()) * 10;

	mov	ecx, ebp
	call	?getNumResource@CvPlot@@QBEHXZ		; CvPlot::getNumResource
	mov	ecx, DWORD PTR _this$[esp+44]
	push	eax
	push	-1
	push	esi
	call	?GetBuilderTaskingAI@CvPlayer@@QBEPAVCvBuilderTaskingAI@@XZ ; CvPlayer::GetBuilderTaskingAI
	mov	ecx, eax
	call	?GetResourceWeight@CvBuilderTaskingAI@@QAEHW4ResourceTypes@@W4ImprovementTypes@@H@Z ; CvBuilderTaskingAI::GetResourceWeight
	lea	eax, DWORD PTR [eax+eax*4]
	lea	ebx, DWORD PTR [ebx+eax*2]

; 1579 : 			}
; 1580 : 			else

	jmp	SHORT $LN16@FindBestAr
$LN6@FindBestAr:

; 1581 : 			{
; 1582 : 				for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)

	xor	esi, esi
$LL4@FindBestAr:

; 1583 : 				{
; 1584 : 					iScore += pAdjacentPlot->getYield((YieldTypes)iYield);

	push	esi
	mov	ecx, ebp
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	inc	esi
	add	ebx, eax
	cmp	esi, 6
	jl	SHORT $LL4@FindBestAr
$LN16@FindBestAr:

; 1519 : 				{
; 1520 : 					continue;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		}
; 1524 : 
; 1525 : 		int iScore = 0;
; 1526 : 
; 1527 : 		for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	eax, DWORD PTR _iI$227329[esp+44]
	inc	eax
	cmp	eax, 6
	mov	DWORD PTR _iI$227329[esp+44], eax
	jl	$LL17@FindBestAr

; 1566 : 
; 1567 : 				// only bomb if we're hostile
; 1568 : 				if(!bTicked && !bTickedAboutLand)

	jmp	SHORT $LN15@FindBestAr
$LN95@FindBestAr:

; 1569 : 				{
; 1570 : 					iScore = 0;

	mov	edi, DWORD PTR _pPlot$227312[esp+40]
$LN94@FindBestAr:
	xor	ebx, ebx
$LN15@FindBestAr:

; 1585 : 				}
; 1586 : 			}
; 1587 : 		}
; 1588 : 
; 1589 : 		if(iScore > iBestScore)

	cmp	ebx, DWORD PTR _iBestScore$[esp+44]
	jle	SHORT $LN29@FindBestAr

; 1590 : 		{
; 1591 : 			iBestScore = iScore;

	mov	DWORD PTR _iBestScore$[esp+44], ebx

; 1592 : 			pBestPlot = pPlot;

	mov	DWORD PTR _pBestPlot$[esp+44], edi
$LN29@FindBestAr:
	mov	ecx, DWORD PTR _ui$227307[esp+44]
	inc	ecx
	mov	DWORD PTR _ui$227307[esp+44], ecx
	cmp	ecx, DWORD PTR _nPlots$[esp+44]
	jb	$LL107@FindBestAr
	pop	edi
	pop	ebp
$LN28@FindBestAr:

; 1593 : 		}
; 1594 : 	}
; 1595 : 
; 1596 : 	iResultScore = iBestScore;

	mov	ecx, DWORD PTR _iBestScore$[esp+36]
	mov	edx, DWORD PTR _iResultScore$[esp+32]

; 1597 : 	return pBestPlot;

	mov	eax, DWORD PTR _pBestPlot$[esp+36]
	pop	esi
	mov	DWORD PTR [edx], ecx
	pop	ebx

; 1598 : }

	add	esp, 28					; 0000001cH
	ret	8
?FindBestArtistTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@AAH@Z ENDP ; CvPlayerAI::FindBestArtistTargetPlot
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::begin, COMDAT
; _this$ = ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	4
?begin@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::begin
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::end, COMDAT
; _this$ = ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 567  : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@XZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@XZ PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@XZ ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@XZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@XZ PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@XZ ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::end
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVCvAIOperation@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::iterator::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVCvAIOperation@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVCvAIOperation@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 465  : 			return ((reference)**(const_iterator *)this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 466  : 			}

	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVCvAIOperation@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	esi
	mov	esi, ecx

; 274  : 			_Inc();

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, esi
	pop	esi

; 276  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAE_NI@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@UCityAndProduction@@@std@@YAPAUCityAndProduction@@IPAU1@@Z ; std::_Allocate<CityAndProduction>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Buy
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >::operator+
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAUCityAndProduction@@PAU1@@stdext@@YAPAUCityAndProduction@@PAU1@00@Z ; stdext::_Unchecked_move_backward<CityAndProduction *,CityAndProduction *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAUCityAndProduction@@PAU1@@stdext@@YAPAUCityAndProduction@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUCityAndProduction@@PAU1@@stdext@@YAPAUCityAndProduction@@PAU1@00@Z PROC ; stdext::_Unchecked_move_backward<CityAndProduction *,CityAndProduction *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_
	push	esi
$LL12@Unchecked_:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_
	pop	esi
$LN11@Unchecked_:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAUCityAndProduction@@PAU1@@stdext@@YAPAUCityAndProduction@@PAU1@00@Z ENDP ; stdext::_Unchecked_move_backward<CityAndProduction *,CityAndProduction *>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CityAndProduction *,unsigned int,CityAndProduction,std::allocator<CityAndProduction> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CityAndProduction *,unsigned int,CityAndProduction,std::allocator<CityAndProduction> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@Uninit_fil:
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil
	pop	esi
$LN4@Uninit_fil:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CityAndProduction *,unsigned int,CityAndProduction,std::allocator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@0AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CityAndProduction> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@0AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@0AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CityAndProduction> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@0AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	??$_Distance@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0AAH@Z ; std::_Distance<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0AAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0AAH@Z PROC ; std::_Distance<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int>, COMDAT

; 1893 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	ecx, 3
	add	DWORD PTR [eax], ecx

; 1894 : 	}

	ret	0
??$_Distance@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0AAH@Z ENDP ; std::_Distance<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int>
_TEXT	ENDS
PUBLIC	?_Maxlen@?$_Temp_iterator@UCityAndProduction@@@std@@QAEHXZ ; std::_Temp_iterator<CityAndProduction>::_Maxlen
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Maxlen@?$_Temp_iterator@UCityAndProduction@@@std@@QAEHXZ
_TEXT	SEGMENT
__Pair$228191 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@UCityAndProduction@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CityAndProduction>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@Maxlen
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jle	SHORT $LN5@Maxlen

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	push	eax
	lea	eax, DWORD PTR __Pair$228191[esp+16]
	push	eax
	call	??$get_temporary_buffer@UCityAndProduction@@@std@@YA?AU?$pair@PAUCityAndProduction@@H@0@H@Z ; std::get_temporary_buffer<CityAndProduction>

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$228191[esp+20]
	mov	DWORD PTR [ecx], eax

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx+4], eax

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+8], eax

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$228191[esp+24]
	mov	DWORD PTR [edx+12], eax

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+12]
	add	esp, 8
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN4@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, eax
	mov	eax, DWORD PTR [edx+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN5@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
?_Maxlen@?$_Temp_iterator@UCityAndProduction@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CityAndProduction>::_Maxlen
_TEXT	ENDS
PUBLIC	??$advance@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@H@Z ; std::advance<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$advance@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@H@Z PROC ; std::advance<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@H@Z ENDP ; std::advance<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@stdext@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@stdext@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@std@@@Z
_TEXT	SEGMENT
$T233779 = -4						; size = 1
__Cat$233784 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@stdext@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T233779[esp+4], 0
	mov	eax, DWORD PTR $T233779[esp+4]
	mov	ecx, DWORD PTR __Cat$233784[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@stdext@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z
_TEXT	SEGMENT
$T233788 = -4						; size = 1
$T233795 = -4						; size = 4
$T233791 = -4						; size = 4
__Cat$233800 = 8					; size = 1
$T233790 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z PROC ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T233795[esp+8], ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$233800[esp+4]
	mov	edx, DWORD PTR $T233790[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T233788[esp+12], bl
	mov	eax, DWORD PTR $T233788[esp+12]
	push	eax
	push	ecx
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+40]
	mov	eax, DWORD PTR __First$[esp+40]
	mov	DWORD PTR $T233791[esp+44], esp
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN27@unchecked_
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN27@unchecked_:
	mov	eax, esi

; 3607 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z ENDP ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@00@Z ; stdext::unchecked_copy_backward<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy_backward@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@00@Z
_TEXT	SEGMENT
$T233839 = -4						; size = 1
__Cat$233845 = 8					; size = 1
$T233841 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy_backward@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@00@Z PROC ; stdext::unchecked_copy_backward<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$233845[esp]
	mov	edx, DWORD PTR $T233841[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T233839[esp+8], 0
	mov	eax, DWORD PTR $T233839[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3639 : 	}

	pop	ecx
	ret	0
??$unchecked_copy_backward@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@00@Z ENDP ; stdext::unchecked_copy_backward<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
_TEXT	ENDS
PUBLIC	??$_Lower_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,int,CityAndProductionEval>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Lower_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Lower_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z PROC ; std::_Lower_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,int,CityAndProductionEval>, COMDAT

; 2289 : 	_DEBUG_POINTER(_Pred);
; 2290 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2291 : 	_Diff _Count = 0;
; 2292 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	sar	ecx, 3

; 2293 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN38@Lower_boun
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+4]
	npad	6
$LL4@Lower_boun:

; 2294 : 		{	// divide and conquer, find half that contains answer
; 2295 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2296 : 		_FwdIt _Mid = _First;
; 2297 : 		std::advance(_Mid, _Count2);
; 2298 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2299 : 
; 2300 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))

	cmp	DWORD PTR [esi+eax*8+4], edi
	jle	SHORT $LN2@Lower_boun

; 2301 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	or	edx, -1
	lea	esi, DWORD PTR [esi+eax*8+8]
	sub	edx, eax
	mov	DWORD PTR __First$[esp+4], esi
	add	ecx, edx

; 2302 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2303 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Lower_boun:

; 2293 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Lower_boun
	pop	edi
$LN38@Lower_boun:

; 2304 : 		}
; 2305 : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], esi
	pop	esi

; 2306 : 	}

	ret	0
??$_Lower_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z ENDP ; std::_Lower_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,int,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,int,CityAndProductionEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Upper_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Upper_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z PROC ; std::_Upper_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,int,CityAndProductionEval>, COMDAT

; 2360 : 	_DEBUG_POINTER(_Pred);
; 2361 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2362 : 	_Diff _Count = 0;
; 2363 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	sar	ecx, 3

; 2364 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN38@Upper_boun
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+4]
	npad	6
$LL4@Upper_boun:

; 2365 : 		{	// divide and conquer, find half that contains answer
; 2366 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2367 : 		_FwdIt _Mid = _First;
; 2368 : 		std::advance(_Mid, _Count2);
; 2369 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2370 : 
; 2371 : 		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))

	cmp	edi, DWORD PTR [esi+eax*8+4]
	jg	SHORT $LN2@Upper_boun

; 2372 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	or	edx, -1
	lea	esi, DWORD PTR [esi+eax*8+8]
	sub	edx, eax
	mov	DWORD PTR __First$[esp+4], esi
	add	ecx, edx

; 2373 : 		else

	jmp	SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2374 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Upper_boun:

; 2364 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Upper_boun
	pop	edi
$LN38@Upper_boun:

; 2375 : 		}
; 2376 : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], esi
	pop	esi

; 2377 : 	}

	ret	0
??$_Upper_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z ENDP ; std::_Upper_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,int,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@00@Z ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@00@Z
_TEXT	SEGMENT
$T234039 = -4						; size = 1
__Cat$234045 = 8					; size = 1
$T234041 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@00@Z PROC ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$234045[esp]
	mov	edx, DWORD PTR $T234041[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T234039[esp+8], 0
	mov	eax, DWORD PTR $T234039[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3607 : 	}

	pop	ecx
	ret	0
??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@00@Z ENDP ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@0V12@@Z ; stdext::unchecked_copy_backward<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy_backward@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@0V12@@Z
_TEXT	SEGMENT
$T234053 = -4						; size = 1
__Cat$234059 = 8					; size = 1
$T234055 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy_backward@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@0V12@@Z PROC ; stdext::unchecked_copy_backward<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$234059[esp]
	mov	edx, DWORD PTR $T234055[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T234053[esp+8], 0
	mov	eax, DWORD PTR $T234053[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3639 : 	}

	pop	ecx
	ret	0
??$unchecked_copy_backward@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@0V12@@Z ENDP ; stdext::unchecked_copy_backward<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@0V12@@Z ; stdext::unchecked_copy<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@0V12@@Z
_TEXT	SEGMENT
$T234067 = -4						; size = 1
__Cat$234073 = 8					; size = 1
$T234069 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@0V12@@Z PROC ; stdext::unchecked_copy<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$234073[esp]
	mov	edx, DWORD PTR $T234069[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T234067[esp+8], 0
	mov	eax, DWORD PTR $T234067[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3607 : 	}

	pop	ecx
	ret	0
??$unchecked_copy@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@0V12@@Z ENDP ; stdext::unchecked_copy<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
_TEXT	ENDS
PUBLIC	??$_Merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@000V10@UCityAndProductionEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,CityAndProductionEval,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@000V10@UCityAndProductionEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T234089 = -24						; size = 4
$T234083 = -24						; size = 4
$T234081 = -24						; size = 4
$T234082 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
__Pred$ = 48						; size = 1
___formal$ = 52						; size = 1
___formal$ = 56						; size = 1
??$_Merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@000V10@UCityAndProductionEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,CityAndProductionEval,std::forward_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	sub	esp, 24					; 00000018H

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp+20]
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T234089[esp+32], edi
	cmp	eax, DWORD PTR __Last1$[esp+28]
	je	$LN3@Merge
	mov	ecx, DWORD PTR __First2$[esp+28]
	lea	esi, DWORD PTR [edi+8]
$LL4@Merge:
	cmp	ecx, DWORD PTR __Last2$[esp+28]
	je	$LN3@Merge

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+4]

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	edx, DWORD PTR __Dest$[esp+44]
	jle	SHORT $LN2@Merge
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN41@Merge
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR __Dest$[esp+44]
	add	DWORD PTR [eax+4], esi
	mov	ecx, DWORD PTR __First2$[esp+28]

; 2600 : 		else

	mov	eax, DWORD PTR __First1$[esp+28]
	add	ecx, esi
	mov	DWORD PTR __First2$[esp+28], ecx
	jmp	SHORT $LN72@Merge

; 2599 : 			*_Dest = *_First2, ++_First2;

$LN41@Merge:
	cmp	eax, edi
	je	SHORT $LN46@Merge
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR __Dest$[esp+44]
$LN46@Merge:
	add	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR __Dest$[esp+44]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR __First2$[esp+28]

; 2600 : 		else

	mov	eax, DWORD PTR __First1$[esp+28]
	add	ecx, esi
	mov	DWORD PTR __First2$[esp+28], ecx
	jmp	SHORT $LN72@Merge
$LN2@Merge:

; 2601 : 			*_Dest = *_First1, ++_First1;

	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN61@Merge
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR __Dest$[esp+44]
	add	DWORD PTR [eax+4], esi
	jmp	SHORT $LN60@Merge
$LN61@Merge:
	cmp	eax, edi
	je	SHORT $LN66@Merge
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR __Dest$[esp+44]
$LN66@Merge:
	add	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR __Dest$[esp+44]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
$LN60@Merge:
	mov	eax, DWORD PTR __First1$[esp+28]
	mov	ecx, DWORD PTR __First2$[esp+28]
	add	eax, esi
	mov	DWORD PTR __First1$[esp+28], eax
$LN72@Merge:

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	cmp	eax, DWORD PTR __Last1$[esp+28]
	jne	$LL4@Merge
$LN3@Merge:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	ecx, DWORD PTR __Dest$[esp+64]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last1$[esp+48]
	mov	eax, DWORD PTR __First1$[esp+48]
	mov	DWORD PTR $T234081[esp+52], esp
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T234082[esp+60]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T234082[esp+64]
	add	esp, 32					; 00000020H
	mov	DWORD PTR __Dest$[esp+44], edx
	cmp	eax, edi
	je	SHORT $LN88@Merge
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN88@Merge:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+28]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	ecx, DWORD PTR __Dest$[esp+64]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last2$[esp+48]
	mov	eax, DWORD PTR __First2$[esp+48]
	mov	DWORD PTR $T234083[esp+52], esp
	push	edx
	push	eax
	push	esi
	call	??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
	mov	eax, DWORD PTR __Dest$[esp+60]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN109@Merge
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN109@Merge:

; 2605 : 	}

	pop	edi
	mov	eax, esi
	pop	esi
	add	esp, 24					; 00000018H
	ret	0
??$_Merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@000V10@UCityAndProductionEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,CityAndProductionEval,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@000V10@UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@000V10@UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
??$_Merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@000V10@UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,std::random_access_iterator_tag>, COMDAT

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	ecx, DWORD PTR __First1$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	eax, DWORD PTR __First2$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Last1$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Last2$[esp+8]
	cmp	ecx, esi
	je	SHORT $LN28@Merge@2
	npad	5
$LL10@Merge@2:
	cmp	eax, edi
	je	SHORT $LN3@Merge@2

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	ebx, DWORD PTR [eax+4]
	cmp	ebx, DWORD PTR [ecx+4]
	jle	SHORT $LN2@Merge@2

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	edx, DWORD PTR [eax+4]
	add	eax, 8

; 2600 : 		else

	jmp	SHORT $LN68@Merge@2
$LN2@Merge@2:

; 2601 : 			*_Dest = *_First1, ++_First1;

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ebx
	mov	edx, DWORD PTR [ecx+4]
	add	ecx, 8
$LN68@Merge@2:
	mov	ebx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [ebx+4], edx
	mov	edx, DWORD PTR __Dest$[esp+8]
	add	edx, 8
	mov	DWORD PTR __Dest$[esp+8], edx
	cmp	ecx, esi
	jne	SHORT $LL10@Merge@2
$LN3@Merge@2:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	cmp	ecx, esi
	je	SHORT $LN28@Merge@2
	npad	4
$LL30@Merge@2:
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], ebx
	add	ecx, 8
	add	edx, 8
	cmp	ecx, esi
	jne	SHORT $LL30@Merge@2
$LN28@Merge@2:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	cmp	eax, edi
	je	SHORT $LN66@Merge@2
$LL49@Merge@2:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	add	eax, 8
	add	edx, 8
	cmp	eax, edi
	jne	SHORT $LL49@Merge@2
$LN66@Merge@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], edx
	pop	ebx

; 2605 : 	}

	ret	0
??$_Merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@000V10@UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00PAHPAUCityAndProduction@@@Z ; std::_Rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00PAHPAUCityAndProduction@@@Z
_TEXT	SEGMENT
$T234483 = -24						; size = 4
__Shift$ = -20						; size = 4
$T234487 = -16						; size = 4
$T234488 = -12						; size = 4
__Holeval$229379 = -8					; size = 8
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00PAHPAUCityAndProduction@@@Z PROC ; std::_Rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	sub	esp, 24					; 00000018H

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;
; 1683 : 	_Diff _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp+20]
	push	ebx
	mov	ebx, DWORD PTR __Mid$[esp+24]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+32]
	sub	ebx, edi
	sar	ebx, 3
	sub	ecx, edi
	sar	ecx, 3
	mov	DWORD PTR __Shift$[esp+36], ebx
	mov	eax, ecx

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	esi, ebx
	test	ebx, ebx
	je	SHORT $LN7@Rotate
$LL8@Rotate:

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	cdq
	idiv	esi

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	eax, esi
	mov	esi, edx
	test	edx, edx
	jne	SHORT $LL8@Rotate
$LN7@Rotate:

; 1689 : 		}
; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	cmp	eax, ecx
	jge	$LN3@Rotate

; 1692 : 		for (; 0 < _Count; --_Count)

	test	eax, eax
	jle	$LN3@Rotate
	add	ebx, ebx
	add	ebx, ebx
	push	ebp
	add	ebx, ebx
	jmp	SHORT $LN5@Rotate
	npad	4
$LL93@Rotate:
	mov	edi, DWORD PTR __First$[esp+36]
$LN5@Rotate:

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;
; 1695 : 			_RanIt _Next = _Hole;
; 1696 : 			_Ty _Holeval = *_Hole;

	mov	ecx, DWORD PTR [edi+eax*8+4]
	mov	ebp, DWORD PTR [edi+eax*8]
	lea	esi, DWORD PTR [edi+eax*8]
	mov	DWORD PTR __Holeval$229379[esp+44], ecx

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	lea	ecx, DWORD PTR [ebx+esi]
	mov	edi, esi
	cmp	ecx, DWORD PTR __Last$[esp+36]
	jne	SHORT $LN11@Rotate
	lea	ecx, DWORD PTR __First$[esp+36]
	jmp	SHORT $LN12@Rotate
$LN11@Rotate:
	mov	DWORD PTR $T234483[esp+40], ecx
	lea	ecx, DWORD PTR $T234483[esp+40]
$LN12@Rotate:
	mov	ecx, DWORD PTR [ecx]

; 1698 : 			while (_Next1 != _Hole)

	cmp	ecx, esi
	je	SHORT $LN1@Rotate
$LL2@Rotate:

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edi], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edi+4], edx

; 1701 : 				_Next = _Next1;
; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	edx, DWORD PTR __Last$[esp+36]
	sub	edx, ecx
	sar	edx, 3
	cmp	DWORD PTR __Shift$[esp+40], edx
	mov	edi, ecx
	jge	SHORT $LN13@Rotate
	add	ecx, ebx
	mov	DWORD PTR $T234487[esp+40], ecx
	lea	ecx, DWORD PTR $T234487[esp+40]
	jmp	SHORT $LN14@Rotate
$LN13@Rotate:
	add	edx, edx
	add	edx, edx
	add	edx, edx
	mov	ecx, ebx
	sub	ecx, edx
	add	ecx, DWORD PTR __First$[esp+36]
	mov	DWORD PTR $T234488[esp+40], ecx
	lea	ecx, DWORD PTR $T234488[esp+40]
$LN14@Rotate:
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, esi
	jne	SHORT $LL2@Rotate
$LN1@Rotate:

; 1704 : 				}
; 1705 : 			*_Next = _Holeval;

	mov	edx, DWORD PTR __Holeval$229379[esp+44]
	dec	eax
	mov	DWORD PTR [edi], ebp
	mov	DWORD PTR [edi+4], edx
	test	eax, eax
	jg	$LL93@Rotate
	pop	ebp
$LN3@Rotate:
	pop	edi
	pop	esi
	pop	ebx

; 1706 : 			}
; 1707 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00PAHPAUCityAndProduction@@@Z ENDP ; std::_Rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction>
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::begin, COMDAT
; _this$ = ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	4
?begin@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::begin
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1410 : 		_TRY_BEGIN
; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	test	eax, eax
	je	SHORT $LN4@Buynode
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+12], ecx
	mov	BYTE PTR [eax+16], dl
	mov	BYTE PTR [eax+17], 0
$LN4@Buynode:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1414 : 		_RERAISE;
; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	ret	20					; 00000014H
?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 286  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	?GetDirectiveMusician@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveMusician
EXTRN	?GetNumCivsInfluentialForWin@CvGameCulture@@QBEHXZ:PROC ; CvGameCulture::GetNumCivsInfluentialForWin
EXTRN	?GetGameCulture@CvGame@@QAEPAVCvGameCulture@@XZ:PROC ; CvGame::GetGameCulture
EXTRN	?getArmyID@CvUnit@@QBEHXZ:PROC			; CvUnit::getArmyID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
;	COMDAT ?GetDirectiveMusician@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_pGreatMusician$ = 8					; size = 4
?GetDirectiveMusician@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z PROC ; CvPlayerAI::GetDirectiveMusician, COMDAT
; _this$ = ecx

; 1031 : {

	push	ebx
	push	esi

; 1032 : 	GreatPeopleDirectiveTypes eDirective = NO_GREAT_PEOPLE_DIRECTIVE_TYPE;
; 1033 : 
; 1034 : 	// If headed on a concert tour, keep going
; 1035 : 	if (pGreatMusician->getArmyID() != FFreeList::INVALID_INDEX)

	mov	esi, DWORD PTR _pGreatMusician$[esp+4]
	push	edi
	mov	edi, ecx
	mov	ecx, esi
	or	ebx, -1
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, ebx

; 1036 : 	{
; 1037 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_TOURISM_BLAST;
; 1038 : 	}
; 1039 : 
; 1040 : 	// If closing in on a Culture win, go for the Concert Tour
; 1041 : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && GetDiplomacyAI()->IsGoingForCultureVictory() && GetCulture()->GetNumCivsInfluentialOn() > (GC.getGame().GetGameCulture()->GetNumCivsInfluentialForWin() / 2))

	jne	SHORT $LN16@GetDirecti@7
	mov	ecx, edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForCultureVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForCultureVictory
	test	al, al
	je	SHORT $LN13@GetDirecti@7
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebp
	call	?GetGameCulture@CvGame@@QAEPAVCvGameCulture@@XZ ; CvGame::GetGameCulture
	mov	ecx, eax
	call	?GetNumCivsInfluentialForWin@CvGameCulture@@QBEHXZ ; CvGameCulture::GetNumCivsInfluentialForWin
	cdq
	sub	eax, edx
	mov	ebp, eax
	mov	ecx, edi
	sar	ebp, 1
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetNumCivsInfluentialOn@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetNumCivsInfluentialOn
	cmp	eax, ebp
	pop	ebp
	jle	SHORT $LN13@GetDirecti@7

; 1042 : 	{		
; 1043 : 		CvPlot* pTarget = FindBestMusicianTargetPlot(pGreatMusician, true);

	push	1
	push	esi
	mov	ecx, edi
	call	?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvPlayerAI::FindBestMusicianTargetPlot

; 1044 : 		if(pTarget)

	test	eax, eax
	je	SHORT $LN13@GetDirecti@7
$LN16@GetDirecti@7:

; 1045 : 		{
; 1046 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_TOURISM_BLAST;

	mov	ebx, 5
$LN13@GetDirecti@7:

; 1047 : 		}
; 1048 : 	}
; 1049 : 
; 1050 : 	// Create Great Work if there is a slot
; 1051 : 	GreatWorkType eGreatWork = pGreatMusician->GetGreatWork();

	mov	ecx, esi
	call	?GetGreatWork@CvUnit@@QBE?AW4GreatWorkType@@XZ ; CvUnit::GetGreatWork

; 1052 : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && GetEconomicAI()->GetBestGreatWorkCity(pGreatMusician->plot(), eGreatWork))

	cmp	ebx, -1
	jne	SHORT $LN3@GetDirecti@7
	push	eax
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, edi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z ; CvEconomicAI::GetBestGreatWorkCity
	test	eax, eax
	je	SHORT $LN3@GetDirecti@7
	pop	edi
	pop	esi

; 1053 : 	{
; 1054 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;

	lea	eax, DWORD PTR [ebx+2]
	pop	ebx

; 1066 : }

	ret	4
$LN3@GetDirecti@7:

; 1055 : 	}
; 1056 : 	else
; 1057 : 	{
; 1058 : 		CvPlot* pTarget = FindBestMusicianTargetPlot(pGreatMusician, true);

	push	1
	push	esi
	mov	ecx, edi
	call	?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvPlayerAI::FindBestMusicianTargetPlot

; 1059 : 		if(pTarget)

	test	eax, eax

; 1060 : 		{
; 1061 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_TOURISM_BLAST;

	mov	eax, 5
	jne	SHORT $LN1@GetDirecti@7

; 1062 : 		}
; 1063 : 	}
; 1064 : 
; 1065 : 	return eDirective;

	mov	eax, ebx
$LN1@GetDirecti@7:
	pop	edi
	pop	esi
	pop	ebx

; 1066 : }

	ret	4
?GetDirectiveMusician@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ENDP ; CvPlayerAI::GetDirectiveMusician
_TEXT	ENDS
PUBLIC	?GetDirectiveMerchant@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveMerchant
; Function compile flags: /Ogtpy
;	COMDAT ?GetDirectiveMerchant@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_eDirective$ = -4					; size = 4
_pGreatMerchant$ = 8					; size = 4
?GetDirectiveMerchant@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z PROC ; CvPlayerAI::GetDirectiveMerchant, COMDAT
; _this$ = ecx

; 1100 : {

	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 1101 : 	GreatPeopleDirectiveTypes eDirective = NO_GREAT_PEOPLE_DIRECTIVE_TYPE;

	mov	DWORD PTR _eDirective$[esp+12], -1

; 1102 : 
; 1103 : 	bool bTheVeniceException = false;

	xor	bl, bl

; 1104 : 	if (GetPlayerTraits()->IsNoAnnexing())

	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+351], bl
	je	SHORT $LN7@GetDirecti@8

; 1105 : 	{
; 1106 : 		bTheVeniceException = true;

	mov	bl, 1
$LN7@GetDirecti@8:

; 1107 : 	}
; 1108 : 
; 1109 : 	// if the merchant is in an army, he's already marching to a destination, so don't evaluate him
; 1110 : 	if(pGreatMerchant->getArmyID() != FFreeList::INVALID_INDEX)

	mov	ecx, DWORD PTR _pGreatMerchant$[esp+8]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	je	SHORT $LN20@GetDirecti@8
	pop	esi

; 1111 : 	{
; 1112 : 		return NO_GREAT_PEOPLE_DIRECTIVE_TYPE;

	or	eax, -1
	pop	ebx

; 1143 : }

	pop	ecx
	ret	4
$LN20@GetDirecti@8:

; 1113 : 	}
; 1114 : 
; 1115 : #ifdef AUI_WARNING_FIXES
; 1116 : 	if (GC.getGame().getGameTurn() <= ((GC.getGame().getEstimateEndTurn() * 2) / 4))
; 1117 : #else
; 1118 : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && GC.getGame().getGameTurn() <= ((GC.getGame().getEstimateEndTurn() * 2) / 4))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebp
	push	edi
	mov	ebp, ecx
	call	?getEstimateEndTurn@CvGame@@QBEHXZ	; CvGame::getEstimateEndTurn
	add	eax, eax
	cdq
	and	edx, 3
	add	eax, edx
	mov	edi, eax
	mov	ecx, ebp
	sar	edi, 2
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	eax, edi
	jg	SHORT $LN21@GetDirecti@8

; 1119 : #endif
; 1120 : 	{
; 1121 : 		if (GetDiplomacyAI()->IsGoingForDiploVictory() && !bTheVeniceException)

	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForDiploVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForDiploVictory
	test	al, al
	je	SHORT $LN21@GetDirecti@8
	test	bl, bl

; 1122 : 		{
; 1123 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT;
; 1124 : 		}
; 1125 : 	}
; 1126 : 
; 1127 : 	// Attempt a run to a minor civ
; 1128 : 	if(eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && IsSafe(this))

	je	SHORT $LN25@GetDirecti@8
$LN21@GetDirecti@8:
	push	esi
	call	?IsSafe@@YA_NPAVCvPlayerAI@@@Z		; IsSafe
	add	esp, 4
	test	al, al
	je	SHORT $LN23@GetDirecti@8

; 1129 : 	{
; 1130 : 		CvPlot* pTarget = FindBestMerchantTargetPlot(pGreatMerchant, true);

	mov	eax, DWORD PTR _pGreatMerchant$[esp+16]
	push	1
	push	eax
	mov	ecx, esi
	call	?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvPlayerAI::FindBestMerchantTargetPlot

; 1131 : 		if(pTarget)

	test	eax, eax
	je	SHORT $LN23@GetDirecti@8
	pop	edi
	pop	ebp

; 1132 : 		{
; 1133 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;

	mov	DWORD PTR _eDirective$[esp+12], 1

; 1140 : 	}
; 1141 : 
; 1142 : 	return eDirective;

	mov	eax, DWORD PTR _eDirective$[esp+12]
	pop	esi
	pop	ebx

; 1143 : }

	pop	ecx
	ret	4
$LN23@GetDirecti@8:

; 1134 : 		}
; 1135 : 	}
; 1136 : 
; 1137 : 	if(eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && (GC.getGame().getGameTurn() - pGreatMerchant->getGameTurnCreated()) >= GC.getAI_HOMELAND_GREAT_PERSON_TURNS_TO_WAIT() && !bTheVeniceException)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2700
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR _pGreatMerchant$[esp+16]
	mov	edi, eax
	call	?getGameTurnCreated@CvUnit@@QBEHXZ	; CvUnit::getGameTurnCreated
	sub	edi, eax
	cmp	edi, esi
	jl	SHORT $LN24@GetDirecti@8
	test	bl, bl
	jne	SHORT $LN24@GetDirecti@8
$LN25@GetDirecti@8:

; 1138 : 	{
; 1139 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT;

	mov	DWORD PTR _eDirective$[esp+20], 2
$LN24@GetDirecti@8:

; 1140 : 	}
; 1141 : 
; 1142 : 	return eDirective;

	mov	eax, DWORD PTR _eDirective$[esp+20]
	pop	edi
	pop	ebp
	pop	esi
	pop	ebx

; 1143 : }

	pop	ecx
	ret	4
?GetDirectiveMerchant@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ENDP ; CvPlayerAI::GetDirectiveMerchant
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVCvAIOperation@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::iterator::operator->
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVCvAIOperation@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVCvAIOperation@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 470  : 			return (&**this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 471  : 			}

	ret	0
??Citerator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVCvAIOperation@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 474  : 			{	// preincrement

	push	esi
	mov	esi, ecx

; 475  : 			++(*(const_iterator *)this);

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::_Inc

; 476  : 			return (*this);

	mov	eax, esi
	pop	esi

; 477  : 			}

	ret	0
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??0?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::vector<CityAndProduction,std::allocator<CityAndProduction> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::vector<CityAndProduction,std::allocator<CityAndProduction> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::vector<CityAndProduction,std::allocator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@stdext@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CityAndProduction *,unsigned int,CityAndProduction,std::allocator<CityAndProduction> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@stdext@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@std@@@Z
_TEXT	SEGMENT
$T234912 = -4						; size = 1
__Cat$234917 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@stdext@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CityAndProduction *,unsigned int,CityAndProduction,std::allocator<CityAndProduction> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T234912[esp+4], 0
	mov	eax, DWORD PTR $T234912[esp+4]
	mov	ecx, DWORD PTR __Cat$234917[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CityAndProduction *,unsigned int,CityAndProduction,std::allocator<CityAndProduction> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@stdext@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CityAndProduction *,unsigned int,CityAndProduction,std::allocator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@0AAV?$allocator@UCityAndProduction@@@0@@Z ; std::_Destroy_range<std::allocator<CityAndProduction> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@0AAV?$allocator@UCityAndProduction@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@0AAV?$allocator@UCityAndProduction@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CityAndProduction> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@0AAV?$allocator@UCityAndProduction@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@U_Undefined_move_tag@3@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@U_Undefined_move_tag@3@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T234938 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$234942 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@U_Undefined_move_tag@3@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$234942[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T234938[esp+4], 0
	mov	eax, DWORD PTR $T234938[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@U_Undefined_move_tag@3@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@UCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@PAUCityAndProduction@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,CityAndProduction>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@UCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@PAUCityAndProduction@@@Z
_TEXT	SEGMENT
$T235014 = -8						; size = 1
$T234948 = -4						; size = 4
__Cat$235019 = 8					; size = 1
$T235016 = 8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@UCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@PAUCityAndProduction@@@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,CityAndProduction>, COMDAT

; 3124 : 	if (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	sub	esp, 8
	cmp	edx, eax
	je	SHORT $LN6@Insertion_
	push	esi

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	esi, DWORD PTR [edx+8]
	cmp	esi, eax
	je	SHORT $LN73@Insertion_
	push	ebx
	mov	ebx, DWORD PTR $T235016[esp+12]
	push	ebp
	push	edi
	jmp	SHORT $LN7@Insertion_
$LL72@Insertion_:
	mov	edx, DWORD PTR __First$[esp+20]
$LN7@Insertion_:

; 3126 : 			{	// order next element
; 3127 : 			_BidIt _Next1 = _Next;
; 3128 : 			_Ty _Val = *_Next;

	mov	edi, DWORD PTR [esi+4]

; 3129 : 
; 3130 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

	cmp	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [esi]
	mov	ecx, esi
	jle	SHORT $LN5@Insertion_

; 3131 : 				{	// found new earliest element, move to front
; 3132 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	BYTE PTR $T235014[esp+24], 0
	mov	ecx, DWORD PTR $T235014[esp+24]
	push	ecx
	mov	ecx, DWORD PTR __Cat$235019[esp+24]
	push	ecx
	push	ebx
	lea	eax, DWORD PTR [esi+8]
	push	eax
	push	esi
	push	edx
	lea	edx, DWORD PTR $T234948[esp+48]
	push	edx
	call	??$_Copy_backward_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>

; 3133 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[esp+48]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR __First$[esp+48]
	add	esp, 28					; 0000001cH

; 3134 : 				}
; 3135 : 			else

	jmp	SHORT $LN75@Insertion_
$LN5@Insertion_:

; 3136 : 				{	// look for insertion point after first
; 3137 : 				for (_BidIt _First1 = _Next1;
; 3138 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3139 : 					_Next1 = _First1)

	cmp	edi, DWORD PTR [esi-4]
	lea	eax, DWORD PTR [esi-8]
	jle	SHORT $LN1@Insertion_
$LL3@Insertion_:

; 3140 : 					*_Next1 = *_First1;	// move hole down

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, eax
	sub	eax, 8
	cmp	edi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_
$LN1@Insertion_:

; 3141 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebp
$LN75@Insertion_:

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	add	esi, 8

; 3141 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx+4], edi
	cmp	esi, DWORD PTR __Last$[esp+20]
	jne	SHORT $LL72@Insertion_
	pop	edi
	pop	ebp
	pop	ebx
$LN73@Insertion_:
	pop	esi
$LN6@Insertion_:

; 3142 : 				}
; 3143 : 			}
; 3144 : 	}

	add	esp, 8
	ret	0
??$_Insertion_sort1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@UCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@PAUCityAndProduction@@@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,CityAndProduction>
_TEXT	ENDS
PUBLIC	??$lower_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@UCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@@Z ; std::lower_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,CityAndProductionEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$lower_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@UCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@@Z
_TEXT	SEGMENT
$T235087 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$lower_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@UCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@@Z PROC ; std::lower_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,CityAndProductionEval>, COMDAT

; 2313 : 	{	// find first element not before _Val, using _Pred

	push	ecx

; 2314 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Pred$[esp]
	mov	ecx, DWORD PTR __Val$[esp]
	mov	edx, DWORD PTR __Last$[esp]
	push	0
	push	eax
	mov	eax, DWORD PTR __First$[esp+8]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T235087[esp+24]
	push	ecx
	call	??$_Lower_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,int,CityAndProductionEval>

; 2315 : 		_Lower_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Pred, _Dist_type(_First)));
; 2316 : 	return _First;

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	DWORD PTR [eax], edx

; 2317 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$lower_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@UCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@@Z ENDP ; std::lower_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	??$upper_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@UCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@@Z ; std::upper_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,CityAndProductionEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$upper_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@UCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@@Z
_TEXT	SEGMENT
$T235094 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$upper_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@UCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@@Z PROC ; std::upper_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,CityAndProductionEval>, COMDAT

; 2384 : 	{	// find first element that _Val is before, using _Pred

	push	ecx

; 2385 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Pred$[esp]
	mov	ecx, DWORD PTR __Val$[esp]
	mov	edx, DWORD PTR __Last$[esp]
	push	0
	push	eax
	mov	eax, DWORD PTR __First$[esp+8]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T235094[esp+24]
	push	ecx
	call	??$_Upper_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,int,CityAndProductionEval>

; 2386 : 		_Upper_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Pred, _Dist_type(_First)));
; 2387 : 	return _First;

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	DWORD PTR [eax], edx

; 2388 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$upper_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@UCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@@Z ENDP ; std::upper_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	??$_Merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V23@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@11UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V23@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@11UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T235247 = 12						; size = 1
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Cat$235252 = 28					; size = 1
$T235249 = 28						; size = 1
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
??$_Merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V23@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@11UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,std::random_access_iterator_tag>, COMDAT

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Last1$[esp+4]
	cmp	eax, esi
	je	SHORT $LN44@Merge@3
$LL10@Merge@3:
	mov	edx, DWORD PTR __First2$[esp+4]
	cmp	edx, DWORD PTR __Last2$[esp+4]
	je	SHORT $LN68@Merge@3

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	ebx, DWORD PTR [edx+4]
	cmp	ebx, DWORD PTR [eax+4]
	jle	SHORT $LN2@Merge@3

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edx+4], ecx
	add	DWORD PTR __First2$[esp+4], 8

; 2600 : 		else

	jmp	SHORT $LN4@Merge@3
$LN2@Merge@3:

; 2601 : 			*_Dest = *_First1, ++_First1;

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edx+4], ecx
	add	eax, 8
$LN4@Merge@3:
	mov	ecx, DWORD PTR __Dest$[esp+4]
	add	ecx, 8
	mov	DWORD PTR __Dest$[esp+4], ecx
	cmp	eax, esi
	jne	SHORT $LL10@Merge@3
$LN68@Merge@3:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	cmp	eax, esi
	je	SHORT $LN44@Merge@3
	npad	3
$LL46@Merge@3:
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	add	eax, 8
	add	ecx, 8
	cmp	eax, esi
	jne	SHORT $LL46@Merge@3
$LN44@Merge@3:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR __Dest$[esp+4], ecx
	mov	edx, DWORD PTR __Cat$235252[esp+4]
	mov	BYTE PTR $T235247[esp+4], 0
	mov	eax, DWORD PTR $T235247[esp+4]
	push	eax
	mov	eax, DWORD PTR $T235249[esp+8]
	push	edx
	mov	edx, DWORD PTR __First2$[esp+12]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Last2$[esp+20]
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi
	pop	ebx

; 2605 : 	}

	ret	0
??$_Merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V23@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@11UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge_backward@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@V12@UCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0PAUCityAndProduction@@10UCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge_backward@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@V12@UCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0PAUCityAndProduction@@10UCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T235311 = -4						; size = 1
$T235286 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Cat$235316 = 16					; size = 1
$T235313 = 16						; size = 1
__Cat$235291 = 16					; size = 1
$T235288 = 16						; size = 1
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge_backward@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@V12@UCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0PAUCityAndProduction@@10UCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>, COMDAT

; 2839 : 	{	// merge backwards to _Dest, using _Pred

	push	ecx

; 2840 : 	for (; ; )
; 2841 : 		if (_First1 == _Last1)

	mov	edx, DWORD PTR __First1$[esp]
	mov	ecx, DWORD PTR __Last1$[esp]
	mov	eax, DWORD PTR __Last2$[esp]
	push	esi
	mov	esi, DWORD PTR __First2$[esp+4]
	push	edi
	cmp	edx, ecx
	je	SHORT $LN61@Merge_back
$LL8@Merge_back:

; 2843 : 		else if (_First2 == _Last2)

	cmp	esi, eax
	je	$LN62@Merge_back

; 2845 : 		else if (_DEBUG_LT_PRED(_Pred, *--_Last2, *--_Last1))

	mov	edx, DWORD PTR [eax-4]
	sub	eax, 8
	sub	ecx, 8
	mov	DWORD PTR __Last1$[esp+8], ecx
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN2@Merge_back

; 2846 : 			*--_Dest = *_Last1, ++_Last2;

	mov	edx, DWORD PTR __Dest$[esp+8]
	sub	edx, 8
	mov	DWORD PTR __Dest$[esp+8], edx
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edx], edi
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+4], ecx

; 2847 : 		else

	mov	ecx, DWORD PTR __Last1$[esp+8]
	add	eax, 8
	jmp	SHORT $LN57@Merge_back
$LN2@Merge_back:

; 2848 : 			*--_Dest = *_Last2, ++_Last1;

	mov	ecx, DWORD PTR __Dest$[esp+8]
	mov	edx, DWORD PTR [eax]
	sub	ecx, 8
	mov	DWORD PTR __Dest$[esp+8], ecx
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR __Last1$[esp+8]
	add	ecx, 8
	mov	DWORD PTR __Last1$[esp+8], ecx
$LN57@Merge_back:
	mov	edx, DWORD PTR __First1$[esp+8]
	cmp	edx, ecx
	jne	SHORT $LL8@Merge_back
$LN61@Merge_back:

; 2842 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __Cat$235291[esp+8]
	mov	BYTE PTR $T235286[esp+12], 0
	mov	ecx, DWORD PTR $T235286[esp+12]
	push	ecx
	mov	ecx, DWORD PTR $T235288[esp+12]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+16]
	push	ecx
	push	edx
	push	eax
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+32]
	push	esi
	call	??$_Copy_backward_opt@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>

; 2844 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	add	esp, 28					; 0000001cH
	pop	edi
	mov	eax, esi
	pop	esi

; 2849 : 	}

	pop	ecx
	ret	0
$LN62@Merge_back:

; 2844 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T235311[esp+12], 0
	mov	eax, DWORD PTR $T235311[esp+12]
	push	eax
	mov	eax, DWORD PTR __Cat$235316[esp+12]
	push	eax
	mov	eax, DWORD PTR $T235313[esp+16]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+20]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	pop	edi
	mov	eax, esi
	pop	esi

; 2849 : 	}

	pop	ecx
	ret	0
??$_Merge_backward@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@V12@UCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0PAUCityAndProduction@@10UCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@000V12@UCityAndProductionEval@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,CityAndProductionEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@000V12@UCityAndProductionEval@@@Z
_TEXT	SEGMENT
$T235400 = -4						; size = 1
$T235406 = -4						; size = 4
$T235402 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
$T235401 = 48						; size = 1
__Pred$ = 48						; size = 1
??$unchecked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@000V12@UCityAndProductionEval@@@Z PROC ; stdext::unchecked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,CityAndProductionEval>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ecx
	push	ebx
	push	esi
	xor	ebx, ebx
	mov	DWORD PTR $T235406[esp+12], ebx

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T235401[esp+8]
	mov	edx, DWORD PTR __Pred$[esp+8]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T235400[esp+12], bl
	mov	eax, DWORD PTR $T235400[esp+12]
	push	eax
	push	ecx
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last2$[esp+40]
	mov	eax, DWORD PTR __First2$[esp+40]
	mov	ecx, DWORD PTR __Last1$[esp+40]
	mov	DWORD PTR $T235402[esp+44], esp
	push	edx
	mov	edx, DWORD PTR __First1$[esp+44]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@000V10@UCityAndProductionEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,CityAndProductionEval,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+60]
	add	esp, 52					; 00000034H
	cmp	eax, ebx
	je	SHORT $LN25@unchecked_@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@unchecked_@2:
	mov	eax, esi

; 5160 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@000V12@UCityAndProductionEval@@@Z ENDP ; stdext::unchecked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@000V12@UCityAndProductionEval@@@Z ; stdext::unchecked_merge<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@000V12@UCityAndProductionEval@@@Z
_TEXT	SEGMENT
$T235446 = -4						; size = 1
$T235447 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$unchecked_merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@000V12@UCityAndProductionEval@@@Z PROC ; stdext::unchecked_merge<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ecx

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T235447[esp]
	mov	edx, DWORD PTR __Pred$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T235446[esp+8], 0
	mov	eax, DWORD PTR $T235446[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First2$[esp+16]
	push	eax
	mov	eax, DWORD PTR __Last1$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First1$[esp+24]
	push	edx
	push	eax
	push	ecx
	push	esi
	call	??$_Merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@000V10@UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
	mov	eax, esi
	pop	esi

; 5160 : 	}

	pop	ecx
	ret	0
??$unchecked_merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@000V12@UCityAndProductionEval@@@Z ENDP ; stdext::unchecked_merge<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	??$_Rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >, COMDAT

; 1713 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __Mid$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00PAHPAUCityAndProduction@@@Z ; std::_Rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction>
	add	esp, 20					; 00000014H

; 1714 : 	}

	ret	0
??$_Rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$2
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
_TEXT	SEGMENT
$T235465 = -80						; size = 28
$T235464 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	edi
	mov	edi, ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	cmp	DWORD PTR [edi+8], 1073741822		; 3ffffffeH
	jb	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T235465[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T235464[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T235465[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T235464[esp+100]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	mov	DWORD PTR $T235464[esp+88], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T235464[esp+88]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+100], 0
	mov	DWORD PTR $T235464[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN228@Insert:
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	edx, DWORD PTR __Val$[esp+80]
	mov	eax, DWORD PTR [edi+4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Wherenode$[esp+92]
	push	0
	push	edx
	push	eax
	push	esi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
	mov	ebp, eax

; 1192 : 
; 1193 : 		++_Mysize;
; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, 1
	add	DWORD PTR [edi+8], ebx
	cmp	esi, eax
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], ebp

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+8], ebp
	jmp	SHORT $LN11@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+92], 0
	je	SHORT $LN14@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi], ebp

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebp

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert
$LN14@Insert:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi+8], ebp

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], ebp
$LN11@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR [ebp+4]
	cmp	BYTE PTR [edx+16], 0
	lea	eax, DWORD PTR [ebp+4]
	mov	esi, ebp
	jne	$LN9@Insert
	npad	5
$LL10@Insert:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN8@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+16], 0
	jne	SHORT $LN7@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+16], bl

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+16], bl

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+16], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1222 : 					}
; 1223 : 				else

	jmp	$LN171@Insert
$LN7@Insert:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN5@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
$LN5@Insert:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+16], bl

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+16], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN171@Insert
$LN8@Insert:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+16], 0
	jne	SHORT $LN3@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+16], bl

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+16], bl

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+16], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN171@Insert
$LN3@Insert:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1250 : 						_Rrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
$LN1@Insert:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+16], bl

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+16], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+17], 0
	jne	SHORT $LN170@Insert
	mov	DWORD PTR [edx+4], eax
$LN170@Insert:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN169@Insert
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN166@Insert
$LN169@Insert:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN167@Insert
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN166@Insert
$LN167@Insert:
	mov	DWORD PTR [edx+8], ecx
$LN166@Insert:
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [eax+4], ecx
$LN171@Insert:
	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+16], 0
	lea	eax, DWORD PTR [esi+4]
	je	$LL10@Insert
$LN9@Insert:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx+4]

; 1259 : 		return (_TREE_ITERATOR(_Newnode));
; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	BYTE PTR [eax+16], bl
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+92]
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	16					; 00000010H
$LN227@Insert:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$0:
	lea	ecx, DWORD PTR $T235465[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$2:
	lea	ecx, DWORD PTR $T235464[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
PUBLIC	??Fiterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fiterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 487  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::operator--
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
_TEXT	ENDS
;	COMDAT ?PeekAtNextUnitToBuildForOperationSlot@CvPlayerAI@@UAE?AUOperationSlot@@H@Z
_TEXT	SEGMENT
$T235872 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_iAreaID$ = 12						; size = 4
?PeekAtNextUnitToBuildForOperationSlot@CvPlayerAI@@UAE?AUOperationSlot@@H@Z PROC ; CvPlayerAI::PeekAtNextUnitToBuildForOperationSlot, COMDAT
; _this$ = ecx

; 745  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 746  : 	OperationSlot thisSlot;

	or	eax, -1
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[esp+20]
	mov	ebx, ecx
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax

; 747  : 
; 748  : 	// search through our operations till we find one that needs a unit
; 749  : 	std::map<int, CvAIOperation*>::iterator iter;
; 750  : 	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)

	mov	eax, DWORD PTR [ebx+4532]
	mov	esi, DWORD PTR [eax]
	cmp	esi, eax
	je	$LN86@PeekAtNext
	push	ebp
	mov	ebp, DWORD PTR _iAreaID$[esp+24]
	npad	4
$LL30@PeekAtNext:

; 751  : 	{
; 752  : 		CvAIOperation* pThisOperation = iter->second;

	mov	ecx, DWORD PTR [esi+16]

; 753  : 		if(pThisOperation)

	test	ecx, ecx
	je	SHORT $LN4@PeekAtNext

; 754  : 		{
; 755  : 			thisSlot = pThisOperation->PeekAtNextUnitToBuild(iAreaID);

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+96]
	push	ebp
	lea	edx, DWORD PTR $T235872[esp+32]
	push	edx
	call	eax
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edi], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+4], edx
	mov	eax, DWORD PTR [eax+8]

; 756  : 			if(thisSlot.IsValid())

	mov	ecx, edi
	mov	DWORD PTR [edi+8], eax
	call	?IsValid@OperationSlot@@QBE_NXZ		; OperationSlot::IsValid
	test	al, al
	jne	SHORT $LN85@PeekAtNext
$LN4@PeekAtNext:

; 747  : 
; 748  : 	// search through our operations till we find one that needs a unit
; 749  : 	std::map<int, CvAIOperation*>::iterator iter;
; 750  : 	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)

	cmp	BYTE PTR [esi+21], 0
	jne	SHORT $LN84@PeekAtNext
	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN80@PeekAtNext
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN84@PeekAtNext
$LL45@PeekAtNext:
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL45@PeekAtNext
	jmp	SHORT $LN84@PeekAtNext
$LN80@PeekAtNext:
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN28@PeekAtNext
	npad	3
$LL29@PeekAtNext:
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN28@PeekAtNext
	mov	esi, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL29@PeekAtNext
$LN28@PeekAtNext:
	mov	esi, eax
$LN84@PeekAtNext:
	cmp	esi, DWORD PTR [ebx+4532]
	jne	SHORT $LL30@PeekAtNext
$LN85@PeekAtNext:
	pop	ebp

; 757  : 			{
; 758  : 				break;
; 759  : 			}
; 760  : 		}
; 761  : 	}
; 762  : 
; 763  : 	return thisSlot;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 764  : }

	add	esp, 12					; 0000000cH
	ret	8
$LN86@PeekAtNext:

; 757  : 			{
; 758  : 				break;
; 759  : 			}
; 760  : 		}
; 761  : 	}
; 762  : 
; 763  : 	return thisSlot;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 764  : }

	add	esp, 12					; 0000000cH
	ret	8
?PeekAtNextUnitToBuildForOperationSlot@CvPlayerAI@@UAE?AUOperationSlot@@H@Z ENDP ; CvPlayerAI::PeekAtNextUnitToBuildForOperationSlot
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CityCommitToBuildUnitForOperationSlot@CvPlayerAI@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T236126 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_iAreaID$ = 12						; size = 4
_iTurns$ = 16						; size = 4
_pCity$ = 20						; size = 4
?CityCommitToBuildUnitForOperationSlot@CvPlayerAI@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z PROC ; CvPlayerAI::CityCommitToBuildUnitForOperationSlot, COMDAT
; _this$ = ecx

; 768  : {

	sub	esp, 16					; 00000010H
	push	esi

; 769  : 	OperationSlot thisSlot;

	or	eax, -1
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[esp+20]
	mov	edx, ecx
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax

; 770  : 
; 771  : 	// search through our operations till we find one that needs a unit
; 772  : 	std::map<int, CvAIOperation*>::iterator iter;
; 773  : 	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)

	mov	eax, DWORD PTR [edx+4532]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+24], edx
	cmp	esi, eax
	je	$LN86@CityCommit
	push	ebx
	mov	ebx, DWORD PTR _pCity$[esp+24]
	push	ebp
	mov	ebp, DWORD PTR _iTurns$[esp+28]
$LL30@CityCommit:

; 774  : 	{
; 775  : 		CvAIOperation* pThisOperation = iter->second;

	mov	ecx, DWORD PTR [esi+16]

; 776  : 		if(pThisOperation)

	test	ecx, ecx
	je	SHORT $LN4@CityCommit

; 777  : 		{
; 778  : 			thisSlot = pThisOperation->CommitToBuildNextUnit(iAreaID, iTurns, pCity);

	mov	edx, DWORD PTR _iAreaID$[esp+28]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+100]
	push	ebx
	push	ebp
	push	edx
	lea	edx, DWORD PTR $T236126[esp+44]
	push	edx
	call	eax
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edi], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+4], edx
	mov	eax, DWORD PTR [eax+8]

; 779  : 			if(thisSlot.IsValid())

	mov	ecx, edi
	mov	DWORD PTR [edi+8], eax
	call	?IsValid@OperationSlot@@QBE_NXZ		; OperationSlot::IsValid
	test	al, al
	jne	SHORT $LN85@CityCommit
	mov	edx, DWORD PTR _this$[esp+32]
$LN4@CityCommit:

; 770  : 
; 771  : 	// search through our operations till we find one that needs a unit
; 772  : 	std::map<int, CvAIOperation*>::iterator iter;
; 773  : 	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)

	cmp	BYTE PTR [esi+21], 0
	jne	SHORT $LN84@CityCommit
	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN80@CityCommit
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN84@CityCommit
$LL45@CityCommit:
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL45@CityCommit
	jmp	SHORT $LN84@CityCommit
$LN80@CityCommit:
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN28@CityCommit
	npad	5
$LL29@CityCommit:
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN28@CityCommit
	mov	esi, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL29@CityCommit
$LN28@CityCommit:
	mov	esi, eax
$LN84@CityCommit:
	cmp	esi, DWORD PTR [edx+4532]
	jne	$LL30@CityCommit
$LN85@CityCommit:
	pop	ebp
	pop	ebx

; 780  : 			{
; 781  : 				break;
; 782  : 			}
; 783  : 		}
; 784  : 	}
; 785  : 
; 786  : 	return thisSlot;

	mov	eax, edi
	pop	edi
	pop	esi

; 787  : }

	add	esp, 16					; 00000010H
	ret	16					; 00000010H
$LN86@CityCommit:

; 780  : 			{
; 781  : 				break;
; 782  : 			}
; 783  : 		}
; 784  : 	}
; 785  : 
; 786  : 	return thisSlot;

	mov	eax, edi
	pop	edi
	pop	esi

; 787  : }

	add	esp, 16					; 00000010H
	ret	16					; 00000010H
?CityCommitToBuildUnitForOperationSlot@CvPlayerAI@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z ENDP ; CvPlayerAI::CityCommitToBuildUnitForOperationSlot
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetNumUnitsNeededToBeBuilt@CvPlayerAI@@UAEHXZ
_TEXT	SEGMENT
?GetNumUnitsNeededToBeBuilt@CvPlayerAI@@UAEHXZ PROC	; CvPlayerAI::GetNumUnitsNeededToBeBuilt, COMDAT
; _this$ = ecx

; 820  : {

	push	esi
	push	edi

; 821  : 	int iRtnValue = 0;
; 822  : 
; 823  : 	std::map<int, CvAIOperation*>::iterator iter;
; 824  : 	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)

	mov	edi, DWORD PTR [ecx+4532]
	mov	ecx, DWORD PTR [edi]
	xor	esi, esi
	cmp	ecx, edi
	je	SHORT $LN85@GetNumUnit
$LL27@GetNumUnit:

; 825  : 	{
; 826  : 		CvAIOperation* pThisOperation = iter->second;

	mov	eax, DWORD PTR [ecx+16]

; 827  : 		if(pThisOperation)

	test	eax, eax
	je	SHORT $LN3@GetNumUnit

; 828  : 		{
; 829  : 			iRtnValue += pThisOperation->GetNumUnitsNeededToBeBuilt();

	mov	edx, DWORD PTR [eax+28]
	sub	edx, DWORD PTR [eax+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	esi, eax
$LN3@GetNumUnit:

; 821  : 	int iRtnValue = 0;
; 822  : 
; 823  : 	std::map<int, CvAIOperation*>::iterator iter;
; 824  : 	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)

	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN84@GetNumUnit
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN81@GetNumUnit
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN84@GetNumUnit
$LL42@GetNumUnit:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL42@GetNumUnit
	jmp	SHORT $LN84@GetNumUnit
$LN81@GetNumUnit:
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN25@GetNumUnit
	npad	3
$LL26@GetNumUnit:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN25@GetNumUnit
	mov	ecx, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL26@GetNumUnit
$LN25@GetNumUnit:
	mov	ecx, eax
$LN84@GetNumUnit:
	cmp	ecx, edi
	jne	SHORT $LL27@GetNumUnit
$LN85@GetNumUnit:
	pop	edi

; 830  : 		}
; 831  : 	}
; 832  : 
; 833  : 	return iRtnValue;

	mov	eax, esi
	pop	esi

; 834  : }

	ret	0
?GetNumUnitsNeededToBeBuilt@CvPlayerAI@@UAEHXZ ENDP	; CvPlayerAI::GetNumUnitsNeededToBeBuilt
_TEXT	ENDS
PUBLIC	?ProcessGreatPeople@CvPlayerAI@@QAEXXZ		; CvPlayerAI::ProcessGreatPeople
EXTRN	?SetGreatPeopleDirective@CvUnit@@QAEXW4GreatPeopleDirectiveTypes@@@Z:PROC ; CvUnit::SetGreatPeopleDirective
; Function compile flags: /Ogtpy
;	COMDAT ?ProcessGreatPeople@CvPlayerAI@@QAEXXZ
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
?ProcessGreatPeople@CvPlayerAI@@QAEXXZ PROC		; CvPlayerAI::ProcessGreatPeople, COMDAT
; _this$ = ecx

; 837  : {

	push	ecx
	push	ebx
	push	ebp

; 838  : 	SpecialUnitTypes eSpecialUnitGreatPerson = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_PEOPLE");

	push	0
	mov	ebx, ecx
	push	OFFSET $SG227049
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 839  : 
; 840  : 	CvAssert(isAlive());
; 841  : 
; 842  : 	if(!isAlive())

	cmp	BYTE PTR [ebx+2256], 0
	mov	ebp, eax
	je	$LN13@ProcessGre
	push	esi

; 843  : 		return;
; 844  : 
; 845  : 	int iLoop;
; 846  : 	for(CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[esp+20]
	push	eax
	mov	ecx, ebx
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	$LN28@ProcessGre
	push	edi
	npad	1
$LL15@ProcessGre:

; 847  : 	{
; 848  : 		if(pLoopUnit->getSpecialUnitType() != eSpecialUnitGreatPerson)

	mov	ecx, esi
	call	?getSpecialUnitType@CvUnit@@QBE?AW4SpecialUnitTypes@@XZ ; CvUnit::getSpecialUnitType
	cmp	eax, ebp
	jne	$LN14@ProcessGre

; 849  : 		{
; 850  : 			continue;
; 851  : 		}
; 852  : 
; 853  : 		GreatPeopleDirectiveTypes eDirective = NO_GREAT_PEOPLE_DIRECTIVE_TYPE;
; 854  : 		switch(pLoopUnit->AI_getUnitAIType())

	mov	ecx, esi
	or	edi, -1
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	add	eax, -11				; fffffff5H
	cmp	eax, 30					; 0000001eH
	ja	SHORT $LN10@ProcessGre
	movzx	ecx, BYTE PTR $LN27@ProcessGre[eax]
	jmp	DWORD PTR $LN30@ProcessGre[ecx*4]
$LN9@ProcessGre:

; 855  : 		{
; 856  : 		case UNITAI_WRITER:
; 857  : 			eDirective = GetDirectiveWriter(pLoopUnit);

	push	esi
	mov	ecx, ebx
	call	?GetDirectiveWriter@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveWriter
	mov	edi, eax

; 858  : 			break;

	jmp	SHORT $LN10@ProcessGre
$LN8@ProcessGre:

; 859  : 		case UNITAI_ARTIST:
; 860  : 			eDirective = GetDirectiveArtist(pLoopUnit);

	push	esi
	mov	ecx, ebx
	call	?GetDirectiveArtist@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveArtist
	mov	edi, eax

; 861  : 			break;

	jmp	SHORT $LN10@ProcessGre
$LN7@ProcessGre:

; 862  : 		case UNITAI_MUSICIAN:
; 863  : 			eDirective = GetDirectiveMusician(pLoopUnit);

	push	esi
	mov	ecx, ebx
	call	?GetDirectiveMusician@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveMusician
	mov	edi, eax

; 864  : 			break;

	jmp	SHORT $LN10@ProcessGre
$LN6@ProcessGre:

; 865  : 		case UNITAI_ENGINEER:
; 866  : 			eDirective = GetDirectiveEngineer(pLoopUnit);

	push	esi
	mov	ecx, ebx
	call	?GetDirectiveEngineer@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveEngineer
	mov	edi, eax

; 867  : 			break;

	jmp	SHORT $LN10@ProcessGre
$LN5@ProcessGre:

; 868  : 		case UNITAI_MERCHANT:
; 869  : 			eDirective = GetDirectiveMerchant(pLoopUnit);

	push	esi
	mov	ecx, ebx
	call	?GetDirectiveMerchant@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveMerchant
	mov	edi, eax

; 870  : 			break;

	jmp	SHORT $LN10@ProcessGre
$LN4@ProcessGre:

; 871  : 		case UNITAI_SCIENTIST:
; 872  : 			eDirective = GetDirectiveScientist(pLoopUnit);

	push	esi
	mov	ecx, ebx
	call	?GetDirectiveScientist@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveScientist
	mov	edi, eax

; 873  : 			break;

	jmp	SHORT $LN10@ProcessGre
$LN3@ProcessGre:

; 874  : 		case UNITAI_GENERAL:
; 875  : 			eDirective = GetDirectiveGeneral(pLoopUnit);

	push	esi
	mov	ecx, ebx
	call	?GetDirectiveGeneral@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveGeneral
	mov	edi, eax

; 876  : 			break;

	jmp	SHORT $LN10@ProcessGre
$LN2@ProcessGre:

; 877  : 		case UNITAI_PROPHET:
; 878  : 			eDirective = GetDirectiveProphet(pLoopUnit);

	push	esi
	mov	ecx, ebx
	call	?GetDirectiveProphet@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveProphet
	mov	edi, eax

; 879  : 			break;

	jmp	SHORT $LN10@ProcessGre
$LN1@ProcessGre:

; 880  : 		case UNITAI_ADMIRAL:
; 881  : 			eDirective = GetDirectiveAdmiral(pLoopUnit);

	or	edi, -1
$LN10@ProcessGre:

; 882  : 			break;
; 883  : 		}
; 884  : 
; 885  : 		pLoopUnit->SetGreatPeopleDirective(eDirective);

	push	edi
	mov	ecx, esi
	call	?SetGreatPeopleDirective@CvUnit@@QAEXW4GreatPeopleDirectiveTypes@@@Z ; CvUnit::SetGreatPeopleDirective
$LN14@ProcessGre:
	push	0
	lea	edx, DWORD PTR _iLoop$[esp+24]
	push	edx
	mov	ecx, ebx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	$LL15@ProcessGre
	pop	edi
$LN28@ProcessGre:
	pop	esi
$LN13@ProcessGre:
	pop	ebp
	pop	ebx

; 886  : 	}
; 887  : }

	pop	ecx
	ret	0
$LN30@ProcessGre:
	DD	$LN8@ProcessGre
	DD	$LN4@ProcessGre
	DD	$LN3@ProcessGre
	DD	$LN5@ProcessGre
	DD	$LN6@ProcessGre
	DD	$LN2@ProcessGre
	DD	$LN1@ProcessGre
	DD	$LN9@ProcessGre
	DD	$LN7@ProcessGre
	DD	$LN10@ProcessGre
$LN27@ProcessGre:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	5
	DB	9
	DB	9
	DB	6
	DB	9
	DB	9
	DB	7
	DB	8
?ProcessGreatPeople@CvPlayerAI@@QAEXXZ ENDP		; CvPlayerAI::ProcessGreatPeople
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEPAUCityAndProduction@@PAU3@IABU3@@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEPAUCityAndProduction@@PAU3@IABU3@@Z
_TEXT	SEGMENT
$T236666 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$236670 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEPAUCityAndProduction@@PAU3@IABU3@@Z PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$236670[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T236666[esp+12], 0
	mov	eax, DWORD PTR $T236666[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CityAndProduction *,unsigned int,CityAndProduction,std::allocator<CityAndProduction> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*8]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEPAUCityAndProduction@@PAU3@IABU3@@Z ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXPAUCityAndProduction@@0@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXPAUCityAndProduction@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXPAUCityAndProduction@@0@Z PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXPAUCityAndProduction@@0@Z ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@stdext@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@stdext@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@std@@@Z
_TEXT	SEGMENT
$T236705 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$236709 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@stdext@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$236709[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T236705[esp+4], 0
	mov	eax, DWORD PTR $T236705[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@stdext@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@@Z ; std::_Insertion_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Insertion_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@@Z PROC ; std::_Insertion_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>, COMDAT

; 3150 : 	std::_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

	mov	eax, DWORD PTR __Pred$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@UCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@PAUCityAndProduction@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,CityAndProduction>
	add	esp, 16					; 00000010H

; 3151 : 	}

	ret	0
??$_Insertion_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@@Z ENDP ; std::_Insertion_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V23@UCityAndProductionEval@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@0V12@11UCityAndProductionEval@@@Z ; stdext::unchecked_merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V23@UCityAndProductionEval@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@0V12@11UCityAndProductionEval@@@Z
_TEXT	SEGMENT
$T236722 = -4						; size = 1
$T236723 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$unchecked_merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V23@UCityAndProductionEval@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@0V12@11UCityAndProductionEval@@@Z PROC ; stdext::unchecked_merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ecx

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T236723[esp]
	mov	edx, DWORD PTR __Pred$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T236722[esp+8], 0
	mov	eax, DWORD PTR $T236722[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First2$[esp+16]
	push	eax
	mov	eax, DWORD PTR __Last1$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First1$[esp+24]
	push	edx
	push	eax
	push	ecx
	push	esi
	call	??$_Merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V23@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@11UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
	mov	eax, esi
	pop	esi

; 5160 : 	}

	pop	ecx
	ret	0
??$unchecked_merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V23@UCityAndProductionEval@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@0V12@11UCityAndProductionEval@@@Z ENDP ; stdext::unchecked_merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	??$_Unchecked_merge_backward@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@V12@UCityAndProductionEval@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@0PAUCityAndProduction@@10UCityAndProductionEval@@@Z ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_merge_backward@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@V12@UCityAndProductionEval@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@0PAUCityAndProduction@@10UCityAndProductionEval@@@Z
_TEXT	SEGMENT
$T236731 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$_Unchecked_merge_backward@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@V12@UCityAndProductionEval@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@0PAUCityAndProduction@@10UCityAndProductionEval@@@Z PROC ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>, COMDAT

; 5227 : 	{

	push	ecx

; 5228 : 		return _STD _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T236731[esp+8], 0
	mov	eax, DWORD PTR $T236731[esp+8]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+16]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+20]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge_backward@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@V12@UCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0PAUCityAndProduction@@10UCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
	add	esp, 32					; 00000020H
	mov	eax, esi
	pop	esi

; 5229 : 	}

	pop	ecx
	ret	0
??$_Unchecked_merge_backward@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@V12@UCityAndProductionEval@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@0PAUCityAndProduction@@10UCityAndProductionEval@@@Z ENDP ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V?$_Temp_iterator@UCityAndProduction@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,int,CityAndProductionEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V?$_Temp_iterator@UCityAndProduction@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T236740 = -20						; size = 20
$T236738 = -20						; size = 20
$T236736 = -20						; size = 20
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
$T236735 = 36						; size = 4
__Chunk$ = 36						; size = 4
$T236739 = 40						; size = 4
$T236737 = 40						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V?$_Temp_iterator@UCityAndProduction@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,int,CityAndProductionEval>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	esi, DWORD PTR __First$[esp+28]
	push	edi
	mov	edi, DWORD PTR __Chunk$[esp+32]
	lea	ebp, DWORD PTR [edi+edi]
	xor	ebx, ebx
	cmp	ebp, DWORD PTR __Count$[esp+32]
	jg	SHORT $LN3@Chunked_me
	npad	6
$LL5@Chunked_me:

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;
; 3438 : 		std::advance(_Mid1, _Chunk);
; 3439 : 		_BidIt _Mid2 = _Mid1;
; 3440 : 		std::advance(_Mid2, _Chunk);
; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+32]
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	lea	ecx, DWORD PTR [esi+edi*8]
	mov	DWORD PTR $T236735[esp+56], esp
	lea	esi, DWORD PTR [ecx+edi*8]
	push	esi
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+76]
	push	ecx
	push	ecx
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __First$[esp+68]
	push	eax
	lea	ecx, DWORD PTR $T236736[esp+76]
	push	ecx
	call	??$unchecked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@000V12@UCityAndProductionEval@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,CityAndProductionEval>
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T236736[esp+80]
	add	esp, 44					; 0000002cH
	mov	DWORD PTR __Dest$[esp+48], edx
	cmp	eax, ebx
	je	SHORT $LN49@Chunked_me
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN49@Chunked_me:
	mov	eax, DWORD PTR __Count$[esp+32]
	sub	eax, ebp
	cmp	eax, ebp

; 3443 : 		_First = _Mid2;

	mov	DWORD PTR __First$[esp+32], esi
	mov	DWORD PTR __Count$[esp+32], eax
	jge	SHORT $LL5@Chunked_me
$LN3@Chunked_me:

; 3444 : 		}
; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	cmp	DWORD PTR __Count$[esp+32], edi
	jg	SHORT $LN2@Chunked_me

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+68]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+52]
	mov	eax, DWORD PTR __First$[esp+52]
	mov	DWORD PTR $T236737[esp+52], esp
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T236738[esp+64]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
	add	esp, 32					; 00000020H

; 3448 : 	else

	jmp	SHORT $LN111@Chunked_me
$LN2@Chunked_me:

; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;
; 3451 : 		std::advance(_Mid1, _Chunk);
; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+32]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+56]
	mov	DWORD PTR $T236739[esp+56], esp
	push	eax
	lea	ecx, DWORD PTR [esi+edi*8]
	push	ecx
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+68]
	push	ecx
	lea	edx, DWORD PTR $T236740[esp+76]
	push	edx
	call	??$unchecked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@000V12@UCityAndProductionEval@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,CityAndProductionEval>
	add	esp, 44					; 0000002cH
$LN111@Chunked_me:
	mov	eax, DWORD PTR $T236740[esp+36]
	cmp	eax, ebx
	je	SHORT $LN87@Chunked_me
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN87@Chunked_me:

; 3454 : 		}
; 3455 : 	}

	mov	eax, DWORD PTR __Dest$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN97@Chunked_me
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN97@Chunked_me:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V?$_Temp_iterator@UCityAndProduction@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,int,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProductionEval@@@std@@YAXPAUCityAndProduction@@0V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProductionEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProductionEval@@@std@@YAXPAUCityAndProduction@@0V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T236970 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
$T237015 = 20						; size = 1
__Chunk$ = 20						; size = 4
$T237123 = 24						; size = 1
$T237124 = 24						; size = 1
$T237016 = 24						; size = 1
$T236972 = 24						; size = 4
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Chunked_merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProductionEval@@@std@@YAXPAUCityAndProduction@@0V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProductionEval>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	push	ecx

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	mov	eax, DWORD PTR __First$[esp]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Chunk$[esp+12]
	lea	ebp, DWORD PTR [edi+edi]
	cmp	ebp, ecx
	jg	SHORT $LN3@Chunked_me@2
	push	ebx
	npad	4
$LL58@Chunked_me@2:

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;
; 3438 : 		std::advance(_Mid1, _Chunk);
; 3439 : 		_BidIt _Mid2 = _Mid1;
; 3440 : 		std::advance(_Mid2, _Chunk);
; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	mov	BYTE PTR $T237015[esp+16], 0
	mov	ebx, DWORD PTR $T237015[esp+16]
	push	ebx
	mov	ebx, DWORD PTR $T237016[esp+20]
	push	ebx
	mov	ebx, DWORD PTR __Pred$[esp+24]
	push	ebx
	lea	ecx, DWORD PTR [eax+edi*8]
	push	edx
	lea	esi, DWORD PTR [ecx+edi*8]
	push	esi
	push	ecx
	push	ecx
	push	eax
	lea	eax, DWORD PTR $T236970[esp+52]
	push	eax
	call	??$_Merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@000V10@UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,std::random_access_iterator_tag>
	mov	ecx, DWORD PTR __Count$[esp+52]
	mov	edx, DWORD PTR $T236970[esp+56]
	sub	ecx, ebp
	add	esp, 36					; 00000024H
	cmp	ecx, ebp
	mov	DWORD PTR __Dest$[esp+16], edx

; 3443 : 		_First = _Mid2;

	mov	eax, esi
	mov	DWORD PTR __Count$[esp+16], ecx
	jge	SHORT $LL58@Chunked_me@2
	pop	ebx
$LN3@Chunked_me@2:

; 3444 : 		}
; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	cmp	ecx, edi
	jg	SHORT $LN2@Chunked_me@2

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	ecx, DWORD PTR __Last$[esp+12]
	cmp	eax, ecx
	je	SHORT $LN49@Chunked_me@2
$LL32@Chunked_me@2:
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx], esi
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], esi
	add	eax, 8
	add	edx, 8
	cmp	eax, ecx
	jne	SHORT $LL32@Chunked_me@2
	pop	edi
	pop	esi
	pop	ebp

; 3454 : 		}
; 3455 : 	}

	pop	ecx
	ret	0
$LN2@Chunked_me@2:

; 3448 : 	else
; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;
; 3451 : 		std::advance(_Mid1, _Chunk);
; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	BYTE PTR $T237123[esp+12], 0
	mov	ecx, DWORD PTR $T237123[esp+12]
	push	ecx
	mov	ecx, DWORD PTR $T237124[esp+16]
	push	ecx
	mov	ecx, DWORD PTR __Pred$[esp+20]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+28]
	push	edx
	lea	edi, DWORD PTR [eax+edi*8]
	push	edi
	push	edi
	push	eax
	lea	eax, DWORD PTR $T236972[esp+44]
	push	eax
	call	??$_Merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@000V10@UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
$LN49@Chunked_me@2:
	pop	edi
	pop	esi
	pop	ebp

; 3454 : 		}
; 3455 : 	}

	pop	ecx
	ret	0
??$_Chunked_merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProductionEval@@@std@@YAXPAUCityAndProduction@@0V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	??$rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00@Z ; std::rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00@Z PROC ; std::rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >, COMDAT

; 1719 : 	if (_First != _Mid && _Mid != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Mid$[esp-4]
	cmp	edx, eax
	je	SHORT $LN14@rotate
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN14@rotate

; 1720 : 		_Rotate(_CHECKED_BASE(_First), _CHECKED_BASE(_Mid), _CHECKED_BASE(_Last), _Iter_cat(_First));

	push	0
	push	0
	push	ecx
	push	eax
	push	edx
	call	??$_Rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00PAHPAUCityAndProduction@@@Z ; std::_Rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction>
	add	esp, 20					; 00000014H
$LN14@rotate:

; 1721 : 	}

	ret	0
??$rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00@Z ENDP ; std::rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> > >
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T237191 = 12						; size = 4
$T237189 = 12						; size = 4
__Where$199253 = 12					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ecx
	push	ebp

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	mov	ebp, DWORD PTR __Val$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+17], 0
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+16], cl
	jne	SHORT $LN9@insert
	mov	edx, DWORD PTR [ebp]
	npad	1
$LL10@insert:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;
; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edx, DWORD PTR [eax+12]
	mov	esi, eax
	setb	cl
	mov	BYTE PTR __Addleft$[esp+16], cl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	test	cl, cl
	je	SHORT $LN13@insert
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@insert
$LN13@insert:
	mov	eax, DWORD PTR [eax+8]
$LN14@insert:

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL10@insert
$LN9@insert:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, esi
	mov	DWORD PTR __Where$199253[esp+12], edx

; 647  : 			if (!_Addleft)

	test	cl, cl
	je	SHORT $LN57@insert

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	lea	ecx, DWORD PTR $T237189[esp+12]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN4@insert
	push	ebp
	push	esi
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN4@insert:

; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay

	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Where$199253[esp+12]
$LN57@insert:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR [ebp]
	jae	SHORT $LN2@insert

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Addleft$[esp+16]
	push	ebp
	push	esi
	push	ecx
	lea	edx, DWORD PTR $T237191[esp+24]
	push	edx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], 1
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN2@insert:

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 0
	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
_TEXT	ENDS
EXTRN	?DoTurn@CvTradeAI@@QAEXXZ:PROC			; CvTradeAI::DoTurn
EXTRN	?GetTradeAI@CvPlayer@@QBEPAVCvTradeAI@@XZ:PROC	; CvPlayer::GetTradeAI
EXTRN	?DoTurn@CvEspionageAI@@QAEXXZ:PROC		; CvEspionageAI::DoTurn
EXTRN	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ:PROC ; CvPlayer::GetEspionageAI
EXTRN	?getNumVictoryInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumVictoryInfos
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
;	COMDAT ?AI_doTurnPost@CvPlayerAI@@UAEXXZ
_TEXT	SEGMENT
?AI_doTurnPost@CvPlayerAI@@UAEXXZ PROC			; CvPlayerAI::AI_doTurnPost, COMDAT
; _this$ = ecx

; 106  : {

	push	edi
	mov	edi, ecx

; 107  : 	AI_PERF_FORMAT("AI-perf.csv", ("CvPlayerAI::AI_doTurnPost, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
; 108  : 	if(isHuman())

	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN7@AI_doTurnP

; 109  : 	{
; 110  : 		return;
; 111  : 	}
; 112  : 
; 113  : 	if(isBarbarian())

	mov	ecx, edi
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	SHORT $LN7@AI_doTurnP

; 114  : 	{
; 115  : 		return;
; 116  : 	}
; 117  : 
; 118  : 	if(isMinorCiv())

	mov	ecx, edi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN7@AI_doTurnP
	push	esi

; 119  : 	{
; 120  : 		return;
; 121  : 	}
; 122  : 
; 123  : #ifdef AUI_WARNING_FIXES
; 124  : 	for (uint i = 0; i < GC.getNumVictoryInfos(); ++i)
; 125  : #else
; 126  : 	for(int i = 0; i < GC.getNumVictoryInfos(); ++i)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	test	eax, eax
	jle	SHORT $LN1@AI_doTurnP
$LL3@AI_doTurnP:

; 127  : #endif
; 128  : 	{
; 129  : 		AI_launch((VictoryTypes)i);

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+68]
	push	esi
	mov	ecx, edi
	call	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	cmp	esi, eax
	jl	SHORT $LL3@AI_doTurnP
$LN1@AI_doTurnP:

; 130  : 	}
; 131  : 
; 132  : 	ProcessGreatPeople();

	mov	ecx, edi
	call	?ProcessGreatPeople@CvPlayerAI@@QAEXXZ	; CvPlayerAI::ProcessGreatPeople

; 133  : 	GetEspionageAI()->DoTurn();

	mov	ecx, edi
	call	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ ; CvPlayer::GetEspionageAI
	mov	ecx, eax
	call	?DoTurn@CvEspionageAI@@QAEXXZ		; CvEspionageAI::DoTurn

; 134  : 	GetTradeAI()->DoTurn();

	mov	ecx, edi
	call	?GetTradeAI@CvPlayer@@QBEPAVCvTradeAI@@XZ ; CvPlayer::GetTradeAI
	pop	esi
	mov	ecx, eax
	pop	edi
	jmp	?DoTurn@CvTradeAI@@QAEXXZ		; CvTradeAI::DoTurn
$LN7@AI_doTurnP:
	pop	edi

; 135  : }

	ret	0
?AI_doTurnPost@CvPlayerAI@@UAEXXZ ENDP			; CvPlayerAI::AI_doTurnPost
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXXZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXXZ PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXXZ ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Umove@PAUCityAndProduction@@@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEPAUCityAndProduction@@PAU2@00@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Umove<CityAndProduction *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAUCityAndProduction@@@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEPAUCityAndProduction@@PAU2@00@Z
_TEXT	SEGMENT
$T237380 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$237383 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUCityAndProduction@@@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEPAUCityAndProduction@@PAU2@00@Z PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Umove<CityAndProduction *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$237383[esp]
	mov	BYTE PTR $T237380[esp+4], 0
	mov	eax, DWORD PTR $T237380[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAUCityAndProduction@@@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEPAUCityAndProduction@@PAU2@00@Z ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Umove<CityAndProduction *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@stdext@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@0V?$_Temp_iterator@UCityAndProduction@@@2@HHUCityAndProductionEval@@@Z ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,int,CityAndProductionEval>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unchecked_chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@stdext@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@0V?$_Temp_iterator@UCityAndProduction@@@2@HHUCityAndProductionEval@@@Z
_TEXT	SEGMENT
$T237390 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T237391 = 40						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
??$_Unchecked_chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@stdext@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@0V?$_Temp_iterator@UCityAndProduction@@@2@HHUCityAndProductionEval@@@Z PROC ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,int,CityAndProductionEval>, COMDAT

; 5285 : 	{

	push	ecx

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Count$[esp]
	push	ebx
	xor	ebx, ebx
	mov	BYTE PTR $T237390[esp+8], bl
	mov	eax, DWORD PTR $T237390[esp+8]
	push	eax
	mov	eax, DWORD PTR __Chunk$[esp+8]
	push	ecx
	push	edx
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+40]
	mov	eax, DWORD PTR __First$[esp+40]
	mov	DWORD PTR $T237391[esp+40], esp
	push	edx
	push	eax
	call	??$_Chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V?$_Temp_iterator@UCityAndProduction@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,int,CityAndProductionEval>

; 5287 : 	}

	mov	eax, DWORD PTR __Dest$[esp+48]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN17@Unchecked_@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@Unchecked_@2:
	pop	ebx
	pop	ecx
	ret	0
??$_Unchecked_chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@stdext@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@0V?$_Temp_iterator@UCityAndProduction@@@2@HHUCityAndProductionEval@@@Z ENDP ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,int,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProductionEval@@@stdext@@YAXPAUCityAndProduction@@0V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HHUCityAndProductionEval@@@Z ; stdext::_Unchecked_chunked_merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProductionEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProductionEval@@@stdext@@YAXPAUCityAndProduction@@0V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HHUCityAndProductionEval@@@Z
_TEXT	SEGMENT
$T237427 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 1
??$_Unchecked_chunked_merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProductionEval@@@stdext@@YAXPAUCityAndProduction@@0V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HHUCityAndProductionEval@@@Z PROC ; stdext::_Unchecked_chunked_merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProductionEval>, COMDAT

; 5285 : 	{

	push	ecx

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Count$[esp]
	mov	BYTE PTR $T237427[esp+4], 0
	mov	eax, DWORD PTR $T237427[esp+4]
	push	eax
	mov	eax, DWORD PTR __Chunk$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First$[esp+16]
	push	ecx
	push	edx
	push	eax
	call	??$_Chunked_merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProductionEval@@@std@@YAXPAUCityAndProduction@@0V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProductionEval>

; 5287 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$_Unchecked_chunked_merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProductionEval@@@stdext@@YAXPAUCityAndProduction@@0V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HHUCityAndProductionEval@@@Z ENDP ; stdext::_Unchecked_chunked_merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@@Z
_TEXT	SEGMENT
$T237435 = -20						; size = 20
$T237432 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Mid$ = 16						; size = 4
__Last$ = 20						; size = 4
$T237607 = 24						; size = 1
__Cat$237612 = 24					; size = 1
$T237609 = 24						; size = 1
$T237579 = 24						; size = 1
__Cat$237583 = 24					; size = 1
$T237581 = 24						; size = 1
$T237519 = 24						; size = 1
__Cat$237523 = 24					; size = 1
$T237521 = 24						; size = 1
$T237486 = 24						; size = 1
__Cat$237490 = 24					; size = 1
$T237488 = 24						; size = 1
$T237436 = 24						; size = 4
$T237434 = 24						; size = 4
$T237433 = 24						; size = 4
$T237431 = 24						; size = 4
__Count1$ = 24						; size = 4
__Count2$ = 28						; size = 4
__Tempbuf$ = 32						; size = 4
??$_Buffered_rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@@Z PROC ; std::_Buffered_rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Count2$[esp+24]
	push	esi
	mov	esi, DWORD PTR __Tempbuf$[esp+28]
	push	edi
	mov	edi, DWORD PTR __Count1$[esp+32]
	cmp	edi, ebp
	jg	$LN4@Buffered_r
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@UCityAndProduction@@@std@@QAEHXZ ; std::_Temp_iterator<CityAndProduction>::_Maxlen
	cmp	edi, eax
	jg	$LN4@Buffered_r

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Mid$[esp+52]
	mov	ecx, DWORD PTR __First$[esp+52]
	mov	DWORD PTR $T237431[esp+52], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T237432[esp+64]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
	mov	eax, DWORD PTR $T237432[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN25@Buffered_r
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Buffered_r:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	BYTE PTR $T237486[esp+32], bl
	mov	eax, DWORD PTR $T237486[esp+32]
	mov	ecx, DWORD PTR __Cat$237490[esp+32]
	mov	edx, DWORD PTR $T237488[esp+32]
	push	eax
	mov	eax, DWORD PTR __First$[esp+36]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+40]
	push	edx
	mov	edx, DWORD PTR __Mid$[esp+44]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T237433[esp+56]
	push	eax
	call	??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T237519[esp+60], bl
	mov	ecx, DWORD PTR $T237519[esp+60]
	mov	edx, DWORD PTR __Cat$237523[esp+60]
	mov	eax, DWORD PTR $T237521[esp+60]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+64]
	push	edx
	mov	edx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+72]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Copy_backward_opt@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	mov	eax, esi

; 2700 : 		std::advance(_First, _Count2);
; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN4@Buffered_r:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@UCityAndProduction@@@std@@QAEHXZ ; std::_Temp_iterator<CityAndProduction>::_Maxlen
	cmp	ebp, eax
	jg	$LN2@Buffered_r

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+52]
	mov	ecx, DWORD PTR __Mid$[esp+52]
	mov	DWORD PTR $T237434[esp+52], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T237435[esp+64]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
	mov	eax, DWORD PTR $T237435[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN57@Buffered_r
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Buffered_r:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	BYTE PTR $T237579[esp+32], bl
	mov	eax, DWORD PTR $T237579[esp+32]
	mov	ecx, DWORD PTR __Cat$237583[esp+32]
	mov	edx, DWORD PTR $T237581[esp+32]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+36]
	push	ecx
	mov	ecx, DWORD PTR __Mid$[esp+40]
	push	edx
	mov	edx, DWORD PTR __First$[esp+44]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T237436[esp+56]
	push	eax
	call	??$_Copy_backward_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T237607[esp+60], bl
	mov	ecx, DWORD PTR $T237607[esp+60]
	mov	edx, DWORD PTR __Cat$237612[esp+60]
	mov	eax, DWORD PTR $T237609[esp+60]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+64]
	push	edx
	mov	edx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+72]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	mov	eax, esi

; 2700 : 		std::advance(_First, _Count2);
; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN2@Buffered_r:

; 2696 : 		}
; 2697 : 	else
; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	eax, DWORD PTR __First$[esp+32]
	mov	ecx, DWORD PTR __Mid$[esp+32]
	cmp	eax, ecx
	je	SHORT $LN88@Buffered_r
	mov	edx, DWORD PTR __Last$[esp+32]
	cmp	ecx, edx
	je	SHORT $LN88@Buffered_r
	xor	ebx, ebx
	push	ebx
	push	ebx
	push	edx
	push	ecx
	push	eax
	call	??$_Rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00PAHPAUCityAndProduction@@@Z ; std::_Rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction>
	mov	eax, DWORD PTR __First$[esp+52]
	add	esp, 20					; 00000014H
$LN88@Buffered_r:

; 2700 : 		std::advance(_First, _Count2);
; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	lea	ecx, DWORD PTR [eax+ebp*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+28]
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Buffered_rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@@Z ENDP ; std::_Buffered_rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction>
_TEXT	ENDS
PUBLIC	?touch@FAutoArchive@@QAEXAAVFAutoVariableBase@@@Z ; FAutoArchive::touch
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautoarchive.h
;	COMDAT ?touch@FAutoArchive@@QAEXAAVFAutoVariableBase@@@Z
_TEXT	SEGMENT
$T237723 = -8						; size = 8
$T237722 = 8						; size = 4
_dirtyVariable$ = 8					; size = 4
?touch@FAutoArchive@@QAEXAAVFAutoVariableBase@@@Z PROC	; FAutoArchive::touch, COMDAT
; _this$ = ecx

; 55   : 	{

	sub	esp, 8

; 56   : #ifdef FAUTOARCHIVE_DEBUG
; 57   : 		debugHelp(dirtyVariable);
; 58   : #endif//FAUTOARCHIVE_DEBUG
; 59   : 		m_deltas.insert(&dirtyVariable);

	mov	eax, DWORD PTR _dirtyVariable$[esp+4]
	lea	edx, DWORD PTR $T237722[esp+4]
	mov	DWORD PTR $T237722[esp+4], eax
	push	edx
	lea	eax, DWORD PTR $T237723[esp+12]
	push	eax
	add	ecx, 20					; 00000014H
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert

; 60   : 	}

	add	esp, 8
	ret	4
?touch@FAutoArchive@@QAEXAAVFAutoVariableBase@@@Z ENDP	; FAutoArchive::touch
_TEXT	ENDS
PUBLIC	??1?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::~vector<CityAndProduction,std::allocator<CityAndProduction> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::~vector<CityAndProduction,std::allocator<CityAndProduction> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@2:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::~vector<CityAndProduction,std::allocator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z$2
__catchsym$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z$0
__unwindtable$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z
_TEXT	SEGMENT
__Tmp$227554 = -24					; size = 8
__Tmp$227544 = -24					; size = 8
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$237944 = 8					; size = 1
__Cat$237872 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$227529 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T237940 = 16						; size = 1
$T237868 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 3
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	ebx, DWORD PTR __Count$[ebp]
	test	ebx, ebx
	je	$LN1@Insert_n

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	edi, DWORD PTR [esi+8]
	mov	eax, edi
	sub	eax, edx
	sar	eax, 3
	mov	edx, 536870911				; 1fffffffH
	sub	edx, eax
	cmp	edx, ebx
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Xlen
$LN87@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+ebx]
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	edi, 536870911				; 1fffffffH
	sub	edi, eax
	cmp	edi, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@UCityAndProduction@@@std@@YAPAUCityAndProduction@@IPAU1@@Z ; std::_Allocate<CityAndProduction>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edi, DWORD PTR __Where$[ebp]
	sub	edi, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	push	ecx
	sar	edi, 3
	push	ebx
	lea	edx, DWORD PTR [eax+edi*8]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$227529[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEPAUCityAndProduction@@PAU3@IABU3@@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$237872[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T237868[ebp], 0
	mov	ecx, DWORD PTR $T237868[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$227529[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T237940[ebp], 0
	mov	edx, DWORD PTR $T237940[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$237944[ebp]
	push	edx
	lea	ecx, DWORD PTR [edi+ebx]
	mov	edi, DWORD PTR __Newvec$227529[ebp]
	push	esi
	lea	ecx, DWORD PTR [edi+ecx*8]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 3
	add	esp, 24					; 00000018H
	add	ebx, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [edi+edx*8]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [edi+ebx*8]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], edi

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$227529[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n:
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sar	ecx, 3
	cmp	ecx, ebx
	jae	SHORT $LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$227544[ebp+4], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ecx, DWORD PTR [ebx*8]
	mov	DWORD PTR tv515[ebp], ecx
	add	ecx, eax
	push	ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Tmp$227544[ebp], edx
	call	??$_Umove@PAUCityAndProduction@@@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEPAUCityAndProduction@@PAU2@00@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Umove<CityAndProduction *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$227544[ebp]
	sar	ecx, 3
	push	edx
	sub	ebx, ecx
	push	ebx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEPAUCityAndProduction@@PAU3@IABU3@@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$227544[ebp]
	push	edx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	eax
	call	??$fill@PAUCityAndProduction@@U1@@std@@YAXPAUCityAndProduction@@0ABU1@@Z ; std::fill<CityAndProduction *,CityAndProduction>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [ebx*8]
	push	edi
	mov	ebx, edi
	sub	ebx, eax
	push	edi
	mov	DWORD PTR __Tmp$227554[ebp], ecx
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$227554[ebp+4], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAUCityAndProduction@@@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEPAUCityAndProduction@@PAU2@00@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Umove<CityAndProduction *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	edi
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	ebx
	push	eax
	call	??$_Unchecked_move_backward@PAUCityAndProduction@@PAU1@@stdext@@YAPAUCityAndProduction@@PAU1@00@Z ; stdext::_Unchecked_move_backward<CityAndProduction *,CityAndProduction *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$227554[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAUCityAndProduction@@U1@@std@@YAXPAUCityAndProduction@@0ABU1@@Z ; std::fill<CityAndProduction *,CityAndProduction>
	add	esp, 24					; 00000018H
$LN1@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Insert_n
PUBLIC	?set@?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QAEXABW4PlayerTypes@@@Z ; FAutoVariable<enum PlayerTypes,CvPlayer>::set
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?set@?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QAEXABW4PlayerTypes@@@Z
_TEXT	SEGMENT
$T237981 = -8						; size = 8
$T237980 = 8						; size = 4
_source$ = 8						; size = 4
?set@?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QAEXABW4PlayerTypes@@@Z PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::set, COMDAT
; _this$ = ecx

; 225  : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 226  : 	if(m_value != source)

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _source$[esp+12]
	cmp	eax, DWORD PTR [edi]
	je	SHORT $LN1@set

; 227  : 	{
; 228  : 		m_owner.touch(*this);

	lea	ecx, DWORD PTR $T237980[esp+12]
	push	ecx
	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR $T237981[esp+20]
	push	edx
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T237980[esp+20], esi
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert

; 229  : 		m_value = source;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax
$LN1@set:
	pop	edi
	pop	esi

; 230  : 	}
; 231  : }

	add	esp, 8
	ret	4
?set@?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QAEXABW4PlayerTypes@@@Z ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::set
_TEXT	ENDS
PUBLIC	??$_Buffered_merge_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_merge_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z
_TEXT	SEGMENT
$T238114 = -8						; size = 1
$T238085 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T238084 = 16						; size = 1
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Buffered_merge_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z PROC ; std::_Buffered_merge_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>, COMDAT

; 3503 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3504 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp+20]
	xor	ebx, ebx
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN4@Buffered_m
	mov	ebp, edi
	shr	ebp, 5
	npad	5
$LL6@Buffered_m:

; 3505 : 		{	// sort chunks
; 3506 : 		_BidIt _Midn = _Mid;
; 3507 : 		std::advance(_Midn, (int)_ISORT_MAX);
; 3508 : 
; 3509 : 		std::_Insertion_sort(_Mid, _Midn, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+20]
	push	ebx
	push	ecx
	lea	esi, DWORD PTR [eax+256]
	push	esi
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@UCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@PAUCityAndProduction@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,CityAndProduction>
	add	esp, 16					; 00000010H
	sub	ebp, 1

; 3510 : 		_Mid = _Midn;

	mov	eax, esi
	jne	SHORT $LL6@Buffered_m
$LN4@Buffered_m:

; 3511 : 		}
; 3512 : 	std::_Insertion_sort(_Mid, _Last, _Pred);	// sort partial last chunk

	mov	edx, DWORD PTR __Pred$[esp+20]
	mov	ecx, DWORD PTR __Last$[esp+20]
	push	ebx
	push	edx
	push	ecx
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@UCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@PAUCityAndProduction@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,CityAndProduction>

; 3513 : 
; 3514 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	esi, 32					; 00000020H
	add	esp, 16					; 00000010H
	cmp	edi, esi
	jle	SHORT $LN1@Buffered_m
	mov	ebp, DWORD PTR __Tempbuf$[esp+20]
	npad	2
$LL3@Buffered_m:

; 3515 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3516 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3517 : 			_Chunk, _Count, _Pred);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Pred$[esp+20]
	mov	ecx, DWORD PTR [ebp+16]
	mov	BYTE PTR $T238084[esp+20], bl
	mov	eax, DWORD PTR $T238084[esp+20]
	push	eax
	push	edx
	push	edi
	push	esi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __Last$[esp+56]
	mov	ecx, DWORD PTR __First$[esp+56]
	mov	DWORD PTR $T238085[esp+60], esp
	push	eax
	push	ecx
	call	??$_Chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V?$_Temp_iterator@UCityAndProduction@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,int,CityAndProductionEval>

; 3518 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3519 : 			_Chunk *= 2, _Count, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+64]
	mov	eax, DWORD PTR [ebp+16]
	mov	BYTE PTR $T238114[esp+68], bl
	mov	edx, DWORD PTR $T238114[esp+68]
	push	edx
	mov	edx, DWORD PTR __First$[esp+68]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	add	esi, esi
	push	esi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProductionEval@@@std@@YAXPAUCityAndProduction@@0V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProductionEval>
	add	esi, esi
	add	esp, 72					; 00000048H
	cmp	esi, edi
	jl	SHORT $LL3@Buffered_m
$LN1@Buffered_m:

; 3520 : 		}
; 3521 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Buffered_merge_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ENDP ; std::_Buffered_merge_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z
_TEXT	SEGMENT
tv518 = -24						; size = 4
$T238436 = -24						; size = 4
$T238346 = -24						; size = 4
$T238128 = -20						; size = 20
$T238125 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
$T238277 = 20						; size = 1
__Midn$228367 = 20					; size = 4
$T238129 = 20						; size = 4
$T238127 = 20						; size = 4
$T238126 = 20						; size = 4
$T238124 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$_Buffered_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z PROC ; std::_Buffered_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>, COMDAT

; 2889 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred

	sub	esp, 24					; 00000018H
	push	ebx

; 2890 : 	if (_Count1 + _Count2 == 2)

	mov	ebx, DWORD PTR __Count1$[esp+24]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+36]
	lea	eax, DWORD PTR [ebx+edi]
	cmp	eax, 2
	jne	SHORT $LN9@Buffered_m@2

; 2891 : 		{	// order two one-element partitions
; 2892 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp+36]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __First$[esp+36]
	cmp	edx, DWORD PTR [ecx+4]
	jle	$LN3@Buffered_m@2

; 2893 : 			std::iter_swap(_First, _Mid);

	mov	edx, ecx
	cmp	ecx, eax
	je	$LN3@Buffered_m@2
	mov	edi, DWORD PTR [eax]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], edi
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], ecx

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN9@Buffered_m@2:

; 2894 : 		}
; 2895 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	cmp	ebx, edi
	mov	esi, DWORD PTR __Tempbuf$[esp+36]
	jg	$LN6@Buffered_m@2
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@UCityAndProduction@@@std@@QAEHXZ ; std::_Temp_iterator<CityAndProduction>::_Maxlen
	cmp	ebx, eax
	jg	SHORT $LN6@Buffered_m@2

; 2896 : 		{	// buffer left partition, then merge
; 2897 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Mid$[esp+56]
	mov	ecx, DWORD PTR __First$[esp+56]
	mov	DWORD PTR $T238124[esp+56], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T238125[esp+68]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
	mov	eax, DWORD PTR $T238125[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN53@Buffered_m@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN53@Buffered_m@2:

; 2898 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(),
; 2899 : 			_Mid, _Last, _First, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+36]
	mov	ecx, DWORD PTR __First$[esp+36]
	mov	edx, DWORD PTR __Last$[esp+36]
	mov	esi, DWORD PTR [esi+16]
	push	eax
	mov	eax, DWORD PTR __Mid$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	push	edx
	mov	edx, DWORD PTR [esi]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T238126[esp+60]
	push	eax
	call	??$unchecked_merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V23@UCityAndProductionEval@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@0V12@11UCityAndProductionEval@@@Z ; stdext::unchecked_merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
	add	esp, 28					; 0000001cH

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN6@Buffered_m@2:

; 2900 : 		}
; 2901 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@UCityAndProduction@@@std@@QAEHXZ ; std::_Temp_iterator<CityAndProduction>::_Maxlen
	cmp	edi, eax
	jg	$LN4@Buffered_m@2

; 2902 : 		{	// buffer right partition, then merge
; 2903 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+56]
	mov	ecx, DWORD PTR __Mid$[esp+56]
	mov	DWORD PTR $T238127[esp+56], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T238128[esp+68]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
	mov	eax, DWORD PTR $T238128[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN73@Buffered_m@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN73@Buffered_m@2:

; 2904 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid, _Tempbuf._First(), _Tempbuf._Last(),
; 2905 : 			_Last, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+36]
	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR __Last$[esp+36]
	mov	BYTE PTR $T238277[esp+36], bl
	mov	eax, DWORD PTR $T238277[esp+36]
	push	eax
	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	edx
	mov	edx, DWORD PTR __Mid$[esp+48]
	push	eax
	mov	eax, DWORD PTR __First$[esp+52]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T238129[esp+64]
	push	ecx
	call	??$_Merge_backward@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@V12@UCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0PAUCityAndProduction@@10UCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
	add	esp, 32					; 00000020H

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN4@Buffered_m@2:

; 2906 : 		}
; 2907 : 	else
; 2908 : 		{	// buffer too small, divide and conquer
; 2909 : 		_BidIt _Firstn, _Lastn;
; 2910 : 		_Diff _Count1n, _Count2n;
; 2911 : 		if (_Count2 < _Count1)

	cmp	edi, ebx

; 2912 : 			{	// left larger, cut it in half and partition right to match
; 2913 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2914 : 			_Firstn = _First;
; 2915 : 			std::advance(_Firstn, _Count1n);
; 2916 : 			_Lastn = lower_bound(_Mid, _Last, *_Firstn, _Pred);

	push	0
	jge	SHORT $LN2@Buffered_m@2
	mov	ecx, DWORD PTR __Last$[esp+40]
	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __First$[esp+40]
	mov	edi, eax
	mov	eax, DWORD PTR __Pred$[esp+40]
	push	eax
	sar	edi, 1
	lea	ebp, DWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR __Mid$[esp+44]
	push	ebp
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T238346[esp+60]
	push	eax
	call	??$_Lower_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,int,CityAndProductionEval>
	mov	ebx, DWORD PTR [eax]

; 2917 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	esi, ebx
	sub	esi, DWORD PTR __Mid$[esp+60]
	add	esp, 24					; 00000018H
	sar	esi, 3

; 2918 : 			}
; 2919 : 		else

	jmp	SHORT $LN139@Buffered_m@2
$LN2@Buffered_m@2:

; 2920 : 			{	// right larger, cut it in half and partition left to match
; 2921 : 			_Count1n = 0, _Count2n = _Count2 / 2;
; 2922 : 			_Lastn = _Mid;
; 2923 : 			std::advance(_Lastn, _Count2n);
; 2924 : 			_Firstn = upper_bound(_First, _Mid, *_Lastn, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+40]
	mov	eax, edi
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __First$[esp+40]
	mov	esi, eax
	mov	eax, DWORD PTR __Mid$[esp+40]
	push	ecx
	sar	esi, 1
	lea	ebx, DWORD PTR [eax+esi*8]
	push	ebx
	push	eax
	push	edx
	lea	eax, DWORD PTR $T238436[esp+60]
	push	eax
	call	??$_Upper_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,int,CityAndProductionEval>
	mov	ebp, DWORD PTR [eax]

; 2925 : 			_Distance(_First, _Firstn, _Count1n);

	mov	edi, ebp
	sub	edi, DWORD PTR __First$[esp+60]
	add	esp, 24					; 00000018H
	sar	edi, 3
$LN139@Buffered_m@2:

; 2926 : 			}
; 2927 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2928 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	ecx, DWORD PTR __Tempbuf$[esp+36]
	mov	eax, DWORD PTR __Count1$[esp+36]
	mov	edx, DWORD PTR __Mid$[esp+36]
	push	ecx
	push	esi
	sub	eax, edi
	push	eax
	push	ebx
	push	edx
	mov	DWORD PTR tv518[esp+60], eax
	lea	eax, DWORD PTR __Midn$228367[esp+56]
	push	ebp
	push	eax
	call	??$_Buffered_rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction>

; 2929 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2930 : 			_Count1n, _Count2n, _Tempbuf, _Pred);	// merge each new part

	mov	ecx, DWORD PTR __Pred$[esp+64]
	mov	edx, DWORD PTR __Tempbuf$[esp+64]
	mov	eax, DWORD PTR __First$[esp+64]
	push	ecx
	push	edx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Midn$228367[esp+80]
	push	edi
	push	ebp
	push	eax
	call	??$_Buffered_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>

; 2931 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2932 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+92]
	mov	edx, DWORD PTR __Tempbuf$[esp+92]
	mov	eax, DWORD PTR __Count2$[esp+92]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+96]
	push	edx
	sub	eax, esi
	push	eax
	mov	eax, DWORD PTR tv518[esp+108]
	push	eax
	push	ecx
	push	ebx
	push	edi
	call	??$_Buffered_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
	add	esp, 84					; 00000054H
$LN3@Buffered_m@2:

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Buffered_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ENDP ; std::_Buffered_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	?insert@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@V?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@ABUCityAndProduction@@@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@V?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@ABUCityAndProduction@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@V?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@ABUCityAndProduction@@@Z PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -8					; fffffff8H
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@2
	xor	esi, esi
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 3
$LN4@insert@2:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@V?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@ABUCityAndProduction@@@Z ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::insert
_TEXT	ENDS
PUBLIC	??4?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QAEAAW4PlayerTypes@@ABW41@@Z ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator=
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??4?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QAEAAW4PlayerTypes@@ABW41@@Z
_TEXT	SEGMENT
$T238562 = -8						; size = 8
$T238561 = 8						; size = 4
_rhs$ = 8						; size = 4
??4?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QAEAAW4PlayerTypes@@ABW41@@Z PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator=, COMDAT
; _this$ = ecx

; 201  : {

	sub	esp, 8
	push	esi
	push	edi

; 202  : 	if(rhs != m_value)

	mov	edi, DWORD PTR _rhs$[esp+12]
	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [ecx+4]
	lea	esi, DWORD PTR [ecx+4]
	je	SHORT $LN9@operator@2

; 203  : 	{
; 204  : 		set(rhs);

	mov	DWORD PTR $T238561[esp+12], ecx
	mov	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR $T238561[esp+12]
	push	edx
	lea	eax, DWORD PTR $T238562[esp+20]
	push	eax
	add	ecx, 20					; 00000014H
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx
$LN9@operator@2:
	pop	edi

; 205  : 	}
; 206  : 	return m_value;

	mov	eax, esi
	pop	esi

; 207  : }

	add	esp, 8
	ret	4
??4?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QAEAAW4PlayerTypes@@ABW41@@Z ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator=
_TEXT	ENDS
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>, COMDAT

; 3529 : 	{	// sort preserving order of equivalents, using _Pred

	push	edi

; 3530 : 	if (_Count <= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp]
	cmp	edi, 32					; 00000020H
	jg	SHORT $LN4@Stable_sor

; 3531 : 		std::_Insertion_sort(_First, _Last, _Pred);	// small

	mov	eax, DWORD PTR __Pred$[esp]
	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@UCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@PAUCityAndProduction@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,CityAndProduction>
	add	esp, 16					; 00000010H
	pop	edi

; 3552 : 		}
; 3553 : 	}

	ret	0
$LN4@Stable_sor:
	push	ebx

; 3532 : 	else
; 3533 : 		{	// sort halves and merge
; 3534 : 		_Diff _Count2 = (_Count + 1) / 2;

	lea	eax, DWORD PTR [edi+1]
	cdq
	push	ebp

; 3535 : 		_BidIt _Mid = _First;
; 3536 : 		std::advance(_Mid, _Count2);
; 3537 : 
; 3538 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Tempbuf$[esp+8]
	sub	eax, edx
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR __First$[esp+12]
	sar	esi, 1
	mov	ecx, ebp
	lea	ebx, DWORD PTR [eax+esi*8]
	call	?_Maxlen@?$_Temp_iterator@UCityAndProduction@@@std@@QAEHXZ ; std::_Temp_iterator<CityAndProduction>::_Maxlen
	cmp	esi, eax
	jg	SHORT $LN2@Stable_sor

; 3539 : 			{	// temp buffer big enough, sort each half using buffer
; 3540 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+12]
	mov	edx, DWORD PTR __First$[esp+12]
	push	ecx
	push	ebp
	push	esi
	push	ebx
	push	edx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>

; 3541 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
; 3542 : 				_Tempbuf, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+32]
	mov	ecx, DWORD PTR __Last$[esp+32]
	push	eax
	push	ebp
	sub	edi, esi
	push	edi
	push	ecx
	push	ebx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>

; 3543 : 			}
; 3544 : 		else

	jmp	SHORT $LN21@Stable_sor
$LN2@Stable_sor:

; 3545 : 			{	// temp buffer not big enough, divide and conquer
; 3546 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+12]
	mov	eax, DWORD PTR __First$[esp+12]
	push	edx
	push	ebp
	push	esi
	push	ebx
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>

; 3547 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+32]
	mov	edx, DWORD PTR __Last$[esp+32]
	push	ecx
	push	ebp
	sub	edi, esi
	push	edi
	push	edx
	push	ebx
	call	??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
$LN21@Stable_sor:

; 3548 : 			}
; 3549 : 
; 3550 : 		_Buffered_merge(_First, _Mid, _Last,
; 3551 : 			_Count2, _Count - _Count2, _Tempbuf, _Pred);	// merge halves

	mov	eax, DWORD PTR __Pred$[esp+52]
	mov	ecx, DWORD PTR __Last$[esp+52]
	mov	edx, DWORD PTR __First$[esp+52]
	add	esp, 40					; 00000028H
	push	eax
	push	ebp
	push	edi
	push	esi
	push	ecx
	push	ebx
	push	edx
	call	??$_Buffered_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
	add	esp, 28					; 0000001cH
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 3552 : 		}
; 3553 : 	}

	ret	0
??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	?initStatics@CvPlayerAI@@SAXXZ			; CvPlayerAI::initStatics
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautoarchive.h
xdata$x	SEGMENT
__unwindtable$?initStatics@CvPlayerAI@@SAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?initStatics@CvPlayerAI@@SAXXZ$0
__ehfuncinfo$?initStatics@CvPlayerAI@@SAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?initStatics@CvPlayerAI@@SAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
xdata$x	ENDS
;	COMDAT ?initStatics@CvPlayerAI@@SAXXZ
_TEXT	SEGMENT
$T238638 = -24						; size = 4
$T238613 = -24						; size = 4
$T238639 = -20						; size = 8
__$EHRec$ = -12						; size = 12
?initStatics@CvPlayerAI@@SAXXZ PROC			; CvPlayerAI::initStatics, COMDAT

; 44   : {

	push	-1
	push	__ehhandler$?initStatics@CvPlayerAI@@SAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi

; 45   : 	m_aPlayers = FNEW(CvPlayerAI[MAX_PLAYERS], c_eCiv5GameplayDLL, 0);

	push	4047108					; 003dc104H
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T238613[esp+36], eax
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+44], ebx
	cmp	eax, ebx
	je	SHORT $LN6@initStatic
	push	OFFSET ??1CvPlayerAI@@UAE@XZ		; CvPlayerAI::~CvPlayerAI
	push	OFFSET ??0CvPlayerAI@@QAE@XZ		; CvPlayerAI::CvPlayerAI
	push	64					; 00000040H
	lea	esi, DWORD PTR [eax+4]
	push	63236					; 0000f704H
	push	esi
	mov	DWORD PTR [eax], 64			; 00000040H
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	jmp	SHORT $LN7@initStatic
$LN6@initStatic:
	xor	esi, esi
$LN7@initStatic:
	mov	DWORD PTR __$EHRec$[esp+44], -1
	mov	DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A, esi ; CvPlayerAI::m_aPlayers

; 46   : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	xor	edi, edi
	npad	6
$LL19@initStatic:

; 47   : 	{
; 48   : 		m_aPlayers[iI].m_eID = ((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	edi, DWORD PTR [ebx+eax+44]
	lea	esi, DWORD PTR [ebx+eax+40]
	je	SHORT $LN2@initStatic
	lea	ecx, DWORD PTR $T238638[esp+36]
	push	ecx
	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR $T238639[esp+40]
	push	edx
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T238638[esp+44], esi
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
	mov	DWORD PTR [esi+4], edi
$LN2@initStatic:
	add	ebx, 63236				; 0000f704H
	inc	edi
	cmp	ebx, 4047104				; 003dc100H
	jl	SHORT $LL19@initStatic

; 49   : 	}
; 50   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?initStatics@CvPlayerAI@@SAXXZ$0:
	mov	eax, DWORD PTR $T238613[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?initStatics@CvPlayerAI@@SAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?initStatics@CvPlayerAI@@SAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?initStatics@CvPlayerAI@@SAXXZ ENDP			; CvPlayerAI::initStatics
PUBLIC	?push_back@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEXABUCityAndProduction@@@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEXABUCityAndProduction@@@Z
_TEXT	SEGMENT
$T238689 = -4						; size = 1
__Cat$238693 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEXABUCityAndProduction@@@Z PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back
	xor	eax, eax
	jmp	SHORT $LN10@push_back
$LN9@push_back:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 3
$LN10@push_back:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 3
	cmp	edx, eax
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$238693[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T238689[esp+12], 0
	mov	eax, DWORD PTR $T238689[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CityAndProduction *,unsigned int,CityAndProduction,std::allocator<CityAndProduction> >
	add	esp, 24					; 00000018H
	add	edi, 8
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEXABUCityAndProduction@@@Z ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::push_back
_TEXT	ENDS
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z$0
__ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>, COMDAT

; 3560 : 	{	// sort preserving order of equivalents, using _Pred

	push	-1
	push	__ehhandler$??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 3561 : 	_Diff _Count = 0;
; 3562 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp+36]
	push	edi
	mov	edi, DWORD PTR __First$[esp+40]
	mov	ecx, esi
	sub	ecx, edi
	sar	ecx, 3

; 3563 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	lea	eax, DWORD PTR [ecx+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	ebx, ebx
	mov	DWORD PTR __Tempbuf$[esp+56], eax
	lea	eax, DWORD PTR __Tempbuf$[esp+44]
	mov	DWORD PTR __Tempbuf$[esp+44], ebx
	mov	DWORD PTR __Tempbuf$[esp+48], ebx
	mov	DWORD PTR __Tempbuf$[esp+52], ebx
	mov	DWORD PTR __Tempbuf$[esp+60], eax

; 3564 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+40]
	push	edx
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[esp+72], ebx
	call	??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>

; 3565 : 	}

	mov	eax, DWORD PTR __Tempbuf$[esp+64]
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN24@Stable_sor@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Stable_sor@2:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@UCityAndProduction@@@std@@QAE@XZ ; std::_Temp_iterator<CityAndProduction>::~_Temp_iterator<CityAndProduction>
__ehhandler$??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
PUBLIC	??$stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@@Z ; std::stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@@Z PROC ; std::stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>, COMDAT

; 3571 : 	_DEBUG_RANGE(_First, _Last);
; 3572 : 	_DEBUG_POINTER(_Pred);
; 3573 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@stable_sor

; 3574 : 		{
; 3575 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 3576 : 			_Dist_type(_First), _Val_type(_First), _Pred);

	mov	edx, DWORD PTR __Pred$[esp-4]
	push	edx
	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
	add	esp, 20					; 00000014H
$LN1@stable_sor:

; 3577 : 		}
; 3578 : 	}

	ret	0
??$stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@@Z ENDP ; std::stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	__real@4f800000
PUBLIC	?AI_considerAnnex@CvPlayerAI@@QAEXXZ		; CvPlayerAI::AI_considerAnnex
EXTRN	?IsResistance@CvCity@@QBE_NXZ:PROC		; CvCity::IsResistance
EXTRN	?GetBuildingClassProductionModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z:PROC ; CvPlayerPolicies::GetBuildingClassProductionModifier
EXTRN	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetBuildingClassType
EXTRN	?IsNoOccupiedUnhappiness@CvBuildingEntry@@QBE_NXZ:PROC ; CvBuildingEntry::IsNoOccupiedUnhappiness
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
EXTRN	?getNumBuildingInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildingInfos
EXTRN	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z:PROC ; CvCity::getYieldRateTimes100
EXTRN	?DoAnnex@CvCity@@QAEXXZ:PROC			; CvCity::DoAnnex
EXTRN	?IsPuppet@CvCity@@QBE_NXZ:PROC			; CvCity::IsPuppet
;	COMDAT __real@4f800000
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AI_considerAnnex@CvPlayerAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AI_considerAnnex@CvPlayerAI@@QAEXXZ$0
__ehfuncinfo$?AI_considerAnnex@CvPlayerAI@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AI_considerAnnex@CvPlayerAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
xdata$x	ENDS
;	COMDAT ?AI_considerAnnex@CvPlayerAI@@QAEXXZ
_TEXT	SEGMENT
tv505 = -48						; size = 2
$T238894 = -48						; size = 1
_fCutoffValue$ = -48					; size = 4
_kEval$226698 = -48					; size = 8
_iLoop$ = -40						; size = 4
tv507 = -36						; size = 4
tv502 = -36						; size = 4
tv500 = -36						; size = 8
_this$ = -36						; size = 4
_aCityAndProductions$ = -28				; size = 16
__$EHRec$ = -12						; size = 12
?AI_considerAnnex@CvPlayerAI@@QAEXXZ PROC		; CvPlayerAI::AI_considerAnnex, COMDAT
; _this$ = ecx

; 554  : {

	push	-1
	push	__ehhandler$?AI_considerAnnex@CvPlayerAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+52], esi

; 555  : #ifdef AUI_PERF_LOGGING_FORMATTING_TWEAKS
; 556  : 	AI_PERF_FORMAT("AI-perf.csv", ("AI_considerAnnex, Turn %03d, %s", GC.getGame().getGameTurn(), getCivilizationShortDescription()));
; 557  : #else
; 558  : 	AI_PERF("AI-perf.csv", "AI_ considerAnnex");
; 559  : #endif
; 560  : 
; 561  : 	// if the empire is unhappy, don't consider annexing
; 562  : 	if (IsEmpireUnhappy())

	call	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ	; CvPlayer::IsEmpireUnhappy
	test	al, al
	jne	$LN102@AI_conside

; 563  : 	{
; 564  : 		return;
; 565  : 	}
; 566  : 
; 567  : 	// if we're going for a culture victory, don't consider annexing
; 568  : 	if (GetDiplomacyAI()->IsGoingForCultureVictory())

	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForCultureVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForCultureVictory
	test	al, al
	jne	$LN102@AI_conside

; 569  : 	{
; 570  : 		return;
; 571  : 	}
; 572  : 
; 573  : 	// for Venice
; 574  : 	if (GetPlayerTraits()->IsNoAnnexing())

	mov	ecx, esi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	al, BYTE PTR [eax+351]
	test	al, al
	jne	$LN102@AI_conside
	push	ebp
	push	edi

; 575  : 	{
; 576  : 		return;
; 577  : 	}
; 578  : 
; 579  : 	// if their capital city is puppeted, annex it
; 580  : 	CvCity* pCity = getCapitalCity();

	mov	ecx, esi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	edi, eax

; 581  : 	if (pCity && pCity->IsPuppet())

	xor	ebp, ebp
	cmp	edi, ebp
	je	SHORT $LN18@AI_conside
	mov	ecx, edi
	call	?IsPuppet@CvCity@@QBE_NXZ		; CvCity::IsPuppet
	test	al, al
	je	SHORT $LN18@AI_conside

; 582  : 	{
; 583  : 		// we should only annex one city a turn, and sense this is one, we're done!
; 584  : 		pCity->DoAnnex();

	mov	ecx, edi
	call	?DoAnnex@CvCity@@QAEXXZ			; CvCity::DoAnnex
	pop	edi
	pop	ebp
	pop	esi

; 655  : 		}
; 656  : 	}
; 657  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	0
$LN18@AI_conside:
	push	ebx

; 585  : 		return;
; 586  : 	}
; 587  : 
; 588  : 	std::vector<CityAndProduction> aCityAndProductions;

	xor	ebx, ebx
	xor	edi, edi
	mov	DWORD PTR _aCityAndProductions$[esp+68], ebx
	mov	DWORD PTR _aCityAndProductions$[esp+72], edi
	mov	DWORD PTR _aCityAndProductions$[esp+76], ebp

; 589  : 	int iLoop = 0;
; 590  : 	pCity = NULL;
; 591  : 
; 592  : 	// Find first coastal city in same area as settler
; 593  : 	for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))

	push	ebp
	lea	eax, DWORD PTR _iLoop$[esp+68]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+80], ebp
	mov	DWORD PTR _iLoop$[esp+72], ebp
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	cmp	eax, ebp
	je	SHORT $LN15@AI_conside
$LL17@AI_conside:

; 594  : 	{
; 595  : 		CityAndProduction kEval;
; 596  : 		kEval.pCity = pCity;
; 597  : 		kEval.iProduction = pCity->getYieldRateTimes100(YIELD_PRODUCTION, false);

	push	ebp
	push	1
	mov	ecx, eax
	mov	DWORD PTR _kEval$226698[esp+72], eax
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100

; 598  : 		aCityAndProductions.push_back(kEval);

	lea	ecx, DWORD PTR _kEval$226698[esp+64]
	push	ecx
	lea	ecx, DWORD PTR _aCityAndProductions$[esp+68]
	mov	DWORD PTR _kEval$226698[esp+72], eax
	call	?push_back@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEXABUCityAndProduction@@@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::push_back
	push	ebp
	lea	edx, DWORD PTR _iLoop$[esp+68]
	push	edx
	mov	ecx, esi
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	cmp	eax, ebp
	jne	SHORT $LL17@AI_conside
	mov	edi, DWORD PTR _aCityAndProductions$[esp+72]
	mov	ebx, DWORD PTR _aCityAndProductions$[esp+68]
$LN15@AI_conside:

; 599  : 	}
; 600  : 	
; 601  : 	std::stable_sort(aCityAndProductions.begin(), aCityAndProductions.end(), CityAndProductionEval());

	mov	BYTE PTR $T238894[esp+64], 0
	cmp	ebx, edi
	je	SHORT $LN76@AI_conside
	mov	eax, DWORD PTR $T238894[esp+64]
	push	eax
	push	ebp
	push	ebp
	push	edi
	push	ebx
	call	??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
	add	esp, 20					; 00000014H
$LN76@AI_conside:

; 602  : 	
; 603  : 	CvCity* pTargetCity = NULL;
; 604  : 	float fCutoffValue = GC.getNORMAL_ANNEX();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8192
	mov	DWORD PTR _fCutoffValue$[esp+64], ecx

; 605  : 	BuildingClassTypes eCourthouseType = NO_BUILDINGCLASS;
; 606  : 	// find courthouse
; 607  : #ifdef AUI_WARNING_FIXES
; 608  : 	for (uint eBuildingType = 0; eBuildingType < GC.getNumBuildingInfos(); eBuildingType++)
; 609  : #else
; 610  : 	for(int eBuildingType = 0; eBuildingType < GC.getNumBuildingInfos(); eBuildingType++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	SHORT $LN114@AI_conside
$LL113@AI_conside:

; 611  : #endif
; 612  : 	{
; 613  : 		const BuildingTypes eBuilding = static_cast<BuildingTypes>(eBuildingType);
; 614  : 		CvBuildingEntry* buildingInfo = GC.getBuildingInfo(eBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ebp, eax

; 615  : 
; 616  : 		if(buildingInfo)

	test	ebp, ebp
	je	SHORT $LN13@AI_conside

; 617  : 		{
; 618  : 			if (buildingInfo->IsNoOccupiedUnhappiness())

	mov	ecx, ebp
	call	?IsNoOccupiedUnhappiness@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsNoOccupiedUnhappiness
	test	al, al
	jne	SHORT $LN107@AI_conside
$LN13@AI_conside:

; 605  : 	BuildingClassTypes eCourthouseType = NO_BUILDINGCLASS;
; 606  : 	// find courthouse
; 607  : #ifdef AUI_WARNING_FIXES
; 608  : 	for (uint eBuildingType = 0; eBuildingType < GC.getNumBuildingInfos(); eBuildingType++)
; 609  : #else
; 610  : 	for(int eBuildingType = 0; eBuildingType < GC.getNumBuildingInfos(); eBuildingType++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	esi, eax
	jl	SHORT $LL113@AI_conside

; 642  : 	{
; 643  : 		if (aCityAndProductions[ui].pCity->IsPuppet())

	jmp	SHORT $LN114@AI_conside
$LN107@AI_conside:

; 619  : 			{
; 620  : 				eCourthouseType = (BuildingClassTypes)buildingInfo->GetBuildingClassType();

	mov	ecx, ebp
	call	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingClassType

; 621  : 				break;
; 622  : 			}
; 623  : 		}
; 624  : 	}
; 625  : 
; 626  : 	bool bCourthouseImprovement = false;
; 627  : 	if (eCourthouseType != NO_BUILDINGCLASS)

	cmp	eax, -1
	je	SHORT $LN114@AI_conside

; 628  : 	{
; 629  : 		if (GetPlayerPolicies()->GetBuildingClassProductionModifier(eCourthouseType) > 0)

	mov	ecx, DWORD PTR _this$[esp+64]
	push	eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetBuildingClassProductionModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z ; CvPlayerPolicies::GetBuildingClassProductionModifier
	test	eax, eax
	jle	SHORT $LN114@AI_conside

; 630  : 		{
; 631  : 			bCourthouseImprovement = true;
; 632  : 		}
; 633  : 	}
; 634  : 
; 635  : 	if (bCourthouseImprovement)
; 636  : 	{
; 637  : 		fCutoffValue = GC.getAGGRESIVE_ANNEX();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8196
	mov	DWORD PTR _fCutoffValue$[esp+64], edx
$LN114@AI_conside:

; 638  : 	}
; 639  : 
; 640  : 	uint uiCutOff = (uint)(aCityAndProductions.size() * fCutoffValue);

	sub	edi, ebx
	sar	edi, 3
	mov	DWORD PTR tv507[esp+64], edi
	fild	DWORD PTR tv507[esp+64]
	test	edi, edi
	jge	SHORT $LN119@AI_conside
	fadd	DWORD PTR __real@4f800000
$LN119@AI_conside:
	fmul	DWORD PTR _fCutoffValue$[esp+64]

; 641  : 	for (uint ui = 0; ui < uiCutOff; ui++)

	xor	esi, esi
	fnstcw	WORD PTR tv505[esp+64]
	movzx	eax, WORD PTR tv505[esp+64]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv502[esp+64], eax
	fldcw	WORD PTR tv502[esp+64]
	fistp	QWORD PTR tv500[esp+64]
	mov	edi, DWORD PTR tv500[esp+64]
	fldcw	WORD PTR tv505[esp+64]
	test	edi, edi
	jbe	SHORT $LN1@AI_conside
	npad	2
$LL6@AI_conside:

; 642  : 	{
; 643  : 		if (aCityAndProductions[ui].pCity->IsPuppet())

	mov	ecx, DWORD PTR [ebx+esi*8]
	call	?IsPuppet@CvCity@@QBE_NXZ		; CvCity::IsPuppet
	test	al, al
	jne	SHORT $LN108@AI_conside
	inc	esi
	cmp	esi, edi
	jb	SHORT $LL6@AI_conside
	jmp	SHORT $LN1@AI_conside
$LN108@AI_conside:

; 644  : 		{
; 645  : 			pTargetCity = aCityAndProductions[ui].pCity;

	mov	esi, DWORD PTR [ebx+esi*8]

; 646  : 			break;
; 647  : 		}
; 648  : 	}
; 649  : 
; 650  : 	if (pTargetCity)

	test	esi, esi
	je	SHORT $LN1@AI_conside

; 651  : 	{
; 652  : 		if (!pTargetCity->IsResistance())

	mov	ecx, esi
	call	?IsResistance@CvCity@@QBE_NXZ		; CvCity::IsResistance
	test	al, al
	jne	SHORT $LN1@AI_conside

; 653  : 		{
; 654  : 			pTargetCity->DoAnnex();

	mov	ecx, esi
	call	?DoAnnex@CvCity@@QAEXXZ			; CvCity::DoAnnex
$LN1@AI_conside:

; 655  : 		}
; 656  : 	}
; 657  : }

	test	ebx, ebx
	je	SHORT $LN118@AI_conside
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN118@AI_conside:
	pop	ebx
	pop	edi
	pop	ebp
$LN102@AI_conside:
	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AI_considerAnnex@CvPlayerAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _aCityAndProductions$[ebp]
	jmp	??1?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::~vector<CityAndProduction,std::allocator<CityAndProduction> >
__ehhandler$?AI_considerAnnex@CvPlayerAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?AI_considerAnnex@CvPlayerAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?AI_considerAnnex@CvPlayerAI@@QAEXXZ ENDP		; CvPlayerAI::AI_considerAnnex
; Function compile flags: /Ogtpy
;	COMDAT ?AI_doTurnPre@CvPlayerAI@@UAEXXZ
_TEXT	SEGMENT
?AI_doTurnPre@CvPlayerAI@@UAEXXZ PROC			; CvPlayerAI::AI_doTurnPre, COMDAT
; _this$ = ecx

; 87   : {

	push	esi
	mov	esi, ecx

; 88   : 	AI_PERF_FORMAT("AI-perf.csv", ("CvPlayerAI::AI_doTurnPre, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
; 89   : 	CvAssertMsg(getPersonalityType() != NO_LEADER, "getPersonalityType() is not expected to be equal with NO_LEADER");
; 90   : 	CvAssertMsg(getLeaderType() != NO_LEADER, "getLeaderType() is not expected to be equal with NO_LEADER");
; 91   : 	CvAssertMsg(getCivilizationType() != NO_CIVILIZATION, "getCivilizationType() is not expected to be equal with NO_CIVILIZATION");
; 92   : 
; 93   : 	if(isHuman())

	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN2@AI_doTurnP@2

; 94   : 	{
; 95   : 		return;
; 96   : 	}
; 97   : 
; 98   : 	AI_updateFoundValues();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+36]
	push	0
	mov	ecx, esi
	call	edx

; 99   : 
; 100  : 	AI_doResearch();

	mov	ecx, esi
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
	cmp	eax, -1
	jne	SHORT $LN4@AI_doTurnP@2
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+60]
	mov	ecx, esi
	call	edx
$LN4@AI_doTurnP@2:

; 101  : 	AI_considerAnnex();

	mov	ecx, esi
	pop	esi
	jmp	?AI_considerAnnex@CvPlayerAI@@QAEXXZ	; CvPlayerAI::AI_considerAnnex
$LN2@AI_doTurnP@2:
	pop	esi

; 102  : }

	ret	0
?AI_doTurnPre@CvPlayerAI@@UAEXXZ ENDP			; CvPlayerAI::AI_doTurnPre
_TEXT	ENDS
END
