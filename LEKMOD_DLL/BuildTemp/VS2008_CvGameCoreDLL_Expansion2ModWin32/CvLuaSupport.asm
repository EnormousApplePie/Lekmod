; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Desktop\Lekmod Files\Lekmod DLL versions\v29\LEKMOD_DLL\CvGameCoreDLL_Expansion2\Lua\CvLuaSupport.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG220641 DB	'Sl', 00H
$SG220645 DB	00H
$SG220646 DB	'%s:%d', 0aH, 00H
CONST	ENDS
PUBLIC	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z		; luaL_optbool
EXTRN	_lua_toboolean:PROC
EXTRN	_lua_type:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\lua\cvluasupport.cpp
;	COMDAT ?luaL_optbool@@YA_NPAUlua_State@@H_N@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
_bdefault$ = 16						; size = 1
?luaL_optbool@@YA_NPAUlua_State@@H_N@Z PROC		; luaL_optbool, COMDAT

; 29   : {

	push	esi

; 30   : 	if(lua_isnoneornil(L, idx))

	mov	esi, DWORD PTR _idx$[esp]
	push	edi
	mov	edi, DWORD PTR _L$[esp+4]
	push	esi
	push	edi
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jg	SHORT $LN2@luaL_optbo

; 31   : 	{
; 32   : 		return bdefault;

	mov	al, BYTE PTR _bdefault$[esp+4]
	pop	edi
	pop	esi

; 37   : 	}
; 38   : }

	ret	0
$LN2@luaL_optbo:

; 33   : 	}
; 34   : 	else
; 35   : 	{
; 36   : 		return (bool)lua_toboolean(L, idx);

	push	esi
	push	edi
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	pop	edi
	setne	al
	pop	esi

; 37   : 	}
; 38   : }

	ret	0
?luaL_optbool@@YA_NPAUlua_State@@H_N@Z ENDP		; luaL_optbool
_TEXT	ENDS
PUBLIC	?pRegister@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAHPAUlua_State@@@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::pRegister
EXTRN	?RegisterMembers@CvLuaMap@@SAXPAUlua_State@@@Z:PROC ; CvLuaMap::RegisterMembers
EXTRN	_lua_setfield:PROC
EXTRN	_lua_pushvalue:PROC
EXTRN	_lua_createtable:PROC
EXTRN	_lua_settop:PROC
EXTRN	_lua_getfield:PROC
EXTRN	?GetInstanceName@CvLuaMap@@SAPBDXZ:PROC		; CvLuaMap::GetInstanceName
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvluastaticinstance.h
;	COMDAT ?pRegister@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?pRegister@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAHPAUlua_State@@@Z PROC ; CvLuaStaticInstance<CvLuaMap,CvMap>::pRegister, COMDAT

; 40   : {

	push	esi
	push	edi

; 41   : 	const char* szInstanceName = Derived::GetInstanceName();

	call	?GetInstanceName@CvLuaMap@@SAPBDXZ	; CvLuaMap::GetInstanceName

; 42   : 	lua_getglobal(L, szInstanceName);

	mov	esi, DWORD PTR _L$[esp+4]
	mov	edi, eax
	push	edi
	push	-10002					; ffffd8eeH
	push	esi
	call	_lua_getfield

; 43   : 	if(lua_isnil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN1@pRegister

; 44   : 	{
; 45   : 		lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 46   : 		lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 47   : 		lua_pushvalue(L, -1);

	push	-1
	push	esi
	call	_lua_pushvalue

; 48   : 		lua_setglobal(L, szInstanceName);

	push	edi
	push	-10002					; ffffd8eeH
	push	esi
	call	_lua_setfield
	add	esp, 40					; 00000028H
$LN1@pRegister:

; 49   : 	}
; 50   : 
; 51   : 	Derived::RegisterMembers(L);

	push	esi
	call	?RegisterMembers@CvLuaMap@@SAXPAUlua_State@@@Z ; CvLuaMap::RegisterMembers
	add	esp, 4
	pop	edi

; 52   : 
; 53   : 	return 0;

	xor	eax, eax
	pop	esi

; 54   : }

	ret	0
?pRegister@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAHPAUlua_State@@@Z ENDP ; CvLuaStaticInstance<CvLuaMap,CvMap>::pRegister
_TEXT	ENDS
PUBLIC	?pRegister@?$CvLuaStaticInstance@VCvLuaGame@@VCvGame@@@@KAHPAUlua_State@@@Z ; CvLuaStaticInstance<CvLuaGame,CvGame>::pRegister
EXTRN	?RegisterMembers@CvLuaGame@@SAXPAUlua_State@@@Z:PROC ; CvLuaGame::RegisterMembers
EXTRN	?GetInstanceName@CvLuaGame@@SAPBDXZ:PROC	; CvLuaGame::GetInstanceName
; Function compile flags: /Ogtpy
;	COMDAT ?pRegister@?$CvLuaStaticInstance@VCvLuaGame@@VCvGame@@@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?pRegister@?$CvLuaStaticInstance@VCvLuaGame@@VCvGame@@@@KAHPAUlua_State@@@Z PROC ; CvLuaStaticInstance<CvLuaGame,CvGame>::pRegister, COMDAT

; 40   : {

	push	esi
	push	edi

; 41   : 	const char* szInstanceName = Derived::GetInstanceName();

	call	?GetInstanceName@CvLuaGame@@SAPBDXZ	; CvLuaGame::GetInstanceName

; 42   : 	lua_getglobal(L, szInstanceName);

	mov	esi, DWORD PTR _L$[esp+4]
	mov	edi, eax
	push	edi
	push	-10002					; ffffd8eeH
	push	esi
	call	_lua_getfield

; 43   : 	if(lua_isnil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN1@pRegister@2

; 44   : 	{
; 45   : 		lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 46   : 		lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 47   : 		lua_pushvalue(L, -1);

	push	-1
	push	esi
	call	_lua_pushvalue

; 48   : 		lua_setglobal(L, szInstanceName);

	push	edi
	push	-10002					; ffffd8eeH
	push	esi
	call	_lua_setfield
	add	esp, 40					; 00000028H
$LN1@pRegister@2:

; 49   : 	}
; 50   : 
; 51   : 	Derived::RegisterMembers(L);

	push	esi
	call	?RegisterMembers@CvLuaGame@@SAXPAUlua_State@@@Z ; CvLuaGame::RegisterMembers
	add	esp, 4
	pop	edi

; 52   : 
; 53   : 	return 0;

	xor	eax, eax
	pop	esi

; 54   : }

	ret	0
?pRegister@?$CvLuaStaticInstance@VCvLuaGame@@VCvGame@@@@KAHPAUlua_State@@@Z ENDP ; CvLuaStaticInstance<CvLuaGame,CvGame>::pRegister
_TEXT	ENDS
PUBLIC	?StringData@FStringAData@FStringA@@QAEPADXZ	; FStringA::FStringAData::StringData
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fstringa.inl
;	COMDAT ?StringData@FStringAData@FStringA@@QAEPADXZ
_TEXT	SEGMENT
?StringData@FStringAData@FStringA@@QAEPADXZ PROC	; FStringA::FStringAData::StringData, COMDAT
; _this$ = ecx

; 1067 : 	return ( ( LPSTR )( this + 1 ) );

	lea	eax, DWORD PTR [ecx+12]

; 1068 : }

	ret	0
?StringData@FStringAData@FStringA@@QAEPADXZ ENDP	; FStringA::FStringAData::StringData
_TEXT	ENDS
PUBLIC	?GetData@FStringA@@IBEPAUFStringAData@1@XZ	; FStringA::GetData
; Function compile flags: /Ogtpy
;	COMDAT ?GetData@FStringA@@IBEPAUFStringAData@1@XZ
_TEXT	SEGMENT
?GetData@FStringA@@IBEPAUFStringAData@1@XZ PROC		; FStringA::GetData, COMDAT
; _this$ = ecx

; 1077 : 	assert( m_pszString != NULL );
; 1078 : 
; 1079 : 	return ( ( ( FStringAData* )m_pszString ) - 1 );

	mov	eax, DWORD PTR [ecx]
	sub	eax, 12					; 0000000cH

; 1080 : }

	ret	0
?GetData@FStringA@@IBEPAUFStringAData@1@XZ ENDP		; FStringA::GetData
_TEXT	ENDS
PUBLIC	?Init@FStringA@@IAEXXZ				; FStringA::Init
EXTRN	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ:PROC ; FStringA_GetStringInitData
; Function compile flags: /Ogtpy
;	COMDAT ?Init@FStringA@@IAEXXZ
_TEXT	SEGMENT
?Init@FStringA@@IAEXXZ PROC				; FStringA::Init, COMDAT
; _this$ = ecx

; 1084 : {

	push	esi
	mov	esi, ecx

; 1085 : #ifdef		_NDS
; 1086 : 	static int strEmpty[] = { FIXED, 0 };	// Empty string
; 1087 : 
; 1088 : 	m_pszString = (LPSTR)&strEmpty[1];
; 1089 : #else	//	_NDS
; 1090 : 	m_pszString = FStringA_GetStringInitData()->StringData();

	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [esi], eax
	pop	esi

; 1091 : #endif	//	_NDS
; 1092 : }

	ret	0
?Init@FStringA@@IAEXXZ ENDP				; FStringA::Init
_TEXT	ENDS
PUBLIC	?Release@FStringA@@IAEXPAUFStringAData@1@@Z	; FStringA::Release
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
;	COMDAT ?Release@FStringA@@IAEXPAUFStringAData@1@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Release@FStringA@@IAEXPAUFStringAData@1@@Z PROC	; FStringA::Release, COMDAT
; _this$ = ecx

; 1105 : {

	push	esi

; 1106 : 	FSTRING_CHECK_BUFFER;
; 1107 : 	if ( pkData && ( pkData != FStringA_GetStringInitData() ) && !pkData->m_bFixed )

	mov	esi, DWORD PTR _pkData$[esp]
	test	esi, esi
	je	SHORT $LN1@Release
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	cmp	esi, eax
	je	SHORT $LN1@Release
	cmp	WORD PTR [esi+10], 0
	jne	SHORT $LN1@Release

; 1108 : 	{
; 1109 : #ifdef		ENABLE_FSTRING_STATS
; 1110 : 		extern uint g_uiFStringBytesCurrent;
; 1111 : 		g_uiFStringBytesCurrent -= sizeof ( FStringAData ) + ( sizeof ( char ) * pkData->m_iAllocLength + 1 );
; 1112 : #endif	//	ENABLE_FSTRING_STATS
; 1113 : 
; 1114 : 		// Free any memory associated with the string
; 1115 : 		delete [] ( byte* )pkData;

	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@Release:
	pop	esi

; 1116 : 	}
; 1117 : }

	ret	4
?Release@FStringA@@IAEXPAUFStringAData@1@@Z ENDP	; FStringA::Release
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\lua\cvluasupport.cpp
;	COMDAT ?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z
_TEXT	SEGMENT
_bResult$ = 8						; size = 1
_pkScriptSystem$ = 8					; size = 4
_szName$ = 12						; size = 4
_args$ = 16						; size = 4
_value$ = 20						; size = 4
?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z PROC ; LuaSupport::CallHook, COMDAT

; 78   : 	// Must release our lock so that if the main thread has the Lua lock and is waiting for the Game Core lock, we don't freeze
; 79   : 	bool bHadLock = gDLL->HasGameCoreLock();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+924]
	push	ebx
	call	edx
	mov	bl, al

; 80   : 	if(bHadLock)

	test	bl, bl
	je	SHORT $LN2@CallHook

; 81   : 		gDLL->ReleaseGameCoreLock();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+916]
	call	edx
$LN2@CallHook:

; 82   : 	bool bResult = pkScriptSystem->CallHook(szName, args, value);

	mov	edx, DWORD PTR _value$[esp]
	mov	ecx, DWORD PTR _pkScriptSystem$[esp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+32]
	push	edx
	mov	edx, DWORD PTR _args$[esp+4]
	push	edx
	mov	edx, DWORD PTR _szName$[esp+8]
	push	edx
	call	eax

; 83   : 	if(bHadLock)

	test	bl, bl
	mov	BYTE PTR _bResult$[esp], al
	pop	ebx
	je	SHORT $LN1@CallHook

; 84   : 		gDLL->GetGameCoreLock();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+912]
	call	eax

; 85   : 	return bResult;

	mov	al, BYTE PTR _bResult$[esp-4]
$LN1@CallHook:

; 86   : }

	ret	0
?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ENDP ; LuaSupport::CallHook
_TEXT	ENDS
PUBLIC	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
; Function compile flags: /Ogtpy
;	COMDAT ?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z
_TEXT	SEGMENT
_bResult$ = 8						; size = 1
_pkScriptSystem$ = 8					; size = 4
_szName$ = 12						; size = 4
_args$ = 16						; size = 4
_value$ = 20						; size = 4
?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z PROC ; LuaSupport::CallTestAll, COMDAT

; 95   : 	// Must release our lock so that if the main thread has the Lua lock and is waiting for the Game Core lock, we don't freeze
; 96   : 	bool bHadLock = gDLL->HasGameCoreLock();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+924]
	push	ebx
	call	edx
	mov	bl, al

; 97   : 	if(bHadLock)

	test	bl, bl
	je	SHORT $LN2@CallTestAl

; 98   : 		gDLL->ReleaseGameCoreLock();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+916]
	call	edx
$LN2@CallTestAl:

; 99   : 	bool bResult = pkScriptSystem->CallTestAll(szName, args, value);

	mov	edx, DWORD PTR _value$[esp]
	mov	ecx, DWORD PTR _pkScriptSystem$[esp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+44]
	push	edx
	mov	edx, DWORD PTR _args$[esp+4]
	push	edx
	mov	edx, DWORD PTR _szName$[esp+8]
	push	edx
	call	eax

; 100  : 	if(bHadLock)

	test	bl, bl
	mov	BYTE PTR _bResult$[esp], al
	pop	ebx
	je	SHORT $LN1@CallTestAl

; 101  : 		gDLL->GetGameCoreLock();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+912]
	call	eax

; 102  : 	return bResult;

	mov	al, BYTE PTR _bResult$[esp-4]
$LN1@CallTestAl:

; 103  : }

	ret	0
?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ENDP ; LuaSupport::CallTestAll
_TEXT	ENDS
PUBLIC	?CallTestAny@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAny
; Function compile flags: /Ogtpy
;	COMDAT ?CallTestAny@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z
_TEXT	SEGMENT
_bResult$ = 8						; size = 1
_pkScriptSystem$ = 8					; size = 4
_szName$ = 12						; size = 4
_args$ = 16						; size = 4
_value$ = 20						; size = 4
?CallTestAny@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z PROC ; LuaSupport::CallTestAny, COMDAT

; 112  : 	// Must release our lock so that if the main thread has the Lua lock and is waiting for the Game Core lock, we don't freeze
; 113  : 	bool bHadLock = gDLL->HasGameCoreLock();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+924]
	push	ebx
	call	edx
	mov	bl, al

; 114  : 	if(bHadLock)

	test	bl, bl
	je	SHORT $LN2@CallTestAn

; 115  : 		gDLL->ReleaseGameCoreLock();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+916]
	call	edx
$LN2@CallTestAn:

; 116  : 	bool bResult = pkScriptSystem->CallTestAny(szName, args, value);

	mov	edx, DWORD PTR _value$[esp]
	mov	ecx, DWORD PTR _pkScriptSystem$[esp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+48]
	push	edx
	mov	edx, DWORD PTR _args$[esp+4]
	push	edx
	mov	edx, DWORD PTR _szName$[esp+8]
	push	edx
	call	eax

; 117  : 	if(bHadLock)

	test	bl, bl
	mov	BYTE PTR _bResult$[esp], al
	pop	ebx
	je	SHORT $LN1@CallTestAn

; 118  : 		gDLL->GetGameCoreLock();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+912]
	call	eax

; 119  : 	return bResult;

	mov	al, BYTE PTR _bResult$[esp-4]
$LN1@CallTestAn:

; 120  : }

	ret	0
?CallTestAny@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ENDP ; LuaSupport::CallTestAny
_TEXT	ENDS
PUBLIC	?CallAccumulator@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AAH@Z ; LuaSupport::CallAccumulator
; Function compile flags: /Ogtpy
;	COMDAT ?CallAccumulator@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AAH@Z
_TEXT	SEGMENT
_bResult$ = 8						; size = 1
_pkScriptSystem$ = 8					; size = 4
_szName$ = 12						; size = 4
_args$ = 16						; size = 4
_value$ = 20						; size = 4
?CallAccumulator@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AAH@Z PROC ; LuaSupport::CallAccumulator, COMDAT

; 125  : 	// Must release our lock so that if the main thread has the Lua lock and is waiting for the Game Core lock, we don't freeze
; 126  : 	bool bHadLock = gDLL->HasGameCoreLock();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+924]
	push	ebx
	call	edx
	mov	bl, al

; 127  : 	if(bHadLock)

	test	bl, bl
	je	SHORT $LN2@CallAccumu

; 128  : 		gDLL->ReleaseGameCoreLock();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+916]
	call	edx
$LN2@CallAccumu:

; 129  : 	bool bResult = pkScriptSystem->CallAccumulator(szName, args, value);

	mov	edx, DWORD PTR _value$[esp]
	mov	ecx, DWORD PTR _pkScriptSystem$[esp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+40]
	push	edx
	mov	edx, DWORD PTR _args$[esp+4]
	push	edx
	mov	edx, DWORD PTR _szName$[esp+8]
	push	edx
	call	eax

; 130  : 	if(bHadLock)

	test	bl, bl
	mov	BYTE PTR _bResult$[esp], al
	pop	ebx
	je	SHORT $LN1@CallAccumu

; 131  : 		gDLL->GetGameCoreLock();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+912]
	call	eax

; 132  : 	return bResult;

	mov	al, BYTE PTR _bResult$[esp-4]
$LN1@CallAccumu:

; 133  : }

	ret	0
?CallAccumulator@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AAH@Z ENDP ; LuaSupport::CallAccumulator
_TEXT	ENDS
PUBLIC	?CallAccumulator@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AAM@Z ; LuaSupport::CallAccumulator
; Function compile flags: /Ogtpy
;	COMDAT ?CallAccumulator@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AAM@Z
_TEXT	SEGMENT
_bResult$ = 8						; size = 1
_pkScriptSystem$ = 8					; size = 4
_szName$ = 12						; size = 4
_args$ = 16						; size = 4
_value$ = 20						; size = 4
?CallAccumulator@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AAM@Z PROC ; LuaSupport::CallAccumulator, COMDAT

; 138  : 	// Must release our lock so that if the main thread has the Lua lock and is waiting for the Game Core lock, we don't freeze
; 139  : 	bool bHadLock = gDLL->HasGameCoreLock();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+924]
	push	ebx
	call	edx
	mov	bl, al

; 140  : 	if(bHadLock)

	test	bl, bl
	je	SHORT $LN2@CallAccumu@2

; 141  : 		gDLL->ReleaseGameCoreLock();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+916]
	call	edx
$LN2@CallAccumu@2:

; 142  : 	bool bResult = pkScriptSystem->CallAccumulator(szName, args, value);

	mov	edx, DWORD PTR _value$[esp]
	mov	ecx, DWORD PTR _pkScriptSystem$[esp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+36]
	push	edx
	mov	edx, DWORD PTR _args$[esp+4]
	push	edx
	mov	edx, DWORD PTR _szName$[esp+8]
	push	edx
	call	eax

; 143  : 	if(bHadLock)

	test	bl, bl
	mov	BYTE PTR _bResult$[esp], al
	pop	ebx
	je	SHORT $LN1@CallAccumu@2

; 144  : 		gDLL->GetGameCoreLock();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+912]
	call	eax

; 145  : 	return bResult;

	mov	al, BYTE PTR _bResult$[esp-4]
$LN1@CallAccumu@2:

; 146  : }

	ret	0
?CallAccumulator@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AAM@Z ENDP ; LuaSupport::CallAccumulator
_TEXT	ENDS
PUBLIC	?Register@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@SAXPAUlua_State@@@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::Register
EXTRN	?CCallWithErrorHandling@Details@FLua@@YA_NPAUlua_State@@P6AH0@ZPAX@Z:PROC ; FLua::Details::CCallWithErrorHandling
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvluastaticinstance.h
;	COMDAT ?Register@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@SAXPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?Register@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@SAXPAUlua_State@@@Z PROC ; CvLuaStaticInstance<CvLuaMap,CvMap>::Register, COMDAT

; 29   : 	FLua::Details::CCallWithErrorHandling(L, pRegister);

	mov	eax, DWORD PTR _L$[esp-4]
	push	0
	push	OFFSET ?pRegister@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAHPAUlua_State@@@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::pRegister
	push	eax
	call	?CCallWithErrorHandling@Details@FLua@@YA_NPAUlua_State@@P6AH0@ZPAX@Z ; FLua::Details::CCallWithErrorHandling
	add	esp, 12					; 0000000cH

; 30   : }

	ret	0
?Register@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@SAXPAUlua_State@@@Z ENDP ; CvLuaStaticInstance<CvLuaMap,CvMap>::Register
_TEXT	ENDS
PUBLIC	?Register@?$CvLuaStaticInstance@VCvLuaGame@@VCvGame@@@@SAXPAUlua_State@@@Z ; CvLuaStaticInstance<CvLuaGame,CvGame>::Register
; Function compile flags: /Ogtpy
;	COMDAT ?Register@?$CvLuaStaticInstance@VCvLuaGame@@VCvGame@@@@SAXPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?Register@?$CvLuaStaticInstance@VCvLuaGame@@VCvGame@@@@SAXPAUlua_State@@@Z PROC ; CvLuaStaticInstance<CvLuaGame,CvGame>::Register, COMDAT

; 29   : 	FLua::Details::CCallWithErrorHandling(L, pRegister);

	mov	eax, DWORD PTR _L$[esp-4]
	push	0
	push	OFFSET ?pRegister@?$CvLuaStaticInstance@VCvLuaGame@@VCvGame@@@@KAHPAUlua_State@@@Z ; CvLuaStaticInstance<CvLuaGame,CvGame>::pRegister
	push	eax
	call	?CCallWithErrorHandling@Details@FLua@@YA_NPAUlua_State@@P6AH0@ZPAX@Z ; FLua::Details::CCallWithErrorHandling
	add	esp, 12					; 0000000cH

; 30   : }

	ret	0
?Register@?$CvLuaStaticInstance@VCvLuaGame@@VCvGame@@@@SAXPAUlua_State@@@Z ENDP ; CvLuaStaticInstance<CvLuaGame,CvGame>::Register
_TEXT	ENDS
PUBLIC	??0FStringA@@QAE@XZ				; FStringA::FStringA
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fstringa.inl
;	COMDAT ??0FStringA@@QAE@XZ
_TEXT	SEGMENT
??0FStringA@@QAE@XZ PROC				; FStringA::FStringA, COMDAT
; _this$ = ecx

; 85   : {

	push	esi
	mov	esi, ecx

; 86   : 	Init();

	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [esi], eax

; 87   : }

	mov	eax, esi
	pop	esi
	ret	0
??0FStringA@@QAE@XZ ENDP				; FStringA::FStringA
_TEXT	ENDS
PUBLIC	?Release@FStringA@@QAEXXZ			; FStringA::Release
; Function compile flags: /Ogtpy
;	COMDAT ?Release@FStringA@@QAEXXZ
_TEXT	SEGMENT
?Release@FStringA@@QAEXXZ PROC				; FStringA::Release, COMDAT
; _this$ = ecx

; 1096 : {

	push	esi
	push	edi
	mov	edi, ecx

; 1097 : 	Release( GetData() );

	mov	esi, DWORD PTR [edi]
	sub	esi, 12					; 0000000cH
	je	SHORT $LN5@Release@2
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	cmp	esi, eax
	je	SHORT $LN5@Release@2
	cmp	WORD PTR [esi+10], 0
	jne	SHORT $LN5@Release@2
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@Release@2:

; 1098 : 	m_pszString = NULL;

	mov	DWORD PTR [edi], 0

; 1099 : 	Init();

	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi

; 1100 : }

	ret	0
?Release@FStringA@@QAEXXZ ENDP				; FStringA::Release
_TEXT	ENDS
PUBLIC	?SetFixedBuffer@FStringA@@QAEXPAUFStringAData@1@@Z ; FStringA::SetFixedBuffer
; Function compile flags: /Ogtpy
;	COMDAT ?SetFixedBuffer@FStringA@@QAEXPAUFStringAData@1@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?SetFixedBuffer@FStringA@@QAEXPAUFStringAData@1@@Z PROC	; FStringA::SetFixedBuffer, COMDAT
; _this$ = ecx

; 1122 : {

	push	ebx

; 1123 : 	assert( pkData != NULL );
; 1124 : 	if(!pkData) return;

	mov	ebx, DWORD PTR _pkData$[esp]
	push	edi
	mov	edi, ecx
	test	ebx, ebx
	je	SHORT $LN2@SetFixedBu
	push	esi

; 1125 : 	assert( pkData->m_bFixed == 1 );
; 1126 : 	assert( pkData->m_iAllocLength > 0 );
; 1127 : 	Release();

	mov	esi, DWORD PTR [edi]
	sub	esi, 12					; 0000000cH
	je	SHORT $LN8@SetFixedBu
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	cmp	esi, eax
	je	SHORT $LN8@SetFixedBu
	cmp	WORD PTR [esi+10], 0
	jne	SHORT $LN8@SetFixedBu
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN8@SetFixedBu:
	mov	DWORD PTR [edi], 0
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData

; 1128 : 	m_pszString = pkData->StringData();

	add	ebx, 12					; 0000000cH
	mov	DWORD PTR [edi], ebx
	pop	esi
$LN2@SetFixedBu:
	pop	edi
	pop	ebx

; 1129 : }

	ret	4
?SetFixedBuffer@FStringA@@QAEXPAUFStringAData@1@@Z ENDP	; FStringA::SetFixedBuffer
_TEXT	ENDS
PUBLIC	??0?$FStringAFixedBuffer@$0CAA@@FStringA@@QAE@AAV1@@Z ; FStringA::FStringAFixedBuffer<512>::FStringAFixedBuffer<512>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStringAFixedBuffer@$0CAA@@FStringA@@QAE@AAV1@@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
??0?$FStringAFixedBuffer@$0CAA@@FStringA@@QAE@AAV1@@Z PROC ; FStringA::FStringAFixedBuffer<512>::FStringAFixedBuffer<512>, COMDAT
; _this$ = ecx

; 58   : {

	push	ebx
	push	ebp

; 59   : 	assert( nLENGTH > 0 );
; 60   : 	m_kStringData.m_bLocked = 0;
; 61   : 	m_kStringData.m_bFixed = 1;
; 62   : 	m_kStringData.m_iAllocLength = nLENGTH;
; 63   : 	m_kStringData.m_iDataLength = 0;
; 64   : 	m_szStringBuffer[ 0 ] = 0;
; 65   : 	str.SetFixedBuffer( &m_kStringData );

	mov	ebp, DWORD PTR _str$[esp+4]
	push	esi
	mov	esi, ecx
	xor	eax, eax
	mov	ecx, 1
	lea	ebx, DWORD PTR [esi+12]
	push	edi
	mov	WORD PTR [esi+8], ax
	mov	WORD PTR [esi+10], cx
	mov	DWORD PTR [esi], 512			; 00000200H
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [ebx], al
	mov	edi, DWORD PTR [ebp]
	sub	edi, 12					; 0000000cH
	je	SHORT $LN19@FStringAFi
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	cmp	edi, eax
	je	SHORT $LN19@FStringAFi
	cmp	WORD PTR [edi+10], 0
	jne	SHORT $LN19@FStringAFi
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN19@FStringAFi:
	mov	DWORD PTR [ebp], 0
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	pop	edi

; 66   : }

	mov	eax, esi
	pop	esi
	mov	DWORD PTR [ebp], ebx
	pop	ebp
	pop	ebx
	ret	4
??0?$FStringAFixedBuffer@$0CAA@@FStringA@@QAE@AAV1@@Z ENDP ; FStringA::FStringAFixedBuffer<512>::FStringAFixedBuffer<512>
_TEXT	ENDS
PUBLIC	?RegisterScriptData@LuaSupport@@YAXPAUlua_State@@@Z ; LuaSupport::RegisterScriptData
EXTRN	?Register@CvLuaTeam@@SAXPAUlua_State@@@Z:PROC	; CvLuaTeam::Register
EXTRN	?Register@CvLuaPlayer@@SAXPAUlua_State@@@Z:PROC	; CvLuaPlayer::Register
EXTRN	?Register@CvLuaGameInfo@@SAXPAUlua_State@@@Z:PROC ; CvLuaGameInfo::Register
EXTRN	?Register@CvLuaFractal@@SAXPAUlua_State@@@Z:PROC ; CvLuaFractal::Register
EXTRN	?Register@CvLuaEnums@@SAXPAUlua_State@@@Z:PROC	; CvLuaEnums::Register
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\lua\cvluasupport.cpp
;	COMDAT ?RegisterScriptData@LuaSupport@@YAXPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?RegisterScriptData@LuaSupport@@YAXPAUlua_State@@@Z PROC ; LuaSupport::RegisterScriptData, COMDAT

; 42   : {

	push	esi

; 43   : 	CvLuaEnums::Register(L);

	mov	esi, DWORD PTR _L$[esp]
	push	esi
	call	?Register@CvLuaEnums@@SAXPAUlua_State@@@Z ; CvLuaEnums::Register

; 44   : 	CvLuaFractal::Register(L);

	push	esi
	call	?Register@CvLuaFractal@@SAXPAUlua_State@@@Z ; CvLuaFractal::Register

; 45   : 	CvLuaGameInfo::Register(L);

	push	esi
	call	?Register@CvLuaGameInfo@@SAXPAUlua_State@@@Z ; CvLuaGameInfo::Register

; 46   : 	CvLuaMap::Register(L);

	push	0
	push	OFFSET ?pRegister@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAHPAUlua_State@@@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::pRegister
	push	esi
	call	?CCallWithErrorHandling@Details@FLua@@YA_NPAUlua_State@@P6AH0@ZPAX@Z ; FLua::Details::CCallWithErrorHandling

; 47   : 	CvLuaGame::Register(L);

	push	0
	push	OFFSET ?pRegister@?$CvLuaStaticInstance@VCvLuaGame@@VCvGame@@@@KAHPAUlua_State@@@Z ; CvLuaStaticInstance<CvLuaGame,CvGame>::pRegister
	push	esi
	call	?CCallWithErrorHandling@Details@FLua@@YA_NPAUlua_State@@P6AH0@ZPAX@Z ; FLua::Details::CCallWithErrorHandling

; 48   : 	CvLuaPlayer::Register(L);

	push	esi
	call	?Register@CvLuaPlayer@@SAXPAUlua_State@@@Z ; CvLuaPlayer::Register

; 49   : 	CvLuaTeam::Register(L);

	push	esi
	call	?Register@CvLuaTeam@@SAXPAUlua_State@@@Z ; CvLuaTeam::Register
	add	esp, 44					; 0000002cH
	pop	esi

; 50   : }

	ret	0
?RegisterScriptData@LuaSupport@@YAXPAUlua_State@@@Z ENDP ; LuaSupport::RegisterScriptData
_TEXT	ENDS
PUBLIC	??1FStringA@@QAE@XZ				; FStringA::~FStringA
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fstringa.inl
;	COMDAT ??1FStringA@@QAE@XZ
_TEXT	SEGMENT
??1FStringA@@QAE@XZ PROC				; FStringA::~FStringA, COMDAT
; _this$ = ecx

; 151  : {

	push	esi
	push	edi
	mov	edi, ecx

; 152  : 	Release();

	mov	esi, DWORD PTR [edi]
	sub	esi, 12					; 0000000cH
	je	SHORT $LN7@FStringA
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	cmp	esi, eax
	je	SHORT $LN7@FStringA
	cmp	WORD PTR [esi+10], 0
	jne	SHORT $LN7@FStringA
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN7@FStringA:
	mov	DWORD PTR [edi], 0
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi

; 153  : }

	ret	0
??1FStringA@@QAE@XZ ENDP				; FStringA::~FStringA
_TEXT	ENDS
PUBLIC	?DumpCallStack@LuaSupport@@YAXPAUlua_State@@@Z	; LuaSupport::DumpCallStack
EXTRN	?Format@FStringA@@QAAXPBDZZ:PROC		; FStringA::Format
EXTRN	_lua_getinfo:PROC
EXTRN	_lua_getstack:PROC
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DumpCallStack@LuaSupport@@YAXPAUlua_State@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DumpCallStack@LuaSupport@@YAXPAUlua_State@@@Z$0
__ehfuncinfo$?DumpCallStack@LuaSupport@@YAXPAUlua_State@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DumpCallStack@LuaSupport@@YAXPAUlua_State@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\lua\cvluasupport.cpp
xdata$x	ENDS
;	COMDAT ?DumpCallStack@LuaSupport@@YAXPAUlua_State@@@Z
_TEXT	SEGMENT
_szTemp$220643 = -640					; size = 4
_ar$220639 = -636					; size = 100
_FStringFixedBuffer_szTemp$220644 = -536		; size = 524
__$EHRec$ = -12						; size = 12
_L$ = 8							; size = 4
?DumpCallStack@LuaSupport@@YAXPAUlua_State@@@Z PROC	; LuaSupport::DumpCallStack, COMDAT

; 54   : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?DumpCallStack@LuaSupport@@YAXPAUlua_State@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 628				; 00000274H
	push	ebx
	push	ebp

; 55   : 	for(int i = 1; i < 10; ++i)

	mov	ebp, DWORD PTR _L$[esp+644]
	push	esi
	push	edi
	mov	ebx, 1
	xor	edi, edi
	npad	3
$LL5@DumpCallSt:

; 56   : 	{
; 57   : 		lua_Debug ar;
; 58   : 		if(lua_getstack(L, i, &ar))

	lea	eax, DWORD PTR _ar$220639[esp+656]
	push	eax
	push	ebx
	push	ebp
	call	_lua_getstack
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN4@DumpCallSt

; 59   : 		{
; 60   : 			lua_getinfo(L, "Sl", &ar);

	lea	ecx, DWORD PTR _ar$220639[esp+656]
	push	ecx
	push	OFFSET $SG220641
	push	ebp
	call	_lua_getinfo
	add	esp, 12					; 0000000cH

; 61   : 			if(ar.currentline > 0)

	cmp	DWORD PTR _ar$220639[esp+676], edi
	jle	$LN4@DumpCallSt

; 62   : 			{
; 63   : 				FStringFixedBuffer(szTemp, 512);

	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _szTemp$220643[esp+656], eax
	lea	edx, DWORD PTR _szTemp$220643[esp+656]
	push	edx
	lea	ecx, DWORD PTR _FStringFixedBuffer_szTemp$220644[esp+660]
	mov	DWORD PTR __$EHRec$[esp+668], edi
	call	??0?$FStringAFixedBuffer@$0CAA@@FStringA@@QAE@AAV1@@Z ; FStringA::FStringAFixedBuffer<512>::FStringAFixedBuffer<512>

; 64   : 				szTemp.Format("%s:%d\n", (ar.source)?ar.source:"", ar.currentline);

	mov	eax, DWORD PTR _ar$220639[esp+672]
	cmp	eax, edi
	jne	SHORT $LN9@DumpCallSt
	mov	eax, OFFSET $SG220645
$LN9@DumpCallSt:
	mov	ecx, DWORD PTR _ar$220639[esp+676]
	push	ecx
	push	eax
	lea	edx, DWORD PTR _szTemp$220643[esp+664]
	push	OFFSET $SG220646
	push	edx
	call	?Format@FStringA@@QAAXPBDZZ		; FStringA::Format

; 65   : 				OutputDebugString(szTemp.c_str());
; 66   : 			}

	mov	esi, DWORD PTR _szTemp$220643[esp+672]
	add	esi, -12				; fffffff4H
	add	esp, 16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+664], -1
	cmp	esi, edi
	je	SHORT $LN23@DumpCallSt
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	cmp	esi, eax
	je	SHORT $LN23@DumpCallSt
	cmp	WORD PTR [esi+10], di
	jne	SHORT $LN23@DumpCallSt
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN23@DumpCallSt:
	mov	DWORD PTR _szTemp$220643[esp+656], edi
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _szTemp$220643[esp+656], eax
$LN4@DumpCallSt:
	inc	ebx
	cmp	ebx, 10					; 0000000aH
	jl	$LL5@DumpCallSt

; 67   : 		}
; 68   : 	}
; 69   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+656]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 640				; 00000280H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DumpCallStack@LuaSupport@@YAXPAUlua_State@@@Z$0:
	lea	ecx, DWORD PTR _szTemp$220643[ebp]
	jmp	??1FStringA@@QAE@XZ			; FStringA::~FStringA
__ehhandler$?DumpCallStack@LuaSupport@@YAXPAUlua_State@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DumpCallStack@LuaSupport@@YAXPAUlua_State@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DumpCallStack@LuaSupport@@YAXPAUlua_State@@@Z ENDP	; LuaSupport::DumpCallStack
END
