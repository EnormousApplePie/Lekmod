; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvGameCoreEnumSerialization.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG217190 DB	'NO_YIELD', 00H
	ORG $+3
$SG217193 DB	'YIELD_FOOD', 00H
	ORG $+1
$SG217196 DB	'YIELD_PRODUCTION', 00H
	ORG $+3
$SG217199 DB	'YIELD_GOLD', 00H
	ORG $+1
$SG217202 DB	'YIELD_SCIENCE', 00H
	ORG $+2
$SG217205 DB	'YIELD_CULTURE', 00H
	ORG $+2
$SG217208 DB	'YIELD_FAITH', 00H
$SG217211 DB	'INVALID ENUM VALUE', 00H
	ORG $+1
$SG217213 DB	'INVALID ENUM VALUE', 00H
CONST	ENDS
PUBLIC	?toString@FSerialization@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABW4YieldTypes@@@Z ; FSerialization::toString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreenumserialization.cpp
;	COMDAT ?toString@FSerialization@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABW4YieldTypes@@@Z
_TEXT	SEGMENT
$T217309 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
?toString@FSerialization@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABW4YieldTypes@@@Z PROC ; FSerialization::toString, COMDAT

; 28   : {

	push	ecx

; 29   : 	switch(v)

	mov	eax, DWORD PTR _v$[esp]
	mov	eax, DWORD PTR [eax]
	inc	eax
	push	esi
	mov	DWORD PTR $T217309[esp+8], 0
	cmp	eax, 6
	ja	$LN1@toString
	jmp	DWORD PTR $LN16@toString[eax*4]
$LN8@toString:

; 30   : 	{
; 31   : 	case NO_YIELD:
; 32   : 		return std::string("NO_YIELD");
; 33   : 		break;
; 34   : 	case YIELD_FOOD:
; 35   : 		return std::string("YIELD_FOOD");
; 36   : 		break;
; 37   : 	case YIELD_PRODUCTION:
; 38   : 		return std::string("YIELD_PRODUCTION");
; 39   : 		break;
; 40   : 	case YIELD_GOLD:
; 41   : 		return std::string("YIELD_GOLD");
; 42   : 		break;
; 43   : 	case YIELD_SCIENCE:
; 44   : 		return std::string("YIELD_SCIENCE");
; 45   : 		break;
; 46   : 	case YIELD_CULTURE:
; 47   : 		return std::string("YIELD_CULTURE");
; 48   : 		break;
; 49   : 	case YIELD_FAITH:
; 50   : 		return std::string("YIELD_FAITH");
; 51   : 		break;
; 52   : 	default:
; 53   : 		return std::string("INVALID ENUM VALUE");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET $SG217190
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 54   : 		break;
; 55   : 	}
; 56   : #ifndef AUI_WARNING_FIXES
; 57   : 	return std::string("INVALID ENUM VALUE");
; 58   : #endif
; 59   : }

	pop	ecx
	ret	0
$LN7@toString:

; 30   : 	{
; 31   : 	case NO_YIELD:
; 32   : 		return std::string("NO_YIELD");
; 33   : 		break;
; 34   : 	case YIELD_FOOD:
; 35   : 		return std::string("YIELD_FOOD");
; 36   : 		break;
; 37   : 	case YIELD_PRODUCTION:
; 38   : 		return std::string("YIELD_PRODUCTION");
; 39   : 		break;
; 40   : 	case YIELD_GOLD:
; 41   : 		return std::string("YIELD_GOLD");
; 42   : 		break;
; 43   : 	case YIELD_SCIENCE:
; 44   : 		return std::string("YIELD_SCIENCE");
; 45   : 		break;
; 46   : 	case YIELD_CULTURE:
; 47   : 		return std::string("YIELD_CULTURE");
; 48   : 		break;
; 49   : 	case YIELD_FAITH:
; 50   : 		return std::string("YIELD_FAITH");
; 51   : 		break;
; 52   : 	default:
; 53   : 		return std::string("INVALID ENUM VALUE");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET $SG217193
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 54   : 		break;
; 55   : 	}
; 56   : #ifndef AUI_WARNING_FIXES
; 57   : 	return std::string("INVALID ENUM VALUE");
; 58   : #endif
; 59   : }

	pop	ecx
	ret	0
$LN6@toString:

; 30   : 	{
; 31   : 	case NO_YIELD:
; 32   : 		return std::string("NO_YIELD");
; 33   : 		break;
; 34   : 	case YIELD_FOOD:
; 35   : 		return std::string("YIELD_FOOD");
; 36   : 		break;
; 37   : 	case YIELD_PRODUCTION:
; 38   : 		return std::string("YIELD_PRODUCTION");
; 39   : 		break;
; 40   : 	case YIELD_GOLD:
; 41   : 		return std::string("YIELD_GOLD");
; 42   : 		break;
; 43   : 	case YIELD_SCIENCE:
; 44   : 		return std::string("YIELD_SCIENCE");
; 45   : 		break;
; 46   : 	case YIELD_CULTURE:
; 47   : 		return std::string("YIELD_CULTURE");
; 48   : 		break;
; 49   : 	case YIELD_FAITH:
; 50   : 		return std::string("YIELD_FAITH");
; 51   : 		break;
; 52   : 	default:
; 53   : 		return std::string("INVALID ENUM VALUE");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET $SG217196
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 54   : 		break;
; 55   : 	}
; 56   : #ifndef AUI_WARNING_FIXES
; 57   : 	return std::string("INVALID ENUM VALUE");
; 58   : #endif
; 59   : }

	pop	ecx
	ret	0
$LN5@toString:

; 30   : 	{
; 31   : 	case NO_YIELD:
; 32   : 		return std::string("NO_YIELD");
; 33   : 		break;
; 34   : 	case YIELD_FOOD:
; 35   : 		return std::string("YIELD_FOOD");
; 36   : 		break;
; 37   : 	case YIELD_PRODUCTION:
; 38   : 		return std::string("YIELD_PRODUCTION");
; 39   : 		break;
; 40   : 	case YIELD_GOLD:
; 41   : 		return std::string("YIELD_GOLD");
; 42   : 		break;
; 43   : 	case YIELD_SCIENCE:
; 44   : 		return std::string("YIELD_SCIENCE");
; 45   : 		break;
; 46   : 	case YIELD_CULTURE:
; 47   : 		return std::string("YIELD_CULTURE");
; 48   : 		break;
; 49   : 	case YIELD_FAITH:
; 50   : 		return std::string("YIELD_FAITH");
; 51   : 		break;
; 52   : 	default:
; 53   : 		return std::string("INVALID ENUM VALUE");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET $SG217199
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 54   : 		break;
; 55   : 	}
; 56   : #ifndef AUI_WARNING_FIXES
; 57   : 	return std::string("INVALID ENUM VALUE");
; 58   : #endif
; 59   : }

	pop	ecx
	ret	0
$LN4@toString:

; 30   : 	{
; 31   : 	case NO_YIELD:
; 32   : 		return std::string("NO_YIELD");
; 33   : 		break;
; 34   : 	case YIELD_FOOD:
; 35   : 		return std::string("YIELD_FOOD");
; 36   : 		break;
; 37   : 	case YIELD_PRODUCTION:
; 38   : 		return std::string("YIELD_PRODUCTION");
; 39   : 		break;
; 40   : 	case YIELD_GOLD:
; 41   : 		return std::string("YIELD_GOLD");
; 42   : 		break;
; 43   : 	case YIELD_SCIENCE:
; 44   : 		return std::string("YIELD_SCIENCE");
; 45   : 		break;
; 46   : 	case YIELD_CULTURE:
; 47   : 		return std::string("YIELD_CULTURE");
; 48   : 		break;
; 49   : 	case YIELD_FAITH:
; 50   : 		return std::string("YIELD_FAITH");
; 51   : 		break;
; 52   : 	default:
; 53   : 		return std::string("INVALID ENUM VALUE");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET $SG217202
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 54   : 		break;
; 55   : 	}
; 56   : #ifndef AUI_WARNING_FIXES
; 57   : 	return std::string("INVALID ENUM VALUE");
; 58   : #endif
; 59   : }

	pop	ecx
	ret	0
$LN3@toString:

; 30   : 	{
; 31   : 	case NO_YIELD:
; 32   : 		return std::string("NO_YIELD");
; 33   : 		break;
; 34   : 	case YIELD_FOOD:
; 35   : 		return std::string("YIELD_FOOD");
; 36   : 		break;
; 37   : 	case YIELD_PRODUCTION:
; 38   : 		return std::string("YIELD_PRODUCTION");
; 39   : 		break;
; 40   : 	case YIELD_GOLD:
; 41   : 		return std::string("YIELD_GOLD");
; 42   : 		break;
; 43   : 	case YIELD_SCIENCE:
; 44   : 		return std::string("YIELD_SCIENCE");
; 45   : 		break;
; 46   : 	case YIELD_CULTURE:
; 47   : 		return std::string("YIELD_CULTURE");
; 48   : 		break;
; 49   : 	case YIELD_FAITH:
; 50   : 		return std::string("YIELD_FAITH");
; 51   : 		break;
; 52   : 	default:
; 53   : 		return std::string("INVALID ENUM VALUE");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET $SG217205
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 54   : 		break;
; 55   : 	}
; 56   : #ifndef AUI_WARNING_FIXES
; 57   : 	return std::string("INVALID ENUM VALUE");
; 58   : #endif
; 59   : }

	pop	ecx
	ret	0
$LN2@toString:

; 30   : 	{
; 31   : 	case NO_YIELD:
; 32   : 		return std::string("NO_YIELD");
; 33   : 		break;
; 34   : 	case YIELD_FOOD:
; 35   : 		return std::string("YIELD_FOOD");
; 36   : 		break;
; 37   : 	case YIELD_PRODUCTION:
; 38   : 		return std::string("YIELD_PRODUCTION");
; 39   : 		break;
; 40   : 	case YIELD_GOLD:
; 41   : 		return std::string("YIELD_GOLD");
; 42   : 		break;
; 43   : 	case YIELD_SCIENCE:
; 44   : 		return std::string("YIELD_SCIENCE");
; 45   : 		break;
; 46   : 	case YIELD_CULTURE:
; 47   : 		return std::string("YIELD_CULTURE");
; 48   : 		break;
; 49   : 	case YIELD_FAITH:
; 50   : 		return std::string("YIELD_FAITH");
; 51   : 		break;
; 52   : 	default:
; 53   : 		return std::string("INVALID ENUM VALUE");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET $SG217208
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 54   : 		break;
; 55   : 	}
; 56   : #ifndef AUI_WARNING_FIXES
; 57   : 	return std::string("INVALID ENUM VALUE");
; 58   : #endif
; 59   : }

	pop	ecx
	ret	0
$LN1@toString:

; 30   : 	{
; 31   : 	case NO_YIELD:
; 32   : 		return std::string("NO_YIELD");
; 33   : 		break;
; 34   : 	case YIELD_FOOD:
; 35   : 		return std::string("YIELD_FOOD");
; 36   : 		break;
; 37   : 	case YIELD_PRODUCTION:
; 38   : 		return std::string("YIELD_PRODUCTION");
; 39   : 		break;
; 40   : 	case YIELD_GOLD:
; 41   : 		return std::string("YIELD_GOLD");
; 42   : 		break;
; 43   : 	case YIELD_SCIENCE:
; 44   : 		return std::string("YIELD_SCIENCE");
; 45   : 		break;
; 46   : 	case YIELD_CULTURE:
; 47   : 		return std::string("YIELD_CULTURE");
; 48   : 		break;
; 49   : 	case YIELD_FAITH:
; 50   : 		return std::string("YIELD_FAITH");
; 51   : 		break;
; 52   : 	default:
; 53   : 		return std::string("INVALID ENUM VALUE");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET $SG217211
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 54   : 		break;
; 55   : 	}
; 56   : #ifndef AUI_WARNING_FIXES
; 57   : 	return std::string("INVALID ENUM VALUE");
; 58   : #endif
; 59   : }

	pop	ecx
	ret	0
	npad	3
$LN16@toString:
	DD	$LN8@toString
	DD	$LN7@toString
	DD	$LN6@toString
	DD	$LN5@toString
	DD	$LN4@toString
	DD	$LN3@toString
	DD	$LN2@toString
?toString@FSerialization@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABW4YieldTypes@@@Z ENDP ; FSerialization::toString
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABW4YieldTypes@@@Z	; operator<<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreenumserialization.cpp
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABW4YieldTypes@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
$T217324 = 12						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABW4YieldTypes@@@Z PROC	; operator<<, COMDAT

; 13   : 	saveTo << static_cast<int>(readFrom);

	mov	eax, DWORD PTR _readFrom$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _saveTo$[esp]
	lea	edx, DWORD PTR $T217324[esp]
	mov	DWORD PTR $T217324[esp], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 14   : 	return saveTo;

	mov	eax, esi
	pop	esi

; 15   : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABW4YieldTypes@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAW4YieldTypes@@@Z	; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAW4YieldTypes@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAW4YieldTypes@@@Z PROC	; operator>>, COMDAT

; 18   : {

	push	esi

; 19   : 	int v;
; 20   : 	loadFrom >> v;

	mov	esi, DWORD PTR _loadFrom$[esp]
	lea	eax, DWORD PTR _v$[esp]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 21   : 	writeTo = static_cast<YieldTypes>(v);

	mov	ecx, DWORD PTR _writeTo$[esp]
	mov	edx, DWORD PTR _v$[esp]

; 22   : 	return loadFrom;

	mov	eax, esi
	mov	DWORD PTR [ecx], edx
	pop	esi

; 23   : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAW4YieldTypes@@@Z ENDP	; operator>>
_TEXT	ENDS
END
