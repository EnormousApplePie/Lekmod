; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvUnitCombat.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
CONST	SEGMENT
$SG222193 DB	'Capture Enemy Roll', 00H
	ORG $+1
$SG222302 DB	'TXT_KEY_MISC_YOU_UNIT_DIED_ATTACKING', 00H
	ORG $+3
$SG222321 DB	'TXT_KEY_MISC_YOU_KILLED_ENEMY_UNIT', 00H
	ORG $+1
$SG222341 DB	'TXT_KEY_MISC_YOU_UNIT_DESTROYED_ENEMY', 00H
	ORG $+2
$SG222355 DB	'TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED_UNKNOWN', 00H
$SG222372 DB	'TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED', 00H
$SG222378 DB	'TXT_KEY_UNIT_LOST', 00H
	ORG $+2
$SG222397 DB	'TXT_KEY_MISC_YOU_UNIT_WITHDRAW', 00H
	ORG $+1
$SG222402 DB	'TXT_KEY_MISC_ENEMY_UNIT_WITHDRAW', 00H
	ORG $+3
$SG222509 DB	'TXT_KEY_MISC_YOU_ATTACK_BY_AIR_AND_DEATH', 00H
	ORG $+3
$SG222513 DB	'TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_AIR_AND_DEATH', 00H
	ORG $+1
$SG222518 DB	'TXT_KEY_UNIT_LOST', 00H
	ORG $+2
$SG222528 DB	'TXT_KEY_MISC_YOU_ATTACK_BY_AIR', 00H
	ORG $+1
$SG222532 DB	'TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_AIR', 00H
	ORG $+3
$SG222545 DB	'TXT_KEY_MISC_YOUR_CITY_ATTACKED_BY_AIR', 00H
	ORG $+1
$SG222570 DB	'TXT_KEY_MISC_YOUR_CITY_RANGE_ATTACK', 00H
$SG222581 DB	'TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_CITY', 00H
	ORG $+2
$SG222589 DB	'TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_CITY', 00H
	ORG $+2
$SG222594 DB	'TXT_KEY_UNIT_LOST', 00H
	ORG $+2
$SG222635 DB	'TXT_KEY_MISC_YOU_CITY_RANSOMED_BY_BARBARIANS', 00H
	ORG $+3
$SG222647 DB	'TXT_KEY_MISC_YOU_UNIT_DIED_ATTACKING_CITY', 00H
	ORG $+2
$SG222664 DB	'TXT_KEY_MISC_YOU_KILLED_ENEMY_UNIT_CITY', 00H
$SG222672 DB	'TXT_KEY_MISC_YOU_UNIT_CAPTURED_ENEMY_CITY', 00H
	ORG $+2
$SG222678 DB	'TXT_KEY_MISC_YOU_CITY_WAS_CAPTURED', 00H
	ORG $+1
$SG222684 DB	'TXT_KEY_MISC_YOU_UNIT_WITHDRAW_CITY', 00H
$SG222689 DB	'TXT_KEY_MISC_ENEMY_UNIT_WITHDRAW_CITY', 00H
	ORG $+2
$SG222703 DB	'Evasion Rand', 00H
	ORG $+3
$SG222705 DB	'Intercept Rand (Air)', 00H
	ORG $+3
$SG222735 DB	'UNIT_AMERICAN_B17', 00H
	ORG $+2
$SG222770 DB	'TXT_KEY_MISC_YOU_UNIT_DIED_ATTACKING', 00H
	ORG $+3
$SG222789 DB	'TXT_KEY_MISC_ENEMY_AIR_UNIT_DESTROYED', 00H
	ORG $+2
$SG222796 DB	'TXT_KEY_MISC_YOU_KILLED_ENEMY_UNIT', 00H
	ORG $+1
$SG222804 DB	'TXT_KEY_MISC_YOU_ATTACK_BY_AIR_AND_DEATH', 00H
	ORG $+3
$SG222809 DB	'TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_AIR_AND_DEATH', 00H
	ORG $+1
$SG222814 DB	'TXT_KEY_UNIT_LOST', 00H
	ORG $+2
$SG222821 DB	'TXT_KEY_MISC_YOU_ATTACK_BY_AIR', 00H
	ORG $+1
$SG222842 DB	'TXT_KEY_MISC_ENEMY_AIR_UNIT_INTERCEPTED', 00H
$SG222847 DB	'TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_AIR', 00H
	ORG $+3
$SG222860 DB	'TXT_KEY_MISC_YOU_UNIT_DIED_ATTACKING_CITY', 00H
	ORG $+2
$SG222865 DB	'TXT_KEY_MISC_YOUR_CITY_ATTACKED_BY_AIR', 00H
	ORG $+1
$SG222925 DB	'TXT_KEY_MISC_YOU_UNIT_DIED_ATTACKING', 00H
	ORG $+3
$SG222932 DB	'TXT_KEY_MISC_YOU_KILLED_ENEMY_UNIT', 00H
	ORG $+1
$SG222944 DB	'TXT_KEY_MISC_YOU_UNIT_DIED_ATTACKING', 00H
	ORG $+3
$SG222951 DB	'TXT_KEY_MISC_YOU_KILLED_ENEMY_UNIT', 00H
	ORG $+1
$SG222962 DB	'TXT_KEY_MISC_YOU_UNIT_DESTROYED_ENEMY', 00H
	ORG $+2
$SG222968 DB	'TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED_UNKNOWN', 00H
$SG222974 DB	'TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED', 00H
$SG222981 DB	'TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED_UNKNOWN', 00H
$SG222987 DB	'TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED', 00H
$SG222990 DB	'TXT_KEY_UNIT_LOST', 00H
	ORG $+2
$SG222997 DB	'TXT_KEY_MISC_YOU_UNIT_WITHDRAW', 00H
	ORG $+1
$SG223002 DB	'TXT_KEY_MISC_ENEMY_UNIT_WITHDRAW', 00H
	ORG $+3
$SG223035 DB	'NuclearDetonation', 00H
	ORG $+2
$SG223098 DB	'Nuke Fallout', 00H
	ORG $+3
$SG223104 DB	'Nuke Fallout', 00H
	ORG $+3
$SG223185 DB	'Population Nuked 1', 00H
	ORG $+1
$SG223186 DB	'Population Nuked 2', 00H
	ORG $+1
$SG223188 DB	'Population Nuked 1', 00H
	ORG $+1
$SG223189 DB	'Population Nuked 2', 00H
	ORG $+1
$SG223354 DB	'Nuke Damage 1', 00H
	ORG $+2
$SG223355 DB	'Nuke Damage 2', 00H
	ORG $+2
$SG223397 DB	'CIVILIZATION_MAYA', 00H
	ORG $+2
$SG223477 DB	'TXT_KEY_MISC_ENEMY_UNIT_WITHDREW', 00H
	ORG $+3
$SG223481 DB	'TXT_KEY_MISC_FRIENDLY_UNIT_WITHDREW', 00H
$SG223495 DB	'TXT_KEY_UNIT_CAPTURED_BARBS_DETAILED', 00H
	ORG $+3
$SG223499 DB	'TXT_KEY_UNIT_CAPTURED_BARBS', 00H
$SG223502 DB	'TXT_KEY_UNIT_CAPTURED_DETAILED', 00H
	ORG $+1
$SG223505 DB	'TXT_KEY_UNIT_CAPTURED', 00H
	ORG $+2
$SG223508 DB	'TXT_KEY_UNIT_LOST', 00H
	ORG $+2
$SG223794 DB	'TXT_KEY_AIR_PATROL_FOUND_NOTHING', 00H
	ORG $+3
$SG223914 DB	'[COLOR_WHITE]+%d[ENDCOLOR][ICON_GOLDEN_AGE]', 00H
$SG223931 DB	'LEADER_ELIZABETH', 00H
	ORG $+3
$SG223933 DB	'UNIT_SIAMESE_WARELEPHANT', 00H
	ORG $+3
$SG223938 DB	'LEADER_ODA_NOBUNAGA', 00H
$SG223940 DB	'UNIT_FRENCH_MUSKETEER', 00H
	ORG $+2
$SG223943 DB	'UNIT_KOREAN_TURTLE_SHIP', 00H
$SG223948 DB	'UNIT_IRONCLAD', 00H
	ORG $+2
$SG223950 DB	'UNIT_KOREAN_HWACHA', 00H
	ORG $+1
$SG223967 DB	'[COLOR_YELLOW]+%d[ENDCOLOR][ICON_GOLD]', 00H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?range@@YAHHHH@Z				; range
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?range@@YAHHHH@Z
_TEXT	SEGMENT
_iNum$ = 8						; size = 4
_iLow$ = 12						; size = 4
_iHigh$ = 16						; size = 4
?range@@YAHHHH@Z PROC					; range, COMDAT

; 21   : 	CvAssertMsg(iHigh >= iLow, "High should be higher than low");
; 22   : 
; 23   : 	if(iNum < iLow)

	mov	ecx, DWORD PTR _iNum$[esp-4]
	mov	eax, DWORD PTR _iLow$[esp-4]
	cmp	ecx, eax

; 24   : 	{
; 25   : 		return iLow;

	jl	SHORT $LN1@range

; 26   : 	}
; 27   : 	else if(iNum > iHigh)

	mov	eax, DWORD PTR _iHigh$[esp-4]
	cmp	ecx, eax

; 28   : 	{
; 29   : 		return iHigh;

	jg	SHORT $LN1@range

; 30   : 	}
; 31   : 	else
; 32   : 	{
; 33   : 		return iNum;

	mov	eax, ecx
$LN1@range:

; 34   : 	}
; 35   : }

	ret	0
?range@@YAHHHH@Z ENDP					; range
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
EXTRN	?quickCombat@CvPreGame@@YA_NXZ:PROC		; CvPreGame::quickCombat
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
;	COMDAT ?GetPostCombatDelay@@YAHXZ
_TEXT	SEGMENT
?GetPostCombatDelay@@YAHXZ PROC				; GetPostCombatDelay, COMDAT

; 33   : 	return CvPreGame::quickCombat()?POST_QUICK_COMBAT_DELAY:POST_COMBAT_DELAY;

	call	?quickCombat@CvPreGame@@YA_NXZ		; CvPreGame::quickCombat
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	and	eax, 109				; 0000006dH
	inc	eax

; 34   : }

	ret	0
?GetPostCombatDelay@@YAHXZ ENDP				; GetPostCombatDelay
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtpy
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	edi
	mov	edi, DWORD PTR ___n$[esp]
	sub	edi, 1
	js	SHORT $LN1@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR ___s$[esp+8]
	push	esi
	mov	esi, DWORD PTR ___t$[esp+12]
	npad	7
$LL2@vector:
	mov	ecx, esi
	call	ebx
	add	esi, ebp
	sub	edi, 1
	jns	SHORT $LL2@vector
	pop	esi
	pop	ebp
	pop	ebx
$LN1@vector:
	pop	edi
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ; FObjectHandle<CvUnit>::pointer
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC ; FObjectHandle<CvUnit>::pointer, COMDAT
; _this$ = ecx

; 78   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 79   : 	}

	ret	0
?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP ; FObjectHandle<CvUnit>::pointer
_TEXT	ENDS
PUBLIC	??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ	; FObjectHandle<CvUnit>::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC	; FObjectHandle<CvUnit>::operator->, COMDAT
; _this$ = ecx

; 88   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 89   : 	}

	ret	0
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP	; FObjectHandle<CvUnit>::operator->
_TEXT	ENDS
PUBLIC	??7?$FObjectHandle@VCvUnit@@@@QBE_NXZ		; FObjectHandle<CvUnit>::operator!
; Function compile flags: /Ogtpy
;	COMDAT ??7?$FObjectHandle@VCvUnit@@@@QBE_NXZ
_TEXT	SEGMENT
??7?$FObjectHandle@VCvUnit@@@@QBE_NXZ PROC		; FObjectHandle<CvUnit>::operator!, COMDAT
; _this$ = ecx

; 113  : 		return m_target == 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	sete	al

; 114  : 	}

	ret	0
??7?$FObjectHandle@VCvUnit@@@@QBE_NXZ ENDP		; FObjectHandle<CvUnit>::operator!
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 215  : 	{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	BYTE PTR [eax+4], 0

; 216  : 		OBJECT_HANDLE_STACK;
; 217  : 	}

	ret	0
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z ; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z PROC	; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z ENDP	; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvUnit1@@@std@@QAE@U?$auto_ptr_ref@VICvUnit1@@@1@@Z ; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvUnit1@@@std@@QAE@U?$auto_ptr_ref@VICvUnit1@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr@VICvUnit1@@@std@@QAE@U?$auto_ptr_ref@VICvUnit1@@@1@@Z PROC ; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 669  : 	auto_ptr(auto_ptr_ref<_Ty> _Right) _THROW0()

	mov	eax, ecx

; 670  : 		{	// construct by assuming pointer from _Right auto_ptr_ref
; 671  : 		_Ty *_Ptr = _Right._Ref;
; 672  : 		_Right._Ref = 0;	// release old
; 673  : 		_Myptr = _Ptr;	// reset this

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 674  : 		}

	ret	4
??0?$auto_ptr@VICvUnit1@@@std@@QAE@U?$auto_ptr_ref@VICvUnit1@@@1@@Z ENDP ; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ ; std::auto_ptr<ICvUnit1>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ PROC ; std::auto_ptr<ICvUnit1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ ENDP ; std::auto_ptr<ICvUnit1>::get
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z ; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z PROC	; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z ENDP	; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvCity1@@@std@@QBEPAVICvCity1@@XZ ; std::auto_ptr<ICvCity1>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$auto_ptr@VICvCity1@@@std@@QBEPAVICvCity1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvCity1@@@std@@QBEPAVICvCity1@@XZ PROC ; std::auto_ptr<ICvCity1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvCity1@@@std@@QBEPAVICvCity1@@XZ ENDP ; std::auto_ptr<ICvCity1>::get
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvPlot1@@@std@@QAE@U?$auto_ptr_ref@VICvPlot1@@@1@@Z ; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvPlot1@@@std@@QAE@U?$auto_ptr_ref@VICvPlot1@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr@VICvPlot1@@@std@@QAE@U?$auto_ptr_ref@VICvPlot1@@@1@@Z PROC ; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>, COMDAT
; _this$ = ecx

; 669  : 	auto_ptr(auto_ptr_ref<_Ty> _Right) _THROW0()

	mov	eax, ecx

; 670  : 		{	// construct by assuming pointer from _Right auto_ptr_ref
; 671  : 		_Ty *_Ptr = _Right._Ref;
; 672  : 		_Right._Ref = 0;	// release old
; 673  : 		_Myptr = _Ptr;	// reset this

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 674  : 		}

	ret	4
??0?$auto_ptr@VICvPlot1@@@std@@QAE@U?$auto_ptr_ref@VICvPlot1@@@1@@Z ENDP ; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ ; std::auto_ptr<ICvPlot1>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ PROC ; std::auto_ptr<ICvPlot1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ ENDP ; std::auto_ptr<ICvPlot1>::get
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvCombatInfo1@@@std@@QAE@PAVICvCombatInfo1@@@Z ; std::auto_ptr<ICvCombatInfo1>::auto_ptr<ICvCombatInfo1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvCombatInfo1@@@std@@QAE@PAVICvCombatInfo1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvCombatInfo1@@@std@@QAE@PAVICvCombatInfo1@@@Z PROC ; std::auto_ptr<ICvCombatInfo1>::auto_ptr<ICvCombatInfo1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvCombatInfo1@@@std@@QAE@PAVICvCombatInfo1@@@Z ENDP ; std::auto_ptr<ICvCombatInfo1>::auto_ptr<ICvCombatInfo1>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvCombatInfo1@@@std@@QBEPAVICvCombatInfo1@@XZ ; std::auto_ptr<ICvCombatInfo1>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$auto_ptr@VICvCombatInfo1@@@std@@QBEPAVICvCombatInfo1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvCombatInfo1@@@std@@QBEPAVICvCombatInfo1@@XZ PROC ; std::auto_ptr<ICvCombatInfo1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvCombatInfo1@@@std@@QBEPAVICvCombatInfo1@@XZ ENDP ; std::auto_ptr<ICvCombatInfo1>::get
_TEXT	ENDS
PUBLIC	?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget, COMDAT
; _this$ = ecx

; 52   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 53   : 		m_targets.insert(&target);
; 54   : #endif
; 55   : 	}

	ret	4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
_TEXT	ENDS
PUBLIC	?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
; Function compile flags: /Ogtpy
;	COMDAT ?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget, COMDAT
; _this$ = ecx

; 63   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 64   : 		m_targets.erase(&target);
; 65   : #endif
; 66   : 	}

	ret	4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UIDInfo@@$00@@QAEAAUIDInfo@@I@Z	; BaseVector<IDInfo,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@UIDInfo@@$00@@QAEAAUIDInfo@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UIDInfo@@$00@@QAEAAUIDInfo@@I@Z PROC	; BaseVector<IDInfo,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 131  : 	};

	ret	4
??A?$BaseVector@UIDInfo@@$00@@QAEAAUIDInfo@@I@Z ENDP	; BaseVector<IDInfo,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UIDInfo@@$00@@QBEIXZ		; BaseVector<IDInfo,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UIDInfo@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UIDInfo@@$00@@QBEIXZ PROC		; BaseVector<IDInfo,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UIDInfo@@$00@@QBEIXZ ENDP		; BaseVector<IDInfo,1>::size
_TEXT	ENDS
PUBLIC	?getAt@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@H@Z ; FFastSmallFixedList<IDInfo,25,1,297,0>::getAt
; Function compile flags: /Ogtpy
;	COMDAT ?getAt@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?getAt@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@H@Z PROC ; FFastSmallFixedList<IDInfo,25,1,297,0>::getAt, COMDAT
; _this$ = ecx

; 881  :         if ( (UINT)iIndex < mVec.size() )

	mov	eax, DWORD PTR _iIndex$[esp-4]
	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN2@getAt

; 882  : #endif
; 883  : 	    {
; 884  : 		    return &mVec[ iIndex ];

	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 889  : 	    }
; 890  :     };

	ret	4
$LN2@getAt:

; 885  : 	    }
; 886  : 	    else
; 887  : 	    {
; 888  : 		    return NULL;

	xor	eax, eax

; 889  : 	    }
; 890  :     };

	ret	4
?getAt@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@H@Z ENDP ; FFastSmallFixedList<IDInfo,25,1,297,0>::getAt
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UIDInfo@@$00@@IAE@XZ		; BaseVector<IDInfo,1>::BaseVector<IDInfo,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UIDInfo@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UIDInfo@@$00@@IAE@XZ PROC		; BaseVector<IDInfo,1>::BaseVector<IDInfo,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UIDInfo@@$00@@IAE@XZ ENDP		; BaseVector<IDInfo,1>::BaseVector<IDInfo,1>
_TEXT	ENDS
PUBLIC	??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEPAUIDInfo@@I@Z ; FStaticVector<IDInfo,25,1,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
CONST	SEGMENT
??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ DB 'c:\users\eno'
	DB	'rmousapplepie\documents\github\lekmod\lekmod_dll\fireplace\in'
	DB	'clude\fireworks\FFastVector.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEPAUIDInfo@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEPAUIDInfo@@I@Z PROC ; FStaticVector<IDInfo,25,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 25					; 00000019H
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 25			; 00000019H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEPAUIDInfo@@I@Z ENDP ; FStaticVector<IDInfo,25,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NPBD@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z PROC	; operator<<<char const *>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ENDP	; operator<<<char const *>
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z	; operator<<<int>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NH@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z PROC	; operator<<<int>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ENDP	; operator<<<int>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ		; sprintf_s<256>
EXTRN	__imp__vsprintf_s:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdio.h
;	COMDAT ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ PROC		; sprintf_s<256>, COMDAT

; 322  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, sprintf_s, vsprintf_s, char, _Dest, _In_z_ _Printf_format_string_ const char *, _Format)

	mov	ecx, DWORD PTR __Format$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	lea	eax, DWORD PTR __Format$[esp]
	push	eax
	push	ecx
	push	256					; 00000100H
	push	edx
	call	DWORD PTR __imp__vsprintf_s
	add	esp, 16					; 00000010H
	ret	0
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ENDP		; sprintf_s<256>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr_ref@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z ; std::auto_ptr_ref<ICvUnit1>::auto_ptr_ref<ICvUnit1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr_ref@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr_ref@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z PROC ; std::auto_ptr_ref<ICvUnit1>::auto_ptr_ref<ICvUnit1>, COMDAT
; _this$ = ecx

; 647  : 		{	// construct from generic pointer to auto_ptr ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 648  : 		}

	ret	4
??0?$auto_ptr_ref@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z ENDP ; std::auto_ptr_ref<ICvUnit1>::auto_ptr_ref<ICvUnit1>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr_ref@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z ; std::auto_ptr_ref<ICvPlot1>::auto_ptr_ref<ICvPlot1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr_ref@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr_ref@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z PROC ; std::auto_ptr_ref<ICvPlot1>::auto_ptr_ref<ICvPlot1>, COMDAT
; _this$ = ecx

; 647  : 		{	// construct from generic pointer to auto_ptr ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 648  : 		}

	ret	4
??0?$auto_ptr_ref@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z ENDP ; std::auto_ptr_ref<ICvPlot1>::auto_ptr_ref<ICvPlot1>
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	?GetPlayer@CvCombatMemberEntry@@QBE?AW4PlayerTypes@@XZ ; CvCombatMemberEntry::GetPlayer
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstructs.h
;	COMDAT ?GetPlayer@CvCombatMemberEntry@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetPlayer@CvCombatMemberEntry@@QBE?AW4PlayerTypes@@XZ PROC ; CvCombatMemberEntry::GetPlayer, COMDAT
; _this$ = ecx

; 42   : 	PlayerTypes GetPlayer() const { return m_ePlayer; }

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetPlayer@CvCombatMemberEntry@@QBE?AW4PlayerTypes@@XZ ENDP ; CvCombatMemberEntry::GetPlayer
_TEXT	ENDS
PUBLIC	?SetPlayer@CvCombatMemberEntry@@QAEXW4PlayerTypes@@@Z ; CvCombatMemberEntry::SetPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?SetPlayer@CvCombatMemberEntry@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?SetPlayer@CvCombatMemberEntry@@QAEXW4PlayerTypes@@@Z PROC ; CvCombatMemberEntry::SetPlayer, COMDAT
; _this$ = ecx

; 43   : 	void		SetPlayer(PlayerTypes ePlayer) { m_ePlayer = ePlayer; }

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	mov	DWORD PTR [ecx], eax
	ret	4
?SetPlayer@CvCombatMemberEntry@@QAEXW4PlayerTypes@@@Z ENDP ; CvCombatMemberEntry::SetPlayer
_TEXT	ENDS
PUBLIC	?IsValid@CvCombatMemberEntry@@QBE_NXZ		; CvCombatMemberEntry::IsValid
; Function compile flags: /Ogtpy
;	COMDAT ?IsValid@CvCombatMemberEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsValid@CvCombatMemberEntry@@QBE_NXZ PROC		; CvCombatMemberEntry::IsValid, COMDAT
; _this$ = ecx

; 45   : 	bool		IsValid() const { return m_ePlayer != NO_PLAYER && m_iID != -1; }

	cmp	DWORD PTR [ecx], -1
	je	SHORT $LN3@IsValid
	cmp	DWORD PTR [ecx+4], -1
	je	SHORT $LN3@IsValid
	mov	eax, 1
	ret	0
$LN3@IsValid:
	xor	eax, eax
	ret	0
?IsValid@CvCombatMemberEntry@@QBE_NXZ ENDP		; CvCombatMemberEntry::IsValid
_TEXT	ENDS
PUBLIC	?GetID@CvCombatMemberEntry@@QBEHXZ		; CvCombatMemberEntry::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvCombatMemberEntry@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvCombatMemberEntry@@QBEHXZ PROC			; CvCombatMemberEntry::GetID, COMDAT
; _this$ = ecx

; 46   : 	int			GetID() const { return m_iID; }

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?GetID@CvCombatMemberEntry@@QBEHXZ ENDP			; CvCombatMemberEntry::GetID
_TEXT	ENDS
PUBLIC	?SetID@CvCombatMemberEntry@@QAEXHW4MEMBER_TYPE@1@@Z ; CvCombatMemberEntry::SetID
; Function compile flags: /Ogtpy
;	COMDAT ?SetID@CvCombatMemberEntry@@QAEXHW4MEMBER_TYPE@1@@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
_eType$ = 12						; size = 4
?SetID@CvCombatMemberEntry@@QAEXHW4MEMBER_TYPE@1@@Z PROC ; CvCombatMemberEntry::SetID, COMDAT
; _this$ = ecx

; 49   : 		m_iID = iID; 
; 50   : 		if (eType == MEMBER_UNIT)

	cmp	DWORD PTR _eType$[esp-4], 0
	mov	eax, DWORD PTR _iID$[esp-4]
	mov	DWORD PTR [ecx+4], eax
	jne	SHORT $LN2@SetID

; 51   : 			m_bfFlags &= ~(uint)INFO_FLAG_IS_CITY; 

	mov	edx, 65534				; 0000fffeH
	and	WORD PTR [ecx+8], dx

; 54   : 	}

	ret	8
$LN2@SetID:

; 52   : 		else
; 53   : 			m_bfFlags |= (uint)INFO_FLAG_IS_CITY; 

	or	WORD PTR [ecx+8], 1

; 54   : 	}

	ret	8
?SetID@CvCombatMemberEntry@@QAEXHW4MEMBER_TYPE@1@@Z ENDP ; CvCombatMemberEntry::SetID
_TEXT	ENDS
PUBLIC	?IsUnit@CvCombatMemberEntry@@QBE_NXZ		; CvCombatMemberEntry::IsUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsUnit@CvCombatMemberEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsUnit@CvCombatMemberEntry@@QBE_NXZ PROC		; CvCombatMemberEntry::IsUnit, COMDAT
; _this$ = ecx

; 56   : 	bool		IsUnit() const { return IsValid() && (m_bfFlags & (uint)INFO_FLAG_IS_CITY) == 0; }

	cmp	DWORD PTR [ecx], -1
	je	SHORT $LN3@IsUnit
	cmp	DWORD PTR [ecx+4], -1
	je	SHORT $LN3@IsUnit
	mov	eax, 1
	test	BYTE PTR [ecx+8], al
	je	SHORT $LN4@IsUnit
$LN3@IsUnit:
	xor	eax, eax
$LN4@IsUnit:
	ret	0
?IsUnit@CvCombatMemberEntry@@QBE_NXZ ENDP		; CvCombatMemberEntry::IsUnit
_TEXT	ENDS
PUBLIC	?GetUnitID@CvCombatMemberEntry@@QBEHXZ		; CvCombatMemberEntry::GetUnitID
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitID@CvCombatMemberEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUnitID@CvCombatMemberEntry@@QBEHXZ PROC		; CvCombatMemberEntry::GetUnitID, COMDAT
; _this$ = ecx

; 57   : 	int			GetUnitID() const { if (IsUnit()) return m_iID; else return -1; }

	cmp	DWORD PTR [ecx], -1
	je	SHORT $LN2@GetUnitID
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, -1
	je	SHORT $LN2@GetUnitID
	test	BYTE PTR [ecx+8], 1
	je	SHORT $LN1@GetUnitID
$LN2@GetUnitID:
	or	eax, -1
$LN1@GetUnitID:
	ret	0
?GetUnitID@CvCombatMemberEntry@@QBEHXZ ENDP		; CvCombatMemberEntry::GetUnitID
_TEXT	ENDS
PUBLIC	?IsCity@CvCombatMemberEntry@@QBE_NXZ		; CvCombatMemberEntry::IsCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsCity@CvCombatMemberEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsCity@CvCombatMemberEntry@@QBE_NXZ PROC		; CvCombatMemberEntry::IsCity, COMDAT
; _this$ = ecx

; 60   : 	bool		IsCity() const { return IsValid() && (m_bfFlags & (uint)INFO_FLAG_IS_CITY) != 0; }

	cmp	DWORD PTR [ecx], -1
	je	SHORT $LN3@IsCity
	cmp	DWORD PTR [ecx+4], -1
	je	SHORT $LN3@IsCity
	mov	eax, 1
	test	BYTE PTR [ecx+8], al
	jne	SHORT $LN4@IsCity
$LN3@IsCity:
	xor	eax, eax
$LN4@IsCity:
	ret	0
?IsCity@CvCombatMemberEntry@@QBE_NXZ ENDP		; CvCombatMemberEntry::IsCity
_TEXT	ENDS
PUBLIC	?GetCityID@CvCombatMemberEntry@@QBEHXZ		; CvCombatMemberEntry::GetCityID
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityID@CvCombatMemberEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityID@CvCombatMemberEntry@@QBEHXZ PROC		; CvCombatMemberEntry::GetCityID, COMDAT
; _this$ = ecx

; 61   : 	int			GetCityID() const { if (IsCity()) return m_iID; else return -1; }

	cmp	DWORD PTR [ecx], -1
	je	SHORT $LN2@GetCityID
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, -1
	je	SHORT $LN2@GetCityID
	test	BYTE PTR [ecx+8], 1
	jne	SHORT $LN1@GetCityID
$LN2@GetCityID:
	or	eax, -1
$LN1@GetCityID:
	ret	0
?GetCityID@CvCombatMemberEntry@@QBEHXZ ENDP		; CvCombatMemberEntry::GetCityID
_TEXT	ENDS
PUBLIC	?IsType@CvCombatMemberEntry@@QBE_NW4MEMBER_TYPE@1@@Z ; CvCombatMemberEntry::IsType
; Function compile flags: /Ogtpy
;	COMDAT ?IsType@CvCombatMemberEntry@@QBE_NW4MEMBER_TYPE@1@@Z
_TEXT	SEGMENT
_eType$ = 8						; size = 4
?IsType@CvCombatMemberEntry@@QBE_NW4MEMBER_TYPE@1@@Z PROC ; CvCombatMemberEntry::IsType, COMDAT
; _this$ = ecx

; 66   : 		if (IsValid())

	cmp	DWORD PTR [ecx], -1
	je	SHORT $LN1@IsType
	cmp	DWORD PTR [ecx+4], -1
	je	SHORT $LN1@IsType

; 67   : 		{
; 68   : 			if ((m_bfFlags & (uint)INFO_FLAG_IS_CITY) != 0)

	mov	eax, 1
	test	BYTE PTR [ecx+8], al
	je	SHORT $LN2@IsType

; 69   : 				return eType == MEMBER_CITY;

	xor	ecx, ecx
	cmp	DWORD PTR _eType$[esp-4], eax
	sete	cl
	mov	al, cl

; 75   : 	}

	ret	4
$LN2@IsType:

; 70   : 			else
; 71   : 				return eType == MEMBER_UNIT;

	xor	eax, eax
	cmp	DWORD PTR _eType$[esp-4], eax
	sete	al

; 75   : 	}

	ret	4
$LN1@IsType:

; 72   : 		}
; 73   : 
; 74   : 		return false;

	xor	al, al

; 75   : 	}

	ret	4
?IsType@CvCombatMemberEntry@@QBE_NW4MEMBER_TYPE@1@@Z ENDP ; CvCombatMemberEntry::IsType
_TEXT	ENDS
PUBLIC	?GetDamage@CvCombatMemberEntry@@QBEHXZ		; CvCombatMemberEntry::GetDamage
; Function compile flags: /Ogtpy
;	COMDAT ?GetDamage@CvCombatMemberEntry@@QBEHXZ
_TEXT	SEGMENT
?GetDamage@CvCombatMemberEntry@@QBEHXZ PROC		; CvCombatMemberEntry::GetDamage, COMDAT
; _this$ = ecx

; 76   : 	int			GetDamage() const { return (int)m_iDamage; }

	movsx	eax, WORD PTR [ecx+10]
	ret	0
?GetDamage@CvCombatMemberEntry@@QBEHXZ ENDP		; CvCombatMemberEntry::GetDamage
_TEXT	ENDS
PUBLIC	?SetDamage@CvCombatMemberEntry@@QAEXH@Z		; CvCombatMemberEntry::SetDamage
; Function compile flags: /Ogtpy
;	COMDAT ?SetDamage@CvCombatMemberEntry@@QAEXH@Z
_TEXT	SEGMENT
_iDamage$ = 8						; size = 4
?SetDamage@CvCombatMemberEntry@@QAEXH@Z PROC		; CvCombatMemberEntry::SetDamage, COMDAT
; _this$ = ecx

; 77   : 	void		SetDamage(int iDamage) { m_iDamage = (int16)iDamage; }

	mov	ax, WORD PTR _iDamage$[esp-4]
	mov	WORD PTR [ecx+10], ax
	ret	4
?SetDamage@CvCombatMemberEntry@@QAEXH@Z ENDP		; CvCombatMemberEntry::SetDamage
_TEXT	ENDS
PUBLIC	?GetFinalDamage@CvCombatMemberEntry@@QBEHXZ	; CvCombatMemberEntry::GetFinalDamage
; Function compile flags: /Ogtpy
;	COMDAT ?GetFinalDamage@CvCombatMemberEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFinalDamage@CvCombatMemberEntry@@QBEHXZ PROC	; CvCombatMemberEntry::GetFinalDamage, COMDAT
; _this$ = ecx

; 79   : 	int			GetFinalDamage() const { return (int)m_iFinalDamage; }

	movsx	eax, WORD PTR [ecx+12]
	ret	0
?GetFinalDamage@CvCombatMemberEntry@@QBEHXZ ENDP	; CvCombatMemberEntry::GetFinalDamage
_TEXT	ENDS
PUBLIC	?SetFinalDamage@CvCombatMemberEntry@@QAEXH@Z	; CvCombatMemberEntry::SetFinalDamage
; Function compile flags: /Ogtpy
;	COMDAT ?SetFinalDamage@CvCombatMemberEntry@@QAEXH@Z
_TEXT	SEGMENT
_iFinalDamage$ = 8					; size = 4
?SetFinalDamage@CvCombatMemberEntry@@QAEXH@Z PROC	; CvCombatMemberEntry::SetFinalDamage, COMDAT
; _this$ = ecx

; 80   : 	void		SetFinalDamage(int iFinalDamage) { m_iFinalDamage = (int16)iFinalDamage; }

	mov	ax, WORD PTR _iFinalDamage$[esp-4]
	mov	WORD PTR [ecx+12], ax
	ret	4
?SetFinalDamage@CvCombatMemberEntry@@QAEXH@Z ENDP	; CvCombatMemberEntry::SetFinalDamage
_TEXT	ENDS
PUBLIC	?SetMaxHitPoints@CvCombatMemberEntry@@QAEXH@Z	; CvCombatMemberEntry::SetMaxHitPoints
; Function compile flags: /Ogtpy
;	COMDAT ?SetMaxHitPoints@CvCombatMemberEntry@@QAEXH@Z
_TEXT	SEGMENT
_iMaxHitPoints$ = 8					; size = 4
?SetMaxHitPoints@CvCombatMemberEntry@@QAEXH@Z PROC	; CvCombatMemberEntry::SetMaxHitPoints, COMDAT
; _this$ = ecx

; 83   : 	void		SetMaxHitPoints(int iMaxHitPoints) { m_iMaxHitPoints = (int16)iMaxHitPoints; }

	mov	ax, WORD PTR _iMaxHitPoints$[esp-4]
	mov	WORD PTR [ecx+14], ax
	ret	4
?SetMaxHitPoints@CvCombatMemberEntry@@QAEXH@Z ENDP	; CvCombatMemberEntry::SetMaxHitPoints
_TEXT	ENDS
PUBLIC	?SetEra@CvCombatMemberEntry@@QAEXW4EraTypes@@@Z	; CvCombatMemberEntry::SetEra
; Function compile flags: /Ogtpy
;	COMDAT ?SetEra@CvCombatMemberEntry@@QAEXW4EraTypes@@@Z
_TEXT	SEGMENT
_eEra$ = 8						; size = 4
?SetEra@CvCombatMemberEntry@@QAEXW4EraTypes@@@Z PROC	; CvCombatMemberEntry::SetEra, COMDAT
; _this$ = ecx

; 89   : 	void		SetEra(EraTypes eEra) { m_eEra = eEra; }

	mov	eax, DWORD PTR _eEra$[esp-4]
	mov	DWORD PTR [ecx+24], eax
	ret	4
?SetEra@CvCombatMemberEntry@@QAEXW4EraTypes@@@Z ENDP	; CvCombatMemberEntry::SetEra
_TEXT	ENDS
PUBLIC	?SetPlot@CvCombatMemberEntry@@QAEXHH@Z		; CvCombatMemberEntry::SetPlot
; Function compile flags: /Ogtpy
;	COMDAT ?SetPlot@CvCombatMemberEntry@@QAEXHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?SetPlot@CvCombatMemberEntry@@QAEXHH@Z PROC		; CvCombatMemberEntry::SetPlot, COMDAT
; _this$ = ecx

; 93   : 	void		SetPlot(int32 iX, int32 iY) { m_iX = (int16)iX; m_iY = (int16)iY; }

	mov	ax, WORD PTR _iX$[esp-4]
	mov	dx, WORD PTR _iY$[esp-4]
	mov	WORD PTR [ecx+16], ax
	mov	WORD PTR [ecx+18], dx
	ret	8
?SetPlot@CvCombatMemberEntry@@QAEXHH@Z ENDP		; CvCombatMemberEntry::SetPlot
_TEXT	ENDS
PUBLIC	??0CvCombatMemberEntry@@QAE@XZ			; CvCombatMemberEntry::CvCombatMemberEntry
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
;	COMDAT ??0CvCombatMemberEntry@@QAE@XZ
_TEXT	SEGMENT
??0CvCombatMemberEntry@@QAE@XZ PROC			; CvCombatMemberEntry::CvCombatMemberEntry, COMDAT
; _this$ = ecx

; 101  : 	CvCombatMemberEntry() : m_ePlayer(NO_PLAYER), m_iID(-1), m_bfFlags(0), m_iDamage(0), m_iFinalDamage(0), m_iMaxHitPoints(0), m_eCombatType(NO_UNITCOMBAT), m_eEra(NO_ERA), m_iX(0), m_iY(0), m_uiWeaponType(0), m_fWeaponOption(0.f) {}

	mov	eax, ecx
	or	ecx, -1
	xor	edx, edx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	xor	ecx, ecx
	mov	WORD PTR [eax+8], dx
	mov	WORD PTR [eax+10], dx
	mov	WORD PTR [eax+12], dx
	mov	WORD PTR [eax+14], dx
	mov	WORD PTR [eax+16], dx
	mov	WORD PTR [eax+18], dx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], ecx
	ret	0
??0CvCombatMemberEntry@@QAE@XZ ENDP			; CvCombatMemberEntry::CvCombatMemberEntry
_TEXT	ENDS
PUBLIC	??3ICvUnknown@@SGXPAX@Z				; ICvUnknown::operator delete
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
;	COMDAT ??3ICvUnknown@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3ICvUnknown@@SGXPAX@Z PROC				; ICvUnknown::operator delete, COMDAT

; 310  : 		if (p)

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN1@operator@2

; 311  : 		{
; 312  : 			ICvUnknown* inst = (ICvUnknown*)(p);
; 313  : 			inst->Destroy();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _p$[esp-4], eax
	jmp	edx
$LN1@operator@2:

; 314  : 		}
; 315  : 	}

	ret	4
??3ICvUnknown@@SGXPAX@Z ENDP				; ICvUnknown::operator delete
_TEXT	ENDS
PUBLIC	??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::operator->
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
;	COMDAT ??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::operator->, COMDAT
; _this$ = ecx

; 40   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 41   : }

	ret	0
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::operator->
_TEXT	ENDS
PUBLIC	?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::get, COMDAT
; _this$ = ecx

; 45   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 46   : }

	ret	0
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::get
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getPlotDirectionX@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionX
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionX@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionX@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionX, COMDAT
; _this$ = ecx

; 191  : 		return m_aiPlotDirectionX;

	lea	eax, DWORD PTR [ecx+112]

; 192  : 	}

	ret	0
?getPlotDirectionX@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionX
_TEXT	ENDS
PUBLIC	?getPlotDirectionY@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionY
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionY@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionY@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionY, COMDAT
; _this$ = ecx

; 195  : 		return m_aiPlotDirectionY;

	lea	eax, DWORD PTR [ecx+136]

; 196  : 	}

	ret	0
?getPlotDirectionY@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionY
_TEXT	ENDS
PUBLIC	?getEVENT_MESSAGE_TIME@CvGlobals@@QAEHXZ	; CvGlobals::getEVENT_MESSAGE_TIME
; Function compile flags: /Ogtpy
;	COMDAT ?getEVENT_MESSAGE_TIME@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getEVENT_MESSAGE_TIME@CvGlobals@@QAEHXZ PROC		; CvGlobals::getEVENT_MESSAGE_TIME, COMDAT
; _this$ = ecx

; 5252 : 		return m_iEVENT_MESSAGE_TIME;

	mov	eax, DWORD PTR [ecx+6176]

; 5253 : 	}

	ret	0
?getEVENT_MESSAGE_TIME@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getEVENT_MESSAGE_TIME
_TEXT	ENDS
PUBLIC	?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ		; CvGlobals::getMOVE_DENOMINATOR
; Function compile flags: /Ogtpy
;	COMDAT ?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ PROC		; CvGlobals::getMOVE_DENOMINATOR, COMDAT
; _this$ = ecx

; 5312 : 		return m_iMOVE_DENOMINATOR;

	mov	eax, DWORD PTR [ecx+6236]

; 5313 : 	}

	ret	0
?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getMOVE_DENOMINATOR
_TEXT	ENDS
PUBLIC	?getNUKE_FALLOUT_PROB@CvGlobals@@QAEHXZ		; CvGlobals::getNUKE_FALLOUT_PROB
; Function compile flags: /Ogtpy
;	COMDAT ?getNUKE_FALLOUT_PROB@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUKE_FALLOUT_PROB@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNUKE_FALLOUT_PROB, COMDAT
; _this$ = ecx

; 5696 : 		return m_iNUKE_FALLOUT_PROB;

	mov	eax, DWORD PTR [ecx+6620]

; 5697 : 	}

	ret	0
?getNUKE_FALLOUT_PROB@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNUKE_FALLOUT_PROB
_TEXT	ENDS
PUBLIC	?getNUKE_UNIT_DAMAGE_BASE@CvGlobals@@QAEHXZ	; CvGlobals::getNUKE_UNIT_DAMAGE_BASE
; Function compile flags: /Ogtpy
;	COMDAT ?getNUKE_UNIT_DAMAGE_BASE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUKE_UNIT_DAMAGE_BASE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNUKE_UNIT_DAMAGE_BASE, COMDAT
; _this$ = ecx

; 5700 : 		return m_iNUKE_UNIT_DAMAGE_BASE;

	mov	eax, DWORD PTR [ecx+6624]

; 5701 : 	}

	ret	0
?getNUKE_UNIT_DAMAGE_BASE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNUKE_UNIT_DAMAGE_BASE
_TEXT	ENDS
PUBLIC	?getNUKE_UNIT_DAMAGE_RAND_1@CvGlobals@@QAEHXZ	; CvGlobals::getNUKE_UNIT_DAMAGE_RAND_1
; Function compile flags: /Ogtpy
;	COMDAT ?getNUKE_UNIT_DAMAGE_RAND_1@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUKE_UNIT_DAMAGE_RAND_1@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNUKE_UNIT_DAMAGE_RAND_1, COMDAT
; _this$ = ecx

; 5704 : 		return m_iNUKE_UNIT_DAMAGE_RAND_1;

	mov	eax, DWORD PTR [ecx+6628]

; 5705 : 	}

	ret	0
?getNUKE_UNIT_DAMAGE_RAND_1@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNUKE_UNIT_DAMAGE_RAND_1
_TEXT	ENDS
PUBLIC	?getNUKE_UNIT_DAMAGE_RAND_2@CvGlobals@@QAEHXZ	; CvGlobals::getNUKE_UNIT_DAMAGE_RAND_2
; Function compile flags: /Ogtpy
;	COMDAT ?getNUKE_UNIT_DAMAGE_RAND_2@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUKE_UNIT_DAMAGE_RAND_2@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNUKE_UNIT_DAMAGE_RAND_2, COMDAT
; _this$ = ecx

; 5708 : 		return m_iNUKE_UNIT_DAMAGE_RAND_2;

	mov	eax, DWORD PTR [ecx+6632]

; 5709 : 	}

	ret	0
?getNUKE_UNIT_DAMAGE_RAND_2@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNUKE_UNIT_DAMAGE_RAND_2
_TEXT	ENDS
PUBLIC	?getNUKE_NON_COMBAT_DEATH_THRESHOLD@CvGlobals@@QAEHXZ ; CvGlobals::getNUKE_NON_COMBAT_DEATH_THRESHOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getNUKE_NON_COMBAT_DEATH_THRESHOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUKE_NON_COMBAT_DEATH_THRESHOLD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getNUKE_NON_COMBAT_DEATH_THRESHOLD, COMDAT
; _this$ = ecx

; 5712 : 		return m_iNUKE_NON_COMBAT_DEATH_THRESHOLD;

	mov	eax, DWORD PTR [ecx+6636]

; 5713 : 	}

	ret	0
?getNUKE_NON_COMBAT_DEATH_THRESHOLD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getNUKE_NON_COMBAT_DEATH_THRESHOLD
_TEXT	ENDS
PUBLIC	?getNUKE_LEVEL1_POPULATION_DEATH_BASE@CvGlobals@@QAEHXZ ; CvGlobals::getNUKE_LEVEL1_POPULATION_DEATH_BASE
; Function compile flags: /Ogtpy
;	COMDAT ?getNUKE_LEVEL1_POPULATION_DEATH_BASE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUKE_LEVEL1_POPULATION_DEATH_BASE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getNUKE_LEVEL1_POPULATION_DEATH_BASE, COMDAT
; _this$ = ecx

; 5716 : 		return m_iNUKE_LEVEL1_POPULATION_DEATH_BASE;

	mov	eax, DWORD PTR [ecx+6640]

; 5717 : 	}

	ret	0
?getNUKE_LEVEL1_POPULATION_DEATH_BASE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getNUKE_LEVEL1_POPULATION_DEATH_BASE
_TEXT	ENDS
PUBLIC	?getNUKE_LEVEL1_POPULATION_DEATH_RAND_1@CvGlobals@@QAEHXZ ; CvGlobals::getNUKE_LEVEL1_POPULATION_DEATH_RAND_1
; Function compile flags: /Ogtpy
;	COMDAT ?getNUKE_LEVEL1_POPULATION_DEATH_RAND_1@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUKE_LEVEL1_POPULATION_DEATH_RAND_1@CvGlobals@@QAEHXZ PROC ; CvGlobals::getNUKE_LEVEL1_POPULATION_DEATH_RAND_1, COMDAT
; _this$ = ecx

; 5720 : 		return m_iNUKE_LEVEL1_POPULATION_DEATH_RAND_1;

	mov	eax, DWORD PTR [ecx+6644]

; 5721 : 	}

	ret	0
?getNUKE_LEVEL1_POPULATION_DEATH_RAND_1@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getNUKE_LEVEL1_POPULATION_DEATH_RAND_1
_TEXT	ENDS
PUBLIC	?getNUKE_LEVEL1_POPULATION_DEATH_RAND_2@CvGlobals@@QAEHXZ ; CvGlobals::getNUKE_LEVEL1_POPULATION_DEATH_RAND_2
; Function compile flags: /Ogtpy
;	COMDAT ?getNUKE_LEVEL1_POPULATION_DEATH_RAND_2@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUKE_LEVEL1_POPULATION_DEATH_RAND_2@CvGlobals@@QAEHXZ PROC ; CvGlobals::getNUKE_LEVEL1_POPULATION_DEATH_RAND_2, COMDAT
; _this$ = ecx

; 5724 : 		return m_iNUKE_LEVEL1_POPULATION_DEATH_RAND_2;

	mov	eax, DWORD PTR [ecx+6648]

; 5725 : 	}

	ret	0
?getNUKE_LEVEL1_POPULATION_DEATH_RAND_2@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getNUKE_LEVEL1_POPULATION_DEATH_RAND_2
_TEXT	ENDS
PUBLIC	?getNUKE_LEVEL2_POPULATION_DEATH_BASE@CvGlobals@@QAEHXZ ; CvGlobals::getNUKE_LEVEL2_POPULATION_DEATH_BASE
; Function compile flags: /Ogtpy
;	COMDAT ?getNUKE_LEVEL2_POPULATION_DEATH_BASE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUKE_LEVEL2_POPULATION_DEATH_BASE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getNUKE_LEVEL2_POPULATION_DEATH_BASE, COMDAT
; _this$ = ecx

; 5728 : 		return m_iNUKE_LEVEL2_POPULATION_DEATH_BASE;

	mov	eax, DWORD PTR [ecx+6652]

; 5729 : 	}

	ret	0
?getNUKE_LEVEL2_POPULATION_DEATH_BASE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getNUKE_LEVEL2_POPULATION_DEATH_BASE
_TEXT	ENDS
PUBLIC	?getNUKE_LEVEL2_POPULATION_DEATH_RAND_1@CvGlobals@@QAEHXZ ; CvGlobals::getNUKE_LEVEL2_POPULATION_DEATH_RAND_1
; Function compile flags: /Ogtpy
;	COMDAT ?getNUKE_LEVEL2_POPULATION_DEATH_RAND_1@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUKE_LEVEL2_POPULATION_DEATH_RAND_1@CvGlobals@@QAEHXZ PROC ; CvGlobals::getNUKE_LEVEL2_POPULATION_DEATH_RAND_1, COMDAT
; _this$ = ecx

; 5732 : 		return m_iNUKE_LEVEL2_POPULATION_DEATH_RAND_1;

	mov	eax, DWORD PTR [ecx+6656]

; 5733 : 	}

	ret	0
?getNUKE_LEVEL2_POPULATION_DEATH_RAND_1@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getNUKE_LEVEL2_POPULATION_DEATH_RAND_1
_TEXT	ENDS
PUBLIC	?getNUKE_LEVEL2_POPULATION_DEATH_RAND_2@CvGlobals@@QAEHXZ ; CvGlobals::getNUKE_LEVEL2_POPULATION_DEATH_RAND_2
; Function compile flags: /Ogtpy
;	COMDAT ?getNUKE_LEVEL2_POPULATION_DEATH_RAND_2@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUKE_LEVEL2_POPULATION_DEATH_RAND_2@CvGlobals@@QAEHXZ PROC ; CvGlobals::getNUKE_LEVEL2_POPULATION_DEATH_RAND_2, COMDAT
; _this$ = ecx

; 5736 : 		return m_iNUKE_LEVEL2_POPULATION_DEATH_RAND_2;

	mov	eax, DWORD PTR [ecx+6660]

; 5737 : 	}

	ret	0
?getNUKE_LEVEL2_POPULATION_DEATH_RAND_2@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getNUKE_LEVEL2_POPULATION_DEATH_RAND_2
_TEXT	ENDS
PUBLIC	?getNUKE_LEVEL2_ELIM_POPULATION_THRESHOLD@CvGlobals@@QAEHXZ ; CvGlobals::getNUKE_LEVEL2_ELIM_POPULATION_THRESHOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getNUKE_LEVEL2_ELIM_POPULATION_THRESHOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUKE_LEVEL2_ELIM_POPULATION_THRESHOLD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getNUKE_LEVEL2_ELIM_POPULATION_THRESHOLD, COMDAT
; _this$ = ecx

; 5740 : 		return m_iNUKE_LEVEL2_ELIM_POPULATION_THRESHOLD;

	mov	eax, DWORD PTR [ecx+6664]

; 5741 : 	}

	ret	0
?getNUKE_LEVEL2_ELIM_POPULATION_THRESHOLD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getNUKE_LEVEL2_ELIM_POPULATION_THRESHOLD
_TEXT	ENDS
PUBLIC	?getNUKE_CITY_HIT_POINT_DAMAGE@CvGlobals@@QAEHXZ ; CvGlobals::getNUKE_CITY_HIT_POINT_DAMAGE
; Function compile flags: /Ogtpy
;	COMDAT ?getNUKE_CITY_HIT_POINT_DAMAGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUKE_CITY_HIT_POINT_DAMAGE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNUKE_CITY_HIT_POINT_DAMAGE, COMDAT
; _this$ = ecx

; 5744 : 		return m_iNUKE_CITY_HIT_POINT_DAMAGE;

	mov	eax, DWORD PTR [ecx+6668]

; 5745 : 	}

	ret	0
?getNUKE_CITY_HIT_POINT_DAMAGE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNUKE_CITY_HIT_POINT_DAMAGE
_TEXT	ENDS
PUBLIC	?getNUKE_BLAST_RADIUS@CvGlobals@@QAEHXZ		; CvGlobals::getNUKE_BLAST_RADIUS
; Function compile flags: /Ogtpy
;	COMDAT ?getNUKE_BLAST_RADIUS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUKE_BLAST_RADIUS@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNUKE_BLAST_RADIUS, COMDAT
; _this$ = ecx

; 5748 : 		return m_iNUKE_BLAST_RADIUS;

	mov	eax, DWORD PTR [ecx+6672]

; 5749 : 	}

	ret	0
?getNUKE_BLAST_RADIUS@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNUKE_BLAST_RADIUS
_TEXT	ENDS
PUBLIC	?getRANGED_ATTACKS_USE_MOVES@CvGlobals@@QAEHXZ	; CvGlobals::getRANGED_ATTACKS_USE_MOVES
; Function compile flags: /Ogtpy
;	COMDAT ?getRANGED_ATTACKS_USE_MOVES@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getRANGED_ATTACKS_USE_MOVES@CvGlobals@@QAEHXZ PROC	; CvGlobals::getRANGED_ATTACKS_USE_MOVES, COMDAT
; _this$ = ecx

; 5976 : 		return m_iRANGED_ATTACKS_USE_MOVES;

	mov	eax, DWORD PTR [ecx+6900]

; 5977 : 	}

	ret	0
?getRANGED_ATTACKS_USE_MOVES@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getRANGED_ATTACKS_USE_MOVES
_TEXT	ENDS
PUBLIC	?getBARBARIAN_CITY_GOLD_RANSOM@CvGlobals@@QAEHXZ ; CvGlobals::getBARBARIAN_CITY_GOLD_RANSOM
; Function compile flags: /Ogtpy
;	COMDAT ?getBARBARIAN_CITY_GOLD_RANSOM@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBARBARIAN_CITY_GOLD_RANSOM@CvGlobals@@QAEHXZ PROC	; CvGlobals::getBARBARIAN_CITY_GOLD_RANSOM, COMDAT
; _this$ = ecx

; 6148 : 		return m_iBARBARIAN_CITY_GOLD_RANSOM;

	mov	eax, DWORD PTR [ecx+7072]

; 6149 : 	}

	ret	0
?getBARBARIAN_CITY_GOLD_RANSOM@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getBARBARIAN_CITY_GOLD_RANSOM
_TEXT	ENDS
PUBLIC	?getFIRE_SUPPORT_DISABLED@CvGlobals@@QAEHXZ	; CvGlobals::getFIRE_SUPPORT_DISABLED
; Function compile flags: /Ogtpy
;	COMDAT ?getFIRE_SUPPORT_DISABLED@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFIRE_SUPPORT_DISABLED@CvGlobals@@QAEHXZ PROC	; CvGlobals::getFIRE_SUPPORT_DISABLED, COMDAT
; _this$ = ecx

; 6493 : 		return m_iFIRE_SUPPORT_DISABLED;

	mov	eax, DWORD PTR [ecx+7364]

; 6494 : 	}

	ret	0
?getFIRE_SUPPORT_DISABLED@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getFIRE_SUPPORT_DISABLED
_TEXT	ENDS
PUBLIC	?getMAX_HIT_POINTS@CvGlobals@@QAEHXZ		; CvGlobals::getMAX_HIT_POINTS
; Function compile flags: /Ogtpy
;	COMDAT ?getMAX_HIT_POINTS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMAX_HIT_POINTS@CvGlobals@@QAEHXZ PROC		; CvGlobals::getMAX_HIT_POINTS, COMDAT
; _this$ = ecx

; 6497 : 		return m_iMAX_HIT_POINTS;

	mov	eax, DWORD PTR [ecx+7368]

; 6498 : 	}

	ret	0
?getMAX_HIT_POINTS@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getMAX_HIT_POINTS
_TEXT	ENDS
PUBLIC	?getAIR_SWEEP_INTERCEPTION_DAMAGE_MOD@CvGlobals@@QAEHXZ ; CvGlobals::getAIR_SWEEP_INTERCEPTION_DAMAGE_MOD
; Function compile flags: /Ogtpy
;	COMDAT ?getAIR_SWEEP_INTERCEPTION_DAMAGE_MOD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAIR_SWEEP_INTERCEPTION_DAMAGE_MOD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAIR_SWEEP_INTERCEPTION_DAMAGE_MOD, COMDAT
; _this$ = ecx

; 6581 : 		return m_iAIR_SWEEP_INTERCEPTION_DAMAGE_MOD;

	mov	eax, DWORD PTR [ecx+7452]

; 6582 : 	}

	ret	0
?getAIR_SWEEP_INTERCEPTION_DAMAGE_MOD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAIR_SWEEP_INTERCEPTION_DAMAGE_MOD
_TEXT	ENDS
PUBLIC	?getEXPERIENCE_ATTACKING_UNIT_MELEE@CvGlobals@@QAEHXZ ; CvGlobals::getEXPERIENCE_ATTACKING_UNIT_MELEE
; Function compile flags: /Ogtpy
;	COMDAT ?getEXPERIENCE_ATTACKING_UNIT_MELEE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getEXPERIENCE_ATTACKING_UNIT_MELEE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getEXPERIENCE_ATTACKING_UNIT_MELEE, COMDAT
; _this$ = ecx

; 6641 : 		return m_iEXPERIENCE_ATTACKING_UNIT_MELEE;

	mov	eax, DWORD PTR [ecx+7512]

; 6642 : 	}

	ret	0
?getEXPERIENCE_ATTACKING_UNIT_MELEE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getEXPERIENCE_ATTACKING_UNIT_MELEE
_TEXT	ENDS
PUBLIC	?getEXPERIENCE_DEFENDING_UNIT_MELEE@CvGlobals@@QAEHXZ ; CvGlobals::getEXPERIENCE_DEFENDING_UNIT_MELEE
; Function compile flags: /Ogtpy
;	COMDAT ?getEXPERIENCE_DEFENDING_UNIT_MELEE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getEXPERIENCE_DEFENDING_UNIT_MELEE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getEXPERIENCE_DEFENDING_UNIT_MELEE, COMDAT
; _this$ = ecx

; 6645 : 		return m_iEXPERIENCE_DEFENDING_UNIT_MELEE;

	mov	eax, DWORD PTR [ecx+7516]

; 6646 : 	}

	ret	0
?getEXPERIENCE_DEFENDING_UNIT_MELEE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getEXPERIENCE_DEFENDING_UNIT_MELEE
_TEXT	ENDS
PUBLIC	?getEXPERIENCE_ATTACKING_UNIT_AIR@CvGlobals@@QAEHXZ ; CvGlobals::getEXPERIENCE_ATTACKING_UNIT_AIR
; Function compile flags: /Ogtpy
;	COMDAT ?getEXPERIENCE_ATTACKING_UNIT_AIR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getEXPERIENCE_ATTACKING_UNIT_AIR@CvGlobals@@QAEHXZ PROC ; CvGlobals::getEXPERIENCE_ATTACKING_UNIT_AIR, COMDAT
; _this$ = ecx

; 6649 : 		return m_iEXPERIENCE_ATTACKING_UNIT_AIR;

	mov	eax, DWORD PTR [ecx+7520]

; 6650 : 	}

	ret	0
?getEXPERIENCE_ATTACKING_UNIT_AIR@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getEXPERIENCE_ATTACKING_UNIT_AIR
_TEXT	ENDS
PUBLIC	?getEXPERIENCE_DEFENDING_UNIT_AIR@CvGlobals@@QAEHXZ ; CvGlobals::getEXPERIENCE_DEFENDING_UNIT_AIR
; Function compile flags: /Ogtpy
;	COMDAT ?getEXPERIENCE_DEFENDING_UNIT_AIR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getEXPERIENCE_DEFENDING_UNIT_AIR@CvGlobals@@QAEHXZ PROC ; CvGlobals::getEXPERIENCE_DEFENDING_UNIT_AIR, COMDAT
; _this$ = ecx

; 6653 : 		return m_iEXPERIENCE_DEFENDING_UNIT_AIR;

	mov	eax, DWORD PTR [ecx+7524]

; 6654 : 	}

	ret	0
?getEXPERIENCE_DEFENDING_UNIT_AIR@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getEXPERIENCE_DEFENDING_UNIT_AIR
_TEXT	ENDS
PUBLIC	?getEXPERIENCE_ATTACKING_UNIT_RANGED@CvGlobals@@QAEHXZ ; CvGlobals::getEXPERIENCE_ATTACKING_UNIT_RANGED
; Function compile flags: /Ogtpy
;	COMDAT ?getEXPERIENCE_ATTACKING_UNIT_RANGED@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getEXPERIENCE_ATTACKING_UNIT_RANGED@CvGlobals@@QAEHXZ PROC ; CvGlobals::getEXPERIENCE_ATTACKING_UNIT_RANGED, COMDAT
; _this$ = ecx

; 6657 : 		return m_iEXPERIENCE_ATTACKING_UNIT_RANGED;

	mov	eax, DWORD PTR [ecx+7528]

; 6658 : 	}

	ret	0
?getEXPERIENCE_ATTACKING_UNIT_RANGED@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getEXPERIENCE_ATTACKING_UNIT_RANGED
_TEXT	ENDS
PUBLIC	?getEXPERIENCE_DEFENDING_UNIT_RANGED@CvGlobals@@QAEHXZ ; CvGlobals::getEXPERIENCE_DEFENDING_UNIT_RANGED
; Function compile flags: /Ogtpy
;	COMDAT ?getEXPERIENCE_DEFENDING_UNIT_RANGED@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getEXPERIENCE_DEFENDING_UNIT_RANGED@CvGlobals@@QAEHXZ PROC ; CvGlobals::getEXPERIENCE_DEFENDING_UNIT_RANGED, COMDAT
; _this$ = ecx

; 6661 : 		return m_iEXPERIENCE_DEFENDING_UNIT_RANGED;

	mov	eax, DWORD PTR [ecx+7532]

; 6662 : 	}

	ret	0
?getEXPERIENCE_DEFENDING_UNIT_RANGED@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getEXPERIENCE_DEFENDING_UNIT_RANGED
_TEXT	ENDS
PUBLIC	?getEXPERIENCE_ATTACKING_AIR_SWEEP@CvGlobals@@QAEHXZ ; CvGlobals::getEXPERIENCE_ATTACKING_AIR_SWEEP
; Function compile flags: /Ogtpy
;	COMDAT ?getEXPERIENCE_ATTACKING_AIR_SWEEP@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getEXPERIENCE_ATTACKING_AIR_SWEEP@CvGlobals@@QAEHXZ PROC ; CvGlobals::getEXPERIENCE_ATTACKING_AIR_SWEEP, COMDAT
; _this$ = ecx

; 6665 : 		return m_iEXPERIENCE_ATTACKING_AIR_SWEEP;

	mov	eax, DWORD PTR [ecx+7536]

; 6666 : 	}

	ret	0
?getEXPERIENCE_ATTACKING_AIR_SWEEP@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getEXPERIENCE_ATTACKING_AIR_SWEEP
_TEXT	ENDS
PUBLIC	?getEXPERIENCE_DEFENDING_AIR_SWEEP_AIR@CvGlobals@@QAEHXZ ; CvGlobals::getEXPERIENCE_DEFENDING_AIR_SWEEP_AIR
; Function compile flags: /Ogtpy
;	COMDAT ?getEXPERIENCE_DEFENDING_AIR_SWEEP_AIR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getEXPERIENCE_DEFENDING_AIR_SWEEP_AIR@CvGlobals@@QAEHXZ PROC ; CvGlobals::getEXPERIENCE_DEFENDING_AIR_SWEEP_AIR, COMDAT
; _this$ = ecx

; 6669 : 		return m_iEXPERIENCE_DEFENDING_AIR_SWEEP_AIR;

	mov	eax, DWORD PTR [ecx+7540]

; 6670 : 	}

	ret	0
?getEXPERIENCE_DEFENDING_AIR_SWEEP_AIR@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getEXPERIENCE_DEFENDING_AIR_SWEEP_AIR
_TEXT	ENDS
PUBLIC	?getEXPERIENCE_DEFENDING_AIR_SWEEP_GROUND@CvGlobals@@QAEHXZ ; CvGlobals::getEXPERIENCE_DEFENDING_AIR_SWEEP_GROUND
; Function compile flags: /Ogtpy
;	COMDAT ?getEXPERIENCE_DEFENDING_AIR_SWEEP_GROUND@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getEXPERIENCE_DEFENDING_AIR_SWEEP_GROUND@CvGlobals@@QAEHXZ PROC ; CvGlobals::getEXPERIENCE_DEFENDING_AIR_SWEEP_GROUND, COMDAT
; _this$ = ecx

; 6673 : 		return m_iEXPERIENCE_DEFENDING_AIR_SWEEP_GROUND;

	mov	eax, DWORD PTR [ecx+7544]

; 6674 : 	}

	ret	0
?getEXPERIENCE_DEFENDING_AIR_SWEEP_GROUND@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getEXPERIENCE_DEFENDING_AIR_SWEEP_GROUND
_TEXT	ENDS
PUBLIC	?getEXPERIENCE_ATTACKING_CITY_MELEE@CvGlobals@@QAEHXZ ; CvGlobals::getEXPERIENCE_ATTACKING_CITY_MELEE
; Function compile flags: /Ogtpy
;	COMDAT ?getEXPERIENCE_ATTACKING_CITY_MELEE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getEXPERIENCE_ATTACKING_CITY_MELEE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getEXPERIENCE_ATTACKING_CITY_MELEE, COMDAT
; _this$ = ecx

; 6677 : 		return m_iEXPERIENCE_ATTACKING_CITY_MELEE;

	mov	eax, DWORD PTR [ecx+7548]

; 6678 : 	}

	ret	0
?getEXPERIENCE_ATTACKING_CITY_MELEE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getEXPERIENCE_ATTACKING_CITY_MELEE
_TEXT	ENDS
PUBLIC	?getEXPERIENCE_ATTACKING_CITY_RANGED@CvGlobals@@QAEHXZ ; CvGlobals::getEXPERIENCE_ATTACKING_CITY_RANGED
; Function compile flags: /Ogtpy
;	COMDAT ?getEXPERIENCE_ATTACKING_CITY_RANGED@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getEXPERIENCE_ATTACKING_CITY_RANGED@CvGlobals@@QAEHXZ PROC ; CvGlobals::getEXPERIENCE_ATTACKING_CITY_RANGED, COMDAT
; _this$ = ecx

; 6681 : 		return m_iEXPERIENCE_ATTACKING_CITY_RANGED;

	mov	eax, DWORD PTR [ecx+7552]

; 6682 : 	}

	ret	0
?getEXPERIENCE_ATTACKING_CITY_RANGED@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getEXPERIENCE_ATTACKING_CITY_RANGED
_TEXT	ENDS
PUBLIC	?getEXPERIENCE_ATTACKING_CITY_AIR@CvGlobals@@QAEHXZ ; CvGlobals::getEXPERIENCE_ATTACKING_CITY_AIR
; Function compile flags: /Ogtpy
;	COMDAT ?getEXPERIENCE_ATTACKING_CITY_AIR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getEXPERIENCE_ATTACKING_CITY_AIR@CvGlobals@@QAEHXZ PROC ; CvGlobals::getEXPERIENCE_ATTACKING_CITY_AIR, COMDAT
; _this$ = ecx

; 6685 : 		return m_iEXPERIENCE_ATTACKING_CITY_AIR;

	mov	eax, DWORD PTR [ecx+7556]

; 6686 : 	}

	ret	0
?getEXPERIENCE_ATTACKING_CITY_AIR@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getEXPERIENCE_ATTACKING_CITY_AIR
_TEXT	ENDS
PUBLIC	?getPOST_COMBAT_TEXT_DELAY@CvGlobals@@QAEMXZ	; CvGlobals::getPOST_COMBAT_TEXT_DELAY
; Function compile flags: /Ogtpy
;	COMDAT ?getPOST_COMBAT_TEXT_DELAY@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getPOST_COMBAT_TEXT_DELAY@CvGlobals@@QAEMXZ PROC	; CvGlobals::getPOST_COMBAT_TEXT_DELAY, COMDAT
; _this$ = ecx

; 7052 : 		return m_fPOST_COMBAT_TEXT_DELAY;

	fld	DWORD PTR [ecx+8040]

; 7053 : 	}

	ret	0
?getPOST_COMBAT_TEXT_DELAY@CvGlobals@@QAEMXZ ENDP	; CvGlobals::getPOST_COMBAT_TEXT_DELAY
_TEXT	ENDS
PUBLIC	?getNUKE_FEATURE@CvGlobals@@QAEHXZ		; CvGlobals::getNUKE_FEATURE
; Function compile flags: /Ogtpy
;	COMDAT ?getNUKE_FEATURE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUKE_FEATURE@CvGlobals@@QAEHXZ PROC			; CvGlobals::getNUKE_FEATURE, COMDAT
; _this$ = ecx

; 7187 : 		return m_iNUKE_FEATURE;

	mov	eax, DWORD PTR [ecx+8404]

; 7188 : 	}

	ret	0
?getNUKE_FEATURE@CvGlobals@@QAEHXZ ENDP			; CvGlobals::getNUKE_FEATURE
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7738 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8596]

; 7739 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ; CvGlobals::GetEngineUserInterface
; Function compile flags: /Ogtpy
;	COMDAT ?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ
_TEXT	SEGMENT
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ PROC ; CvGlobals::GetEngineUserInterface, COMDAT
; _this$ = ecx

; 7748 : 		return m_pEngineUI;

	mov	eax, DWORD PTR [ecx+8600]

; 7749 : 	}

	ret	0
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ENDP ; CvGlobals::GetEngineUserInterface
_TEXT	ENDS
PUBLIC	?GetPlayerAchievements@CvPlayer@@QAEAAVCvPlayerAchievements@@XZ ; CvPlayer::GetPlayerAchievements
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?GetPlayerAchievements@CvPlayer@@QAEAAVCvPlayerAchievements@@XZ
_TEXT	SEGMENT
?GetPlayerAchievements@CvPlayer@@QAEAAVCvPlayerAchievements@@XZ PROC ; CvPlayer::GetPlayerAchievements, COMDAT
; _this$ = ecx

; 1721 : 	CvPlayerAchievements& GetPlayerAchievements(){return m_kPlayerAchievements;}

	lea	eax, DWORD PTR [ecx+63156]
	ret	0
?GetPlayerAchievements@CvPlayer@@QAEAAVCvPlayerAchievements@@XZ ENDP ; CvPlayer::GetPlayerAchievements
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@isCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax

; 249  : 	}

	ret	0
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al

; 249  : 	}

	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?isHills@CvPlot@@QBE_NXZ			; CvPlot::isHills
; Function compile flags: /Ogtpy
;	COMDAT ?isHills@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isHills@CvPlot@@QBE_NXZ PROC				; CvPlot::isHills, COMDAT
; _this$ = ecx

; 413  : 		return (PlotTypes)m_ePlotType == PLOT_HILLS;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 1
	sete	al

; 414  : 	};

	ret	0
?isHills@CvPlot@@QBE_NXZ ENDP				; CvPlot::isHills
_TEXT	ENDS
PUBLIC	?isMountain@CvPlot@@QBE_NXZ			; CvPlot::isMountain
; Function compile flags: /Ogtpy
;	COMDAT ?isMountain@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isMountain@CvPlot@@QBE_NXZ PROC			; CvPlot::isMountain, COMDAT
; _this$ = ecx

; 422  : 		return (PlotTypes)m_ePlotType == PLOT_MOUNTAIN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], al
	sete	al

; 423  : 	};

	ret	0
?isMountain@CvPlot@@QBE_NXZ ENDP			; CvPlot::isMountain
_TEXT	ENDS
PUBLIC	?isImpassable@CvPlot@@QBE_NXZ			; CvPlot::isImpassable
; Function compile flags: /Ogtpy
;	COMDAT ?isImpassable@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isImpassable@CvPlot@@QBE_NXZ PROC			; CvPlot::isImpassable, COMDAT
; _this$ = ecx

; 444  : 		return m_bIsImpassable;

	mov	al, BYTE PTR [ecx+462]
	shr	al, 7

; 445  : 	}

	ret	0
?isImpassable@CvPlot@@QBE_NXZ ENDP			; CvPlot::isImpassable
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@getPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 537  : 	}

	ret	0
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax

; 537  : 	}

	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UIDInfo@@$00@@IAEXPAUIDInfo@@I@Z ; BaseVector<IDInfo,1>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@UIDInfo@@$00@@IAEXPAUIDInfo@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UIDInfo@@$00@@IAEXPAUIDInfo@@I@Z PROC ; BaseVector<IDInfo,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UIDInfo@@$00@@IAEXPAUIDInfo@@I@Z ENDP ; BaseVector<IDInfo,1>::Destroy
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvUnit>::get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvUnit>::get
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ	; FAutoVariable<int,CvUnit>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::get
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ		; FAutoVariable<int,CvUnit>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ	; FAutoVariable<bool,CvUnit>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ PROC		; FAutoVariable<bool,CvUnit>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ ENDP		; FAutoVariable<bool,CvUnit>::operator bool const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ		; FAutoVariable<char,CvPlot>::operator char const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ
_TEXT	SEGMENT
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ PROC		; FAutoVariable<char,CvPlot>::operator char const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ ENDP		; FAutoVariable<char,CvPlot>::operator char const &
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UIDInfo@@$00@@QAE@XZ		; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@UIDInfo@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UIDInfo@@$00@@QAE@XZ PROC		; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UIDInfo@@$00@@QAE@XZ ENDP		; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
_TEXT	ENDS
;	COMDAT ?FindCombatMember@@YAPAUCvCombatMemberEntry@@PAU1@HUIDInfo@@W4MEMBER_TYPE@1@@Z
_TEXT	SEGMENT
_kMember$ = 8						; size = 8
_eType$ = 16						; size = 4
?FindCombatMember@@YAPAUCvCombatMemberEntry@@PAU1@HUIDInfo@@W4MEMBER_TYPE@1@@Z PROC ; FindCombatMember, COMDAT
; _pkArray$ = eax
; _iMembers$ = ecx

; 39   : {

	push	ebp
	mov	ebp, DWORD PTR _eType$[esp]
	push	esi
	push	edi
	mov	edi, ecx

; 40   : 	if(iMembers > 0)

	test	edi, edi
	jle	SHORT $LN23@FindCombat
	npad	3
$LL4@FindCombat:

; 41   : 	{
; 42   : 		while(iMembers--)
; 43   : 		{
; 44   : 			if(pkArray->IsType(eType))

	mov	edx, DWORD PTR [eax]
	dec	edi
	cmp	edx, -1
	je	SHORT $LN26@FindCombat
	mov	esi, DWORD PTR [eax+4]
	cmp	esi, -1
	je	SHORT $LN26@FindCombat
	test	BYTE PTR [eax+8], 1
	je	SHORT $LN9@FindCombat
	cmp	ebp, 1
	jmp	SHORT $LN27@FindCombat
$LN9@FindCombat:
	test	ebp, ebp
$LN27@FindCombat:
	sete	cl
	test	cl, cl
	je	SHORT $LN26@FindCombat

; 45   : 			{
; 46   : 				if(pkArray->GetID() == kMember.iID && pkArray->GetPlayer() == kMember.eOwner)

	cmp	esi, DWORD PTR _kMember$[esp+12]
	jne	SHORT $LN26@FindCombat
	cmp	edx, DWORD PTR _kMember$[esp+8]
	je	SHORT $LN6@FindCombat
$LN26@FindCombat:

; 47   : 					return pkArray;
; 48   : 			}
; 49   : 			++pkArray;

	add	eax, 36					; 00000024H
	test	edi, edi
	jne	SHORT $LL4@FindCombat
$LN23@FindCombat:

; 50   : 		}
; 51   : 	}
; 52   : 
; 53   : 	return NULL;

	xor	eax, eax
$LN6@FindCombat:
	pop	edi
	pop	esi
	pop	ebp

; 54   : }

	ret	0
?FindCombatMember@@YAPAUCvCombatMemberEntry@@PAU1@HUIDInfo@@W4MEMBER_TYPE@1@@Z ENDP ; FindCombatMember
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?AddCombatMember@@YAPAUCvCombatMemberEntry@@PAU1@PAHHUIDInfo@@W4MEMBER_TYPE@1@HHW4EraTypes@@@Z
_TEXT	SEGMENT
_pkArray$ = 8						; size = 4
_iMaxMembers$ = 12					; size = 4
_kMember$ = 16						; size = 8
_eType$ = 24						; size = 4
_iX$ = 28						; size = 4
_iY$ = 32						; size = 4
_eEra$ = 36						; size = 4
?AddCombatMember@@YAPAUCvCombatMemberEntry@@PAU1@PAHHUIDInfo@@W4MEMBER_TYPE@1@HHW4EraTypes@@@Z PROC ; AddCombatMember, COMDAT
; _piMembers$ = edi

; 59   : {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _eType$[esp+4]
	push	esi

; 60   : 	if(*piMembers < iMaxMembers)

	mov	esi, DWORD PTR [edi]
	cmp	esi, DWORD PTR _iMaxMembers$[esp+8]
	jge	SHORT $LN1@AddCombatM

; 61   : 	{
; 62   : 		int iCount = *piMembers;
; 63   : 		if(!FindCombatMember(pkArray, iCount, kMember, eType))

	mov	eax, DWORD PTR _kMember$[esp+12]
	mov	ebx, DWORD PTR _kMember$[esp+8]
	push	ebp
	push	eax
	mov	eax, DWORD PTR _pkArray$[esp+16]
	push	ebx
	mov	ecx, esi
	call	?FindCombatMember@@YAPAUCvCombatMemberEntry@@PAU1@HUIDInfo@@W4MEMBER_TYPE@1@@Z ; FindCombatMember
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@AddCombatM

; 64   : 		{
; 65   : 			CvCombatMemberEntry& kEntry = pkArray[iCount];

	mov	edx, DWORD PTR _pkArray$[esp+8]
	lea	ecx, DWORD PTR [esi+esi*8]
	lea	eax, DWORD PTR [edx+ecx*4]

; 66   : 			kEntry.SetPlayer(kMember.eOwner);

	mov	DWORD PTR [eax], ebx

; 67   : 			kEntry.SetID(kMember.iID, eType);

	mov	ecx, DWORD PTR _kMember$[esp+12]
	mov	DWORD PTR [eax+4], ecx
	test	ebp, ebp
	jne	SHORT $LN8@AddCombatM
	mov	edx, 65534				; 0000fffeH
	and	WORD PTR [eax+8], dx
	jmp	SHORT $LN7@AddCombatM
$LN8@AddCombatM:
	or	WORD PTR [eax+8], 1
$LN7@AddCombatM:

; 68   : 			kEntry.SetDamage(0);
; 69   : 			kEntry.SetFinalDamage(0);

	xor	edx, edx
	xor	ecx, ecx
	mov	WORD PTR [eax+12], dx

; 70   : 			kEntry.SetMaxHitPoints(0);
; 71   : 			kEntry.SetPlot(iX, iY);

	mov	dx, WORD PTR _iX$[esp+8]
	mov	WORD PTR [eax+10], cx
	mov	WORD PTR [eax+14], cx
	mov	cx, WORD PTR _iY$[esp+8]
	mov	WORD PTR [eax+16], dx

; 72   : 			kEntry.SetEra(eEra);

	mov	edx, DWORD PTR _eEra$[esp+8]
	pop	esi
	pop	ebp
	mov	WORD PTR [eax+18], cx
	mov	DWORD PTR [eax+24], edx

; 73   : 			*piMembers += 1;

	inc	DWORD PTR [edi]
	pop	ebx

; 78   : }

	ret	0
$LN1@AddCombatM:
	pop	esi
	pop	ebp

; 74   : 			return &(pkArray[iCount]);
; 75   : 		}
; 76   : 	}
; 77   : 	return NULL;

	xor	eax, eax
	pop	ebx

; 78   : }

	ret	0
?AddCombatMember@@YAPAUCvCombatMemberEntry@@PAU1@PAHHUIDInfo@@W4MEMBER_TYPE@1@HHW4EraTypes@@@Z ENDP ; AddCombatMember
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 147  : 		if(m_target) 

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	jmp	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@FObjectHan:

; 150  : 		}
; 151  : 	}

	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z PROC	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 156  : 	{

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx
	mov	BYTE PTR [esi+4], 0

; 157  : 		OBJECT_HANDLE_STACK;
; 158  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@2

; 159  : 		{
; 160  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@2:

; 161  : 		}
; 162  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ENDP	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z	; FObjectHandle<CvUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z PROC	; FObjectHandle<CvUnit>::operator=, COMDAT
; _this$ = ecx

; 195  : 	{

	push	esi
	push	edi

; 196  : 		if(&rhs != this)

	mov	edi, DWORD PTR _rhs$[esp+4]
	mov	esi, ecx
	cmp	edi, esi
	je	SHORT $LN11@operator@3

; 197  : 		{
; 198  : 			OBJECT_HANDLE_STACK;
; 199  : 			if(m_target)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@operator@3

; 200  : 			{
; 201  : 				const_cast<FObjectHandle *>(this)->m_target->getDestructionNotification().removeTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@operator@3:

; 202  : 			}
; 203  : 			const_cast<FObjectHandle *>(this)->m_target = rhs.m_target;

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx

; 204  : 			if(m_target)

	test	ecx, ecx
	je	SHORT $LN11@operator@3

; 205  : 			{
; 206  : 				const_cast<FObjectHandle *>(this)->m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN11@operator@3:
	pop	edi

; 207  : 			}
; 208  : 		}
; 209  : 		return *this;

	mov	eax, esi
	pop	esi

; 210  : 	}

	ret	4
??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z ENDP	; FObjectHandle<CvUnit>::operator=
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr@2
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr@2:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
_TEXT	ENDS
PUBLIC	?next@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@PAU2@@Z ; FFastSmallFixedList<IDInfo,25,1,297,0>::next
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?next@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@PAU2@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?next@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@PAU2@@Z PROC ; FFastSmallFixedList<IDInfo,25,1,297,0>::next, COMDAT
; _this$ = ecx

; 914  : #ifdef AUI_FIX_FFASTVECTOR_USE_UNSIGNED
; 915  : 		unsigned int iIndex = (pNode + 1) - &mVec[0];
; 916  : #else
; 917  :         INT iIndex = ( pNode + 1 ) - &mVec[ 0 ];

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pNode$[esp-4]
	sub	eax, edx
	add	eax, 8
	sar	eax, 3

; 918  : #endif
; 919  :         return getAt( iIndex );

	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN6@next
	lea	eax, DWORD PTR [edx+eax*8]

; 920  :     }

	ret	4

; 918  : #endif
; 919  :         return getAt( iIndex );

$LN6@next:
	xor	eax, eax

; 920  :     }

	ret	4
?next@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@PAU2@@Z ENDP ; FFastSmallFixedList<IDInfo,25,1,297,0>::next
_TEXT	ENDS
PUBLIC	?head@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@XZ ; FFastSmallFixedList<IDInfo,25,1,297,0>::head
; Function compile flags: /Ogtpy
;	COMDAT ?head@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@XZ
_TEXT	SEGMENT
?head@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@XZ PROC ; FFastSmallFixedList<IDInfo,25,1,297,0>::head, COMDAT
; _this$ = ecx

; 968  :         UINT uSize = mVec.size();
; 969  : 
; 970  :         if( uSize > 0 )

	cmp	DWORD PTR [ecx+4], 0
	jbe	SHORT $LN2@head

; 971  :         {
; 972  :             return &mVec[ 0 ];

	mov	eax, DWORD PTR [ecx]

; 977  :         }
; 978  :     };

	ret	0
$LN2@head:

; 973  :         }
; 974  :         else
; 975  :         {
; 976  :             return NULL;

	xor	eax, eax

; 977  :         }
; 978  :     };

	ret	0
?head@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@XZ ENDP ; FFastSmallFixedList<IDInfo,25,1,297,0>::head
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr@3
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr@3:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvCombatInfo1@@@std@@QAE@XZ	; std::auto_ptr<ICvCombatInfo1>::~auto_ptr<ICvCombatInfo1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$auto_ptr@VICvCombatInfo1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvCombatInfo1@@@std@@QAE@XZ PROC	; std::auto_ptr<ICvCombatInfo1>::~auto_ptr<ICvCombatInfo1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr@4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr@4:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvCombatInfo1@@@std@@QAE@XZ ENDP	; std::auto_ptr<ICvCombatInfo1>::~auto_ptr<ICvCombatInfo1>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,25,1,297,0>::FStaticVector<IDInfo,25,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<IDInfo,25,1,297,0>::FStaticVector<IDInfo,25,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 25			; 00000019H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<IDInfo,25,1,297,0>::FStaticVector<IDInfo,25,1,297,0>
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXPAUIDInfo@@I@Z ; FStaticVector<IDInfo,25,1,297,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXPAUIDInfo@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXPAUIDInfo@@I@Z PROC ; FStaticVector<IDInfo,25,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXPAUIDInfo@@I@Z ENDP ; FStaticVector<IDInfo,25,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,25,1,297,0>::GrowSize
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<IDInfo,25,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN31@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 25					; 00000019H
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize
$LN15@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 25			; 00000019H
$LN14@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+212], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<IDInfo,25,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	??$?BVICvUnit1@@@?$auto_ptr@VICvUnit1@@@std@@QAE?AU?$auto_ptr_ref@VICvUnit1@@@1@XZ ; std::auto_ptr<ICvUnit1>::operator<ICvUnit1> std::auto_ptr_ref<ICvUnit1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$?BVICvUnit1@@@?$auto_ptr@VICvUnit1@@@std@@QAE?AU?$auto_ptr_ref@VICvUnit1@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BVICvUnit1@@@?$auto_ptr@VICvUnit1@@@std@@QAE?AU?$auto_ptr_ref@VICvUnit1@@@1@XZ PROC ; std::auto_ptr<ICvUnit1>::operator<ICvUnit1> std::auto_ptr_ref<ICvUnit1>, COMDAT
; _this$ = ecx

; 684  : 		{	// convert to compatible auto_ptr_ref
; 685  : 		_Other *_Cvtptr = _Myptr;	// test implicit conversion
; 686  : 		auto_ptr_ref<_Other> _Ans(_Cvtptr);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 687  : 		_Myptr = 0;	// pass ownership to auto_ptr_ref

	mov	DWORD PTR [ecx], 0

; 688  : 		return (_Ans);
; 689  : 		}

	ret	4
??$?BVICvUnit1@@@?$auto_ptr@VICvUnit1@@@std@@QAE?AU?$auto_ptr_ref@VICvUnit1@@@1@XZ ENDP ; std::auto_ptr<ICvUnit1>::operator<ICvUnit1> std::auto_ptr_ref<ICvUnit1>
_TEXT	ENDS
PUBLIC	??$GetLocalizedText@PBDPBDHH@@YA?AVCvString@@PBDABQBD1ABH2@Z ; GetLocalizedText<char const *,char const *,int,int>
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z:PROC
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDPBDHH@@YA?AVCvString@@PBDABQBD1ABH2@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBDHH@@YA?AVCvString@@PBDABQBD1ABH2@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBDHH@@YA?AVCvString@@PBDABQBD1ABH2@Z$0
__ehfuncinfo$??$GetLocalizedText@PBDPBDHH@@YA?AVCvString@@PBDABQBD1ABH2@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDPBDHH@@YA?AVCvString@@PBDABQBD1ABH2@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDPBDHH@@YA?AVCvString@@PBDABQBD1ABH2@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T225298 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_arg3$ = 24						; size = 4
_arg4$ = 28						; size = 4
??$GetLocalizedText@PBDPBDHH@@YA?AVCvString@@PBDABQBD1ABH2@Z PROC ; GetLocalizedText<char const *,char const *,int,int>, COMDAT

; 565  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDPBDHH@@YA?AVCvString@@PBDABQBD1ABH2@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 566  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T225298[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 567  : 	text << arg1 << arg2 << arg3 << arg4;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	eax, DWORD PTR _arg3$[esp+108]
	mov	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	edx, DWORD PTR _arg4$[esp+108]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 568  : 
; 569  : 	size_t bytes = 0;
; 570  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	ecx, DWORD PTR _bytes$[esp+116]
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 571  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 572  : 	str.assign(szComposedString, bytes);
; 573  : 	return str;

	mov	edx, DWORD PTR _bytes$[esp+112]
	push	edx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T225298[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 574  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDPBDHH@@YA?AVCvString@@PBDABQBD1ABH2@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDPBDHH@@YA?AVCvString@@PBDABQBD1ABH2@Z$1:
	mov	eax, DWORD PTR $T225298[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz
	and	DWORD PTR $T225298[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz:
	ret	0
__ehhandler$??$GetLocalizedText@PBDPBDHH@@YA?AVCvString@@PBDABQBD1ABH2@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDPBDHH@@YA?AVCvString@@PBDABQBD1ABH2@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDPBDHH@@YA?AVCvString@@PBDABQBD1ABH2@Z ENDP ; GetLocalizedText<char const *,char const *,int,int>
PUBLIC	??$GetLocalizedText@PBDHHPBDPBD@@YA?AVCvString@@PBDABQBDABH211@Z ; GetLocalizedText<char const *,int,int,char const *,char const *>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDHHPBDPBD@@YA?AVCvString@@PBDABQBDABH211@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDHHPBDPBD@@YA?AVCvString@@PBDABQBDABH211@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDHHPBDPBD@@YA?AVCvString@@PBDABQBDABH211@Z$0
__ehfuncinfo$??$GetLocalizedText@PBDHHPBDPBD@@YA?AVCvString@@PBDABQBDABH211@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDHHPBDPBD@@YA?AVCvString@@PBDABQBDABH211@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDHHPBDPBD@@YA?AVCvString@@PBDABQBDABH211@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T225330 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_arg3$ = 24						; size = 4
_arg4$ = 28						; size = 4
_arg5$ = 32						; size = 4
??$GetLocalizedText@PBDHHPBDPBD@@YA?AVCvString@@PBDABQBDABH211@Z PROC ; GetLocalizedText<char const *,int,int,char const *,char const *>, COMDAT

; 578  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDHHPBDPBD@@YA?AVCvString@@PBDABQBDABH211@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 579  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T225330[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 580  : 	text << arg1 << arg2 << arg3 << arg4 << arg5;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	edi
	mov	eax, DWORD PTR _arg3$[esp+108]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	edi
	mov	edx, DWORD PTR _arg4$[esp+108]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	ecx, DWORD PTR _arg5$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 581  : 
; 582  : 	size_t bytes = 0;
; 583  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[esp+116]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 584  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 585  : 	str.assign(szComposedString, bytes);
; 586  : 	return str;

	mov	ecx, DWORD PTR _bytes$[esp+112]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T225330[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 587  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDHHPBDPBD@@YA?AVCvString@@PBDABQBDABH211@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDHHPBDPBD@@YA?AVCvString@@PBDABQBDABH211@Z$1:
	mov	eax, DWORD PTR $T225330[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@2
	and	DWORD PTR $T225330[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@2:
	ret	0
__ehhandler$??$GetLocalizedText@PBDHHPBDPBD@@YA?AVCvString@@PBDABQBDABH211@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDHHPBDPBD@@YA?AVCvString@@PBDABQBDABH211@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDHHPBDPBD@@YA?AVCvString@@PBDABQBDABH211@Z ENDP ; GetLocalizedText<char const *,int,int,char const *,char const *>
PUBLIC	??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z ; GetLocalizedText<char const *,int,char const *>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z$0
__ehfuncinfo$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T225362 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_arg3$ = 24						; size = 4
??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z PROC ; GetLocalizedText<char const *,int,char const *>, COMDAT

; 552  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 553  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T225362[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 554  : 	text << arg1 << arg2 << arg3;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	mov	eax, DWORD PTR _arg3$[esp+108]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 555  : 
; 556  : 	size_t bytes = 0;
; 557  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+116]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 558  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 559  : 	str.assign(szComposedString, bytes);
; 560  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+112]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T225362[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 561  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z$1:
	mov	eax, DWORD PTR $T225362[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@3
	and	DWORD PTR $T225362[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@3:
	ret	0
__ehhandler$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z ENDP ; GetLocalizedText<char const *,int,char const *>
PUBLIC	??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z ; GetLocalizedText<char const *,char const *,int>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z$0
__ehfuncinfo$??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T225388 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_arg3$ = 24						; size = 4
??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z PROC ; GetLocalizedText<char const *,char const *,int>, COMDAT

; 552  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 553  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T225388[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 554  : 	text << arg1 << arg2 << arg3;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	eax, DWORD PTR _arg3$[esp+108]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 555  : 
; 556  : 	size_t bytes = 0;
; 557  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+116]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 558  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 559  : 	str.assign(szComposedString, bytes);
; 560  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+112]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T225388[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 561  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z$1:
	mov	eax, DWORD PTR $T225388[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@4
	and	DWORD PTR $T225388[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@4:
	ret	0
__ehhandler$??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z ENDP ; GetLocalizedText<char const *,char const *,int>
PUBLIC	??$GetLocalizedText@PBDPBDPBDH@@YA?AVCvString@@PBDABQBD11ABH@Z ; GetLocalizedText<char const *,char const *,char const *,int>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDPBDPBDH@@YA?AVCvString@@PBDABQBD11ABH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBDPBDH@@YA?AVCvString@@PBDABQBD11ABH@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBDPBDH@@YA?AVCvString@@PBDABQBD11ABH@Z$0
__ehfuncinfo$??$GetLocalizedText@PBDPBDPBDH@@YA?AVCvString@@PBDABQBD11ABH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDPBDPBDH@@YA?AVCvString@@PBDABQBD11ABH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDPBDPBDH@@YA?AVCvString@@PBDABQBD11ABH@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T225414 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_arg3$ = 24						; size = 4
_arg4$ = 28						; size = 4
??$GetLocalizedText@PBDPBDPBDH@@YA?AVCvString@@PBDABQBD11ABH@Z PROC ; GetLocalizedText<char const *,char const *,char const *,int>, COMDAT

; 565  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDPBDPBDH@@YA?AVCvString@@PBDABQBD11ABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 566  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T225414[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 567  : 	text << arg1 << arg2 << arg3 << arg4;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	eax, DWORD PTR _arg3$[esp+108]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	edx, DWORD PTR _arg4$[esp+108]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 568  : 
; 569  : 	size_t bytes = 0;
; 570  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	ecx, DWORD PTR _bytes$[esp+116]
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 571  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 572  : 	str.assign(szComposedString, bytes);
; 573  : 	return str;

	mov	edx, DWORD PTR _bytes$[esp+112]
	push	edx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T225414[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 574  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDPBDPBDH@@YA?AVCvString@@PBDABQBD11ABH@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDPBDPBDH@@YA?AVCvString@@PBDABQBD11ABH@Z$1:
	mov	eax, DWORD PTR $T225414[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@5
	and	DWORD PTR $T225414[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@5:
	ret	0
__ehhandler$??$GetLocalizedText@PBDPBDPBDH@@YA?AVCvString@@PBDABQBD11ABH@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDPBDPBDH@@YA?AVCvString@@PBDABQBD11ABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDPBDPBDH@@YA?AVCvString@@PBDABQBD11ABH@Z ENDP ; GetLocalizedText<char const *,char const *,char const *,int>
PUBLIC	??$GetLocalizedText@PBDHPBDH@@YA?AVCvString@@PBDABQBDABH12@Z ; GetLocalizedText<char const *,int,char const *,int>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDHPBDH@@YA?AVCvString@@PBDABQBDABH12@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDHPBDH@@YA?AVCvString@@PBDABQBDABH12@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDHPBDH@@YA?AVCvString@@PBDABQBDABH12@Z$0
__ehfuncinfo$??$GetLocalizedText@PBDHPBDH@@YA?AVCvString@@PBDABQBDABH12@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDHPBDH@@YA?AVCvString@@PBDABQBDABH12@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDHPBDH@@YA?AVCvString@@PBDABQBDABH12@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T225443 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_arg3$ = 24						; size = 4
_arg4$ = 28						; size = 4
??$GetLocalizedText@PBDHPBDH@@YA?AVCvString@@PBDABQBDABH12@Z PROC ; GetLocalizedText<char const *,int,char const *,int>, COMDAT

; 565  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDHPBDH@@YA?AVCvString@@PBDABQBDABH12@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 566  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T225443[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 567  : 	text << arg1 << arg2 << arg3 << arg4;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	edi
	mov	eax, DWORD PTR _arg3$[esp+108]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	edx, DWORD PTR _arg4$[esp+108]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	call	edi

; 568  : 
; 569  : 	size_t bytes = 0;
; 570  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	ecx, DWORD PTR _bytes$[esp+116]
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 571  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 572  : 	str.assign(szComposedString, bytes);
; 573  : 	return str;

	mov	edx, DWORD PTR _bytes$[esp+112]
	push	edx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T225443[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 574  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDHPBDH@@YA?AVCvString@@PBDABQBDABH12@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDHPBDH@@YA?AVCvString@@PBDABQBDABH12@Z$1:
	mov	eax, DWORD PTR $T225443[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@6
	and	DWORD PTR $T225443[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@6:
	ret	0
__ehhandler$??$GetLocalizedText@PBDHPBDH@@YA?AVCvString@@PBDABQBDABH12@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDHPBDH@@YA?AVCvString@@PBDABQBDABH12@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDHPBDH@@YA?AVCvString@@PBDABQBDABH12@Z ENDP ; GetLocalizedText<char const *,int,char const *,int>
PUBLIC	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$0
__ehfuncinfo$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T225472 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z PROC ; GetLocalizedText<char const *,char const *>, COMDAT

; 539  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 540  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T225472[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 541  : 	text << arg1 << arg2;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 542  : 
; 543  : 	size_t bytes = 0;
; 544  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[esp+116]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 545  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 546  : 	str.assign(szComposedString, bytes);
; 547  : 	return str;

	mov	ecx, DWORD PTR _bytes$[esp+112]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T225472[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 548  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$1:
	mov	eax, DWORD PTR $T225472[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@7
	and	DWORD PTR $T225472[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@7:
	ret	0
__ehhandler$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ENDP ; GetLocalizedText<char const *,char const *>
PUBLIC	??$GetLocalizedText@PBDH@@YA?AVCvString@@PBDABQBDABH@Z ; GetLocalizedText<char const *,int>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDH@@YA?AVCvString@@PBDABQBDABH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDH@@YA?AVCvString@@PBDABQBDABH@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDH@@YA?AVCvString@@PBDABQBDABH@Z$0
__ehfuncinfo$??$GetLocalizedText@PBDH@@YA?AVCvString@@PBDABQBDABH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDH@@YA?AVCvString@@PBDABQBDABH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDH@@YA?AVCvString@@PBDABQBDABH@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T225495 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
??$GetLocalizedText@PBDH@@YA?AVCvString@@PBDABQBDABH@Z PROC ; GetLocalizedText<char const *,int>, COMDAT

; 539  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDH@@YA?AVCvString@@PBDABQBDABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 540  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T225495[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 541  : 	text << arg1 << arg2;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 542  : 
; 543  : 	size_t bytes = 0;
; 544  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[esp+116]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 545  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 546  : 	str.assign(szComposedString, bytes);
; 547  : 	return str;

	mov	ecx, DWORD PTR _bytes$[esp+112]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T225495[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 548  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDH@@YA?AVCvString@@PBDABQBDABH@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDH@@YA?AVCvString@@PBDABQBDABH@Z$1:
	mov	eax, DWORD PTR $T225495[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@8
	and	DWORD PTR $T225495[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@8:
	ret	0
__ehhandler$??$GetLocalizedText@PBDH@@YA?AVCvString@@PBDABQBDABH@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDH@@YA?AVCvString@@PBDABQBDABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDH@@YA?AVCvString@@PBDABQBDABH@Z ENDP ; GetLocalizedText<char const *,int>
PUBLIC	??$GetLocalizedText@PBDHPBDPBD@@YA?AVCvString@@PBDABQBDABH11@Z ; GetLocalizedText<char const *,int,char const *,char const *>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDHPBDPBD@@YA?AVCvString@@PBDABQBDABH11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDHPBDPBD@@YA?AVCvString@@PBDABQBDABH11@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDHPBDPBD@@YA?AVCvString@@PBDABQBDABH11@Z$0
__ehfuncinfo$??$GetLocalizedText@PBDHPBDPBD@@YA?AVCvString@@PBDABQBDABH11@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDHPBDPBD@@YA?AVCvString@@PBDABQBDABH11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDHPBDPBD@@YA?AVCvString@@PBDABQBDABH11@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T225518 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_arg3$ = 24						; size = 4
_arg4$ = 28						; size = 4
??$GetLocalizedText@PBDHPBDPBD@@YA?AVCvString@@PBDABQBDABH11@Z PROC ; GetLocalizedText<char const *,int,char const *,char const *>, COMDAT

; 565  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDHPBDPBD@@YA?AVCvString@@PBDABQBDABH11@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 566  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T225518[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 567  : 	text << arg1 << arg2 << arg3 << arg4;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	mov	eax, DWORD PTR _arg3$[esp+108]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	edx, DWORD PTR _arg4$[esp+108]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 568  : 
; 569  : 	size_t bytes = 0;
; 570  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	ecx, DWORD PTR _bytes$[esp+116]
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 571  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 572  : 	str.assign(szComposedString, bytes);
; 573  : 	return str;

	mov	edx, DWORD PTR _bytes$[esp+112]
	push	edx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T225518[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 574  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDHPBDPBD@@YA?AVCvString@@PBDABQBDABH11@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDHPBDPBD@@YA?AVCvString@@PBDABQBDABH11@Z$1:
	mov	eax, DWORD PTR $T225518[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@9
	and	DWORD PTR $T225518[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@9:
	ret	0
__ehhandler$??$GetLocalizedText@PBDHPBDPBD@@YA?AVCvString@@PBDABQBDABH11@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDHPBDPBD@@YA?AVCvString@@PBDABQBDABH11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDHPBDPBD@@YA?AVCvString@@PBDABQBDABH11@Z ENDP ; GetLocalizedText<char const *,int,char const *,char const *>
PUBLIC	??$GetLocalizedText@PBDPBDPBDPBD@@YA?AVCvString@@PBDABQBD111@Z ; GetLocalizedText<char const *,char const *,char const *,char const *>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDPBDPBDPBD@@YA?AVCvString@@PBDABQBD111@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBDPBDPBD@@YA?AVCvString@@PBDABQBD111@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBDPBDPBD@@YA?AVCvString@@PBDABQBD111@Z$0
__ehfuncinfo$??$GetLocalizedText@PBDPBDPBDPBD@@YA?AVCvString@@PBDABQBD111@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDPBDPBDPBD@@YA?AVCvString@@PBDABQBD111@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDPBDPBDPBD@@YA?AVCvString@@PBDABQBD111@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T225547 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_arg3$ = 24						; size = 4
_arg4$ = 28						; size = 4
??$GetLocalizedText@PBDPBDPBDPBD@@YA?AVCvString@@PBDABQBD111@Z PROC ; GetLocalizedText<char const *,char const *,char const *,char const *>, COMDAT

; 565  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDPBDPBDPBD@@YA?AVCvString@@PBDABQBD111@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 566  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T225547[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 567  : 	text << arg1 << arg2 << arg3 << arg4;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	eax, DWORD PTR _arg3$[esp+108]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	edx, DWORD PTR _arg4$[esp+108]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 568  : 
; 569  : 	size_t bytes = 0;
; 570  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	ecx, DWORD PTR _bytes$[esp+116]
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 571  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 572  : 	str.assign(szComposedString, bytes);
; 573  : 	return str;

	mov	edx, DWORD PTR _bytes$[esp+112]
	push	edx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T225547[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 574  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDPBDPBDPBD@@YA?AVCvString@@PBDABQBD111@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDPBDPBDPBD@@YA?AVCvString@@PBDABQBD111@Z$1:
	mov	eax, DWORD PTR $T225547[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@10
	and	DWORD PTR $T225547[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@10:
	ret	0
__ehhandler$??$GetLocalizedText@PBDPBDPBDPBD@@YA?AVCvString@@PBDABQBD111@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDPBDPBDPBD@@YA?AVCvString@@PBDABQBD111@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDPBDPBDPBD@@YA?AVCvString@@PBDABQBD111@Z ENDP ; GetLocalizedText<char const *,char const *,char const *,char const *>
PUBLIC	??$GetLocalizedText@PBDPBDPBDHPBD@@YA?AVCvString@@PBDABQBD11ABH1@Z ; GetLocalizedText<char const *,char const *,char const *,int,char const *>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDPBDPBDHPBD@@YA?AVCvString@@PBDABQBD11ABH1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBDPBDHPBD@@YA?AVCvString@@PBDABQBD11ABH1@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBDPBDHPBD@@YA?AVCvString@@PBDABQBD11ABH1@Z$0
__ehfuncinfo$??$GetLocalizedText@PBDPBDPBDHPBD@@YA?AVCvString@@PBDABQBD11ABH1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDPBDPBDHPBD@@YA?AVCvString@@PBDABQBD11ABH1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDPBDPBDHPBD@@YA?AVCvString@@PBDABQBD11ABH1@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T225576 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_arg3$ = 24						; size = 4
_arg4$ = 28						; size = 4
_arg5$ = 32						; size = 4
??$GetLocalizedText@PBDPBDPBDHPBD@@YA?AVCvString@@PBDABQBD11ABH1@Z PROC ; GetLocalizedText<char const *,char const *,char const *,int,char const *>, COMDAT

; 578  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDPBDPBDHPBD@@YA?AVCvString@@PBDABQBD11ABH1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 579  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T225576[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 580  : 	text << arg1 << arg2 << arg3 << arg4 << arg5;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	eax, DWORD PTR _arg3$[esp+108]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	edx, DWORD PTR _arg4$[esp+108]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	mov	ecx, DWORD PTR _arg5$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 581  : 
; 582  : 	size_t bytes = 0;
; 583  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[esp+116]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 584  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 585  : 	str.assign(szComposedString, bytes);
; 586  : 	return str;

	mov	ecx, DWORD PTR _bytes$[esp+112]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T225576[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 587  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDPBDPBDHPBD@@YA?AVCvString@@PBDABQBD11ABH1@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDPBDPBDHPBD@@YA?AVCvString@@PBDABQBD11ABH1@Z$1:
	mov	eax, DWORD PTR $T225576[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@11
	and	DWORD PTR $T225576[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@11:
	ret	0
__ehhandler$??$GetLocalizedText@PBDPBDPBDHPBD@@YA?AVCvString@@PBDABQBD11ABH1@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDPBDPBDHPBD@@YA?AVCvString@@PBDABQBD11ABH1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDPBDPBDHPBD@@YA?AVCvString@@PBDABQBD11ABH1@Z ENDP ; GetLocalizedText<char const *,char const *,char const *,int,char const *>
PUBLIC	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z	; GetLocalizedText<char const *>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$0
__ehfuncinfo$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T225608 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z PROC	; GetLocalizedText<char const *>, COMDAT

; 526  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 527  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T225608[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 528  : 	text << arg1;

	mov	edx, DWORD PTR _arg1$[esp+108]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 529  : 
; 530  : 	size_t bytes = 0;
; 531  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[esp+116]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 532  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 533  : 	str.assign(szComposedString, bytes);
; 534  : 	return str;

	mov	ecx, DWORD PTR _bytes$[esp+112]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T225608[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 535  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$1:
	mov	eax, DWORD PTR $T225608[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@12
	and	DWORD PTR $T225608[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@12:
	ret	0
__ehhandler$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ENDP	; GetLocalizedText<char const *>
PUBLIC	??$?BVICvPlot1@@@?$auto_ptr@VICvPlot1@@@std@@QAE?AU?$auto_ptr_ref@VICvPlot1@@@1@XZ ; std::auto_ptr<ICvPlot1>::operator<ICvPlot1> std::auto_ptr_ref<ICvPlot1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$?BVICvPlot1@@@?$auto_ptr@VICvPlot1@@@std@@QAE?AU?$auto_ptr_ref@VICvPlot1@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BVICvPlot1@@@?$auto_ptr@VICvPlot1@@@std@@QAE?AU?$auto_ptr_ref@VICvPlot1@@@1@XZ PROC ; std::auto_ptr<ICvPlot1>::operator<ICvPlot1> std::auto_ptr_ref<ICvPlot1>, COMDAT
; _this$ = ecx

; 684  : 		{	// convert to compatible auto_ptr_ref
; 685  : 		_Other *_Cvtptr = _Myptr;	// test implicit conversion
; 686  : 		auto_ptr_ref<_Other> _Ans(_Cvtptr);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 687  : 		_Myptr = 0;	// pass ownership to auto_ptr_ref

	mov	DWORD PTR [ecx], 0

; 688  : 		return (_Ans);
; 689  : 		}

	ret	4
??$?BVICvPlot1@@@?$auto_ptr@VICvPlot1@@@std@@QAE?AU?$auto_ptr_ref@VICvPlot1@@@1@XZ ENDP ; std::auto_ptr<ICvPlot1>::operator<ICvPlot1> std::auto_ptr_ref<ICvPlot1>
_TEXT	ENDS
PUBLIC	?isEmbarked@CvUnit@@QBE_NXZ			; CvUnit::isEmbarked
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?isEmbarked@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?isEmbarked@CvUnit@@QBE_NXZ PROC			; CvUnit::isEmbarked, COMDAT
; _this$ = ecx

; 257  : 		return m_bEmbarked;

	mov	al, BYTE PTR [ecx+1652]

; 258  : 	}

	ret	0
?isEmbarked@CvUnit@@QBE_NXZ ENDP			; CvUnit::isEmbarked
_TEXT	ENDS
PUBLIC	?getX@CvUnit@@QBEHXZ				; CvUnit::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getX@CvUnit@@QBEHXZ PROC				; CvUnit::getX, COMDAT
; _this$ = ecx

; 673  : 		return m_iX.get();

	mov	eax, DWORD PTR [ecx+76]

; 674  : 	}

	ret	0
?getX@CvUnit@@QBEHXZ ENDP				; CvUnit::getX
_TEXT	ENDS
PUBLIC	?getY@CvUnit@@QBEHXZ				; CvUnit::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getY@CvUnit@@QBEHXZ PROC				; CvUnit::getY, COMDAT
; _this$ = ecx

; 678  : 		return m_iY.get();

	mov	eax, DWORD PTR [ecx+88]

; 679  : 	}

	ret	0
?getY@CvUnit@@QBEHXZ ENDP				; CvUnit::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ	; CvUnit::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ PROC		; CvUnit::getOwner, COMDAT
; _this$ = ecx

; 1046 : 		return m_eOwner.get();

	mov	eax, DWORD PTR [ecx+40]

; 1047 : 	}

	ret	0
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ENDP		; CvUnit::getOwner
_TEXT	ENDS
PUBLIC	?IsCombatUnit@CvUnit@@QBE_NXZ			; CvUnit::IsCombatUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsCombatUnit@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?IsCombatUnit@CvUnit@@QBE_NXZ PROC			; CvUnit::IsCombatUnit, COMDAT
; _this$ = ecx

; 1243 : 		return (m_iBaseCombat > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+1044], eax
	setg	al

; 1244 : 	}

	ret	0
?IsCombatUnit@CvUnit@@QBE_NXZ ENDP			; CvUnit::IsCombatUnit
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ	; CvCity::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ PROC		; CvCity::getOwner, COMDAT
; _this$ = ecx

; 604  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+84]

; 605  : 	}

	ret	0
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ENDP		; CvCity::getOwner
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1172 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1173 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayerID$ = 8						; size = 4
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPlayer::getTeam, COMDAT

; 1177 : 		return CvPreGame::teamType(ePlayerID);

	mov	eax, DWORD PTR _ePlayerID$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN3@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1178 : 	}

	ret	0

; 1177 : 		return CvPreGame::teamType(ePlayerID);

$LN3@getTeam:
	or	eax, -1

; 1178 : 	}

	ret	0
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ		; CvPlot::getTeam
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ PROC		; CvPlot::getTeam, COMDAT
; _this$ = ecx

; 232  : 		PlayerTypes playerID = getOwner();

	movsx	eax, BYTE PTR [ecx+4]

; 233  : 		if(playerID != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN2@getTeam@2

; 234  : 		{
; 235  : 			return CvPlayer::getTeam(playerID);

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN2@getTeam@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 240  : 		}
; 241  : 	}

	ret	0
$LN2@getTeam@2:

; 236  : 		}
; 237  : 		else
; 238  : 		{
; 239  : 			return NO_TEAM;

	or	eax, -1

; 240  : 		}
; 241  : 	}

	ret	0
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlot::getTeam
_TEXT	ENDS
PUBLIC	?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ	; CvPlot::getFeatureType
; Function compile flags: /Ogtpy
;	COMDAT ?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ
_TEXT	SEGMENT
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ PROC	; CvPlot::getFeatureType, COMDAT
; _this$ = ecx

; 435  : #ifdef AUI_WARNING_FIXES
; 436  : 		int f = m_eFeatureType;
; 437  : #else
; 438  : 		char f = m_eFeatureType;
; 439  : #endif
; 440  : 		return (FeatureTypes)f;

	movsx	eax, BYTE PTR [ecx+432]

; 441  : 	}

	ret	0
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ ENDP	; CvPlot::getFeatureType
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 219  : 	if(eDirection == NO_DIRECTION)

	mov	ecx, DWORD PTR _eDirection$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	ecx, -1
	jne	$LN2@plotDirect

; 220  : 	{
; 221  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebx, DWORD PTR _iY$[esp+12]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN99@plotDirect
	test	eax, eax
	jge	SHORT $LN19@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@plotDirect
$LN19@plotDirect:
	cmp	eax, ecx
	jl	SHORT $LN99@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@plotDirect
$LN99@plotDirect:
	mov	esi, eax
$LN21@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN101@plotDirect
	test	ebx, ebx
	jge	SHORT $LN29@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@plotDirect
$LN29@plotDirect:
	cmp	ebx, edi
	jl	SHORT $LN101@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@plotDirect
$LN101@plotDirect:
	mov	edx, ebx
$LN31@plotDirect:
	test	esi, esi
	jl	$LN59@plotDirect
	cmp	esi, ecx
	jge	$LN59@plotDirect
	test	edx, edx
	jl	$LN59@plotDirect
	cmp	edx, edi
	jge	$LN59@plotDirect
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 234  : 	}
; 235  : }

	ret	0
$LN2@plotDirect:

; 222  : 	}
; 223  : 	else
; 224  : 	{
; 225  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 226  : 		iX = xToHexspaceX(iX , iY);

	mov	esi, DWORD PTR _iY$[esp+12]
	test	esi, esi
	jl	SHORT $LN47@plotDirect
	mov	eax, esi
	jmp	SHORT $LN103@plotDirect
$LN47@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN103@plotDirect:

; 227  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	mov	edi, DWORD PTR _iX$[esp+12]
	sar	eax, 1
	sub	edx, eax
	add	edi, edx

; 228  : 		iY += GC.getPlotDirectionY()[eDirection];

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]

; 229  : 
; 230  : 		// convert from hex-space coordinates to the storage array
; 231  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN55@plotDirect
	mov	eax, esi
	jmp	SHORT $LN104@plotDirect
$LN55@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN104@plotDirect:
	sar	eax, 1
	add	edi, eax

; 232  : 
; 233  : 		return GC.getMap().plot(iX, iY);

	cmp	edi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	cmp	esi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN69@plotDirect
	test	edi, edi
	jge	SHORT $LN71@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN69@plotDirect
$LN71@plotDirect:
	cmp	edi, ecx
	jl	SHORT $LN69@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN69@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN100@plotDirect
	test	esi, esi
	jge	SHORT $LN81@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN83@plotDirect
$LN81@plotDirect:
	cmp	esi, ebx
	jl	SHORT $LN100@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN83@plotDirect
$LN100@plotDirect:
	mov	edx, esi
$LN83@plotDirect:
	test	edi, edi
	jl	SHORT $LN59@plotDirect
	cmp	edi, ecx
	jge	SHORT $LN59@plotDirect
	test	edx, edx
	jl	SHORT $LN59@plotDirect
	cmp	edx, ebx
	jge	SHORT $LN59@plotDirect
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 234  : 	}
; 235  : }

	ret	0

; 232  : 
; 233  : 		return GC.getMap().plot(iX, iY);

$LN59@plotDirect:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 234  : 	}
; 235  : }

	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Ogtpy
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 239  : 	// convert the start coord to hex-space coordinates
; 240  : 	int iStartHexX = xToHexspaceX(iX, iY);

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jl	SHORT $LN5@plotXY
	mov	eax, ecx
	jmp	SHORT $LN55@plotXY
$LN5@plotXY:
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
$LN55@plotXY:
	push	esi

; 241  : 
; 242  : 	int iPlotHexX = iStartHexX + iDX;

	mov	esi, DWORD PTR _iX$[esp]
	sar	eax, 1
	sub	esi, eax

; 243  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iDY$[esp]
	add	esi, DWORD PTR _iDX$[esp]
	push	edi
	lea	edi, DWORD PTR [ecx+eax]

; 244  : 
; 245  : 	// convert from hex-space coordinates to the storage array
; 246  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	test	edi, edi
	jl	SHORT $LN9@plotXY
	mov	eax, edi
	jmp	SHORT $LN56@plotXY
$LN9@plotXY:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN56@plotXY:
	sar	eax, 1
	add	esi, eax

; 247  : 
; 248  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	cmp	esi, -2147483647			; 80000001H
	je	$LN13@plotXY
	cmp	edi, -2147483647			; 80000001H
	je	$LN13@plotXY
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN23@plotXY
	test	esi, esi
	jge	SHORT $LN25@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN23@plotXY
$LN25@plotXY:
	cmp	esi, ecx
	jl	SHORT $LN23@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN23@plotXY:
	cmp	BYTE PTR [ebp+4057], 0
	push	ebx
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN52@plotXY
	test	edi, edi
	jge	SHORT $LN35@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN37@plotXY
$LN35@plotXY:
	cmp	edi, ebx
	jl	SHORT $LN52@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	jmp	SHORT $LN37@plotXY
$LN52@plotXY:
	mov	edx, edi
$LN37@plotXY:
	test	esi, esi
	jl	SHORT $LN17@plotXY
	cmp	esi, ecx
	jge	SHORT $LN17@plotXY
	test	edx, edx
	jl	SHORT $LN17@plotXY
	cmp	edx, ebx
	jge	SHORT $LN17@plotXY
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	ebx
	pop	ebp
	pop	edi
	mov	eax, ecx
	pop	esi

; 249  : }

	ret	0

; 247  : 
; 248  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN17@plotXY:
	pop	ebx
	pop	ebp
	pop	edi
	xor	eax, eax
	pop	esi

; 249  : }

	ret	0

; 247  : 
; 248  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN13@plotXY:
	pop	edi
	xor	eax, eax
	pop	esi

; 249  : }

	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
; Function compile flags: /Ogtpy
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 259  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 260  : 	// I'm assuming iDX and iDY are in hex-space
; 261  : 	if (hexDistance(iDX, iDY) > iRange)
; 262  : #else
; 263  : 	int hexRange;
; 264  : 
; 265  : 	// I'm assuming iDX and iDY are in hex-space
; 266  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iDX$[esp-4]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR _iDY$[esp]
	test	esi, esi
	setge	cl
	cmp	eax, ecx

; 267  : 	{
; 268  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	mov	ecx, edx
	jne	SHORT $LN3@plotXYWith
	test	edx, edx
	jge	SHORT $LN7@plotXYWith
	neg	ecx
$LN7@plotXYWith:

; 269  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN9@plotXYWith
	neg	eax
$LN9@plotXYWith:

; 270  : 		hexRange = iAbsDX + iAbsDY;

	add	eax, ecx

; 271  : 	}
; 272  : 	else

	jmp	SHORT $LN14@plotXYWith
$LN3@plotXYWith:

; 273  : 	{
; 274  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	edx, edx
	jge	SHORT $LN11@plotXYWith
	neg	ecx
$LN11@plotXYWith:

; 275  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN13@plotXYWith
	neg	eax
$LN13@plotXYWith:

; 276  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	cmp	ecx, eax
	jl	SHORT $LN14@plotXYWith
	mov	eax, ecx
$LN14@plotXYWith:

; 277  : 	}
; 278  : 
; 279  : 	if(hexRange > iRange)

	cmp	eax, DWORD PTR _iRange$[esp]
	jle	SHORT $LN1@plotXYWith

; 280  : #endif
; 281  : 	{
; 282  : 		return NULL;

	xor	eax, eax
	pop	esi

; 286  : }

	ret	0
$LN1@plotXYWith:

; 283  : 	}
; 284  : 
; 285  : 	return plotXY(iX, iY, iDX, iDY);

	mov	eax, DWORD PTR _iX$[esp]
	push	esi
	push	edx
	mov	edx, DWORD PTR _iY$[esp+8]
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
	pop	esi

; 286  : }

	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
_TEXT	ENDS
EXTRN	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ:PROC ; CvPlayer::GetCurrentEra
EXTRN	?GetIDInfo@CvUnit@@QBE?AUIDInfo@@XZ:PROC	; CvUnit::GetIDInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
;	COMDAT ?AddCombatMember@@YAPAUCvCombatMemberEntry@@PAU1@PAHHPAVCvUnit@@@Z
_TEXT	SEGMENT
$T226205 = -8						; size = 8
_pkArray$ = 8						; size = 4
_piMembers$ = 12					; size = 4
_iMaxMembers$ = 16					; size = 4
?AddCombatMember@@YAPAUCvCombatMemberEntry@@PAU1@PAHHPAVCvUnit@@@Z PROC ; AddCombatMember, COMDAT
; _pkMember$ = ecx

; 83   : {

	sub	esp, 8

; 84   : 	if(pkMember)

	test	ecx, ecx
	je	SHORT $LN1@AddCombatM@2
	push	ebx

; 85   : 		return AddCombatMember(pkArray, piMembers, iMaxMembers, pkMember->GetIDInfo(), CvCombatMemberEntry::MEMBER_UNIT, pkMember->getX(), pkMember->getY(), GET_PLAYER(pkMember->getOwner()).GetCurrentEra());

	mov	ebx, DWORD PTR [ecx+88]
	push	ebp
	mov	ebp, DWORD PTR [ecx+76]
	push	esi
	mov	esi, DWORD PTR [ecx+40]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	lea	eax, DWORD PTR $T226205[esp+24]
	push	eax
	call	?GetIDInfo@CvUnit@@QBE?AUIDInfo@@XZ	; CvUnit::GetIDInfo
	mov	ecx, esi
	mov	edi, eax
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi]
	mov	edi, DWORD PTR _piMembers$[esp+20]
	push	eax
	mov	eax, DWORD PTR _iMaxMembers$[esp+24]
	push	ebx
	push	ebp
	push	0
	push	ecx
	mov	ecx, DWORD PTR _pkArray$[esp+40]
	push	edx
	push	eax
	push	ecx
	call	?AddCombatMember@@YAPAUCvCombatMemberEntry@@PAU1@PAHHUIDInfo@@W4MEMBER_TYPE@1@HHW4EraTypes@@@Z ; AddCombatMember
	add	esp, 32					; 00000020H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 88   : }

	add	esp, 8
	ret	0
$LN1@AddCombatM@2:

; 86   : 
; 87   : 	return NULL;

	xor	eax, eax

; 88   : }

	add	esp, 8
	ret	0
?AddCombatMember@@YAPAUCvCombatMemberEntry@@PAU1@PAHHPAVCvUnit@@@Z ENDP ; AddCombatMember
_TEXT	ENDS
EXTRN	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ:PROC	; CvCity::GetIDInfo
; Function compile flags: /Ogtpy
;	COMDAT ?AddCombatMember@@YAPAUCvCombatMemberEntry@@PAU1@PAHHPAVCvCity@@@Z
_TEXT	SEGMENT
$T226240 = -8						; size = 8
_pkArray$ = 8						; size = 4
_piMembers$ = 12					; size = 4
_iMaxMembers$ = 16					; size = 4
?AddCombatMember@@YAPAUCvCombatMemberEntry@@PAU1@PAHHPAVCvCity@@@Z PROC ; AddCombatMember, COMDAT
; _pkMember$ = ecx

; 93   : {

	sub	esp, 8

; 94   : 	if(pkMember)

	test	ecx, ecx
	je	SHORT $LN1@AddCombatM@3
	push	ebx

; 95   : 		return AddCombatMember(pkArray, piMembers, iMaxMembers, pkMember->GetIDInfo(), CvCombatMemberEntry::MEMBER_CITY, pkMember->getX(), pkMember->getY(), GET_PLAYER(pkMember->getOwner()).GetCurrentEra());

	mov	ebx, DWORD PTR [ecx+108]
	push	ebp
	mov	ebp, DWORD PTR [ecx+96]
	push	esi
	mov	esi, DWORD PTR [ecx+84]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	lea	eax, DWORD PTR $T226240[esp+24]
	push	eax
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	mov	ecx, esi
	mov	edi, eax
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi]
	mov	edi, DWORD PTR _piMembers$[esp+20]
	push	eax
	mov	eax, DWORD PTR _iMaxMembers$[esp+24]
	push	ebx
	push	ebp
	push	1
	push	ecx
	mov	ecx, DWORD PTR _pkArray$[esp+40]
	push	edx
	push	eax
	push	ecx
	call	?AddCombatMember@@YAPAUCvCombatMemberEntry@@PAU1@PAHHUIDInfo@@W4MEMBER_TYPE@1@HHW4EraTypes@@@Z ; AddCombatMember
	add	esp, 32					; 00000020H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 98   : }

	add	esp, 8
	ret	0
$LN1@AddCombatM@3:

; 96   : 
; 97   : 	return NULL;

	xor	eax, eax

; 98   : }

	add	esp, 8
	ret	0
?AddCombatMember@@YAPAUCvCombatMemberEntry@@PAU1@PAHHPAVCvCity@@@Z ENDP ; AddCombatMember
_TEXT	ENDS
PUBLIC	?GenerateMeleeCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z ; CvUnitCombat::GenerateMeleeCombatInfo
EXTRN	?setDefenderRetaliates@CvCombatInfo@@QAEX_N@Z:PROC ; CvCombatInfo::setDefenderRetaliates
EXTRN	?setAttackerAdvances@CvCombatInfo@@QAEX_N@Z:PROC ; CvCombatInfo::setAttackerAdvances
EXTRN	?isDelayedDeath@CvUnit@@QBE_NXZ:PROC		; CvUnit::isDelayedDeath
EXTRN	?setDefenderCaptured@CvCombatInfo@@QAEX_N@Z:PROC ; CvCombatInfo::setDefenderCaptured
EXTRN	?GetCaptureChance@CvUnit@@QAEHPAV1@@Z:PROC	; CvUnit::GetCaptureChance
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?AreUnitsOfSameType@CvUnit@@QBE_NABV1@_N@Z:PROC	; CvUnit::AreUnitsOfSameType
EXTRN	?IsCaptureDefeatedEnemy@CvUnit@@QBE_NXZ:PROC	; CvUnit::IsCaptureDefeatedEnemy
EXTRN	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlot::getNumDefenders
EXTRN	?setFearDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z:PROC ; CvCombatInfo::setFearDamageInflicted
EXTRN	?CanFallBackFromMelee@CvUnit@@IAE_NAAV1@@Z:PROC	; CvUnit::CanFallBackFromMelee
EXTRN	?GetHeavyChargeDownhill@CvUnit@@QBEHXZ:PROC	; CvUnit::GetHeavyChargeDownhill
EXTRN	?IsCanHeavyCharge@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsCanHeavyCharge
EXTRN	?isFlatlands@CvPlot@@QBE_NXZ:PROC		; CvPlot::isFlatlands
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
EXTRN	?GetMaxRangedCombatStrength@CvUnit@@QBEHPBV1@PBVCvCity@@_N2@Z:PROC ; CvUnit::GetMaxRangedCombatStrength
EXTRN	?GetMaxDefenseStrength@CvUnit@@QBEHPBVCvPlot@@PBV1@_N@Z:PROC ; CvUnit::GetMaxDefenseStrength
EXTRN	?setAttackIsRanged@CvCombatInfo@@QAEX_N@Z:PROC	; CvCombatInfo::setAttackIsRanged
EXTRN	?maxXPValue@CvUnit@@QBEHXZ:PROC			; CvUnit::maxXPValue
EXTRN	?setUpdateGlobal@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z:PROC ; CvCombatInfo::setUpdateGlobal
EXTRN	?isBarbarian@CvCity@@QBE_NXZ:PROC		; CvCity::isBarbarian
EXTRN	?isBarbarian@CvUnit@@QBE_NXZ:PROC		; CvUnit::isBarbarian
EXTRN	?setInBorders@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z:PROC ; CvCombatInfo::setInBorders
EXTRN	?setMaxExperienceAllowed@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z:PROC ; CvCombatInfo::setMaxExperienceAllowed
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?setExperience@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z:PROC ; CvCombatInfo::setExperience
EXTRN	?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z:PROC ; CvCombatInfo::setDamageInflicted
EXTRN	?setFinalDamage@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z:PROC ; CvCombatInfo::setFinalDamage
EXTRN	?getDamage@CvCity@@QBEHXZ:PROC			; CvCity::getDamage
EXTRN	?getCombatDamage@CvUnit@@QBEHHHH_N00@Z:PROC	; CvUnit::getCombatDamage
EXTRN	?getDamage@CvUnit@@QBEHXZ:PROC			; CvUnit::getDamage
EXTRN	?getStrengthValue@CvCity@@QBEH_N@Z:PROC		; CvCity::getStrengthValue
EXTRN	?GetMaxAttackStrength@CvUnit@@QBEHPBVCvPlot@@0PBV1@@Z:PROC ; CvUnit::GetMaxAttackStrength
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	?GetMaxHitPoints@CvCity@@QBEHXZ:PROC		; CvCity::GetMaxHitPoints
EXTRN	?setPlot@CvCombatInfo@@QAEXPAVCvPlot@@@Z:PROC	; CvCombatInfo::setPlot
EXTRN	?setUnit@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z:PROC ; CvCombatInfo::setUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GenerateMeleeCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z
_TEXT	SEGMENT
_isAttackingFromHigherElevation$222167 = -21		; size = 1
_iMaxHP$ = -20						; size = 4
_iAttackerDamageInflicted$222175 = -16			; size = 4
_iDefenderStrength$222168 = -12				; size = 4
_iMaxCityHP$222155 = -12				; size = 4
_bAdvance$222188 = -8					; size = 1
_bIsGlobalXPAwarded$222186 = -8				; size = 1
_iAttackerStrength$222169 = -8				; size = 4
_iAttackerDamageInflicted$222158 = -8			; size = 4
_iDefenderDamageInflicted$222176 = -4			; size = 4
_iDefenderDamageInflicted$222159 = -4			; size = 4
_iDefenderStrength$222157 = -4				; size = 4
_kAttacker$ = 8						; size = 4
_pkDefender$ = 12					; size = 4
_bIsGlobalXPAwarded$222165 = 16				; size = 1
_plot$ = 16						; size = 4
_pkCombatInfo$ = 20					; size = 4
?GenerateMeleeCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z PROC ; CvUnitCombat::GenerateMeleeCombatInfo, COMDAT

; 102  : {

	sub	esp, 24					; 00000018H

; 103  : 	int iMaxHP = GC.getMAX_HIT_POINTS();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	push	ebx
	push	ebp
	push	esi

; 104  : 
; 105  : 	pkCombatInfo->setUnit(BATTLE_UNIT_ATTACKER, &kAttacker);

	mov	esi, DWORD PTR _kAttacker$[esp+32]
	push	edi
	mov	edi, DWORD PTR _pkCombatInfo$[esp+36]
	push	esi
	push	0
	mov	ecx, edi
	mov	DWORD PTR _iMaxHP$[esp+48], eax
	call	?setUnit@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z ; CvCombatInfo::setUnit

; 106  : 	pkCombatInfo->setUnit(BATTLE_UNIT_DEFENDER, pkDefender);

	mov	ebp, DWORD PTR _pkDefender$[esp+36]
	push	ebp
	push	1
	mov	ecx, edi
	call	?setUnit@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z ; CvCombatInfo::setUnit

; 107  : 	pkCombatInfo->setPlot(&plot);

	mov	ebx, DWORD PTR _plot$[esp+36]
	push	ebx
	mov	ecx, edi
	call	?setPlot@CvCombatInfo@@QAEXPAVCvPlot@@@Z ; CvCombatInfo::setPlot

; 108  : 
; 109  : 	// Attacking a City
; 110  : 	if(plot.isCity())

	mov	eax, DWORD PTR [ebx+104]
	test	eax, eax
	jl	$LN143@GenerateMe
	cmp	eax, 64					; 00000040H
	jge	$LN143@GenerateMe
	mov	ecx, DWORD PTR [ebx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	$LN143@GenerateMe

; 111  : 	{
; 112  : 		// Unit vs. City (non-ranged so the city will retaliate
; 113  : 		CvCity* pkCity = plot.getPlotCity();

	mov	eax, DWORD PTR [ebx+104]
	test	eax, eax
	jl	SHORT $LN46@GenerateMe
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN46@GenerateMe
	mov	edx, DWORD PTR [ebx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	ebp, eax
	jmp	SHORT $LN47@GenerateMe
$LN46@GenerateMe:
	xor	ebp, ebp
$LN47@GenerateMe:

; 114  : 		int iMaxCityHP = pkCity->GetMaxHitPoints();

	mov	ecx, ebp
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints

; 115  : 
; 116  : 		int iAttackerStrength = kAttacker.GetMaxAttackStrength(kAttacker.plot(), &plot, NULL);

	push	0
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR _iMaxCityHP$222155[esp+48], eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, esi
	call	?GetMaxAttackStrength@CvUnit@@QBEHPBVCvPlot@@0PBV1@@Z ; CvUnit::GetMaxAttackStrength

; 117  : 		int iDefenderStrength = pkCity->getStrengthValue();

	push	0
	mov	ecx, ebp
	mov	ebx, eax
	call	?getStrengthValue@CvCity@@QBEH_N@Z	; CvCity::getStrengthValue

; 118  : 
; 119  : 		int iAttackerDamageInflicted = kAttacker.getCombatDamage(iAttackerStrength, iDefenderStrength, kAttacker.getDamage(), /*bIncludeRand*/ true, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ true);

	push	1
	push	0
	push	1
	mov	ecx, esi
	mov	DWORD PTR _iDefenderStrength$222157[esp+52], eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	push	eax
	mov	eax, DWORD PTR _iDefenderStrength$222157[esp+56]
	push	eax
	push	ebx
	mov	ecx, esi
	call	?getCombatDamage@CvUnit@@QBEHHHH_N00@Z	; CvUnit::getCombatDamage

; 120  : 		int iDefenderDamageInflicted = kAttacker.getCombatDamage(iDefenderStrength, iAttackerStrength, pkCity->getDamage(), /*bIncludeRand*/ true, /*bAttackerIsCity*/ true, /*bDefenderIsCity*/ false);

	push	0
	push	1
	push	1
	mov	ecx, ebp
	mov	DWORD PTR _iAttackerDamageInflicted$222158[esp+52], eax
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	mov	ecx, DWORD PTR _iDefenderStrength$222157[esp+52]
	push	eax
	push	ebx
	push	ecx
	mov	ecx, esi
	call	?getCombatDamage@CvUnit@@QBEHHHH_N00@Z	; CvUnit::getCombatDamage

; 121  : 
; 122  : 		int iAttackerTotalDamageInflicted = iAttackerDamageInflicted + pkCity->getDamage();

	mov	ecx, ebp
	mov	DWORD PTR _iDefenderDamageInflicted$222159[esp+40], eax
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	mov	ebx, eax
	add	ebx, DWORD PTR _iAttackerDamageInflicted$222158[esp+40]

; 123  : 		int iDefenderTotalDamageInflicted = iDefenderDamageInflicted + kAttacker.getDamage();

	mov	ecx, esi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	add	eax, DWORD PTR _iDefenderDamageInflicted$222159[esp+40]

; 124  : 
; 125  : 		// Will both the attacker die, and the city fall? If so, the unit wins
; 126  : 		if(iAttackerTotalDamageInflicted >= iMaxCityHP && iDefenderTotalDamageInflicted >= iMaxHP)

	cmp	ebx, DWORD PTR _iMaxCityHP$222155[esp+40]
	jl	SHORT $LN19@GenerateMe
	cmp	eax, DWORD PTR _iMaxHP$[esp+40]
	jl	SHORT $LN19@GenerateMe

; 127  : 		{
; 128  : 			iDefenderDamageInflicted = iMaxHP - kAttacker.getDamage() - 1;

	mov	ecx, esi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ecx, DWORD PTR _iMaxHP$[esp+40]
	mov	edx, eax
	mov	eax, ecx
	sub	eax, edx
	dec	eax
	mov	DWORD PTR _iDefenderDamageInflicted$222159[esp+40], eax

; 129  : 			iDefenderTotalDamageInflicted = iMaxHP - 1;

	lea	eax, DWORD PTR [ecx-1]
$LN19@GenerateMe:

; 130  : 		}
; 131  : 
; 132  : 		pkCombatInfo->setFinalDamage(BATTLE_UNIT_ATTACKER, iDefenderTotalDamageInflicted);

	push	eax
	push	0
	mov	ecx, edi
	call	?setFinalDamage@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFinalDamage

; 133  : 		pkCombatInfo->setDamageInflicted(BATTLE_UNIT_ATTACKER, iAttackerDamageInflicted);

	mov	eax, DWORD PTR _iAttackerDamageInflicted$222158[esp+40]
	push	eax
	push	0
	mov	ecx, edi
	call	?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setDamageInflicted

; 134  : 		pkCombatInfo->setFinalDamage(BATTLE_UNIT_DEFENDER, iAttackerTotalDamageInflicted);

	push	ebx
	push	1
	mov	ecx, edi
	call	?setFinalDamage@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFinalDamage

; 135  : 		pkCombatInfo->setDamageInflicted(BATTLE_UNIT_DEFENDER, iDefenderDamageInflicted);

	mov	ecx, DWORD PTR _iDefenderDamageInflicted$222159[esp+40]
	push	ecx
	push	1
	mov	ecx, edi
	call	?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setDamageInflicted

; 136  : 		
; 137  : 		int iExperience = /*5*/ GC.getEXPERIENCE_ATTACKING_CITY_MELEE();
; 138  : 
; 139  : 		pkCombatInfo->setExperience(BATTLE_UNIT_ATTACKER, iExperience);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7548
	push	edx
	push	0
	mov	ecx, edi
	call	?setExperience@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setExperience

; 140  : 		int iMaxExperience = (GET_PLAYER(pkCity->getOwner()).isMinorCiv()) ? 30 : MAX_INT; // NQMP GJS - cap XP from fighting CS to 30

	mov	ecx, DWORD PTR [ebp+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	and	eax, -2147483617			; 8000001fH
	add	eax, 2147483647				; 7fffffffH

; 141  : 		pkCombatInfo->setMaxExperienceAllowed(BATTLE_UNIT_ATTACKER, iMaxExperience);

	push	eax
	push	0
	mov	ecx, edi
	call	?setMaxExperienceAllowed@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setMaxExperienceAllowed

; 142  : 		pkCombatInfo->setInBorders(BATTLE_UNIT_ATTACKER, plot.getOwner() == pkCity->getOwner());

	mov	ebx, DWORD PTR _plot$[esp+36]
	movsx	eax, BYTE PTR [ebx+4]
	cmp	eax, DWORD PTR [ebp+84]
	sete	cl
	movzx	edx, cl
	push	edx
	push	0
	mov	ecx, edi
	call	?setInBorders@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setInBorders

; 143  : #ifdef NQ_NO_GG_POINTS_FROM_CS_OR_BARBS
; 144  : 		bool bIsGlobalXPAwarded = !kAttacker.isBarbarian() && !GET_PLAYER(kAttacker.getOwner()).isMinorCiv() && !pkCity->isBarbarian() && !GET_PLAYER(pkCity->getOwner()).isMinorCiv();

	mov	ecx, esi
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	test	al, al
	jne	SHORT $LN23@GenerateMe
	mov	ecx, DWORD PTR [esi+40]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN23@GenerateMe
	mov	ecx, ebp
	call	?isBarbarian@CvCity@@QBE_NXZ		; CvCity::isBarbarian
	test	al, al
	jne	SHORT $LN23@GenerateMe
	mov	ebp, DWORD PTR [ebp+84]
	imul	ebp, 63236				; 0000f704H
	add	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, ebp
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	mov	BYTE PTR _bIsGlobalXPAwarded$222165[esp+36], 1
	test	al, al
	je	SHORT $LN24@GenerateMe
$LN23@GenerateMe:
	mov	BYTE PTR _bIsGlobalXPAwarded$222165[esp+36], 0
$LN24@GenerateMe:

; 145  : 		pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_ATTACKER, bIsGlobalXPAwarded);

	mov	ebp, DWORD PTR _bIsGlobalXPAwarded$222165[esp+36]
	push	ebp
	push	0
	mov	ecx, edi
	call	?setUpdateGlobal@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setUpdateGlobal

; 146  : #else
; 147  : 		pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_ATTACKER, !kAttacker.isBarbarian());
; 148  : #endif
; 149  : 
; 150  : 		pkCombatInfo->setExperience(BATTLE_UNIT_DEFENDER, 0);

	push	0
	push	1
	mov	ecx, edi
	call	?setExperience@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setExperience

; 151  : 		pkCombatInfo->setMaxExperienceAllowed(BATTLE_UNIT_DEFENDER, kAttacker.maxXPValue());

	mov	ecx, esi
	call	?maxXPValue@CvUnit@@QBEHXZ		; CvUnit::maxXPValue
	push	eax
	push	1
	mov	ecx, edi
	call	?setMaxExperienceAllowed@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setMaxExperienceAllowed

; 152  : 		pkCombatInfo->setInBorders(BATTLE_UNIT_DEFENDER, plot.getOwner() == kAttacker.getOwner());

	movsx	eax, BYTE PTR [ebx+4]
	cmp	eax, DWORD PTR [esi+40]
	sete	cl
	movzx	edx, cl
	push	edx
	push	1
	mov	ecx, edi
	call	?setInBorders@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setInBorders

; 153  : #ifdef NQ_NO_GG_POINTS_FROM_CS_OR_BARBS
; 154  : 		pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_DEFENDER, bIsGlobalXPAwarded);

	push	ebp
	push	1
	mov	ecx, edi
	call	?setUpdateGlobal@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setUpdateGlobal

; 155  : #else
; 156  : 		pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_DEFENDER, !pkCity->isBarbarian());
; 157  : #endif
; 158  : 
; 159  : 		pkCombatInfo->setAttackIsRanged(false);

	push	0
	mov	ecx, edi
	call	?setAttackIsRanged@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setAttackIsRanged

; 160  : 		pkCombatInfo->setDefenderRetaliates(true);
; 161  : 	}
; 162  : 	// Attacking a Unit
; 163  : 	else

	jmp	$LN145@GenerateMe
$LN143@GenerateMe:

; 164  : 	{
; 165  : 		// Unit vs. Unit
; 166  : 		CvAssert(pkDefender != NULL);
; 167  : 
; 168  : #ifdef NQ_HEAVY_CHARGE_DOWNHILL
; 169  : 		bool isAttackingFromHigherElevation;
; 170  : #endif
; 171  : 		int iDefenderStrength = pkDefender->GetMaxDefenseStrength(&plot, &kAttacker);

	push	0
	push	esi
	push	ebx
	mov	ecx, ebp
	call	?GetMaxDefenseStrength@CvUnit@@QBEHPBVCvPlot@@PBV1@_N@Z ; CvUnit::GetMaxDefenseStrength

; 172  : 		int iAttackerStrength = 0;
; 173  : 		if(kAttacker.GetMaxRangedCombatStrength(NULL, /*pCity*/ NULL, true, true) > 0 && kAttacker.getDomainType() == DOMAIN_AIR)

	push	1
	push	1
	push	0
	push	0
	mov	ecx, esi
	mov	DWORD PTR _iDefenderStrength$222168[esp+56], eax
	call	?GetMaxRangedCombatStrength@CvUnit@@QBEHPBV1@PBVCvCity@@_N2@Z ; CvUnit::GetMaxRangedCombatStrength
	test	eax, eax
	jle	SHORT $LN17@GenerateMe
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN17@GenerateMe

; 174  : 		{
; 175  : 			iAttackerStrength = kAttacker.GetMaxRangedCombatStrength(NULL, /*pCity*/ NULL, true, true);

	push	eax
	push	eax
	push	0
	push	0
	mov	ecx, esi
	call	?GetMaxRangedCombatStrength@CvUnit@@QBEHPBV1@PBVCvCity@@_N2@Z ; CvUnit::GetMaxRangedCombatStrength
	mov	ebx, eax

; 176  : 			if(pkDefender->getDomainType() != DOMAIN_AIR)

	mov	ecx, ebp
	mov	DWORD PTR _iAttackerStrength$222169[esp+40], ebx
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	je	SHORT $LN144@GenerateMe

; 177  : 			{
; 178  : 				iDefenderStrength /= 2;

	mov	eax, DWORD PTR _iDefenderStrength$222168[esp+40]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iDefenderStrength$222168[esp+40], eax

; 179  : 			}
; 180  : 		}
; 181  : 		else

	jmp	SHORT $LN144@GenerateMe
$LN17@GenerateMe:

; 182  : 		{
; 183  : 			iAttackerStrength = kAttacker.GetMaxAttackStrength(kAttacker.plot(), &plot, pkDefender);

	push	ebp
	push	ebx
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, esi
	call	?GetMaxAttackStrength@CvUnit@@QBEHPBVCvPlot@@0PBV1@@Z ; CvUnit::GetMaxAttackStrength
	mov	DWORD PTR _iAttackerStrength$222169[esp+40], eax
	mov	ebx, eax
$LN144@GenerateMe:

; 184  : 		}
; 185  : 
; 186  : #ifndef AUI_UNIT_FIX_HEAVY_CHARGE_BONUS_INTEGRATED_INTO_STACKS
; 187  : #ifdef NQ_HEAVY_CHARGE_DOWNHILL
; 188  : 		isAttackingFromHigherElevation =
; 189  : 			(kAttacker.plot()->isMountain() && !pkDefender->plot()->isMountain()) ||
; 190  : 			(kAttacker.plot()->isHills() && pkDefender->plot()->isFlatlands());

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	BYTE PTR [eax+5], 0
	jne	SHORT $LN25@GenerateMe
	mov	ecx, ebp
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	BYTE PTR [eax+5], 0
	jne	SHORT $LN27@GenerateMe
$LN25@GenerateMe:
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	BYTE PTR [eax+5], 1
	jne	SHORT $LN26@GenerateMe
	mov	ecx, ebp
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?isFlatlands@CvPlot@@QBE_NXZ		; CvPlot::isFlatlands
	test	al, al
	je	SHORT $LN26@GenerateMe
$LN27@GenerateMe:
	mov	BYTE PTR _isAttackingFromHigherElevation$222167[esp+40], 1
	jmp	SHORT $LN28@GenerateMe
$LN26@GenerateMe:
	mov	BYTE PTR _isAttackingFromHigherElevation$222167[esp+40], 0
$LN28@GenerateMe:

; 191  : 		
; 192  : 		if ((kAttacker.IsCanHeavyCharge() || (kAttacker.GetHeavyChargeDownhill() > 0 && isAttackingFromHigherElevation))
; 193  : 			&& !pkDefender->CanFallBackFromMelee(kAttacker))

	mov	ecx, esi
	call	?IsCanHeavyCharge@CvUnit@@QBE_NXZ	; CvUnit::IsCanHeavyCharge
	test	al, al
	jne	SHORT $LN13@GenerateMe
	mov	ecx, esi
	call	?GetHeavyChargeDownhill@CvUnit@@QBEHXZ	; CvUnit::GetHeavyChargeDownhill
	test	eax, eax
	jle	SHORT $LN14@GenerateMe
	cmp	BYTE PTR _isAttackingFromHigherElevation$222167[esp+40], 0
	je	SHORT $LN14@GenerateMe
$LN13@GenerateMe:
	push	esi
	mov	ecx, ebp
	call	?CanFallBackFromMelee@CvUnit@@IAE_NAAV1@@Z ; CvUnit::CanFallBackFromMelee
	test	al, al
	jne	SHORT $LN14@GenerateMe

; 194  : 		{
; 195  : 			iAttackerStrength = (iAttackerStrength * 150) / 100;

	imul	ebx, 150				; 00000096H
	mov	eax, 1374389535				; 51eb851fH
	imul	ebx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iAttackerStrength$222169[esp+40], eax
	mov	ebx, eax
$LN14@GenerateMe:

; 196  : 		}
; 197  : #else
; 198  : 		if (kAttacker.IsCanHeavyCharge() && !pkDefender->CanFallBackFromMelee(kAttacker))
; 199  : 		{
; 200  : 			iAttackerStrength = (iAttackerStrength * 150) / 100;
; 201  : 		}
; 202  : #endif
; 203  : #endif
; 204  : 
; 205  : 		int iAttackerDamageInflicted = kAttacker.getCombatDamage(iAttackerStrength, iDefenderStrength, kAttacker.getDamage(), /*bIncludeRand*/ true, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ false);

	push	0
	push	0
	push	1
	mov	ecx, esi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ecx, DWORD PTR _iDefenderStrength$222168[esp+52]
	push	eax
	push	ecx
	push	ebx
	mov	ecx, esi
	call	?getCombatDamage@CvUnit@@QBEHHHH_N00@Z	; CvUnit::getCombatDamage

; 206  : 		int iDefenderDamageInflicted = pkDefender->getCombatDamage(iDefenderStrength, iAttackerStrength, pkDefender->getDamage(), /*bIncludeRand*/ true, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ false);

	push	0
	push	0
	push	1
	mov	ecx, ebp
	mov	DWORD PTR _iAttackerDamageInflicted$222175[esp+52], eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	edx, DWORD PTR _iDefenderStrength$222168[esp+52]
	push	eax
	push	ebx
	push	edx
	mov	ecx, ebp
	call	?getCombatDamage@CvUnit@@QBEHHHH_N00@Z	; CvUnit::getCombatDamage
	mov	ebx, eax

; 207  : 
; 208  : 		if(kAttacker.getDomainType() == DOMAIN_AIR && pkDefender->getDomainType() != DOMAIN_AIR)

	mov	ecx, esi
	mov	DWORD PTR _iDefenderDamageInflicted$222176[esp+40], ebx
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN12@GenerateMe
	mov	ecx, ebp
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	je	SHORT $LN12@GenerateMe

; 209  : 		{
; 210  : 			iAttackerDamageInflicted /= 2;

	mov	eax, DWORD PTR _iAttackerDamageInflicted$222175[esp+40]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iAttackerDamageInflicted$222175[esp+40], eax

; 211  : 			iDefenderDamageInflicted /= 3;

	mov	eax, 1431655766				; 55555556H
	imul	ebx
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iDefenderDamageInflicted$222176[esp+40], eax
$LN12@GenerateMe:

; 212  : 		}
; 213  : 
; 214  : 		int iAttackerTotalDamageInflicted = iAttackerDamageInflicted + pkDefender->getDamage();

	mov	ecx, ebp
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ebx, eax
	add	ebx, DWORD PTR _iAttackerDamageInflicted$222175[esp+40]

; 215  : 		int iDefenderTotalDamageInflicted = iDefenderDamageInflicted + kAttacker.getDamage();

	mov	ecx, esi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage

; 216  : 
; 217  : 		// Will both units be killed by this? :o If so, take drastic corrective measures
; 218  : 		if(iAttackerTotalDamageInflicted >= iMaxHP && iDefenderTotalDamageInflicted >= iMaxHP)

	mov	ecx, DWORD PTR _iMaxHP$[esp+40]
	add	eax, DWORD PTR _iDefenderDamageInflicted$222176[esp+40]
	cmp	ebx, ecx
	jl	SHORT $LN9@GenerateMe
	cmp	eax, ecx
	jl	SHORT $LN9@GenerateMe

; 219  : 		{
; 220  : 			// He who hath the least amount of damage survives with 1 HP left
; 221  : 			if(iAttackerTotalDamageInflicted > iDefenderTotalDamageInflicted)

	cmp	ebx, eax
	jle	SHORT $LN10@GenerateMe

; 222  : 			{
; 223  : 				iDefenderDamageInflicted = iMaxHP - kAttacker.getDamage() - 1;

	mov	ecx, esi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ebx, DWORD PTR _iMaxHP$[esp+40]
	mov	ecx, eax
	mov	eax, ebx
	sub	eax, ecx
	dec	eax
	mov	DWORD PTR _iDefenderDamageInflicted$222176[esp+40], eax

; 224  : 				iDefenderTotalDamageInflicted = iMaxHP - 1;

	lea	eax, DWORD PTR [ebx-1]

; 225  : 				iAttackerTotalDamageInflicted = iMaxHP;
; 226  : 			}
; 227  : 			else

	jmp	SHORT $LN9@GenerateMe
$LN10@GenerateMe:

; 228  : 			{
; 229  : 				iAttackerDamageInflicted = iMaxHP - pkDefender->getDamage() - 1;

	mov	ecx, ebp
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	edx, eax
	mov	eax, DWORD PTR _iMaxHP$[esp+40]
	mov	ecx, eax
	sub	ecx, edx
	dec	ecx
	mov	DWORD PTR _iAttackerDamageInflicted$222175[esp+40], ecx

; 230  : 				iAttackerTotalDamageInflicted = iMaxHP - 1;

	lea	ebx, DWORD PTR [eax-1]
$LN9@GenerateMe:

; 231  : 				iDefenderTotalDamageInflicted = iMaxHP;
; 232  : 			}
; 233  : 		}
; 234  : 
; 235  : 		pkCombatInfo->setFinalDamage(BATTLE_UNIT_ATTACKER, iDefenderTotalDamageInflicted);

	push	eax
	push	0
	mov	ecx, edi
	call	?setFinalDamage@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFinalDamage

; 236  : 		pkCombatInfo->setDamageInflicted(BATTLE_UNIT_ATTACKER, iAttackerDamageInflicted);

	mov	eax, DWORD PTR _iAttackerDamageInflicted$222175[esp+40]
	push	eax
	push	0
	mov	ecx, edi
	call	?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setDamageInflicted

; 237  : 		pkCombatInfo->setFinalDamage(BATTLE_UNIT_DEFENDER, iAttackerTotalDamageInflicted);

	push	ebx
	push	1
	mov	ecx, edi
	call	?setFinalDamage@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFinalDamage

; 238  : 		pkCombatInfo->setDamageInflicted(BATTLE_UNIT_DEFENDER, iDefenderDamageInflicted);

	mov	ecx, DWORD PTR _iDefenderDamageInflicted$222176[esp+40]
	push	ecx
	push	1
	mov	ecx, edi
	call	?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setDamageInflicted

; 239  : 
; 240  : 		// Fear Damage
; 241  : 		pkCombatInfo->setFearDamageInflicted(BATTLE_UNIT_ATTACKER, kAttacker.getCombatDamage(iAttackerStrength, iDefenderStrength, kAttacker.getDamage(), true, false, true));

	push	1
	push	0
	push	1
	mov	ecx, esi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	edx, DWORD PTR _iDefenderStrength$222168[esp+52]
	push	eax
	mov	eax, DWORD PTR _iAttackerStrength$222169[esp+56]
	push	edx
	push	eax
	mov	ecx, esi
	call	?getCombatDamage@CvUnit@@QBEHHHH_N00@Z	; CvUnit::getCombatDamage
	push	eax
	push	0
	mov	ecx, edi
	call	?setFearDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFearDamageInflicted

; 242  : 		//	pkCombatInfo->setFearDamageInflicted( BATTLE_UNIT_DEFENDER, getCombatDamage(iDefenderStrength, iAttackerStrength, pDefender->getDamage(), true, false, true) );
; 243  : 
; 244  : #ifndef NQM_PRUNING
; 245  : 		int iAttackerEffectiveStrength = iAttackerStrength * (iMaxHP - range(kAttacker.getDamage(), 0, iMaxHP-1)) / iMaxHP;

	mov	ecx, esi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage

; 246  : 		iAttackerEffectiveStrength = iAttackerEffectiveStrength > 0 ? iAttackerEffectiveStrength : 1;
; 247  : 		int iDefenderEffectiveStrength = iDefenderStrength * (iMaxHP - range(pkDefender->getDamage(), 0, iMaxHP-1)) / iMaxHP;

	mov	ecx, ebp
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage

; 248  : 		iDefenderEffectiveStrength = iDefenderEffectiveStrength > 0 ? iDefenderEffectiveStrength : 1;
; 249  : #endif
; 250  : 
; 251  : 		//int iExperience = kAttacker.defenseXPValue();
; 252  : 		//iExperience = ((iExperience * iAttackerEffectiveStrength) / iDefenderEffectiveStrength); // is this right? looks like more for less [Jon: Yes, it's XP for the defender]
; 253  : 		//iExperience = range(iExperience, GC.getMIN_EXPERIENCE_PER_COMBAT(), GC.getMAX_EXPERIENCE_PER_COMBAT());
; 254  : 		int iExperience = /*4*/ GC.getEXPERIENCE_DEFENDING_UNIT_MELEE();
; 255  : 		pkCombatInfo->setExperience(BATTLE_UNIT_DEFENDER, iExperience);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7516
	push	ecx
	push	1
	mov	ecx, edi
	call	?setExperience@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setExperience

; 256  : 		pkCombatInfo->setMaxExperienceAllowed(BATTLE_UNIT_DEFENDER, kAttacker.maxXPValue());

	mov	ecx, esi
	call	?maxXPValue@CvUnit@@QBEHXZ		; CvUnit::maxXPValue
	push	eax
	push	1
	mov	ecx, edi
	call	?setMaxExperienceAllowed@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setMaxExperienceAllowed

; 257  : 		pkCombatInfo->setInBorders(BATTLE_UNIT_DEFENDER, plot.getOwner() == pkDefender->getOwner());

	mov	edx, DWORD PTR _plot$[esp+36]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, DWORD PTR [ebp+40]
	sete	cl
	movzx	edx, cl
	push	edx
	push	1
	mov	ecx, edi
	call	?setInBorders@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setInBorders

; 258  : #ifdef NQ_NO_GG_POINTS_FROM_CS_OR_BARBS
; 259  : 		bool bIsGlobalXPAwarded = !kAttacker.isBarbarian() && !GET_PLAYER(kAttacker.getOwner()).isMinorCiv() && !pkDefender->isBarbarian() && !GET_PLAYER(pkDefender->getOwner()).isMinorCiv();

	mov	ecx, esi
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	test	al, al
	jne	SHORT $LN33@GenerateMe
	mov	ecx, DWORD PTR [esi+40]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN33@GenerateMe
	mov	ecx, ebp
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	test	al, al
	jne	SHORT $LN33@GenerateMe
	mov	ecx, DWORD PTR [ebp+40]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	mov	BYTE PTR _bIsGlobalXPAwarded$222186[esp+40], 1
	test	al, al
	je	SHORT $LN34@GenerateMe
$LN33@GenerateMe:
	mov	BYTE PTR _bIsGlobalXPAwarded$222186[esp+40], 0
$LN34@GenerateMe:

; 260  : 		pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_DEFENDER, bIsGlobalXPAwarded);

	mov	eax, DWORD PTR _bIsGlobalXPAwarded$222186[esp+40]
	push	eax
	push	1
	mov	ecx, edi
	call	?setUpdateGlobal@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setUpdateGlobal

; 261  : #else
; 262  : 		pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_DEFENDER, !kAttacker.isBarbarian());
; 263  : #endif
; 264  : 
; 265  : 		//iExperience = ((iExperience * iDefenderEffectiveStrength) / iAttackerEffectiveStrength);
; 266  : 		//iExperience = range(iExperience, GC.getMIN_EXPERIENCE_PER_COMBAT(), GC.getMAX_EXPERIENCE_PER_COMBAT());
; 267  : 		iExperience = /*6*/ GC.getEXPERIENCE_ATTACKING_UNIT_MELEE();
; 268  : 		pkCombatInfo->setExperience(BATTLE_UNIT_ATTACKER, iExperience);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7512
	push	ecx
	push	0
	mov	ecx, edi
	call	?setExperience@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setExperience

; 269  : 		pkCombatInfo->setMaxExperienceAllowed(BATTLE_UNIT_ATTACKER, pkDefender->maxXPValue());

	mov	ecx, ebp
	call	?maxXPValue@CvUnit@@QBEHXZ		; CvUnit::maxXPValue
	push	eax
	push	0
	mov	ecx, edi
	call	?setMaxExperienceAllowed@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setMaxExperienceAllowed

; 270  : 		pkCombatInfo->setInBorders(BATTLE_UNIT_ATTACKER, plot.getOwner() == kAttacker.getOwner());

	mov	edx, DWORD PTR _plot$[esp+36]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, DWORD PTR [esi+40]
	sete	cl
	movzx	edx, cl
	push	edx
	push	0
	mov	ecx, edi
	call	?setInBorders@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setInBorders

; 271  : #ifdef NQ_NO_GG_POINTS_FROM_CS_OR_BARBS
; 272  : 		pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_ATTACKER, bIsGlobalXPAwarded);

	mov	eax, DWORD PTR _bIsGlobalXPAwarded$222186[esp+40]
	push	eax
	push	0
	mov	ecx, edi
	call	?setUpdateGlobal@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setUpdateGlobal

; 273  : #else
; 274  : 		pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_ATTACKER, !pkDefender->isBarbarian());
; 275  : #endif
; 276  : 
; 277  : 		pkCombatInfo->setAttackIsRanged(false);

	push	0
	mov	ecx, edi
	call	?setAttackIsRanged@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setAttackIsRanged

; 278  : 
; 279  : #ifdef NQ_HEAVY_CHARGE_DOWNHILL
; 280  : 		isAttackingFromHigherElevation = false;
; 281  : 		if (kAttacker.GetHeavyChargeDownhill() > 0)

	mov	ecx, esi
	mov	BYTE PTR _isAttackingFromHigherElevation$222167[esp+40], 0
	call	?GetHeavyChargeDownhill@CvUnit@@QBEHXZ	; CvUnit::GetHeavyChargeDownhill
	test	eax, eax
	jle	SHORT $LN38@GenerateMe

; 282  : 		{
; 283  : 			isAttackingFromHigherElevation = 
; 284  : 				(kAttacker.plot()->isMountain() && !pkDefender->plot()->isMountain()) ||
; 285  : 				(kAttacker.plot()->isHills() && pkDefender->plot()->isFlatlands());

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	BYTE PTR [eax+5], 0
	jne	SHORT $LN35@GenerateMe
	mov	ecx, ebp
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	BYTE PTR [eax+5], 0
	jne	SHORT $LN37@GenerateMe
$LN35@GenerateMe:
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	BYTE PTR [eax+5], 1
	jne	SHORT $LN36@GenerateMe
	mov	ecx, ebp
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?isFlatlands@CvPlot@@QBE_NXZ		; CvPlot::isFlatlands
	test	al, al
	je	SHORT $LN36@GenerateMe
$LN37@GenerateMe:
	mov	BYTE PTR _isAttackingFromHigherElevation$222167[esp+40], 1
	jmp	SHORT $LN38@GenerateMe
$LN36@GenerateMe:
	mov	BYTE PTR _isAttackingFromHigherElevation$222167[esp+40], 0
$LN38@GenerateMe:

; 286  : 		}
; 287  : #endif
; 288  : 		bool bAdvance = true;
; 289  : 		if(plot.getNumDefenders(pkDefender->getOwner()) > 1)

	mov	eax, DWORD PTR [ebp+40]
	mov	ecx, DWORD PTR _plot$[esp+36]
	push	eax
	mov	BYTE PTR _bAdvance$222188[esp+44], 1
	call	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumDefenders
	cmp	eax, 1
	jle	SHORT $LN7@GenerateMe

; 290  : 		{
; 291  : 			bAdvance = false;

	mov	BYTE PTR _bAdvance$222188[esp+40], 0
	jmp	$LN2@GenerateMe
$LN7@GenerateMe:

; 292  : 		}
; 293  : 		else if(iAttackerTotalDamageInflicted >= iMaxHP && kAttacker.IsCaptureDefeatedEnemy() && kAttacker.AreUnitsOfSameType(*pkDefender))

	cmp	ebx, DWORD PTR _iMaxHP$[esp+40]
	jl	SHORT $LN5@GenerateMe
	mov	ecx, esi
	call	?IsCaptureDefeatedEnemy@CvUnit@@QBE_NXZ	; CvUnit::IsCaptureDefeatedEnemy
	test	al, al
	je	SHORT $LN5@GenerateMe
	push	0
	push	ebp
	mov	ecx, esi
	call	?AreUnitsOfSameType@CvUnit@@QBE_NABV1@_N@Z ; CvUnit::AreUnitsOfSameType
	test	al, al
	je	SHORT $LN5@GenerateMe

; 294  : 		{
; 295  : 			int iCaptureRoll = GC.getGame().getJonRandNum(100, "Capture Enemy Roll");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG222193
	push	100					; 00000064H
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 296  : 
; 297  : 			if (iCaptureRoll < kAttacker.GetCaptureChance(pkDefender))

	push	ebp
	mov	ecx, esi
	mov	ebx, eax
	call	?GetCaptureChance@CvUnit@@QAEHPAV1@@Z	; CvUnit::GetCaptureChance
	cmp	ebx, eax
	jge	SHORT $LN2@GenerateMe

; 298  : 			{
; 299  : 				bAdvance = false;
; 300  : 				pkCombatInfo->setDefenderCaptured(true);

	push	1
	mov	ecx, edi
	mov	BYTE PTR _bAdvance$222188[esp+44], 0
	call	?setDefenderCaptured@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setDefenderCaptured

; 301  : 			}
; 302  : 		}
; 303  : #ifdef NQ_HEAVY_CHARGE_DOWNHILL
; 304  : 		else if ((kAttacker.IsCanHeavyCharge() || (kAttacker.GetHeavyChargeDownhill() > 0 && isAttackingFromHigherElevation))

	jmp	SHORT $LN2@GenerateMe
$LN5@GenerateMe:

; 305  : 			&& !pkDefender->isDelayedDeath() && (iAttackerDamageInflicted > iDefenderDamageInflicted) )

	mov	ecx, esi
	call	?IsCanHeavyCharge@CvUnit@@QBE_NXZ	; CvUnit::IsCanHeavyCharge
	test	al, al
	jne	SHORT $LN1@GenerateMe
	mov	ecx, esi
	call	?GetHeavyChargeDownhill@CvUnit@@QBEHXZ	; CvUnit::GetHeavyChargeDownhill
	test	eax, eax
	jle	SHORT $LN2@GenerateMe
	cmp	BYTE PTR _isAttackingFromHigherElevation$222167[esp+40], 0
	je	SHORT $LN2@GenerateMe
$LN1@GenerateMe:
	mov	ecx, ebp
	call	?isDelayedDeath@CvUnit@@QBE_NXZ		; CvUnit::isDelayedDeath
	test	al, al
	jne	SHORT $LN2@GenerateMe
	mov	ecx, DWORD PTR _iDefenderDamageInflicted$222176[esp+40]
	cmp	DWORD PTR _iAttackerDamageInflicted$222175[esp+40], ecx
	jle	SHORT $LN2@GenerateMe

; 306  : #else
; 307  : 		else if (kAttacker.IsCanHeavyCharge() && !pkDefender->isDelayedDeath() && (iAttackerDamageInflicted > iDefenderDamageInflicted) )
; 308  : #endif
; 309  : 		{
; 310  : 			bAdvance = true;

	mov	BYTE PTR _bAdvance$222188[esp+40], 1
$LN2@GenerateMe:

; 311  : 		}
; 312  : 
; 313  : 		pkCombatInfo->setAttackerAdvances(bAdvance);

	mov	edx, DWORD PTR _bAdvance$222188[esp+40]
	push	edx
	mov	ecx, edi
	call	?setAttackerAdvances@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setAttackerAdvances
$LN145@GenerateMe:

; 314  : 		pkCombatInfo->setDefenderRetaliates(true);

	push	1
	mov	ecx, edi
	call	?setDefenderRetaliates@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setDefenderRetaliates

; 315  : 	}
; 316  : 
; 317  : 	GC.GetEngineUserInterface()->setDirty(UnitInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	19					; 00000013H
	call	edx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 318  : }

	add	esp, 24					; 00000018H
	ret	0
?GenerateMeleeCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z ENDP ; CvUnitCombat::GenerateMeleeCombatInfo
_TEXT	ENDS
PUBLIC	?GenerateRangedCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z ; CvUnitCombat::GenerateRangedCombatInfo
EXTRN	?isRangedSupportFire@CvUnit@@QBE_NXZ:PROC	; CvUnit::isRangedSupportFire
EXTRN	?GetRangeCombatDamage@CvUnit@@QBEHPBV1@PAVCvCity@@_NH@Z:PROC ; CvUnit::GetRangeCombatDamage
; Function compile flags: /Ogtpy
;	COMDAT ?GenerateRangedCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z
_TEXT	SEGMENT
$T226539 = -16						; size = 4
$T226506 = -16						; size = 4
$T226504 = -16						; size = 4
_iTotalDamage$ = -16					; size = 4
_iExperience$ = -12					; size = 4
_eDefenderOwner$ = -8					; size = 4
tv374 = -4						; size = 4
tv162 = -4						; size = 4
$T226507 = -4						; size = 4
$T226505 = -4						; size = 4
_kAttacker$ = 8						; size = 4
_pkDefender$ = 12					; size = 4
_bIsGlobalXPAwarded$ = 16				; size = 1
_plot$ = 16						; size = 4
_pkCombatInfo$ = 20					; size = 4
?GenerateRangedCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z PROC ; CvUnitCombat::GenerateRangedCombatInfo, COMDAT

; 599  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp

; 600  : 	pkCombatInfo->setUnit(BATTLE_UNIT_ATTACKER, &kAttacker);

	mov	ebp, DWORD PTR _kAttacker$[esp+20]
	push	esi
	mov	esi, DWORD PTR _pkCombatInfo$[esp+24]
	push	edi
	push	ebp
	push	0
	mov	ecx, esi
	call	?setUnit@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z ; CvCombatInfo::setUnit

; 601  : 	pkCombatInfo->setUnit(BATTLE_UNIT_DEFENDER, pkDefender);

	mov	ebx, DWORD PTR _pkDefender$[esp+28]
	push	ebx
	push	1
	mov	ecx, esi
	call	?setUnit@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z ; CvCombatInfo::setUnit

; 602  : 	pkCombatInfo->setPlot(&plot);

	mov	edi, DWORD PTR _plot$[esp+28]
	push	edi
	mov	ecx, esi
	call	?setPlot@CvCombatInfo@@QAEXPAVCvPlot@@@Z ; CvCombatInfo::setPlot

; 603  : 
; 604  : 	//////////////////////////////////////////////////////////////////////
; 605  : 
; 606  : 	bool bBarbarian = false;
; 607  : 	int iExperience = 0;
; 608  : 	int iMaxXP = 0;
; 609  : 	int iDamage = 0;
; 610  : 	int iTotalDamage = 0;
; 611  : #ifdef DEL_RANGED_COUNTERATTACKS
; 612  : 	int iDamageToAttacker = 0;
; 613  : 	int iTotalDamageToAttacker = 0;
; 614  : 	const CvPlot* pFromPlot = kAttacker.plot();
; 615  : 	const int iMaxHP = GC.getMAX_HIT_POINTS();
; 616  : #endif
; 617  : 	PlayerTypes eDefenderOwner;
; 618  : 	if(!plot.isCity())

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	jl	SHORT $LN85@GenerateRa
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN85@GenerateRa
	mov	ecx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	$LN8@GenerateRa
$LN85@GenerateRa:

; 619  : 	{
; 620  : 		CvAssert(pkDefender != NULL);
; 621  : 
; 622  : 		eDefenderOwner = pkDefender->getOwner();

	mov	edx, DWORD PTR [ebx+40]

; 623  : 
; 624  : 		iExperience = /*2*/ GC.getEXPERIENCE_ATTACKING_UNIT_RANGED();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7528

; 625  : 		if(pkDefender->isBarbarian())

	mov	ecx, ebx
	mov	DWORD PTR _eDefenderOwner$[esp+32], edx
	mov	DWORD PTR _iExperience$[esp+32], eax
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian

; 626  : 			bBarbarian = true;
; 627  : 		iMaxXP = pkDefender->maxXPValue();

	mov	ecx, ebx
	call	?maxXPValue@CvUnit@@QBEHXZ		; CvUnit::maxXPValue

; 628  : 
; 629  : 		//CvAssert(pkDefender->IsCanDefend());
; 630  : 
; 631  : 		iDamage = kAttacker.GetRangeCombatDamage(pkDefender, /*pCity*/ NULL, /*bIncludeRand*/ true);

	push	0
	push	1
	push	0
	push	ebx
	mov	ecx, ebp
	mov	edi, eax
	call	?GetRangeCombatDamage@CvUnit@@QBEHPBV1@PAVCvCity@@_NH@Z ; CvUnit::GetRangeCombatDamage

; 632  : #ifdef DEL_RANGED_COUNTERATTACKS
; 633  : 		iTotalDamage = pkDefender->getDamage() + iDamage;
; 634  : 
; 635  : 		if (GC.getGame().isOption("GAMEOPTION_ENABLE_RANGED_COUNTERATTACKS"))
; 636  : 		{
; 637  : 			if (!kAttacker.isRangedSupportFire() && !pkDefender->IsCityAttackOnly() &&
; 638  : 				// Ranged unit counterattacks
; 639  : 				(pkDefender->canRangeStrike() && pkDefender->canEverRangeStrikeAt(pFromPlot->getX(), pFromPlot->getY())) || 
; 640  : 				// Melee unit counterattacks
; 641  : 				(pkDefender->IsCanAttackWithMove() && plot.isAdjacent(pFromPlot) && pkDefender->PlotValid(pFromPlot) && pkDefender->PlotValid(&plot)))
; 642  : 			{
; 643  : 				if (pkDefender->IsCanAttackRanged())
; 644  : 				{
; 645  : 					iDamageToAttacker = pkDefender->GetRangeCombatDamage(&kAttacker, NULL, true);
; 646  : 				}
; 647  : 				else if (iTotalDamage < iMaxHP)
; 648  : 				{
; 649  : 					// Melee unit (defender) is counterattacking by attacking into the plot from which they were bombarded, where the attacker is
; 650  : 					int iAttackerStrength = kAttacker.GetMaxDefenseStrength(pFromPlot, pkDefender);
; 651  : 					int iDefenderStrength = pkDefender->GetMaxAttackStrength(&plot, pFromPlot, &kAttacker);
; 652  : 					iDamageToAttacker = pkDefender->getCombatDamage(iDefenderStrength, iAttackerStrength, iTotalDamage, /*bIncludeRand*/ true, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ false);
; 653  : 				}
; 654  : 			}
; 655  : 
; 656  : 			iTotalDamageToAttacker = iDamageToAttacker + kAttacker.getDamage();
; 657  : 
; 658  : 			// Will both units be killed by this? If so, take drastic corrective measures
; 659  : 			if (iTotalDamage >= iMaxHP && iTotalDamageToAttacker >= iMaxHP)
; 660  : 			{
; 661  : 				// He who hath the least amount of damage survives with 1 HP left
; 662  : 				if (iTotalDamage > iTotalDamageToAttacker)
; 663  : 				{
; 664  : 					iDamageToAttacker = iMaxHP - kAttacker.getDamage() - 1;
; 665  : 					iTotalDamageToAttacker = iMaxHP - 1;
; 666  : 					iTotalDamage = iMaxHP;
; 667  : 				}
; 668  : 				else
; 669  : 				{
; 670  : 					iDamage = iMaxHP - pkDefender->getDamage() - 1;
; 671  : 					iTotalDamage = iMaxHP - 1;
; 672  : 					iTotalDamageToAttacker = iMaxHP;
; 673  : 				}
; 674  : 			}
; 675  : 		}
; 676  : #else
; 677  : 		if(iDamage + pkDefender->getDamage() > GC.getMAX_HIT_POINTS())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	DWORD PTR $T226539[esp+32], ecx
	mov	ecx, ebx
	mov	ebp, eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	add	eax, ebp
	cmp	eax, DWORD PTR $T226539[esp+32]
	jle	SHORT $LN6@GenerateRa

; 678  : 		{
; 679  : 			iDamage = GC.getMAX_HIT_POINTS() - pkDefender->getDamage();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, ebx
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	sub	ebp, eax
$LN6@GenerateRa:

; 680  : 		}
; 681  : 
; 682  : 		iTotalDamage = std::max(pkDefender->getDamage(), pkDefender->getDamage() + iDamage);

	mov	ecx, ebx
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	add	eax, ebp
	mov	ecx, ebx
	mov	DWORD PTR $T226504[esp+32], eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	cmp	eax, DWORD PTR $T226504[esp+32]
	mov	DWORD PTR $T226505[esp+32], eax
	lea	eax, DWORD PTR $T226504[esp+32]
	jl	$LN35@GenerateRa
	lea	eax, DWORD PTR $T226505[esp+32]

; 683  : #endif
; 684  : 	}
; 685  : 	else

	jmp	$LN35@GenerateRa
$LN8@GenerateRa:

; 686  : 	{
; 687  : 		if (kAttacker.isRangedSupportFire()) return; // can't attack cities with this

	mov	ecx, ebp
	call	?isRangedSupportFire@CvUnit@@QBE_NXZ	; CvUnit::isRangedSupportFire
	test	al, al
	jne	$LN9@GenerateRa

; 688  : 
; 689  : 		CvCity* pCity = plot.getPlotCity();

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	jl	$LN9@GenerateRa
	cmp	eax, 64					; 00000040H
	jge	$LN9@GenerateRa
	mov	ecx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	ebx, eax

; 690  : 		CvAssert(pCity != NULL);
; 691  : 		if(!pCity) return;

	test	ebx, ebx
	je	$LN9@GenerateRa

; 692  : 
; 693  : 		eDefenderOwner = plot.getOwner();
; 694  : 		/*		iDefenderStrength = pCity->getStrengthValue() / 2;
; 695  : 		iOldDamage = pCity->getDamage();*/
; 696  : 
; 697  : 		iExperience = /*3*/ GC.getEXPERIENCE_ATTACKING_CITY_RANGED();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7552
	mov	edx, edi
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _iExperience$[esp+32], ecx

; 698  : 
; 699  : 		if(pCity->isBarbarian())

	mov	ecx, ebx
	mov	DWORD PTR _eDefenderOwner$[esp+32], eax
	call	?isBarbarian@CvCity@@QBE_NXZ		; CvCity::isBarbarian

; 700  : 			bBarbarian = true;
; 701  : 		iMaxXP = (GET_PLAYER(pCity->getOwner()).isMinorCiv()) ? 30 : 1000; // NQMP GJS - cap XP from fighting CS to 30

	mov	ecx, DWORD PTR [ebx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edi, al

; 702  : 
; 703  : 		iDamage = kAttacker.GetRangeCombatDamage(/*pDefender*/ NULL, pCity, /*bIncludeRand*/ true);

	push	0
	neg	edi
	push	1
	sbb	edi, edi
	push	ebx
	and	edi, -970				; fffffc36H
	push	0
	mov	ecx, ebp
	add	edi, 1000				; 000003e8H
	call	?GetRangeCombatDamage@CvUnit@@QBEHPBV1@PAVCvCity@@_NH@Z ; CvUnit::GetRangeCombatDamage

; 704  : 
; 705  : 		// Cities can't be knocked to less than 1 HP
; 706  : 		if(iDamage + pCity->getDamage() >= pCity->GetMaxHitPoints())

	mov	ecx, ebx
	mov	ebp, eax
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	add	eax, ebp
	mov	ecx, ebx
	mov	DWORD PTR tv374[esp+32], eax
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	cmp	DWORD PTR tv374[esp+32], eax
	jl	SHORT $LN1@GenerateRa

; 707  : 		{
; 708  : 			iDamage = pCity->GetMaxHitPoints() - pCity->getDamage() - 1;

	mov	ecx, ebx
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	or	ecx, -1
	sub	ecx, eax
	mov	DWORD PTR tv162[esp+32], ecx
	mov	ecx, ebx
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	mov	ebp, eax
	add	ebp, DWORD PTR tv162[esp+32]
$LN1@GenerateRa:

; 709  : 		}
; 710  : 
; 711  : #ifdef DEL_RANGED_COUNTERATTACKS
; 712  : 		iTotalDamage = pCity->getDamage() + iDamage;
; 713  : 
; 714  : 		if (GC.getGame().isOption("GAMEOPTION_ENABLE_RANGED_COUNTERATTACKS"))
; 715  : 		{
; 716  : 			if (pCity->canRangeStrikeAt(pFromPlot->getX(), pFromPlot->getY(), true))
; 717  : 			{
; 718  : 				iDamageToAttacker = pCity->rangeCombatDamage(&kAttacker, NULL, true);
; 719  : 			}
; 720  : 
; 721  : 			iTotalDamageToAttacker = iDamageToAttacker + kAttacker.getDamage();
; 722  : 		}
; 723  : #else
; 724  : 		iTotalDamage = std::max(pCity->getDamage(), pCity->getDamage() + iDamage);

	mov	ecx, ebx
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	add	eax, ebp
	mov	ecx, ebx
	mov	DWORD PTR $T226506[esp+32], eax
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	cmp	eax, DWORD PTR $T226506[esp+32]
	mov	DWORD PTR $T226507[esp+32], eax
	lea	eax, DWORD PTR $T226506[esp+32]
	jl	SHORT $LN54@GenerateRa
	lea	eax, DWORD PTR $T226507[esp+32]
$LN54@GenerateRa:
	mov	ebx, DWORD PTR _pkDefender$[esp+28]

; 680  : 		}
; 681  : 
; 682  : 		iTotalDamage = std::max(pkDefender->getDamage(), pkDefender->getDamage() + iDamage);

$LN35@GenerateRa:

; 709  : 		}
; 710  : 
; 711  : #ifdef DEL_RANGED_COUNTERATTACKS
; 712  : 		iTotalDamage = pCity->getDamage() + iDamage;
; 713  : 
; 714  : 		if (GC.getGame().isOption("GAMEOPTION_ENABLE_RANGED_COUNTERATTACKS"))
; 715  : 		{
; 716  : 			if (pCity->canRangeStrikeAt(pFromPlot->getX(), pFromPlot->getY(), true))
; 717  : 			{
; 718  : 				iDamageToAttacker = pCity->rangeCombatDamage(&kAttacker, NULL, true);
; 719  : 			}
; 720  : 
; 721  : 			iTotalDamageToAttacker = iDamageToAttacker + kAttacker.getDamage();
; 722  : 		}
; 723  : #else
; 724  : 		iTotalDamage = std::max(pCity->getDamage(), pCity->getDamage() + iDamage);

	mov	edx, DWORD PTR [eax]

; 725  : #endif
; 726  : 	}
; 727  : 	//////////////////////////////////////////////////////////////////////
; 728  : 
; 729  : #ifdef DEL_RANGED_COUNTERATTACKS
; 730  : 	pkCombatInfo->setFinalDamage(BATTLE_UNIT_ATTACKER, iTotalDamageToAttacker);				// Total damage to the unit
; 731  : #else
; 732  : 	pkCombatInfo->setFinalDamage(BATTLE_UNIT_ATTACKER, 0);				// Total damage to the unit

	push	0
	push	0
	mov	ecx, esi
	mov	DWORD PTR _iTotalDamage$[esp+40], edx
	call	?setFinalDamage@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFinalDamage

; 733  : #endif
; 734  : 	pkCombatInfo->setDamageInflicted(BATTLE_UNIT_ATTACKER, iDamage);		// Damage inflicted this round

	push	ebp
	push	0
	mov	ecx, esi
	call	?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setDamageInflicted

; 735  : 	pkCombatInfo->setFinalDamage(BATTLE_UNIT_DEFENDER, iTotalDamage);		// Total damage to the unit

	mov	eax, DWORD PTR _iTotalDamage$[esp+32]
	push	eax
	push	1
	mov	ecx, esi
	call	?setFinalDamage@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFinalDamage

; 736  : #ifdef DEL_RANGED_COUNTERATTACKS
; 737  : 	pkCombatInfo->setDamageInflicted(BATTLE_UNIT_DEFENDER, iDamageToAttacker);			// Damage inflicted this round
; 738  : #else
; 739  : 	pkCombatInfo->setDamageInflicted(BATTLE_UNIT_DEFENDER, 0);			// Damage inflicted this round

	push	0
	push	1
	mov	ecx, esi
	call	?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setDamageInflicted

; 740  : #endif
; 741  : 
; 742  : 	// Fear Damage
; 743  : 	pkCombatInfo->setFearDamageInflicted(BATTLE_UNIT_ATTACKER, 0);

	push	0
	push	0
	mov	ecx, esi
	call	?setFearDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFearDamageInflicted

; 744  : 	// pkCombatInfo->setFearDamageInflicted( BATTLE_UNIT_DEFENDER, 0 );
; 745  : 
; 746  : 	pkCombatInfo->setExperience(BATTLE_UNIT_ATTACKER, iExperience);

	mov	ecx, DWORD PTR _iExperience$[esp+32]
	push	ecx
	push	0
	mov	ecx, esi
	call	?setExperience@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setExperience

; 747  : 	pkCombatInfo->setMaxExperienceAllowed(BATTLE_UNIT_ATTACKER, iMaxXP);

	push	edi
	push	0
	mov	ecx, esi
	call	?setMaxExperienceAllowed@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setMaxExperienceAllowed

; 748  : 	pkCombatInfo->setInBorders(BATTLE_UNIT_ATTACKER, plot.getOwner() == eDefenderOwner);

	mov	ebp, DWORD PTR _plot$[esp+28]
	movsx	edx, BYTE PTR [ebp+4]
	cmp	edx, DWORD PTR _eDefenderOwner$[esp+32]
	sete	al
	movzx	ecx, al
	push	ecx
	push	0
	mov	ecx, esi
	call	?setInBorders@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setInBorders

; 749  : #ifdef NQ_NO_GG_POINTS_FROM_CS_OR_BARBS
; 750  : 	bool bIsGlobalXPAwarded = !kAttacker.isBarbarian() && !GET_PLAYER(kAttacker.getOwner()).isMinorCiv() && 
; 751  : 		(plot.isCity() || (!pkDefender->isBarbarian() && !GET_PLAYER(pkDefender->getOwner()).isMinorCiv())) &&
; 752  : 		(!plot.isCity() || (!plot.getPlotCity()->isBarbarian() && !GET_PLAYER(plot.getPlotCity()->getOwner()).isMinorCiv()));

	mov	edi, DWORD PTR _kAttacker$[esp+28]
	mov	ecx, edi
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	test	al, al
	jne	$LN11@GenerateRa
	mov	ecx, DWORD PTR [edi+40]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN11@GenerateRa
	mov	ecx, ebp
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	test	al, al
	jne	SHORT $LN13@GenerateRa
	mov	ecx, ebx
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	test	al, al
	jne	SHORT $LN11@GenerateRa
	mov	ebx, DWORD PTR [ebx+40]
	imul	ebx, 63236				; 0000f704H
	add	ebx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, ebx
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN11@GenerateRa
$LN13@GenerateRa:
	mov	ecx, ebp
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	test	al, al
	je	SHORT $LN15@GenerateRa
	mov	ecx, ebp
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	ecx, eax
	call	?isBarbarian@CvCity@@QBE_NXZ		; CvCity::isBarbarian
	test	al, al
	jne	SHORT $LN11@GenerateRa
	mov	ecx, ebp
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN11@GenerateRa
$LN15@GenerateRa:
	mov	BYTE PTR _bIsGlobalXPAwarded$[esp+28], 1
	jmp	SHORT $LN16@GenerateRa
$LN11@GenerateRa:
	mov	BYTE PTR _bIsGlobalXPAwarded$[esp+28], 0
$LN16@GenerateRa:

; 753  : 	pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_ATTACKER, bIsGlobalXPAwarded);

	mov	ebx, DWORD PTR _bIsGlobalXPAwarded$[esp+28]
	push	ebx
	push	0
	mov	ecx, esi
	call	?setUpdateGlobal@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setUpdateGlobal

; 754  : #else
; 755  : 	pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_ATTACKER, !kAttacker.isBarbarian());
; 756  : #endif
; 757  : 
; 758  : 	iExperience = /*2*/ GC.getEXPERIENCE_DEFENDING_UNIT_RANGED();
; 759  : 	pkCombatInfo->setExperience(BATTLE_UNIT_DEFENDER, iExperience);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7532
	push	edx
	push	1
	mov	ecx, esi
	call	?setExperience@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setExperience

; 760  : 	pkCombatInfo->setMaxExperienceAllowed(BATTLE_UNIT_DEFENDER, kAttacker.maxXPValue());

	mov	ecx, edi
	call	?maxXPValue@CvUnit@@QBEHXZ		; CvUnit::maxXPValue
	push	eax
	push	1
	mov	ecx, esi
	call	?setMaxExperienceAllowed@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setMaxExperienceAllowed

; 761  : 	pkCombatInfo->setInBorders(BATTLE_UNIT_DEFENDER, plot.getOwner() == kAttacker.getOwner());

	movsx	eax, BYTE PTR [ebp+4]
	cmp	eax, DWORD PTR [edi+40]
	sete	cl
	movzx	edx, cl
	push	edx
	push	1
	mov	ecx, esi
	call	?setInBorders@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setInBorders

; 762  : #ifdef NQ_NO_GG_POINTS_FROM_CS_OR_BARBS
; 763  : 	pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_DEFENDER, bIsGlobalXPAwarded);

	push	ebx
	push	1
	mov	ecx, esi
	call	?setUpdateGlobal@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setUpdateGlobal

; 764  : #else
; 765  : 	pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_DEFENDER, !bBarbarian && !kAttacker.isBarbarian());
; 766  : #endif
; 767  : 
; 768  : 	pkCombatInfo->setAttackIsRanged(true);

	push	1
	mov	ecx, esi
	call	?setAttackIsRanged@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setAttackIsRanged

; 769  : #ifdef DEL_RANGED_COUNTERATTACKS
; 770  : 	pkCombatInfo->setDefenderRetaliates(iDamageToAttacker > 0);
; 771  : #else
; 772  : 	// Defender doesn't retaliate.  We'll keep this separate from the ranged attack flag in case something changes to allow
; 773  : 	// some units to retaliate on a ranged attack (Archer vs. Archers maybe?)
; 774  : 	pkCombatInfo->setDefenderRetaliates(false);

	push	0
	mov	ecx, esi
	call	?setDefenderRetaliates@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setDefenderRetaliates

; 775  : #endif
; 776  : 
; 777  : 	GC.GetEngineUserInterface()->setDirty(UnitInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	19					; 00000013H
	call	edx
$LN9@GenerateRa:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 778  : }

	add	esp, 16					; 00000010H
	ret	0
?GenerateRangedCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z ENDP ; CvUnitCombat::GenerateRangedCombatInfo
_TEXT	ENDS
PUBLIC	?GenerateRangedCombatInfo@CvUnitCombat@@SAXAAVCvCity@@PAVCvUnit@@AAVCvPlot@@PAVCvCombatInfo@@@Z ; CvUnitCombat::GenerateRangedCombatInfo
EXTRN	?rangeCombatDamage@CvCity@@QBEHPBVCvUnit@@PAV1@_N@Z:PROC ; CvCity::rangeCombatDamage
EXTRN	?setCity@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvCity@@@Z:PROC ; CvCombatInfo::setCity
; Function compile flags: /Ogtpy
;	COMDAT ?GenerateRangedCombatInfo@CvUnitCombat@@SAXAAVCvCity@@PAVCvUnit@@AAVCvPlot@@PAVCvCombatInfo@@@Z
_TEXT	SEGMENT
_eDefenderOwner$ = -8					; size = 4
$T226658 = -4						; size = 4
$T226683 = 8						; size = 4
$T226657 = 8						; size = 4
_iTotalDamage$ = 8					; size = 4
_kAttacker$ = 8						; size = 4
_pkDefender$ = 12					; size = 4
_bIsGlobalXPAwarded$ = 16				; size = 1
_plot$ = 16						; size = 4
_pkCombatInfo$ = 20					; size = 4
?GenerateRangedCombatInfo@CvUnitCombat@@SAXAAVCvCity@@PAVCvUnit@@AAVCvPlot@@PAVCvCombatInfo@@@Z PROC ; CvUnitCombat::GenerateRangedCombatInfo, COMDAT

; 792  : {

	sub	esp, 8
	push	ebx
	push	ebp

; 793  : 	pkCombatInfo->setCity(BATTLE_UNIT_ATTACKER, &kAttacker);

	mov	ebp, DWORD PTR _kAttacker$[esp+12]
	push	esi
	mov	esi, DWORD PTR _pkCombatInfo$[esp+16]
	push	edi
	push	ebp
	push	0
	mov	ecx, esi
	call	?setCity@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvCity@@@Z ; CvCombatInfo::setCity

; 794  : 	pkCombatInfo->setUnit(BATTLE_UNIT_DEFENDER, pkDefender);

	mov	edi, DWORD PTR _pkDefender$[esp+20]
	push	edi
	push	1
	mov	ecx, esi
	call	?setUnit@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z ; CvCombatInfo::setUnit

; 795  : 	pkCombatInfo->setPlot(&plot);

	mov	eax, DWORD PTR _plot$[esp+20]
	push	eax
	mov	ecx, esi
	call	?setPlot@CvCombatInfo@@QAEXPAVCvPlot@@@Z ; CvCombatInfo::setPlot

; 796  : 
; 797  : 	//////////////////////////////////////////////////////////////////////
; 798  : 
; 799  : 	bool bBarbarian = false;
; 800  : 	int iDamage = 0;
; 801  : 	int iTotalDamage = 0;
; 802  : 	PlayerTypes eDefenderOwner = NO_PLAYER;
; 803  : #ifdef DEL_RANGED_COUNTERATTACKS
; 804  : 	int iDamageToAttacker = 0;
; 805  : 	int iTotalDamageToAttacker = 0;
; 806  : 	const CvPlot* pFromPlot = kAttacker.plot();
; 807  : 	const int iMaxHP = GC.getMAX_HIT_POINTS();
; 808  : #endif
; 809  : 	if(!plot.isCity())

	mov	edx, DWORD PTR _plot$[esp+20]
	mov	eax, DWORD PTR [edx+104]
	xor	ebx, ebx
	mov	DWORD PTR _iTotalDamage$[esp+20], ebx
	mov	DWORD PTR _eDefenderOwner$[esp+24], -1
	test	eax, eax
	jl	SHORT $LN56@GenerateRa@2
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN56@GenerateRa@2
	mov	ecx, DWORD PTR [edx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	SHORT $LN4@GenerateRa@2
$LN56@GenerateRa@2:

; 810  : 	{
; 811  : 		CvAssert(pkDefender != NULL);
; 812  : 
; 813  : 		eDefenderOwner = pkDefender->getOwner();

	mov	edx, DWORD PTR [edi+40]

; 814  : 
; 815  : 		if(pkDefender->isBarbarian())

	mov	ecx, edi
	mov	DWORD PTR _eDefenderOwner$[esp+24], edx
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian

; 816  : 			bBarbarian = true;
; 817  : 
; 818  : 		//CvAssert(pkDefender->IsCanDefend());
; 819  : 
; 820  : 		iDamage = kAttacker.rangeCombatDamage(pkDefender);

	push	1
	push	0
	push	edi
	mov	ecx, ebp
	call	?rangeCombatDamage@CvCity@@QBEHPBVCvUnit@@PAV1@_N@Z ; CvCity::rangeCombatDamage
	mov	ebx, eax

; 821  : 
; 822  : #ifdef DEL_RANGED_COUNTERATTACKS
; 823  : 		iTotalDamage = pkDefender->getDamage() + iDamage;
; 824  : 
; 825  : 		if (GC.getGame().isOption("GAMEOPTION_ENABLE_RANGED_COUNTERATTACKS"))
; 826  : 		{
; 827  : 			if (// Ranged unit counterattacks
; 828  : 				(pkDefender->canRangeStrike() && pkDefender->canEverRangeStrikeAt(pFromPlot->getX(), pFromPlot->getY())) ||
; 829  : 				// Melee unit counterattacks
; 830  : 				(pkDefender->IsCanAttackWithMove() && plot.isAdjacent(pFromPlot) && pkDefender->PlotValid(pFromPlot) && pkDefender->PlotValid(&plot)))
; 831  : 			{
; 832  : 				if (pkDefender->IsCanAttackRanged())
; 833  : 				{
; 834  : 					iDamageToAttacker = pkDefender->GetRangeCombatDamage(NULL, &kAttacker, true);
; 835  : 				}
; 836  : 				else if (iTotalDamage < iMaxHP)
; 837  : 				{
; 838  : 					// Melee unit (defender) is counterattacking by attacking into the plot from which they were bombarded, where the attacker is
; 839  : 					int iAttackerStrength = kAttacker.getStrengthValue();
; 840  : 					int iDefenderStrength = pkDefender->GetMaxAttackStrength(&plot, pFromPlot, NULL);
; 841  : 					iDefenderStrength *= /*40*/ GC.getCITY_RANGED_ATTACK_STRENGTH_MULTIPLIER();
; 842  : 					iDefenderStrength /= 100;
; 843  : 
; 844  : 					// Damage steps: city deals ranged damage to melee unit -> unit deals melee damage to city with the same -60% strength penalty that cities have for ranged attacks
; 845  : 					iDamageToAttacker = pkDefender->getCombatDamage(iDefenderStrength, iAttackerStrength, iTotalDamage, /*bIncludeRand*/ true, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ true);
; 846  : 				}
; 847  : 			}
; 848  : 
; 849  : 			iTotalDamageToAttacker = iDamageToAttacker + kAttacker.getDamage();
; 850  : 
; 851  : 			// Cities can't be knocked to less than 1 HP by counterattacks
; 852  : 			if (iTotalDamageToAttacker >= kAttacker.GetMaxHitPoints())
; 853  : 			{
; 854  : 				iTotalDamageToAttacker = kAttacker.GetMaxHitPoints() - kAttacker.getDamage() - 1;
; 855  : 			}
; 856  : 		}
; 857  : #else
; 858  : 		if(iDamage + pkDefender->getDamage() > GC.getMAX_HIT_POINTS())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, edi
	mov	DWORD PTR $T226683[esp+20], eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	add	eax, ebx
	cmp	eax, DWORD PTR $T226683[esp+20]
	jle	SHORT $LN2@GenerateRa@2

; 859  : 		{
; 860  : 			iDamage = GC.getMAX_HIT_POINTS() - pkDefender->getDamage();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, edi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	sub	ebx, eax
$LN2@GenerateRa@2:

; 861  : 		}
; 862  : 
; 863  : 		iTotalDamage = std::max(pkDefender->getDamage(), pkDefender->getDamage() + iDamage);

	mov	ecx, edi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	add	eax, ebx
	mov	ecx, edi
	mov	DWORD PTR $T226657[esp+20], eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	cmp	eax, DWORD PTR $T226657[esp+20]
	mov	DWORD PTR $T226658[esp+24], eax
	lea	eax, DWORD PTR $T226657[esp+20]
	jl	SHORT $LN25@GenerateRa@2
	lea	eax, DWORD PTR $T226658[esp+24]
$LN25@GenerateRa@2:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iTotalDamage$[esp+20], ecx
$LN4@GenerateRa@2:

; 864  : #endif
; 865  : 	}
; 866  : 	else
; 867  : 	{
; 868  : 		FAssertMsg(false, "City vs. City not supported.");	// Don't even think about it Jon....
; 869  : 	}
; 870  : 
; 871  : 	//////////////////////////////////////////////////////////////////////
; 872  : 
; 873  : #ifdef DEL_RANGED_COUNTERATTACKS
; 874  : 	pkCombatInfo->setFinalDamage(BATTLE_UNIT_ATTACKER, iTotalDamageToAttacker);				// Total damage to the unit
; 875  : #else
; 876  : 	pkCombatInfo->setFinalDamage(BATTLE_UNIT_ATTACKER, 0);				// Total damage to the unit

	push	0
	push	0
	mov	ecx, esi
	call	?setFinalDamage@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFinalDamage

; 877  : #endif
; 878  : 	pkCombatInfo->setDamageInflicted(BATTLE_UNIT_ATTACKER, iDamage);		// Damage inflicted this round

	push	ebx
	push	0
	mov	ecx, esi
	call	?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setDamageInflicted

; 879  : 	pkCombatInfo->setFinalDamage(BATTLE_UNIT_DEFENDER, iTotalDamage);		// Total damage to the unit

	mov	edx, DWORD PTR _iTotalDamage$[esp+20]
	push	edx
	push	1
	mov	ecx, esi
	call	?setFinalDamage@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFinalDamage

; 880  : #ifdef DEL_RANGED_COUNTERATTACKS
; 881  : 	pkCombatInfo->setDamageInflicted(BATTLE_UNIT_DEFENDER, iDamageToAttacker);			// Damage inflicted this round
; 882  : #else
; 883  : 	pkCombatInfo->setDamageInflicted(BATTLE_UNIT_DEFENDER, 0);			// Damage inflicted this round

	push	0
	push	1
	mov	ecx, esi
	call	?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setDamageInflicted

; 884  : #endif
; 885  : 
; 886  : 	// Fear Damage
; 887  : 	pkCombatInfo->setFearDamageInflicted(BATTLE_UNIT_ATTACKER, 0);

	push	0
	push	0
	mov	ecx, esi
	call	?setFearDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFearDamageInflicted

; 888  : 	// pkCombatInfo->setFearDamageInflicted( BATTLE_UNIT_DEFENDER, 0 );
; 889  : 
; 890  : 	pkCombatInfo->setExperience(BATTLE_UNIT_ATTACKER, 0);

	push	0
	push	0
	mov	ecx, esi
	call	?setExperience@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setExperience

; 891  : 	pkCombatInfo->setMaxExperienceAllowed(BATTLE_UNIT_ATTACKER, 0);

	push	0
	push	0
	mov	ecx, esi
	call	?setMaxExperienceAllowed@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setMaxExperienceAllowed

; 892  : 	pkCombatInfo->setInBorders(BATTLE_UNIT_ATTACKER, plot.getOwner() == eDefenderOwner);

	mov	ebx, DWORD PTR _plot$[esp+20]
	movsx	eax, BYTE PTR [ebx+4]
	cmp	eax, DWORD PTR _eDefenderOwner$[esp+24]
	sete	cl
	movzx	edx, cl
	push	edx
	push	0
	mov	ecx, esi
	call	?setInBorders@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setInBorders

; 893  : #ifdef NQ_NO_GG_POINTS_FROM_CS_OR_BARBS
; 894  : 	bool bIsGlobalXPAwarded = !kAttacker.isBarbarian() && !GET_PLAYER(kAttacker.getOwner()).isMinorCiv() && !pkDefender->isBarbarian() && !GET_PLAYER(pkDefender->getOwner()).isMinorCiv();

	mov	ecx, ebp
	call	?isBarbarian@CvCity@@QBE_NXZ		; CvCity::isBarbarian
	test	al, al
	jne	SHORT $LN7@GenerateRa@2
	mov	ecx, DWORD PTR [ebp+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN7@GenerateRa@2
	mov	ecx, edi
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	test	al, al
	jne	SHORT $LN7@GenerateRa@2
	mov	edi, DWORD PTR [edi+40]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, edi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	mov	BYTE PTR _bIsGlobalXPAwarded$[esp+20], 1
	test	al, al
	je	SHORT $LN8@GenerateRa@2
$LN7@GenerateRa@2:
	mov	BYTE PTR _bIsGlobalXPAwarded$[esp+20], 0
$LN8@GenerateRa@2:

; 895  : 	pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_ATTACKER, bIsGlobalXPAwarded);

	mov	edi, DWORD PTR _bIsGlobalXPAwarded$[esp+20]
	push	edi
	push	0
	mov	ecx, esi
	call	?setUpdateGlobal@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setUpdateGlobal

; 896  : #else
; 897  : 	pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_ATTACKER, !kAttacker.isBarbarian());
; 898  : #endif
; 899  : 
; 900  : 	int iExperience = /*2*/ GC.getEXPERIENCE_DEFENDING_UNIT_RANGED();
; 901  : 	pkCombatInfo->setExperience(BATTLE_UNIT_DEFENDER, iExperience);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7532
	push	eax
	push	1
	mov	ecx, esi
	call	?setExperience@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setExperience

; 902  : 	int iMaxExperience = (GET_PLAYER(kAttacker.getOwner()).isMinorCiv()) ? 30 : MAX_INT; // NQMP GJS - cap XP from fighting CS to 30

	mov	ecx, DWORD PTR [ebp+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	and	eax, -2147483617			; 8000001fH
	add	eax, 2147483647				; 7fffffffH

; 903  : 	pkCombatInfo->setMaxExperienceAllowed(BATTLE_UNIT_DEFENDER, iMaxExperience);

	push	eax
	push	1
	mov	ecx, esi
	call	?setMaxExperienceAllowed@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setMaxExperienceAllowed

; 904  : 	pkCombatInfo->setInBorders(BATTLE_UNIT_DEFENDER, plot.getOwner() == kAttacker.getOwner());

	movsx	ecx, BYTE PTR [ebx+4]
	cmp	ecx, DWORD PTR [ebp+84]
	mov	ecx, esi
	sete	dl
	movzx	eax, dl
	push	eax
	push	1
	call	?setInBorders@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setInBorders

; 905  : #ifdef NQ_NO_GG_POINTS_FROM_CS_OR_BARBS
; 906  : 	pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_DEFENDER, bIsGlobalXPAwarded);

	push	edi
	push	1
	mov	ecx, esi
	call	?setUpdateGlobal@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setUpdateGlobal

; 907  : #else
; 908  : 	pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_DEFENDER, !bBarbarian && !kAttacker.isBarbarian());
; 909  : #endif
; 910  : 
; 911  : 	pkCombatInfo->setAttackIsRanged(true);

	push	1
	mov	ecx, esi
	call	?setAttackIsRanged@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setAttackIsRanged

; 912  : #ifdef DEL_RANGED_COUNTERATTACKS
; 913  : 	pkCombatInfo->setDefenderRetaliates(iDamageToAttacker > 0);
; 914  : #else
; 915  : 	// Defender doesn't retaliate.  We'll keep this separate from the ranged attack flag in case something changes to allow
; 916  : 	// some units to retaliate on a ranged attack (Archer vs. Archers maybe?)
; 917  : 	pkCombatInfo->setDefenderRetaliates(false);

	push	0
	mov	ecx, esi
	call	?setDefenderRetaliates@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setDefenderRetaliates

; 918  : #endif
; 919  : 
; 920  : 	GC.GetEngineUserInterface()->setDirty(UnitInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	19					; 00000013H
	call	eax
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 921  : }

	add	esp, 8
	ret	0
?GenerateRangedCombatInfo@CvUnitCombat@@SAXAAVCvCity@@PAVCvUnit@@AAVCvPlot@@PAVCvCombatInfo@@@Z ENDP ; CvUnitCombat::GenerateRangedCombatInfo
_TEXT	ENDS
PUBLIC	?ResolveRangedCityVsUnitCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveRangedCityVsUnitCombat
EXTRN	?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z:PROC	; CvTacticalAI::CombatResolved
EXTRN	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ:PROC ; CvPlayer::GetTacticalAI
EXTRN	?ClearMissionQueue@CvUnit@@QAEXH@Z:PROC		; CvUnit::ClearMissionQueue
EXTRN	?IsHeadMission@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z:PROC ; CvUnitMission::IsHeadMission
EXTRN	?getMISSION_WAIT_FOR@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_WAIT_FOR
EXTRN	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z:PROC	; CvUnit::setCombatUnit
EXTRN	?changeExperience@CvUnit@@QAEXHH_N00@Z:PROC	; CvUnit::changeExperience
EXTRN	?getExperience@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z:PROC ; CvCombatInfo::getExperience
EXTRN	?getMaxExperienceAllowed@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z:PROC ; CvCombatInfo::getMaxExperienceAllowed
EXTRN	?getInBorders@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z:PROC ; CvCombatInfo::getInBorders
EXTRN	?getUpdateGlobal@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z:PROC ; CvCombatInfo::getUpdateGlobal
EXTRN	?changeDamage@CvUnit@@QAEHHW4PlayerTypes@@MPBVCvString@@@Z:PROC ; CvUnit::changeDamage
EXTRN	?DoYieldsFromKill@CvPlayer@@QAEXW4UnitTypes@@0HH_NH@Z:PROC ; CvPlayer::DoYieldsFromKill
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ:PROC	; CvUnit::getUnitType
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDXZ:PROC
EXTRN	?getNameKey@CvCity@@QBEPBDXZ:PROC		; CvCity::getNameKey
EXTRN	?getNameKey@CvUnit@@QBEPBDXZ:PROC		; CvUnit::getNameKey
EXTRN	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z:PROC ; CvCombatInfo::getUnit
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
EXTRN	?getPlot@CvCombatInfo@@QBEPAVCvPlot@@XZ:PROC	; CvCombatInfo::getPlot
EXTRN	?clearCombat@CvCity@@QAEXXZ:PROC		; CvCity::clearCombat
EXTRN	?getCity@CvCombatInfo@@QBEPAVCvCity@@W4BattleUnitTypes@@@Z:PROC ; CvCombatInfo::getCity
EXTRN	?getDamageInflicted@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z:PROC ; CvCombatInfo::getDamageInflicted
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
xdata$x	SEGMENT
__unwindtable$?ResolveRangedCityVsUnitCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ResolveRangedCityVsUnitCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ResolveRangedCityVsUnitCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ResolveRangedCityVsUnitCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ResolveRangedCityVsUnitCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$3
__ehfuncinfo$?ResolveRangedCityVsUnitCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?ResolveRangedCityVsUnitCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
xdata$x	ENDS
;	COMDAT ?ResolveRangedCityVsUnitCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
_TEXT	SEGMENT
tv588 = -276						; size = 4
$T226936 = -276						; size = 4
$T226906 = -276						; size = 4
$T226857 = -276						; size = 4
$T226844 = -276						; size = 4
$T226768 = -276						; size = 4
$T226766 = -276						; size = 4
$T226764 = -276						; size = 4
$T226853 = -272						; size = 4
$T226822 = -272						; size = 4
_pNotifications$222585 = -272				; size = 4
_iDamage$ = -268					; size = 4
tv589 = -264						; size = 4
$T226813 = -264						; size = 4
$T226762 = -264						; size = 4
_bTargetDied$ = -260					; size = 1
_iActivePlayerID$ = -256				; size = 4
_localizedText$222579 = -252				; size = 80
_localizedText$222568 = -252				; size = 80
_localizedText$222587 = -172				; size = 80
_strSummary$222592 = -92				; size = 80
__$EHRec$ = -12						; size = 12
_kCombatInfo$ = 8					; size = 4
_uiParentEventID$ = 12					; size = 4
?ResolveRangedCityVsUnitCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z PROC ; CvUnitCombat::ResolveRangedCityVsUnitCombat, COMDAT

; 1203 : {

	push	-1
	push	__ehhandler$?ResolveRangedCityVsUnitCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1204 : 	bool bTargetDied = false;
; 1205 : 	int iDamage = kCombatInfo.getDamageInflicted(BATTLE_UNIT_ATTACKER);

	mov	edi, DWORD PTR _kCombatInfo$[esp+288]
	push	0
	mov	ecx, edi
	mov	BYTE PTR _bTargetDied$[esp+296], 0
	call	?getDamageInflicted@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getDamageInflicted

; 1206 : 	bool bBarbarian = false;
; 1207 : 
; 1208 : 	CvCity* pkAttacker = kCombatInfo.getCity(BATTLE_UNIT_ATTACKER);

	push	0
	mov	ecx, edi
	mov	DWORD PTR _iDamage$[esp+296], eax
	call	?getCity@CvCombatInfo@@QBEPAVCvCity@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getCity
	mov	ebp, eax

; 1209 : 	CvAssert_Debug(pkAttacker);
; 1210 : 
; 1211 : 	if(pkAttacker)

	test	ebp, ebp
	je	SHORT $LN13@ResolveRan

; 1212 : 		pkAttacker->clearCombat();

	mov	ecx, ebp
	call	?clearCombat@CvCity@@QAEXXZ		; CvCity::clearCombat
$LN13@ResolveRan:

; 1213 : 
; 1214 : 	CvPlot* pkTargetPlot = kCombatInfo.getPlot();

	mov	ecx, edi
	call	?getPlot@CvCombatInfo@@QBEPAVCvPlot@@XZ	; CvCombatInfo::getPlot

; 1215 : 	CvAssert_Debug(pkTargetPlot);
; 1216 : 
; 1217 : 	ICvUserInterface2* pkDLLInterface = GC.GetEngineUserInterface();
; 1218 : 	int iActivePlayerID = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	esi, eax
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR _iActivePlayerID$[esp+292], eax

; 1219 : 
; 1220 : #ifdef DEL_RANGED_COUNTERATTACKS
; 1221 : 	int iDamageToCity = kCombatInfo.getDamageInflicted(BATTLE_UNIT_DEFENDER);
; 1222 : 
; 1223 : 	CvString strBuffer;
; 1224 : #endif
; 1225 : 
; 1226 : 	if(pkTargetPlot)

	test	esi, esi
	je	$LN2@ResolveRan

; 1227 : 	{
; 1228 : 		if(!pkTargetPlot->isCity())

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN117@ResolveRan
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN117@ResolveRan
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	$LN11@ResolveRan
$LN117@ResolveRan:

; 1229 : 		{
; 1230 : 			CvUnit* pkDefender = kCombatInfo.getUnit(BATTLE_UNIT_DEFENDER);

	push	1
	mov	ecx, edi
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit
	mov	esi, eax

; 1231 : 			CvAssert_Debug(pkDefender != NULL);
; 1232 : 			if(pkDefender)

	test	esi, esi
	je	$LN11@ResolveRan

; 1233 : 			{
; 1234 : 				bBarbarian = pkDefender->isBarbarian();

	mov	ecx, esi
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian

; 1235 : 
; 1236 : 				if(pkAttacker)

	test	ebp, ebp
	je	$LN9@ResolveRan

; 1237 : 				{
; 1238 : #ifdef DEL_RANGED_COUNTERATTACKS
; 1239 : 					pkDefender->changeDamage(iDamage, pkAttacker->getOwner());
; 1240 : 					pkAttacker->changeDamage(iDamageToCity);
; 1241 : 
; 1242 : 					pkDefender->changeExperience(
; 1243 : 						kCombatInfo.getExperience(BATTLE_UNIT_DEFENDER),
; 1244 : 						kCombatInfo.getMaxExperienceAllowed(BATTLE_UNIT_DEFENDER),
; 1245 : 						true,
; 1246 : 						kCombatInfo.getInBorders(BATTLE_UNIT_DEFENDER),
; 1247 : 						kCombatInfo.getUpdateGlobal(BATTLE_UNIT_DEFENDER));
; 1248 : 
; 1249 : 					if (pkDefender->IsDead())
; 1250 : 					{
; 1251 : 						CvNotifications* pNotifications = GET_PLAYER(pkDefender->getOwner()).GetNotifications();
; 1252 : 						if (pNotifications)
; 1253 : 						{
; 1254 : 							Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_CITY");
; 1255 : 							localizedText << pkDefender->getNameKey() << pkAttacker->getNameKey() << iDamage;
; 1256 : 							Localization::String strSummary = Localization::Lookup("TXT_KEY_UNIT_LOST");
; 1257 : 							pNotifications->Add(NOTIFICATION_UNIT_DIED, localizedText.toUTF8(), strSummary.toUTF8(), pkDefender->getX(), pkDefender->getY(), (int)pkDefender->getUnitType(), pkDefender->getOwner());
; 1258 : 						}
; 1259 : 
; 1260 : 						if (pkAttacker->getOwner() == iActivePlayerID && iDamageToCity > 0)
; 1261 : 						{
; 1262 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_KILLED_ENEMY_UNIT_CITY", pkAttacker->getNameKey(), iDamageToCity, pkDefender->getNameKey(), pkDefender->getVisualCivAdjective(pkAttacker->getTeam()));
; 1263 : 							pkDLLInterface->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkPlot->getX(), pkPlot->getY()*/);
; 1264 : 						}
; 1265 : 
; 1266 : 						// Earn bonuses for kills?
; 1267 : 						CvPlayer& kAttackingPlayer = GET_PLAYER(pkAttacker->getOwner());
; 1268 : 						kAttackingPlayer.DoYieldsFromKill(NO_UNIT, pkDefender->getUnitType(), pkDefender->getX(), pkDefender->getY(), pkDefender->isBarbarian(), 0);
; 1269 : 					}
; 1270 : 					// Neither side lost
; 1271 : 					else if (iDamageToCity > 0)
; 1272 : 					{
; 1273 : 						if (pkDefender->getOwner() == iActivePlayerID)
; 1274 : 						{
; 1275 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_WITHDRAW_CITY", pkDefender->getNameKey(), iDamage, pkAttacker->getNameKey(), iDamageToCity);
; 1276 : 							pkDLLInterface->AddMessage(uiParentEventID, pkDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkPlot->getX(), pkPlot->getY()*/);
; 1277 : 						}
; 1278 : 						if (pkAttacker->getOwner() == iActivePlayerID)
; 1279 : 						{
; 1280 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_ENEMY_UNIT_WITHDRAW_CITY", pkDefender->getNameKey(), iDamageToCity, pkAttacker->getNameKey(), iDamage);
; 1281 : 							pkDLLInterface->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkPlot->getX(), pkPlot->getY()*/);
; 1282 : 						}
; 1283 : 
; 1284 : 						ApplyPostCityCombatEffects(pkDefender, pkAttacker, iDamageToCity);
; 1285 : 					}
; 1286 : #else
; 1287 : 					// Info message for the attacking player
; 1288 : 					if(iActivePlayerID == pkAttacker->getOwner())

	mov	eax, DWORD PTR [ebp+84]
	mov	edi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	cmp	DWORD PTR _iActivePlayerID$[esp+292], eax
	jne	$LN8@ResolveRan

; 1289 : 					{
; 1290 : 						Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_YOUR_CITY_RANGE_ATTACK");

	lea	edx, DWORD PTR _localizedText$222568[esp+292]
	push	OFFSET $SG222570
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 1291 : 						localizedText << pkAttacker->getNameKey() << pkDefender->getNameKey() << iDamage;

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+300], 0
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, ebp
	mov	DWORD PTR $T226762[esp+292], eax
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _localizedText$222568[esp+296]
	call	edi
	mov	eax, DWORD PTR $T226762[esp+292]
	push	eax
	lea	ecx, DWORD PTR _localizedText$222568[esp+296]
	call	edi
	mov	ecx, DWORD PTR _iDamage$[esp+292]
	push	ecx
	lea	ecx, DWORD PTR _localizedText$222568[esp+296]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 1292 : 						pkDLLInterface->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), localizedText.toUTF8());//, "AS2D_COMBAT", MESSAGE_TYPE_INFO, pDefender->getUnitInfo().GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pPlot->getX(), pPlot->getY());

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	eax, DWORD PTR [ebp+84]
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	mov	DWORD PTR tv588[esp+320], ecx
	push	0
	lea	ecx, DWORD PTR _localizedText$222568[esp+324]
	mov	DWORD PTR $T226813[esp+324], edx
	mov	DWORD PTR $T226822[esp+324], eax
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	edx, DWORD PTR $T226813[esp+324]
	mov	ecx, DWORD PTR _uiParentEventID$[esp+320]
	push	eax
	mov	eax, DWORD PTR $T226822[esp+328]
	push	edx
	mov	edx, DWORD PTR tv588[esp+332]
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+160]
	push	ecx
	mov	ecx, ebx
	call	eax

; 1293 : 					}

	lea	ecx, DWORD PTR _localizedText$222568[esp+292]
	mov	DWORD PTR __$EHRec$[esp+300], -1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN8@ResolveRan:

; 1294 : 
; 1295 : 					// Red icon over defending unit
; 1296 : 					if(iActivePlayerID == pkDefender->getOwner())

	mov	ecx, DWORD PTR _iActivePlayerID$[esp+292]
	cmp	ecx, DWORD PTR [esi+40]
	jne	$LN118@ResolveRan

; 1297 : 					{
; 1298 : 						Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_CITY");

	lea	edx, DWORD PTR _localizedText$222579[esp+292]
	push	OFFSET $SG222581
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 1299 : 						localizedText << pkDefender->getNameKey() << pkAttacker->getNameKey() << iDamage;

	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+300], 1
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T226764[esp+292], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	push	eax
	lea	ecx, DWORD PTR _localizedText$222579[esp+296]
	call	edi
	mov	eax, DWORD PTR $T226764[esp+292]
	push	eax
	lea	ecx, DWORD PTR _localizedText$222579[esp+296]
	call	edi
	mov	ecx, DWORD PTR _iDamage$[esp+292]
	push	ecx
	lea	ecx, DWORD PTR _localizedText$222579[esp+296]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 1300 : 						pkDLLInterface->AddMessage(uiParentEventID, pkDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), localizedText.toUTF8());//, "AS2D_COMBAT", MESSAGE_TYPE_COMBAT_MESSAGE, pDefender->getUnitInfo().GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pDefender->getX(), pDefender->getY(), true, true);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	eax, DWORD PTR [esi+40]
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	mov	DWORD PTR tv589[esp+320], ecx
	push	0
	lea	ecx, DWORD PTR _localizedText$222579[esp+324]
	mov	DWORD PTR $T226844[esp+324], edx
	mov	DWORD PTR $T226853[esp+324], eax
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	edx, DWORD PTR $T226844[esp+324]
	mov	ecx, DWORD PTR _uiParentEventID$[esp+320]
	push	eax
	mov	eax, DWORD PTR $T226853[esp+328]
	push	edx
	mov	edx, DWORD PTR tv589[esp+332]
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+160]
	push	ecx
	mov	ecx, ebx
	call	eax

; 1301 : 					}

	mov	ebx, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _localizedText$222579[esp+292]
	mov	DWORD PTR __$EHRec$[esp+300], -1
	call	ebx
	jmp	SHORT $LN7@ResolveRan
$LN118@ResolveRan:
	mov	ebx, DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN7@ResolveRan:

; 1302 : 
; 1303 : 					if(iDamage + pkDefender->getDamage() >= GC.getMAX_HIT_POINTS())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	DWORD PTR $T226857[esp+292], ecx
	mov	ecx, esi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	add	eax, DWORD PTR _iDamage$[esp+292]
	cmp	eax, DWORD PTR $T226857[esp+292]
	jl	$LN6@ResolveRan

; 1304 : 					{
; 1305 : 						CvNotifications* pNotifications = GET_PLAYER(pkDefender->getOwner()).GetNotifications();

	mov	eax, DWORD PTR [esi+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$222585[esp+292], eax

; 1306 : 						if(pNotifications)

	test	eax, eax
	je	$LN5@ResolveRan

; 1307 : 						{
; 1308 : 							Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_CITY");

	lea	edx, DWORD PTR _localizedText$222587[esp+292]
	push	OFFSET $SG222589
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 1309 : 							localizedText << pkDefender->getNameKey() << pkAttacker->getNameKey() << iDamage;

	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+300], 2
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T226766[esp+292], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	push	eax
	lea	ecx, DWORD PTR _localizedText$222587[esp+296]
	call	edi
	mov	eax, DWORD PTR $T226766[esp+292]
	push	eax
	lea	ecx, DWORD PTR _localizedText$222587[esp+296]
	call	edi
	mov	ecx, DWORD PTR _iDamage$[esp+292]
	push	ecx
	lea	ecx, DWORD PTR _localizedText$222587[esp+296]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 1310 : 							Localization::String strSummary = Localization::Lookup("TXT_KEY_UNIT_LOST");

	lea	edx, DWORD PTR _strSummary$222592[esp+292]
	push	OFFSET $SG222594
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 1311 : 							pNotifications->Add(NOTIFICATION_UNIT_DIED, localizedText.toUTF8(), strSummary.toUTF8(), pkDefender->getX(), pkDefender->getY(), (int) pkDefender->getUnitType(), pkDefender->getOwner());

	mov	ecx, DWORD PTR [esi+76]
	mov	eax, DWORD PTR [esi+40]
	mov	edi, DWORD PTR [esi+88]
	mov	DWORD PTR $T226906[esp+292], ecx
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+304], 3
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	mov	edx, DWORD PTR $T226906[esp+296]
	push	eax
	push	edi
	mov	edi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	edx
	lea	ecx, DWORD PTR _strSummary$222592[esp+308]
	call	edi
	push	eax
	lea	ecx, DWORD PTR _localizedText$222587[esp+312]
	call	edi
	mov	ecx, DWORD PTR _pNotifications$222585[esp+312]
	push	eax
	push	-16309126				; ff07247aH
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 1312 : 						}

	lea	ecx, DWORD PTR _strSummary$222592[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 2
	call	ebx
	lea	ecx, DWORD PTR _localizedText$222587[esp+292]
	mov	DWORD PTR __$EHRec$[esp+300], -1
	call	ebx
$LN5@ResolveRan:

; 1313 : 						bTargetDied = true;
; 1314 : 
; 1315 : 						// Earn bonuses for kills?
; 1316 : 						CvPlayer& kAttackingPlayer = GET_PLAYER(pkAttacker->getOwner());

	mov	eax, DWORD PTR [ebp+84]

; 1317 : 						kAttackingPlayer.DoYieldsFromKill(NO_UNIT, pkDefender->getUnitType(), pkDefender->getX(), pkDefender->getY(), pkDefender->isBarbarian(), 0);

	mov	ebx, DWORD PTR [esi+88]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	mov	edi, eax
	mov	eax, DWORD PTR [esi+76]
	mov	ecx, esi
	mov	BYTE PTR _bTargetDied$[esp+296], 1
	mov	DWORD PTR $T226936[esp+296], eax
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	mov	edx, DWORD PTR $T226936[esp+296]
	movzx	ecx, al
	push	ecx
	push	ebx
	push	edx
	mov	ecx, esi
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	push	-1
	mov	ecx, edi
	call	?DoYieldsFromKill@CvPlayer@@QAEXW4UnitTypes@@0HH_NH@Z ; CvPlayer::DoYieldsFromKill
$LN6@ResolveRan:

; 1318 : 					}
; 1319 : 
; 1320 : 					//set damage but don't update entity damage visibility
; 1321 : 					pkDefender->changeDamage(iDamage, pkAttacker->getOwner());

	mov	eax, DWORD PTR [ebp+84]
	push	0
	push	ecx
	mov	DWORD PTR [esp], 0
	push	eax
	mov	eax, DWORD PTR _iDamage$[esp+304]
	push	eax
	mov	ecx, esi
	call	?changeDamage@CvUnit@@QAEHHW4PlayerTypes@@MPBVCvString@@@Z ; CvUnit::changeDamage

; 1322 : 
; 1323 : 					// Update experience
; 1324 : 					pkDefender->changeExperience(
; 1325 : 					    kCombatInfo.getExperience(BATTLE_UNIT_DEFENDER),
; 1326 : 					    kCombatInfo.getMaxExperienceAllowed(BATTLE_UNIT_DEFENDER),
; 1327 : 					    true,
; 1328 : 					    kCombatInfo.getInBorders(BATTLE_UNIT_DEFENDER),
; 1329 : 					    kCombatInfo.getUpdateGlobal(BATTLE_UNIT_DEFENDER));

	mov	edi, DWORD PTR _kCombatInfo$[esp+288]
	push	1
	mov	ecx, edi
	call	?getUpdateGlobal@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getUpdateGlobal
	movzx	ecx, al
	push	ecx
	push	1
	mov	ecx, edi
	call	?getInBorders@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getInBorders
	movzx	edx, al
	push	edx
	push	1
	push	1
	mov	ecx, edi
	call	?getMaxExperienceAllowed@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getMaxExperienceAllowed
	push	eax
	push	1
	mov	ecx, edi
	call	?getExperience@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getExperience
	push	eax
	mov	ecx, esi
	call	?changeExperience@CvUnit@@QAEXHH_N00@Z	; CvUnit::changeExperience
$LN9@ResolveRan:

; 1330 : #endif
; 1331 : 				}
; 1332 : 
; 1333 : 				pkDefender->setCombatUnit(NULL);

	push	0
	push	0
	mov	ecx, esi
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 1334 : 				if(!CvUnitMission::IsHeadMission(pkDefender, CvTypes::getMISSION_WAIT_FOR()))		// If the top mission was not a 'wait for', then clear it.

	call	?getMISSION_WAIT_FOR@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_WAIT_FOR
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T226768[esp+304], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?IsHeadMission@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z ; CvUnitMission::IsHeadMission
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@ResolveRan

; 1335 : 					pkDefender->ClearMissionQueue();

	push	1
	mov	ecx, esi
	call	?ClearMissionQueue@CvUnit@@QAEXH@Z	; CvUnit::ClearMissionQueue

; 1336 : 			}
; 1337 : 			else

	jmp	SHORT $LN2@ResolveRan
$LN11@ResolveRan:

; 1338 : 				bTargetDied = true;
; 1339 : 		}
; 1340 : 		else
; 1341 : 		{
; 1342 : 			CvAssert(false);	// Left as an exercise for the reader
; 1343 : 			bTargetDied = true;

	mov	BYTE PTR _bTargetDied$[esp+292], 1
$LN2@ResolveRan:

; 1344 : 		}
; 1345 : 	}
; 1346 : 
; 1347 : 	// Report that combat is over in case we want to queue another attack
; 1348 : 	if(pkAttacker)

	test	ebp, ebp
	je	SHORT $LN1@ResolveRan

; 1349 : 		GET_PLAYER(pkAttacker->getOwner()).GetTacticalAI()->CombatResolved((void*)pkAttacker, bTargetDied, true);

	mov	ecx, DWORD PTR [ebp+84]
	mov	eax, DWORD PTR _bTargetDied$[esp+292]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	1
	push	eax
	push	ebp
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z ; CvTacticalAI::CombatResolved
$LN1@ResolveRan:

; 1350 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+292]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 276				; 00000114H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ResolveRangedCityVsUnitCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$0:
	lea	ecx, DWORD PTR _localizedText$222568[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ResolveRangedCityVsUnitCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$1:
	lea	ecx, DWORD PTR _localizedText$222579[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ResolveRangedCityVsUnitCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$2:
	lea	ecx, DWORD PTR _localizedText$222587[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ResolveRangedCityVsUnitCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$3:
	lea	ecx, DWORD PTR _strSummary$222592[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__ehhandler$?ResolveRangedCityVsUnitCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z:
	mov	eax, OFFSET __ehfuncinfo$?ResolveRangedCityVsUnitCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ResolveRangedCityVsUnitCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ENDP ; CvUnitCombat::ResolveRangedCityVsUnitCombat
PUBLIC	?GenerateAirCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z ; CvUnitCombat::GenerateAirCombatInfo
EXTRN	?setAttackIsBombingMission@CvCombatInfo@@QAEX_N@Z:PROC ; CvCombatInfo::setAttackIsBombingMission
EXTRN	__imp___stricmp:PROC
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
EXTRN	?isHuman@CvUnit@@QBE_NXZ:PROC			; CvUnit::isHuman
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?GetAirStrikeDefenseDamage@CvCity@@QBEHPBVCvUnit@@_N@Z:PROC ; CvCity::GetAirStrikeDefenseDamage
EXTRN	?GetAirStrikeDefenseDamage@CvUnit@@QBEHPBV1@_N@Z:PROC ; CvUnit::GetAirStrikeDefenseDamage
EXTRN	?GetAirCombatDamage@CvUnit@@QBEHPBV1@PAVCvCity@@_NH@Z:PROC ; CvUnit::GetAirCombatDamage
EXTRN	?GetInterceptionDamage@CvUnit@@QBEHPBV1@_N@Z:PROC ; CvUnit::GetInterceptionDamage
EXTRN	?currInterceptionProbability@CvUnit@@QBEHXZ:PROC ; CvUnit::currInterceptionProbability
EXTRN	?evasionProbability@CvUnit@@QBEHXZ:PROC		; CvUnit::evasionProbability
EXTRN	?GetBestInterceptor@CvUnit@@QBEPAV1@ABVCvPlot@@PAV1@_N2@Z:PROC ; CvUnit::GetBestInterceptor
; Function compile flags: /Ogtpy
;	COMDAT ?GenerateAirCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z
_TEXT	SEGMENT
_iAttackerDamageInflicted$ = -32			; size = 4
_iDefenderDamageInflicted$ = -28			; size = 4
$T226984 = -28						; size = 4
_pInterceptor$ = -28					; size = 4
_iInterceptionDamage$ = -24				; size = 4
$T227052 = -20						; size = 4
$T227048 = -20						; size = 4
$T226991 = -20						; size = 4
$T226988 = -20						; size = 4
$T226986 = -20						; size = 4
_iDefenderTotalDamageInflicted$ = -20			; size = 4
$T227035 = -16						; size = 4
$T227031 = -16						; size = 4
$T226985 = -16						; size = 4
_iAttackerTotalDamageInflicted$ = -16			; size = 4
_iExperience$ = -12					; size = 4
_eDefenderOwner$ = -8					; size = 4
tv559 = -4						; size = 4
tv556 = -4						; size = 4
tv205 = -4						; size = 4
$T226990 = -4						; size = 4
$T226989 = -4						; size = 4
$T226987 = -4						; size = 4
_kAttacker$ = 8						; size = 4
_pkDefender$ = 12					; size = 4
_bIsGlobalXPAwarded$ = 16				; size = 1
_plot$ = 16						; size = 4
_pkCombatInfo$ = 20					; size = 4
?GenerateAirCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z PROC ; CvUnitCombat::GenerateAirCombatInfo, COMDAT

; 1532 : {

	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	push	esi

; 1533 : 	int iExperience = 0;
; 1534 : 
; 1535 : 	pkCombatInfo->setUnit(BATTLE_UNIT_ATTACKER, &kAttacker);

	mov	esi, DWORD PTR _pkCombatInfo$[esp+40]
	push	edi
	mov	edi, DWORD PTR _kAttacker$[esp+44]
	push	edi
	push	0
	mov	ecx, esi
	call	?setUnit@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z ; CvCombatInfo::setUnit

; 1536 : 	pkCombatInfo->setUnit(BATTLE_UNIT_DEFENDER, pkDefender);

	mov	ebx, DWORD PTR _pkDefender$[esp+44]
	push	ebx
	push	1
	mov	ecx, esi
	call	?setUnit@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z ; CvCombatInfo::setUnit

; 1537 : 	pkCombatInfo->setPlot(&plot);

	mov	ebp, DWORD PTR _plot$[esp+44]
	push	ebp
	mov	ecx, esi
	call	?setPlot@CvCombatInfo@@QAEXPAVCvPlot@@@Z ; CvCombatInfo::setPlot

; 1538 : 
; 1539 : 	//////////////////////////////////////////////////////////////////////
; 1540 : 
; 1541 : 	// Any interception to be done?
; 1542 : 	CvUnit* pInterceptor = kAttacker.GetBestInterceptor(plot, pkDefender);

	push	0
	push	0
	push	ebx
	push	ebp
	mov	ecx, edi
	call	?GetBestInterceptor@CvUnit@@QBEPAV1@ABVCvPlot@@PAV1@_N2@Z ; CvUnit::GetBestInterceptor
	mov	DWORD PTR _pInterceptor$[esp+48], eax

; 1543 : 	int iInterceptionDamage = 0;

	mov	DWORD PTR _iInterceptionDamage$[esp+48], 0

; 1544 : 
; 1545 : 	if(pInterceptor != NULL && pInterceptor != pkDefender)

	test	eax, eax
	je	SHORT $LN126@GenerateAi
	cmp	eax, ebx
	je	SHORT $LN126@GenerateAi

; 1546 : 	{
; 1547 : 		pkCombatInfo->setUnit(BATTLE_UNIT_INTERCEPTOR, pInterceptor);

	push	eax
	push	2
	mov	ecx, esi
	call	?setUnit@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z ; CvCombatInfo::setUnit

; 1548 : 		// Does the attacker evade?
; 1549 : 		if(GC.getGame().getJonRandNum(100, "Evasion Rand") >= kAttacker.evasionProbability())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG222703
	push	100					; 00000064H
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	ecx, edi
	mov	ebp, eax
	call	?evasionProbability@CvUnit@@QBEHXZ	; CvUnit::evasionProbability
	cmp	ebp, eax
	jl	SHORT $LN14@GenerateAi

; 1550 : 		{
; 1551 : 			// Is the interception successful?
; 1552 : 			if(GC.getGame().getJonRandNum(100, "Intercept Rand (Air)") < pInterceptor->currInterceptionProbability())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG222705
	push	100					; 00000064H
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	ecx, DWORD PTR _pInterceptor$[esp+48]
	mov	ebp, eax
	call	?currInterceptionProbability@CvUnit@@QBEHXZ ; CvUnit::currInterceptionProbability
	cmp	ebp, eax
	jge	SHORT $LN14@GenerateAi

; 1553 : 			{
; 1554 : 				iInterceptionDamage = pInterceptor->GetInterceptionDamage(&kAttacker);

	mov	ecx, DWORD PTR _pInterceptor$[esp+48]
	push	1
	push	edi
	call	?GetInterceptionDamage@CvUnit@@QBEHPBV1@_N@Z ; CvUnit::GetInterceptionDamage
	mov	DWORD PTR _iInterceptionDamage$[esp+48], eax
$LN14@GenerateAi:

; 1555 : 			}
; 1556 : 		}
; 1557 : 		pkCombatInfo->setDamageInflicted(BATTLE_UNIT_INTERCEPTOR, iInterceptionDamage);		// Damage inflicted this round

	mov	eax, DWORD PTR _iInterceptionDamage$[esp+48]
	push	eax
	push	2
	mov	ecx, esi
	call	?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setDamageInflicted
	mov	ebp, DWORD PTR _plot$[esp+44]
$LN126@GenerateAi:

; 1558 : 	}
; 1559 : 
; 1560 : 	//////////////////////////////////////////////////////////////////////
; 1561 : 
; 1562 : 	bool bBarbarian = false;
; 1563 : 	int iMaxXP = 0;
; 1564 : 
; 1565 : 	int iAttackerDamageInflicted;
; 1566 : 	int iDefenderDamageInflicted;
; 1567 : 
; 1568 : 	int iAttackerTotalDamageInflicted;
; 1569 : 	int iDefenderTotalDamageInflicted;
; 1570 : 
; 1571 : 	PlayerTypes eDefenderOwner;
; 1572 : 
; 1573 : 	// Target is a Unit
; 1574 : 	if(!plot.isCity())

	mov	eax, DWORD PTR [ebp+104]
	test	eax, eax
	jl	SHORT $LN125@GenerateAi
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN125@GenerateAi
	mov	ecx, DWORD PTR [ebp+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	$LN13@GenerateAi
$LN125@GenerateAi:

; 1575 : 	{
; 1576 : 		CvAssert(pkDefender != NULL);
; 1577 : 		if(!pkDefender)

	test	ebx, ebx
	je	$LN17@GenerateAi

; 1578 : 			return;
; 1579 : 
; 1580 : 		eDefenderOwner = pkDefender->getOwner();

	mov	edx, DWORD PTR [ebx+40]

; 1581 : 
; 1582 : 		iExperience = /*4*/ GC.getEXPERIENCE_ATTACKING_UNIT_AIR();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7520

; 1583 : 		if(pkDefender->isBarbarian())

	mov	ecx, ebx
	mov	DWORD PTR _eDefenderOwner$[esp+48], edx
	mov	DWORD PTR _iExperience$[esp+48], eax
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian

; 1584 : 			bBarbarian = true;
; 1585 : 		iMaxXP = pkDefender->maxXPValue();

	mov	ecx, ebx
	call	?maxXPValue@CvUnit@@QBEHXZ		; CvUnit::maxXPValue

; 1586 : 
; 1587 : 		// Calculate attacker damage
; 1588 : 		iAttackerDamageInflicted = kAttacker.GetAirCombatDamage(pkDefender, /*pCity*/ NULL, /*bIncludeRand*/ true, iInterceptionDamage);

	mov	ecx, DWORD PTR _iInterceptionDamage$[esp+48]
	push	ecx
	push	1
	push	0
	push	ebx
	mov	ecx, edi
	mov	ebp, eax
	call	?GetAirCombatDamage@CvUnit@@QBEHPBV1@PAVCvCity@@_NH@Z ; CvUnit::GetAirCombatDamage

; 1589 : 
; 1590 : 		if(iAttackerDamageInflicted + pkDefender->getDamage() > GC.getMAX_HIT_POINTS())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, ebx
	mov	DWORD PTR _iAttackerDamageInflicted$[esp+48], eax
	mov	DWORD PTR $T227031[esp+48], edx
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	add	eax, DWORD PTR _iAttackerDamageInflicted$[esp+48]
	cmp	eax, DWORD PTR $T227031[esp+48]
	jle	SHORT $LN10@GenerateAi

; 1591 : 		{
; 1592 : 			iAttackerDamageInflicted = GC.getMAX_HIT_POINTS() - pkDefender->getDamage();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, ebx
	mov	DWORD PTR $T227035[esp+48], eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ecx, DWORD PTR $T227035[esp+48]
	sub	ecx, eax
	mov	DWORD PTR _iAttackerDamageInflicted$[esp+48], ecx
$LN10@GenerateAi:

; 1593 : 		}
; 1594 : 
; 1595 : 		iAttackerTotalDamageInflicted = std::max(pkDefender->getDamage(), pkDefender->getDamage() + iAttackerDamageInflicted);

	mov	ecx, ebx
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	add	eax, DWORD PTR _iAttackerDamageInflicted$[esp+48]
	mov	ecx, ebx
	mov	DWORD PTR $T226984[esp+48], eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	cmp	eax, DWORD PTR $T226984[esp+48]
	mov	DWORD PTR $T226985[esp+48], eax
	lea	eax, DWORD PTR $T226984[esp+48]
	jl	SHORT $LN47@GenerateAi
	lea	eax, DWORD PTR $T226985[esp+48]
$LN47@GenerateAi:
	mov	ecx, DWORD PTR [eax]

; 1596 : 
; 1597 : 		// Calculate defense damage
; 1598 : 		iDefenderDamageInflicted = pkDefender->GetAirStrikeDefenseDamage(&kAttacker);

	push	1
	mov	DWORD PTR _iAttackerTotalDamageInflicted$[esp+52], ecx
	push	edi
	mov	ecx, ebx
	call	?GetAirStrikeDefenseDamage@CvUnit@@QBEHPBV1@_N@Z ; CvUnit::GetAirStrikeDefenseDamage

; 1599 : 
; 1600 : 		if(iDefenderDamageInflicted + kAttacker.getDamage() > GC.getMAX_HIT_POINTS())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, edi
	mov	DWORD PTR _iDefenderDamageInflicted$[esp+48], eax
	mov	DWORD PTR $T227048[esp+48], edx
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	add	eax, DWORD PTR _iDefenderDamageInflicted$[esp+48]
	cmp	eax, DWORD PTR $T227048[esp+48]
	jle	SHORT $LN9@GenerateAi

; 1601 : 		{
; 1602 : 			iDefenderDamageInflicted = GC.getMAX_HIT_POINTS() - kAttacker.getDamage();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, edi
	mov	DWORD PTR $T227052[esp+48], eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ecx, DWORD PTR $T227052[esp+48]
	sub	ecx, eax
	mov	DWORD PTR _iDefenderDamageInflicted$[esp+48], ecx
$LN9@GenerateAi:

; 1603 : 		}
; 1604 : 
; 1605 : 		iDefenderTotalDamageInflicted = std::max(kAttacker.getDamage(), kAttacker.getDamage() + (iDefenderDamageInflicted + iInterceptionDamage));

	mov	ecx, edi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	add	eax, DWORD PTR _iDefenderDamageInflicted$[esp+48]
	mov	ecx, edi
	add	eax, DWORD PTR _iInterceptionDamage$[esp+48]
	mov	DWORD PTR $T226986[esp+48], eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	cmp	eax, DWORD PTR $T226986[esp+48]
	mov	DWORD PTR $T226987[esp+48], eax
	lea	eax, DWORD PTR $T226986[esp+48]
	jl	SHORT $LN55@GenerateAi
	lea	eax, DWORD PTR $T226987[esp+48]
$LN55@GenerateAi:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iDefenderTotalDamageInflicted$[esp+48], ecx

; 1606 : 	}
; 1607 : 	// Target is a City
; 1608 : 	else

	jmp	$LN2@GenerateAi
$LN13@GenerateAi:

; 1609 : 	{
; 1610 : 		CvCity* pCity = plot.getPlotCity();

	mov	eax, DWORD PTR [ebp+104]
	test	eax, eax
	jl	$LN17@GenerateAi
	cmp	eax, 64					; 00000040H
	jge	$LN17@GenerateAi
	mov	edx, DWORD PTR [ebp+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	ebx, eax

; 1611 : 		CvAssert(pCity != NULL);
; 1612 : 		if(!pCity) return;

	test	ebx, ebx
	je	$LN17@GenerateAi

; 1613 : 
; 1614 : 		eDefenderOwner = plot.getOwner();

	mov	eax, DWORD PTR _plot$[esp+44]
	movsx	ecx, BYTE PTR [eax+4]

; 1615 : 
; 1616 : 		/*		iDefenderStrength = pCity->getStrengthValue() / 2;
; 1617 : 		iOldDamage = pCity->getDamage();*/
; 1618 : 
; 1619 : 		iExperience = /*4*/ GC.getEXPERIENCE_ATTACKING_CITY_AIR();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7556
	mov	DWORD PTR _eDefenderOwner$[esp+48], ecx

; 1620 : 
; 1621 : 		if(pCity->isBarbarian())

	mov	ecx, ebx
	mov	DWORD PTR _iExperience$[esp+48], edx
	call	?isBarbarian@CvCity@@QBE_NXZ		; CvCity::isBarbarian

; 1622 : 			bBarbarian = true;
; 1623 : 		iMaxXP = (GET_PLAYER(pCity->getOwner()).isMinorCiv()) ? 30 : 1000; // NQMP GJS - cap XP from fighting CS to 30

	mov	ecx, DWORD PTR [ebx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ebp, al

; 1624 : 
; 1625 : 		iAttackerDamageInflicted = kAttacker.GetAirCombatDamage(/*pUnit*/ NULL, pCity, /*bIncludeRand*/ true, iInterceptionDamage);

	mov	eax, DWORD PTR _iInterceptionDamage$[esp+48]
	push	eax
	neg	ebp
	push	1
	sbb	ebp, ebp
	push	ebx
	and	ebp, -970				; fffffc36H
	push	0
	mov	ecx, edi
	add	ebp, 1000				; 000003e8H
	call	?GetAirCombatDamage@CvUnit@@QBEHPBV1@PAVCvCity@@_NH@Z ; CvUnit::GetAirCombatDamage

; 1626 : 
; 1627 : 		// Cities can't be knocked to less than 1 HP
; 1628 : 		if(iAttackerDamageInflicted + pCity->getDamage() >= pCity->GetMaxHitPoints())

	mov	ecx, ebx
	mov	DWORD PTR _iAttackerDamageInflicted$[esp+48], eax
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	mov	ecx, DWORD PTR _iAttackerDamageInflicted$[esp+48]
	add	eax, ecx
	mov	ecx, ebx
	mov	DWORD PTR tv559[esp+48], eax
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	cmp	DWORD PTR tv559[esp+48], eax
	jl	SHORT $LN5@GenerateAi

; 1629 : 		{
; 1630 : 			iAttackerDamageInflicted = pCity->GetMaxHitPoints() - pCity->getDamage() - 1;

	mov	ecx, ebx
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	or	ecx, -1
	sub	ecx, eax
	mov	DWORD PTR tv205[esp+48], ecx
	mov	ecx, ebx
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	add	eax, DWORD PTR tv205[esp+48]
	mov	DWORD PTR _iAttackerDamageInflicted$[esp+48], eax
$LN5@GenerateAi:

; 1631 : 		}
; 1632 : 
; 1633 : 		iAttackerTotalDamageInflicted = std::max(pCity->getDamage(), pCity->getDamage() + iAttackerDamageInflicted);

	mov	ecx, ebx
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	add	eax, DWORD PTR _iAttackerDamageInflicted$[esp+48]
	mov	ecx, ebx
	mov	DWORD PTR $T226988[esp+48], eax
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	cmp	eax, DWORD PTR $T226988[esp+48]
	mov	DWORD PTR $T226989[esp+48], eax
	lea	eax, DWORD PTR $T226988[esp+48]
	jl	SHORT $LN74@GenerateAi
	lea	eax, DWORD PTR $T226989[esp+48]
$LN74@GenerateAi:
	mov	edx, DWORD PTR [eax]

; 1634 : 
; 1635 : 		// Calculate defense damage
; 1636 : 		iDefenderDamageInflicted = pCity->GetAirStrikeDefenseDamage(&kAttacker);

	push	1
	push	edi
	mov	ecx, ebx
	mov	DWORD PTR _iAttackerTotalDamageInflicted$[esp+56], edx
	call	?GetAirStrikeDefenseDamage@CvCity@@QBEHPBVCvUnit@@_N@Z ; CvCity::GetAirStrikeDefenseDamage

; 1637 : 
; 1638 : 		if(iDefenderDamageInflicted + kAttacker.getDamage() > pCity->GetMaxHitPoints())

	mov	ecx, edi
	mov	DWORD PTR _iDefenderDamageInflicted$[esp+48], eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ecx, DWORD PTR _iDefenderDamageInflicted$[esp+48]
	add	eax, ecx
	mov	ecx, ebx
	mov	DWORD PTR tv556[esp+48], eax
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	cmp	DWORD PTR tv556[esp+48], eax
	jle	SHORT $LN127@GenerateAi

; 1639 : 		{
; 1640 : 			iDefenderDamageInflicted = GC.getMAX_HIT_POINTS() - kAttacker.getDamage();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, edi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	sub	ebx, eax
	mov	DWORD PTR _iDefenderDamageInflicted$[esp+48], ebx
$LN127@GenerateAi:

; 1641 : 		}
; 1642 : 
; 1643 : 		iDefenderTotalDamageInflicted = std::max(kAttacker.getDamage(), kAttacker.getDamage() + (iDefenderDamageInflicted + iInterceptionDamage));

	mov	ecx, edi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ebx, eax
	add	ebx, DWORD PTR _iDefenderDamageInflicted$[esp+48]
	mov	ecx, edi
	add	ebx, DWORD PTR _iInterceptionDamage$[esp+48]
	mov	DWORD PTR $T226990[esp+48], ebx
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	DWORD PTR $T226991[esp+48], eax
	cmp	eax, ebx
	lea	eax, DWORD PTR $T226990[esp+48]
	jl	SHORT $LN80@GenerateAi
	lea	eax, DWORD PTR $T226991[esp+48]
$LN80@GenerateAi:
	mov	edx, DWORD PTR [eax]

; 1644 : 
; 1645 : 		//Achievement for Washington
; 1646 : 		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(kAttacker.getUnitType());

	mov	ecx, edi
	mov	DWORD PTR _iDefenderTotalDamageInflicted$[esp+48], edx
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	ebx, eax

; 1647 : 		if(pkUnitInfo)

	test	ebx, ebx
	je	SHORT $LN128@GenerateAi

; 1648 : 		{
; 1649 : 			if(kAttacker.isHuman() && !GC.getGame().isGameMultiPlayer() && _stricmp(pkUnitInfo->GetType(), "UNIT_AMERICAN_B17") == 0)

	mov	ecx, edi
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	je	SHORT $LN128@GenerateAi
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	SHORT $LN128@GenerateAi
	lea	ecx, DWORD PTR [ebx+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	OFFSET $SG222735
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN128@GenerateAi

; 1650 : 			{
; 1651 : 				gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_B17);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+828]
	push	98					; 00000062H
	call	edx
$LN128@GenerateAi:
	mov	ebx, DWORD PTR _pkDefender$[esp+44]
$LN2@GenerateAi:

; 1652 : 			}
; 1653 : 		}
; 1654 : 	}
; 1655 : 	//////////////////////////////////////////////////////////////////////
; 1656 : 
; 1657 : 	pkCombatInfo->setFinalDamage(BATTLE_UNIT_ATTACKER, iDefenderTotalDamageInflicted);				// Total damage to the unit

	mov	eax, DWORD PTR _iDefenderTotalDamageInflicted$[esp+48]
	push	eax
	push	0
	mov	ecx, esi
	call	?setFinalDamage@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFinalDamage

; 1658 : 	pkCombatInfo->setDamageInflicted(BATTLE_UNIT_ATTACKER, iAttackerDamageInflicted);		// Damage inflicted this round

	mov	ecx, DWORD PTR _iAttackerDamageInflicted$[esp+48]
	push	ecx
	push	0
	mov	ecx, esi
	call	?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setDamageInflicted

; 1659 : 	pkCombatInfo->setFinalDamage(BATTLE_UNIT_DEFENDER, iAttackerTotalDamageInflicted);		// Total damage to the unit

	mov	edx, DWORD PTR _iAttackerTotalDamageInflicted$[esp+48]
	push	edx
	push	1
	mov	ecx, esi
	call	?setFinalDamage@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFinalDamage

; 1660 : 	pkCombatInfo->setDamageInflicted(BATTLE_UNIT_DEFENDER, iDefenderDamageInflicted);			// Damage inflicted this round

	mov	eax, DWORD PTR _iDefenderDamageInflicted$[esp+48]
	push	eax
	push	1
	mov	ecx, esi
	call	?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setDamageInflicted

; 1661 : 
; 1662 : 	// Fear Damage
; 1663 : 	pkCombatInfo->setFearDamageInflicted(BATTLE_UNIT_ATTACKER, 0);

	push	0
	push	0
	mov	ecx, esi
	call	?setFearDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFearDamageInflicted

; 1664 : 	// pkCombatInfo->setFearDamageInflicted( BATTLE_UNIT_DEFENDER, 0 );
; 1665 : 
; 1666 : 	pkCombatInfo->setExperience(BATTLE_UNIT_ATTACKER, iExperience);

	mov	ecx, DWORD PTR _iExperience$[esp+48]
	push	ecx
	push	0
	mov	ecx, esi
	call	?setExperience@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setExperience

; 1667 : 	pkCombatInfo->setMaxExperienceAllowed(BATTLE_UNIT_ATTACKER, iMaxXP);

	push	ebp
	push	0
	mov	ecx, esi
	call	?setMaxExperienceAllowed@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setMaxExperienceAllowed

; 1668 : 	pkCombatInfo->setInBorders(BATTLE_UNIT_ATTACKER, plot.getOwner() == eDefenderOwner);

	mov	ebp, DWORD PTR _plot$[esp+44]
	movsx	edx, BYTE PTR [ebp+4]
	cmp	edx, DWORD PTR _eDefenderOwner$[esp+48]
	sete	al
	movzx	ecx, al
	push	ecx
	push	0
	mov	ecx, esi
	call	?setInBorders@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setInBorders

; 1669 : #ifdef NQ_NO_GG_POINTS_FROM_CS_OR_BARBS
; 1670 : 	bool bIsGlobalXPAwarded = !kAttacker.isBarbarian() && !GET_PLAYER(kAttacker.getOwner()).isMinorCiv() &&
; 1671 : 		(plot.isCity() || (!pkDefender->isBarbarian() && !GET_PLAYER(pkDefender->getOwner()).isMinorCiv())) &&
; 1672 : 		(!plot.isCity() || (!plot.getPlotCity()->isBarbarian() && !GET_PLAYER(plot.getPlotCity()->getOwner()).isMinorCiv()));

	mov	ecx, edi
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	test	al, al
	jne	$LN19@GenerateAi
	mov	ecx, DWORD PTR [edi+40]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN19@GenerateAi
	mov	ecx, ebp
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	test	al, al
	jne	SHORT $LN21@GenerateAi
	mov	ecx, ebx
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	test	al, al
	jne	SHORT $LN19@GenerateAi
	mov	ebx, DWORD PTR [ebx+40]
	imul	ebx, 63236				; 0000f704H
	add	ebx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, ebx
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN19@GenerateAi
$LN21@GenerateAi:
	mov	ecx, ebp
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	test	al, al
	je	SHORT $LN23@GenerateAi
	mov	ecx, ebp
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	ecx, eax
	call	?isBarbarian@CvCity@@QBE_NXZ		; CvCity::isBarbarian
	test	al, al
	jne	SHORT $LN19@GenerateAi
	mov	ecx, ebp
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN19@GenerateAi
$LN23@GenerateAi:
	mov	BYTE PTR _bIsGlobalXPAwarded$[esp+44], 1
	jmp	SHORT $LN24@GenerateAi
$LN19@GenerateAi:
	mov	BYTE PTR _bIsGlobalXPAwarded$[esp+44], 0
$LN24@GenerateAi:

; 1673 : 	pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_ATTACKER, bIsGlobalXPAwarded);

	mov	ebx, DWORD PTR _bIsGlobalXPAwarded$[esp+44]
	push	ebx
	push	0
	mov	ecx, esi
	call	?setUpdateGlobal@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setUpdateGlobal

; 1674 : #else
; 1675 : 	pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_ATTACKER, !kAttacker.isBarbarian());
; 1676 : #endif
; 1677 : 
; 1678 : 	iExperience = /*2*/ GC.getEXPERIENCE_DEFENDING_UNIT_AIR();
; 1679 : 	pkCombatInfo->setExperience(BATTLE_UNIT_DEFENDER, iExperience);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7524
	push	edx
	push	1
	mov	ecx, esi
	call	?setExperience@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setExperience

; 1680 : 	pkCombatInfo->setMaxExperienceAllowed(BATTLE_UNIT_DEFENDER, MAX_INT);

	push	2147483647				; 7fffffffH
	push	1
	mov	ecx, esi
	call	?setMaxExperienceAllowed@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setMaxExperienceAllowed

; 1681 : 	pkCombatInfo->setInBorders(BATTLE_UNIT_DEFENDER, plot.getOwner() == kAttacker.getOwner());

	movsx	eax, BYTE PTR [ebp+4]
	cmp	eax, DWORD PTR [edi+40]
	sete	cl
	movzx	edx, cl
	push	edx
	push	1
	mov	ecx, esi
	call	?setInBorders@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setInBorders

; 1682 : #ifdef NQ_NO_GG_POINTS_FROM_CS_OR_BARBS
; 1683 : 	pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_DEFENDER, bIsGlobalXPAwarded);

	push	ebx
	push	1
	mov	ecx, esi
	call	?setUpdateGlobal@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setUpdateGlobal

; 1684 : #else
; 1685 : 	pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_DEFENDER, !bBarbarian);
; 1686 : #endif
; 1687 : 
; 1688 : 	if (iInterceptionDamage > 0)

	cmp	DWORD PTR _iInterceptionDamage$[esp+48], 0
	jle	SHORT $LN1@GenerateAi

; 1689 : 	{
; 1690 : 		iExperience = /*2*/ GC.getEXPERIENCE_DEFENDING_AIR_SWEEP_GROUND();
; 1691 : 		pkCombatInfo->setExperience( BATTLE_UNIT_INTERCEPTOR, iExperience );

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7544
	push	eax
	push	2
	mov	ecx, esi
	call	?setExperience@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setExperience

; 1692 : 		pkCombatInfo->setMaxExperienceAllowed( BATTLE_UNIT_INTERCEPTOR, MAX_INT );

	push	2147483647				; 7fffffffH
	push	2
	mov	ecx, esi
	call	?setMaxExperienceAllowed@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setMaxExperienceAllowed

; 1693 : 		pkCombatInfo->setInBorders( BATTLE_UNIT_INTERCEPTOR, plot.getOwner() == kAttacker.getOwner() );

	movsx	ecx, BYTE PTR [ebp+4]
	cmp	ecx, DWORD PTR [edi+40]
	mov	ecx, esi
	sete	dl
	movzx	eax, dl
	push	eax
	push	2
	call	?setInBorders@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setInBorders

; 1694 : #ifdef NQ_NO_GG_POINTS_FROM_CS_OR_BARBS
; 1695 : 		pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_INTERCEPTOR, bIsGlobalXPAwarded);

	push	ebx
	push	2
	mov	ecx, esi
	call	?setUpdateGlobal@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setUpdateGlobal
$LN1@GenerateAi:

; 1696 : #else
; 1697 : 		pkCombatInfo->setUpdateGlobal( BATTLE_UNIT_INTERCEPTOR, !bBarbarian );
; 1698 : #endif
; 1699 : 	}
; 1700 : 
; 1701 : 	pkCombatInfo->setAttackIsBombingMission(true);

	push	1
	mov	ecx, esi
	call	?setAttackIsBombingMission@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setAttackIsBombingMission

; 1702 : 	pkCombatInfo->setDefenderRetaliates(true);

	push	1
	mov	ecx, esi
	call	?setDefenderRetaliates@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setDefenderRetaliates

; 1703 : 
; 1704 : 	GC.GetEngineUserInterface()->setDirty(UnitInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	19					; 00000013H
	call	eax
$LN17@GenerateAi:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1705 : }

	add	esp, 32					; 00000020H
	ret	0
?GenerateAirCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z ENDP ; CvUnitCombat::GenerateAirCombatInfo
_TEXT	ENDS
PUBLIC	?GenerateAirSweepCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z ; CvUnitCombat::GenerateAirSweepCombatInfo
EXTRN	?setAttackIsAirSweep@CvCombatInfo@@QAEX_N@Z:PROC ; CvCombatInfo::setAttackIsAirSweep
EXTRN	?GetAirSweepCombatModifier@CvUnit@@QBEHXZ:PROC	; CvUnit::GetAirSweepCombatModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GenerateAirSweepCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z
_TEXT	SEGMENT
_iDefenderExperience$ = -16				; size = 4
_iMaxHP$ = -16						; size = 4
_iAttackerDamageInflicted$222887 = -12			; size = 4
_iDefenderDamageInflicted$222888 = -8			; size = 4
_iDefenderStrength$ = -8				; size = 4
_bIsGlobalXPAwarded$ = -4				; size = 1
_kAttacker$ = 8						; size = 4
_pkDefender$ = 12					; size = 4
_plot$ = 16						; size = 4
_pkCombatInfo$ = 20					; size = 4
?GenerateAirSweepCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z PROC ; CvUnitCombat::GenerateAirSweepCombatInfo, COMDAT

; 1961 : {

	sub	esp, 16					; 00000010H

; 1962 : 	int iMaxHP = GC.getMAX_HIT_POINTS();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	push	ebx
	push	ebp
	push	esi

; 1963 : 
; 1964 : 	pkCombatInfo->setUnit(BATTLE_UNIT_ATTACKER, &kAttacker);

	mov	esi, DWORD PTR _pkCombatInfo$[esp+24]
	push	edi
	mov	edi, DWORD PTR _kAttacker$[esp+28]
	push	edi
	push	0
	mov	ecx, esi
	mov	DWORD PTR _iMaxHP$[esp+40], eax
	call	?setUnit@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z ; CvCombatInfo::setUnit

; 1965 : 	pkCombatInfo->setUnit(BATTLE_UNIT_DEFENDER, pkDefender);

	mov	ebx, DWORD PTR _pkDefender$[esp+28]
	push	ebx
	push	1
	mov	ecx, esi
	call	?setUnit@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z ; CvCombatInfo::setUnit

; 1966 : 	pkCombatInfo->setPlot(&plot);

	mov	ecx, DWORD PTR _plot$[esp+28]
	push	ecx
	mov	ecx, esi
	call	?setPlot@CvCombatInfo@@QAEXPAVCvPlot@@@Z ; CvCombatInfo::setPlot

; 1967 : 
; 1968 : 	// Unit vs. Unit
; 1969 : 	CvAssert(pkDefender != NULL);
; 1970 : 
; 1971 : 	int iAttackerStrength = kAttacker.GetMaxRangedCombatStrength(pkDefender, /*pCity*/ NULL, true, false);

	push	0
	push	1
	push	0
	push	ebx
	mov	ecx, edi
	call	?GetMaxRangedCombatStrength@CvUnit@@QBEHPBV1@PBVCvCity@@_N2@Z ; CvUnit::GetMaxRangedCombatStrength

; 1972 : 
; 1973 : 	// Mod to air sweep strength
; 1974 : 	iAttackerStrength *= (100 + kAttacker.GetAirSweepCombatModifier());

	mov	ecx, edi
	mov	ebp, eax
	call	?GetAirSweepCombatModifier@CvUnit@@QBEHXZ ; CvUnit::GetAirSweepCombatModifier
	mov	ecx, eax
	add	ecx, 100				; 00000064H
	imul	ecx, ebp

; 1975 : 	iAttackerStrength /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ebp, edx
	shr	ebp, 31					; 0000001fH

; 1976 : 
; 1977 : 	int iDefenderStrength = 0;
; 1978 : 
; 1979 : 	int iDefenderExperience = 0;
; 1980 : #ifdef NQ_NO_GG_POINTS_FROM_CS_OR_BARBS
; 1981 : 	bool bIsGlobalXPAwarded = !kAttacker.isBarbarian() && !GET_PLAYER(kAttacker.getOwner()).isMinorCiv() && !pkDefender->isBarbarian() && !GET_PLAYER(pkDefender->getOwner()).isMinorCiv();

	mov	ecx, edi
	add	ebp, edx
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	test	al, al
	jne	SHORT $LN8@GenerateAi@2
	mov	ecx, DWORD PTR [edi+40]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN8@GenerateAi@2
	mov	ecx, ebx
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	test	al, al
	jne	SHORT $LN8@GenerateAi@2
	mov	ecx, DWORD PTR [ebx+40]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	mov	BYTE PTR _bIsGlobalXPAwarded$[esp+32], 1
	test	al, al
	je	SHORT $LN9@GenerateAi@2
$LN8@GenerateAi@2:
	mov	BYTE PTR _bIsGlobalXPAwarded$[esp+32], 0
$LN9@GenerateAi@2:

; 1982 : #endif
; 1983 : 
; 1984 : 	// Ground AA interceptor
; 1985 : 	if(pkDefender->getDomainType() != DOMAIN_AIR)

	mov	ecx, ebx
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType

; 1986 : 	{
; 1987 : 		int iInterceptionDamage = pkDefender->GetInterceptionDamage(&kAttacker);

	mov	ecx, ebx
	cmp	eax, 1
	je	SHORT $LN5@GenerateAi@2
	push	1
	push	edi
	call	?GetInterceptionDamage@CvUnit@@QBEHPBV1@_N@Z ; CvUnit::GetInterceptionDamage

; 1988 : 
; 1989 : 		// Reduce damage for performing a sweep
; 1990 : 		iInterceptionDamage *= /*75*/ GC.getAIR_SWEEP_INTERCEPTION_DAMAGE_MOD();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7452
	imul	ecx, eax

; 1991 : 		iInterceptionDamage /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1992 : 
; 1993 : 		iDefenderExperience = /*2*/ GC.getEXPERIENCE_DEFENDING_AIR_SWEEP_GROUND();
; 1994 : 
; 1995 : 		pkCombatInfo->setDamageInflicted(BATTLE_UNIT_DEFENDER, iInterceptionDamage);		// Damage inflicted this round

	push	eax
	push	1
	mov	ecx, esi
	call	?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setDamageInflicted

; 1996 : #ifdef AUI_UNIT_COMBAT_FIX_AIR_SWEEP_VS_GROUND_INTERCEPTOR
; 1997 : 		int iTotalInterceptionDamage = iInterceptionDamage + kAttacker.getDamage();
; 1998 : 		pkCombatInfo->setFinalDamage(BATTLE_UNIT_ATTACKER, iTotalInterceptionDamage);
; 1999 : 		pkCombatInfo->setDamageInflicted(BATTLE_UNIT_ATTACKER, 0);
; 2000 : 		pkCombatInfo->setFinalDamage(BATTLE_UNIT_DEFENDER, pkDefender->getDamage());
; 2001 : 
; 2002 : 		pkCombatInfo->setExperience(BATTLE_UNIT_DEFENDER, iDefenderExperience);
; 2003 : 		pkCombatInfo->setMaxExperienceAllowed(BATTLE_UNIT_ATTACKER, pkDefender->maxXPValue());
; 2004 : 		pkCombatInfo->setInBorders(BATTLE_UNIT_ATTACKER, plot.getOwner() == pkDefender->getOwner());
; 2005 : #ifdef NQ_NO_GG_POINTS_FROM_CS_OR_BARBS
; 2006 : 		pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_ATTACKER, bIsGlobalXPAwarded);
; 2007 : #else
; 2008 : 		pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_ATTACKER, !kAttacker.isBarbarian());
; 2009 : #endif
; 2010 : 
; 2011 : 		pkCombatInfo->setExperience(BATTLE_UNIT_ATTACKER, 0);
; 2012 : 		pkCombatInfo->setMaxExperienceAllowed(BATTLE_UNIT_DEFENDER, kAttacker.maxXPValue());
; 2013 : 		pkCombatInfo->setInBorders(BATTLE_UNIT_DEFENDER, plot.getOwner() == kAttacker.getOwner());
; 2014 : #ifdef NQ_NO_GG_POINTS_FROM_CS_OR_BARBS
; 2015 : 		pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_DEFENDER, bIsGlobalXPAwarded);
; 2016 : #else
; 2017 : 		pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_DEFENDER, !pkDefender->isBarbarian());
; 2018 : #endif
; 2019 : #endif
; 2020 : 	}
; 2021 : 	// Air interceptor
; 2022 : 	else

	jmp	$LN4@GenerateAi@2
$LN5@GenerateAi@2:

; 2023 : 	{
; 2024 : 		iDefenderStrength = pkDefender->GetMaxRangedCombatStrength(&kAttacker, /*pCity*/ NULL, false, false);

	push	0
	push	0
	push	0
	push	edi
	call	?GetMaxRangedCombatStrength@CvUnit@@QBEHPBV1@PBVCvCity@@_N2@Z ; CvUnit::GetMaxRangedCombatStrength

; 2025 : 
; 2026 : 		int iAttackerDamageInflicted = kAttacker.getCombatDamage(iAttackerStrength, iDefenderStrength, kAttacker.getDamage(), /*bIncludeRand*/ true, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ false);

	push	0
	push	0
	push	1
	mov	ecx, edi
	mov	DWORD PTR _iDefenderStrength$[esp+44], eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ecx, DWORD PTR _iDefenderStrength$[esp+44]
	push	eax
	push	ecx
	push	ebp
	mov	ecx, edi
	call	?getCombatDamage@CvUnit@@QBEHHHH_N00@Z	; CvUnit::getCombatDamage

; 2027 : 		int iDefenderDamageInflicted = pkDefender->getCombatDamage(iDefenderStrength, iAttackerStrength, pkDefender->getDamage(), /*bIncludeRand*/ true, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ false);

	push	0
	push	0
	push	1
	mov	ecx, ebx
	mov	DWORD PTR _iAttackerDamageInflicted$222887[esp+44], eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	edx, DWORD PTR _iDefenderStrength$[esp+44]
	push	eax
	push	ebp
	push	edx
	mov	ecx, ebx
	call	?getCombatDamage@CvUnit@@QBEHHHH_N00@Z	; CvUnit::getCombatDamage

; 2028 : 
; 2029 : 		int iAttackerTotalDamageInflicted = iAttackerDamageInflicted + pkDefender->getDamage();

	mov	ecx, ebx
	mov	DWORD PTR _iDefenderDamageInflicted$222888[esp+32], eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ebp, eax
	add	ebp, DWORD PTR _iAttackerDamageInflicted$222887[esp+32]

; 2030 : 		int iDefenderTotalDamageInflicted = iDefenderDamageInflicted + kAttacker.getDamage();

	mov	ecx, edi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage

; 2031 : 
; 2032 : 		// Will both units be killed by this? :o If so, take drastic corrective measures
; 2033 : 		if(iAttackerTotalDamageInflicted >= iMaxHP && iDefenderTotalDamageInflicted >= iMaxHP)

	mov	ecx, DWORD PTR _iMaxHP$[esp+32]
	add	eax, DWORD PTR _iDefenderDamageInflicted$222888[esp+32]
	cmp	ebp, ecx
	jl	SHORT $LN1@GenerateAi@2
	cmp	eax, ecx
	jl	SHORT $LN1@GenerateAi@2

; 2034 : 		{
; 2035 : 			// He who hath the least amount of damage survives with 1 HP left
; 2036 : 			if(iAttackerTotalDamageInflicted > iDefenderTotalDamageInflicted)

	cmp	ebp, eax
	jle	SHORT $LN2@GenerateAi@2

; 2037 : 			{
; 2038 : 				iDefenderDamageInflicted = iMaxHP - kAttacker.getDamage() - 1;

	mov	ecx, edi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ebp, DWORD PTR _iMaxHP$[esp+32]
	mov	ecx, eax
	mov	eax, ebp
	sub	eax, ecx
	dec	eax
	mov	DWORD PTR _iDefenderDamageInflicted$222888[esp+32], eax

; 2039 : 				iDefenderTotalDamageInflicted = iMaxHP - 1;

	lea	eax, DWORD PTR [ebp-1]

; 2040 : 				iAttackerTotalDamageInflicted = iMaxHP;
; 2041 : 			}
; 2042 : 			else

	jmp	SHORT $LN1@GenerateAi@2
$LN2@GenerateAi@2:

; 2043 : 			{
; 2044 : 				iAttackerDamageInflicted = iMaxHP - pkDefender->getDamage() - 1;

	mov	ecx, ebx
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	edx, eax
	mov	eax, DWORD PTR _iMaxHP$[esp+32]
	mov	ecx, eax
	sub	ecx, edx
	dec	ecx
	mov	DWORD PTR _iAttackerDamageInflicted$222887[esp+32], ecx

; 2045 : 				iAttackerTotalDamageInflicted = iMaxHP - 1;

	lea	ebp, DWORD PTR [eax-1]
$LN1@GenerateAi@2:

; 2046 : 				iDefenderTotalDamageInflicted = iMaxHP;
; 2047 : 			}
; 2048 : 		}
; 2049 : 
; 2050 : 		iDefenderExperience = /*6*/ GC.getEXPERIENCE_DEFENDING_AIR_SWEEP_AIR();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7540

; 2051 : 
; 2052 : 		pkCombatInfo->setFinalDamage(BATTLE_UNIT_ATTACKER, iDefenderTotalDamageInflicted);

	push	eax
	mov	DWORD PTR _iDefenderExperience$[esp+36], ecx
	push	0
	mov	ecx, esi
	call	?setFinalDamage@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFinalDamage

; 2053 : 		pkCombatInfo->setDamageInflicted(BATTLE_UNIT_ATTACKER, iAttackerDamageInflicted);

	mov	edx, DWORD PTR _iAttackerDamageInflicted$222887[esp+32]
	push	edx
	push	0
	mov	ecx, esi
	call	?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setDamageInflicted

; 2054 : 		pkCombatInfo->setFinalDamage(BATTLE_UNIT_DEFENDER, iAttackerTotalDamageInflicted);

	push	ebp
	push	1
	mov	ecx, esi
	call	?setFinalDamage@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFinalDamage

; 2055 : 		pkCombatInfo->setDamageInflicted(BATTLE_UNIT_DEFENDER, iDefenderDamageInflicted);

	mov	eax, DWORD PTR _iDefenderDamageInflicted$222888[esp+32]
	push	eax
	push	1
	mov	ecx, esi
	call	?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setDamageInflicted

; 2056 : 
; 2057 : 		// Fear Damage
; 2058 : 		//pkCombatInfo->setFearDamageInflicted( BATTLE_UNIT_ATTACKER, kAttacker.getCombatDamage(iAttackerStrength, iDefenderStrength, kAttacker.getDamage(), true, false, true) );
; 2059 : 		//	pkCombatInfo->setFearDamageInflicted( BATTLE_UNIT_DEFENDER, getCombatDamage(iDefenderStrength, iAttackerStrength, pDefender->getDamage(), true, false, true) );
; 2060 : 
; 2061 : #ifndef NQM_PRUNING
; 2062 : 		int iAttackerEffectiveStrength = iAttackerStrength * (iMaxHP - range(kAttacker.getDamage(), 0, iMaxHP-1)) / iMaxHP;

	mov	ecx, edi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage

; 2063 : 		iAttackerEffectiveStrength = iAttackerEffectiveStrength > 0 ? iAttackerEffectiveStrength : 1;
; 2064 : 		int iDefenderEffectiveStrength = iDefenderStrength * (iMaxHP - range(pkDefender->getDamage(), 0, iMaxHP-1)) / iMaxHP;

	mov	ecx, ebx
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage

; 2065 : 		iDefenderEffectiveStrength = iDefenderEffectiveStrength > 0 ? iDefenderEffectiveStrength : 1;
; 2066 : #endif
; 2067 : 
; 2068 : 		//int iExperience = kAttacker.defenseXPValue();
; 2069 : 		//iExperience = ((iExperience * iAttackerEffectiveStrength) / iDefenderEffectiveStrength); // is this right? looks like more for less [Jon: Yes, it's XP for the defender]
; 2070 : 		//iExperience = range(iExperience, GC.getMIN_EXPERIENCE_PER_COMBAT(), GC.getMAX_EXPERIENCE_PER_COMBAT());
; 2071 : 		pkCombatInfo->setExperience(BATTLE_UNIT_DEFENDER, iDefenderExperience);

	mov	ecx, DWORD PTR _iDefenderExperience$[esp+32]
	push	ecx
	push	1
	mov	ecx, esi
	call	?setExperience@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setExperience

; 2072 : 		pkCombatInfo->setMaxExperienceAllowed(BATTLE_UNIT_ATTACKER, pkDefender->maxXPValue());

	mov	ecx, ebx
	call	?maxXPValue@CvUnit@@QBEHXZ		; CvUnit::maxXPValue
	push	eax
	push	0
	mov	ecx, esi
	call	?setMaxExperienceAllowed@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setMaxExperienceAllowed

; 2073 : 		pkCombatInfo->setInBorders(BATTLE_UNIT_ATTACKER, plot.getOwner() == pkDefender->getOwner());

	mov	ebp, DWORD PTR _plot$[esp+28]
	movsx	edx, BYTE PTR [ebp+4]
	cmp	edx, DWORD PTR [ebx+40]
	sete	al
	movzx	ecx, al
	push	ecx
	push	0
	mov	ecx, esi
	call	?setInBorders@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setInBorders

; 2074 : #ifdef NQ_NO_GG_POINTS_FROM_CS_OR_BARBS
; 2075 : 		pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_ATTACKER, bIsGlobalXPAwarded);

	mov	ebx, DWORD PTR _bIsGlobalXPAwarded$[esp+32]
	push	ebx
	push	0
	mov	ecx, esi
	call	?setUpdateGlobal@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setUpdateGlobal

; 2076 : #else
; 2077 : 		pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_ATTACKER, !kAttacker.isBarbarian());
; 2078 : #endif
; 2079 : 
; 2080 : 		//iExperience = ((iExperience * iDefenderEffectiveStrength) / iAttackerEffectiveStrength);
; 2081 : 		//iExperience = range(iExperience, GC.getMIN_EXPERIENCE_PER_COMBAT(), GC.getMAX_EXPERIENCE_PER_COMBAT());
; 2082 : 		int iExperience = /*6*/ GC.getEXPERIENCE_ATTACKING_AIR_SWEEP();
; 2083 : 		pkCombatInfo->setExperience(BATTLE_UNIT_ATTACKER, iExperience);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7536
	push	edx
	push	0
	mov	ecx, esi
	call	?setExperience@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setExperience

; 2084 : 		pkCombatInfo->setMaxExperienceAllowed(BATTLE_UNIT_DEFENDER, kAttacker.maxXPValue());

	mov	ecx, edi
	call	?maxXPValue@CvUnit@@QBEHXZ		; CvUnit::maxXPValue
	push	eax
	push	1
	mov	ecx, esi
	call	?setMaxExperienceAllowed@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setMaxExperienceAllowed

; 2085 : 		pkCombatInfo->setInBorders(BATTLE_UNIT_DEFENDER, plot.getOwner() == kAttacker.getOwner());

	movsx	eax, BYTE PTR [ebp+4]
	cmp	eax, DWORD PTR [edi+40]
	sete	cl
	movzx	edx, cl
	push	edx
	push	1
	mov	ecx, esi
	call	?setInBorders@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setInBorders

; 2086 : #ifdef NQ_NO_GG_POINTS_FROM_CS_OR_BARBS
; 2087 : 		pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_DEFENDER, bIsGlobalXPAwarded);

	push	ebx
	push	1
	mov	ecx, esi
	call	?setUpdateGlobal@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setUpdateGlobal
$LN4@GenerateAi@2:

; 2088 : #else
; 2089 : 		pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_DEFENDER, !pkDefender->isBarbarian());
; 2090 : #endif
; 2091 : 	}
; 2092 : 
; 2093 : 	pkCombatInfo->setAttackIsRanged(false);

	push	0
	mov	ecx, esi
	call	?setAttackIsRanged@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setAttackIsRanged

; 2094 : 	pkCombatInfo->setAttackIsAirSweep(true);

	push	1
	mov	ecx, esi
	call	?setAttackIsAirSweep@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setAttackIsAirSweep

; 2095 : 	pkCombatInfo->setAttackerAdvances(false);

	push	0
	mov	ecx, esi
	call	?setAttackerAdvances@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setAttackerAdvances

; 2096 : 	pkCombatInfo->setDefenderRetaliates(true);

	push	1
	mov	ecx, esi
	call	?setDefenderRetaliates@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setDefenderRetaliates

; 2097 : 
; 2098 : 	GC.GetEngineUserInterface()->setDirty(UnitInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	19					; 00000013H
	call	edx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2099 : }

	add	esp, 16					; 00000010H
	ret	0
?GenerateAirSweepCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z ENDP ; CvUnitCombat::GenerateAirSweepCombatInfo
_TEXT	ENDS
PUBLIC	?ApplyNuclearExplosionDamage@CvUnitCombat@@KAIPBUCvCombatMemberEntry@@HPAVCvUnit@@PAVCvPlot@@H@Z ; CvUnitCombat::ApplyNuclearExplosionDamage
EXTRN	??3CvDllCity@@SAXPAX@Z:PROC			; CvDllCity::operator delete
EXTRN	?setDamage@CvCity@@QAEXH_N@Z:PROC		; CvCity::setDamage
EXTRN	?changePopulation@CvCity@@QAEXH_N@Z:PROC	; CvCity::changePopulation
EXTRN	?getNukeModifier@CvCity@@QBEHXZ:PROC		; CvCity::getNukeModifier
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	?CheckForMurder@CvPlayer@@QAEXW4PlayerTypes@@@Z:PROC ; CvPlayer::CheckForMurder
EXTRN	?kill@CvCity@@QAEXXZ:PROC			; CvCity::kill
EXTRN	??0CvDllCity@@QAE@PAVCvCity@@@Z:PROC		; CvDllCity::CvDllCity
EXTRN	??2CvDllCity@@SAPAXI@Z:PROC			; CvDllCity::operator new
EXTRN	?IsOriginalCapital@CvCity@@QBE_NXZ:PROC		; CvCity::IsOriginalCapital
EXTRN	?setCombatUnit@CvCity@@QAEXPAVCvUnit@@_N@Z:PROC	; CvCity::setCombatUnit
EXTRN	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z:PROC ; CvPlot::setFeatureType
EXTRN	?SetImprovementPillaged@CvPlot@@QAEX_N@Z:PROC	; CvPlot::SetImprovementPillaged
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?isNukeImmune@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::isNukeImmune
EXTRN	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z:PROC ; CvGlobals::getFeatureInfo
EXTRN	?ChangeNumTimesNuked@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDiplomacyAI::ChangeNumTimesNuked
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z:PROC	; CvUnit::kill
EXTRN	?IsCanAttackRanged@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsCanAttackRanged
EXTRN	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z:PROC ; CvUnit::SetAutomateType
EXTRN	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z:PROC	; CvPlayer::getUnit
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
xdata$x	SEGMENT
__unwindtable$?ApplyNuclearExplosionDamage@CvUnitCombat@@KAIPBUCvCombatMemberEntry@@HPAVCvUnit@@PAVCvPlot@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyNuclearExplosionDamage@CvUnitCombat@@KAIPBUCvCombatMemberEntry@@HPAVCvUnit@@PAVCvPlot@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyNuclearExplosionDamage@CvUnitCombat@@KAIPBUCvCombatMemberEntry@@HPAVCvUnit@@PAVCvPlot@@H@Z$1
__ehfuncinfo$?ApplyNuclearExplosionDamage@CvUnitCombat@@KAIPBUCvCombatMemberEntry@@HPAVCvUnit@@PAVCvPlot@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ApplyNuclearExplosionDamage@CvUnitCombat@@KAIPBUCvCombatMemberEntry@@HPAVCvUnit@@PAVCvPlot@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
xdata$x	ENDS
;	COMDAT ?ApplyNuclearExplosionDamage@CvUnitCombat@@KAIPBUCvCombatMemberEntry@@HPAVCvUnit@@PAVCvPlot@@H@Z
_TEXT	SEGMENT
tv67 = -40						; size = 4
_uiOpposingDamageCount$ = -36				; size = 4
tv1132 = -32						; size = 4
tv1147 = -28						; size = 4
tv269 = -24						; size = 4
_iBlastRadius$ = -24					; size = 4
tv719 = -20						; size = 4
$T227316 = -20						; size = 4
$T227315 = -20						; size = 4
tv723 = -16						; size = 4
$T227314 = -16						; size = 4
_iNukedPopulation$223190 = -16				; size = 4
$T227311 = -16						; size = 4
_pkDllCity$223169 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pkDamageArray$ = 8					; size = 4
tv1201 = 12						; size = 4
_iDamageMembers$ = 12					; size = 4
_pkAttacker$ = 16					; size = 4
_pkTargetPlot$ = 20					; size = 4
_iDamageLevel$ = 24					; size = 4
?ApplyNuclearExplosionDamage@CvUnitCombat@@KAIPBUCvCombatMemberEntry@@HPAVCvUnit@@PAVCvPlot@@H@Z PROC ; CvUnitCombat::ApplyNuclearExplosionDamage, COMDAT

; 2434 : {

	push	-1
	push	__ehhandler$?ApplyNuclearExplosionDamage@CvUnitCombat@@KAIPBUCvCombatMemberEntry@@HPAVCvUnit@@PAVCvPlot@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp

; 2435 : 	uint uiOpposingDamageCount = 0;
; 2436 : 	PlayerTypes eAttackerOwner = pkAttacker?pkAttacker->getOwner():NO_PLAYER;

	mov	ebp, DWORD PTR _pkAttacker$[esp+44]
	push	esi
	push	edi
	mov	DWORD PTR _uiOpposingDamageCount$[esp+56], 0
	test	ebp, ebp
	je	SHORT $LN43@ApplyNucle
	mov	eax, DWORD PTR [ebp+40]
	mov	DWORD PTR tv67[esp+56], eax
	jmp	SHORT $LN44@ApplyNucle
$LN43@ApplyNucle:
	mov	DWORD PTR tv67[esp+56], -1
$LN44@ApplyNucle:

; 2437 : 
; 2438 : 	// Do all the units first
; 2439 : 	for(int i = 0; i < iDamageMembers; ++i)

	mov	ebx, DWORD PTR _iDamageMembers$[esp+52]
	test	ebx, ebx
	jle	$LN38@ApplyNucle
	mov	edi, DWORD PTR _pkDamageArray$[esp+52]
	add	edi, 4
$LL40@ApplyNucle:

; 2440 : 	{
; 2441 : 		const CvCombatMemberEntry& kEntry = pkDamageArray[i];
; 2442 : 		if(kEntry.IsUnit())

	mov	eax, DWORD PTR [edi-4]
	cmp	eax, -1
	je	$LN39@ApplyNucle
	mov	ecx, DWORD PTR [edi]
	cmp	ecx, -1
	je	$LN39@ApplyNucle
	test	BYTE PTR [edi+4], 1
	jne	$LN39@ApplyNucle

; 2443 : 		{
; 2444 : 			CvUnit* pkUnit = GET_PLAYER(kEntry.GetPlayer()).getUnit(kEntry.GetUnitID());

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax

; 2445 : 			if(pkUnit)

	test	esi, esi
	je	$LN39@ApplyNucle

; 2446 : 			{
; 2447 : 				// Apply the damage
; 2448 : 				pkUnit->setCombatUnit(NULL);

	push	0
	push	0
	mov	ecx, esi
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 2449 : 				pkUnit->ClearMissionQueue();

	push	1
	mov	ecx, esi
	call	?ClearMissionQueue@CvUnit@@QAEXH@Z	; CvUnit::ClearMissionQueue

; 2450 : 				pkUnit->SetAutomateType(NO_AUTOMATE); // kick unit out of automation

	push	-1
	mov	ecx, esi
	call	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z ; CvUnit::SetAutomateType

; 2451 : 
; 2452 : 				if((eAttackerOwner == NO_PLAYER || pkUnit->getOwner() != eAttackerOwner) && !pkUnit->isBarbarian())

	cmp	DWORD PTR tv67[esp+56], -1
	je	SHORT $LN34@ApplyNucle
	mov	ecx, DWORD PTR tv67[esp+56]
	cmp	DWORD PTR [esi+40], ecx
	je	SHORT $LN35@ApplyNucle
$LN34@ApplyNucle:
	mov	ecx, esi
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	test	al, al
	jne	SHORT $LN35@ApplyNucle

; 2453 : 					uiOpposingDamageCount++;	// Count the number of non-barbarian opposing units

	inc	DWORD PTR _uiOpposingDamageCount$[esp+56]
$LN35@ApplyNucle:

; 2454 : 
; 2455 : 				if(pkUnit->IsCombatUnit() || pkUnit->IsCanAttackRanged())

	cmp	DWORD PTR [esi+1044], 0
	jg	SHORT $LN32@ApplyNucle
	mov	ecx, esi
	call	?IsCanAttackRanged@CvUnit@@QBE_NXZ	; CvUnit::IsCanAttackRanged
	test	al, al
	jne	SHORT $LN32@ApplyNucle

; 2458 : 				}
; 2459 : 				else if(kEntry.GetDamage() >= /*6*/ GC.getNUKE_NON_COMBAT_DEATH_THRESHOLD())

	movsx	edx, WORD PTR [edi+6]
	cmp	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6636
	jl	SHORT $LN30@ApplyNucle

; 2460 : 				{
; 2461 : 					pkUnit->kill(false, eAttackerOwner);

	mov	eax, DWORD PTR tv67[esp+56]
	push	eax
	push	0
	mov	ecx, esi
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill
	jmp	SHORT $LN30@ApplyNucle
$LN32@ApplyNucle:

; 2456 : 				{
; 2457 : 					pkUnit->changeDamage(kEntry.GetDamage(), eAttackerOwner);

	movsx	edx, WORD PTR [edi+6]
	push	0
	push	ecx
	mov	ecx, DWORD PTR tv67[esp+64]
	mov	DWORD PTR [esp], 0
	push	ecx
	push	edx
	mov	ecx, esi
	call	?changeDamage@CvUnit@@QAEHHW4PlayerTypes@@MPBVCvString@@@Z ; CvUnit::changeDamage
$LN30@ApplyNucle:

; 2462 : 				}
; 2463 : 
; 2464 : #ifdef AUI_WARNING_FIXES
; 2465 : 				if (pkAttacker)
; 2466 : #endif
; 2467 : 				GET_PLAYER(kEntry.GetPlayer()).GetDiplomacyAI()->ChangeNumTimesNuked(pkAttacker->getOwner(), 1);

	mov	eax, DWORD PTR [edi-4]
	mov	edx, DWORD PTR [ebp+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	1
	push	edx
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ChangeNumTimesNuked@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::ChangeNumTimesNuked
$LN39@ApplyNucle:
	add	edi, 36					; 00000024H
	sub	ebx, 1
	jne	$LL40@ApplyNucle
$LN38@ApplyNucle:

; 2468 : 			}
; 2469 : 		}
; 2470 : 	}
; 2471 : 
; 2472 : 	// Then the terrain effects
; 2473 : 	int iBlastRadius = GC.getNUKE_BLAST_RADIUS();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6672

; 2474 : 
; 2475 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2476 : 	int iMaxDX, iDX;
; 2477 : 	CvPlot* pLoopPlot;
; 2478 : 	if (pkTargetPlot)
; 2479 : 	{
; 2480 : 		for (int iDY = -iBlastRadius; iDY <= iBlastRadius; iDY++)
; 2481 : 		{
; 2482 : 			iMaxDX = iBlastRadius - MAX(0, iDY);
; 2483 : 			for (iDX = -iBlastRadius - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 2484 : 			{
; 2485 : 				// No need for range check because loops are set up properly
; 2486 : 				pLoopPlot = plotXY(pkTargetPlot->getX(), pkTargetPlot->getY(), iDX, iDY);
; 2487 : #else
; 2488 : 	for(int iDX = -(iBlastRadius); iDX <= iBlastRadius; iDX++)

	mov	ebp, eax
	neg	ebp
	mov	ebx, ebp
	cmp	ebx, eax
	mov	DWORD PTR _iBlastRadius$[esp+56], eax
	mov	DWORD PTR tv719[esp+56], ebp
	jg	$LN27@ApplyNucle
	mov	edi, DWORD PTR _pkTargetPlot$[esp+52]
	mov	ecx, ebx
	neg	ecx
	mov	DWORD PTR tv1147[esp+56], ecx
	jmp	SHORT $LN29@ApplyNucle
	npad	2
$LL269@ApplyNucle:

; 2468 : 			}
; 2469 : 		}
; 2470 : 	}
; 2471 : 
; 2472 : 	// Then the terrain effects
; 2473 : 	int iBlastRadius = GC.getNUKE_BLAST_RADIUS();

	mov	eax, DWORD PTR _iBlastRadius$[esp+56]
	mov	ebp, DWORD PTR tv719[esp+56]
$LN29@ApplyNucle:

; 2489 : 	{
; 2490 : 		for(int iDY = -(iBlastRadius); iDY <= iBlastRadius; iDY++)

	cmp	ebp, eax
	jg	$LN28@ApplyNucle

; 2491 : 		{
; 2492 : 			CvPlot* pLoopPlot = plotXYWithRangeCheck(pkTargetPlot->getX(), pkTargetPlot->getY(), iDX, iDY, iBlastRadius);

	xor	eax, eax
	test	ebx, ebx
	setge	al
	mov	DWORD PTR tv723[esp+56], eax
	mov	eax, ebp
	neg	eax
	mov	DWORD PTR tv1132[esp+56], eax
$LL26@ApplyNucle:
	xor	ecx, ecx
	test	ebp, ebp
	setge	cl
	cmp	DWORD PTR tv723[esp+56], ecx
	mov	ecx, ebx
	jne	SHORT $LN107@ApplyNucle
	test	ebx, ebx
	jge	SHORT $LN111@ApplyNucle
	mov	ecx, DWORD PTR tv1147[esp+56]
$LN111@ApplyNucle:
	mov	eax, ebp
	test	ebp, ebp
	jge	SHORT $LN113@ApplyNucle
	mov	eax, DWORD PTR tv1132[esp+56]
$LN113@ApplyNucle:
	add	eax, ecx
	jmp	SHORT $LN118@ApplyNucle
$LN107@ApplyNucle:
	test	ebx, ebx
	jge	SHORT $LN115@ApplyNucle
	mov	ecx, DWORD PTR tv1147[esp+56]
$LN115@ApplyNucle:
	mov	eax, ebp
	test	ebp, ebp
	jge	SHORT $LN117@ApplyNucle
	mov	eax, DWORD PTR tv1132[esp+56]
$LN117@ApplyNucle:
	cmp	ecx, eax
	jl	SHORT $LN118@ApplyNucle
	mov	eax, ecx
$LN118@ApplyNucle:
	cmp	eax, DWORD PTR _iBlastRadius$[esp+56]
	jg	$LN25@ApplyNucle
	movsx	edx, WORD PTR [edi+2]
	movsx	eax, WORD PTR [edi]
	push	ebp
	push	ebx
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	esi, eax
	add	esp, 16					; 00000010H

; 2493 : #endif
; 2494 : 
; 2495 : 			if(pLoopPlot != NULL)

	test	esi, esi
	je	$LN25@ApplyNucle

; 2496 : 			{
; 2497 : 				// if we remove roads, don't remove them on the city... XXX
; 2498 : 				CvCity* pLoopCity = pLoopPlot->getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN256@ApplyNucle
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN256@ApplyNucle
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 2499 : 
; 2500 : 				if(pLoopCity == NULL)

	test	eax, eax
	jne	$LN25@ApplyNucle
$LN256@ApplyNucle:

; 2501 : 				{
; 2502 : 					if(!(pLoopPlot->isWater()) && !(pLoopPlot->isImpassable()))

	cmp	BYTE PTR [esi+5], 3
	je	$LN25@ApplyNucle
	test	BYTE PTR [esi+462], 128			; 00000080H
	jne	$LN25@ApplyNucle

; 2503 : 					{
; 2504 : 						if(pLoopPlot->getFeatureType() != NO_FEATURE)

	mov	al, BYTE PTR [esi+432]
	cmp	al, -1
	je	SHORT $LN20@ApplyNucle

; 2505 : 						{
; 2506 : 							CvFeatureInfo* pkFeatureInfo = GC.getFeatureInfo(pLoopPlot->getFeatureType());

	movsx	edx, al
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo

; 2507 : 							if(pkFeatureInfo && !pkFeatureInfo->isNukeImmune())

	test	eax, eax
	je	$LN25@ApplyNucle
	mov	ecx, eax
	call	?isNukeImmune@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isNukeImmune
	test	al, al
	jne	$LN25@ApplyNucle

; 2508 : 							{
; 2509 : 								if(pLoopPlot == pkTargetPlot || GC.getGame().getJonRandNum(100, "Nuke Fallout") < GC.getNUKE_FALLOUT_PROB())

	cmp	esi, edi
	je	SHORT $LN17@ApplyNucle
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6620
	push	OFFSET $SG223098
	push	100					; 00000064H
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	cmp	eax, edi
	jge	SHORT $LN268@ApplyNucle
	mov	edi, DWORD PTR _pkTargetPlot$[esp+52]
$LN17@ApplyNucle:

; 2510 : 								{
; 2511 : 									if(pLoopPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN264@ApplyNucle

; 2512 : 									{
; 2513 : 										pLoopPlot->SetImprovementPillaged(true);

	push	1
	mov	ecx, esi
	call	?SetImprovementPillaged@CvPlot@@QAEX_N@Z ; CvPlot::SetImprovementPillaged
$LN264@ApplyNucle:

; 2514 : 									}
; 2515 : 									pLoopPlot->setFeatureType((FeatureTypes)(GC.getNUKE_FEATURE()));

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8404
	push	-1
	push	eax
	mov	ecx, esi
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 2516 : 								}
; 2517 : 							}
; 2518 : 						}
; 2519 : 						else

	jmp	SHORT $LN25@ApplyNucle
$LN20@ApplyNucle:

; 2520 : 						{
; 2521 : 							if(pLoopPlot == pkTargetPlot || GC.getGame().getJonRandNum(100, "Nuke Fallout") < GC.getNUKE_FALLOUT_PROB())

	cmp	esi, edi
	je	SHORT $LN13@ApplyNucle
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6620
	push	OFFSET $SG223104
	push	100					; 00000064H
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	cmp	eax, edi
	jge	SHORT $LN268@ApplyNucle
	mov	edi, DWORD PTR _pkTargetPlot$[esp+52]
$LN13@ApplyNucle:

; 2522 : 							{
; 2523 : 								if(pLoopPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN265@ApplyNucle

; 2524 : 								{
; 2525 : 									pLoopPlot->SetImprovementPillaged(true);

	push	1
	mov	ecx, esi
	call	?SetImprovementPillaged@CvPlot@@QAEX_N@Z ; CvPlot::SetImprovementPillaged
$LN265@ApplyNucle:

; 2526 : 								}
; 2527 : 								pLoopPlot->setFeatureType((FeatureTypes)(GC.getNUKE_FEATURE()));

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8404
	push	-1
	push	ecx
	mov	ecx, esi
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType
	jmp	SHORT $LN25@ApplyNucle
$LN268@ApplyNucle:
	mov	edi, DWORD PTR _pkTargetPlot$[esp+52]
$LN25@ApplyNucle:

; 2489 : 	{
; 2490 : 		for(int iDY = -(iBlastRadius); iDY <= iBlastRadius; iDY++)

	dec	DWORD PTR tv1132[esp+56]
	inc	ebp
	cmp	ebp, DWORD PTR _iBlastRadius$[esp+56]
	jle	$LL26@ApplyNucle
$LN28@ApplyNucle:

; 2474 : 
; 2475 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2476 : 	int iMaxDX, iDX;
; 2477 : 	CvPlot* pLoopPlot;
; 2478 : 	if (pkTargetPlot)
; 2479 : 	{
; 2480 : 		for (int iDY = -iBlastRadius; iDY <= iBlastRadius; iDY++)
; 2481 : 		{
; 2482 : 			iMaxDX = iBlastRadius - MAX(0, iDY);
; 2483 : 			for (iDX = -iBlastRadius - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 2484 : 			{
; 2485 : 				// No need for range check because loops are set up properly
; 2486 : 				pLoopPlot = plotXY(pkTargetPlot->getX(), pkTargetPlot->getY(), iDX, iDY);
; 2487 : #else
; 2488 : 	for(int iDX = -(iBlastRadius); iDX <= iBlastRadius; iDX++)

	dec	DWORD PTR tv1147[esp+56]
	inc	ebx
	cmp	ebx, DWORD PTR _iBlastRadius$[esp+56]
	jle	$LL269@ApplyNucle
$LN27@ApplyNucle:

; 2528 : 							}
; 2529 : 						}
; 2530 : 					}
; 2531 : 				}
; 2532 : 			}
; 2533 : 		}
; 2534 : 	}
; 2535 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2536 : 	}
; 2537 : #endif
; 2538 : 
; 2539 : 	// Then the cities
; 2540 : 	for(int i = 0; i < iDamageMembers; ++i)

	mov	eax, DWORD PTR _iDamageMembers$[esp+52]
	test	eax, eax
	jle	$LN261@ApplyNucle
	mov	edi, DWORD PTR _pkDamageArray$[esp+52]
	add	edi, 4
	mov	DWORD PTR tv1201[esp+52], edi
	mov	DWORD PTR tv269[esp+56], eax
	npad	6
$LL11@ApplyNucle:

; 2541 : 	{
; 2542 : 		const CvCombatMemberEntry& kEntry = pkDamageArray[i];
; 2543 : 		if(kEntry.IsCity())

	mov	eax, DWORD PTR [edi-4]
	cmp	eax, -1
	je	$LN10@ApplyNucle
	mov	ecx, DWORD PTR [edi]
	cmp	ecx, -1
	je	$LN10@ApplyNucle
	test	BYTE PTR [edi+4], 1
	je	$LN10@ApplyNucle

; 2544 : 		{
; 2545 : 			CvCity* pkCity = GET_PLAYER(kEntry.GetPlayer()).getCity(kEntry.GetCityID());

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	esi, eax

; 2546 : 			if(pkCity)

	test	esi, esi
	je	$LN10@ApplyNucle

; 2547 : 			{
; 2548 : 				pkCity->setCombatUnit(NULL);

	push	0
	push	0
	mov	ecx, esi
	call	?setCombatUnit@CvCity@@QAEXPAVCvUnit@@_N@Z ; CvCity::setCombatUnit

; 2549 : 
; 2550 : 				if(eAttackerOwner == NO_PLAYER || pkCity->getOwner() != eAttackerOwner)

	mov	eax, DWORD PTR tv67[esp+56]
	cmp	eax, -1
	je	SHORT $LN5@ApplyNucle
	cmp	DWORD PTR [esi+84], eax
	je	SHORT $LN267@ApplyNucle
$LN5@ApplyNucle:

; 2551 : 					uiOpposingDamageCount++;

	inc	DWORD PTR _uiOpposingDamageCount$[esp+56]
$LN267@ApplyNucle:

; 2552 : 
; 2553 : 				if(kEntry.GetFinalDamage() >= pkCity->GetMaxHitPoints() && !pkCity->IsOriginalCapital())

	movsx	edi, WORD PTR [edi+8]
	mov	ecx, esi
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	cmp	edi, eax
	jl	$LN4@ApplyNucle
	mov	ecx, esi
	call	?IsOriginalCapital@CvCity@@QBE_NXZ	; CvCity::IsOriginalCapital
	test	al, al
	jne	$LN4@ApplyNucle

; 2554 : 				{
; 2555 : 					auto_ptr<ICvCity1> pkDllCity(new CvDllCity(pkCity));

	push	12					; 0000000cH
	call	??2CvDllCity@@SAPAXI@Z			; CvDllCity::operator new
	add	esp, 4
	mov	DWORD PTR $T227311[esp+56], eax
	mov	DWORD PTR __$EHRec$[esp+64], 0
	test	eax, eax
	je	SHORT $LN45@ApplyNucle
	push	esi
	mov	ecx, eax
	call	??0CvDllCity@@QAE@PAVCvCity@@@Z		; CvDllCity::CvDllCity
	mov	edi, eax
	jmp	SHORT $LN46@ApplyNucle
$LN45@ApplyNucle:
	xor	edi, edi
$LN46@ApplyNucle:
	mov	DWORD PTR _pkDllCity$223169[esp+56], edi

; 2556 : 					gDLL->GameplayCitySetDamage(pkDllCity.get(), 0, pkCity->getDamage()); // to stop the fires

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	ebx, DWORD PTR [ebp]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+64], 1
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	mov	edx, DWORD PTR [ebx+660]
	push	eax
	push	0
	push	edi
	mov	ecx, ebp
	call	edx

; 2557 : 					gDLL->GameplayCityDestroyed(pkDllCity.get(), NO_PLAYER);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+652]
	push	-1
	push	edi
	call	edx

; 2558 : 
; 2559 : 					PlayerTypes eOldOwner = pkCity->getOwner();

	mov	ebx, DWORD PTR [esi+84]

; 2560 : 					pkCity->kill();

	mov	ecx, esi
	call	?kill@CvCity@@QAEXXZ			; CvCity::kill

; 2561 : 
; 2562 : 					// slewis - check for killing a player
; 2563 : #ifdef AUI_WARNING_FIXES
; 2564 : 					if (pkAttacker)
; 2565 : #endif
; 2566 : 					GET_PLAYER(pkAttacker->getOwner()).CheckForMurder(eOldOwner);

	mov	eax, DWORD PTR _pkAttacker$[esp+52]
	mov	ecx, DWORD PTR [eax+40]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	call	?CheckForMurder@CvPlayer@@QAEXW4PlayerTypes@@@Z ; CvPlayer::CheckForMurder

; 2567 : 				}

	mov	DWORD PTR __$EHRec$[esp+64], -1
	test	edi, edi
	je	$LN262@ApplyNucle
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+4]
	push	edi
	call	edx

; 2568 : 				else

	jmp	$LN262@ApplyNucle
$LN4@ApplyNucle:

; 2569 : 				{
; 2570 : 					// Unlike the city hit points, the population damage is calculated when the pre-calculated damage is applied.
; 2571 : 					// This is simply to save space in the damage array, since the combat visualization does not need it.
; 2572 : 					// It can be moved into the pre-calculated damage array if needed.
; 2573 : 					int iBaseDamage, iRandDamage1, iRandDamage2;
; 2574 : 					// How much destruction is unleashed on nearby Cities?
; 2575 : 					if(iDamageLevel == 1)

	cmp	DWORD PTR _iDamageLevel$[esp+52], 1

; 2576 : 					{
; 2577 : 						iBaseDamage = /*30*/ GC.getNUKE_LEVEL1_POPULATION_DEATH_BASE();
; 2578 : 						iRandDamage1 = GC.getGame().getJonRandNum(/*20*/ GC.getNUKE_LEVEL1_POPULATION_DEATH_RAND_1(), "Population Nuked 1");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	jne	SHORT $LN2@ApplyNucle
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6644
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6640
	push	OFFSET $SG223185
	push	eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 2579 : 						iRandDamage2 = GC.getGame().getJonRandNum(/*20*/ GC.getNUKE_LEVEL1_POPULATION_DEATH_RAND_2(), "Population Nuked 2");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6648
	push	OFFSET $SG223186
	mov	ebp, eax
	push	ecx

; 2580 : 					}
; 2581 : 					else

	jmp	SHORT $LN271@ApplyNucle
$LN2@ApplyNucle:

; 2582 : 					{
; 2583 : 						iBaseDamage = /*60*/ GC.getNUKE_LEVEL2_POPULATION_DEATH_BASE();
; 2584 : 						iRandDamage1 = GC.getGame().getJonRandNum(/*10*/ GC.getNUKE_LEVEL2_POPULATION_DEATH_RAND_1(), "Population Nuked 1");

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6656
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6652
	push	OFFSET $SG223188
	push	edx
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	ebp, eax

; 2585 : 						iRandDamage2 = GC.getGame().getJonRandNum(/*10*/ GC.getNUKE_LEVEL2_POPULATION_DEATH_RAND_2(), "Population Nuked 2");

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6660
	push	OFFSET $SG223189
	push	eax
$LN271@ApplyNucle:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 2586 : 					}
; 2587 : 
; 2588 : 					int iNukedPopulation = pkCity->getPopulation() * (iBaseDamage + iRandDamage1 + iRandDamage2) / 100;

	mov	ecx, esi
	mov	ebx, eax
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	mov	ecx, eax
	add	ebx, ebp
	add	ebx, edi
	imul	ecx, ebx
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH

; 2589 : 
; 2590 : 					iNukedPopulation *= std::max(0, (pkCity->getNukeModifier() + 100));

	mov	ecx, esi
	add	edi, edx
	call	?getNukeModifier@CvCity@@QBEHXZ		; CvCity::getNukeModifier
	add	eax, 100				; 00000064H
	mov	DWORD PTR $T227314[esp+56], eax
	test	eax, eax
	mov	DWORD PTR $T227315[esp+56], 0
	lea	eax, DWORD PTR $T227314[esp+56]
	jg	SHORT $LN227@ApplyNucle
	lea	eax, DWORD PTR $T227315[esp+56]
$LN227@ApplyNucle:
	mov	ecx, DWORD PTR [eax]
	imul	ecx, edi

; 2591 : 					iNukedPopulation /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx

; 2592 : 
; 2593 : 					pkCity->changePopulation(-(std::min((pkCity->getPopulation() - 1), iNukedPopulation)));

	mov	ecx, esi
	mov	DWORD PTR _iNukedPopulation$223190[esp+56], edi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	dec	eax
	mov	DWORD PTR $T227316[esp+56], eax
	cmp	edi, eax
	lea	eax, DWORD PTR _iNukedPopulation$223190[esp+56]
	jl	SHORT $LN231@ApplyNucle
	lea	eax, DWORD PTR $T227316[esp+56]
$LN231@ApplyNucle:
	mov	ecx, DWORD PTR [eax]
	neg	ecx
	push	1
	push	ecx
	mov	ecx, esi
	call	?changePopulation@CvCity@@QAEXH_N@Z	; CvCity::changePopulation

; 2594 : 
; 2595 : 					// Add damage to the city
; 2596 : 					pkCity->setDamage(kEntry.GetFinalDamage());

	mov	edx, DWORD PTR tv1201[esp+52]
	movsx	eax, WORD PTR [edx+8]
	push	0
	push	eax
	mov	ecx, esi
	call	?setDamage@CvCity@@QAEXH_N@Z		; CvCity::setDamage

; 2597 : 
; 2598 : #ifdef AUI_WARNING_FIXES
; 2599 : 					if (pkAttacker)
; 2600 : #endif
; 2601 : 					GET_PLAYER(pkCity->getOwner()).GetDiplomacyAI()->ChangeNumTimesNuked(pkAttacker->getOwner(), 1);

	mov	ecx, DWORD PTR _pkAttacker$[esp+52]
	mov	eax, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR [esi+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	1
	push	eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ChangeNumTimesNuked@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::ChangeNumTimesNuked
$LN262@ApplyNucle:

; 2568 : 				else

	mov	edi, DWORD PTR tv1201[esp+52]
$LN10@ApplyNucle:

; 2528 : 							}
; 2529 : 						}
; 2530 : 					}
; 2531 : 				}
; 2532 : 			}
; 2533 : 		}
; 2534 : 	}
; 2535 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2536 : 	}
; 2537 : #endif
; 2538 : 
; 2539 : 	// Then the cities
; 2540 : 	for(int i = 0; i < iDamageMembers; ++i)

	add	edi, 36					; 00000024H
	sub	DWORD PTR tv269[esp+56], 1
	mov	DWORD PTR tv1201[esp+52], edi
	jne	$LL11@ApplyNucle
$LN261@ApplyNucle:

; 2602 : 				}
; 2603 : 			}
; 2604 : 		}
; 2605 : 	}
; 2606 : 	return uiOpposingDamageCount;
; 2607 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	mov	eax, DWORD PTR _uiOpposingDamageCount$[esp+56]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ApplyNuclearExplosionDamage@CvUnitCombat@@KAIPBUCvCombatMemberEntry@@HPAVCvUnit@@PAVCvPlot@@H@Z$0:
	mov	eax, DWORD PTR $T227311[ebp]
	push	eax
	call	??3CvDllCity@@SAXPAX@Z			; CvDllCity::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ApplyNuclearExplosionDamage@CvUnitCombat@@KAIPBUCvCombatMemberEntry@@HPAVCvUnit@@PAVCvPlot@@H@Z$1:
	lea	ecx, DWORD PTR _pkDllCity$223169[ebp]
	jmp	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ	; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
__ehhandler$?ApplyNuclearExplosionDamage@CvUnitCombat@@KAIPBUCvCombatMemberEntry@@HPAVCvUnit@@PAVCvPlot@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?ApplyNuclearExplosionDamage@CvUnitCombat@@KAIPBUCvCombatMemberEntry@@HPAVCvUnit@@PAVCvPlot@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ApplyNuclearExplosionDamage@CvUnitCombat@@KAIPBUCvCombatMemberEntry@@HPAVCvUnit@@PAVCvPlot@@H@Z ENDP ; CvUnitCombat::ApplyNuclearExplosionDamage
PUBLIC	?ResolveNuclearCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveNuclearCombat
EXTRN	?finishMoves@CvUnit@@QAEXXZ:PROC		; CvUnit::finishMoves
EXTRN	?isOutOfAttacks@CvUnit@@QBE_NXZ:PROC		; CvUnit::isOutOfAttacks
EXTRN	?canMoveAfterAttacking@CvUnit@@QBE_NXZ:PROC	; CvUnit::canMoveAfterAttacking
EXTRN	?changeMoves@CvUnit@@QAEXH@Z:PROC		; CvUnit::changeMoves
EXTRN	?setAttackPlot@CvUnit@@QAEXPBVCvPlot@@_N@Z:PROC	; CvUnit::setAttackPlot
EXTRN	?isSuicide@CvUnit@@QBE_NXZ:PROC			; CvUnit::isSuicide
EXTRN	__imp__strncmp:PROC
EXTRN	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ:PROC	; CvPlayer::getCivilizationTypeKey
EXTRN	?getGameTurnYear@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurnYear
EXTRN	?getDamageMembers@CvCombatInfo@@QBEPBUCvCombatMemberEntry@@XZ:PROC ; CvCombatInfo::getDamageMembers
EXTRN	?getDamageMemberCount@CvCombatInfo@@QBEHXZ:PROC	; CvCombatInfo::getDamageMemberCount
EXTRN	?getAttackNuclearLevel@CvCombatInfo@@QBEHXZ:PROC ; CvCombatInfo::getAttackNuclearLevel
EXTRN	?setTransportUnit@CvUnit@@QAEXPAV1@@Z:PROC	; CvUnit::setTransportUnit
EXTRN	?changeNukesExploded@CvGame@@QAEXH@Z:PROC	; CvGame::changeNukesExploded
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?ResolveNuclearCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ResolveNuclearCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$0
__ehfuncinfo$?ResolveNuclearCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ResolveNuclearCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
xdata$x	ENDS
;	COMDAT ?ResolveNuclearCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
_TEXT	SEGMENT
_strBuffer$ = -40					; size = 28
__$EHRec$ = -12						; size = 12
_kCombatInfo$ = 8					; size = 4
_uiParentEventID$ = 12					; size = 4
?ResolveNuclearCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z PROC ; CvUnitCombat::ResolveNuclearCombat, COMDAT

; 2759 : {

	push	-1
	push	__ehhandler$?ResolveNuclearCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi

; 2760 : 	UNREFERENCED_PARAMETER(uiParentEventID);
; 2761 : 
; 2762 : 	CvUnit* pkAttacker = kCombatInfo.getUnit(BATTLE_UNIT_ATTACKER);

	mov	edi, DWORD PTR _kCombatInfo$[esp+48]
	push	0
	mov	ecx, edi
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit

; 2763 : 	CvAssert_Debug(pkAttacker);
; 2764 : 
; 2765 : 	CvPlot* pkTargetPlot = kCombatInfo.getPlot();

	mov	ecx, edi
	mov	esi, eax
	call	?getPlot@CvCombatInfo@@QBEPAVCvPlot@@XZ	; CvCombatInfo::getPlot

; 2766 : 	CvAssert_Debug(pkTargetPlot);
; 2767 : 
; 2768 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[esp+52]
	mov	ebx, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2769 : 
; 2770 : 	GC.getGame().changeNukesExploded(1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	1
	mov	DWORD PTR __$EHRec$[esp+64], 0
	call	?changeNukesExploded@CvGame@@QAEXH@Z	; CvGame::changeNukesExploded

; 2771 : 
; 2772 : 	if(pkAttacker)

	test	esi, esi
	je	$LN9@ResolveNuc

; 2773 : 	{
; 2774 : 		// Make sure we are disconnected from any unit transporting the attacker (i.e. its a missile)
; 2775 : 		pkAttacker->setTransportUnit(NULL);

	push	0
	mov	ecx, esi
	call	?setTransportUnit@CvUnit@@QAEXPAV1@@Z	; CvUnit::setTransportUnit

; 2776 : 
; 2777 : 		if(pkTargetPlot)

	test	ebx, ebx
	je	$LN4@ResolveNuc

; 2778 : 		{
; 2779 : 			if(ApplyNuclearExplosionDamage(kCombatInfo.getDamageMembers(), kCombatInfo.getDamageMemberCount(), pkAttacker, pkTargetPlot, kCombatInfo.getAttackNuclearLevel() - 1) > 0)

	mov	ecx, edi
	call	?getAttackNuclearLevel@CvCombatInfo@@QBEHXZ ; CvCombatInfo::getAttackNuclearLevel
	dec	eax
	push	eax
	push	ebx
	push	esi
	mov	ecx, edi
	call	?getDamageMemberCount@CvCombatInfo@@QBEHXZ ; CvCombatInfo::getDamageMemberCount
	push	eax
	mov	ecx, edi
	call	?getDamageMembers@CvCombatInfo@@QBEPBUCvCombatMemberEntry@@XZ ; CvCombatInfo::getDamageMembers
	push	eax
	call	?ApplyNuclearExplosionDamage@CvUnitCombat@@KAIPBUCvCombatMemberEntry@@HPAVCvUnit@@PAVCvPlot@@H@Z ; CvUnitCombat::ApplyNuclearExplosionDamage
	add	esp, 20					; 00000014H
	test	eax, eax
	jbe	SHORT $LN4@ResolveNuc

; 2780 : 			{
; 2781 : 				if(pkAttacker->getOwner() == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, DWORD PTR [esi+40]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	edi, eax
	jne	SHORT $LN4@ResolveNuc

; 2782 : 				{
; 2783 : 					// Must damage someone to get the achievement.
; 2784 : 					gDLL->UnlockAchievement(ACHIEVEMENT_DROP_NUKE);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+828]
	push	72					; 00000048H
	call	edx

; 2785 : 
; 2786 : 					if(GC.getGame().getGameTurnYear() == 2012)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurnYear@CvGame@@QAEHXZ		; CvGame::getGameTurnYear
	cmp	eax, 2012				; 000007dcH
	jne	SHORT $LN4@ResolveNuc

; 2787 : 					{
; 2788 : 						CvPlayerAI& kPlayer = GET_PLAYER(GC.getGame().getActivePlayer());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 2789 : 						if(strncmp(kPlayer.getCivilizationTypeKey(), "CIVILIZATION_MAYA", 32) == 0)

	push	32					; 00000020H
	push	OFFSET $SG223397
	mov	ecx, eax
	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@ResolveNuc

; 2790 : 						{
; 2791 : 							gDLL->UnlockAchievement(ACHIEVEMENT_XP1_36);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+828]
	push	226					; 000000e2H
	call	edx
$LN4@ResolveNuc:

; 2792 : 						}
; 2793 : 
; 2794 : 					}
; 2795 : 
; 2796 : 				}
; 2797 : 			}
; 2798 : 		}
; 2799 : 
; 2800 : 		// Suicide Unit (currently all nuclear attackers are)
; 2801 : 		if(pkAttacker->isSuicide())

	mov	ecx, esi
	call	?isSuicide@CvUnit@@QBE_NXZ		; CvUnit::isSuicide

; 2802 : 		{
; 2803 : 			pkAttacker->setCombatUnit(NULL);	// Must clear this if doing a delayed kill, should this be part of the kill method?

	push	0
	mov	ecx, esi
	push	0
	test	al, al
	je	SHORT $LN3@ResolveNuc
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 2804 : 			pkAttacker->setAttackPlot(NULL, false);

	push	0
	push	0
	mov	ecx, esi
	call	?setAttackPlot@CvUnit@@QAEXPBVCvPlot@@_N@Z ; CvUnit::setAttackPlot

; 2805 : 			pkAttacker->kill(true);

	push	-1
	push	1
	mov	ecx, esi
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill

; 2806 : 		}
; 2807 : 		else

	jmp	SHORT $LN1@ResolveNuc
$LN3@ResolveNuc:

; 2808 : 		{
; 2809 : 			CvAssertMsg(pkAttacker->isSuicide(), "A nuke unit that is not a one time use?");
; 2810 : 
; 2811 : 			// Clean up some stuff
; 2812 : 			pkAttacker->setCombatUnit(NULL);

	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 2813 : 			pkAttacker->ClearMissionQueue(GetPostCombatDelay());

	call	?quickCombat@CvPreGame@@YA_NXZ		; CvPreGame::quickCombat
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	and	eax, 109				; 0000006dH
	inc	eax
	push	eax
	mov	ecx, esi
	call	?ClearMissionQueue@CvUnit@@QAEXH@Z	; CvUnit::ClearMissionQueue

; 2814 : 			pkAttacker->SetAutomateType(NO_AUTOMATE); // kick unit out of automation

	push	-1
	mov	ecx, esi
	call	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z ; CvUnit::SetAutomateType

; 2815 : 
; 2816 : 			// Spend a move for this attack
; 2817 : 			pkAttacker->changeMoves(-GC.getMOVE_DENOMINATOR());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	neg	ecx
	push	ecx
	mov	ecx, esi
	call	?changeMoves@CvUnit@@QAEXH@Z		; CvUnit::changeMoves

; 2818 : 
; 2819 : 			// Can't move or attack again
; 2820 : #ifdef NQ_UNIT_TURN_ENDS_ON_FINAL_ATTACK
; 2821 : 			if(!pkAttacker->canMoveAfterAttacking() && pkAttacker->isOutOfAttacks())

	mov	ecx, esi
	call	?canMoveAfterAttacking@CvUnit@@QBE_NXZ	; CvUnit::canMoveAfterAttacking
	test	al, al
	jne	SHORT $LN1@ResolveNuc
	mov	ecx, esi
	call	?isOutOfAttacks@CvUnit@@QBE_NXZ		; CvUnit::isOutOfAttacks
	test	al, al
	je	SHORT $LN1@ResolveNuc

; 2822 : #else
; 2823 : 			if(!pkAttacker->canMoveAfterAttacking())
; 2824 : #endif
; 2825 : 			{
; 2826 : 				pkAttacker->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN1@ResolveNuc:

; 2827 : 			}
; 2828 : 		}
; 2829 : 
; 2830 : 		// Report that combat is over in case we want to queue another attack
; 2831 : 		GET_PLAYER(pkAttacker->getOwner()).GetTacticalAI()->CombatResolved(pkAttacker, true);

	mov	eax, DWORD PTR [esi+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	1
	push	esi
	mov	ecx, eax
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z ; CvTacticalAI::CombatResolved
$LN9@ResolveNuc:

; 2832 : 	}
; 2833 : }

	lea	ecx, DWORD PTR _strBuffer$[esp+52]
	mov	DWORD PTR __$EHRec$[esp+60], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ResolveNuclearCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ResolveNuclearCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z:
	mov	eax, OFFSET __ehfuncinfo$?ResolveNuclearCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ResolveNuclearCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ENDP ; CvUnitCombat::ResolveNuclearCombat
PUBLIC	?GetFireSupportUnit@CvUnitCombat@@SAPAVCvUnit@@W4PlayerTypes@@HHHH@Z ; CvUnitCombat::GetFireSupportUnit
EXTRN	?canRangeStrikeAt@CvUnit@@QBE_NHH_N0@Z:PROC	; CvUnit::canRangeStrikeAt
EXTRN	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z:PROC	; CvPlot::getUnitByIndex
EXTRN	?getNumUnits@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumUnits
; Function compile flags: /Ogtpy
;	COMDAT ?GetFireSupportUnit@CvUnitCombat@@SAPAVCvUnit@@W4PlayerTypes@@HHHH@Z
_TEXT	SEGMENT
_pPlot$ = -4						; size = 4
_eDefender$ = 8						; size = 4
_iDefendX$ = 12						; size = 4
_iDefendY$ = 16						; size = 4
_iAttackX$ = 20						; size = 4
_iAttackY$ = 24						; size = 4
?GetFireSupportUnit@CvUnitCombat@@SAPAVCvUnit@@W4PlayerTypes@@HHHH@Z PROC ; CvUnitCombat::GetFireSupportUnit, COMDAT

; 3537 : {

	push	ecx

; 3538 : 	VALIDATE_OBJECT
; 3539 : 
; 3540 : 	if(GC.getFIRE_SUPPORT_DISABLED() == 1)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+7364, 1
	jne	SHORT $LN10@GetFireSup

; 3541 : 		return NULL;

	xor	eax, eax

; 3575 : }

	pop	ecx
	ret	0
$LN10@GetFireSup:

; 3542 : 
; 3543 : 	CvPlot* pAdjacentPlot = NULL;
; 3544 : 	CvPlot* pPlot = GC.getMap().plot(iDefendX, iDefendY);

	mov	eax, DWORD PTR _iDefendX$[esp]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	eax, -2147483647			; 80000001H
	je	$LN17@GetFireSup
	mov	ebx, DWORD PTR _iDefendY$[esp+16]
	cmp	ebx, -2147483647			; 80000001H
	je	SHORT $LN17@GetFireSup
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN69@GetFireSup
	test	eax, eax
	jge	SHORT $LN29@GetFireSup
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN31@GetFireSup
$LN29@GetFireSup:
	cmp	eax, ecx
	jl	SHORT $LN69@GetFireSup
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN31@GetFireSup
$LN69@GetFireSup:
	mov	esi, eax
$LN31@GetFireSup:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN70@GetFireSup
	test	ebx, ebx
	jge	SHORT $LN39@GetFireSup
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN41@GetFireSup
$LN39@GetFireSup:
	cmp	ebx, edi
	jl	SHORT $LN70@GetFireSup
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN41@GetFireSup
$LN70@GetFireSup:
	mov	edx, ebx
$LN41@GetFireSup:
	test	esi, esi
	jl	SHORT $LN17@GetFireSup
	cmp	esi, ecx
	jge	SHORT $LN17@GetFireSup
	test	edx, edx
	jl	SHORT $LN17@GetFireSup
	cmp	edx, edi
	jge	SHORT $LN17@GetFireSup
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	mov	DWORD PTR _pPlot$[esp+20], ecx
	jmp	SHORT $LN19@GetFireSup
$LN17@GetFireSup:
	mov	DWORD PTR _pPlot$[esp+20], 0
$LN19@GetFireSup:

; 3545 : 
; 3546 : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	xor	ebp, ebp
	npad	10
$LL9@GetFireSup:

; 3547 : 	{
; 3548 : 		pAdjacentPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iI));

	mov	eax, DWORD PTR _pPlot$[esp+20]
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	push	ebp
	push	ecx
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 3549 : 
; 3550 : 		if(pAdjacentPlot != NULL)

	test	edi, edi
	je	SHORT $LN8@GetFireSup

; 3551 : 		{
; 3552 : #ifdef AUI_WARNING_FIXES
; 3553 : 			for (uint iUnitLoop = 0; iUnitLoop < pAdjacentPlot->getNumUnits(); iUnitLoop++)
; 3554 : #else
; 3555 : 			for(int iUnitLoop = 0; iUnitLoop < pAdjacentPlot->getNumUnits(); iUnitLoop++)

	mov	ecx, edi
	xor	ebx, ebx
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	test	eax, eax
	jle	SHORT $LN8@GetFireSup
	npad	7
$LL5@GetFireSup:

; 3556 : #endif
; 3557 : 			{
; 3558 : 				CvUnit* pLoopUnit = pAdjacentPlot->getUnitByIndex(iUnitLoop);

	push	ebx
	mov	ecx, edi
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	esi, eax

; 3559 : 
; 3560 : 				// Unit owned by same player?
; 3561 : 				if(pLoopUnit->getOwner() == eDefender)

	mov	eax, DWORD PTR _eDefender$[esp+16]
	cmp	DWORD PTR [esi+40], eax
	jne	SHORT $LN4@GetFireSup

; 3562 : 				{
; 3563 : 					// Can this unit perform a ranged strike on the attacker's plot?
; 3564 : 					if(pLoopUnit->canRangeStrikeAt(iAttackX, iAttackY))

	mov	ecx, DWORD PTR _iAttackY$[esp+16]
	mov	edx, DWORD PTR _iAttackX$[esp+16]
	push	1
	push	1
	push	ecx
	push	edx
	mov	ecx, esi
	call	?canRangeStrikeAt@CvUnit@@QBE_NHH_N0@Z	; CvUnit::canRangeStrikeAt
	test	al, al
	jne	SHORT $LN65@GetFireSup
$LN4@GetFireSup:

; 3551 : 		{
; 3552 : #ifdef AUI_WARNING_FIXES
; 3553 : 			for (uint iUnitLoop = 0; iUnitLoop < pAdjacentPlot->getNumUnits(); iUnitLoop++)
; 3554 : #else
; 3555 : 			for(int iUnitLoop = 0; iUnitLoop < pAdjacentPlot->getNumUnits(); iUnitLoop++)

	mov	ecx, edi
	inc	ebx
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	ebx, eax
	jl	SHORT $LL5@GetFireSup
$LN8@GetFireSup:

; 3545 : 
; 3546 : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	inc	ebp
	cmp	ebp, 6
	jl	SHORT $LL9@GetFireSup
	pop	edi
	pop	esi
	pop	ebp

; 3568 : 					}
; 3569 : 				}
; 3570 : 			}
; 3571 : 		}
; 3572 : 	}
; 3573 : 
; 3574 : 	return NULL;

	xor	eax, eax
	pop	ebx

; 3575 : }

	pop	ecx
	ret	0
$LN65@GetFireSup:
	pop	edi

; 3565 : 					{
; 3566 : 						// Range strike would be calculated here, so get the estimated damage
; 3567 : 						return pLoopUnit;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 3575 : }

	pop	ecx
	ret	0
?GetFireSupportUnit@CvUnitCombat@@SAPAVCvUnit@@W4PlayerTypes@@HHHH@Z ENDP ; CvUnitCombat::GetFireSupportUnit
_TEXT	ENDS
PUBLIC	__real@3fc00000
PUBLIC	?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z ; CvUnitCombat::ApplyPostCombatTraitEffects
EXTRN	?GetNumSpecificEnemyUnitsAdjacent@CvUnit@@QBEHPBV1@0@Z:PROC ; CvUnit::GetNumSpecificEnemyUnitsAdjacent
EXTRN	?GetMaxHitPoints@CvUnit@@QBEHXZ:PROC		; CvUnit::GetMaxHitPoints
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
EXTRN	?getLeaderTypeKey@CvPlayer@@QBEPBDXZ:PROC	; CvPlayer::getLeaderTypeKey
EXTRN	?ChangeGoldenAgeProgressMeter@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::ChangeGoldenAgeProgressMeter
EXTRN	?GetCombat@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetCombat
EXTRN	?GetRangedCombat@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetRangedCombat
EXTRN	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ:PROC	; CvUnit::getUnitInfo
EXTRN	?GetGoldenAgeValueFromKills@CvUnit@@QBEHXZ:PROC	; CvUnit::GetGoldenAgeValueFromKills
EXTRN	?IsHealIfDefeatExcludeBarbarians@CvUnit@@QBE_NXZ:PROC ; CvUnit::IsHealIfDefeatExcludeBarbarians
EXTRN	?getHPHealedIfDefeatEnemy@CvUnit@@QBEHXZ:PROC	; CvUnit::getHPHealedIfDefeatEnemy
EXTRN	_memset:PROC
;	COMDAT __real@3fc00000
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
xdata$x	ENDS
;	COMDAT ?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z
_TEXT	SEGMENT
$T227995 = -368						; size = 4
_iExistingDelay$ = -368					; size = 4
_fDelay$223917 = -364					; size = 4
$T227984 = -364						; size = 4
_kPlayer$ = -360					; size = 4
$T227983 = -356						; size = 4
$T227990 = -352						; size = 28
$T227986 = -352						; size = 28
_yieldString$223913 = -352				; size = 28
_szUnitType$223924 = -324				; size = 28
_szLoserUnitType$223944 = -296				; size = 28
_text$223916 = -268					; size = 256
__$EHRec$ = -12						; size = 12
_pkWinner$ = 8						; size = 4
_pkLoser$ = 12						; size = 4
?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z PROC ; CvUnitCombat::ApplyPostCombatTraitEffects, COMDAT

; 3654 : {

	push	-1
	push	__ehhandler$?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 356				; 00000164H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3655 : 	int iExistingDelay = 0;
; 3656 : 
; 3657 : 	// "Heal if defeat enemy" promotion; doesn't apply if defeat a barbarian
; 3658 : 	if(pkWinner->getHPHealedIfDefeatEnemy() > 0 && (pkLoser->getOwner() != BARBARIAN_PLAYER || !(pkWinner->IsHealIfDefeatExcludeBarbarians())))

	mov	edi, DWORD PTR _pkWinner$[esp+380]

; 3675 : 		{
; 3676 : 			int iValue = iCombatStrength * pkWinner->GetGoldenAgeValueFromKills() / 100;

	xor	esi, esi
	mov	DWORD PTR $T227995[esp+384], esi
	mov	ecx, edi
	mov	DWORD PTR _iExistingDelay$[esp+384], esi
	call	?getHPHealedIfDefeatEnemy@CvUnit@@QBEHXZ ; CvUnit::getHPHealedIfDefeatEnemy
	mov	ebp, DWORD PTR _pkLoser$[esp+380]
	test	eax, eax
	jle	SHORT $LN132@ApplyPostC

; 3655 : 	int iExistingDelay = 0;
; 3656 : 
; 3657 : 	// "Heal if defeat enemy" promotion; doesn't apply if defeat a barbarian
; 3658 : 	if(pkWinner->getHPHealedIfDefeatEnemy() > 0 && (pkLoser->getOwner() != BARBARIAN_PLAYER || !(pkWinner->IsHealIfDefeatExcludeBarbarians())))

	cmp	DWORD PTR [ebp+40], 63			; 0000003fH
	jne	SHORT $LN17@ApplyPostC
	mov	ecx, edi
	call	?IsHealIfDefeatExcludeBarbarians@CvUnit@@QBE_NXZ ; CvUnit::IsHealIfDefeatExcludeBarbarians
	test	al, al
	jne	SHORT $LN132@ApplyPostC
$LN17@ApplyPostC:

; 3659 : 	{
; 3660 : 		if(pkWinner->getHPHealedIfDefeatEnemy() > pkWinner->getDamage())

	mov	ecx, edi
	call	?getHPHealedIfDefeatEnemy@CvUnit@@QBEHXZ ; CvUnit::getHPHealedIfDefeatEnemy
	mov	ecx, edi
	mov	ebx, eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	cmp	ebx, eax

; 3661 : 		{
; 3662 : 			pkWinner->changeDamage(-pkWinner->getDamage());

	push	esi
	push	ecx
	mov	DWORD PTR [esp], esi
	mov	ecx, edi
	push	-1
	jle	SHORT $LN16@ApplyPostC
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage

; 3663 : 		}
; 3664 : 		else

	jmp	SHORT $LN137@ApplyPostC
$LN16@ApplyPostC:

; 3665 : 		{
; 3666 : 			pkWinner->changeDamage(-pkWinner->getHPHealedIfDefeatEnemy());

	call	?getHPHealedIfDefeatEnemy@CvUnit@@QBEHXZ ; CvUnit::getHPHealedIfDefeatEnemy
$LN137@ApplyPostC:
	neg	eax
	push	eax
	mov	ecx, edi
	call	?changeDamage@CvUnit@@QAEHHW4PlayerTypes@@MPBVCvString@@@Z ; CvUnit::changeDamage
$LN132@ApplyPostC:

; 3667 : 		}
; 3668 : 	}
; 3669 : 
; 3670 : 	CvPlayer& kPlayer = GET_PLAYER(pkWinner->getOwner());

	mov	eax, DWORD PTR [edi+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 3671 : 	if (pkWinner->GetGoldenAgeValueFromKills() > 0)

	mov	ecx, edi
	mov	ebx, eax
	mov	DWORD PTR _kPlayer$[esp+384], ebx
	call	?GetGoldenAgeValueFromKills@CvUnit@@QBEHXZ ; CvUnit::GetGoldenAgeValueFromKills
	test	eax, eax
	jle	$LN134@ApplyPostC

; 3672 : 	{
; 3673 : 		int iCombatStrength = max(pkLoser->getUnitInfo().GetCombat(), pkLoser->getUnitInfo().GetRangedCombat());

	mov	ecx, ebp
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetRangedCombat@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetRangedCombat
	mov	esi, eax
	mov	ecx, ebp
	mov	DWORD PTR $T227983[esp+384], esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetCombat@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetCombat
	mov	DWORD PTR $T227984[esp+384], eax
	cmp	eax, esi
	lea	eax, DWORD PTR $T227983[esp+384]
	jl	SHORT $LN47@ApplyPostC
	lea	eax, DWORD PTR $T227984[esp+384]
$LN47@ApplyPostC:
	mov	esi, DWORD PTR [eax]

; 3674 : 		if(iCombatStrength > 0)

	test	esi, esi
	jle	$LN134@ApplyPostC

; 3675 : 		{
; 3676 : 			int iValue = iCombatStrength * pkWinner->GetGoldenAgeValueFromKills() / 100;

	mov	ecx, edi
	call	?GetGoldenAgeValueFromKills@CvUnit@@QBEHXZ ; CvUnit::GetGoldenAgeValueFromKills
	mov	ecx, eax
	imul	ecx, esi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 3677 : 			kPlayer.ChangeGoldenAgeProgressMeter(iValue);

	push	esi
	mov	ecx, ebx
	call	?ChangeGoldenAgeProgressMeter@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeGoldenAgeProgressMeter

; 3678 : 
; 3679 : 			CvString yieldString = "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GOLDEN_AGE]";

	push	OFFSET $SG223914
	lea	ecx, DWORD PTR _yieldString$223913[esp+388]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 3680 : 
; 3681 : 			if(pkWinner->getOwner() == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, DWORD PTR [edi+40]
	mov	DWORD PTR __$EHRec$[esp+392], 0
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	ebx, eax
	jne	SHORT $LN133@ApplyPostC

; 3682 : 			{
; 3683 : 				char text[256] = {0};

	push	255					; 000000ffH
	lea	eax, DWORD PTR _text$223916[esp+389]
	push	0
	push	eax
	mov	BYTE PTR _text$223916[esp+396], 0
	call	_memset

; 3684 : 				float fDelay = GC.getPOST_COMBAT_TEXT_DELAY() * 1.5f;

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8040
	fmul	DWORD PTR __real@3fc00000
	add	esp, 12					; 0000000cH

; 3685 : 				sprintf_s(text, yieldString, iValue);

	push	esi
	lea	ecx, DWORD PTR _yieldString$223913[esp+388]
	fstp	DWORD PTR _fDelay$223917[esp+388]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _text$223916[esp+392]
	push	ecx
	call	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ	; sprintf_s<256>

; 3686 : 				GC.GetEngineUserInterface()->AddPopupText(pkLoser->getX(), pkLoser->getY(), text, fDelay);

	mov	ebx, DWORD PTR _fDelay$223917[esp+396]
	mov	eax, DWORD PTR [ebp+88]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ebp+76]
	mov	esi, DWORD PTR [ecx]
	add	esp, 8
	mov	DWORD PTR [esp], ebx
	lea	ebx, DWORD PTR _text$223916[esp+388]
	push	ebx
	push	eax
	push	edx
	mov	edx, DWORD PTR [esi+184]
	call	edx

; 3687 : 
; 3688 : 				iExistingDelay++;

	mov	DWORD PTR _iExistingDelay$[esp+384], 1
$LN133@ApplyPostC:

; 3689 : 			}
; 3690 : 		}

	lea	ecx, DWORD PTR _yieldString$223913[esp+384]
	mov	DWORD PTR __$EHRec$[esp+392], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN134@ApplyPostC:

; 3691 : 	}
; 3692 : 
; 3693 : 	// Earn bonuses for kills?
; 3694 : 	kPlayer.DoYieldsFromKill(pkWinner->getUnitType(), pkLoser->getUnitType(), pkLoser->getX(), pkLoser->getY(), pkLoser->isBarbarian(), iExistingDelay);

	mov	eax, DWORD PTR _iExistingDelay$[esp+384]
	mov	esi, DWORD PTR [ebp+88]
	mov	ebx, DWORD PTR [ebp+76]
	push	eax
	mov	ecx, ebp
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	movzx	ecx, al
	push	ecx
	push	esi
	push	ebx
	mov	ecx, ebp
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, edi
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	mov	esi, DWORD PTR _kPlayer$[esp+404]
	push	eax
	mov	ecx, esi
	call	?DoYieldsFromKill@CvPlayer@@QAEXW4UnitTypes@@0HH_NH@Z ; CvPlayer::DoYieldsFromKill

; 3695 : 
; 3696 : 	//Achievements and Stats
; 3697 : 	if(pkWinner->isHuman() && !GC.getGame().isGameMultiPlayer())

	mov	ecx, edi
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	je	$LN11@ApplyPostC
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	$LN11@ApplyPostC

; 3698 : 	{
; 3699 : 		CvString szUnitType;

	lea	ecx, DWORD PTR _szUnitType$223924[esp+384]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ebx, 1

; 3700 : 		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(pkWinner->getUnitType());

	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+392], ebx
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo

; 3701 : 		if(pkUnitInfo)

	test	eax, eax
	je	SHORT $LN91@ApplyPostC

; 3702 : 			szUnitType = pkUnitInfo->GetType();

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _szUnitType$223924[esp+384]
	test	eax, eax
	je	SHORT $LN92@ApplyPostC
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN91@ApplyPostC
$LN92@ApplyPostC:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN91@ApplyPostC:

; 3703 : 
; 3704 : 		//Elizabeth Special Achievement
; 3705 : 		if((CvString)kPlayer.getLeaderTypeKey() == "LEADER_ELIZABETH" && pkLoser->getDomainType() == DOMAIN_SEA)

	mov	ecx, esi
	call	?getLeaderTypeKey@CvPlayer@@QBEPBDXZ	; CvPlayer::getLeaderTypeKey
	test	eax, eax
	jne	SHORT $LN98@ApplyPostC
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN98@ApplyPostC:
	push	eax
	lea	ecx, DWORD PTR $T227986[esp+388]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR $T227986[esp+384]
	push	OFFSET $SG223931
	push	edx
	mov	BYTE PTR __$EHRec$[esp+400], 2
	mov	DWORD PTR $T227995[esp+392], ebx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al
	je	SHORT $LN21@ApplyPostC
	mov	ecx, ebp
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN21@ApplyPostC
	mov	bl, 1
	jmp	SHORT $LN22@ApplyPostC
$LN21@ApplyPostC:
	xor	bl, bl
$LN22@ApplyPostC:
	lea	ecx, DWORD PTR $T227986[esp+384]
	mov	DWORD PTR __$EHRec$[esp+392], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	test	bl, bl
	je	SHORT $LN9@ApplyPostC

; 3706 : 		{
; 3707 : 			gDLL->IncrementSteamStatAndUnlock(ESTEAMSTAT_BRITISHNAVY, 357, ACHIEVEMENT_SPECIAL_ARMADA);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+848]
	push	115					; 00000073H
	push	357					; 00000165H
	push	129					; 00000081H
	call	edx
$LN9@ApplyPostC:

; 3708 : 		}
; 3709 : 		//Ramkang's Special Achievement
; 3710 : 		if(szUnitType == "UNIT_SIAMESE_WARELEPHANT")

	mov	ebx, DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	lea	eax, DWORD PTR _szUnitType$223924[esp+384]
	push	OFFSET $SG223933
	push	eax
	call	ebx
	add	esp, 8

; 3711 : 		{
; 3712 : 			//CvString szUnitTypeLoser = (CvString) GC.getUnitInfo(pkLoser->getUnitType())->GetType();
; 3713 : 		}
; 3714 : 
; 3715 : 		//Oda's Special Achievement
; 3716 : 		if((CvString)kPlayer.getLeaderTypeKey() == "LEADER_ODA_NOBUNAGA" && (pkWinner->GetMaxHitPoints() - pkWinner->getDamage() == 1))

	mov	ecx, esi
	call	?getLeaderTypeKey@CvPlayer@@QBEPBDXZ	; CvPlayer::getLeaderTypeKey
	test	eax, eax
	jne	SHORT $LN108@ApplyPostC
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN108@ApplyPostC:
	push	eax
	lea	ecx, DWORD PTR $T227990[esp+388]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T227990[esp+384]
	push	OFFSET $SG223938
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+400], 3
	mov	DWORD PTR $T227995[esp+392], 2
	call	ebx
	add	esp, 8
	test	al, al
	je	SHORT $LN135@ApplyPostC
	mov	ecx, edi
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	mov	ecx, edi
	mov	esi, eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	sub	esi, eax
	cmp	esi, 1
	jne	SHORT $LN135@ApplyPostC
	mov	bl, 1
	jmp	SHORT $LN24@ApplyPostC
$LN135@ApplyPostC:
	xor	bl, bl
$LN24@ApplyPostC:
	lea	ecx, DWORD PTR $T227990[esp+384]
	mov	DWORD PTR __$EHRec$[esp+392], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	test	bl, bl
	je	SHORT $LN7@ApplyPostC

; 3717 : 		{
; 3718 : 			gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_KAMIKAZE);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	105					; 00000069H
	call	eax
$LN7@ApplyPostC:

; 3719 : 		}
; 3720 : 		//Napoleon's Special Achievement
; 3721 : 		if(szUnitType == "UNIT_FRENCH_MUSKETEER")

	mov	esi, DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	lea	ecx, DWORD PTR _szUnitType$223924[esp+384]
	push	OFFSET $SG223940
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN5@ApplyPostC

; 3722 : 		{
; 3723 : 			if(pkLoser->GetNumSpecificEnemyUnitsAdjacent(pkLoser, pkWinner) >=3)

	push	edi
	push	ebp
	mov	ecx, ebp
	call	?GetNumSpecificEnemyUnitsAdjacent@CvUnit@@QBEHPBV1@0@Z ; CvUnit::GetNumSpecificEnemyUnitsAdjacent
	cmp	eax, 3
	jl	SHORT $LN5@ApplyPostC

; 3724 : 			{
; 3725 : 				gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_MUSKETEERS);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	102					; 00000066H
	call	eax
$LN5@ApplyPostC:

; 3726 : 			}
; 3727 : 		}
; 3728 : 
; 3729 : 		//DLC_05 Sejong's Turtle Boat Achievement
; 3730 : 		if(szUnitType == "UNIT_KOREAN_TURTLE_SHIP")

	lea	ecx, DWORD PTR _szUnitType$223924[esp+384]
	push	OFFSET $SG223943
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN4@ApplyPostC

; 3731 : 		{
; 3732 : 			CvString szLoserUnitType;

	lea	ecx, DWORD PTR _szLoserUnitType$223944[esp+384]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3733 : 			CvUnitEntry* pkLoserUnitInfo = GC.getUnitInfo(pkLoser->getUnitType());

	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+392], 4
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo

; 3734 : 			if(pkLoserUnitInfo)

	test	eax, eax
	je	SHORT $LN3@ApplyPostC

; 3735 : 			{
; 3736 : 				szLoserUnitType = pkLoserUnitInfo->GetType();

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _szLoserUnitType$223944[esp+388]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
$LN3@ApplyPostC:

; 3737 : 			}
; 3738 : 			if(szLoserUnitType == "UNIT_IRONCLAD")

	lea	edx, DWORD PTR _szLoserUnitType$223944[esp+384]
	push	OFFSET $SG223948
	push	edx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN2@ApplyPostC

; 3739 : 			{
; 3740 : 				gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_IRONCLAD_TURTLE);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+828]
	push	162					; 000000a2H
	call	edx
$LN2@ApplyPostC:

; 3741 : 			}
; 3742 : 		}

	lea	ecx, DWORD PTR _szLoserUnitType$223944[esp+384]
	mov	BYTE PTR __$EHRec$[esp+392], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@ApplyPostC:

; 3743 : 
; 3744 : 		//DLC_05 Sejong's Hwacha Achievement
; 3745 : 		if(szUnitType == "UNIT_KOREAN_HWACHA")

	lea	eax, DWORD PTR _szUnitType$223924[esp+384]
	push	OFFSET $SG223950
	push	eax
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN1@ApplyPostC

; 3746 : 		{
; 3747 : 			gDLL->IncrementSteamStatAndUnlock(ESTEAMSTAT_HWACHAKILLS, 99, ACHIEVEMENT_SPECIAL_HWATCH_OUT);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+848]
	push	163					; 000000a3H
	push	99					; 00000063H
	push	131					; 00000083H
	call	eax
$LN1@ApplyPostC:

; 3748 : 		}
; 3749 : 
; 3750 : 	}

	lea	ecx, DWORD PTR _szUnitType$223924[esp+384]
	mov	DWORD PTR __$EHRec$[esp+392], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN11@ApplyPostC:

; 3751 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+384]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 368				; 00000170H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z$0:
	lea	ecx, DWORD PTR _yieldString$223913[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z$1:
	lea	ecx, DWORD PTR _szUnitType$223924[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z$2:
	mov	eax, DWORD PTR $T227995[ebp]
	and	eax, 1
	je	$LN28@ApplyPostC
	and	DWORD PTR $T227995[ebp], -2		; fffffffeH
	lea	ecx, DWORD PTR $T227986[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN28@ApplyPostC:
	ret	0
__unwindfunclet$?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z$3:
	mov	eax, DWORD PTR $T227995[ebp]
	and	eax, 2
	je	$LN31@ApplyPostC
	and	DWORD PTR $T227995[ebp], -3		; fffffffdH
	lea	ecx, DWORD PTR $T227990[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN31@ApplyPostC:
	ret	0
__unwindfunclet$?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z$4:
	lea	ecx, DWORD PTR _szLoserUnitType$223944[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z:
	mov	eax, OFFSET __ehfuncinfo$?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z ENDP ; CvUnitCombat::ApplyPostCombatTraitEffects
PUBLIC	__real@40400000
PUBLIC	?ApplyPostCityCombatEffects@CvUnitCombat@@KAXPAVCvUnit@@PAVCvCity@@H@Z ; CvUnitCombat::ApplyPostCityCombatEffects
EXTRN	?GetGold@CvTreasury@@QBEHXZ:PROC		; CvTreasury::GetGold
EXTRN	?ChangeGold@CvTreasury@@QAEXH@Z:PROC		; CvTreasury::ChangeGold
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?GetCityAttackPlunderModifier@CvUnit@@QBEHXZ:PROC ; CvUnit::GetCityAttackPlunderModifier
;	COMDAT __real@40400000
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ApplyPostCityCombatEffects@CvUnitCombat@@KAXPAVCvUnit@@PAVCvCity@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyPostCityCombatEffects@CvUnitCombat@@KAXPAVCvUnit@@PAVCvCity@@H@Z$0
__ehfuncinfo$?ApplyPostCityCombatEffects@CvUnitCombat@@KAXPAVCvUnit@@PAVCvCity@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ApplyPostCityCombatEffects@CvUnitCombat@@KAXPAVCvUnit@@PAVCvCity@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
xdata$x	ENDS
;	COMDAT ?ApplyPostCityCombatEffects@CvUnitCombat@@KAXPAVCvUnit@@PAVCvCity@@H@Z
_TEXT	SEGMENT
_fDelay$ = -308						; size = 4
$T228200 = -304						; size = 4
_iGoldPlundered$223960 = -300				; size = 4
_colorString$ = -296					; size = 28
_text$223966 = -268					; size = 256
__$EHRec$ = -12						; size = 12
_pkAttacker$ = 8					; size = 4
_pkDefender$ = 12					; size = 4
_iAttackerDamageInflicted$ = 16				; size = 4
?ApplyPostCityCombatEffects@CvUnitCombat@@KAXPAVCvUnit@@PAVCvCity@@H@Z PROC ; CvUnitCombat::ApplyPostCityCombatEffects, COMDAT

; 3754 : {

	push	-1
	push	__ehhandler$?ApplyPostCityCombatEffects@CvUnitCombat@@KAXPAVCvUnit@@PAVCvCity@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 296				; 00000128H
	push	edi

; 3755 : 	CvString colorString;

	lea	ecx, DWORD PTR _colorString$[esp+312]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3756 : 	int iPlunderModifier;
; 3757 : 	float fDelay = GC.getPOST_COMBAT_TEXT_DELAY() * 3;

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8040
	fmul	DWORD PTR __real@40400000

; 3758 : 	iPlunderModifier = pkAttacker->GetCityAttackPlunderModifier();

	mov	edi, DWORD PTR _pkAttacker$[esp+308]
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+320], 0
	fstp	DWORD PTR _fDelay$[esp+312]
	call	?GetCityAttackPlunderModifier@CvUnit@@QBEHXZ ; CvUnit::GetCityAttackPlunderModifier

; 3759 : 	if(iPlunderModifier > 0)

	test	eax, eax
	jle	$LN1@ApplyPostC@2

; 3760 : 	{
; 3761 : 		int iGoldPlundered = iAttackerDamageInflicted * iPlunderModifier;

	imul	eax, DWORD PTR _iAttackerDamageInflicted$[esp+308]

; 3762 : 		iGoldPlundered /= 100;

	mov	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	push	esi
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	mov	DWORD PTR _iGoldPlundered$223960[esp+316], esi

; 3763 : 
; 3764 : 		if(iGoldPlundered > 0)

	test	esi, esi
	jle	$LN54@ApplyPostC@2

; 3765 : 		{
; 3766 : 			GET_PLAYER(pkAttacker->getOwner()).GetTreasury()->ChangeGold(iGoldPlundered);

	mov	eax, DWORD PTR [edi+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	push	esi
	mov	ecx, eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 3767 : 
; 3768 : 			CvPlayer& kCityPlayer = GET_PLAYER(pkDefender->getOwner());

	mov	eax, DWORD PTR _pkDefender$[esp+316]
	mov	eax, DWORD PTR [eax+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ebp, eax

; 3769 : 			int iDeduction = min(iGoldPlundered, kCityPlayer.GetTreasury()->GetGold());

	mov	ecx, ebp
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	mov	DWORD PTR $T228200[esp+320], eax
	cmp	eax, esi
	lea	eax, DWORD PTR $T228200[esp+320]
	jl	SHORT $LN27@ApplyPostC@2
	lea	eax, DWORD PTR _iGoldPlundered$223960[esp+320]
$LN27@ApplyPostC@2:
	mov	eax, DWORD PTR [eax]

; 3770 : 			kCityPlayer.GetTreasury()->ChangeGold(-iDeduction);

	neg	eax
	push	eax
	mov	ecx, ebp
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 3771 : 
; 3772 : 			if(pkAttacker->getOwner() == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebp, DWORD PTR [edi+40]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	ebp, eax
	pop	ebp
	jne	SHORT $LN54@ApplyPostC@2

; 3773 : 			{
; 3774 : 				char text[256] = {0};

	push	255					; 000000ffH
	lea	ecx, DWORD PTR _text$223966[esp+321]
	push	0
	push	ecx
	mov	BYTE PTR _text$223966[esp+328], 0
	call	_memset
	add	esp, 12					; 0000000cH

; 3775 : 				colorString = "[COLOR_YELLOW]+%d[ENDCOLOR][ICON_GOLD]";

	push	OFFSET $SG223967
	lea	ecx, DWORD PTR _colorString$[esp+320]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 3776 : 				sprintf_s(text, colorString, iGoldPlundered);

	lea	ecx, DWORD PTR _colorString$[esp+316]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	esi
	push	eax
	lea	edx, DWORD PTR _text$223966[esp+324]
	push	edx
	call	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ	; sprintf_s<256>

; 3777 : 				GC.GetEngineUserInterface()->AddPopupText(pkAttacker->getX(), pkAttacker->getY(), text, fDelay);

	mov	esi, DWORD PTR _fDelay$[esp+328]
	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edi, DWORD PTR [edi+76]
	mov	edx, DWORD PTR [ecx]
	add	esp, 8
	mov	DWORD PTR [esp], esi
	lea	esi, DWORD PTR _text$223966[esp+320]
	push	esi
	push	eax
	mov	eax, DWORD PTR [edx+184]
	push	edi
	call	eax
$LN54@ApplyPostC@2:
	pop	esi
$LN1@ApplyPostC@2:

; 3778 : 			}
; 3779 : 		}
; 3780 : 	}
; 3781 : }

	lea	ecx, DWORD PTR _colorString$[esp+312]
	mov	DWORD PTR __$EHRec$[esp+320], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+312]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 308				; 00000134H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ApplyPostCityCombatEffects@CvUnitCombat@@KAXPAVCvUnit@@PAVCvCity@@H@Z$0:
	lea	ecx, DWORD PTR _colorString$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ApplyPostCityCombatEffects@CvUnitCombat@@KAXPAVCvUnit@@PAVCvCity@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?ApplyPostCityCombatEffects@CvUnitCombat@@KAXPAVCvUnit@@PAVCvCity@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ApplyPostCityCombatEffects@CvUnitCombat@@KAXPAVCvUnit@@PAVCvCity@@H@Z ENDP ; CvUnitCombat::ApplyPostCityCombatEffects
PUBLIC	??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,25,1,297,0>::~FStaticVector<IDInfo,25,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<IDInfo,25,1,297,0>::~FStaticVector<IDInfo,25,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<IDInfo,25,1,297,0>::~FStaticVector<IDInfo,25,1,297,0>
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ; FStaticVector<IDInfo,25,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z PROC ; FStaticVector<IDInfo,25,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+212], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,25,1,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ENDP ; FStaticVector<IDInfo,25,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?resize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXI@Z ; FStaticVector<IDInfo,25,1,297,0>::resize
; Function compile flags: /Ogtpy
;	COMDAT ?resize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXI@Z
_TEXT	SEGMENT
_uiNewSize$ = 8						; size = 4
?resize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXI@Z PROC ; FStaticVector<IDInfo,25,1,297,0>::resize, COMDAT
; _this$ = ecx

; 666  : 	{

	push	esi
	push	edi

; 667  : 		if( m_uiCurrMaxSize < uiNewSize ){

	mov	edi, DWORD PTR _uiNewSize$[esp+4]
	mov	esi, ecx
	cmp	DWORD PTR [esi+8], edi
	jae	SHORT $LN4@resize

; 668  : 			GrowSize(uiNewSize);

	push	edi
	call	?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,25,1,297,0>::GrowSize
$LN4@resize:

; 669  : 		}
; 670  : 		m_uiCurrSize = uiNewSize;

	mov	DWORD PTR [esi+4], edi
	pop	edi
	pop	esi

; 671  : 	};

	ret	4
?resize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXI@Z ENDP ; FStaticVector<IDInfo,25,1,297,0>::resize
_TEXT	ENDS
PUBLIC	?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveMeleeCombat
EXTRN	?ShowDamageDeltaText@CvUnit@@SAXHPAVCvPlot@@MPBVCvString@@@Z:PROC ; CvUnit::ShowDamageDeltaText
EXTRN	?IsDead@CvUnit@@QBE_NXZ:PROC			; CvUnit::IsDead
EXTRN	?IsSelected@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsSelected
EXTRN	?isBlitz@CvUnit@@QBE_NXZ:PROC			; CvUnit::isBlitz
EXTRN	?canMove@CvUnit@@QBE_NXZ:PROC			; CvUnit::canMove
EXTRN	?movementCost@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z:PROC ; CvPlot::movementCost
EXTRN	?getMoves@CvUnit@@QBEHXZ:PROC			; CvUnit::getMoves
EXTRN	?UnitMove@CvUnit@@QAE_NPAVCvPlot@@_NPAV1@1@Z:PROC ; CvUnit::UnitMove
EXTRN	?PublishQueuedVisualizationMoves@CvUnit@@IAEXXZ:PROC ; CvUnit::PublishQueuedVisualizationMoves
EXTRN	?move@CvUnit@@QAEXAAVCvPlot@@_N@Z:PROC		; CvUnit::move
EXTRN	?getAttackerAdvancedVisualization@CvCombatInfo@@QBE_NXZ:PROC ; CvCombatInfo::getAttackerAdvancedVisualization
EXTRN	?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z:PROC ; CvPlot::getNumVisibleEnemyDefenders
EXTRN	?getAttackerAdvances@CvCombatInfo@@QBE_NXZ:PROC	; CvCombatInfo::getAttackerAdvances
EXTRN	?DoFallBackFromMelee@CvUnit@@IAE_NAAV1@@Z:PROC	; CvUnit::DoFallBackFromMelee
EXTRN	?DoTestBarbarianThreatToMinorsWithThisUnitsDeath@CvUnit@@QAEXW4PlayerTypes@@@Z:PROC ; CvUnit::DoTestBarbarianThreatToMinorsWithThisUnitsDeath
EXTRN	?SetCapturedAsIs@CvUnit@@QAEX_N@Z:PROC		; CvUnit::SetCapturedAsIs
EXTRN	?setCapturingPlayer@CvUnit@@QAEXW4PlayerTypes@@@Z:PROC ; CvUnit::setCapturingPlayer
EXTRN	?getDefenderCaptured@CvCombatInfo@@QBE_NXZ:PROC	; CvCombatInfo::getDefenderCaptured
EXTRN	?getVisualOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@@Z:PROC ; CvUnit::getVisualOwner
EXTRN	?testPromotionReady@CvUnit@@QAEXXZ:PROC		; CvUnit::testPromotionReady
EXTRN	?getVisualCivAdjective@CvUnit@@QBEPBDW4TeamTypes@@@Z:PROC ; CvUnit::getVisualCivAdjective
EXTRN	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ:PROC	; CvUnit::getTeam
EXTRN	?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z:PROC ; CvGlobals::WrapUnitPointer
EXTRN	?KilledUnitWithUnit@CvPlayerAchievements@@QAEXPAVCvUnit@@0@Z:PROC ; CvPlayerAchievements::KilledUnitWithUnit
EXTRN	?AttackedUnitWithUnit@CvPlayerAchievements@@QAEXPAVCvUnit@@0@Z:PROC ; CvPlayerAchievements::AttackedUnitWithUnit
EXTRN	?GetCurrHitPoints@CvUnit@@QBEHXZ:PROC		; CvUnit::GetCurrHitPoints
EXTRN	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::IsCanDefend
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$7
	DD	04H
	DD	FLAT:__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$8
	DD	04H
	DD	FLAT:__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$9
	DD	04H
	DD	FLAT:__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$11
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$12
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$14
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
xdata$x	ENDS
;	COMDAT ?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
_TEXT	SEGMENT
_isAttackingFromHigherElevation$222415 = -198		; size = 1
_bAttackerDead$ = -198					; size = 1
_bAttackerDidMoreDamage$ = -197				; size = 1
$T228379 = -196						; size = 4
$T228370 = -196						; size = 4
$T228367 = -196						; size = 4
$T228354 = -196						; size = 4
$T228350 = -196						; size = 4
$T228348 = -196						; size = 4
$T228754 = -192						; size = 4
$T228362 = -192						; size = 4
$T228359 = -192						; size = 4
$T228356 = -192						; size = 4
$T228351 = -192						; size = 4
$T228347 = -192						; size = 4
$T228380 = -188						; size = 4
$T228378 = -188						; size = 4
$T228369 = -188						; size = 4
$T228366 = -188						; size = 4
$T228355 = -188						; size = 4
_pAttacker$222267 = -188				; size = 4
$T228346 = -184						; size = 4
_iDefenderDamageInflicted$222214 = -184			; size = 4
$T228763 = -180						; size = 4
$T228363 = -180						; size = 4
$T228360 = -180						; size = 4
$T228357 = -180						; size = 4
$T228345 = -180						; size = 4
$T228352 = -176						; size = 4
_iActivePlayerID$ = -176				; size = 4
$T228772 = -172						; size = 4
$T228364 = -172						; size = 4
_iAttackerFearDamageInflicted$222215 = -172		; size = 4
$T228776 = -168						; size = 4
_iAttackerDamageInflicted$222213 = -168			; size = 4
_pkTargetPlot$ = -164					; size = 4
_bDefenderDead$ = -160					; size = 1
$T228408 = -156						; size = 4
_iAttackerDamageDelta$ = -156				; size = 4
_strBuffer$ = -152					; size = 28
$T228371 = -124						; size = 28
$T228368 = -124						; size = 28
$T228365 = -124						; size = 28
$T228361 = -124						; size = 28
$T228358 = -124						; size = 28
$T228353 = -124						; size = 28
$T228349 = -124						; size = 28
_pDllAttacker$222431 = -96				; size = 4
_pDefender$222325 = -96					; size = 4
_strSummary$222376 = -92				; size = 80
__$EHRec$ = -12						; size = 12
_kCombatInfo$ = 8					; size = 4
_uiParentEventID$ = 12					; size = 4
?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z PROC ; CvUnitCombat::ResolveMeleeCombat, COMDAT

; 322  : {

	push	-1
	push	__ehhandler$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 188				; 000000bcH
	push	ebx
	push	ebp
	push	esi
	push	edi

; 323  : 	// After combat stuff
; 324  : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[esp+216]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 325  : 	bool bAttackerDead = false;
; 326  : 	bool bDefenderDead = false;
; 327  : 	int iAttackerDamageDelta = 0;
; 328  : 
; 329  : 	CvUnit* pkAttacker = kCombatInfo.getUnit(BATTLE_UNIT_ATTACKER);

	mov	ebp, DWORD PTR _kCombatInfo$[esp+212]
	xor	eax, eax
	push	eax
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+228], eax
	mov	BYTE PTR _bDefenderDead$[esp+220], al
	mov	DWORD PTR _iAttackerDamageDelta$[esp+220], eax
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit

; 330  : 	CvUnit* pkDefender = kCombatInfo.getUnit(BATTLE_UNIT_DEFENDER);

	push	1
	mov	ecx, ebp
	mov	esi, eax
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit

; 331  : 	CvPlot* pkTargetPlot = kCombatInfo.getPlot();

	mov	ecx, ebp
	mov	edi, eax
	call	?getPlot@CvCombatInfo@@QBEPAVCvPlot@@XZ	; CvCombatInfo::getPlot
	mov	ebx, eax
	mov	DWORD PTR _pkTargetPlot$[esp+216], ebx

; 332  : 	if(!pkTargetPlot && pkDefender)

	test	ebx, ebx
	jne	SHORT $LN42@ResolveMel
	test	edi, edi
	je	SHORT $LN42@ResolveMel

; 333  : 		pkTargetPlot = pkDefender->plot();

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pkTargetPlot$[esp+216], eax
	mov	ebx, eax
$LN42@ResolveMel:

; 334  : 
; 335  : 	CvAssert_Debug(pkAttacker && pkDefender && pkTargetPlot);
; 336  : 
; 337  : 	int iActivePlayerID = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR _iActivePlayerID$[esp+216], eax

; 338  : 
; 339  : 	bool bAttackerDidMoreDamage = false;

	mov	BYTE PTR _bAttackerDidMoreDamage$[esp+216], 0

; 340  : 
; 341  : 	if(pkAttacker != NULL && pkDefender != NULL && pkTargetPlot != NULL &&
; 342  : 	        pkDefender->IsCanDefend()) 		// Did the defender actually defend?

	test	esi, esi
	je	$LN356@ResolveMel
	test	edi, edi
	je	$LN21@ResolveMel
	test	ebx, ebx
	je	$LN21@ResolveMel
	push	0
	mov	ecx, edi
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	test	al, al
	je	$LN21@ResolveMel

; 343  : 	{
; 344  : 		// Internal variables
; 345  : 		int iAttackerDamageInflicted = kCombatInfo.getDamageInflicted(BATTLE_UNIT_ATTACKER);

	push	0
	mov	ecx, ebp
	call	?getDamageInflicted@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getDamageInflicted
	mov	ebx, eax

; 346  : 		int iDefenderDamageInflicted = kCombatInfo.getDamageInflicted(BATTLE_UNIT_DEFENDER);

	push	1
	mov	ecx, ebp
	mov	DWORD PTR _iAttackerDamageInflicted$222213[esp+220], ebx
	call	?getDamageInflicted@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getDamageInflicted

; 347  : 		int iAttackerFearDamageInflicted = 0;//pInfo->getFearDamageInflicted( BATTLE_UNIT_ATTACKER );
; 348  : 
; 349  : 		bAttackerDidMoreDamage = iAttackerDamageInflicted > iDefenderDamageInflicted;

	cmp	ebx, eax
	mov	DWORD PTR _iDefenderDamageInflicted$222214[esp+216], eax

; 350  : 
; 351  : 		//One Hit
; 352  : 		if(pkDefender->GetCurrHitPoints() == GC.getMAX_HIT_POINTS() && iAttackerDamageInflicted >= pkDefender->GetCurrHitPoints()  // Defender at full hit points and will the damage be more than the full hit points?
; 353  : 		        && pkAttacker->isHuman() && !GC.getGame().isGameMultiPlayer())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, edi
	mov	DWORD PTR _iAttackerFearDamageInflicted$222215[esp+216], 0
	setg	BYTE PTR _bAttackerDidMoreDamage$[esp+216]
	mov	DWORD PTR $T228408[esp+216], eax
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	cmp	eax, DWORD PTR $T228408[esp+216]
	jne	SHORT $LN40@ResolveMel
	mov	ecx, edi
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	cmp	ebx, eax
	jl	SHORT $LN40@ResolveMel
	mov	ecx, esi
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	je	SHORT $LN40@ResolveMel
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	SHORT $LN40@ResolveMel

; 354  : 		{
; 355  : 			gDLL->UnlockAchievement(ACHIEVEMENT_ONEHITKILL);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	60					; 0000003cH
	call	eax
$LN40@ResolveMel:

; 356  : 		}
; 357  : 
; 358  : 		pkDefender->changeDamage(iAttackerDamageInflicted, pkAttacker->getOwner());

	mov	eax, DWORD PTR [esi+40]
	push	0
	push	ecx
	mov	DWORD PTR [esp], 0
	push	eax
	push	ebx
	mov	ecx, edi
	call	?changeDamage@CvUnit@@QAEHHW4PlayerTypes@@MPBVCvString@@@Z ; CvUnit::changeDamage

; 359  : 		iAttackerDamageDelta = pkAttacker->changeDamage(iDefenderDamageInflicted, pkDefender->getOwner(), -1.f);		// Signal that we don't want the popup text.  It will be added later when the unit is at its final location

	mov	eax, DWORD PTR [edi+40]
	push	0
	push	ecx
	mov	ecx, DWORD PTR _iDefenderDamageInflicted$222214[esp+224]
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	eax
	push	ecx
	mov	ecx, esi
	call	?changeDamage@CvUnit@@QAEHHW4PlayerTypes@@MPBVCvString@@@Z ; CvUnit::changeDamage

; 360  : 
; 361  : 		// Update experience for both sides.
; 362  : 		pkDefender->changeExperience(
; 363  : 		    kCombatInfo.getExperience(BATTLE_UNIT_DEFENDER),
; 364  : 		    kCombatInfo.getMaxExperienceAllowed(BATTLE_UNIT_DEFENDER),
; 365  : 		    true,
; 366  : 		    kCombatInfo.getInBorders(BATTLE_UNIT_DEFENDER),
; 367  : 		    kCombatInfo.getUpdateGlobal(BATTLE_UNIT_DEFENDER));

	push	1
	mov	ecx, ebp
	mov	DWORD PTR _iAttackerDamageDelta$[esp+220], eax
	call	?getUpdateGlobal@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getUpdateGlobal
	movzx	edx, al
	push	edx
	push	1
	mov	ecx, ebp
	call	?getInBorders@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getInBorders
	movzx	eax, al
	push	eax
	push	1
	push	1
	mov	ecx, ebp
	call	?getMaxExperienceAllowed@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getMaxExperienceAllowed
	push	eax
	push	1
	mov	ecx, ebp
	call	?getExperience@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getExperience
	push	eax
	mov	ecx, edi
	call	?changeExperience@CvUnit@@QAEXHH_N00@Z	; CvUnit::changeExperience

; 368  : 
; 369  : 		pkAttacker->changeExperience(
; 370  : 		    kCombatInfo.getExperience(BATTLE_UNIT_ATTACKER),
; 371  : 		    kCombatInfo.getMaxExperienceAllowed(BATTLE_UNIT_ATTACKER),
; 372  : 		    true,
; 373  : 		    kCombatInfo.getInBorders(BATTLE_UNIT_ATTACKER),
; 374  : 		    kCombatInfo.getUpdateGlobal(BATTLE_UNIT_ATTACKER));

	push	0
	mov	ecx, ebp
	call	?getUpdateGlobal@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getUpdateGlobal
	movzx	ecx, al
	push	ecx
	push	0
	mov	ecx, ebp
	call	?getInBorders@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getInBorders
	movzx	edx, al
	push	edx
	push	1
	push	0
	mov	ecx, ebp
	call	?getMaxExperienceAllowed@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getMaxExperienceAllowed
	push	eax
	push	0
	mov	ecx, ebp
	call	?getExperience@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getExperience
	push	eax
	mov	ecx, esi
	call	?changeExperience@CvUnit@@QAEXHH_N00@Z	; CvUnit::changeExperience

; 375  : 
; 376  : 		// Anyone eat it?
; 377  : 		bAttackerDead = (pkAttacker->getDamage() >= GC.getMAX_HIT_POINTS());

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, esi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	cmp	eax, ebx

; 378  : 		bDefenderDead = (pkDefender->getDamage() >= GC.getMAX_HIT_POINTS());

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, edi
	setge	BYTE PTR _bAttackerDead$[esp+216]
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	cmp	eax, ebx

; 379  : 
; 380  : 		CvPlayerAI& kAttackerOwner = GET_PLAYER(pkAttacker->getOwner());

	mov	eax, DWORD PTR [esi+40]
	setge	BYTE PTR _bDefenderDead$[esp+216]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 381  : 		kAttackerOwner.GetPlayerAchievements().AttackedUnitWithUnit(pkAttacker, pkDefender);

	push	edi
	lea	ebx, DWORD PTR [eax+63156]
	push	esi
	mov	ecx, ebx
	call	?AttackedUnitWithUnit@CvPlayerAchievements@@QAEXPAVCvUnit@@0@Z ; CvPlayerAchievements::AttackedUnitWithUnit

; 382  : 
; 383  : 		// Attacker died
; 384  : 		if(bAttackerDead)

	cmp	BYTE PTR _bAttackerDead$[esp+216], 0
	je	$LN39@ResolveMel

; 385  : 		{
; 386  : 			CvPlayerAI& kDefenderOwner = GET_PLAYER(pkDefender->getOwner());

	mov	eax, DWORD PTR [edi+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 387  : 			kDefenderOwner.GetPlayerAchievements().KilledUnitWithUnit(pkDefender, pkAttacker);

	push	esi
	push	edi
	lea	ecx, DWORD PTR [eax+63156]
	call	?KilledUnitWithUnit@CvPlayerAchievements@@QAEXPAVCvUnit@@0@Z ; CvPlayerAchievements::KilledUnitWithUnit

; 388  : 
; 389  : 			auto_ptr<ICvUnit1> pAttacker = GC.WrapUnitPointer(pkAttacker);

	push	esi
	lea	eax, DWORD PTR $T228345[esp+220]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z ; CvGlobals::WrapUnitPointer
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR $T228346[esp+216], ebx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pAttacker$222267[esp+216], ebx
	mov	eax, DWORD PTR $T228345[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 1
	test	eax, eax
	je	SHORT $LN113@ResolveMel
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN113@ResolveMel:

; 390  : 			gDLL->GameplayUnitDestroyedInCombat(pAttacker.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+600]
	push	ebx
	call	edx

; 391  : 
; 392  : 			if(iActivePlayerID == pkAttacker->getOwner())

	mov	eax, DWORD PTR _iActivePlayerID$[esp+216]
	cmp	eax, DWORD PTR [esi+40]
	jne	$LN350@ResolveMel

; 393  : 			{
; 394  : 				strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_DIED_ATTACKING", pkAttacker->getNameKey(), pkDefender->getNameKey(), iAttackerDamageInflicted, iAttackerFearDamageInflicted);

	mov	ecx, edi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T228347[esp+216], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	lea	ecx, DWORD PTR _iAttackerFearDamageInflicted$222215[esp+216]
	push	ecx
	lea	edx, DWORD PTR _iAttackerDamageInflicted$222213[esp+220]
	push	edx
	mov	DWORD PTR $T228348[esp+224], eax
	lea	eax, DWORD PTR $T228347[esp+224]
	push	eax
	lea	ecx, DWORD PTR $T228348[esp+228]
	push	ecx
	lea	edx, DWORD PTR $T228349[esp+232]
	push	OFFSET $SG222302
	push	edx
	call	??$GetLocalizedText@PBDPBDHH@@YA?AVCvString@@PBDABQBD1ABH2@Z ; GetLocalizedText<char const *,char const *,int,int>
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 2
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T228349[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 395  : 				GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+216]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi+40]
	push	0
	push	0
	mov	edx, DWORD PTR [ebx]
	push	-1
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	mov	ecx, DWORD PTR _uiParentEventID$[esp+260]
	push	ecx
	mov	ecx, ebx
	call	edx
	mov	ebx, DWORD PTR $T228346[esp+216]
$LN350@ResolveMel:

; 396  : 			}
; 397  : 			if(iActivePlayerID == pkDefender->getOwner())

	mov	eax, DWORD PTR _iActivePlayerID$[esp+216]
	cmp	eax, DWORD PTR [edi+40]
	jne	$LN37@ResolveMel

; 398  : 			{
; 399  : 				strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_KILLED_ENEMY_UNIT", pkDefender->getNameKey(), iAttackerDamageInflicted, iAttackerFearDamageInflicted, pkAttacker->getNameKey(), pkAttacker->getVisualCivAdjective(pkDefender->getTeam()));

	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, esi
	call	?getVisualCivAdjective@CvUnit@@QBEPBDW4TeamTypes@@@Z ; CvUnit::getVisualCivAdjective
	mov	ecx, esi
	mov	DWORD PTR $T228350[esp+216], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, edi
	mov	DWORD PTR $T228351[esp+216], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	lea	ecx, DWORD PTR $T228350[esp+216]
	push	ecx
	mov	DWORD PTR $T228352[esp+220], eax
	lea	edx, DWORD PTR $T228351[esp+220]
	push	edx
	lea	eax, DWORD PTR _iAttackerFearDamageInflicted$222215[esp+224]
	push	eax
	lea	ecx, DWORD PTR _iAttackerDamageInflicted$222213[esp+228]
	push	ecx
	lea	edx, DWORD PTR $T228352[esp+232]
	push	edx
	lea	eax, DWORD PTR $T228353[esp+236]
	push	OFFSET $SG222321
	push	eax
	call	??$GetLocalizedText@PBDHHPBDPBD@@YA?AVCvString@@PBDABQBDABH211@Z ; GetLocalizedText<char const *,int,int,char const *,char const *>
	add	esp, 28					; 0000001cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T228353[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 400  : 				GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+216]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi+40]
	push	0
	push	0
	mov	edx, DWORD PTR [ebx]
	push	-1
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	mov	ecx, DWORD PTR _uiParentEventID$[esp+260]
	push	ecx
	mov	ecx, ebx
	call	edx
	mov	ebx, DWORD PTR $T228346[esp+216]
$LN37@ResolveMel:

; 401  : 			}
; 402  : #ifndef AUI_UNIT_TEST_PROMOTION_READY_MOVED
; 403  : 			pkDefender->testPromotionReady();

	mov	ecx, edi
	call	?testPromotionReady@CvUnit@@QAEXXZ	; CvUnit::testPromotionReady

; 404  : #endif
; 405  : 
; 406  : 			ApplyPostCombatTraitEffects(pkDefender, pkAttacker);

	push	esi
	push	edi
	call	?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z ; CvUnitCombat::ApplyPostCombatTraitEffects
	add	esp, 8

; 407  : 
; 408  : 		}

	mov	BYTE PTR __$EHRec$[esp+224], 0
	test	ebx, ebx
	je	SHORT $LN28@ResolveMel
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	push	ebx
	call	ecx
$LN28@ResolveMel:

; 478  : 		{
; 479  : 			if(pkAttacker->isBarbarian())

	mov	ecx, esi
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	test	al, al
	je	$LN355@ResolveMel

; 480  : 				pkAttacker->DoTestBarbarianThreatToMinorsWithThisUnitsDeath(pkDefender->getOwner());

	mov	eax, DWORD PTR [edi+40]
	mov	ecx, esi

; 481  : 		}

	jmp	$LN364@ResolveMel
$LN39@ResolveMel:

; 409  : 		// Defender died
; 410  : 		else if(bDefenderDead)

	cmp	BYTE PTR _bDefenderDead$[esp+216], 0
	je	$LN35@ResolveMel

; 411  : 		{
; 412  : 			kAttackerOwner.GetPlayerAchievements().KilledUnitWithUnit(pkAttacker, pkDefender);

	push	edi
	push	esi
	mov	ecx, ebx
	call	?KilledUnitWithUnit@CvPlayerAchievements@@QAEXPAVCvUnit@@0@Z ; CvPlayerAchievements::KilledUnitWithUnit

; 413  : 
; 414  : 			auto_ptr<ICvUnit1> pDefender = GC.WrapUnitPointer(pkDefender);

	push	edi
	lea	edx, DWORD PTR $T228354[esp+220]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z ; CvGlobals::WrapUnitPointer
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR $T228355[esp+216], ebx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pDefender$222325[esp+216], ebx
	mov	eax, DWORD PTR $T228354[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 4
	test	eax, eax
	je	SHORT $LN173@ResolveMel
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN173@ResolveMel:

; 415  : 			gDLL->GameplayUnitDestroyedInCombat(pDefender.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+600]
	push	ebx
	call	edx

; 416  : 
; 417  : 			if(iActivePlayerID == pkAttacker->getOwner())

	mov	eax, DWORD PTR _iActivePlayerID$[esp+216]
	cmp	eax, DWORD PTR [esi+40]
	jne	$LN351@ResolveMel

; 418  : 			{
; 419  : 				strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_DESTROYED_ENEMY", pkAttacker->getNameKey(), iDefenderDamageInflicted, pkDefender->getNameKey());

	mov	ecx, edi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T228356[esp+216], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	lea	ecx, DWORD PTR $T228356[esp+216]
	push	ecx
	lea	edx, DWORD PTR _iDefenderDamageInflicted$222214[esp+220]
	push	edx
	mov	DWORD PTR $T228357[esp+224], eax
	lea	eax, DWORD PTR $T228357[esp+224]
	push	eax
	lea	ecx, DWORD PTR $T228358[esp+228]
	push	OFFSET $SG222341
	push	ecx
	call	??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z ; GetLocalizedText<char const *,int,char const *>
	add	esp, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 5
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T228358[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 420  : 				GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+216]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi+40]
	push	0
	push	0
	mov	edx, DWORD PTR [ebx]
	push	-1
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	mov	ecx, DWORD PTR _uiParentEventID$[esp+260]
	push	ecx
	mov	ecx, ebx
	call	edx
$LN351@ResolveMel:

; 421  : 			}
; 422  : 
; 423  : 			if(pkAttacker->getVisualOwner(pkDefender->getTeam()) != pkAttacker->getOwner())

	mov	ebx, DWORD PTR [esi+40]
	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, esi
	call	?getVisualOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@@Z ; CvUnit::getVisualOwner
	cmp	eax, ebx
	je	SHORT $LN33@ResolveMel

; 424  : 			{
; 425  : 				strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED_UNKNOWN", pkDefender->getNameKey(), pkAttacker->getNameKey(), iDefenderDamageInflicted);

	mov	ecx, esi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, edi
	mov	DWORD PTR $T228359[esp+216], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	DWORD PTR $T228360[esp+216], eax
	lea	eax, DWORD PTR _iDefenderDamageInflicted$222214[esp+216]
	push	eax
	lea	ecx, DWORD PTR $T228359[esp+220]
	push	ecx
	lea	edx, DWORD PTR $T228360[esp+224]
	push	edx
	lea	eax, DWORD PTR $T228361[esp+228]
	push	OFFSET $SG222355
	push	eax
	call	??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z ; GetLocalizedText<char const *,char const *,int>
	add	esp, 20					; 00000014H
	mov	BYTE PTR __$EHRec$[esp+224], 6

; 426  : 			}
; 427  : 			else

	jmp	SHORT $LN363@ResolveMel
$LN33@ResolveMel:

; 428  : 			{
; 429  : 				strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED", pkDefender->getNameKey(), pkAttacker->getNameKey(), pkAttacker->getVisualCivAdjective(pkDefender->getTeam()), iDefenderDamageInflicted);

	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, esi
	call	?getVisualCivAdjective@CvUnit@@QBEPBDW4TeamTypes@@@Z ; CvUnit::getVisualCivAdjective
	mov	ecx, esi
	mov	DWORD PTR $T228362[esp+216], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, edi
	mov	DWORD PTR $T228363[esp+216], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	lea	ecx, DWORD PTR _iDefenderDamageInflicted$222214[esp+216]
	push	ecx
	lea	edx, DWORD PTR $T228362[esp+220]
	push	edx
	mov	DWORD PTR $T228364[esp+224], eax
	lea	eax, DWORD PTR $T228363[esp+224]
	push	eax
	lea	ecx, DWORD PTR $T228364[esp+228]
	push	ecx
	lea	edx, DWORD PTR $T228365[esp+232]
	push	OFFSET $SG222372
	push	edx
	call	??$GetLocalizedText@PBDPBDPBDH@@YA?AVCvString@@PBDABQBD11ABH@Z ; GetLocalizedText<char const *,char const *,char const *,int>
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+224], 7
$LN363@ResolveMel:
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+220]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T228365[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 430  : 			}
; 431  : 			if(iActivePlayerID == pkDefender->getOwner())

	mov	eax, DWORD PTR _iActivePlayerID$[esp+216]
	cmp	eax, DWORD PTR [edi+40]
	jne	SHORT $LN357@ResolveMel

; 432  : 			{
; 433  : 				GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*,GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+216]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi+40]
	push	0
	push	0
	mov	edx, DWORD PTR [ebx]
	push	-1
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	mov	ecx, DWORD PTR _uiParentEventID$[esp+260]
	push	ecx
	mov	ecx, ebx
	call	edx
$LN357@ResolveMel:

; 434  : 			}
; 435  : 			CvNotifications* pNotification = GET_PLAYER(pkDefender->getOwner()).GetNotifications();

	mov	eax, DWORD PTR [edi+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ebx, eax

; 436  : 			if(pNotification)

	test	ebx, ebx
	je	$LN30@ResolveMel

; 437  : 			{
; 438  : 				Localization::String strSummary = Localization::Lookup("TXT_KEY_UNIT_LOST");

	lea	eax, DWORD PTR _strSummary$222376[esp+216]
	push	OFFSET $SG222378
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 439  : 				pNotification->Add(NOTIFICATION_UNIT_DIED, strBuffer, strSummary.toUTF8(), pkDefender->getX(), pkDefender->getY(), (int) pkDefender->getUnitType(), pkDefender->getOwner());

	mov	ecx, DWORD PTR [edi+40]
	mov	edx, DWORD PTR [edi+88]
	mov	eax, DWORD PTR [edi+76]
	mov	DWORD PTR $T228754[esp+216], ecx
	lea	ecx, DWORD PTR _strBuffer$[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 8
	mov	DWORD PTR $T228763[esp+216], edx
	mov	DWORD PTR $T228772[esp+216], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR $T228754[esp+216]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T228776[esp+220], eax
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	mov	edx, DWORD PTR $T228763[esp+220]
	push	eax
	mov	eax, DWORD PTR $T228772[esp+224]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _strSummary$222376[esp+232]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	ecx, DWORD PTR $T228776[esp+232]
	push	eax
	push	ecx
	push	-16309126				; ff07247aH
	mov	ecx, ebx
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 440  : 			}

	lea	ecx, DWORD PTR _strSummary$222376[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 4
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN30@ResolveMel:

; 441  : 
; 442  : #ifndef AUI_UNIT_TEST_PROMOTION_READY_MOVED
; 443  : 			pkAttacker->testPromotionReady();

	mov	ecx, esi
	call	?testPromotionReady@CvUnit@@QAEXXZ	; CvUnit::testPromotionReady

; 444  : #endif
; 445  : 
; 446  : 			ApplyPostCombatTraitEffects(pkAttacker, pkDefender);

	push	edi
	push	esi
	call	?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z ; CvUnitCombat::ApplyPostCombatTraitEffects
	add	esp, 8

; 447  : 
; 448  : 			// If defender captured, mark who captured him
; 449  : 			if (kCombatInfo.getDefenderCaptured())

	mov	ecx, ebp
	call	?getDefenderCaptured@CvCombatInfo@@QBE_NXZ ; CvCombatInfo::getDefenderCaptured
	test	al, al
	je	SHORT $LN29@ResolveMel

; 450  : 			{
; 451  : 				pkDefender->setCapturingPlayer(pkAttacker->getOwner());

	mov	eax, DWORD PTR [esi+40]
	push	eax
	mov	ecx, edi
	call	?setCapturingPlayer@CvUnit@@QAEXW4PlayerTypes@@@Z ; CvUnit::setCapturingPlayer

; 452  : 				pkDefender->SetCapturedAsIs(true);

	push	1
	mov	ecx, edi
	call	?SetCapturedAsIs@CvUnit@@QAEX_N@Z	; CvUnit::SetCapturedAsIs
$LN29@ResolveMel:

; 453  : 			}
; 454  : 		}

	mov	eax, DWORD PTR $T228355[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 0
	test	eax, eax
	je	SHORT $LN25@ResolveMel
	mov	edx, DWORD PTR [eax]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN25@ResolveMel:

; 482  : 		else if(bDefenderDead)

	cmp	BYTE PTR _bDefenderDead$[esp+216], 0
	je	SHORT $LN355@ResolveMel

; 483  : 		{
; 484  : 			if(pkDefender->isBarbarian())

	mov	ecx, edi
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	test	al, al
	je	SHORT $LN355@ResolveMel

; 485  : 				pkDefender->DoTestBarbarianThreatToMinorsWithThisUnitsDeath(pkAttacker->getOwner());

	mov	eax, DWORD PTR [esi+40]
	mov	ecx, edi
$LN364@ResolveMel:
	push	eax
	call	?DoTestBarbarianThreatToMinorsWithThisUnitsDeath@CvUnit@@QAEXW4PlayerTypes@@@Z ; CvUnit::DoTestBarbarianThreatToMinorsWithThisUnitsDeath
$LN355@ResolveMel:

; 481  : 		}

	mov	ebx, DWORD PTR _pkTargetPlot$[esp+216]
$LN21@ResolveMel:

; 486  : 		}
; 487  : 	}
; 488  : 
; 489  : 	if(pkAttacker)
; 490  : 	{
; 491  : 		pkAttacker->setCombatUnit(NULL);

	push	0
	push	0
	mov	ecx, esi
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 492  : 		pkAttacker->ClearMissionQueue(GetPostCombatDelay());

	call	?quickCombat@CvPreGame@@YA_NXZ		; CvPreGame::quickCombat
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	and	eax, 109				; 0000006dH
	inc	eax
	push	eax
	mov	ecx, esi
	call	?ClearMissionQueue@CvUnit@@QAEXH@Z	; CvUnit::ClearMissionQueue
$LN356@ResolveMel:

; 493  : 	}
; 494  : 	if(pkDefender)

	test	edi, edi
	je	$LN19@ResolveMel

; 495  : 	{
; 496  : 		pkDefender->setCombatUnit(NULL);

	push	0
	push	0
	mov	ecx, edi
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 497  : 		pkDefender->ClearMissionQueue();

	push	1
	mov	ecx, edi
	call	?ClearMissionQueue@CvUnit@@QAEXH@Z	; CvUnit::ClearMissionQueue

; 498  : 	}
; 499  : 	else

	jmp	$LN18@ResolveMel
$LN35@ResolveMel:

; 455  : 		// Nobody died
; 456  : 		else
; 457  : 		{
; 458  : 			if(iActivePlayerID == pkAttacker->getOwner())

	mov	ecx, DWORD PTR _iActivePlayerID$[esp+216]
	cmp	ecx, DWORD PTR [esi+40]
	jne	$LN352@ResolveMel

; 459  : 			{
; 460  : 				strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_WITHDRAW", pkAttacker->getNameKey(), iDefenderDamageInflicted, pkDefender->getNameKey(), iAttackerDamageInflicted);

	mov	ecx, edi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T228366[esp+216], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	DWORD PTR $T228367[esp+216], eax
	lea	edx, DWORD PTR _iAttackerDamageInflicted$222213[esp+216]
	push	edx
	lea	eax, DWORD PTR $T228366[esp+220]
	push	eax
	lea	ecx, DWORD PTR _iDefenderDamageInflicted$222214[esp+224]
	push	ecx
	lea	edx, DWORD PTR $T228367[esp+228]
	push	edx
	lea	eax, DWORD PTR $T228368[esp+232]
	push	OFFSET $SG222397
	push	eax
	call	??$GetLocalizedText@PBDHPBDH@@YA?AVCvString@@PBDABQBDABH12@Z ; GetLocalizedText<char const *,int,char const *,int>
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 9
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T228368[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 461  : 				GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+216]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi+40]
	push	0
	push	0
	mov	edx, DWORD PTR [ebx]
	push	-1
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	mov	ecx, DWORD PTR _uiParentEventID$[esp+260]
	push	ecx
	mov	ecx, ebx
	call	edx
$LN352@ResolveMel:

; 462  : 			}
; 463  : 			if(iActivePlayerID == pkDefender->getOwner())

	mov	eax, DWORD PTR _iActivePlayerID$[esp+216]
	cmp	eax, DWORD PTR [edi+40]
	jne	$LN26@ResolveMel

; 464  : 			{
; 465  : 				strBuffer = GetLocalizedText("TXT_KEY_MISC_ENEMY_UNIT_WITHDRAW", pkAttacker->getNameKey(), iDefenderDamageInflicted, pkDefender->getNameKey(), iAttackerDamageInflicted);

	mov	ecx, edi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T228369[esp+216], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	lea	ecx, DWORD PTR _iAttackerDamageInflicted$222213[esp+216]
	push	ecx
	lea	edx, DWORD PTR $T228369[esp+220]
	push	edx
	mov	DWORD PTR $T228370[esp+224], eax
	lea	eax, DWORD PTR _iDefenderDamageInflicted$222214[esp+224]
	push	eax
	lea	ecx, DWORD PTR $T228370[esp+228]
	push	ecx
	lea	edx, DWORD PTR $T228371[esp+232]
	push	OFFSET $SG222402
	push	edx
	call	??$GetLocalizedText@PBDHPBDH@@YA?AVCvString@@PBDABQBDABH12@Z ; GetLocalizedText<char const *,int,char const *,int>
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 10		; 0000000aH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T228371[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 466  : 				GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+216]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi+40]
	push	0
	push	0
	mov	edx, DWORD PTR [ebx]
	push	-1
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	mov	ecx, DWORD PTR _uiParentEventID$[esp+260]
	push	ecx
	mov	ecx, ebx
	call	edx
$LN26@ResolveMel:

; 467  : 			}
; 468  : 
; 469  : #ifndef AUI_UNIT_TEST_PROMOTION_READY_MOVED
; 470  : 			pkDefender->testPromotionReady();

	mov	ecx, edi
	call	?testPromotionReady@CvUnit@@QAEXXZ	; CvUnit::testPromotionReady

; 471  : 			pkAttacker->testPromotionReady();

	mov	ecx, esi
	call	?testPromotionReady@CvUnit@@QAEXXZ	; CvUnit::testPromotionReady

; 472  : #endif
; 473  : 
; 474  : 		}
; 475  : 
; 476  : 		// Minors want Barbs near them dead
; 477  : 		if(bAttackerDead)

	jmp	$LN25@ResolveMel
$LN19@ResolveMel:

; 500  : 		bDefenderDead = true;

	mov	BYTE PTR _bDefenderDead$[esp+216], 1
$LN18@ResolveMel:

; 501  : 
; 502  : 	if(pkAttacker)

	test	esi, esi
	je	$LN359@ResolveMel

; 503  : 	{
; 504  : 		if(pkAttacker->isSuicide())

	mov	ecx, esi
	call	?isSuicide@CvUnit@@QBE_NXZ		; CvUnit::isSuicide
	test	al, al
	je	SHORT $LN16@ResolveMel

; 505  : 		{
; 506  : 			pkAttacker->setCombatUnit(NULL);	// Must clear this if doing a delayed kill, should this be part of the kill method?

	push	0
	push	0
	mov	ecx, esi
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 507  : 			pkAttacker->kill(true);

	push	-1
	push	1
	mov	ecx, esi
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill

; 508  : 		}
; 509  : 		else

	jmp	$LN358@ResolveMel
$LN16@ResolveMel:

; 510  : 		{
; 511  : #ifdef AUI_WARNING_FIXES
; 512  : 			if (pkTargetPlot && pkDefender)
; 513  : #else
; 514  : 			if(pkTargetPlot)

	test	ebx, ebx
	je	$LN361@ResolveMel

; 515  : #endif
; 516  : 			{
; 517  : #ifdef NQ_HEAVY_CHARGE_DOWNHILL
; 518  : 				bool isAttackingFromHigherElevation = false;
; 519  : 				if (pkAttacker->GetHeavyChargeDownhill() > 0)

	mov	ecx, esi
	mov	BYTE PTR _isAttackingFromHigherElevation$222415[esp+216], 0
	call	?GetHeavyChargeDownhill@CvUnit@@QBEHXZ	; CvUnit::GetHeavyChargeDownhill
	test	eax, eax
	jle	SHORT $LN48@ResolveMel

; 520  : 				{
; 521  : 					isAttackingFromHigherElevation = 
; 522  : 						(pkAttacker->plot()->isMountain() && !pkDefender->plot()->isMountain()) ||
; 523  : 						(pkAttacker->plot()->isHills() && pkDefender->plot()->isFlatlands());

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	BYTE PTR [eax+5], 0
	jne	SHORT $LN45@ResolveMel
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	BYTE PTR [eax+5], 0
	jne	SHORT $LN47@ResolveMel
$LN45@ResolveMel:
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	BYTE PTR [eax+5], 1
	jne	SHORT $LN46@ResolveMel
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?isFlatlands@CvPlot@@QBE_NXZ		; CvPlot::isFlatlands
	test	al, al
	je	SHORT $LN46@ResolveMel
$LN47@ResolveMel:
	mov	BYTE PTR _isAttackingFromHigherElevation$222415[esp+216], 1
	jmp	SHORT $LN48@ResolveMel
$LN46@ResolveMel:
	mov	BYTE PTR _isAttackingFromHigherElevation$222415[esp+216], 0
$LN48@ResolveMel:

; 524  : 				}
; 525  : 				if ((pkAttacker->IsCanHeavyCharge() || (pkAttacker->GetHeavyChargeDownhill() > 0 && isAttackingFromHigherElevation))
; 526  : 					&& !pkDefender->isDelayedDeath() && bAttackerDidMoreDamage)

	mov	ecx, esi
	call	?IsCanHeavyCharge@CvUnit@@QBE_NXZ	; CvUnit::IsCanHeavyCharge
	test	al, al
	jne	SHORT $LN11@ResolveMel
	mov	ecx, esi
	call	?GetHeavyChargeDownhill@CvUnit@@QBEHXZ	; CvUnit::GetHeavyChargeDownhill
	test	eax, eax
	jle	SHORT $LN12@ResolveMel
	cmp	BYTE PTR _isAttackingFromHigherElevation$222415[esp+216], 0
	je	SHORT $LN12@ResolveMel
$LN11@ResolveMel:
	mov	ecx, edi
	call	?isDelayedDeath@CvUnit@@QBE_NXZ		; CvUnit::isDelayedDeath
	test	al, al
	jne	SHORT $LN12@ResolveMel
	cmp	BYTE PTR _bAttackerDidMoreDamage$[esp+216], al
	je	SHORT $LN12@ResolveMel

; 527  : #else
; 528  : 				if (pkAttacker->IsCanHeavyCharge() && !pkDefender->isDelayedDeath() && bAttackerDidMoreDamage)
; 529  : #endif
; 530  : 				{
; 531  : 					pkDefender->DoFallBackFromMelee(*pkAttacker);

	push	esi
	mov	ecx, edi
	call	?DoFallBackFromMelee@CvUnit@@IAE_NAAV1@@Z ; CvUnit::DoFallBackFromMelee
$LN12@ResolveMel:

; 532  : 				}
; 533  : 
; 534  : 				bool bCanAdvance = kCombatInfo.getAttackerAdvances() && pkTargetPlot->getNumVisibleEnemyDefenders(pkAttacker) == 0;

	mov	ecx, ebp
	call	?getAttackerAdvances@CvCombatInfo@@QBE_NXZ ; CvCombatInfo::getAttackerAdvances
	test	al, al
	je	SHORT $LN10@ResolveMel
	push	esi
	mov	ecx, ebx
	call	?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z ; CvPlot::getNumVisibleEnemyDefenders
	test	eax, eax

; 535  : 				if(bCanAdvance)

	jne	SHORT $LN10@ResolveMel

; 536  : 				{
; 537  : 					if(kCombatInfo.getAttackerAdvancedVisualization())

	mov	ecx, ebp
	call	?getAttackerAdvancedVisualization@CvCombatInfo@@QBE_NXZ ; CvCombatInfo::getAttackerAdvancedVisualization

; 538  : 						// The combat vis has already 'moved' the unit.  Have the game side just do its movement calculations and pop the unit to the new location.
; 539  : 						pkAttacker->move(*pkTargetPlot, false);

	push	0
	mov	ecx, esi
	test	al, al
	je	SHORT $LN9@ResolveMel
	push	ebx
	call	?move@CvUnit@@QAEXAAVCvPlot@@_N@Z	; CvUnit::move

; 542  : 
; 543  : 					pkAttacker->PublishQueuedVisualizationMoves();

	mov	ecx, esi
	call	?PublishQueuedVisualizationMoves@CvUnit@@IAEXXZ ; CvUnit::PublishQueuedVisualizationMoves

; 544  : 				}
; 545  : 				else

	jmp	$LN361@ResolveMel
$LN9@ResolveMel:

; 540  : 					else
; 541  : 						pkAttacker->UnitMove(pkTargetPlot, true, pkAttacker);

	push	esi
	push	1
	push	ebx
	call	?UnitMove@CvUnit@@QAE_NPAVCvPlot@@_NPAV1@1@Z ; CvUnit::UnitMove

; 542  : 
; 543  : 					pkAttacker->PublishQueuedVisualizationMoves();

	mov	ecx, esi
	call	?PublishQueuedVisualizationMoves@CvUnit@@IAEXXZ ; CvUnit::PublishQueuedVisualizationMoves

; 544  : 				}
; 545  : 				else

	jmp	$LN361@ResolveMel
$LN10@ResolveMel:

; 546  : 				{
; 547  : #ifdef NQ_FIX_MOVES_THAT_CONSUME_ALL_MOVEMENT
; 548  : 					pkAttacker->changeMoves(-1 * std::max(GC.getMOVE_DENOMINATOR(), pkTargetPlot->movementCost(pkAttacker, pkAttacker->plot(), pkAttacker->getMoves())));

	mov	ecx, esi
	call	?getMoves@CvUnit@@QBEHXZ		; CvUnit::getMoves
	push	eax
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	push	esi
	mov	ecx, ebx
	call	?movementCost@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z ; CvPlot::movementCost
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	mov	DWORD PTR $T228378[esp+216], eax
	cmp	ecx, eax
	mov	DWORD PTR $T228379[esp+216], ecx
	lea	eax, DWORD PTR $T228378[esp+216]
	jl	SHORT $LN315@ResolveMel
	lea	eax, DWORD PTR $T228379[esp+216]
$LN315@ResolveMel:
	mov	ecx, DWORD PTR [eax]
	neg	ecx
	push	ecx
	mov	ecx, esi
	call	?changeMoves@CvUnit@@QAEXH@Z		; CvUnit::changeMoves

; 549  : #else
; 550  : 					pkAttacker->changeMoves(-1 * std::max(GC.getMOVE_DENOMINATOR(), pkTargetPlot->movementCost(pkAttacker, pkAttacker->plot())));
; 551  : #endif
; 552  : 
; 553  : 					if(!pkAttacker->canMove() || !pkAttacker->isBlitz())

	mov	ecx, esi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	SHORT $LN5@ResolveMel
	mov	ecx, esi
	call	?isBlitz@CvUnit@@QBE_NXZ		; CvUnit::isBlitz
	test	al, al
	jne	SHORT $LN361@ResolveMel
$LN5@ResolveMel:

; 554  : 					{
; 555  : 						if(pkAttacker->IsSelected())

	mov	ecx, esi
	call	?IsSelected@CvUnit@@QBE_NXZ		; CvUnit::IsSelected
	test	al, al
	je	SHORT $LN361@ResolveMel

; 556  : 						{
; 557  : 							if(GC.GetEngineUserInterface()->GetLengthSelectionList() > 1)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+104]
	call	eax
	cmp	eax, 1
	jle	SHORT $LN361@ResolveMel

; 558  : 							{
; 559  : 								auto_ptr<ICvUnit1> pDllAttacker = GC.WrapUnitPointer(pkAttacker);

	push	esi
	lea	ecx, DWORD PTR $T228380[esp+220]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z ; CvGlobals::WrapUnitPointer
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pDllAttacker$222431[esp+216], edi
	mov	eax, DWORD PTR $T228380[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 11		; 0000000bH
	test	eax, eax
	je	SHORT $LN326@ResolveMel
	mov	edx, DWORD PTR [eax]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN326@ResolveMel:

; 560  : 								GC.GetEngineUserInterface()->RemoveFromSelectionList(pDllAttacker.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+68]
	push	edi
	call	eax

; 561  : 							}

	mov	BYTE PTR __$EHRec$[esp+224], 0
	test	edi, edi
	je	SHORT $LN361@ResolveMel
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+4]
	push	edi
	call	edx
$LN361@ResolveMel:

; 562  : 						}
; 563  : 					}
; 564  : 				}
; 565  : 			}
; 566  : 
; 567  : 			// If a Unit loses his moves after attacking, do so
; 568  : #ifdef NQ_UNIT_TURN_ENDS_ON_FINAL_ATTACK
; 569  : 			if(!pkAttacker->canMoveAfterAttacking() && pkAttacker->isOutOfAttacks())

	mov	ecx, esi
	call	?canMoveAfterAttacking@CvUnit@@QBE_NXZ	; CvUnit::canMoveAfterAttacking
	test	al, al
	jne	SHORT $LN2@ResolveMel
	mov	ecx, esi
	call	?isOutOfAttacks@CvUnit@@QBE_NXZ		; CvUnit::isOutOfAttacks
	test	al, al
	je	SHORT $LN2@ResolveMel

; 570  : #else
; 571  : 			if(!pkAttacker->canMoveAfterAttacking())
; 572  : #endif
; 573  : 			{
; 574  : 				pkAttacker->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 575  : 				GC.GetEngineUserInterface()->changeCycleSelectionCounter(1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+224]
	push	1
	call	edx
$LN2@ResolveMel:

; 576  : 			}
; 577  : 
; 578  : 			// Now that the attacker is in their final location, show any damage popup
; 579  : 			if (!pkAttacker->IsDead() && iAttackerDamageDelta != 0)

	mov	ecx, esi
	call	?IsDead@CvUnit@@QBE_NXZ			; CvUnit::IsDead
	test	al, al
	jne	SHORT $LN358@ResolveMel
	mov	edi, DWORD PTR _iAttackerDamageDelta$[esp+216]
	test	edi, edi
	je	SHORT $LN358@ResolveMel

; 580  : 				CvUnit::ShowDamageDeltaText(iAttackerDamageDelta, pkAttacker->plot());

	push	0
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR [esp], 0
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	push	edi
	call	?ShowDamageDeltaText@CvUnit@@SAXHPAVCvPlot@@MPBVCvString@@@Z ; CvUnit::ShowDamageDeltaText
	add	esp, 16					; 00000010H
$LN358@ResolveMel:

; 581  : 		}
; 582  : 
; 583  : 		// Report that combat is over in case we want to queue another attack
; 584  : 		GET_PLAYER(pkAttacker->getOwner()).GetTacticalAI()->CombatResolved(pkAttacker, bDefenderDead);

	mov	eax, DWORD PTR [esi+40]
	mov	ecx, DWORD PTR _bDefenderDead$[esp+216]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	ecx
	push	esi
	mov	ecx, eax
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z ; CvTacticalAI::CombatResolved
$LN359@ResolveMel:

; 585  : 	}
; 586  : }

	lea	ecx, DWORD PTR _strBuffer$[esp+216]
	mov	DWORD PTR __$EHRec$[esp+224], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+216]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 200				; 000000c8H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$2:
	lea	ecx, DWORD PTR _pAttacker$222267[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$3:
	lea	ecx, DWORD PTR $T228349[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$4:
	lea	ecx, DWORD PTR $T228353[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$6:
	lea	ecx, DWORD PTR _pDefender$222325[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$7:
	lea	ecx, DWORD PTR $T228358[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$8:
	lea	ecx, DWORD PTR $T228361[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$9:
	lea	ecx, DWORD PTR $T228365[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$10:
	lea	ecx, DWORD PTR _strSummary$222376[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$11:
	lea	ecx, DWORD PTR $T228368[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$12:
	lea	ecx, DWORD PTR $T228371[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$14:
	lea	ecx, DWORD PTR _pDllAttacker$222431[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__ehhandler$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z:
	mov	eax, OFFSET __ehfuncinfo$?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ENDP ; CvUnitCombat::ResolveMeleeCombat
PUBLIC	?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveRangedUnitVsCombat
EXTRN	?changeDamage@CvCity@@QAEXH@Z:PROC		; CvCity::changeDamage
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
xdata$x	ENDS
;	COMDAT ?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
_TEXT	SEGMENT
$T229307 = -176						; size = 4
$T229248 = -176						; size = 4
$T229202 = -176						; size = 4
$T229157 = -176						; size = 4
$T229035 = -176						; size = 4
$T229034 = -176						; size = 4
$T229031 = -176						; size = 4
$T229028 = -176						; size = 4
$T229144 = -172						; size = 4
$T229067 = -172						; size = 4
$T229026 = -172						; size = 4
$T229022 = -172						; size = 4
_bBarbarian$ = -165					; size = 1
_iDamage$ = -164					; size = 4
$T229153 = -160						; size = 4
$T229036 = -160						; size = 4
$T229032 = -160						; size = 4
$T229029 = -160						; size = 4
$T229135 = -156						; size = 4
$T229025 = -156						; size = 4
$T229023 = -156						; size = 4
_bTargetDied$ = -152					; size = 1
_strBuffer$ = -148					; size = 28
$T229037 = -120						; size = 28
$T229033 = -120						; size = 28
$T229030 = -120						; size = 28
$T229027 = -120						; size = 28
$T229024 = -120						; size = 28
_strSummary$222516 = -92				; size = 80
__$EHRec$ = -12						; size = 12
_kCombatInfo$ = 8					; size = 4
_uiParentEventID$ = 12					; size = 4
?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z PROC ; CvUnitCombat::ResolveRangedUnitVsCombat, COMDAT

; 929  : {

	push	-1
	push	__ehhandler$?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 164				; 000000a4H
	push	ebx

; 930  : 	bool bTargetDied = false;
; 931  : 	int iDamage = kCombatInfo.getDamageInflicted(BATTLE_UNIT_ATTACKER);

	mov	ebx, DWORD PTR _kCombatInfo$[esp+176]
	push	ebp
	push	esi
	push	edi
	push	0
	mov	ecx, ebx
	mov	BYTE PTR _bTargetDied$[esp+196], 0
	call	?getDamageInflicted@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getDamageInflicted

; 932  : //	int iExperience = kCombatInfo.getExperience(BATTLE_UNIT_ATTACKER);
; 933  : //	int iMaxXP = kCombatInfo.getMaxExperienceAllowed(BATTLE_UNIT_ATTACKER);
; 934  : 	bool bBarbarian = false;
; 935  : 
; 936  : 	CvUnit* pkAttacker = kCombatInfo.getUnit(BATTLE_UNIT_ATTACKER);

	push	0
	mov	ecx, ebx
	mov	DWORD PTR _iDamage$[esp+196], eax
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit

; 937  : 	CvAssert_Debug(pkAttacker);
; 938  : 
; 939  : 	CvPlot* pkTargetPlot = kCombatInfo.getPlot();

	mov	ecx, ebx
	mov	edi, eax
	call	?getPlot@CvCombatInfo@@QBEPAVCvPlot@@XZ	; CvCombatInfo::getPlot

; 940  : 	CvAssert_Debug(pkTargetPlot);
; 941  : 
; 942  : #ifdef DEL_RANGED_COUNTERATTACKS
; 943  : 	bool bAttackerDied = false;
; 944  : 	int iDamageToAttacker = kCombatInfo.getDamageInflicted(BATTLE_UNIT_DEFENDER);
; 945  : 	int iAttackerFearDamageInflicted = 0;//pInfo->getFearDamageInflicted( BATTLE_UNIT_ATTACKER );
; 946  : #endif
; 947  : 
; 948  : 	ICvUserInterface2* pkDLLInterface = GC.GetEngineUserInterface();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600

; 949  : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[esp+192]
	mov	esi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[esp+200], 0

; 950  : 
; 951  : 	if(pkTargetPlot)

	test	esi, esi
	je	$LN22@ResolveRan@2

; 952  : 	{
; 953  : 		if(!pkTargetPlot->isCity())

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN189@ResolveRan@2
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN189@ResolveRan@2
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	$LN21@ResolveRan@2
$LN189@ResolveRan@2:

; 954  : 		{
; 955  : 			// Unit
; 956  : 			CvUnit* pkDefender = kCombatInfo.getUnit(BATTLE_UNIT_DEFENDER);

	push	1
	mov	ecx, ebx
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit
	mov	esi, eax

; 957  : 			CvAssert_Debug(pkDefender != NULL);
; 958  : 			if(pkDefender)

	test	esi, esi
	je	$LN22@ResolveRan@2

; 959  : 			{
; 960  : 				bBarbarian = pkDefender->isBarbarian();

	mov	ecx, esi
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	mov	BYTE PTR _bBarbarian$[esp+192], al

; 961  : 
; 962  : 				if(pkAttacker)

	test	edi, edi
	je	$LN19@ResolveRan@2

; 963  : 				{
; 964  : #ifdef DEL_RANGED_COUNTERATTACKS
; 965  : 					pkDefender->changeDamage(iDamage, pkAttacker->getOwner());
; 966  : 					pkAttacker->changeDamage(iDamageToAttacker, pkDefender->getOwner());
; 967  : 
; 968  : 					pkDefender->changeExperience(
; 969  : 						kCombatInfo.getExperience(BATTLE_UNIT_DEFENDER),
; 970  : 						kCombatInfo.getMaxExperienceAllowed(BATTLE_UNIT_DEFENDER),
; 971  : 						true,
; 972  : 						kCombatInfo.getInBorders(BATTLE_UNIT_DEFENDER),
; 973  : 						kCombatInfo.getUpdateGlobal(BATTLE_UNIT_DEFENDER));
; 974  : 					pkAttacker->changeExperience(
; 975  : 						kCombatInfo.getExperience(BATTLE_UNIT_ATTACKER),
; 976  : 						kCombatInfo.getMaxExperienceAllowed(BATTLE_UNIT_ATTACKER),
; 977  : 						true,
; 978  : 						kCombatInfo.getInBorders(BATTLE_UNIT_ATTACKER),
; 979  : 						kCombatInfo.getUpdateGlobal(BATTLE_UNIT_ATTACKER));
; 980  : 
; 981  : 																															// Anyone eat it?
; 982  : 					bAttackerDied = (pkAttacker->getDamage() >= GC.getMAX_HIT_POINTS());
; 983  : 					bTargetDied = (pkDefender->getDamage() >= GC.getMAX_HIT_POINTS());
; 984  : 
; 985  : 					if (bTargetDied)
; 986  : #else
; 987  : 					// Defender died
; 988  : 					if(iDamage + pkDefender->getDamage() >= GC.getMAX_HIT_POINTS())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, esi
	mov	DWORD PTR $T229067[esp+192], edx
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	add	eax, DWORD PTR _iDamage$[esp+192]
	cmp	eax, DWORD PTR $T229067[esp+192]
	jl	$LN18@ResolveRan@2

; 989  : #endif
; 990  : 					{
; 991  : 						if(pkAttacker->getOwner() == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, DWORD PTR [edi+40]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	ebx, eax
	jne	$LN17@ResolveRan@2

; 992  : 						{
; 993  : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_ATTACK_BY_AIR_AND_DEATH", pkAttacker->getNameKey(), pkDefender->getNameKey());

	mov	ecx, esi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, edi
	mov	DWORD PTR $T229022[esp+192], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	DWORD PTR $T229023[esp+192], eax
	lea	eax, DWORD PTR $T229022[esp+192]
	push	eax
	lea	ecx, DWORD PTR $T229023[esp+196]
	push	ecx
	lea	edx, DWORD PTR $T229024[esp+200]
	push	OFFSET $SG222509
	push	edx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 1
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T229024[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 994  : 							pkDLLInterface->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_COMBAT", MESSAGE_TYPE_INFO, pkDefender->getUnitInfo().GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	lea	ecx, DWORD PTR _strBuffer$[esp+192]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi+40]
	push	0
	push	0
	mov	edx, DWORD PTR [ebp]
	push	-1
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	mov	ecx, DWORD PTR _uiParentEventID$[esp+236]
	push	ecx
	mov	ecx, ebp
	call	edx
$LN17@ResolveRan@2:

; 995  : 						}
; 996  : 
; 997  : 						strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_AIR_AND_DEATH", pkDefender->getNameKey(), pkAttacker->getNameKey());

	mov	ecx, edi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T229025[esp+192], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	DWORD PTR $T229026[esp+192], eax
	lea	eax, DWORD PTR $T229025[esp+192]
	push	eax
	lea	ecx, DWORD PTR $T229026[esp+196]
	push	ecx
	lea	edx, DWORD PTR $T229027[esp+200]
	push	OFFSET $SG222513
	push	edx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 2
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T229027[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 998  : 						CvNotifications* pNotifications = GET_PLAYER(pkDefender->getOwner()).GetNotifications();

	mov	eax, DWORD PTR [esi+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ebx, eax

; 999  : 						if(pNotifications)

	test	ebx, ebx
	je	$LN16@ResolveRan@2

; 1000 : 						{
; 1001 : 							Localization::String strSummary = Localization::Lookup("TXT_KEY_UNIT_LOST");

	lea	eax, DWORD PTR _strSummary$222516[esp+192]
	push	OFFSET $SG222518
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 1002 : 							pNotifications->Add(NOTIFICATION_UNIT_DIED, strBuffer, strSummary.toUTF8(), pkDefender->getX(), pkDefender->getY(), (int) pkDefender->getUnitType(), pkDefender->getOwner());

	mov	ecx, DWORD PTR [esi+40]
	mov	edx, DWORD PTR [esi+88]
	mov	eax, DWORD PTR [esi+76]
	mov	DWORD PTR $T229135[esp+192], ecx
	lea	ecx, DWORD PTR _strBuffer$[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 3
	mov	DWORD PTR $T229144[esp+192], edx
	mov	DWORD PTR $T229153[esp+192], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR $T229135[esp+192]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T229157[esp+196], eax
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	mov	edx, DWORD PTR $T229144[esp+196]
	push	eax
	mov	eax, DWORD PTR $T229153[esp+200]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _strSummary$222516[esp+208]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	ecx, DWORD PTR $T229157[esp+208]
	push	eax
	push	ecx
	push	-16309126				; ff07247aH
	mov	ecx, ebx
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 1003 : 						}

	lea	ecx, DWORD PTR _strSummary$222516[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 0
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN16@ResolveRan@2:

; 1004 : 
; 1005 : #ifdef DEL_RANGED_COUNTERATTACKS
; 1006 : #ifndef AUI_UNIT_TEST_PROMOTION_READY_MOVED
; 1007 : 						pkAttacker->testPromotionReady();
; 1008 : #endif
; 1009 : #else
; 1010 : 						bTargetDied = true;
; 1011 : #endif
; 1012 : 
; 1013 : 						CvPlayerAI& kAttackerOwner = GET_PLAYER(pkAttacker->getOwner());

	mov	eax, DWORD PTR [edi+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 1014 : 						kAttackerOwner.GetPlayerAchievements().KilledUnitWithUnit(pkAttacker, pkDefender);

	push	esi
	push	edi
	lea	ecx, DWORD PTR [eax+63156]
	mov	BYTE PTR _bTargetDied$[esp+200], 1
	call	?KilledUnitWithUnit@CvPlayerAchievements@@QAEXPAVCvUnit@@0@Z ; CvPlayerAchievements::KilledUnitWithUnit

; 1015 : 
; 1016 : 						ApplyPostCombatTraitEffects(pkAttacker, pkDefender);

	push	esi
	push	edi
	call	?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z ; CvUnitCombat::ApplyPostCombatTraitEffects
	add	esp, 8

; 1017 : 
; 1018 : 						if(bBarbarian)

	cmp	BYTE PTR _bBarbarian$[esp+192], 0
	je	SHORT $LN15@ResolveRan@2

; 1019 : 						{
; 1020 : 							pkDefender->DoTestBarbarianThreatToMinorsWithThisUnitsDeath(pkAttacker->getOwner());

	mov	eax, DWORD PTR [edi+40]
	push	eax
	mov	ecx, esi
	call	?DoTestBarbarianThreatToMinorsWithThisUnitsDeath@CvUnit@@QAEXW4PlayerTypes@@@Z ; CvUnit::DoTestBarbarianThreatToMinorsWithThisUnitsDeath
$LN15@ResolveRan@2:

; 1021 : 						}
; 1022 : 
; 1023 : 						//One Hit
; 1024 : 						if(pkDefender->GetCurrHitPoints() == GC.getMAX_HIT_POINTS() && pkAttacker->isHuman() && !GC.getGame().isGameMultiPlayer())

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, esi
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	cmp	eax, ebx
	jne	SHORT $LN191@ResolveRan@2
	mov	ecx, edi
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	je	SHORT $LN191@ResolveRan@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	SHORT $LN191@ResolveRan@2

; 1025 : 						{
; 1026 : 							gDLL->UnlockAchievement(ACHIEVEMENT_ONEHITKILL);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	60					; 0000003cH
	call	eax
$LN191@ResolveRan@2:

; 1027 : 						}
; 1028 : 					}
; 1029 : #ifdef DEL_RANGED_COUNTERATTACKS
; 1030 : 					else if (bAttackerDied)
; 1031 : 					{
; 1032 : 						CvPlayerAI& kDefenderOwner = GET_PLAYER(pkDefender->getOwner());
; 1033 : 						kDefenderOwner.GetPlayerAchievements().KilledUnitWithUnit(pkDefender, pkAttacker);
; 1034 : 
; 1035 : 						auto_ptr<ICvUnit1> pAttacker = GC.WrapUnitPointer(pkAttacker);
; 1036 : 						gDLL->GameplayUnitDestroyedInCombat(pAttacker.get());
; 1037 : 
; 1038 : 						if (GC.getGame().getActivePlayer() == pkAttacker->getOwner())
; 1039 : 						{
; 1040 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_DIED_ATTACKING", pkAttacker->getNameKey(), pkDefender->getNameKey(), iDamage, iAttackerFearDamageInflicted);
; 1041 : 							GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);
; 1042 : 						}
; 1043 : 						if (GC.getGame().getActivePlayer() == pkDefender->getOwner())
; 1044 : 						{
; 1045 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_KILLED_ENEMY_UNIT", pkDefender->getNameKey(), iDamage, iAttackerFearDamageInflicted, pkAttacker->getNameKey(), pkAttacker->getVisualCivAdjective(pkDefender->getTeam()));
; 1046 : 							GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);
; 1047 : 						}
; 1048 : #ifndef AUI_UNIT_TEST_PROMOTION_READY_MOVED
; 1049 : 						pkDefender->testPromotionReady();
; 1050 : #endif
; 1051 : 
; 1052 : 						ApplyPostCombatTraitEffects(pkDefender, pkAttacker);
; 1053 : 					}
; 1054 : #endif
; 1055 : 					// Nobody died
; 1056 : 					else

	mov	ebx, DWORD PTR _kCombatInfo$[esp+188]
$LN13@ResolveRan@2:

; 1064 : #if defined(DEL_RANGED_COUNTERATTACKS) && !defined(AUI_UNIT_TEST_PROMOTION_READY_MOVED)
; 1065 : 						pkAttacker->testPromotionReady();
; 1066 : 						pkDefender->testPromotionReady();
; 1067 : #endif
; 1068 : 					}
; 1069 : 
; 1070 : 					//red icon over attacking unit
; 1071 : 					if(pkDefender->getOwner() == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR [esi+40]
	mov	DWORD PTR $T229248[esp+192], ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR $T229248[esp+192], eax
	jne	SHORT $LN11@ResolveRan@2

; 1072 : 					{
; 1073 : 						pkDLLInterface->AddMessage(uiParentEventID, pkDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_COMBAT", MESSAGE_TYPE_INFO, pkAttacker->m_pUnitInfo->GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkAttacker->getX(), pkAttacker->getY(), true, true*/);

	lea	ecx, DWORD PTR _strBuffer$[esp+192]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi+40]
	push	0
	push	0
	mov	edx, DWORD PTR [ebp]
	push	-1
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	0
	push	ecx
	mov	ecx, DWORD PTR _uiParentEventID$[esp+236]
	push	ecx
	mov	ecx, ebp
	call	edx
$LN11@ResolveRan@2:

; 1074 : 					}
; 1075 : 					//white icon over defending unit
; 1076 : 					//pkDLLInterface->AddMessage(uiParentEventID, pkDefender->getOwner(), false, 0, ""/*, "AS2D_COMBAT", MESSAGE_TYPE_DISPLAY_ONLY, pkDefender->getUnitInfo().GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), pkDefender->getX(), pkDefender->getY(), true, true*/);
; 1077 : 
; 1078 : #ifndef DEL_RANGED_COUNTERATTACKS
; 1079 : 					//set damage but don't update entity damage visibility
; 1080 : 					pkDefender->changeDamage(iDamage, pkAttacker->getOwner());

	mov	eax, DWORD PTR [edi+40]
	push	0
	push	ecx
	mov	DWORD PTR [esp], 0
	push	eax
	mov	eax, DWORD PTR _iDamage$[esp+204]
	push	eax
	mov	ecx, esi
	call	?changeDamage@CvUnit@@QAEHHW4PlayerTypes@@MPBVCvString@@@Z ; CvUnit::changeDamage

; 1081 : 
; 1082 : 					// Update experience
; 1083 : 					pkDefender->changeExperience(
; 1084 : 					    kCombatInfo.getExperience(BATTLE_UNIT_DEFENDER),
; 1085 : 					    kCombatInfo.getMaxExperienceAllowed(BATTLE_UNIT_DEFENDER),
; 1086 : 					    true,
; 1087 : 					    kCombatInfo.getInBorders(BATTLE_UNIT_DEFENDER),
; 1088 : 					    kCombatInfo.getUpdateGlobal(BATTLE_UNIT_DEFENDER));

	push	1
	mov	ecx, ebx
	call	?getUpdateGlobal@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getUpdateGlobal
	movzx	ecx, al
	push	ecx
	push	1
	mov	ecx, ebx
	call	?getInBorders@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getInBorders
	movzx	edx, al
	push	edx
	push	1
	push	1
	mov	ecx, ebx
	call	?getMaxExperienceAllowed@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getMaxExperienceAllowed
	push	eax
	push	1
	mov	ecx, ebx
	call	?getExperience@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getExperience
	push	eax
	mov	ecx, esi
	call	?changeExperience@CvUnit@@QAEXHH_N00@Z	; CvUnit::changeExperience
$LN19@ResolveRan@2:

; 1089 : #endif
; 1090 : 				}
; 1091 : 
; 1092 : 				pkDefender->setCombatUnit(NULL);

	push	0
	push	0
	mov	ecx, esi
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 1093 : 				if(!CvUnitMission::IsHeadMission(pkDefender, CvTypes::getMISSION_WAIT_FOR()))		// If the top mission was not a 'wait for', then clear it.

	call	?getMISSION_WAIT_FOR@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_WAIT_FOR
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T229034[esp+204], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?IsHeadMission@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z ; CvUnitMission::IsHeadMission
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN3@ResolveRan@2

; 1094 : 					pkDefender->ClearMissionQueue();

	push	1
	mov	ecx, esi
	call	?ClearMissionQueue@CvUnit@@QAEXH@Z	; CvUnit::ClearMissionQueue

; 1095 : 			}
; 1096 : 			else
; 1097 : 				bTargetDied = true;
; 1098 : 		}
; 1099 : 		else

	jmp	$LN3@ResolveRan@2
$LN18@ResolveRan@2:

; 1057 : 					{
; 1058 : 						if(pkAttacker->getOwner() == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR [edi+40]
	mov	DWORD PTR $T229202[esp+192], ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR $T229202[esp+192], eax
	jne	$LN12@ResolveRan@2

; 1059 : 						{
; 1060 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_ATTACK_BY_AIR", pkAttacker->getNameKey(), pkDefender->getNameKey(), iDamage);

	mov	ecx, esi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, edi
	mov	DWORD PTR $T229028[esp+192], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	lea	edx, DWORD PTR _iDamage$[esp+192]
	push	edx
	mov	DWORD PTR $T229029[esp+196], eax
	lea	eax, DWORD PTR $T229028[esp+196]
	push	eax
	lea	ecx, DWORD PTR $T229029[esp+200]
	push	ecx
	lea	edx, DWORD PTR $T229030[esp+204]
	push	OFFSET $SG222528
	push	edx
	call	??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z ; GetLocalizedText<char const *,char const *,int>
	add	esp, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 4
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T229030[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1061 : 							pkDLLInterface->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_COMBAT", MESSAGE_TYPE_INFO, pkDefender->getUnitInfo().GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	lea	ecx, DWORD PTR _strBuffer$[esp+192]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi+40]
	push	0
	push	0
	mov	edx, DWORD PTR [ebp]
	push	-1
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	mov	ecx, DWORD PTR _uiParentEventID$[esp+236]
	push	ecx
	mov	ecx, ebp
	call	edx
$LN12@ResolveRan@2:

; 1062 : 						}
; 1063 : 						strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_AIR", pkDefender->getNameKey(), pkAttacker->getNameKey(), iDamage);

	mov	ecx, edi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T229031[esp+192], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	DWORD PTR $T229032[esp+192], eax
	lea	eax, DWORD PTR _iDamage$[esp+192]
	push	eax
	lea	ecx, DWORD PTR $T229031[esp+196]
	push	ecx
	lea	edx, DWORD PTR $T229032[esp+200]
	push	edx
	lea	eax, DWORD PTR $T229033[esp+204]
	push	OFFSET $SG222532
	push	eax
	call	??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z ; GetLocalizedText<char const *,char const *,int>
	add	esp, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 5
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T229033[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN13@ResolveRan@2
$LN21@ResolveRan@2:

; 1100 : 		{
; 1101 : 			// City
; 1102 : 			CvCity* pCity = pkTargetPlot->getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	$LN22@ResolveRan@2
	cmp	eax, 64					; 00000040H
	jge	$LN22@ResolveRan@2
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	esi, eax

; 1103 : 			CvAssert_Debug(pCity != NULL);
; 1104 : 			if(pCity)

	test	esi, esi
	je	$LN22@ResolveRan@2

; 1105 : 			{
; 1106 : 				if(pkAttacker)

	test	edi, edi
	je	$LN5@ResolveRan@2

; 1107 : 				{
; 1108 : 					bBarbarian = pCity->isBarbarian();

	mov	ecx, esi
	call	?isBarbarian@CvCity@@QBE_NXZ		; CvCity::isBarbarian

; 1109 : 					pCity->changeDamage(iDamage);

	mov	edx, DWORD PTR _iDamage$[esp+192]
	push	edx
	mov	ecx, esi
	call	?changeDamage@CvCity@@QAEXH@Z		; CvCity::changeDamage

; 1110 : 
; 1111 : #ifdef DEL_RANGED_COUNTERATTACKS
; 1112 : 					pkAttacker->changeDamage(iDamageToAttacker, pCity->getOwner());
; 1113 : 
; 1114 : 					pkAttacker->changeExperience(
; 1115 : 						kCombatInfo.getExperience(BATTLE_UNIT_ATTACKER),
; 1116 : 						kCombatInfo.getMaxExperienceAllowed(BATTLE_UNIT_ATTACKER),
; 1117 : 						true,
; 1118 : 						kCombatInfo.getInBorders(BATTLE_UNIT_ATTACKER),
; 1119 : 						kCombatInfo.getUpdateGlobal(BATTLE_UNIT_ATTACKER));
; 1120 : 
; 1121 : 					// Anyone eat it?
; 1122 : 					bAttackerDied = (pkAttacker->getDamage() >= GC.getMAX_HIT_POINTS());
; 1123 : 
; 1124 : 					if (bAttackerDied)
; 1125 : 					{
; 1126 : 						auto_ptr<ICvUnit1> pAttacker = GC.WrapUnitPointer(pkAttacker);
; 1127 : 						gDLL->GameplayUnitDestroyedInCombat(pAttacker.get());
; 1128 : 
; 1129 : 						if (GC.getGame().getActivePlayer() == pkAttacker->getOwner())
; 1130 : 						{
; 1131 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_DIED_ATTACKING_CITY", pkAttacker->getNameKey(), pCity->getNameKey(), iDamage, iAttackerFearDamageInflicted);
; 1132 : 							pkDLLInterface->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);
; 1133 : 						}
; 1134 : 						if (GC.getGame().getActivePlayer() == pCity->getOwner())
; 1135 : 						{
; 1136 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_KILLED_ENEMY_UNIT_CITY", pCity->getNameKey(), iDamageToAttacker, iAttackerFearDamageInflicted, pkAttacker->getNameKey(), pkAttacker->getVisualCivAdjective(pCity->getTeam()));
; 1137 : 							pkDLLInterface->AddMessage(uiParentEventID, pCity->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);
; 1138 : 						}
; 1139 : 					}
; 1140 : 					else
; 1141 : 					{
; 1142 : #ifndef AUI_UNIT_TEST_PROMOTION_READY_MOVED
; 1143 : 						pkAttacker->testPromotionReady();
; 1144 : #endif
; 1145 : #endif
; 1146 : 					if(pCity->getOwner() == GC.getGame().getActivePlayer())

	mov	eax, DWORD PTR [esi+84]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T229307[esp+192], eax
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR $T229307[esp+192], eax
	jne	$LN5@ResolveRan@2

; 1147 : 					{
; 1148 : 						strBuffer = GetLocalizedText("TXT_KEY_MISC_YOUR_CITY_ATTACKED_BY_AIR", pCity->getNameKey(), pkAttacker->getNameKey(), iDamage);

	mov	ecx, edi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T229035[esp+192], eax
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	lea	ecx, DWORD PTR _iDamage$[esp+192]
	push	ecx
	lea	edx, DWORD PTR $T229035[esp+196]
	push	edx
	mov	DWORD PTR $T229036[esp+200], eax
	lea	eax, DWORD PTR $T229036[esp+200]
	push	eax
	lea	ecx, DWORD PTR $T229037[esp+204]
	push	OFFSET $SG222545
	push	ecx
	call	??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z ; GetLocalizedText<char const *,char const *,int>
	add	esp, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 6
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T229037[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1149 : 						//red icon over attacking unit
; 1150 : 						pkDLLInterface->AddMessage(uiParentEventID, pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_COMBAT", MESSAGE_TYPE_INFO, pkAttacker->m_pUnitInfo->GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkAttacker->getX(), pkAttacker->getY(), true, true*/);

	lea	ecx, DWORD PTR _strBuffer$[esp+192]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi+84]
	push	0
	push	0
	mov	edx, DWORD PTR [ebp]
	push	-1
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	0
	push	ecx
	mov	ecx, DWORD PTR _uiParentEventID$[esp+236]
	push	ecx
	mov	ecx, ebp
	call	edx
$LN5@ResolveRan@2:

; 1151 : 					}
; 1152 : #ifdef DEL_RANGED_COUNTERATTACKS
; 1153 : 						if (GC.getGame().getActivePlayer() == pkAttacker->getOwner())
; 1154 : 						{
; 1155 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_ATTACK_BY_AIR", pkAttacker->getNameKey(), pCity->getNameKey(), iDamage);
; 1156 : 							pkDLLInterface->AddMessage(uiParentEventID, pkAttacker->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);
; 1157 : 						}
; 1158 : 					}
; 1159 : #endif
; 1160 : 				}
; 1161 : 
; 1162 : 				pCity->clearCombat();

	mov	ecx, esi
	call	?clearCombat@CvCity@@QAEXXZ		; CvCity::clearCombat

; 1163 : 			}
; 1164 : 			else

	jmp	SHORT $LN3@ResolveRan@2
$LN22@ResolveRan@2:

; 1165 : 				bTargetDied = true;
; 1166 : 		}
; 1167 : 	}
; 1168 : 	else
; 1169 : 		bTargetDied = true;

	mov	BYTE PTR _bTargetDied$[esp+192], 1
$LN3@ResolveRan@2:

; 1170 : 
; 1171 : 	if(pkAttacker)

	test	edi, edi
	je	$LN2@ResolveRan@2

; 1172 : 	{
; 1173 : #ifndef DEL_RANGED_COUNTERATTACKS
; 1174 : 		// Unit gains XP for executing a Range Strike
; 1175 : 		if(iDamage > 0) // && iDefenderStrength > 0)

	cmp	DWORD PTR _iDamage$[esp+192], 0
	jle	SHORT $LN1@ResolveRan@2

; 1176 : 		{
; 1177 : 			pkAttacker->changeExperience(
; 1178 : 			    kCombatInfo.getExperience(BATTLE_UNIT_ATTACKER),
; 1179 : 			    kCombatInfo.getMaxExperienceAllowed(BATTLE_UNIT_ATTACKER),
; 1180 : 			    true,
; 1181 : 			    kCombatInfo.getInBorders(BATTLE_UNIT_ATTACKER),
; 1182 : 			    kCombatInfo.getUpdateGlobal(BATTLE_UNIT_ATTACKER));

	push	0
	mov	ecx, ebx
	call	?getUpdateGlobal@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getUpdateGlobal
	movzx	eax, al
	push	eax
	push	0
	mov	ecx, ebx
	call	?getInBorders@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getInBorders
	movzx	ecx, al
	push	ecx
	push	1
	push	0
	mov	ecx, ebx
	call	?getMaxExperienceAllowed@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getMaxExperienceAllowed
	push	eax
	push	0
	mov	ecx, ebx
	call	?getExperience@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getExperience
	push	eax
	mov	ecx, edi
	call	?changeExperience@CvUnit@@QAEXHH_N00@Z	; CvUnit::changeExperience
$LN1@ResolveRan@2:

; 1183 : 		}
; 1184 : 
; 1185 : #ifndef AUI_UNIT_TEST_PROMOTION_READY_MOVED
; 1186 : 		pkAttacker->testPromotionReady();

	mov	ecx, edi
	call	?testPromotionReady@CvUnit@@QAEXXZ	; CvUnit::testPromotionReady

; 1187 : #endif
; 1188 : #endif
; 1189 : 
; 1190 : 		pkAttacker->setCombatUnit(NULL);

	push	0
	push	0
	mov	ecx, edi
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 1191 : 		pkAttacker->ClearMissionQueue(GetPostCombatDelay());

	call	?quickCombat@CvPreGame@@YA_NXZ		; CvPreGame::quickCombat
	movzx	edx, al
	neg	edx
	sbb	edx, edx
	and	edx, 109				; 0000006dH
	inc	edx
	push	edx
	mov	ecx, edi
	call	?ClearMissionQueue@CvUnit@@QAEXH@Z	; CvUnit::ClearMissionQueue

; 1192 : 
; 1193 : 		// Report that combat is over in case we want to queue another attack
; 1194 : 		GET_PLAYER(pkAttacker->getOwner()).GetTacticalAI()->CombatResolved(pkAttacker, bTargetDied);

	mov	eax, DWORD PTR [edi+40]
	mov	ecx, DWORD PTR _bTargetDied$[esp+192]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	ecx
	push	edi
	mov	ecx, eax
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z ; CvTacticalAI::CombatResolved
$LN2@ResolveRan@2:

; 1195 : 	}
; 1196 : }

	lea	ecx, DWORD PTR _strBuffer$[esp+192]
	mov	DWORD PTR __$EHRec$[esp+200], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+192]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 176				; 000000b0H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$1:
	lea	ecx, DWORD PTR $T229024[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$2:
	lea	ecx, DWORD PTR $T229027[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$3:
	lea	ecx, DWORD PTR _strSummary$222516[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$4:
	lea	ecx, DWORD PTR $T229030[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$5:
	lea	ecx, DWORD PTR $T229033[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$7:
	lea	ecx, DWORD PTR $T229037[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z:
	mov	eax, OFFSET __ehfuncinfo$?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ENDP ; CvUnitCombat::ResolveRangedUnitVsCombat
PUBLIC	?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveCityMeleeCombat
EXTRN	?isNoCapture@CvUnit@@QBE_NXZ:PROC		; CvUnit::isNoCapture
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
EXTRN	?isHuman@CvCity@@QBE_NXZ:PROC			; CvCity::isHuman
EXTRN	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ:PROC	; CvCity::GetPlayer
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$9
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
xdata$x	ENDS
;	COMDAT ?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
_TEXT	SEGMENT
_iAttackerDamageInflicted$ = -100			; size = 4
$T229376 = -96						; size = 4
_iDefenderDamageInflicted$ = -96			; size = 4
_bCityConquered$ = -92					; size = 1
$T229389 = -88						; size = 4
$T229382 = -88						; size = 4
_iNumGoldStolen$222623 = -88				; size = 4
_iActivePlayerID$ = -88					; size = 4
$T229375 = -84						; size = 4
$T229373 = -84						; size = 4
_pkPlot$ = -84						; size = 4
$T229395 = -80						; size = 4
$T229392 = -80						; size = 4
$T229388 = -80						; size = 4
$T229385 = -80						; size = 4
$T229381 = -80						; size = 4
$T229377 = -80						; size = 4
$T229394 = -76						; size = 4
$T229391 = -76						; size = 4
$T229387 = -76						; size = 4
$T229384 = -76						; size = 4
$T229380 = -76						; size = 4
$T229378 = -76						; size = 4
_pAttacker$222640 = -72					; size = 4
_strBuffer$ = -68					; size = 28
$T229396 = -40						; size = 28
$T229393 = -40						; size = 28
$T229390 = -40						; size = 28
$T229386 = -40						; size = 28
$T229383 = -40						; size = 28
$T229379 = -40						; size = 28
$T229374 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_kCombatInfo$ = 8					; size = 4
_uiParentEventID$ = 12					; size = 4
?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z PROC ; CvUnitCombat::ResolveCityMeleeCombat, COMDAT

; 1362 : {

	push	-1
	push	__ehhandler$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	ebp

; 1363 : 	CvUnit* pkAttacker = kCombatInfo.getUnit(BATTLE_UNIT_ATTACKER);

	mov	ebp, DWORD PTR _kCombatInfo$[esp+104]
	push	esi
	push	edi
	push	0
	mov	ecx, ebp
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit

; 1364 : 	CvCity* pkDefender = kCombatInfo.getCity(BATTLE_UNIT_DEFENDER);

	push	1
	mov	ecx, ebp
	mov	edi, eax
	call	?getCity@CvCombatInfo@@QBEPAVCvCity@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getCity

; 1365 : 
; 1366 : 	CvAssert_Debug(pkAttacker && pkDefender);
; 1367 : 
; 1368 : 	CvPlot* pkPlot = kCombatInfo.getPlot();

	mov	ecx, ebp
	mov	esi, eax
	call	?getPlot@CvCombatInfo@@QBEPAVCvPlot@@XZ	; CvCombatInfo::getPlot
	mov	DWORD PTR _pkPlot$[esp+116], eax

; 1369 : 	if(!pkPlot && pkDefender)

	test	eax, eax
	jne	SHORT $LN25@ResolveCit
	test	esi, esi
	je	SHORT $LN25@ResolveCit

; 1370 : 		pkPlot = pkDefender->plot();

	mov	ecx, esi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pkPlot$[esp+116], eax
$LN25@ResolveCit:

; 1371 : 
; 1372 : 	CvAssert_Debug(pkPlot);
; 1373 : 
; 1374 : 	int iAttackerDamageInflicted = kCombatInfo.getDamageInflicted(BATTLE_UNIT_ATTACKER);

	push	0
	mov	ecx, ebp
	call	?getDamageInflicted@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getDamageInflicted
	mov	ebx, eax

; 1375 : 	int iDefenderDamageInflicted = kCombatInfo.getDamageInflicted(BATTLE_UNIT_DEFENDER);

	push	1
	mov	ecx, ebp
	mov	DWORD PTR _iAttackerDamageInflicted$[esp+120], ebx
	call	?getDamageInflicted@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getDamageInflicted
	mov	DWORD PTR _iDefenderDamageInflicted$[esp+116], eax

; 1376 : 
; 1377 : 	if(pkAttacker && pkDefender)

	test	edi, edi
	je	SHORT $LN247@ResolveCit
	test	esi, esi
	je	SHORT $LN247@ResolveCit

; 1378 : 	{
; 1379 : 		pkAttacker->changeDamage(iDefenderDamageInflicted, pkDefender->getOwner());

	mov	ecx, DWORD PTR [esi+84]
	push	0
	push	ecx
	mov	DWORD PTR [esp], 0
	push	ecx
	push	eax
	mov	ecx, edi
	call	?changeDamage@CvUnit@@QAEHHW4PlayerTypes@@MPBVCvString@@@Z ; CvUnit::changeDamage

; 1380 : 		pkDefender->changeDamage(iAttackerDamageInflicted);

	push	ebx
	mov	ecx, esi
	call	?changeDamage@CvCity@@QAEXH@Z		; CvCity::changeDamage

; 1381 : 
; 1382 : 		pkAttacker->changeExperience(kCombatInfo.getExperience(BATTLE_UNIT_ATTACKER),
; 1383 : 		                             kCombatInfo.getMaxExperienceAllowed(BATTLE_UNIT_ATTACKER),
; 1384 : 		                             true,
; 1385 : 		                             false,
; 1386 : 		                             kCombatInfo.getUpdateGlobal(BATTLE_UNIT_ATTACKER));

	push	0
	mov	ecx, ebp
	call	?getUpdateGlobal@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getUpdateGlobal
	movzx	eax, al
	push	eax
	push	0
	push	1
	push	0
	mov	ecx, ebp
	call	?getMaxExperienceAllowed@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getMaxExperienceAllowed
	push	eax
	push	0
	mov	ecx, ebp
	call	?getExperience@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getExperience
	push	eax
	mov	ecx, edi
	call	?changeExperience@CvUnit@@QAEXHH_N00@Z	; CvUnit::changeExperience
$LN247@ResolveCit:

; 1387 : 	}
; 1388 : 
; 1389 : 	bool bCityConquered = false;

	mov	BYTE PTR _bCityConquered$[esp+116], 0

; 1390 : 
; 1391 : 	if(pkDefender)

	test	esi, esi
	je	SHORT $LN23@ResolveCit

; 1392 : 		pkDefender->clearCombat();

	mov	ecx, esi
	call	?clearCombat@CvCity@@QAEXXZ		; CvCity::clearCombat

; 1393 : 	else

	jmp	SHORT $LN22@ResolveCit
$LN23@ResolveCit:

; 1394 : 		bCityConquered = true;

	mov	BYTE PTR _bCityConquered$[esp+116], 1
$LN22@ResolveCit:

; 1395 : 
; 1396 : 	if(pkAttacker)

	test	edi, edi
	je	SHORT $LN245@ResolveCit

; 1397 : 	{
; 1398 : 		pkAttacker->setCombatUnit(NULL);

	push	0
	push	0
	mov	ecx, edi
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 1399 : 		pkAttacker->ClearMissionQueue(GetPostCombatDelay());

	call	?quickCombat@CvPreGame@@YA_NXZ		; CvPreGame::quickCombat
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	and	ecx, 109				; 0000006dH
	inc	ecx
	push	ecx
	mov	ecx, edi
	call	?ClearMissionQueue@CvUnit@@QAEXH@Z	; CvUnit::ClearMissionQueue

; 1400 : 
; 1401 : 		if(pkAttacker->isSuicide())

	mov	ecx, edi
	call	?isSuicide@CvUnit@@QBE_NXZ		; CvUnit::isSuicide
	test	al, al
	je	SHORT $LN245@ResolveCit

; 1402 : 		{
; 1403 : 			pkAttacker->setCombatUnit(NULL);	// Must clear this if doing a delayed kill, should this be part of the kill method?

	push	0
	push	0
	mov	ecx, edi
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 1404 : 			pkAttacker->kill(true);

	push	-1
	push	1
	mov	ecx, edi
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill
$LN245@ResolveCit:

; 1405 : 		}
; 1406 : 	}
; 1407 : 
; 1408 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[esp+116]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1409 : 	int iActivePlayerID = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR __$EHRec$[esp+124], 0
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	ebx, eax
	mov	DWORD PTR _iActivePlayerID$[esp+116], ebx

; 1410 : 
; 1411 : 	// Barbarians don't capture Cities
; 1412 : 	if(pkAttacker && pkDefender)

	test	edi, edi
	je	$LN2@ResolveCit
	test	esi, esi
	je	$LN246@ResolveCit

; 1413 : 	{
; 1414 : 		if(pkAttacker->isBarbarian() && (pkDefender->getDamage() >= pkDefender->GetMaxHitPoints()))

	mov	ecx, edi
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	test	al, al
	je	$LN18@ResolveCit
	mov	ecx, esi
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	mov	ecx, esi
	mov	ebp, eax
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	cmp	ebp, eax
	jl	$LN18@ResolveCit

; 1415 : 		{
; 1416 : 			// 1 HP left
; 1417 : 			pkDefender->setDamage(pkDefender->GetMaxHitPoints() - 1);

	push	0
	mov	ecx, esi
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	dec	eax
	push	eax
	mov	ecx, esi
	call	?setDamage@CvCity@@QAEXH_N@Z		; CvCity::setDamage

; 1418 : 
; 1419 : 			int iNumGoldStolen = GC.getBARBARIAN_CITY_GOLD_RANSOM();	// 200
; 1420 : 
; 1421 : 			if(iNumGoldStolen > GET_PLAYER(pkDefender->getOwner()).GetTreasury()->GetGold())

	mov	eax, DWORD PTR [esi+84]
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7072
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _iNumGoldStolen$222623[esp+116], ebp
	mov	ecx, eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	cmp	ebp, eax
	jle	SHORT $LN17@ResolveCit

; 1422 : 			{
; 1423 : 				iNumGoldStolen = GET_PLAYER(pkDefender->getOwner()).GetTreasury()->GetGold();

	mov	eax, DWORD PTR [esi+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	mov	ebp, eax
	mov	DWORD PTR _iNumGoldStolen$222623[esp+116], ebp
$LN17@ResolveCit:

; 1424 : 			}
; 1425 : 
; 1426 : 			// City is ransomed for Gold
; 1427 : 			GET_PLAYER(pkDefender->getOwner()).GetTreasury()->ChangeGold(-iNumGoldStolen);

	mov	eax, DWORD PTR [esi+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	neg	ebp
	push	ebp
	mov	ecx, eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 1428 : 
; 1429 : 			if(pkDefender->getOwner() == iActivePlayerID)

	cmp	DWORD PTR [esi+84], ebx
	jne	$LN248@ResolveCit

; 1430 : 			{
; 1431 : 				strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_CITY_RANSOMED_BY_BARBARIANS", pkDefender->getNameKey(), iNumGoldStolen);

	mov	ecx, esi
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	lea	edx, DWORD PTR _iNumGoldStolen$222623[esp+116]
	push	edx
	mov	DWORD PTR $T229373[esp+120], eax
	lea	eax, DWORD PTR $T229373[esp+120]
	push	eax
	lea	ecx, DWORD PTR $T229374[esp+124]
	push	OFFSET $SG222635
	push	ecx
	call	??$GetLocalizedText@PBDH@@YA?AVCvString@@PBDABQBDABH@Z ; GetLocalizedText<char const *,int>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 1
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T229374[esp+116]
	mov	BYTE PTR __$EHRec$[esp+124], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1432 : 				GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*,GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkPlot->getX(), pkPlot->getY()*/);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+116]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi+84]
	push	0
	push	0
	mov	edx, DWORD PTR [ebp]
	push	-1
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	mov	ecx, DWORD PTR _uiParentEventID$[esp+160]
	push	ecx
	mov	ecx, ebp
	call	edx
$LN248@ResolveCit:

; 1433 : 			}
; 1434 : 
; 1435 : 			if( pkDefender->GetPlayer()->GetID() == GC.getGame().getActivePlayer() && pkDefender->isHuman() && !GC.getGame().isGameMultiPlayer())

	mov	ecx, esi
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, DWORD PTR [eax+44]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	ebx, eax
	jne	SHORT $LN15@ResolveCit
	mov	ecx, esi
	call	?isHuman@CvCity@@QBE_NXZ		; CvCity::isHuman
	test	al, al
	je	SHORT $LN15@ResolveCit
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	SHORT $LN15@ResolveCit

; 1436 : 			{
; 1437 : 				gDLL->UnlockAchievement(ACHIEVEMENT_REALLY_SUCK);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+828]
	push	118					; 00000076H
	call	edx
$LN15@ResolveCit:

; 1438 : 			}
; 1439 : 
; 1440 : 			// Barb goes away after ransom
; 1441 : 			pkAttacker->kill(true, NO_PLAYER);

	push	-1
	push	1
	mov	ecx, edi
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill

; 1442 : 
; 1443 : 			// Treat this as a conquest
; 1444 : 			bCityConquered = true;

	mov	BYTE PTR _bCityConquered$[esp+116], 1
	jmp	$LN246@ResolveCit
$LN18@ResolveCit:

; 1445 : 		}
; 1446 : 		// Attacker died
; 1447 : 		else if(pkAttacker->IsDead())

	mov	ecx, edi
	call	?IsDead@CvUnit@@QBE_NXZ			; CvUnit::IsDead
	test	al, al
	je	$LN13@ResolveCit

; 1448 : 		{
; 1449 : 			auto_ptr<ICvUnit1> pAttacker = GC.WrapUnitPointer(pkAttacker);

	push	edi
	lea	eax, DWORD PTR $T229375[esp+120]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z ; CvGlobals::WrapUnitPointer
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR $T229376[esp+116], ebp
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pAttacker$222640[esp+116], ebp
	mov	eax, DWORD PTR $T229375[esp+116]
	mov	BYTE PTR __$EHRec$[esp+124], 2
	test	eax, eax
	je	SHORT $LN106@ResolveCit
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN106@ResolveCit:

; 1450 : 			gDLL->GameplayUnitDestroyedInCombat(pAttacker.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+600]
	push	ebp
	call	edx

; 1451 : 			if(pkAttacker->getOwner() == iActivePlayerID)

	cmp	DWORD PTR [edi+40], ebx
	mov	ebx, DWORD PTR _uiParentEventID$[esp+112]
	jne	$LN12@ResolveCit

; 1452 : 			{
; 1453 : 				strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_DIED_ATTACKING_CITY", pkAttacker->getNameKey(), pkDefender->getNameKey(), iAttackerDamageInflicted);

	mov	ecx, esi
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	ecx, edi
	mov	DWORD PTR $T229377[esp+116], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	DWORD PTR $T229378[esp+116], eax
	lea	eax, DWORD PTR _iAttackerDamageInflicted$[esp+116]
	push	eax
	lea	ecx, DWORD PTR $T229377[esp+120]
	push	ecx
	lea	edx, DWORD PTR $T229378[esp+124]
	push	edx
	lea	eax, DWORD PTR $T229379[esp+128]
	push	OFFSET $SG222647
	push	eax
	call	??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z ; GetLocalizedText<char const *,char const *,int>
	add	esp, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 3
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T229379[esp+116]
	mov	BYTE PTR __$EHRec$[esp+124], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1454 : 				GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkPlot->getX(), pkPlot->getY()*/);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+116]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi+40]
	push	0
	mov	edx, DWORD PTR [ebp]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	push	ebx
	mov	ecx, ebp
	call	edx
	mov	ebp, DWORD PTR $T229376[esp+116]
$LN12@ResolveCit:

; 1455 : 			}
; 1456 : 			if(pkDefender->getOwner() == iActivePlayerID)

	mov	eax, DWORD PTR _iActivePlayerID$[esp+116]
	cmp	DWORD PTR [esi+84], eax
	jne	$LN11@ResolveCit

; 1457 : 			{
; 1458 : 				strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_KILLED_ENEMY_UNIT_CITY", pkDefender->getNameKey(), iAttackerDamageInflicted, pkAttacker->getNameKey(), pkAttacker->getVisualCivAdjective(pkDefender->getTeam()));

	mov	ecx, esi
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	ecx, edi
	call	?getVisualCivAdjective@CvUnit@@QBEPBDW4TeamTypes@@@Z ; CvUnit::getVisualCivAdjective
	mov	ecx, edi
	mov	DWORD PTR $T229380[esp+116], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T229381[esp+116], eax
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	lea	ecx, DWORD PTR $T229380[esp+116]
	push	ecx
	lea	edx, DWORD PTR $T229381[esp+120]
	push	edx
	mov	DWORD PTR $T229382[esp+124], eax
	lea	eax, DWORD PTR _iAttackerDamageInflicted$[esp+124]
	push	eax
	lea	ecx, DWORD PTR $T229382[esp+128]
	push	ecx
	lea	edx, DWORD PTR $T229383[esp+132]
	push	OFFSET $SG222664
	push	edx
	call	??$GetLocalizedText@PBDHPBDPBD@@YA?AVCvString@@PBDABQBDABH11@Z ; GetLocalizedText<char const *,int,char const *,char const *>
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 4
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T229383[esp+116]
	mov	BYTE PTR __$EHRec$[esp+124], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1459 : 				GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkPlot->getX(), pkPlot->getY()*/);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+116]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	esi, DWORD PTR [esi+84]
	push	0
	mov	edx, DWORD PTR [ebp]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	esi
	push	ebx
	mov	ecx, ebp
	call	edx
	mov	ebp, DWORD PTR $T229376[esp+116]
$LN11@ResolveCit:

; 1460 : 			}
; 1461 : 		}

	mov	BYTE PTR __$EHRec$[esp+124], 0
	test	ebp, ebp
	je	$LN246@ResolveCit
	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ebp
	call	ecx
	jmp	$LN246@ResolveCit
$LN13@ResolveCit:

; 1462 : 		// City conquest
; 1463 : 		else if(pkDefender->getDamage() >= pkDefender->GetMaxHitPoints())

	mov	ecx, esi
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	mov	ecx, esi
	mov	ebp, eax
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	cmp	ebp, eax
	jl	$LN9@ResolveCit

; 1464 : 		{
; 1465 : 			if(!pkAttacker->isNoCapture())

	mov	ecx, edi
	call	?isNoCapture@CvUnit@@QBE_NXZ		; CvUnit::isNoCapture
	test	al, al
	jne	$LN246@ResolveCit

; 1466 : 			{
; 1467 : 				if(pkAttacker->getOwner() == iActivePlayerID)

	cmp	DWORD PTR [edi+40], ebx
	mov	ebx, DWORD PTR _uiParentEventID$[esp+112]
	jne	$LN7@ResolveCit

; 1468 : 				{
; 1469 : 					strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_CAPTURED_ENEMY_CITY", pkAttacker->getNameKey(), iDefenderDamageInflicted, pkDefender->getNameKey());

	mov	ecx, esi
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	ecx, edi
	mov	DWORD PTR $T229384[esp+116], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	lea	edx, DWORD PTR $T229384[esp+116]
	push	edx
	mov	DWORD PTR $T229385[esp+120], eax
	lea	eax, DWORD PTR _iDefenderDamageInflicted$[esp+120]
	push	eax
	lea	ecx, DWORD PTR $T229385[esp+124]
	push	ecx
	lea	edx, DWORD PTR $T229386[esp+128]
	push	OFFSET $SG222672
	push	edx
	call	??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z ; GetLocalizedText<char const *,int,char const *>
	add	esp, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 5
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T229386[esp+116]
	mov	BYTE PTR __$EHRec$[esp+124], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1470 : 					GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkPlot->getX(), pkPlot->getY()*/);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+116]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi+40]
	push	0
	mov	edx, DWORD PTR [ebp]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	push	ebx
	mov	ecx, ebp
	call	edx
$LN7@ResolveCit:

; 1471 : 				}
; 1472 : 				if(pkDefender->getOwner() == iActivePlayerID)

	mov	eax, DWORD PTR _iActivePlayerID$[esp+116]
	cmp	DWORD PTR [esi+84], eax
	jne	$LN6@ResolveCit

; 1473 : 				{
; 1474 : 					strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_CITY_WAS_CAPTURED", pkDefender->getNameKey(), pkAttacker->getNameKey(), pkAttacker->getVisualCivAdjective(pkDefender->getTeam()), iDefenderDamageInflicted);

	mov	ecx, esi
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	ecx, edi
	call	?getVisualCivAdjective@CvUnit@@QBEPBDW4TeamTypes@@@Z ; CvUnit::getVisualCivAdjective
	mov	ecx, edi
	mov	DWORD PTR $T229387[esp+116], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T229388[esp+116], eax
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	lea	ecx, DWORD PTR _iDefenderDamageInflicted$[esp+116]
	push	ecx
	lea	edx, DWORD PTR $T229387[esp+120]
	push	edx
	mov	DWORD PTR $T229389[esp+124], eax
	lea	eax, DWORD PTR $T229388[esp+124]
	push	eax
	lea	ecx, DWORD PTR $T229389[esp+128]
	push	ecx
	lea	edx, DWORD PTR $T229390[esp+132]
	push	OFFSET $SG222678
	push	edx
	call	??$GetLocalizedText@PBDPBDPBDH@@YA?AVCvString@@PBDABQBD11ABH@Z ; GetLocalizedText<char const *,char const *,char const *,int>
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 6
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T229390[esp+116]
	mov	BYTE PTR __$EHRec$[esp+124], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1475 : 					GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*,GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkPlot->getX(), pkPlot->getY()*/);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+116]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	esi, DWORD PTR [esi+84]
	push	0
	mov	edx, DWORD PTR [ebp]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	esi
	push	ebx
	mov	ecx, ebp
	call	edx
$LN6@ResolveCit:

; 1476 : 				}
; 1477 : 
; 1478 : 				pkAttacker->UnitMove(pkPlot, true, pkAttacker);

	mov	eax, DWORD PTR _pkPlot$[esp+116]
	push	0
	push	edi
	push	1
	push	eax
	mov	ecx, edi
	call	?UnitMove@CvUnit@@QAE_NPAVCvPlot@@_NPAV1@1@Z ; CvUnit::UnitMove

; 1479 : 
; 1480 : 				bCityConquered = true;

	mov	BYTE PTR _bCityConquered$[esp+116], 1

; 1481 : 			}
; 1482 : 		}
; 1483 : 		// Neither side lost
; 1484 : 		else

	jmp	$LN246@ResolveCit
$LN9@ResolveCit:

; 1485 : 		{
; 1486 : 			if(pkAttacker->getOwner() == iActivePlayerID)

	cmp	DWORD PTR [edi+40], ebx
	mov	ebx, DWORD PTR _uiParentEventID$[esp+112]
	jne	$LN4@ResolveCit

; 1487 : 			{
; 1488 : 				strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_WITHDRAW_CITY", pkAttacker->getNameKey(), iDefenderDamageInflicted, pkDefender->getNameKey(), iAttackerDamageInflicted);

	mov	ecx, esi
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	ecx, edi
	mov	DWORD PTR $T229391[esp+116], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	lea	ecx, DWORD PTR _iAttackerDamageInflicted$[esp+116]
	push	ecx
	lea	edx, DWORD PTR $T229391[esp+120]
	push	edx
	mov	DWORD PTR $T229392[esp+124], eax
	lea	eax, DWORD PTR _iDefenderDamageInflicted$[esp+124]
	push	eax
	lea	ecx, DWORD PTR $T229392[esp+128]
	push	ecx
	lea	edx, DWORD PTR $T229393[esp+132]
	push	OFFSET $SG222684
	push	edx
	call	??$GetLocalizedText@PBDHPBDH@@YA?AVCvString@@PBDABQBDABH12@Z ; GetLocalizedText<char const *,int,char const *,int>
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 7
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T229393[esp+116]
	mov	BYTE PTR __$EHRec$[esp+124], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1489 : 				GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkPlot->getX(), pkPlot->getY()*/);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+116]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi+40]
	push	0
	mov	edx, DWORD PTR [ebp]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	push	ebx
	mov	ecx, ebp
	call	edx
$LN4@ResolveCit:

; 1490 : 			}
; 1491 : 			if(pkDefender->getOwner() == iActivePlayerID)

	mov	eax, DWORD PTR _iActivePlayerID$[esp+116]
	cmp	DWORD PTR [esi+84], eax
	jne	$LN3@ResolveCit

; 1492 : 			{
; 1493 : 				strBuffer = GetLocalizedText("TXT_KEY_MISC_ENEMY_UNIT_WITHDRAW_CITY", pkAttacker->getNameKey(), iDefenderDamageInflicted, pkDefender->getNameKey(), iAttackerDamageInflicted);

	mov	ecx, esi
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	ecx, edi
	mov	DWORD PTR $T229394[esp+116], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	lea	ecx, DWORD PTR _iAttackerDamageInflicted$[esp+116]
	push	ecx
	lea	edx, DWORD PTR $T229394[esp+120]
	push	edx
	mov	DWORD PTR $T229395[esp+124], eax
	lea	eax, DWORD PTR _iDefenderDamageInflicted$[esp+124]
	push	eax
	lea	ecx, DWORD PTR $T229395[esp+128]
	push	ecx
	lea	edx, DWORD PTR $T229396[esp+132]
	push	OFFSET $SG222689
	push	edx
	call	??$GetLocalizedText@PBDHPBDH@@YA?AVCvString@@PBDABQBDABH12@Z ; GetLocalizedText<char const *,int,char const *,int>
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 8
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T229396[esp+116]
	mov	BYTE PTR __$EHRec$[esp+124], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1494 : 				GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkPlot->getX(), pkPlot->getY()*/);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+116]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi+84]
	push	0
	mov	edx, DWORD PTR [ebp]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	push	ebx
	mov	ecx, ebp
	call	edx
$LN3@ResolveCit:

; 1495 : 			}
; 1496 : 			pkAttacker->changeMoves(-GC.getMOVE_DENOMINATOR());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	neg	eax
	push	eax
	mov	ecx, edi
	call	?changeMoves@CvUnit@@QAEXH@Z		; CvUnit::changeMoves

; 1497 : 
; 1498 : 			ApplyPostCityCombatEffects(pkAttacker, pkDefender, iAttackerDamageInflicted);

	mov	ecx, DWORD PTR _iAttackerDamageInflicted$[esp+116]
	push	ecx
	push	esi
	push	edi
	call	?ApplyPostCityCombatEffects@CvUnitCombat@@KAXPAVCvUnit@@PAVCvCity@@H@Z ; CvUnitCombat::ApplyPostCityCombatEffects
	add	esp, 12					; 0000000cH
$LN246@ResolveCit:

; 1499 : 		}
; 1500 : 	}
; 1501 : 
; 1502 : 	if(pkAttacker)
; 1503 : 	{
; 1504 : 		pkAttacker->PublishQueuedVisualizationMoves();

	mov	ecx, edi
	call	?PublishQueuedVisualizationMoves@CvUnit@@IAEXXZ ; CvUnit::PublishQueuedVisualizationMoves

; 1505 : 
; 1506 : #ifdef NQ_UNIT_TURN_ENDS_ON_FINAL_ATTACK
; 1507 : 		if(!pkAttacker->canMoveAfterAttacking() && pkAttacker->isOutOfAttacks())

	mov	ecx, edi
	call	?canMoveAfterAttacking@CvUnit@@QBE_NXZ	; CvUnit::canMoveAfterAttacking
	test	al, al
	jne	SHORT $LN1@ResolveCit
	mov	ecx, edi
	call	?isOutOfAttacks@CvUnit@@QBE_NXZ		; CvUnit::isOutOfAttacks
	test	al, al
	je	SHORT $LN1@ResolveCit

; 1508 : #else
; 1509 : 		if(!pkAttacker->canMoveAfterAttacking())
; 1510 : #endif
; 1511 : 		{
; 1512 : 			pkAttacker->finishMoves();

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 1513 : 			GC.GetEngineUserInterface()->changeCycleSelectionCounter(1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+224]
	push	1
	call	eax
$LN1@ResolveCit:

; 1514 : 		}
; 1515 : 
; 1516 : 		// Report that combat is over in case we want to queue another attack
; 1517 : 		GET_PLAYER(pkAttacker->getOwner()).GetTacticalAI()->CombatResolved(pkAttacker, bCityConquered);

	mov	eax, DWORD PTR [edi+40]
	mov	ecx, DWORD PTR _bCityConquered$[esp+116]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	ecx
	push	edi
	mov	ecx, eax
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z ; CvTacticalAI::CombatResolved
$LN2@ResolveCit:

; 1518 : 	}
; 1519 : }

	lea	ecx, DWORD PTR _strBuffer$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+116]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$1:
	lea	ecx, DWORD PTR $T229374[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$3:
	lea	ecx, DWORD PTR _pAttacker$222640[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__unwindfunclet$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$4:
	lea	ecx, DWORD PTR $T229379[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$5:
	lea	ecx, DWORD PTR $T229383[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$6:
	lea	ecx, DWORD PTR $T229386[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$7:
	lea	ecx, DWORD PTR $T229390[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$8:
	lea	ecx, DWORD PTR $T229393[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$9:
	lea	ecx, DWORD PTR $T229396[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z:
	mov	eax, OFFSET __ehfuncinfo$?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ENDP ; CvUnitCombat::ResolveCityMeleeCombat
PUBLIC	?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveAirUnitVsCombat
EXTRN	?setMadeInterception@CvUnit@@QAEX_N@Z:PROC	; CvUnit::setMadeInterception
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$11
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$13
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$14
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
xdata$x	ENDS
;	COMDAT ?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
_TEXT	SEGMENT
$T230227 = -188						; size = 4
$T229886 = -188						; size = 4
$T229883 = -188						; size = 4
$T229879 = -188						; size = 4
$T229874 = -188						; size = 4
$T229871 = -188						; size = 4
$T229868 = -188						; size = 4
$T229865 = -188						; size = 4
$T229859 = -188						; size = 4
$T229854 = -188						; size = 4
$T229852 = -188						; size = 4
$T230218 = -184						; size = 4
$T229885 = -184						; size = 4
$T229882 = -184						; size = 4
$T229878 = -184						; size = 4
$T229873 = -184						; size = 4
$T229870 = -184						; size = 4
$T229867 = -184						; size = 4
$T229864 = -184						; size = 4
$T229850 = -184						; size = 4
$T229862 = -180						; size = 4
$T229856 = -180						; size = 4
$T229851 = -180						; size = 4
_iDefenderDamageInflicted$ = -180			; size = 4
$T230240 = -176						; size = 4
$T229876 = -176						; size = 4
$T229860 = -176						; size = 4
$T229855 = -176						; size = 4
_iInterceptionDamage$ = -176				; size = 4
$T229861 = -172						; size = 4
$T229857 = -172						; size = 4
_pInterceptor$ = -172					; size = 4
_iActivePlayerID$ = -168				; size = 4
$T230236 = -164						; size = 4
$T229928 = -164						; size = 4
$T229875 = -164						; size = 4
$T229849 = -164						; size = 4
_iAttackerDamageInflicted$ = -160			; size = 4
_bTargetDied$ = -156					; size = 1
_strBuffer$ = -152					; size = 28
$T229887 = -124						; size = 28
$T229884 = -124						; size = 28
$T229880 = -124						; size = 28
$T229877 = -124						; size = 28
$T229872 = -124						; size = 28
$T229869 = -124						; size = 28
$T229866 = -124						; size = 28
$T229863 = -124						; size = 28
$T229858 = -124						; size = 28
$T229853 = -124						; size = 28
$T229881 = -96						; size = 4
_pAttacker$222762 = -96					; size = 4
_strSummary$222812 = -92				; size = 80
__$EHRec$ = -12						; size = 12
_kCombatInfo$ = 8					; size = 4
_uiParentEventID$ = 12					; size = 4
?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z PROC ; CvUnitCombat::ResolveAirUnitVsCombat, COMDAT

; 1713 : {

	push	-1
	push	__ehhandler$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 176				; 000000b0H
	push	ebx

; 1714 : 	bool bTargetDied = false;
; 1715 : 	int iAttackerDamageInflicted = kCombatInfo.getDamageInflicted(BATTLE_UNIT_ATTACKER);

	mov	ebx, DWORD PTR _kCombatInfo$[esp+188]
	push	ebp
	push	esi
	push	edi
	push	0
	mov	ecx, ebx
	mov	BYTE PTR _bTargetDied$[esp+208], 0
	call	?getDamageInflicted@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getDamageInflicted

; 1716 : 	int iDefenderDamageInflicted = kCombatInfo.getDamageInflicted(BATTLE_UNIT_DEFENDER);

	push	1
	mov	ecx, ebx
	mov	DWORD PTR _iAttackerDamageInflicted$[esp+208], eax
	call	?getDamageInflicted@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getDamageInflicted

; 1717 : 
; 1718 : 	CvUnit* pkAttacker = kCombatInfo.getUnit(BATTLE_UNIT_ATTACKER);

	push	0
	mov	ecx, ebx
	mov	DWORD PTR _iDefenderDamageInflicted$[esp+208], eax
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit

; 1719 : 
; 1720 : 	// If there's no valid attacker, then get out of here
; 1721 : 	CvAssert_Debug(pkAttacker);
; 1722 : 
; 1723 : 	// Interception?
; 1724 : 	int iInterceptionDamage = kCombatInfo.getDamageInflicted(BATTLE_UNIT_INTERCEPTOR);

	push	2
	mov	ecx, ebx
	mov	esi, eax
	call	?getDamageInflicted@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getDamageInflicted
	mov	DWORD PTR _iInterceptionDamage$[esp+204], eax

; 1725 : 	if(iInterceptionDamage > 0)

	test	eax, eax
	jle	SHORT $LN37@ResolveAir

; 1726 : 		iDefenderDamageInflicted += iInterceptionDamage;

	add	DWORD PTR _iDefenderDamageInflicted$[esp+204], eax
$LN37@ResolveAir:

; 1727 : 
; 1728 : 	CvUnit* pInterceptor = kCombatInfo.getUnit(BATTLE_UNIT_INTERCEPTOR);

	push	2
	mov	ecx, ebx
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit
	mov	edi, eax
	mov	DWORD PTR _pInterceptor$[esp+204], edi

; 1729 : 	CvAssert_Debug(pInterceptor);
; 1730 : 	if(pInterceptor)

	test	edi, edi
	je	SHORT $LN36@ResolveAir

; 1731 : 	{
; 1732 : 		pInterceptor->setMadeInterception(true);

	push	1
	mov	ecx, edi
	call	?setMadeInterception@CvUnit@@QAEX_N@Z	; CvUnit::setMadeInterception

; 1733 : 		pInterceptor->setCombatUnit(NULL);

	push	0
	push	0
	mov	ecx, edi
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 1734 : 		pInterceptor->changeExperience(
; 1735 : 			kCombatInfo.getExperience(BATTLE_UNIT_INTERCEPTOR),
; 1736 : 			kCombatInfo.getMaxExperienceAllowed(BATTLE_UNIT_INTERCEPTOR),
; 1737 : 			true,
; 1738 : 			kCombatInfo.getInBorders(BATTLE_UNIT_INTERCEPTOR),
; 1739 : 			kCombatInfo.getUpdateGlobal(BATTLE_UNIT_INTERCEPTOR));

	push	2
	mov	ecx, ebx
	call	?getUpdateGlobal@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getUpdateGlobal
	movzx	eax, al
	push	eax
	push	2
	mov	ecx, ebx
	call	?getInBorders@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getInBorders
	movzx	ecx, al
	push	ecx
	push	1
	push	2
	mov	ecx, ebx
	call	?getMaxExperienceAllowed@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getMaxExperienceAllowed
	push	eax
	push	2
	mov	ecx, ebx
	call	?getExperience@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getExperience
	push	eax
	mov	ecx, edi
	call	?changeExperience@CvUnit@@QAEXHH_N00@Z	; CvUnit::changeExperience
$LN36@ResolveAir:

; 1740 : 	}
; 1741 : 
; 1742 : 	CvPlot* pkTargetPlot = kCombatInfo.getPlot();

	mov	ecx, ebx
	call	?getPlot@CvCombatInfo@@QBEPAVCvPlot@@XZ	; CvCombatInfo::getPlot

; 1743 : 	CvAssert_Debug(pkTargetPlot);
; 1744 : 
; 1745 : 	ICvUserInterface2* pkDLLInterface = GC.GetEngineUserInterface();
; 1746 : 	int iActivePlayerID = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edi, eax
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer

; 1747 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[esp+204]
	mov	DWORD PTR _iActivePlayerID$[esp+204], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[esp+212], 0

; 1748 : 
; 1749 : 	if(pkTargetPlot)

	test	edi, edi
	je	$LN35@ResolveAir

; 1750 : 	{
; 1751 : 		if(!pkTargetPlot->isCity())

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	jl	SHORT $LN326@ResolveAir
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN326@ResolveAir
	mov	edx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	$LN34@ResolveAir
$LN326@ResolveAir:

; 1752 : 		{
; 1753 : 			// Target was a Unit
; 1754 : 			CvUnit* pkDefender = kCombatInfo.getUnit(BATTLE_UNIT_DEFENDER);

	push	1
	mov	ecx, ebx
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit
	mov	edi, eax

; 1755 : 			CvAssert_Debug(pkDefender != NULL);
; 1756 : 
; 1757 : 			if(pkDefender)

	test	edi, edi
	je	$LN35@ResolveAir

; 1758 : 			{
; 1759 : 				if(pkAttacker)

	test	esi, esi
	je	$LN16@ResolveAir

; 1760 : 				{
; 1761 : 					//One Hit
; 1762 : 					if(pkDefender->GetCurrHitPoints() == GC.getMAX_HIT_POINTS() && pkAttacker->isHuman() && !GC.getGame().isGameMultiPlayer())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, edi
	mov	DWORD PTR $T229928[esp+204], eax
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	cmp	eax, DWORD PTR $T229928[esp+204]
	jne	SHORT $LN31@ResolveAir
	mov	ecx, esi
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	je	SHORT $LN31@ResolveAir
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	SHORT $LN31@ResolveAir

; 1763 : 					{
; 1764 : 						gDLL->UnlockAchievement(ACHIEVEMENT_ONEHITKILL);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	60					; 0000003cH
	call	eax
$LN31@ResolveAir:

; 1765 : 					}
; 1766 : 
; 1767 : 					pkAttacker->changeDamage(iDefenderDamageInflicted, pkDefender->getOwner());

	mov	eax, DWORD PTR [edi+40]
	push	0
	push	ecx
	mov	ecx, DWORD PTR _iDefenderDamageInflicted$[esp+212]
	mov	DWORD PTR [esp], 0
	push	eax
	push	ecx
	mov	ecx, esi
	call	?changeDamage@CvUnit@@QAEHHW4PlayerTypes@@MPBVCvString@@@Z ; CvUnit::changeDamage

; 1768 : 					pkDefender->changeDamage(iAttackerDamageInflicted, pkAttacker->getOwner());

	mov	eax, DWORD PTR [esi+40]
	mov	edx, DWORD PTR _iAttackerDamageInflicted$[esp+204]
	push	0
	push	ecx
	mov	DWORD PTR [esp], 0
	push	eax
	push	edx
	mov	ecx, edi
	call	?changeDamage@CvUnit@@QAEHHW4PlayerTypes@@MPBVCvString@@@Z ; CvUnit::changeDamage

; 1769 : 
; 1770 : 					// Update experience
; 1771 : 					pkDefender->changeExperience(
; 1772 : 					    kCombatInfo.getExperience(BATTLE_UNIT_DEFENDER),
; 1773 : 					    kCombatInfo.getMaxExperienceAllowed(BATTLE_UNIT_DEFENDER),
; 1774 : 					    true,
; 1775 : 					    kCombatInfo.getInBorders(BATTLE_UNIT_DEFENDER),
; 1776 : 					    kCombatInfo.getUpdateGlobal(BATTLE_UNIT_DEFENDER));

	push	1
	mov	ecx, ebx
	call	?getUpdateGlobal@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getUpdateGlobal
	movzx	eax, al
	push	eax
	push	1
	mov	ecx, ebx
	call	?getInBorders@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getInBorders
	movzx	ecx, al
	push	ecx
	push	1
	push	1
	mov	ecx, ebx
	call	?getMaxExperienceAllowed@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getMaxExperienceAllowed
	push	eax
	push	1
	mov	ecx, ebx
	call	?getExperience@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getExperience
	push	eax
	mov	ecx, edi
	call	?changeExperience@CvUnit@@QAEXHH_N00@Z	; CvUnit::changeExperience

; 1777 : 
; 1778 : 					// Attacker died
; 1779 : 					if(pkAttacker->IsDead())

	mov	ecx, esi
	call	?IsDead@CvUnit@@QBE_NXZ			; CvUnit::IsDead
	test	al, al
	je	$LN30@ResolveAir

; 1780 : 					{
; 1781 : 						auto_ptr<ICvUnit1> pAttacker = GC.WrapUnitPointer(pkAttacker);

	push	esi
	lea	edx, DWORD PTR $T229849[esp+208]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z ; CvGlobals::WrapUnitPointer
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR $T229850[esp+204], ebx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pAttacker$222762[esp+204], ebx
	mov	eax, DWORD PTR $T229849[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 1
	test	eax, eax
	je	SHORT $LN89@ResolveAir
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN89@ResolveAir:

; 1782 : 						gDLL->GameplayUnitDestroyedInCombat(pAttacker.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+600]
	push	ebx
	call	edx

; 1783 : 
; 1784 : 						CvPlayerAI& kDefenderOwner = GET_PLAYER(pkDefender->getOwner());

	mov	eax, DWORD PTR [edi+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 1785 : 						kDefenderOwner.GetPlayerAchievements().KilledUnitWithUnit(pkDefender, pkAttacker);

	push	esi
	push	edi
	lea	ecx, DWORD PTR [eax+63156]
	call	?KilledUnitWithUnit@CvPlayerAchievements@@QAEXPAVCvUnit@@0@Z ; CvPlayerAchievements::KilledUnitWithUnit

; 1786 : 
; 1787 : 						if(iActivePlayerID == pkAttacker->getOwner())

	mov	eax, DWORD PTR _iActivePlayerID$[esp+204]
	mov	ebx, DWORD PTR _uiParentEventID$[esp+200]
	cmp	eax, DWORD PTR [esi+40]
	jne	$LN29@ResolveAir

; 1788 : 						{
; 1789 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_DIED_ATTACKING", pkAttacker->getNameKey(), pkDefender->getNameKey(), iAttackerDamageInflicted);

	mov	ecx, edi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T229851[esp+204], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	lea	ecx, DWORD PTR _iAttackerDamageInflicted$[esp+204]
	push	ecx
	lea	edx, DWORD PTR $T229851[esp+208]
	push	edx
	mov	DWORD PTR $T229852[esp+212], eax
	lea	eax, DWORD PTR $T229852[esp+212]
	push	eax
	lea	ecx, DWORD PTR $T229853[esp+216]
	push	OFFSET $SG222770
	push	ecx
	call	??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z ; GetLocalizedText<char const *,char const *,int>
	add	esp, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+208]
	mov	BYTE PTR __$EHRec$[esp+216], 2
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T229853[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1790 : 							pkDLLInterface->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	lea	ecx, DWORD PTR _strBuffer$[esp+204]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi+40]
	push	0
	mov	edx, DWORD PTR [ebp]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	push	ebx
	mov	ecx, ebp
	call	edx
$LN29@ResolveAir:

; 1791 : 						}
; 1792 : 						if(iActivePlayerID == pkDefender->getOwner())

	mov	eax, DWORD PTR _iActivePlayerID$[esp+204]
	cmp	eax, DWORD PTR [edi+40]
	jne	$LN26@ResolveAir

; 1793 : 						{
; 1794 : 							if (iInterceptionDamage > 0 && pInterceptor)

	cmp	DWORD PTR _iInterceptionDamage$[esp+204], 0
	jle	SHORT $LN27@ResolveAir
	cmp	DWORD PTR _pInterceptor$[esp+204], 0
	je	SHORT $LN27@ResolveAir

; 1795 : 							{
; 1796 : 								strBuffer = GetLocalizedText("TXT_KEY_MISC_ENEMY_AIR_UNIT_DESTROYED", pInterceptor->getNameKey(), pkAttacker->getVisualCivAdjective(pkDefender->getTeam()), pkAttacker->getNameKey(), pkDefender->getNameKey());

	mov	ecx, edi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T229854[esp+204], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, edi
	mov	DWORD PTR $T229855[esp+204], eax
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, esi
	call	?getVisualCivAdjective@CvUnit@@QBEPBDW4TeamTypes@@@Z ; CvUnit::getVisualCivAdjective
	mov	ecx, DWORD PTR _pInterceptor$[esp+204]
	mov	DWORD PTR $T229856[esp+204], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	lea	ecx, DWORD PTR $T229854[esp+204]
	push	ecx
	lea	edx, DWORD PTR $T229855[esp+208]
	push	edx
	mov	DWORD PTR $T229857[esp+212], eax
	lea	eax, DWORD PTR $T229856[esp+212]
	push	eax
	lea	ecx, DWORD PTR $T229857[esp+216]
	push	ecx
	lea	edx, DWORD PTR $T229858[esp+220]
	push	OFFSET $SG222789
	push	edx
	call	??$GetLocalizedText@PBDPBDPBDPBD@@YA?AVCvString@@PBDABQBD111@Z ; GetLocalizedText<char const *,char const *,char const *,char const *>
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+212], 3

; 1797 : 								pkDLLInterface->AddMessage(uiParentEventID, pkDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);
; 1798 : 							}
; 1799 : 							else

	jmp	SHORT $LN340@ResolveAir
$LN27@ResolveAir:

; 1800 : 							{
; 1801 : 								strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_KILLED_ENEMY_UNIT", pkDefender->getNameKey(), iAttackerDamageInflicted, 0, pkAttacker->getNameKey(), pkAttacker->getVisualCivAdjective(pkDefender->getTeam()));

	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, esi
	call	?getVisualCivAdjective@CvUnit@@QBEPBDW4TeamTypes@@@Z ; CvUnit::getVisualCivAdjective
	mov	ecx, esi
	mov	DWORD PTR $T229859[esp+204], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, edi
	mov	DWORD PTR $T229860[esp+204], eax
	mov	DWORD PTR $T229861[esp+204], 0
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	DWORD PTR $T229862[esp+204], eax
	lea	eax, DWORD PTR $T229859[esp+204]
	push	eax
	lea	ecx, DWORD PTR $T229860[esp+208]
	push	ecx
	lea	edx, DWORD PTR $T229861[esp+212]
	push	edx
	lea	eax, DWORD PTR _iAttackerDamageInflicted$[esp+216]
	push	eax
	lea	ecx, DWORD PTR $T229862[esp+220]
	push	ecx
	lea	edx, DWORD PTR $T229863[esp+224]
	push	OFFSET $SG222796
	push	edx
	call	??$GetLocalizedText@PBDHHPBDPBD@@YA?AVCvString@@PBDABQBDABH211@Z ; GetLocalizedText<char const *,int,int,char const *,char const *>
	add	esp, 28					; 0000001cH
	mov	BYTE PTR __$EHRec$[esp+212], 4
$LN340@ResolveAir:
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+208]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T229863[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1802 : 								pkDLLInterface->AddMessage(uiParentEventID, pkDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	lea	ecx, DWORD PTR _strBuffer$[esp+204]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi+40]
	push	0
	mov	edx, DWORD PTR [ebp]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	push	ebx
	mov	ecx, ebp
	call	edx
$LN26@ResolveAir:

; 1803 : 							}
; 1804 : 						}
; 1805 : 
; 1806 : 						ApplyPostCombatTraitEffects(pkDefender, pkAttacker);

	push	esi
	push	edi
	call	?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z ; CvUnitCombat::ApplyPostCombatTraitEffects

; 1807 : 					}

	mov	eax, DWORD PTR $T229850[esp+212]
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+212], 0
	test	eax, eax
	je	SHORT $LN329@ResolveAir
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN329@ResolveAir:
	mov	ebx, DWORD PTR _kCombatInfo$[esp+200]
$LN16@ResolveAir:

; 1855 : 							}
; 1856 : 						}
; 1857 : 					}
; 1858 : 				}
; 1859 : 
; 1860 : 				//set damage but don't update entity damage visibility
; 1861 : 				//pkDefender->changeDamage(iDamage, pkAttacker->getOwner());
; 1862 : 
; 1863 : 				pkDefender->setCombatUnit(NULL);

	push	0
	push	0
	mov	ecx, edi
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 1864 : 				if(!CvUnitMission::IsHeadMission(pkDefender, CvTypes::getMISSION_WAIT_FOR()))		// If the top mission was not a 'wait for', then clear it.

	call	?getMISSION_WAIT_FOR@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_WAIT_FOR
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	ecx, edi
	mov	DWORD PTR $T229881[esp+216], esp
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?IsHeadMission@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z ; CvUnitMission::IsHeadMission
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN6@ResolveAir

; 1865 : 					pkDefender->ClearMissionQueue();

	push	1
	mov	ecx, edi
	call	?ClearMissionQueue@CvUnit@@QAEXH@Z	; CvUnit::ClearMissionQueue

; 1866 : 			}
; 1867 : 			else
; 1868 : 				bTargetDied = true;
; 1869 : 		}
; 1870 : 		else

	jmp	$LN6@ResolveAir
$LN30@ResolveAir:

; 1808 : 					// Defender died
; 1809 : 					else if(pkDefender->IsDead())

	mov	ecx, edi
	call	?IsDead@CvUnit@@QBE_NXZ			; CvUnit::IsDead
	test	al, al
	je	$LN24@ResolveAir

; 1810 : 					{
; 1811 : 						CvPlayerAI& kAttackerOwner = GET_PLAYER(pkAttacker->getOwner());

	mov	eax, DWORD PTR [esi+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 1812 : 						kAttackerOwner.GetPlayerAchievements().KilledUnitWithUnit(pkAttacker, pkDefender);

	push	edi
	push	esi
	lea	ecx, DWORD PTR [eax+63156]
	call	?KilledUnitWithUnit@CvPlayerAchievements@@QAEXPAVCvUnit@@0@Z ; CvPlayerAchievements::KilledUnitWithUnit

; 1813 : 
; 1814 : 						if(iActivePlayerID == pkAttacker->getOwner())

	mov	eax, DWORD PTR _iActivePlayerID$[esp+204]
	cmp	eax, DWORD PTR [esi+40]
	jne	$LN23@ResolveAir

; 1815 : 						{
; 1816 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_ATTACK_BY_AIR_AND_DEATH", pkAttacker->getNameKey(), pkDefender->getNameKey());

	mov	ecx, edi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T229864[esp+204], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	lea	ecx, DWORD PTR $T229864[esp+204]
	push	ecx
	lea	edx, DWORD PTR $T229865[esp+208]
	push	edx
	mov	DWORD PTR $T229865[esp+212], eax
	lea	eax, DWORD PTR $T229866[esp+212]
	push	OFFSET $SG222804
	push	eax
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+208]
	mov	BYTE PTR __$EHRec$[esp+216], 5
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T229866[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1817 : 							pkDLLInterface->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_COMBAT", MESSAGE_TYPE_INFO, pkDefender->getUnitInfo().GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	lea	ecx, DWORD PTR _strBuffer$[esp+204]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi+40]
	push	0
	push	0
	mov	edx, DWORD PTR [ebp]
	push	-1
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	mov	ecx, DWORD PTR _uiParentEventID$[esp+248]
	push	ecx
	mov	ecx, ebp
	call	edx
$LN23@ResolveAir:

; 1818 : 						}
; 1819 : 						if(iActivePlayerID == pkDefender->getOwner())

	mov	eax, DWORD PTR _iActivePlayerID$[esp+204]
	cmp	eax, DWORD PTR [edi+40]
	jne	$LN22@ResolveAir

; 1820 : 						{
; 1821 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_AIR_AND_DEATH", pkDefender->getNameKey(), pkAttacker->getNameKey());

	mov	ecx, esi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, edi
	mov	DWORD PTR $T229867[esp+204], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	lea	ecx, DWORD PTR $T229867[esp+204]
	push	ecx
	lea	edx, DWORD PTR $T229868[esp+208]
	push	edx
	mov	DWORD PTR $T229868[esp+212], eax
	lea	eax, DWORD PTR $T229869[esp+212]
	push	OFFSET $SG222809
	push	eax
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+208]
	mov	BYTE PTR __$EHRec$[esp+216], 6
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T229869[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1822 : 							pkDLLInterface->AddMessage(uiParentEventID, pkDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_COMBAT", MESSAGE_TYPE_INFO, pkDefender->getUnitInfo().GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	lea	ecx, DWORD PTR _strBuffer$[esp+204]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi+40]
	push	0
	push	0
	mov	edx, DWORD PTR [ebp]
	push	-1
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	mov	ecx, DWORD PTR _uiParentEventID$[esp+248]
	push	ecx
	mov	ecx, ebp
	call	edx
$LN22@ResolveAir:

; 1823 : 						}
; 1824 : 
; 1825 : 						CvNotifications* pNotifications = GET_PLAYER(pkDefender->getOwner()).GetNotifications();

	mov	eax, DWORD PTR [edi+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ebp, eax

; 1826 : 						if(pNotifications)

	test	ebp, ebp
	je	$LN21@ResolveAir

; 1827 : 						{
; 1828 : 							Localization::String strSummary = Localization::Lookup("TXT_KEY_UNIT_LOST");

	lea	eax, DWORD PTR _strSummary$222812[esp+204]
	push	OFFSET $SG222814
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 1829 : 							pNotifications->Add(NOTIFICATION_UNIT_DIED, strBuffer, strSummary.toUTF8(), pkDefender->getX(), pkDefender->getY(), (int) pkDefender->getUnitType(), pkDefender->getOwner());

	mov	ecx, DWORD PTR [edi+40]
	mov	edx, DWORD PTR [edi+88]
	mov	eax, DWORD PTR [edi+76]
	mov	DWORD PTR $T230218[esp+204], ecx
	lea	ecx, DWORD PTR _strBuffer$[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 7
	mov	DWORD PTR $T230227[esp+204], edx
	mov	DWORD PTR $T230236[esp+204], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR $T230218[esp+204]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T230240[esp+208], eax
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	mov	edx, DWORD PTR $T230227[esp+208]
	push	eax
	mov	eax, DWORD PTR $T230236[esp+212]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _strSummary$222812[esp+220]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	ecx, DWORD PTR $T230240[esp+220]
	push	eax
	push	ecx
	push	-16309126				; ff07247aH
	mov	ecx, ebp
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 1830 : 						}

	lea	ecx, DWORD PTR _strSummary$222812[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 0
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN21@ResolveAir:

; 1831 : 
; 1832 : 						bTargetDied = true;
; 1833 : 
; 1834 : 						ApplyPostCombatTraitEffects(pkAttacker, pkDefender);

	push	edi
	push	esi
	mov	BYTE PTR _bTargetDied$[esp+212], 1
	call	?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z ; CvUnitCombat::ApplyPostCombatTraitEffects
	add	esp, 8

; 1835 : 					}
; 1836 : 					// Nobody died
; 1837 : 					else

	jmp	$LN16@ResolveAir
$LN24@ResolveAir:

; 1838 : 					{
; 1839 : 						if(iActivePlayerID == pkAttacker->getOwner())

	mov	edx, DWORD PTR _iActivePlayerID$[esp+204]
	cmp	edx, DWORD PTR [esi+40]
	jne	$LN19@ResolveAir

; 1840 : 						{
; 1841 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_ATTACK_BY_AIR", pkAttacker->getNameKey(), pkDefender->getNameKey(), iDefenderDamageInflicted);

	mov	ecx, edi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T229870[esp+204], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	DWORD PTR $T229871[esp+204], eax
	lea	eax, DWORD PTR _iDefenderDamageInflicted$[esp+204]
	push	eax
	lea	ecx, DWORD PTR $T229870[esp+208]
	push	ecx
	lea	edx, DWORD PTR $T229871[esp+212]
	push	edx
	lea	eax, DWORD PTR $T229872[esp+216]
	push	OFFSET $SG222821
	push	eax
	call	??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z ; GetLocalizedText<char const *,char const *,int>
	add	esp, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+208]
	mov	BYTE PTR __$EHRec$[esp+216], 8
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T229872[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1842 : 							pkDLLInterface->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_COMBAT", MESSAGE_TYPE_INFO, pkDefender->getUnitInfo().GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	lea	ecx, DWORD PTR _strBuffer$[esp+204]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi+40]
	push	0
	push	0
	mov	edx, DWORD PTR [ebp]
	push	-1
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	mov	ecx, DWORD PTR _uiParentEventID$[esp+248]
	push	ecx
	mov	ecx, ebp
	call	edx
$LN19@ResolveAir:

; 1843 : 						}
; 1844 : 						if(iActivePlayerID == pkDefender->getOwner())

	mov	eax, DWORD PTR _iActivePlayerID$[esp+204]
	cmp	eax, DWORD PTR [edi+40]
	jne	$LN16@ResolveAir

; 1845 : 						{
; 1846 : 							if (iInterceptionDamage > 0 && pInterceptor)

	cmp	DWORD PTR _iInterceptionDamage$[esp+204], 0
	jle	$LN17@ResolveAir
	cmp	DWORD PTR _pInterceptor$[esp+204], 0
	je	$LN17@ResolveAir

; 1847 : 							{
; 1848 : 								strBuffer = GetLocalizedText("TXT_KEY_MISC_ENEMY_AIR_UNIT_INTERCEPTED", pInterceptor->getNameKey(), pkAttacker->getVisualCivAdjective(pkDefender->getTeam()), pkAttacker->getNameKey(), iDefenderDamageInflicted, pkDefender->getNameKey());

	mov	ecx, edi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T229873[esp+204], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, edi
	mov	DWORD PTR $T229874[esp+204], eax
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, esi
	call	?getVisualCivAdjective@CvUnit@@QBEPBDW4TeamTypes@@@Z ; CvUnit::getVisualCivAdjective
	mov	ecx, DWORD PTR _pInterceptor$[esp+204]
	mov	DWORD PTR $T229875[esp+204], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	lea	ecx, DWORD PTR $T229873[esp+204]
	push	ecx
	mov	DWORD PTR $T229876[esp+208], eax
	lea	edx, DWORD PTR _iDefenderDamageInflicted$[esp+208]
	push	edx
	lea	eax, DWORD PTR $T229874[esp+212]
	push	eax
	lea	ecx, DWORD PTR $T229875[esp+216]
	push	ecx
	lea	edx, DWORD PTR $T229876[esp+220]
	push	edx
	lea	eax, DWORD PTR $T229877[esp+224]
	push	OFFSET $SG222842
	push	eax
	call	??$GetLocalizedText@PBDPBDPBDHPBD@@YA?AVCvString@@PBDABQBD11ABH1@Z ; GetLocalizedText<char const *,char const *,char const *,int,char const *>
	add	esp, 28					; 0000001cH
	mov	BYTE PTR __$EHRec$[esp+212], 9
$LN341@ResolveAir:
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+208]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T229877[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1849 : 								pkDLLInterface->AddMessage(uiParentEventID, pkDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	lea	ecx, DWORD PTR _strBuffer$[esp+204]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi+40]
	push	0
	push	0
	mov	edx, DWORD PTR [ebp]
	push	-1
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	mov	ecx, DWORD PTR _uiParentEventID$[esp+248]
	push	ecx
	mov	ecx, ebp
	call	edx

; 1850 : 							}
; 1851 : 							else

	jmp	$LN16@ResolveAir
$LN17@ResolveAir:

; 1852 : 							{
; 1853 : 								strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_AIR", pkDefender->getNameKey(), pkAttacker->getNameKey(), iAttackerDamageInflicted);

	mov	ecx, esi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, edi
	mov	DWORD PTR $T229878[esp+204], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	DWORD PTR $T229879[esp+204], eax
	lea	eax, DWORD PTR _iAttackerDamageInflicted$[esp+204]
	push	eax
	lea	ecx, DWORD PTR $T229878[esp+208]
	push	ecx
	lea	edx, DWORD PTR $T229879[esp+212]
	push	edx
	lea	eax, DWORD PTR $T229880[esp+216]
	push	OFFSET $SG222847
	push	eax
	call	??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z ; GetLocalizedText<char const *,char const *,int>
	add	esp, 20					; 00000014H
	mov	BYTE PTR __$EHRec$[esp+212], 10		; 0000000aH

; 1854 : 								pkDLLInterface->AddMessage(uiParentEventID, pkDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_COMBAT", MESSAGE_TYPE_INFO, pkDefender->getUnitInfo().GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	jmp	$LN341@ResolveAir
$LN34@ResolveAir:

; 1871 : 		{
; 1872 : 			// Target was a City
; 1873 : 			CvCity* pCity = pkTargetPlot->getPlotCity();

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	jl	$LN35@ResolveAir
	cmp	eax, 64					; 00000040H
	jge	$LN35@ResolveAir
	mov	ecx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	edi, eax

; 1874 : 			CvAssert_Debug(pCity != NULL);
; 1875 : 
; 1876 : 			if(pCity)

	test	edi, edi
	je	$LN35@ResolveAir

; 1877 : 			{
; 1878 : 				pCity->clearCombat();

	mov	ecx, edi
	call	?clearCombat@CvCity@@QAEXXZ		; CvCity::clearCombat

; 1879 : 				if(pkAttacker)

	test	esi, esi
	je	$LN5@ResolveAir

; 1880 : 				{
; 1881 : 					pCity->changeDamage(iAttackerDamageInflicted);

	mov	edx, DWORD PTR _iAttackerDamageInflicted$[esp+204]
	push	edx
	mov	ecx, edi
	call	?changeDamage@CvCity@@QAEXH@Z		; CvCity::changeDamage

; 1882 : 					pkAttacker->changeDamage(iDefenderDamageInflicted, pCity->getOwner());

	mov	eax, DWORD PTR [edi+84]
	push	0
	push	ecx
	mov	DWORD PTR [esp], 0
	push	eax
	mov	eax, DWORD PTR _iDefenderDamageInflicted$[esp+216]
	push	eax
	mov	ecx, esi
	call	?changeDamage@CvUnit@@QAEHHW4PlayerTypes@@MPBVCvString@@@Z ; CvUnit::changeDamage

; 1883 : 
; 1884 : 					//		iUnitDamage = std::max(pCity->getDamage(), pCity->getDamage() + iDamage);
; 1885 : 
; 1886 : 					if(pkAttacker->IsDead())

	mov	ecx, esi
	call	?IsDead@CvUnit@@QBE_NXZ			; CvUnit::IsDead
	test	al, al
	je	$LN9@ResolveAir

; 1887 : 					{
; 1888 : 						if(iActivePlayerID == pkAttacker->getOwner())

	mov	ecx, DWORD PTR _iActivePlayerID$[esp+204]
	cmp	ecx, DWORD PTR [esi+40]
	jne	$LN9@ResolveAir

; 1889 : 						{
; 1890 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_DIED_ATTACKING_CITY", pkAttacker->getNameKey(), pCity->getNameKey(), iAttackerDamageInflicted);

	mov	ecx, edi
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T229882[esp+204], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	lea	edx, DWORD PTR _iAttackerDamageInflicted$[esp+204]
	push	edx
	mov	DWORD PTR $T229883[esp+208], eax
	lea	eax, DWORD PTR $T229882[esp+208]
	push	eax
	lea	ecx, DWORD PTR $T229883[esp+212]
	push	ecx
	lea	edx, DWORD PTR $T229884[esp+216]
	push	OFFSET $SG222860
	push	edx
	call	??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z ; GetLocalizedText<char const *,char const *,int>
	add	esp, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+208]
	mov	BYTE PTR __$EHRec$[esp+216], 11		; 0000000bH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T229884[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1891 : 							pkDLLInterface->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	lea	ecx, DWORD PTR _strBuffer$[esp+204]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi+40]
	push	0
	push	0
	mov	edx, DWORD PTR [ebp]
	push	-1
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	mov	ecx, DWORD PTR _uiParentEventID$[esp+248]
	push	ecx
	mov	ecx, ebp
	call	edx
$LN9@ResolveAir:

; 1892 : 						}
; 1893 : 					}
; 1894 : 
; 1895 : 					if(pCity->getOwner() == iActivePlayerID)

	mov	eax, DWORD PTR _iActivePlayerID$[esp+204]
	cmp	DWORD PTR [edi+84], eax
	jne	$LN6@ResolveAir

; 1896 : 					{
; 1897 : 						strBuffer = GetLocalizedText("TXT_KEY_MISC_YOUR_CITY_ATTACKED_BY_AIR", pCity->getNameKey(), pkAttacker->getNameKey(), iDefenderDamageInflicted);

	mov	ecx, esi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, edi
	mov	DWORD PTR $T229885[esp+204], eax
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	lea	ecx, DWORD PTR _iDefenderDamageInflicted$[esp+204]
	push	ecx
	lea	edx, DWORD PTR $T229885[esp+208]
	push	edx
	mov	DWORD PTR $T229886[esp+212], eax
	lea	eax, DWORD PTR $T229886[esp+212]
	push	eax
	lea	ecx, DWORD PTR $T229887[esp+216]
	push	OFFSET $SG222865
	push	ecx
	call	??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z ; GetLocalizedText<char const *,char const *,int>
	add	esp, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+208]
	mov	BYTE PTR __$EHRec$[esp+216], 12		; 0000000cH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T229887[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1898 : 						//red icon over attacking unit
; 1899 : 						pkDLLInterface->AddMessage(uiParentEventID, pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), strBuffer);

	lea	ecx, DWORD PTR _strBuffer$[esp+204]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edi, DWORD PTR [edi+84]
	push	0
	mov	ecx, DWORD PTR _uiParentEventID$[esp+204]
	mov	edx, DWORD PTR [ebp]
	push	0
	push	-1
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	0
	push	edi
	push	ecx
	mov	ecx, ebp
	call	edx

; 1900 : 					}
; 1901 : 				}
; 1902 : 			}
; 1903 : 			else

	jmp	SHORT $LN6@ResolveAir
$LN35@ResolveAir:

; 1904 : 				bTargetDied = true;
; 1905 : 		}
; 1906 : 	}
; 1907 : 	else
; 1908 : 		bTargetDied = true;

	mov	BYTE PTR _bTargetDied$[esp+204], 1
$LN6@ResolveAir:

; 1909 : 
; 1910 : 	// Suicide Unit (e.g. Missiles)
; 1911 : 	if(pkAttacker)

	test	esi, esi
	je	$LN5@ResolveAir

; 1912 : 	{
; 1913 : 		if(pkAttacker->isSuicide())

	mov	ecx, esi
	call	?isSuicide@CvUnit@@QBE_NXZ		; CvUnit::isSuicide
	test	al, al
	je	SHORT $LN4@ResolveAir

; 1914 : 		{
; 1915 : 			pkAttacker->setCombatUnit(NULL);	// Must clear this if doing a delayed kill, should this be part of the kill method?

	push	0
	push	0
	mov	ecx, esi
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 1916 : 			pkAttacker->kill(true);

	push	-1
	push	1
	mov	ecx, esi
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill

; 1917 : 		}
; 1918 : 		else

	jmp	$LN1@ResolveAir
$LN4@ResolveAir:

; 1919 : 		{
; 1920 : 			// Experience
; 1921 : 			if(iAttackerDamageInflicted > 0)

	cmp	DWORD PTR _iAttackerDamageInflicted$[esp+204], 0
	jle	SHORT $LN2@ResolveAir

; 1922 : 			{
; 1923 : 				pkAttacker->changeExperience(kCombatInfo.getExperience(BATTLE_UNIT_ATTACKER),
; 1924 : 				                             kCombatInfo.getMaxExperienceAllowed(BATTLE_UNIT_ATTACKER),
; 1925 : 				                             true,
; 1926 : 				                             kCombatInfo.getInBorders(BATTLE_UNIT_ATTACKER),
; 1927 : 				                             kCombatInfo.getUpdateGlobal(BATTLE_UNIT_ATTACKER));

	push	0
	mov	ecx, ebx
	call	?getUpdateGlobal@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getUpdateGlobal
	movzx	eax, al
	push	eax
	push	0
	mov	ecx, ebx
	call	?getInBorders@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getInBorders
	movzx	ecx, al
	push	ecx
	push	1
	push	0
	mov	ecx, ebx
	call	?getMaxExperienceAllowed@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getMaxExperienceAllowed
	push	eax
	push	0
	mov	ecx, ebx
	call	?getExperience@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getExperience
	push	eax
	mov	ecx, esi
	call	?changeExperience@CvUnit@@QAEXHH_N00@Z	; CvUnit::changeExperience

; 1928 : 
; 1929 : #ifndef AUI_UNIT_TEST_PROMOTION_READY_MOVED
; 1930 : 				// Promotion time?
; 1931 : 				pkAttacker->testPromotionReady();

	mov	ecx, esi
	call	?testPromotionReady@CvUnit@@QAEXXZ	; CvUnit::testPromotionReady
$LN2@ResolveAir:

; 1932 : #endif
; 1933 : 
; 1934 : 			}
; 1935 : 
; 1936 : 			// Clean up some stuff
; 1937 : 			pkAttacker->setCombatUnit(NULL);

	push	0
	push	0
	mov	ecx, esi
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 1938 : 			pkAttacker->ClearMissionQueue(GetPostCombatDelay());

	call	?quickCombat@CvPreGame@@YA_NXZ		; CvPreGame::quickCombat
	movzx	edx, al
	neg	edx
	sbb	edx, edx
	and	edx, 109				; 0000006dH
	inc	edx
	push	edx
	mov	ecx, esi
	call	?ClearMissionQueue@CvUnit@@QAEXH@Z	; CvUnit::ClearMissionQueue

; 1939 : 
; 1940 : 			// Spend a move for this attack
; 1941 : 			pkAttacker->changeMoves(-GC.getMOVE_DENOMINATOR());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	neg	eax
	push	eax
	mov	ecx, esi
	call	?changeMoves@CvUnit@@QAEXH@Z		; CvUnit::changeMoves

; 1942 : 
; 1943 : 			// Can't move or attack again
; 1944 : #ifdef NQ_UNIT_TURN_ENDS_ON_FINAL_ATTACK
; 1945 : 			if(!pkAttacker->canMoveAfterAttacking() && pkAttacker->isOutOfAttacks())

	mov	ecx, esi
	call	?canMoveAfterAttacking@CvUnit@@QBE_NXZ	; CvUnit::canMoveAfterAttacking
	test	al, al
	jne	SHORT $LN1@ResolveAir
	mov	ecx, esi
	call	?isOutOfAttacks@CvUnit@@QBE_NXZ		; CvUnit::isOutOfAttacks
	test	al, al
	je	SHORT $LN1@ResolveAir

; 1946 : #else
; 1947 : 			if(!pkAttacker->canMoveAfterAttacking())
; 1948 : #endif
; 1949 : 			{
; 1950 : 				pkAttacker->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN1@ResolveAir:

; 1951 : 			}
; 1952 : 		}
; 1953 : 
; 1954 : 		// Report that combat is over in case we want to queue another attack
; 1955 : 		GET_PLAYER(pkAttacker->getOwner()).GetTacticalAI()->CombatResolved(pkAttacker, bTargetDied);

	mov	eax, DWORD PTR [esi+40]
	mov	ecx, DWORD PTR _bTargetDied$[esp+204]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	ecx
	push	esi
	mov	ecx, eax
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z ; CvTacticalAI::CombatResolved
$LN5@ResolveAir:

; 1956 : 	}
; 1957 : }

	lea	ecx, DWORD PTR _strBuffer$[esp+204]
	mov	DWORD PTR __$EHRec$[esp+212], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+204]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 188				; 000000bcH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$2:
	lea	ecx, DWORD PTR _pAttacker$222762[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$3:
	lea	ecx, DWORD PTR $T229853[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$4:
	lea	ecx, DWORD PTR $T229858[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$5:
	lea	ecx, DWORD PTR $T229863[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$6:
	lea	ecx, DWORD PTR $T229866[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$7:
	lea	ecx, DWORD PTR $T229869[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$8:
	lea	ecx, DWORD PTR _strSummary$222812[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$9:
	lea	ecx, DWORD PTR $T229872[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$10:
	lea	ecx, DWORD PTR $T229877[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$11:
	lea	ecx, DWORD PTR $T229880[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$13:
	lea	ecx, DWORD PTR $T229884[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$14:
	lea	ecx, DWORD PTR $T229887[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z:
	mov	eax, OFFSET __ehfuncinfo$?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ENDP ; CvUnitCombat::ResolveAirUnitVsCombat
PUBLIC	?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveAirSweep
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$7
	DD	04H
	DD	FLAT:__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$10
	DD	07H
	DD	FLAT:__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$11
	DD	07H
	DD	FLAT:__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$12
	DD	07H
	DD	FLAT:__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$13
	DD	07H
	DD	FLAT:__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$14
	DD	07H
	DD	FLAT:__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$15
	DD	07H
	DD	FLAT:__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$16
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$17
	DD	00H
	DD	FLAT:__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$18
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
xdata$x	ENDS
;	COMDAT ?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
_TEXT	SEGMENT
$T231040 = -184						; size = 4
$T230525 = -184						; size = 4
$T230522 = -184						; size = 4
$T230517 = -184						; size = 4
$T230514 = -184						; size = 4
$T230510 = -184						; size = 4
$T230507 = -184						; size = 4
$T230504 = -184						; size = 4
$T230497 = -184						; size = 4
$T230493 = -184						; size = 4
$T230486 = -184						; size = 4
$T230484 = -184						; size = 4
$T231044 = -180						; size = 4
$T230518 = -180						; size = 4
$T230515 = -180						; size = 4
$T230511 = -180						; size = 4
$T230508 = -180						; size = 4
$T230505 = -180						; size = 4
$T230498 = -180						; size = 4
$T230494 = -180						; size = 4
$T230487 = -180						; size = 4
$T230483 = -180						; size = 4
$T230553 = -176						; size = 4
_pNotification$222975 = -176				; size = 4
$T230500 = -176						; size = 4
$T230489 = -176						; size = 4
_iActivePlayerID$222913 = -176				; size = 4
_pkTargetPlot$ = -176					; size = 4
$T230492 = -172						; size = 4
$T230480 = -172						; size = 4
_iDefenderDamageInflicted$ = -172			; size = 4
$T230519 = -168						; size = 4
$T230512 = -168						; size = 4
$T230499 = -168						; size = 4
$T230495 = -168						; size = 4
$T230488 = -168						; size = 4
$T230482 = -168						; size = 4
$T230524 = -164						; size = 4
$T230521 = -164						; size = 4
$T230502 = -164						; size = 4
$T230491 = -164						; size = 4
$T230481 = -164						; size = 4
$T230503 = -160						; size = 4
_iAttackerDamageInflicted$ = -160			; size = 4
_bDefenderDead$ = -156					; size = 1
_strBuffer$ = -152					; size = 28
$T230526 = -124						; size = 28
$T230523 = -124						; size = 28
$T230520 = -124						; size = 28
$T230516 = -124						; size = 28
$T230513 = -124						; size = 28
$T230509 = -124						; size = 28
$T230506 = -124						; size = 28
$T230501 = -124						; size = 28
$T230496 = -124						; size = 28
$T230490 = -124						; size = 28
$T230485 = -124						; size = 28
_pDefender$222955 = -96					; size = 4
_pAttacker$222936 = -96					; size = 4
_pAttacker$222917 = -96					; size = 4
_strSummary$222988 = -92				; size = 80
__$EHRec$ = -12						; size = 12
_kCombatInfo$ = 8					; size = 4
_uiParentEventID$ = 12					; size = 4
?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z PROC ; CvUnitCombat::ResolveAirSweep, COMDAT

; 2103 : {

	push	-1
	push	__ehhandler$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 172				; 000000acH
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2104 : 	// After combat stuff
; 2105 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[esp+200]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2106 : 	bool bAttackerDead = false;
; 2107 : 	bool bDefenderDead = false;
; 2108 : 
; 2109 : 	CvUnit* pkAttacker = kCombatInfo.getUnit(BATTLE_UNIT_ATTACKER);

	mov	ebp, DWORD PTR _kCombatInfo$[esp+196]
	push	0
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+212], 0
	mov	BYTE PTR _bDefenderDead$[esp+204], 0
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit

; 2110 : 	CvUnit* pkDefender = kCombatInfo.getUnit(BATTLE_UNIT_DEFENDER);

	push	1
	mov	ecx, ebp
	mov	edi, eax
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit

; 2111 : 	CvPlot* pkTargetPlot = kCombatInfo.getPlot();

	mov	ecx, ebp
	mov	esi, eax
	call	?getPlot@CvCombatInfo@@QBEPAVCvPlot@@XZ	; CvCombatInfo::getPlot
	mov	DWORD PTR _pkTargetPlot$[esp+200], eax

; 2112 : 	if(!pkTargetPlot && pkDefender)

	test	eax, eax
	jne	SHORT $LN28@ResolveAir@2
	test	esi, esi
	je	SHORT $LN28@ResolveAir@2

; 2113 : 		pkTargetPlot = pkDefender->plot();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pkTargetPlot$[esp+200], eax
$LN28@ResolveAir@2:

; 2114 : 
; 2115 : 	CvAssert_Debug(pkAttacker && pkDefender && pkTargetPlot);
; 2116 : 
; 2117 : 	// Internal variables
; 2118 : 	int iAttackerDamageInflicted = kCombatInfo.getDamageInflicted(BATTLE_UNIT_ATTACKER);

	push	0
	mov	ecx, ebp
	call	?getDamageInflicted@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getDamageInflicted
	mov	ebx, eax

; 2119 : 	int iDefenderDamageInflicted = kCombatInfo.getDamageInflicted(BATTLE_UNIT_DEFENDER);

	push	1
	mov	ecx, ebp
	mov	DWORD PTR _iAttackerDamageInflicted$[esp+204], ebx
	call	?getDamageInflicted@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getDamageInflicted
	mov	DWORD PTR _iDefenderDamageInflicted$[esp+200], eax

; 2120 : 
; 2121 : 	// Made interception!
; 2122 : 	if(pkDefender)

	test	esi, esi
	je	$LN27@ResolveAir@2

; 2123 : 	{
; 2124 : 		pkDefender->setMadeInterception(true);

	push	1
	mov	ecx, esi
	call	?setMadeInterception@CvUnit@@QAEX_N@Z	; CvUnit::setMadeInterception

; 2125 : 		if(pkAttacker && pkTargetPlot)

	test	edi, edi
	je	$LN348@ResolveAir@2
	cmp	DWORD PTR _pkTargetPlot$[esp+200], 0
	je	$LN348@ResolveAir@2

; 2126 : 		{
; 2127 : 			//One Hit
; 2128 : 			if(pkDefender->GetCurrHitPoints() == GC.getMAX_HIT_POINTS() && pkAttacker->isHuman() && !GC.getGame().isGameMultiPlayer())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, esi
	mov	DWORD PTR $T230553[esp+200], eax
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	cmp	eax, DWORD PTR $T230553[esp+200]
	jne	SHORT $LN25@ResolveAir@2
	mov	ecx, edi
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	je	SHORT $LN25@ResolveAir@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	SHORT $LN25@ResolveAir@2

; 2129 : 			{
; 2130 : 				gDLL->UnlockAchievement(ACHIEVEMENT_ONEHITKILL);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	60					; 0000003cH
	call	eax
$LN25@ResolveAir@2:

; 2131 : 			}
; 2132 : 
; 2133 : 			pkDefender->changeDamage(iAttackerDamageInflicted, pkAttacker->getOwner());

	mov	eax, DWORD PTR [edi+40]
	push	0
	push	ecx
	mov	DWORD PTR [esp], 0
	push	eax
	push	ebx
	mov	ecx, esi
	call	?changeDamage@CvUnit@@QAEHHW4PlayerTypes@@MPBVCvString@@@Z ; CvUnit::changeDamage

; 2134 : 			pkAttacker->changeDamage(iDefenderDamageInflicted, pkDefender->getOwner());

	mov	eax, DWORD PTR [esi+40]
	push	0
	push	ecx
	mov	ecx, DWORD PTR _iDefenderDamageInflicted$[esp+208]
	mov	DWORD PTR [esp], 0
	push	eax
	push	ecx
	mov	ecx, edi
	call	?changeDamage@CvUnit@@QAEHHW4PlayerTypes@@MPBVCvString@@@Z ; CvUnit::changeDamage

; 2135 : 
; 2136 : 			// Update experience for both sides.
; 2137 : 			pkDefender->changeExperience(
; 2138 : 			    kCombatInfo.getExperience(BATTLE_UNIT_DEFENDER),
; 2139 : 			    kCombatInfo.getMaxExperienceAllowed(BATTLE_UNIT_DEFENDER),
; 2140 : 			    true,
; 2141 : 			    kCombatInfo.getInBorders(BATTLE_UNIT_DEFENDER),
; 2142 : 			    kCombatInfo.getUpdateGlobal(BATTLE_UNIT_DEFENDER));

	push	1
	mov	ecx, ebp
	call	?getUpdateGlobal@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getUpdateGlobal
	movzx	edx, al
	push	edx
	push	1
	mov	ecx, ebp
	call	?getInBorders@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getInBorders
	movzx	eax, al
	push	eax
	push	1
	push	1
	mov	ecx, ebp
	call	?getMaxExperienceAllowed@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getMaxExperienceAllowed
	push	eax
	push	1
	mov	ecx, ebp
	call	?getExperience@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getExperience
	push	eax
	mov	ecx, esi
	call	?changeExperience@CvUnit@@QAEXHH_N00@Z	; CvUnit::changeExperience

; 2143 : 
; 2144 : 			pkAttacker->changeExperience(
; 2145 : 			    kCombatInfo.getExperience(BATTLE_UNIT_ATTACKER),
; 2146 : 			    kCombatInfo.getMaxExperienceAllowed(BATTLE_UNIT_ATTACKER),
; 2147 : 			    true,
; 2148 : 			    kCombatInfo.getInBorders(BATTLE_UNIT_ATTACKER),
; 2149 : 			    kCombatInfo.getUpdateGlobal(BATTLE_UNIT_ATTACKER));

	push	0
	mov	ecx, ebp
	call	?getUpdateGlobal@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getUpdateGlobal
	movzx	ecx, al
	push	ecx
	push	0
	mov	ecx, ebp
	call	?getInBorders@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getInBorders
	movzx	edx, al
	push	edx
	push	1
	push	0
	mov	ecx, ebp
	call	?getMaxExperienceAllowed@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getMaxExperienceAllowed
	push	eax
	push	0
	mov	ecx, ebp
	call	?getExperience@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getExperience
	push	eax
	mov	ecx, edi
	call	?changeExperience@CvUnit@@QAEXHH_N00@Z	; CvUnit::changeExperience

; 2150 : 
; 2151 : 			// Anyone eat it?
; 2152 : 			bAttackerDead = (pkAttacker->getDamage() >= GC.getMAX_HIT_POINTS());

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, edi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	cmp	eax, ebp

; 2153 : 			bDefenderDead = (pkDefender->getDamage() >= GC.getMAX_HIT_POINTS());

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, esi
	setge	bl
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage

; 2154 : 
; 2155 : 			int iActivePlayerID = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	cmp	eax, ebp
	setge	BYTE PTR _bDefenderDead$[esp+200]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	ebp, eax

; 2156 : 
; 2157 : 			//////////////////////////////////////////////////////////////////////////
; 2158 : 
; 2159 : #ifndef AUI_UNIT_COMBAT_FIX_AIR_SWEEP_VS_GROUND_INTERCEPTOR
; 2160 : 			// Ground AA interceptor
; 2161 : 			if(pkDefender->getDomainType() != DOMAIN_AIR)

	mov	ecx, esi
	mov	DWORD PTR _iActivePlayerID$222913[esp+200], ebp
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	je	$LN24@ResolveAir@2

; 2162 : 			{
; 2163 : 				// Attacker died
; 2164 : 				if(bAttackerDead)

	test	bl, bl
	je	$LN348@ResolveAir@2

; 2165 : 				{
; 2166 : 					auto_ptr<ICvUnit1> pAttacker = GC.WrapUnitPointer(pkAttacker);

	push	edi
	lea	eax, DWORD PTR $T230480[esp+204]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z ; CvGlobals::WrapUnitPointer
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR $T230481[esp+200], ebx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pAttacker$222917[esp+200], ebx
	mov	eax, DWORD PTR $T230480[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 1
	test	eax, eax
	je	SHORT $LN81@ResolveAir@2
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN81@ResolveAir@2:

; 2167 : 					gDLL->GameplayUnitDestroyedInCombat(pAttacker.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+600]
	push	ebx
	call	edx

; 2168 : 
; 2169 : 					if(iActivePlayerID == pkAttacker->getOwner())

	mov	ebx, DWORD PTR _uiParentEventID$[esp+196]
	cmp	ebp, DWORD PTR [edi+40]
	jne	$LN341@ResolveAir@2

; 2170 : 					{
; 2171 : 						strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_DIED_ATTACKING", pkAttacker->getNameKey(), pkDefender->getNameKey(), iAttackerDamageInflicted, 0);

	mov	ecx, esi
	mov	DWORD PTR $T230482[esp+200], 0
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, edi
	mov	DWORD PTR $T230483[esp+200], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	DWORD PTR $T230484[esp+200], eax
	lea	eax, DWORD PTR $T230482[esp+200]
	push	eax
	lea	ecx, DWORD PTR _iAttackerDamageInflicted$[esp+204]
	push	ecx
	lea	edx, DWORD PTR $T230483[esp+208]
	push	edx
	lea	eax, DWORD PTR $T230484[esp+212]
	push	eax
	lea	ecx, DWORD PTR $T230485[esp+216]
	push	OFFSET $SG222925
	push	ecx
	call	??$GetLocalizedText@PBDPBDHH@@YA?AVCvString@@PBDABQBD1ABH2@Z ; GetLocalizedText<char const *,char const *,int,int>
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 2
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T230485[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2172 : 						GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+200]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi+40]
	push	0
	mov	edx, DWORD PTR [ebp]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	push	ebx
	mov	ecx, ebp
	call	edx
	mov	ebp, DWORD PTR _iActivePlayerID$222913[esp+200]
$LN341@ResolveAir@2:

; 2173 : 					}
; 2174 : 					if(iActivePlayerID == pkDefender->getOwner())

	cmp	ebp, DWORD PTR [esi+40]
	jne	$LN21@ResolveAir@2

; 2175 : 					{
; 2176 : 						strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_KILLED_ENEMY_UNIT", pkDefender->getNameKey(), iAttackerDamageInflicted, 0, pkAttacker->getNameKey(), pkAttacker->getVisualCivAdjective(pkDefender->getTeam()));

	mov	ecx, esi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, edi
	call	?getVisualCivAdjective@CvUnit@@QBEPBDW4TeamTypes@@@Z ; CvUnit::getVisualCivAdjective
	mov	ecx, edi
	mov	DWORD PTR $T230486[esp+200], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T230487[esp+200], eax
	mov	DWORD PTR $T230488[esp+200], 0
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	DWORD PTR $T230489[esp+200], eax
	lea	eax, DWORD PTR $T230486[esp+200]
	push	eax
	lea	ecx, DWORD PTR $T230487[esp+204]
	push	ecx
	lea	edx, DWORD PTR $T230488[esp+208]
	push	edx
	lea	eax, DWORD PTR _iAttackerDamageInflicted$[esp+212]
	push	eax
	lea	ecx, DWORD PTR $T230489[esp+216]
	push	ecx
	lea	edx, DWORD PTR $T230490[esp+220]
	push	OFFSET $SG222932
	push	edx
	call	??$GetLocalizedText@PBDHHPBDPBD@@YA?AVCvString@@PBDABQBDABH211@Z ; GetLocalizedText<char const *,int,int,char const *,char const *>
	add	esp, 28					; 0000001cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 3
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T230490[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2177 : 						GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+200]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi+40]
	push	0
	mov	edx, DWORD PTR [ebp]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	push	ebx
	mov	ecx, ebp
	call	edx
$LN21@ResolveAir@2:

; 2178 : 					}
; 2179 : #ifndef AUI_UNIT_TEST_PROMOTION_READY_MOVED
; 2180 : 					pkDefender->testPromotionReady();

	mov	ecx, esi
	call	?testPromotionReady@CvUnit@@QAEXXZ	; CvUnit::testPromotionReady

; 2181 : #endif
; 2182 : 				}

	mov	eax, DWORD PTR $T230481[esp+200]
$LN353@ResolveAir@2:
	mov	BYTE PTR __$EHRec$[esp+208], 0
	test	eax, eax
	je	SHORT $LN348@ResolveAir@2
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN348@ResolveAir@2:

; 2283 : 	{
; 2284 : 		pkDefender->setCombatUnit(NULL);

	push	0
	push	0
	mov	ecx, esi
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 2285 : 		pkDefender->ClearMissionQueue();

	push	1
	mov	ecx, esi
	call	?ClearMissionQueue@CvUnit@@QAEXH@Z	; CvUnit::ClearMissionQueue
$LN3@ResolveAir@2:

; 2286 : #ifdef NQM_UNIT_COMBAT_WITHDRAW_INTERCEPT_AFTER_SWEEP_IF_AT_OR_BELOW_TARGET_HEALTH
; 2287 : 		if (pkDefender->GetActivityType() == ACTIVITY_INTERCEPT)
; 2288 : 		{
; 2289 : 			int iEffectiveDefenderHP = pkDefender->GetCurrHitPoints();
; 2290 : 			if (pkDefender->isAlwaysHeal() && pkDefender->isOutOfInterceptions() && !GET_PLAYER(pkDefender->getOwner()).isEndTurn() && pkDefender->canHeal(pkDefender->plot()))
; 2291 : 				iEffectiveDefenderHP += pkDefender->healRate(pkDefender->plot());
; 2292 : 			if (iEffectiveDefenderHP * NQM_UNIT_COMBAT_WITHDRAW_INTERCEPT_AFTER_SWEEP_IF_AT_OR_BELOW_TARGET_HEALTH <= GC.getMAX_HIT_POINTS() * 100)
; 2293 : 				pkDefender->SetActivityType(ACTIVITY_AWAKE);
; 2294 : 		}
; 2295 : #endif
; 2296 : 	}
; 2297 : 
; 2298 : 	if(pkAttacker)

	test	edi, edi
	je	SHORT $LN2@ResolveAir@2

; 2299 : 	{
; 2300 : 		pkAttacker->setCombatUnit(NULL);

	push	0
	push	0
	mov	ecx, edi
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 2301 : 		pkAttacker->ClearMissionQueue(GetPostCombatDelay());

	call	?quickCombat@CvPreGame@@YA_NXZ		; CvPreGame::quickCombat
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	and	eax, 109				; 0000006dH
	inc	eax
	push	eax
	mov	ecx, edi
	call	?ClearMissionQueue@CvUnit@@QAEXH@Z	; CvUnit::ClearMissionQueue

; 2302 : 
; 2303 : 		// Spend a move for this attack
; 2304 : 		pkAttacker->changeMoves(-GC.getMOVE_DENOMINATOR());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	neg	ecx
	push	ecx
	mov	ecx, edi
	call	?changeMoves@CvUnit@@QAEXH@Z		; CvUnit::changeMoves

; 2305 : 
; 2306 : 		// Can't move or attack again
; 2307 : #ifdef NQ_UNIT_TURN_ENDS_ON_FINAL_ATTACK
; 2308 : 		if(!pkAttacker->canMoveAfterAttacking() && pkAttacker->isOutOfAttacks())

	mov	ecx, edi
	call	?canMoveAfterAttacking@CvUnit@@QBE_NXZ	; CvUnit::canMoveAfterAttacking
	test	al, al
	jne	SHORT $LN1@ResolveAir@2
	mov	ecx, edi
	call	?isOutOfAttacks@CvUnit@@QBE_NXZ		; CvUnit::isOutOfAttacks
	test	al, al
	je	SHORT $LN1@ResolveAir@2

; 2309 : #else
; 2310 : 		if(!pkAttacker->canMoveAfterAttacking())
; 2311 : #endif
; 2312 : 		{
; 2313 : 			pkAttacker->finishMoves();

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN1@ResolveAir@2:

; 2314 : 		}
; 2315 : 
; 2316 : 		// Report that combat is over in case we want to queue another attack
; 2317 : 		GET_PLAYER(pkAttacker->getOwner()).GetTacticalAI()->CombatResolved(pkAttacker, bDefenderDead);

	mov	eax, DWORD PTR [edi+40]
	mov	edx, DWORD PTR _bDefenderDead$[esp+200]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	edx
	push	edi
	mov	ecx, eax
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z ; CvTacticalAI::CombatResolved
$LN2@ResolveAir@2:

; 2318 : 	}
; 2319 : }

	lea	ecx, DWORD PTR _strBuffer$[esp+200]
	mov	DWORD PTR __$EHRec$[esp+208], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+200]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 184				; 000000b8H
	ret	0
$LN24@ResolveAir@2:

; 2183 : 			}
; 2184 : 			// Air AA interceptor
; 2185 : 			else
; 2186 : #endif
; 2187 : 			{
; 2188 : 				// Attacker died
; 2189 : 				if(bAttackerDead)

	test	bl, bl
	je	$LN19@ResolveAir@2

; 2190 : 				{
; 2191 : 					auto_ptr<ICvUnit1> pAttacker = GC.WrapUnitPointer(pkAttacker);

	push	edi
	lea	eax, DWORD PTR $T230491[esp+204]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z ; CvGlobals::WrapUnitPointer
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR $T230492[esp+200], ebx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pAttacker$222936[esp+200], ebx
	mov	eax, DWORD PTR $T230491[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 4
	test	eax, eax
	je	SHORT $LN139@ResolveAir@2
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN139@ResolveAir@2:

; 2192 : 					gDLL->GameplayUnitDestroyedInCombat(pAttacker.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+600]
	push	ebx
	call	edx

; 2193 : 
; 2194 : 					if(iActivePlayerID == pkAttacker->getOwner())

	mov	ebx, DWORD PTR _uiParentEventID$[esp+196]
	cmp	ebp, DWORD PTR [edi+40]
	jne	$LN18@ResolveAir@2

; 2195 : 					{
; 2196 : 						strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_DIED_ATTACKING", pkAttacker->getNameKey(), pkDefender->getNameKey(), iAttackerDamageInflicted, 0);

	mov	ecx, esi
	mov	DWORD PTR $T230493[esp+200], 0
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, edi
	mov	DWORD PTR $T230494[esp+200], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	DWORD PTR $T230495[esp+200], eax
	lea	eax, DWORD PTR $T230493[esp+200]
	push	eax
	lea	ecx, DWORD PTR _iAttackerDamageInflicted$[esp+204]
	push	ecx
	lea	edx, DWORD PTR $T230494[esp+208]
	push	edx
	lea	eax, DWORD PTR $T230495[esp+212]
	push	eax
	lea	ecx, DWORD PTR $T230496[esp+216]
	push	OFFSET $SG222944
	push	ecx
	call	??$GetLocalizedText@PBDPBDHH@@YA?AVCvString@@PBDABQBD1ABH2@Z ; GetLocalizedText<char const *,char const *,int,int>
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 5
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T230496[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2197 : 						GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+200]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi+40]
	push	0
	mov	edx, DWORD PTR [ebp]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	push	ebx
	mov	ecx, ebp
	call	edx
	mov	ebp, DWORD PTR _iActivePlayerID$222913[esp+200]
$LN18@ResolveAir@2:

; 2198 : 					}
; 2199 : 					if(iActivePlayerID == pkDefender->getOwner())

	cmp	ebp, DWORD PTR [esi+40]
	jne	$LN17@ResolveAir@2

; 2200 : 					{
; 2201 : 						strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_KILLED_ENEMY_UNIT", pkDefender->getNameKey(), iAttackerDamageInflicted, 0, pkAttacker->getNameKey(), pkAttacker->getVisualCivAdjective(pkDefender->getTeam()));

	mov	ecx, esi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, edi
	call	?getVisualCivAdjective@CvUnit@@QBEPBDW4TeamTypes@@@Z ; CvUnit::getVisualCivAdjective
	mov	ecx, edi
	mov	DWORD PTR $T230497[esp+200], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T230498[esp+200], eax
	mov	DWORD PTR $T230499[esp+200], 0
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	DWORD PTR $T230500[esp+200], eax
	lea	eax, DWORD PTR $T230497[esp+200]
	push	eax
	lea	ecx, DWORD PTR $T230498[esp+204]
	push	ecx
	lea	edx, DWORD PTR $T230499[esp+208]
	push	edx
	lea	eax, DWORD PTR _iAttackerDamageInflicted$[esp+212]
	push	eax
	lea	ecx, DWORD PTR $T230500[esp+216]
	push	ecx
	lea	edx, DWORD PTR $T230501[esp+220]
	push	OFFSET $SG222951
	push	edx
	call	??$GetLocalizedText@PBDHHPBDPBD@@YA?AVCvString@@PBDABQBDABH211@Z ; GetLocalizedText<char const *,int,int,char const *,char const *>
	add	esp, 28					; 0000001cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 6
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T230501[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2202 : 						GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+200]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi+40]
	push	0
	mov	edx, DWORD PTR [ebp]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	push	ebx
	mov	ecx, ebp
	call	edx
$LN17@ResolveAir@2:

; 2203 : 					}
; 2204 : 
; 2205 : #ifndef AUI_UNIT_TEST_PROMOTION_READY_MOVED
; 2206 : 					pkDefender->testPromotionReady();

	mov	ecx, esi
	call	?testPromotionReady@CvUnit@@QAEXXZ	; CvUnit::testPromotionReady

; 2207 : #endif
; 2208 : 
; 2209 : 					ApplyPostCombatTraitEffects(pkDefender, pkAttacker);

	push	edi
	push	esi
	call	?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z ; CvUnitCombat::ApplyPostCombatTraitEffects

; 2210 : 				}

	mov	eax, DWORD PTR $T230492[esp+208]
	add	esp, 8
	jmp	$LN353@ResolveAir@2
$LN19@ResolveAir@2:

; 2211 : 				// Defender died
; 2212 : 				else if(bDefenderDead)

	cmp	BYTE PTR _bDefenderDead$[esp+200], 0
	je	$LN15@ResolveAir@2

; 2213 : 				{
; 2214 : 					auto_ptr<ICvUnit1> pDefender = GC.WrapUnitPointer(pkDefender);

	push	esi
	lea	eax, DWORD PTR $T230502[esp+204]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z ; CvGlobals::WrapUnitPointer
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR $T230503[esp+200], ebx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pDefender$222955[esp+200], ebx
	mov	eax, DWORD PTR $T230502[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 7
	test	eax, eax
	je	SHORT $LN197@ResolveAir@2
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN197@ResolveAir@2:

; 2215 : 					gDLL->GameplayUnitDestroyedInCombat(pDefender.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+600]
	push	ebx
	call	edx

; 2216 : 
; 2217 : 					if(iActivePlayerID == pkAttacker->getOwner())

	mov	ebx, DWORD PTR _uiParentEventID$[esp+196]
	cmp	ebp, DWORD PTR [edi+40]
	jne	$LN342@ResolveAir@2

; 2218 : 					{
; 2219 : 						strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_DESTROYED_ENEMY", pkAttacker->getNameKey(), iDefenderDamageInflicted, pkDefender->getNameKey());

	mov	ecx, esi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, edi
	mov	DWORD PTR $T230504[esp+200], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	DWORD PTR $T230505[esp+200], eax
	lea	eax, DWORD PTR $T230504[esp+200]
	push	eax
	lea	ecx, DWORD PTR _iDefenderDamageInflicted$[esp+204]
	push	ecx
	lea	edx, DWORD PTR $T230505[esp+208]
	push	edx
	lea	eax, DWORD PTR $T230506[esp+212]
	push	OFFSET $SG222962
	push	eax
	call	??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z ; GetLocalizedText<char const *,int,char const *>
	add	esp, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 8
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T230506[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2220 : 						GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+200]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi+40]
	push	0
	mov	edx, DWORD PTR [ebp]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	push	ebx
	mov	ecx, ebp
	call	edx
	mov	ebp, DWORD PTR _iActivePlayerID$222913[esp+200]
$LN342@ResolveAir@2:

; 2221 : 					}
; 2222 : 					if(iActivePlayerID == pkDefender->getOwner())

	cmp	ebp, DWORD PTR [esi+40]
	jne	$LN13@ResolveAir@2

; 2223 : 					{
; 2224 : 						if(pkAttacker->getVisualOwner(pkDefender->getTeam()) != pkAttacker->getOwner())

	mov	ebp, DWORD PTR [edi+40]
	mov	ecx, esi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, edi
	call	?getVisualOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@@Z ; CvUnit::getVisualOwner
	cmp	eax, ebp
	je	SHORT $LN12@ResolveAir@2

; 2225 : 						{
; 2226 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED_UNKNOWN", pkDefender->getNameKey(), pkAttacker->getNameKey(), iDefenderDamageInflicted);

	mov	ecx, edi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T230507[esp+200], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	DWORD PTR $T230508[esp+200], eax
	lea	eax, DWORD PTR _iDefenderDamageInflicted$[esp+200]
	push	eax
	lea	ecx, DWORD PTR $T230507[esp+204]
	push	ecx
	lea	edx, DWORD PTR $T230508[esp+208]
	push	edx
	lea	eax, DWORD PTR $T230509[esp+212]
	push	OFFSET $SG222968
	push	eax
	call	??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z ; GetLocalizedText<char const *,char const *,int>
	add	esp, 20					; 00000014H
	mov	BYTE PTR __$EHRec$[esp+208], 9

; 2227 : 						}
; 2228 : 						else

	jmp	SHORT $LN350@ResolveAir@2
$LN12@ResolveAir@2:

; 2229 : 						{
; 2230 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED", pkDefender->getNameKey(), pkAttacker->getNameKey(), pkAttacker->getVisualCivAdjective(pkDefender->getTeam()), iDefenderDamageInflicted);

	mov	ecx, esi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, edi
	call	?getVisualCivAdjective@CvUnit@@QBEPBDW4TeamTypes@@@Z ; CvUnit::getVisualCivAdjective
	mov	ecx, edi
	mov	DWORD PTR $T230510[esp+200], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T230511[esp+200], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	lea	ecx, DWORD PTR _iDefenderDamageInflicted$[esp+200]
	push	ecx
	lea	edx, DWORD PTR $T230510[esp+204]
	push	edx
	mov	DWORD PTR $T230512[esp+208], eax
	lea	eax, DWORD PTR $T230511[esp+208]
	push	eax
	lea	ecx, DWORD PTR $T230512[esp+212]
	push	ecx
	lea	edx, DWORD PTR $T230513[esp+216]
	push	OFFSET $SG222974
	push	edx
	call	??$GetLocalizedText@PBDPBDPBDH@@YA?AVCvString@@PBDABQBD11ABH@Z ; GetLocalizedText<char const *,char const *,char const *,int>
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+208], 10		; 0000000aH
$LN350@ResolveAir@2:
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+204]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T230513[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2231 : 						}
; 2232 : 						GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*,GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+200]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi+40]
	push	0
	mov	edx, DWORD PTR [ebp]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	push	ebx
	mov	ecx, ebp
	call	edx
$LN13@ResolveAir@2:

; 2233 : 					}
; 2234 : 
; 2235 : 					CvNotifications* pNotification = GET_PLAYER(pkDefender->getOwner()).GetNotifications();

	mov	eax, DWORD PTR [esi+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotification$222975[esp+200], eax

; 2236 : 					if(pNotification)

	test	eax, eax
	je	$LN10@ResolveAir@2

; 2237 : 					{
; 2238 : 						if(pkAttacker->getVisualOwner(pkDefender->getTeam()) != pkAttacker->getOwner())

	mov	ebx, DWORD PTR [edi+40]
	mov	ecx, esi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, edi
	call	?getVisualOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@@Z ; CvUnit::getVisualOwner
	cmp	eax, ebx
	je	SHORT $LN9@ResolveAir@2

; 2239 : 						{
; 2240 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED_UNKNOWN", pkDefender->getNameKey(), pkAttacker->getNameKey(), iDefenderDamageInflicted);

	mov	ecx, edi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T230514[esp+200], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	DWORD PTR $T230515[esp+200], eax
	lea	eax, DWORD PTR _iDefenderDamageInflicted$[esp+200]
	push	eax
	lea	ecx, DWORD PTR $T230514[esp+204]
	push	ecx
	lea	edx, DWORD PTR $T230515[esp+208]
	push	edx
	lea	eax, DWORD PTR $T230516[esp+212]
	push	OFFSET $SG222981
	push	eax
	call	??$GetLocalizedText@PBDPBDH@@YA?AVCvString@@PBDABQBD1ABH@Z ; GetLocalizedText<char const *,char const *,int>
	add	esp, 20					; 00000014H
	mov	BYTE PTR __$EHRec$[esp+208], 11		; 0000000bH

; 2241 : 						}
; 2242 : 						else

	jmp	SHORT $LN351@ResolveAir@2
$LN9@ResolveAir@2:

; 2243 : 						{
; 2244 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED", pkDefender->getNameKey(), pkAttacker->getNameKey(), pkAttacker->getVisualCivAdjective(pkDefender->getTeam()), iDefenderDamageInflicted);

	mov	ecx, esi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, edi
	call	?getVisualCivAdjective@CvUnit@@QBEPBDW4TeamTypes@@@Z ; CvUnit::getVisualCivAdjective
	mov	ecx, edi
	mov	DWORD PTR $T230517[esp+200], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T230518[esp+200], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	lea	ecx, DWORD PTR _iDefenderDamageInflicted$[esp+200]
	push	ecx
	lea	edx, DWORD PTR $T230517[esp+204]
	push	edx
	mov	DWORD PTR $T230519[esp+208], eax
	lea	eax, DWORD PTR $T230518[esp+208]
	push	eax
	lea	ecx, DWORD PTR $T230519[esp+212]
	push	ecx
	lea	edx, DWORD PTR $T230520[esp+216]
	push	OFFSET $SG222987
	push	edx
	call	??$GetLocalizedText@PBDPBDPBDH@@YA?AVCvString@@PBDABQBD11ABH@Z ; GetLocalizedText<char const *,char const *,char const *,int>
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+208], 12		; 0000000cH
$LN351@ResolveAir@2:
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+204]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T230520[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2245 : 						}
; 2246 : 						Localization::String strSummary = Localization::Lookup("TXT_KEY_UNIT_LOST");

	lea	eax, DWORD PTR _strSummary$222988[esp+200]
	push	OFFSET $SG222990
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 2247 : 						pNotification->Add(NOTIFICATION_UNIT_DIED, strBuffer, strSummary.toUTF8(), pkDefender->getX(), pkDefender->getY(), (int) pkDefender->getUnitType(), pkDefender->getOwner());

	mov	ecx, DWORD PTR [esi+76]
	mov	ebp, DWORD PTR [esi+40]
	mov	ebx, DWORD PTR [esi+88]
	mov	DWORD PTR $T231040[esp+200], ecx
	lea	ecx, DWORD PTR _strBuffer$[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 13		; 0000000dH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	ebp
	mov	ecx, esi
	mov	DWORD PTR $T231044[esp+204], eax
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	mov	edx, DWORD PTR $T231040[esp+204]
	push	eax
	push	ebx
	push	edx
	lea	ecx, DWORD PTR _strSummary$222988[esp+216]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	ecx, DWORD PTR _pNotification$222975[esp+216]
	push	eax
	mov	eax, DWORD PTR $T231044[esp+220]
	push	eax
	push	-16309126				; ff07247aH
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 2248 : 					}

	lea	ecx, DWORD PTR _strSummary$222988[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 7
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN10@ResolveAir@2:

; 2249 : 
; 2250 : #ifndef AUI_UNIT_TEST_PROMOTION_READY_MOVED
; 2251 : 					pkAttacker->testPromotionReady();

	mov	ecx, edi
	call	?testPromotionReady@CvUnit@@QAEXXZ	; CvUnit::testPromotionReady

; 2252 : #endif
; 2253 : 
; 2254 : 					ApplyPostCombatTraitEffects(pkAttacker, pkDefender);

	push	esi
	push	edi
	call	?ApplyPostCombatTraitEffects@CvUnitCombat@@KAXPAVCvUnit@@0@Z ; CvUnitCombat::ApplyPostCombatTraitEffects

; 2255 : 				}

	mov	eax, DWORD PTR $T230503[esp+208]
	add	esp, 8

; 2256 : 				// Nobody died
; 2257 : 				else

	jmp	$LN353@ResolveAir@2
$LN15@ResolveAir@2:

; 2258 : 				{
; 2259 : 					if(iActivePlayerID == pkAttacker->getOwner())

	mov	ebx, DWORD PTR _uiParentEventID$[esp+196]
	cmp	ebp, DWORD PTR [edi+40]
	jne	$LN343@ResolveAir@2

; 2260 : 					{
; 2261 : 						strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_WITHDRAW", pkAttacker->getNameKey(), iDefenderDamageInflicted, pkDefender->getNameKey(), iAttackerDamageInflicted);

	mov	ecx, esi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, edi
	mov	DWORD PTR $T230521[esp+200], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	DWORD PTR $T230522[esp+200], eax
	lea	eax, DWORD PTR _iAttackerDamageInflicted$[esp+200]
	push	eax
	lea	ecx, DWORD PTR $T230521[esp+204]
	push	ecx
	lea	edx, DWORD PTR _iDefenderDamageInflicted$[esp+208]
	push	edx
	lea	eax, DWORD PTR $T230522[esp+212]
	push	eax
	lea	ecx, DWORD PTR $T230523[esp+216]
	push	OFFSET $SG222997
	push	ecx
	call	??$GetLocalizedText@PBDHPBDH@@YA?AVCvString@@PBDABQBDABH12@Z ; GetLocalizedText<char const *,int,char const *,int>
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 14		; 0000000eH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T230523[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2262 : 						GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkAttacker->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+200]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi+40]
	push	0
	mov	edx, DWORD PTR [ebp]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	push	ebx
	mov	ecx, ebp
	call	edx
	mov	ebp, DWORD PTR _iActivePlayerID$222913[esp+200]
$LN343@ResolveAir@2:

; 2263 : 					}
; 2264 : 					if(iActivePlayerID == pkDefender->getOwner())

	cmp	ebp, DWORD PTR [esi+40]
	jne	$LN5@ResolveAir@2

; 2265 : 					{
; 2266 : 						strBuffer = GetLocalizedText("TXT_KEY_MISC_ENEMY_UNIT_WITHDRAW", pkAttacker->getNameKey(), iDefenderDamageInflicted, pkDefender->getNameKey(), iAttackerDamageInflicted);

	mov	ecx, esi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	ecx, edi
	mov	DWORD PTR $T230524[esp+200], eax
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	mov	DWORD PTR $T230525[esp+200], eax
	lea	eax, DWORD PTR _iAttackerDamageInflicted$[esp+200]
	push	eax
	lea	ecx, DWORD PTR $T230524[esp+204]
	push	ecx
	lea	edx, DWORD PTR _iDefenderDamageInflicted$[esp+208]
	push	edx
	lea	eax, DWORD PTR $T230525[esp+212]
	push	eax
	lea	ecx, DWORD PTR $T230526[esp+216]
	push	OFFSET $SG223002
	push	ecx
	call	??$GetLocalizedText@PBDHPBDH@@YA?AVCvString@@PBDABQBDABH12@Z ; GetLocalizedText<char const *,int,char const *,int>
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 15		; 0000000fH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T230526[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2267 : 						GC.GetEngineUserInterface()->AddMessage(uiParentEventID, pkDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pkTargetPlot->getX(), pkTargetPlot->getY()*/);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+200]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi+40]
	push	0
	mov	edx, DWORD PTR [ebp]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	push	ebx
	mov	ecx, ebp
	call	edx
$LN5@ResolveAir@2:

; 2268 : 					}
; 2269 : 
; 2270 : #ifndef AUI_UNIT_TEST_PROMOTION_READY_MOVED
; 2271 : 					pkDefender->testPromotionReady();

	mov	ecx, esi
	call	?testPromotionReady@CvUnit@@QAEXXZ	; CvUnit::testPromotionReady

; 2272 : 					pkAttacker->testPromotionReady();

	mov	ecx, edi
	call	?testPromotionReady@CvUnit@@QAEXXZ	; CvUnit::testPromotionReady

; 2273 : #endif
; 2274 : 				}
; 2275 : 			}
; 2276 : 		}
; 2277 : 	}
; 2278 : 	else

	jmp	$LN348@ResolveAir@2
$LN27@ResolveAir@2:

; 2279 : 		bDefenderDead = true;

	mov	BYTE PTR _bDefenderDead$[esp+200], 1

; 2280 : 
; 2281 : 	// Clean up some stuff
; 2282 : 	if(pkDefender)

	jmp	$LN3@ResolveAir@2
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$2:
	lea	ecx, DWORD PTR _pAttacker$222917[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$3:
	lea	ecx, DWORD PTR $T230485[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$4:
	lea	ecx, DWORD PTR $T230490[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$6:
	lea	ecx, DWORD PTR _pAttacker$222936[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$7:
	lea	ecx, DWORD PTR $T230496[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$8:
	lea	ecx, DWORD PTR $T230501[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$10:
	lea	ecx, DWORD PTR _pDefender$222955[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$11:
	lea	ecx, DWORD PTR $T230506[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$12:
	lea	ecx, DWORD PTR $T230509[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$13:
	lea	ecx, DWORD PTR $T230513[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$14:
	lea	ecx, DWORD PTR $T230516[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$15:
	lea	ecx, DWORD PTR $T230520[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$16:
	lea	ecx, DWORD PTR _strSummary$222988[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$17:
	lea	ecx, DWORD PTR $T230523[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z$18:
	lea	ecx, DWORD PTR $T230526[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z:
	mov	eax, OFFSET __ehfuncinfo$?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ENDP ; CvUnitCombat::ResolveAirSweep
PUBLIC	??1?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FFastSmallFixedList<IDInfo,25,1,297,0>::~FFastSmallFixedList<IDInfo,25,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ PROC ; FFastSmallFixedList<IDInfo,25,1,297,0>::~FFastSmallFixedList<IDInfo,25,1,297,0>, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@FFastSmall
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@FFastSmall:
	ret	0
??1?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FFastSmallFixedList<IDInfo,25,1,297,0>::~FFastSmallFixedList<IDInfo,25,1,297,0>
_TEXT	ENDS
PUBLIC	?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveCombat
EXTRN	??3CvDllUnit@@SAXPAX@Z:PROC			; CvDllUnit::operator delete
EXTRN	?AddArchaeologicalRecord@CvPlot@@QAEXW4GreatWorkArtifactClass@@W4PlayerTypes@@1@Z:PROC ; CvPlot::AddArchaeologicalRecord
EXTRN	?getARTIFACT_BATTLE_MELEE@CvTypes@@YA?BW4GreatWorkArtifactClass@@XZ:PROC ; CvTypes::getARTIFACT_BATTLE_MELEE
EXTRN	?getARTIFACT_BATTLE_RANGED@CvTypes@@YA?BW4GreatWorkArtifactClass@@XZ:PROC ; CvTypes::getARTIFACT_BATTLE_RANGED
EXTRN	?getAttackIsRanged@CvCombatInfo@@QBE_NXZ:PROC	; CvCombatInfo::getAttackIsRanged
EXTRN	?getAttackIsAirSweep@CvCombatInfo@@QBE_NXZ:PROC	; CvCombatInfo::getAttackIsAirSweep
EXTRN	?getAttackIsBombingMission@CvCombatInfo@@QBE_NXZ:PROC ; CvCombatInfo::getAttackIsBombingMission
EXTRN	?getAttackIsNuclear@CvCombatInfo@@QBE_NXZ:PROC	; CvCombatInfo::getAttackIsNuclear
EXTRN	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z:PROC ; CvUnit::isInvisible
EXTRN	??0CvDllUnit@@QAE@PAVCvUnit@@@Z:PROC		; CvDllUnit::CvDllUnit
EXTRN	??2CvDllUnit@@SAPAXI@Z:PROC			; CvDllUnit::operator new
EXTRN	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ:PROC ; CvGame::getActiveTeam
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__ehfuncinfo$?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z$5
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
xdata$x	ENDS
;	COMDAT ?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z
_TEXT	SEGMENT
_eActiveTeam$ = -28					; size = 4
_eAttackingPlayer$ = -24				; size = 4
tv582 = -20						; size = 4
tv580 = -20						; size = 4
tv578 = -20						; size = 4
$T231226 = -20						; size = 4
$T231234 = -16						; size = 4
_pDllUnit$223430 = -16					; size = 4
$T231230 = -16						; size = 4
_pDllUnit$223422 = -16					; size = 4
_pDllUnit$223414 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_kInfo$ = 8						; size = 4
_uiParentEventID$ = 12					; size = 4
?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z PROC ; CvUnitCombat::ResolveCombat, COMDAT

; 2837 : {

	push	-1
	push	__ehhandler$?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi

; 2838 : 	PlayerTypes eAttackingPlayer = NO_PLAYER;
; 2839 : 	// Restore visibility
; 2840 : 	CvUnit* pAttacker = kInfo.getUnit(BATTLE_UNIT_ATTACKER);

	mov	esi, DWORD PTR _kInfo$[esp+36]
	push	edi
	xor	ebx, ebx
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR _eAttackingPlayer$[esp+48], -1
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit

; 2841 : 
; 2842 : 	const TeamTypes eActiveTeam = GC.getGame().getActiveTeam();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, eax
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	DWORD PTR _eActiveTeam$[esp+44], eax

; 2843 : 
; 2844 : 	if(pAttacker)

	cmp	edi, ebx
	je	$LN103@ResolveCom

; 2845 : 	{
; 2846 : 		eAttackingPlayer = pAttacker->getOwner();

	mov	eax, DWORD PTR [edi+40]

; 2847 : 		auto_ptr<ICvUnit1> pDllUnit(new CvDllUnit(pAttacker));

	push	12					; 0000000cH
	mov	DWORD PTR _eAttackingPlayer$[esp+48], eax
	call	??2CvDllUnit@@SAPAXI@Z			; CvDllUnit::operator new
	add	esp, 4
	mov	DWORD PTR $T231226[esp+44], eax
	mov	DWORD PTR __$EHRec$[esp+52], ebx
	cmp	eax, ebx
	je	SHORT $LN22@ResolveCom
	push	edi
	mov	ecx, eax
	call	??0CvDllUnit@@QAE@PAVCvUnit@@@Z		; CvDllUnit::CvDllUnit
	mov	ebx, eax
$LN22@ResolveCom:
	mov	DWORD PTR _pDllUnit$223414[esp+44], ebx

; 2848 : 		gDLL->GameplayUnitVisibility(pDllUnit.get(), !pAttacker->isInvisible(eActiveTeam, false));

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ebp]
	push	ecx
	mov	ecx, DWORD PTR _eActiveTeam$[esp+48]
	mov	DWORD PTR [esp], 1056964608		; 3f000000H
	push	0
	push	1
	push	0
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+72], 1
	mov	DWORD PTR tv582[esp+64], eax
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	test	al, al
	sete	dl
	movzx	eax, dl
	push	eax
	mov	eax, DWORD PTR tv582[esp+56]
	mov	edx, DWORD PTR [eax+640]
	push	ebx
	mov	ecx, ebp
	call	edx

; 2849 : 	}

	mov	DWORD PTR __$EHRec$[esp+52], -1
	test	ebx, ebx
	je	SHORT $LN103@ResolveCom
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	push	ebx
	call	ecx
$LN103@ResolveCom:

; 2850 : 
; 2851 : 	CvUnit* pDefender = kInfo.getUnit(BATTLE_UNIT_DEFENDER);

	push	1
	mov	ecx, esi
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit
	mov	ebp, eax

; 2852 : 	if(pDefender)

	test	ebp, ebp
	je	$LN102@ResolveCom

; 2853 : 	{
; 2854 : 		auto_ptr<ICvUnit1> pDllUnit(new CvDllUnit(pDefender));

	push	12					; 0000000cH
	call	??2CvDllUnit@@SAPAXI@Z			; CvDllUnit::operator new
	add	esp, 4
	mov	DWORD PTR $T231230[esp+44], eax
	mov	DWORD PTR __$EHRec$[esp+52], 2
	test	eax, eax
	je	SHORT $LN24@ResolveCom
	push	ebp
	mov	ecx, eax
	call	??0CvDllUnit@@QAE@PAVCvUnit@@@Z		; CvDllUnit::CvDllUnit
	mov	edi, eax
	jmp	SHORT $LN25@ResolveCom
$LN24@ResolveCom:
	xor	edi, edi
$LN25@ResolveCom:
	mov	DWORD PTR _pDllUnit$223422[esp+44], edi

; 2855 : 		gDLL->GameplayUnitVisibility(pDllUnit.get(), !pDefender->isInvisible(eActiveTeam, false));

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR _eActiveTeam$[esp+44]
	mov	eax, DWORD PTR [ebx]
	push	ecx
	mov	DWORD PTR [esp], 1056964608		; 3f000000H
	push	0
	push	1
	push	0
	push	edx
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+72], 3
	mov	DWORD PTR tv580[esp+64], eax
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	test	al, al
	sete	al
	movzx	ecx, al
	mov	eax, DWORD PTR tv580[esp+52]
	mov	edx, DWORD PTR [eax+640]
	push	ecx
	push	edi
	mov	ecx, ebx
	call	edx

; 2856 : 	}

	mov	DWORD PTR __$EHRec$[esp+52], -1
	test	edi, edi
	je	SHORT $LN102@ResolveCom
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	call	ecx
$LN102@ResolveCom:

; 2857 : 
; 2858 : 	CvUnit* pDefenderSupport = kInfo.getUnit(BATTLE_UNIT_INTERCEPTOR);

	push	2
	mov	ecx, esi
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit
	mov	ebp, eax

; 2859 : 	if(pDefenderSupport)

	test	ebp, ebp
	je	$LN101@ResolveCom

; 2860 : 	{
; 2861 : 		auto_ptr<ICvUnit1> pDllUnit(new CvDllUnit(pDefenderSupport));

	push	12					; 0000000cH
	call	??2CvDllUnit@@SAPAXI@Z			; CvDllUnit::operator new
	add	esp, 4
	mov	DWORD PTR $T231234[esp+44], eax
	mov	DWORD PTR __$EHRec$[esp+52], 4
	test	eax, eax
	je	SHORT $LN26@ResolveCom
	push	ebp
	mov	ecx, eax
	call	??0CvDllUnit@@QAE@PAVCvUnit@@@Z		; CvDllUnit::CvDllUnit
	mov	edi, eax
	jmp	SHORT $LN27@ResolveCom
$LN26@ResolveCom:
	xor	edi, edi
$LN27@ResolveCom:
	mov	DWORD PTR _pDllUnit$223430[esp+44], edi

; 2862 : 		gDLL->GameplayUnitVisibility(pDllUnit.get(), !pDefenderSupport->isInvisible(eActiveTeam, false));

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR _eActiveTeam$[esp+44]
	mov	eax, DWORD PTR [ebx]
	push	ecx
	mov	DWORD PTR [esp], 1056964608		; 3f000000H
	push	0
	push	1
	push	0
	push	edx
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+72], 5
	mov	DWORD PTR tv578[esp+64], eax
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	test	al, al
	sete	al
	movzx	ecx, al
	mov	eax, DWORD PTR tv578[esp+52]
	mov	edx, DWORD PTR [eax+640]
	push	ecx
	push	edi
	mov	ecx, ebx
	call	edx

; 2863 : 	}

	mov	DWORD PTR __$EHRec$[esp+52], -1
	test	edi, edi
	je	SHORT $LN101@ResolveCom
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	call	ecx
$LN101@ResolveCom:

; 2864 : 	// Nuclear Mission
; 2865 : 	if(kInfo.getAttackIsNuclear())

	mov	ecx, esi
	call	?getAttackIsNuclear@CvCombatInfo@@QBE_NXZ ; CvCombatInfo::getAttackIsNuclear
	test	al, al
	je	SHORT $LN16@ResolveCom

; 2866 : 	{
; 2867 : 		ResolveNuclearCombat(kInfo, uiParentEventID);

	mov	edx, DWORD PTR _uiParentEventID$[esp+40]
	push	edx
	push	esi
	call	?ResolveNuclearCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveNuclearCombat
	add	esp, 8
	jmp	$LN104@ResolveCom
$LN16@ResolveCom:

; 2868 : 	}
; 2869 : 
; 2870 : 	// Bombing Mission
; 2871 : 	else if(kInfo.getAttackIsBombingMission())

	mov	ecx, esi
	call	?getAttackIsBombingMission@CvCombatInfo@@QBE_NXZ ; CvCombatInfo::getAttackIsBombingMission
	test	al, al
	je	SHORT $LN14@ResolveCom

; 2872 : 	{
; 2873 : 		ResolveAirUnitVsCombat(kInfo, uiParentEventID);

	mov	eax, DWORD PTR _uiParentEventID$[esp+40]
	push	eax
	push	esi
	call	?ResolveAirUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveAirUnitVsCombat
	add	esp, 8
	jmp	$LN104@ResolveCom
$LN14@ResolveCom:

; 2874 : 	}
; 2875 : 
; 2876 : 	// Air Sweep Mission
; 2877 : 	else if(kInfo.getAttackIsAirSweep())

	mov	ecx, esi
	call	?getAttackIsAirSweep@CvCombatInfo@@QBE_NXZ ; CvCombatInfo::getAttackIsAirSweep
	test	al, al
	je	SHORT $LN12@ResolveCom

; 2878 : 	{
; 2879 : 		ResolveAirSweep(kInfo, uiParentEventID);

	mov	ecx, DWORD PTR _uiParentEventID$[esp+40]
	push	ecx
	push	esi
	call	?ResolveAirSweep@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveAirSweep
	add	esp, 8
	jmp	$LN104@ResolveCom
$LN12@ResolveCom:

; 2880 : 	}
; 2881 : 
; 2882 : 	// Ranged Attack
; 2883 : 	else if(kInfo.getAttackIsRanged())

	mov	ecx, esi
	call	?getAttackIsRanged@CvCombatInfo@@QBE_NXZ ; CvCombatInfo::getAttackIsRanged

; 2884 : 	{
; 2885 : 		if(kInfo.getUnit(BATTLE_UNIT_ATTACKER))

	mov	ecx, esi
	test	al, al
	je	$LN10@ResolveCom
	push	0
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit
	test	eax, eax
	je	SHORT $LN9@ResolveCom

; 2886 : 		{
; 2887 : 			ResolveRangedUnitVsCombat(kInfo, uiParentEventID);

	mov	edx, DWORD PTR _uiParentEventID$[esp+40]
	push	edx
	push	esi
	call	?ResolveRangedUnitVsCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveRangedUnitVsCombat
	add	esp, 8

; 2888 : 			CvPlot *pPlot = kInfo.getPlot();

	mov	ecx, esi
	call	?getPlot@CvCombatInfo@@QBEPAVCvPlot@@XZ	; CvCombatInfo::getPlot

; 2889 : 			if (kInfo.getUnit(BATTLE_UNIT_ATTACKER) && kInfo.getUnit(BATTLE_UNIT_DEFENDER) && pPlot)

	push	0
	mov	ecx, esi
	mov	ebx, eax
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit
	test	eax, eax
	je	$LN104@ResolveCom
	push	1
	mov	ecx, esi
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit
	test	eax, eax
	je	$LN104@ResolveCom
	test	ebx, ebx
	je	$LN104@ResolveCom

; 2890 : 			{
; 2891 : 				pPlot->AddArchaeologicalRecord(CvTypes::getARTIFACT_BATTLE_RANGED(), kInfo.getUnit(BATTLE_UNIT_ATTACKER)->getOwner(), kInfo.getUnit(BATTLE_UNIT_DEFENDER)->getOwner());

	push	1
	mov	ecx, esi
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit
	mov	edi, DWORD PTR [eax+40]
	push	0
	mov	ecx, esi
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit
	mov	eax, DWORD PTR [eax+40]
	push	edi
	push	eax
	call	?getARTIFACT_BATTLE_RANGED@CvTypes@@YA?BW4GreatWorkArtifactClass@@XZ ; CvTypes::getARTIFACT_BATTLE_RANGED

; 2892 : 			}
; 2893 : 		}
; 2894 : 		else

	jmp	$LN108@ResolveCom
$LN9@ResolveCom:

; 2895 : 		{
; 2896 : 			ResolveRangedCityVsUnitCombat(kInfo, uiParentEventID);

	mov	eax, DWORD PTR _uiParentEventID$[esp+40]
	push	eax
	push	esi
	call	?ResolveRangedCityVsUnitCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveRangedCityVsUnitCombat
	add	esp, 8

; 2897 : 			CvPlot *pPlot = kInfo.getPlot();

	mov	ecx, esi
	call	?getPlot@CvCombatInfo@@QBEPAVCvPlot@@XZ	; CvCombatInfo::getPlot

; 2898 : 			if (kInfo.getCity(BATTLE_UNIT_ATTACKER) && kInfo.getUnit(BATTLE_UNIT_DEFENDER) && pPlot)

	push	0
	mov	ecx, esi
	mov	ebx, eax
	call	?getCity@CvCombatInfo@@QBEPAVCvCity@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getCity
	test	eax, eax
	je	$LN104@ResolveCom
	push	1
	mov	ecx, esi
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit
	test	eax, eax
	je	$LN104@ResolveCom
	test	ebx, ebx
	je	$LN104@ResolveCom

; 2899 : 			{
; 2900 : 				pPlot->AddArchaeologicalRecord(CvTypes::getARTIFACT_BATTLE_RANGED(), kInfo.getCity(BATTLE_UNIT_ATTACKER)->getOwner(), kInfo.getUnit(BATTLE_UNIT_DEFENDER)->getOwner());

	push	1
	mov	ecx, esi
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit
	mov	edi, DWORD PTR [eax+40]
	push	0
	mov	ecx, esi
	call	?getCity@CvCombatInfo@@QBEPAVCvCity@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getCity
	mov	eax, DWORD PTR [eax+84]
	push	edi
	push	eax
	call	?getARTIFACT_BATTLE_RANGED@CvTypes@@YA?BW4GreatWorkArtifactClass@@XZ ; CvTypes::getARTIFACT_BATTLE_RANGED

; 2901 : 			}
; 2902 : 		}
; 2903 : 	}
; 2904 : 
; 2905 : 	// Melee Attack
; 2906 : 	else

	jmp	SHORT $LN108@ResolveCom
$LN10@ResolveCom:

; 2907 : 	{
; 2908 : 		if(kInfo.getCity(BATTLE_UNIT_DEFENDER))

	push	1
	call	?getCity@CvCombatInfo@@QBEPAVCvCity@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getCity
	test	eax, eax
	je	SHORT $LN4@ResolveCom

; 2909 : 		{
; 2910 : 			ResolveCityMeleeCombat(kInfo, uiParentEventID);

	mov	ecx, DWORD PTR _uiParentEventID$[esp+40]
	push	ecx
	push	esi
	call	?ResolveCityMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveCityMeleeCombat
	add	esp, 8

; 2911 : 		}
; 2912 : 		else

	jmp	SHORT $LN104@ResolveCom
$LN4@ResolveCom:

; 2913 : 		{
; 2914 : 			ResolveMeleeCombat(kInfo, uiParentEventID);

	mov	edx, DWORD PTR _uiParentEventID$[esp+40]
	push	edx
	push	esi
	call	?ResolveMeleeCombat@CvUnitCombat@@KAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveMeleeCombat
	add	esp, 8

; 2915 : 			CvPlot *pPlot = kInfo.getPlot();

	mov	ecx, esi
	call	?getPlot@CvCombatInfo@@QBEPAVCvPlot@@XZ	; CvCombatInfo::getPlot

; 2916 : 			if (kInfo.getUnit(BATTLE_UNIT_ATTACKER) && kInfo.getUnit(BATTLE_UNIT_DEFENDER) && pPlot)

	push	0
	mov	ecx, esi
	mov	ebx, eax
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit
	test	eax, eax
	je	SHORT $LN104@ResolveCom
	push	1
	mov	ecx, esi
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit
	test	eax, eax
	je	SHORT $LN104@ResolveCom
	test	ebx, ebx
	je	SHORT $LN104@ResolveCom

; 2917 : 			{
; 2918 : 				pPlot->AddArchaeologicalRecord(CvTypes::getARTIFACT_BATTLE_MELEE(), kInfo.getUnit(BATTLE_UNIT_ATTACKER)->getOwner(), kInfo.getUnit(BATTLE_UNIT_DEFENDER)->getOwner());

	push	1
	mov	ecx, esi
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit
	mov	edi, DWORD PTR [eax+40]
	push	0
	mov	ecx, esi
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit
	mov	eax, DWORD PTR [eax+40]
	push	edi
	push	eax
	call	?getARTIFACT_BATTLE_MELEE@CvTypes@@YA?BW4GreatWorkArtifactClass@@XZ ; CvTypes::getARTIFACT_BATTLE_MELEE
$LN108@ResolveCom:
	push	eax
	mov	ecx, ebx
	call	?AddArchaeologicalRecord@CvPlot@@QAEXW4GreatWorkArtifactClass@@W4PlayerTypes@@1@Z ; CvPlot::AddArchaeologicalRecord
$LN104@ResolveCom:

; 2919 : 			}
; 2920 : 		}
; 2921 : 	}
; 2922 : 
; 2923 : 	// Clear popup blocking after combat resolves
; 2924 : 	if(eAttackingPlayer == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	cmp	DWORD PTR _eAttackingPlayer$[esp+28], eax
	jne	SHORT $LN1@ResolveCom

; 2925 : 	{
; 2926 : 		GC.GetEngineUserInterface()->SetDontShowPopups(false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+556]
	push	0
	call	edx
$LN1@ResolveCom:

; 2927 : 	}
; 2928 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	add	esp, 28					; 0000001cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z$0:
	mov	eax, DWORD PTR $T231226[ebp]
	push	eax
	call	??3CvDllUnit@@SAXPAX@Z			; CvDllUnit::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z$1:
	lea	ecx, DWORD PTR _pDllUnit$223414[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__unwindfunclet$?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z$2:
	mov	eax, DWORD PTR $T231230[ebp]
	push	eax
	call	??3CvDllUnit@@SAXPAX@Z			; CvDllUnit::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z$3:
	lea	ecx, DWORD PTR _pDllUnit$223422[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__unwindfunclet$?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z$4:
	mov	eax, DWORD PTR $T231234[ebp]
	push	eax
	call	??3CvDllUnit@@SAXPAX@Z			; CvDllUnit::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z$5:
	lea	ecx, DWORD PTR _pDllUnit$223430[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__ehhandler$?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z:
	mov	eax, OFFSET __ehfuncinfo$?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z ENDP ; CvUnitCombat::ResolveCombat
PUBLIC	?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z ; CvUnitCombat::AttackRanged
EXTRN	??3CvDllCombatInfo@@SAXPAX@Z:PROC		; CvDllCombatInfo::operator delete
EXTRN	?setCombatCity@CvUnit@@QAEXPAVCvCity@@@Z:PROC	; CvUnit::setCombatCity
EXTRN	??0CvDllCombatInfo@@QAE@PAVCvCombatInfo@@@Z:PROC ; CvDllCombatInfo::CvDllCombatInfo
EXTRN	??2CvDllCombatInfo@@SAPAXI@Z:PROC		; CvDllCombatInfo::operator new
EXTRN	?setVisualizeCombat@CvCombatInfo@@QAEX_N@Z:PROC	; CvCombatInfo::setVisualizeCombat
EXTRN	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z:PROC ; CvGlobals::WrapPlotPointer
EXTRN	?isActiveVisible@CvPlot@@QBE_N_N@Z:PROC		; CvPlot::isActiveVisible
EXTRN	??0CvCombatInfo@@QAE@XZ:PROC			; CvCombatInfo::CvCombatInfo
EXTRN	?airStrikeTarget@CvUnit@@IBEPAV1@AAVCvPlot@@_N@Z:PROC ; CvUnit::airStrikeTarget
EXTRN	?setFortifyTurns@CvUnit@@QAEXH@Z:PROC		; CvUnit::setFortifyTurns
EXTRN	?setMadeAttack@CvUnit@@QAEX_N@Z:PROC		; CvUnit::setMadeAttack
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__ehfuncinfo$?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
xdata$x	ENDS
;	COMDAT ?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z
_TEXT	SEGMENT
_bDoImmediate$ = -2769					; size = 1
$T231423 = -2768					; size = 4
_pDllCombatInfo$223709 = -2768				; size = 4
_pDllPlot$223701 = -2768				; size = 4
$T231417 = -2768					; size = 4
_pDllCombatInfo$223691 = -2768				; size = 4
_pDllPlot$223683 = -2768				; size = 4
_isTargetVisibleToActivePlayer$223680 = -2764		; size = 1
$T231420 = -2764					; size = 4
_isTargetVisibleToActivePlayer$223698 = -2760		; size = 1
$T231414 = -2760					; size = 4
_kCombatInfo$223677 = -2756				; size = 1372
_kCombatInfo$223695 = -1384				; size = 1372
__$EHRec$ = -12						; size = 12
_kAttacker$ = 8						; size = 4
_iX$ = 12						; size = 4
_iY$ = 16						; size = 4
___formal$ = 20						; size = 4
?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z PROC ; CvUnitCombat::AttackRanged, COMDAT

; 3153 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 2760				; 00000ac8H
	push	ebx
	push	ebp
	push	esi

; 3154 : 	//VALIDATE_OBJECT
; 3155 : 	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	mov	esi, DWORD PTR _iX$[esp+2780]
	push	edi
	cmp	esi, -2147483647			; 80000001H
	je	$LN146@AttackRang
	mov	ebp, DWORD PTR _iY$[esp+2784]
	cmp	ebp, -2147483647			; 80000001H
	je	SHORT $LN146@AttackRang
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	al, al
	je	SHORT $LN147@AttackRang
	test	esi, esi
	jge	SHORT $LN45@AttackRang
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN147@AttackRang
$LN45@AttackRang:
	cmp	esi, ecx
	jl	SHORT $LN147@AttackRang
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN147@AttackRang:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN149@AttackRang
	test	ebp, ebp
	jge	SHORT $LN55@AttackRang
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN57@AttackRang
$LN55@AttackRang:
	cmp	ebp, edi
	jl	SHORT $LN149@AttackRang
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN57@AttackRang
$LN149@AttackRang:
	mov	edx, ebp
$LN57@AttackRang:
	test	esi, esi
	jl	SHORT $LN146@AttackRang
	cmp	esi, ecx
	jge	SHORT $LN146@AttackRang
	test	edx, edx
	jl	SHORT $LN146@AttackRang
	cmp	edx, edi
	jge	SHORT $LN146@AttackRang
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	mov	edi, ecx

; 3156 : 	ATTACK_RESULT eResult = ATTACK_ABORTED;
; 3157 : 
; 3158 : 	CvAssertMsg(kAttacker.getDomainType() != DOMAIN_AIR, "Air units should not use AttackRanged, they should just MoveTo the target");
; 3159 : 
; 3160 : 	if(NULL == pPlot)

	jne	SHORT $LN16@AttackRang
$LN146@AttackRang:

; 3161 : 	{
; 3162 : 		return eResult;

	xor	eax, eax
	jmp	$LN17@AttackRang
$LN16@AttackRang:

; 3163 : 	}
; 3164 : 
; 3165 : 	if (!kAttacker.isRangedSupportFire())

	mov	esi, DWORD PTR _kAttacker$[esp+2784]
	mov	ecx, esi
	call	?isRangedSupportFire@CvUnit@@QBE_NXZ	; CvUnit::isRangedSupportFire
	test	al, al
	jne	SHORT $LN148@AttackRang

; 3166 : 	{
; 3167 : 		if(!kAttacker.canRangeStrikeAt(iX, iY))

	mov	eax, DWORD PTR _iX$[esp+2784]
	push	1
	push	1
	push	ebp
	push	eax
	mov	ecx, esi
	call	?canRangeStrikeAt@CvUnit@@QBE_NHH_N0@Z	; CvUnit::canRangeStrikeAt
	test	al, al

; 3168 : 		{
; 3169 : 			return eResult;

	je	SHORT $LN146@AttackRang

; 3170 : 		}
; 3171 : 
; 3172 : 		if(GC.getRANGED_ATTACKS_USE_MOVES() == 0)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6900, 0
	jne	SHORT $LN13@AttackRang

; 3173 : 		{
; 3174 : 			kAttacker.setMadeAttack(true);

	push	1
	mov	ecx, esi
	call	?setMadeAttack@CvUnit@@QAEX_N@Z		; CvUnit::setMadeAttack
$LN13@AttackRang:

; 3175 : 		}
; 3176 : 		kAttacker.changeMoves(-GC.getMOVE_DENOMINATOR());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	neg	ecx
	push	ecx
	mov	ecx, esi
	call	?changeMoves@CvUnit@@QAEXH@Z		; CvUnit::changeMoves
$LN148@AttackRang:

; 3177 : 	}
; 3178 : 
; 3179 : 	// Unit that attacks loses his Fort bonus
; 3180 : 	kAttacker.setFortifyTurns(0);

	push	0
	mov	ecx, esi
	call	?setFortifyTurns@CvUnit@@QAEXH@Z	; CvUnit::setFortifyTurns

; 3181 : 
; 3182 : 	// New test feature - attacking/range striking uses up all moves for most Units
; 3183 : #ifdef NQ_UNIT_TURN_ENDS_ON_FINAL_ATTACK
; 3184 : 	if(!kAttacker.canMoveAfterAttacking() && !kAttacker.isRangedSupportFire() && kAttacker.isOutOfAttacks())

	mov	ecx, esi
	call	?canMoveAfterAttacking@CvUnit@@QBE_NXZ	; CvUnit::canMoveAfterAttacking
	test	al, al
	jne	SHORT $LN150@AttackRang
	mov	ecx, esi
	call	?isRangedSupportFire@CvUnit@@QBE_NXZ	; CvUnit::isRangedSupportFire
	test	al, al
	jne	SHORT $LN150@AttackRang
	mov	ecx, esi
	call	?isOutOfAttacks@CvUnit@@QBE_NXZ		; CvUnit::isOutOfAttacks
	test	al, al
	je	SHORT $LN150@AttackRang

; 3185 : #else
; 3186 : 	if(!kAttacker.canMoveAfterAttacking() && !kAttacker.isRangedSupportFire())
; 3187 : #endif
; 3188 : 	{
; 3189 : 		kAttacker.finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3190 : 		GC.GetEngineUserInterface()->changeCycleSelectionCounter(1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+224]
	push	1
	call	eax
$LN150@AttackRang:

; 3191 : 	}
; 3192 : 
; 3193 : 	kAttacker.SetAutomateType(NO_AUTOMATE);

	push	-1
	mov	ecx, esi
	call	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z ; CvUnit::SetAutomateType

; 3194 : 
; 3195 : 	bool bDoImmediate = CvPreGame::quickCombat();

	call	?quickCombat@CvPreGame@@YA_NXZ		; CvPreGame::quickCombat
	mov	BYTE PTR _bDoImmediate$[esp+2788], al

; 3196 : 	// Range-striking a Unit
; 3197 : 	if(!pPlot->isCity())

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	jl	SHORT $LN145@AttackRang
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN145@AttackRang
	mov	ecx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	$LN11@AttackRang
$LN145@AttackRang:

; 3198 : 	{
; 3199 : 		CvUnit* pDefender = kAttacker.airStrikeTarget(*pPlot, true);

	push	1
	push	edi
	mov	ecx, esi
	call	?airStrikeTarget@CvUnit@@IBEPAV1@AAVCvPlot@@_N@Z ; CvUnit::airStrikeTarget
	mov	ebp, eax

; 3200 : 		CvAssert(pDefender != NULL);
; 3201 : 		if(!pDefender) return ATTACK_ABORTED;

	test	ebp, ebp
	je	$LN146@AttackRang

; 3202 : 
; 3203 : 		pDefender->SetAutomateType(NO_AUTOMATE);

	push	-1
	mov	ecx, ebp
	call	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z ; CvUnit::SetAutomateType

; 3204 : 
; 3205 : 		CvCombatInfo kCombatInfo;

	lea	ecx, DWORD PTR _kCombatInfo$223677[esp+2788]
	call	??0CvCombatInfo@@QAE@XZ			; CvCombatInfo::CvCombatInfo

; 3206 : 		CvUnitCombat::GenerateRangedCombatInfo(kAttacker, pDefender, *pPlot, &kCombatInfo);

	lea	edx, DWORD PTR _kCombatInfo$223677[esp+2788]
	push	edx
	push	edi
	push	ebp
	push	esi
	call	?GenerateRangedCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z ; CvUnitCombat::GenerateRangedCombatInfo

; 3207 : 		CvAssertMsg(!kAttacker.isDelayedDeath() && !pDefender->isDelayedDeath(), "Trying to battle and one of the units is already dead!");
; 3208 : 
; 3209 : 		uint uiParentEventID = 0;

	xor	ebx, ebx
	add	esp, 16					; 00000010H

; 3210 : 		if(!bDoImmediate)

	cmp	BYTE PTR _bDoImmediate$[esp+2788], bl
	jne	$LN9@AttackRang

; 3211 : 		{
; 3212 : 			// Center camera here!
; 3213 : 			bool isTargetVisibleToActivePlayer = pPlot->isActiveVisible(false);

	push	ebx
	mov	ecx, edi
	call	?isActiveVisible@CvPlot@@QBE_N_N@Z	; CvPlot::isActiveVisible
	mov	BYTE PTR _isTargetVisibleToActivePlayer$223680[esp+2788], al

; 3214 : 			if(isTargetVisibleToActivePlayer)

	test	al, al
	je	SHORT $LN99@AttackRang

; 3215 : 			{
; 3216 : 				auto_ptr<ICvPlot1> pDllPlot = GC.WrapPlotPointer(pPlot);

	push	edi
	lea	eax, DWORD PTR $T231414[esp+2792]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ; CvGlobals::WrapPlotPointer
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR _pDllPlot$223683[esp+2788], edi
	mov	eax, DWORD PTR $T231414[esp+2788]
	mov	DWORD PTR __$EHRec$[esp+2796], ebx
	test	eax, eax
	je	SHORT $LN90@AttackRang
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN90@AttackRang:

; 3217 : 				GC.GetEngineUserInterface()->lookAt(pDllPlot.get(), CAMERALOOKAT_NORMAL);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+272]
	push	0
	push	edi
	call	edx

; 3218 : 			}

	mov	DWORD PTR __$EHRec$[esp+2796], -1
	test	edi, edi
	je	SHORT $LN99@AttackRang
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	call	ecx
$LN99@AttackRang:

; 3219 : 			kCombatInfo.setVisualizeCombat(isTargetVisibleToActivePlayer);

	mov	edx, DWORD PTR _isTargetVisibleToActivePlayer$223680[esp+2788]
	push	edx
	lea	ecx, DWORD PTR _kCombatInfo$223677[esp+2792]
	call	?setVisualizeCombat@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setVisualizeCombat

; 3220 : 
; 3221 : 			auto_ptr<ICvCombatInfo1> pDllCombatInfo(new CvDllCombatInfo(&kCombatInfo));

	push	12					; 0000000cH
	call	??2CvDllCombatInfo@@SAPAXI@Z		; CvDllCombatInfo::operator new
	add	esp, 4
	mov	DWORD PTR $T231417[esp+2788], eax
	mov	DWORD PTR __$EHRec$[esp+2796], 1
	test	eax, eax
	je	SHORT $LN19@AttackRang
	lea	ecx, DWORD PTR _kCombatInfo$223677[esp+2788]
	push	ecx
	mov	ecx, eax
	call	??0CvDllCombatInfo@@QAE@PAVCvCombatInfo@@@Z ; CvDllCombatInfo::CvDllCombatInfo
	mov	edi, eax
	jmp	SHORT $LN20@AttackRang
$LN19@AttackRang:
	xor	edi, edi
$LN20@AttackRang:
	mov	DWORD PTR _pDllCombatInfo$223691[esp+2788], edi

; 3222 : 			uiParentEventID = gDLL->GameplayUnitCombat(pDllCombatInfo.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+644]
	push	edi
	mov	DWORD PTR __$EHRec$[esp+2800], 2
	call	eax

; 3223 : 
; 3224 : 			// Set the combat units so that other missions do not continue until combat is over.
; 3225 : 			kAttacker.setCombatUnit(pDefender, true);

	push	1
	push	ebp
	mov	ecx, esi
	mov	ebx, eax
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 3226 : 			pDefender->setCombatUnit(&kAttacker, false);

	push	0
	push	esi
	mov	ecx, ebp
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 3227 : 			eResult = ATTACK_QUEUED;

	mov	esi, 2

; 3228 : 		}

	mov	DWORD PTR __$EHRec$[esp+2796], -1
	test	edi, edi
	je	SHORT $LN7@AttackRang
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+4]
	push	edi
	call	edx

; 3231 : 
; 3232 : 		ResolveCombat(kCombatInfo, uiParentEventID);

	lea	eax, DWORD PTR _kCombatInfo$223677[esp+2788]

; 3233 : 	}
; 3234 : 	// Range-striking a City
; 3235 : 	else

	jmp	$LN152@AttackRang
$LN9@AttackRang:

; 3229 : 		else
; 3230 : 			eResult = ATTACK_COMPLETED;

	mov	esi, 1
$LN7@AttackRang:

; 3231 : 
; 3232 : 		ResolveCombat(kCombatInfo, uiParentEventID);

	lea	eax, DWORD PTR _kCombatInfo$223677[esp+2788]

; 3233 : 	}
; 3234 : 	// Range-striking a City
; 3235 : 	else

	jmp	$LN152@AttackRang
$LN11@AttackRang:

; 3236 : 	{
; 3237 : 		if (kAttacker.isRangedSupportFire())

	mov	ecx, esi
	call	?isRangedSupportFire@CvUnit@@QBE_NXZ	; CvUnit::isRangedSupportFire
	test	al, al

; 3238 : 		{
; 3239 : 			return eResult;

	jne	$LN146@AttackRang

; 3240 : 		}
; 3241 : 
; 3242 : 		CvCombatInfo kCombatInfo;

	lea	ecx, DWORD PTR _kCombatInfo$223695[esp+2788]
	call	??0CvCombatInfo@@QAE@XZ			; CvCombatInfo::CvCombatInfo

; 3243 : 		GenerateRangedCombatInfo(kAttacker, NULL, *pPlot, &kCombatInfo);

	lea	ecx, DWORD PTR _kCombatInfo$223695[esp+2788]
	push	ecx
	push	edi
	push	0
	push	esi
	call	?GenerateRangedCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z ; CvUnitCombat::GenerateRangedCombatInfo

; 3244 : 		CvAssertMsg(!kAttacker.isDelayedDeath(), "Trying to battle and the attacker is already dead!");
; 3245 : 
; 3246 : 		uint uiParentEventID = 0;

	xor	ebx, ebx
	add	esp, 16					; 00000010H

; 3247 : 		if(!bDoImmediate)

	cmp	BYTE PTR _bDoImmediate$[esp+2788], bl
	jne	$LN4@AttackRang

; 3248 : 		{
; 3249 : 			// Center camera here!
; 3250 : 			bool isTargetVisibleToActivePlayer = pPlot->isActiveVisible(false);

	push	ebx
	mov	ecx, edi
	call	?isActiveVisible@CvPlot@@QBE_N_N@Z	; CvPlot::isActiveVisible
	mov	BYTE PTR _isTargetVisibleToActivePlayer$223698[esp+2788], al

; 3251 : 			if(isTargetVisibleToActivePlayer)

	test	al, al
	je	SHORT $LN130@AttackRang

; 3252 : 			{
; 3253 : 				auto_ptr<ICvPlot1> pDllPlot = GC.WrapPlotPointer(pPlot);

	push	edi
	lea	edx, DWORD PTR $T231420[esp+2792]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ; CvGlobals::WrapPlotPointer
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR _pDllPlot$223701[esp+2788], ebp
	mov	eax, DWORD PTR $T231420[esp+2788]
	mov	DWORD PTR __$EHRec$[esp+2796], 3
	test	eax, eax
	je	SHORT $LN121@AttackRang
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN121@AttackRang:

; 3254 : 				GC.GetEngineUserInterface()->lookAt(pDllPlot.get(), CAMERALOOKAT_NORMAL);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+272]
	push	0
	push	ebp
	call	edx

; 3255 : 			}

	mov	DWORD PTR __$EHRec$[esp+2796], -1
	test	ebp, ebp
	je	SHORT $LN130@AttackRang
	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ebp
	call	ecx
$LN130@AttackRang:

; 3256 : 
; 3257 : 			kCombatInfo.setVisualizeCombat(isTargetVisibleToActivePlayer);

	mov	edx, DWORD PTR _isTargetVisibleToActivePlayer$223698[esp+2788]
	push	edx
	lea	ecx, DWORD PTR _kCombatInfo$223695[esp+2792]
	call	?setVisualizeCombat@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setVisualizeCombat

; 3258 : 
; 3259 : 			auto_ptr<ICvCombatInfo1> pDllCombatInfo(new CvDllCombatInfo(&kCombatInfo));

	push	12					; 0000000cH
	call	??2CvDllCombatInfo@@SAPAXI@Z		; CvDllCombatInfo::operator new
	add	esp, 4
	mov	DWORD PTR $T231423[esp+2788], eax
	mov	DWORD PTR __$EHRec$[esp+2796], 4
	test	eax, eax
	je	SHORT $LN21@AttackRang
	lea	ecx, DWORD PTR _kCombatInfo$223695[esp+2788]
	push	ecx
	mov	ecx, eax
	call	??0CvDllCombatInfo@@QAE@PAVCvCombatInfo@@@Z ; CvDllCombatInfo::CvDllCombatInfo
	mov	ebp, eax
	jmp	SHORT $LN22@AttackRang
$LN21@AttackRang:
	xor	ebp, ebp
$LN22@AttackRang:
	mov	DWORD PTR _pDllCombatInfo$223709[esp+2788], ebp

; 3260 : 			uiParentEventID = gDLL->GameplayCityCombat(pDllCombatInfo.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+668]
	push	ebp
	mov	DWORD PTR __$EHRec$[esp+2800], 5
	call	eax

; 3261 : 
; 3262 : 			CvCity* pkDefender = pPlot->getPlotCity();

	mov	ecx, edi
	mov	ebx, eax
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	edi, eax

; 3263 : 			kAttacker.setCombatCity(pkDefender);

	push	edi
	mov	ecx, esi
	call	?setCombatCity@CvUnit@@QAEXPAVCvCity@@@Z ; CvUnit::setCombatCity

; 3264 : 			if(pkDefender)

	test	edi, edi
	je	SHORT $LN2@AttackRang

; 3265 : 				pkDefender->setCombatUnit(&kAttacker);

	push	0
	push	esi
	mov	ecx, edi
	call	?setCombatUnit@CvCity@@QAEXPAVCvUnit@@_N@Z ; CvCity::setCombatUnit
$LN2@AttackRang:

; 3266 : 			eResult = ATTACK_QUEUED;

	mov	esi, 2

; 3267 : 		}

	mov	DWORD PTR __$EHRec$[esp+2796], -1
	test	ebp, ebp
	je	SHORT $LN1@AttackRang
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	ebp
	call	edx

; 3268 : 		else

	jmp	SHORT $LN1@AttackRang
$LN4@AttackRang:

; 3269 : 			eResult = ATTACK_COMPLETED;

	mov	esi, 1
$LN1@AttackRang:

; 3270 : 
; 3271 : 		ResolveCombat(kCombatInfo, uiParentEventID);

	lea	eax, DWORD PTR _kCombatInfo$223695[esp+2788]
$LN152@AttackRang:
	push	ebx
	push	eax
	call	?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveCombat
	add	esp, 8

; 3272 : 	}
; 3273 : 
; 3274 : 	return eResult;

	mov	eax, esi
$LN17@AttackRang:

; 3275 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+2788]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 2772				; 00000ad4H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z$1:
	lea	ecx, DWORD PTR _pDllPlot$223683[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__unwindfunclet$?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z$2:
	mov	eax, DWORD PTR $T231417[ebp]
	push	eax
	call	??3CvDllCombatInfo@@SAXPAX@Z		; CvDllCombatInfo::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z$3:
	lea	ecx, DWORD PTR _pDllCombatInfo$223691[ebp]
	jmp	??1?$auto_ptr@VICvCombatInfo1@@@std@@QAE@XZ ; std::auto_ptr<ICvCombatInfo1>::~auto_ptr<ICvCombatInfo1>
__unwindfunclet$?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z$5:
	lea	ecx, DWORD PTR _pDllPlot$223701[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__unwindfunclet$?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z$6:
	mov	eax, DWORD PTR $T231423[ebp]
	push	eax
	call	??3CvDllCombatInfo@@SAXPAX@Z		; CvDllCombatInfo::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z$7:
	lea	ecx, DWORD PTR _pDllCombatInfo$223709[ebp]
	jmp	??1?$auto_ptr@VICvCombatInfo1@@@std@@QAE@XZ ; std::auto_ptr<ICvCombatInfo1>::~auto_ptr<ICvCombatInfo1>
__ehhandler$?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z ENDP ; CvUnitCombat::AttackRanged
PUBLIC	?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z ; CvUnitCombat::AttackAir
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__ehfuncinfo$?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
xdata$x	ENDS
;	COMDAT ?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z
_TEXT	SEGMENT
_isTargetVisibleToActivePlayer$223746 = -2768		; size = 1
_uiParentEventID$223744 = -2768				; size = 4
$T231731 = -2768					; size = 4
_uiParentEventID$223725 = -2768				; size = 4
$T231740 = -2764					; size = 4
_pDllCombatInfo$223757 = -2764				; size = 4
_pDllTargetPlot$223749 = -2764				; size = 4
$T231734 = -2764					; size = 4
_pDllCombatInfo$223738 = -2764				; size = 4
_pDllTargetPlot$223730 = -2764				; size = 4
_isTargetVisibleToActivePlayer$223727 = -2760		; size = 1
$T231737 = -2760					; size = 4
_kCombatInfo$223724 = -2756				; size = 1372
_kCombatInfo$223743 = -1384				; size = 1372
__$EHRec$ = -12						; size = 12
_kAttacker$ = 8						; size = 4
_targetPlot$ = 12					; size = 4
___formal$ = 16						; size = 4
?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z PROC ; CvUnitCombat::AttackAir, COMDAT

; 3279 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 2756				; 00000ac4H
	push	esi

; 3280 : 	//VALIDATE_OBJECT
; 3281 : 	CvAssert(kAttacker.getCombatTimer() == 0);
; 3282 : 
; 3283 : 	CvUnitCombat::ATTACK_RESULT eResult = CvUnitCombat::ATTACK_ABORTED;
; 3284 : 
; 3285 : 	// Can we actually hit the target?
; 3286 : 	if(!kAttacker.canRangeStrikeAt(targetPlot.getX(), targetPlot.getY()))

	mov	esi, DWORD PTR _targetPlot$[esp+2768]
	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR _kAttacker$[esp+2772]
	push	1
	push	1
	push	eax
	push	ecx
	mov	ecx, edi
	call	?canRangeStrikeAt@CvUnit@@QBE_NHH_N0@Z	; CvUnit::canRangeStrikeAt
	test	al, al
	jne	SHORT $LN13@AttackAir
	pop	edi

; 3287 : 	{
; 3288 : 		return eResult;

	xor	eax, eax
	pop	esi

; 3375 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+2768]
	mov	DWORD PTR fs:0, ecx
	add	esp, 2768				; 00000ad0H
	ret	0
$LN13@AttackAir:
	push	ebx
	push	ebp

; 3289 : 	}
; 3290 : 
; 3291 : 	bool bDoImmediate = CvPreGame::quickCombat();

	call	?quickCombat@CvPreGame@@YA_NXZ		; CvPreGame::quickCombat

; 3292 : 	kAttacker.SetAutomateType(NO_AUTOMATE);

	push	-1
	mov	ecx, edi
	mov	bl, al
	call	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z ; CvUnit::SetAutomateType

; 3293 : 	kAttacker.setMadeAttack(true);

	push	1
	mov	ecx, edi
	call	?setMadeAttack@CvUnit@@QAEX_N@Z		; CvUnit::setMadeAttack

; 3294 : 
; 3295 : 	// Bombing a Unit
; 3296 : 	if(!targetPlot.isCity())

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN104@AttackAir
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN104@AttackAir
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	$LN12@AttackAir
$LN104@AttackAir:

; 3297 : 	{
; 3298 : 		CvUnit* pDefender = kAttacker.airStrikeTarget(targetPlot, true);

	push	1
	push	esi
	mov	ecx, edi
	call	?airStrikeTarget@CvUnit@@IBEPAV1@AAVCvPlot@@_N@Z ; CvUnit::airStrikeTarget
	mov	ebp, eax

; 3299 : 		CvAssert(pDefender != NULL);
; 3300 : 		if(!pDefender) return CvUnitCombat::ATTACK_ABORTED;

	test	ebp, ebp
	je	$LN110@AttackAir
$LN11@AttackAir:

; 3301 : 
; 3302 : 		pDefender->SetAutomateType(NO_AUTOMATE);

	push	-1
	mov	ecx, ebp
	call	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z ; CvUnit::SetAutomateType

; 3303 : 
; 3304 : 		CvCombatInfo kCombatInfo;

	lea	ecx, DWORD PTR _kCombatInfo$223724[esp+2784]
	call	??0CvCombatInfo@@QAE@XZ			; CvCombatInfo::CvCombatInfo

; 3305 : 		CvUnitCombat::GenerateAirCombatInfo(kAttacker, pDefender, targetPlot, &kCombatInfo);

	lea	edx, DWORD PTR _kCombatInfo$223724[esp+2784]
	push	edx
	push	esi
	push	ebp
	push	edi
	call	?GenerateAirCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z ; CvUnitCombat::GenerateAirCombatInfo
	add	esp, 16					; 00000010H

; 3306 : 		CvAssertMsg(!kAttacker.isDelayedDeath() && !pDefender->isDelayedDeath(), "Trying to battle and one of the units is already dead!");
; 3307 : 
; 3308 : 		uint uiParentEventID = 0;

	mov	DWORD PTR _uiParentEventID$223725[esp+2784], 0

; 3309 : 		if(!bDoImmediate)

	test	bl, bl
	jne	$LN10@AttackAir

; 3310 : 		{
; 3311 : 			// Center camera here!
; 3312 : 			bool isTargetVisibleToActivePlayer = targetPlot.isActiveVisible(false);

	push	0
	mov	ecx, esi
	call	?isActiveVisible@CvPlot@@QBE_N_N@Z	; CvPlot::isActiveVisible
	mov	BYTE PTR _isTargetVisibleToActivePlayer$223727[esp+2784], al

; 3313 : 			if(isTargetVisibleToActivePlayer)

	test	al, al
	je	SHORT $LN105@AttackAir

; 3314 : 			{
; 3315 : 				auto_ptr<ICvPlot1> pDllTargetPlot = GC.WrapPlotPointer(&targetPlot);

	push	esi
	lea	eax, DWORD PTR $T231731[esp+2788]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ; CvGlobals::WrapPlotPointer
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pDllTargetPlot$223730[esp+2784], esi
	mov	eax, DWORD PTR $T231731[esp+2784]
	mov	DWORD PTR __$EHRec$[esp+2792], 0
	test	eax, eax
	je	SHORT $LN45@AttackAir
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN45@AttackAir:

; 3316 : 				GC.GetEngineUserInterface()->lookAt(pDllTargetPlot.get(), CAMERALOOKAT_NORMAL);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+272]
	push	0
	push	esi
	call	edx

; 3317 : 			}

	mov	DWORD PTR __$EHRec$[esp+2792], -1
	test	esi, esi
	je	SHORT $LN105@AttackAir
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	push	esi
	call	ecx
$LN105@AttackAir:

; 3318 : 			kCombatInfo.setVisualizeCombat(isTargetVisibleToActivePlayer);

	mov	edx, DWORD PTR _isTargetVisibleToActivePlayer$223727[esp+2784]
	push	edx
	lea	ecx, DWORD PTR _kCombatInfo$223724[esp+2788]
	call	?setVisualizeCombat@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setVisualizeCombat

; 3319 : 
; 3320 : 			auto_ptr<ICvCombatInfo1> pDllCombatInfo(new CvDllCombatInfo(&kCombatInfo));

	push	12					; 0000000cH
	call	??2CvDllCombatInfo@@SAPAXI@Z		; CvDllCombatInfo::operator new
	add	esp, 4
	mov	DWORD PTR $T231734[esp+2784], eax
	mov	DWORD PTR __$EHRec$[esp+2792], 1
	test	eax, eax
	je	SHORT $LN16@AttackAir
	lea	ecx, DWORD PTR _kCombatInfo$223724[esp+2784]
	push	ecx
	mov	ecx, eax
	call	??0CvDllCombatInfo@@QAE@PAVCvCombatInfo@@@Z ; CvDllCombatInfo::CvDllCombatInfo
	mov	esi, eax
	jmp	SHORT $LN17@AttackAir
$LN16@AttackAir:
	xor	esi, esi
$LN17@AttackAir:
	mov	DWORD PTR _pDllCombatInfo$223738[esp+2784], esi

; 3321 : 			uiParentEventID = gDLL->GameplayUnitCombat(pDllCombatInfo.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+644]
	push	esi
	mov	DWORD PTR __$EHRec$[esp+2796], 2
	call	eax

; 3322 : 
; 3323 : 			// Set the combat units so that other missions do not continue until combat is over.
; 3324 : 			kAttacker.setCombatUnit(pDefender, true);

	push	1
	push	ebp
	mov	ecx, edi
	mov	DWORD PTR _uiParentEventID$223725[esp+2792], eax
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 3325 : 			pDefender->setCombatUnit(&kAttacker, false);

	push	0
	push	edi
	mov	ecx, ebp
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 3326 : 			CvUnit* pDefenderSupport = kCombatInfo.getUnit(BATTLE_UNIT_INTERCEPTOR);

	push	2
	lea	ecx, DWORD PTR _kCombatInfo$223724[esp+2788]
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit

; 3327 : 			if(pDefenderSupport)

	test	eax, eax
	je	SHORT $LN8@AttackAir

; 3328 : 				pDefenderSupport->setCombatUnit(&kAttacker, false);

	push	0
	push	edi
	mov	ecx, eax
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit
$LN8@AttackAir:

; 3329 : 
; 3330 : 			eResult = ATTACK_QUEUED;

	mov	edi, 2

; 3331 : 		}

	mov	DWORD PTR __$EHRec$[esp+2792], -1
	test	esi, esi
	je	SHORT $LN106@AttackAir
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	call	edx

; 3334 : 
; 3335 : 		ResolveCombat(kCombatInfo, uiParentEventID);

	mov	eax, DWORD PTR _uiParentEventID$223725[esp+2784]
	push	eax
	lea	ecx, DWORD PTR _kCombatInfo$223724[esp+2788]
	push	ecx

; 3336 : 	}
; 3337 : 	// Bombing a City
; 3338 : 	else

	jmp	$LN112@AttackAir
$LN10@AttackAir:

; 3332 : 		else
; 3333 : 			eResult = ATTACK_COMPLETED;

	mov	edi, 1
$LN106@AttackAir:

; 3334 : 
; 3335 : 		ResolveCombat(kCombatInfo, uiParentEventID);

	mov	eax, DWORD PTR _uiParentEventID$223725[esp+2784]
	push	eax
	lea	ecx, DWORD PTR _kCombatInfo$223724[esp+2788]
	push	ecx

; 3336 : 	}
; 3337 : 	// Bombing a City
; 3338 : 	else

	jmp	$LN112@AttackAir
$LN12@AttackAir:

; 3339 : 	{
; 3340 : 		CvCombatInfo kCombatInfo;

	lea	ecx, DWORD PTR _kCombatInfo$223743[esp+2784]
	call	??0CvCombatInfo@@QAE@XZ			; CvCombatInfo::CvCombatInfo

; 3341 : 		GenerateAirCombatInfo(kAttacker, NULL, targetPlot, &kCombatInfo);

	lea	edx, DWORD PTR _kCombatInfo$223743[esp+2784]
	push	edx
	push	esi
	push	0
	push	edi
	call	?GenerateAirCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z ; CvUnitCombat::GenerateAirCombatInfo
	add	esp, 16					; 00000010H

; 3342 : 		CvAssertMsg(!kAttacker.isDelayedDeath(), "Trying to battle and the attacker is already dead!");
; 3343 : 
; 3344 : 		uint uiParentEventID = 0;

	mov	DWORD PTR _uiParentEventID$223744[esp+2784], 0

; 3345 : 		if(!bDoImmediate)

	test	bl, bl
	jne	$LN5@AttackAir

; 3346 : 		{
; 3347 : 			// Center camera here!
; 3348 : 			bool isTargetVisibleToActivePlayer = targetPlot.isActiveVisible(false);

	push	0
	mov	ecx, esi
	call	?isActiveVisible@CvPlot@@QBE_N_N@Z	; CvPlot::isActiveVisible
	mov	BYTE PTR _isTargetVisibleToActivePlayer$223746[esp+2784], al

; 3349 : 			if(isTargetVisibleToActivePlayer)

	test	al, al
	je	SHORT $LN107@AttackAir

; 3350 : 			{
; 3351 : 				auto_ptr<ICvPlot1> pDllTargetPlot = GC.WrapPlotPointer(&targetPlot);

	push	esi
	lea	eax, DWORD PTR $T231737[esp+2788]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ; CvGlobals::WrapPlotPointer
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pDllTargetPlot$223749[esp+2784], ebp
	mov	eax, DWORD PTR $T231737[esp+2784]
	mov	DWORD PTR __$EHRec$[esp+2792], 3
	test	eax, eax
	je	SHORT $LN76@AttackAir
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN76@AttackAir:

; 3352 : 				GC.GetEngineUserInterface()->lookAt(pDllTargetPlot.get(), CAMERALOOKAT_NORMAL);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+272]
	push	0
	push	ebp
	call	edx

; 3353 : 			}

	mov	DWORD PTR __$EHRec$[esp+2792], -1
	test	ebp, ebp
	je	SHORT $LN107@AttackAir
	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ebp
	call	ecx
$LN107@AttackAir:

; 3354 : 
; 3355 : 			kCombatInfo.setVisualizeCombat(isTargetVisibleToActivePlayer);

	mov	edx, DWORD PTR _isTargetVisibleToActivePlayer$223746[esp+2784]
	push	edx
	lea	ecx, DWORD PTR _kCombatInfo$223743[esp+2788]
	call	?setVisualizeCombat@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setVisualizeCombat

; 3356 : 			auto_ptr<ICvCombatInfo1> pDllCombatInfo(new CvDllCombatInfo(&kCombatInfo));

	push	12					; 0000000cH
	call	??2CvDllCombatInfo@@SAPAXI@Z		; CvDllCombatInfo::operator new
	add	esp, 4
	mov	DWORD PTR $T231740[esp+2784], eax
	mov	DWORD PTR __$EHRec$[esp+2792], 4
	test	eax, eax
	je	SHORT $LN18@AttackAir
	lea	ecx, DWORD PTR _kCombatInfo$223743[esp+2784]
	push	ecx
	mov	ecx, eax
	call	??0CvDllCombatInfo@@QAE@PAVCvCombatInfo@@@Z ; CvDllCombatInfo::CvDllCombatInfo
	mov	ebp, eax
	jmp	SHORT $LN19@AttackAir
$LN18@AttackAir:
	xor	ebp, ebp
$LN19@AttackAir:
	mov	DWORD PTR _pDllCombatInfo$223757[esp+2784], ebp

; 3357 : 			uiParentEventID = gDLL->GameplayCityCombat(pDllCombatInfo.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+668]
	push	ebp
	mov	DWORD PTR __$EHRec$[esp+2796], 5
	call	eax
	mov	DWORD PTR _uiParentEventID$223744[esp+2784], eax

; 3358 : 
; 3359 : 			CvCity* pkDefender = targetPlot.getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN94@AttackAir
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN94@AttackAir
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	esi, eax
	jmp	SHORT $LN95@AttackAir
$LN94@AttackAir:
	xor	esi, esi
$LN95@AttackAir:

; 3360 : 			kAttacker.setCombatCity(pkDefender);

	push	esi
	mov	ecx, edi
	call	?setCombatCity@CvUnit@@QAEXPAVCvCity@@@Z ; CvUnit::setCombatCity

; 3361 : 			if(pkDefender)

	test	esi, esi
	je	SHORT $LN3@AttackAir

; 3362 : 				pkDefender->setCombatUnit(&kAttacker);

	push	0
	push	edi
	mov	ecx, esi
	call	?setCombatUnit@CvCity@@QAEXPAVCvUnit@@_N@Z ; CvCity::setCombatUnit
$LN3@AttackAir:

; 3363 : 			CvUnit* pDefenderSupport = kCombatInfo.getUnit(BATTLE_UNIT_INTERCEPTOR);

	push	2
	lea	ecx, DWORD PTR _kCombatInfo$223743[esp+2788]
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit

; 3364 : 			if(pDefenderSupport)

	test	eax, eax
	je	SHORT $LN2@AttackAir

; 3365 : 				pDefenderSupport->setCombatUnit(&kAttacker, false);

	push	0
	push	edi
	mov	ecx, eax
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit
$LN2@AttackAir:

; 3366 : 			eResult = ATTACK_QUEUED;

	mov	edi, 2

; 3367 : 		}

	mov	DWORD PTR __$EHRec$[esp+2792], -1
	test	ebp, ebp
	je	SHORT $LN108@AttackAir
	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+4]
	push	ebp
	call	eax

; 3368 : 		else

	jmp	SHORT $LN108@AttackAir
$LN5@AttackAir:

; 3369 : 			eResult = ATTACK_COMPLETED;

	mov	edi, 1
$LN108@AttackAir:

; 3370 : 
; 3371 : 		ResolveCombat(kCombatInfo, uiParentEventID);

	mov	ecx, DWORD PTR _uiParentEventID$223744[esp+2784]
	push	ecx
	lea	edx, DWORD PTR _kCombatInfo$223743[esp+2788]
	push	edx
$LN112@AttackAir:
	call	?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveCombat
	add	esp, 8

; 3372 : 	}
; 3373 : 
; 3374 : 	return eResult;

	mov	eax, edi
$LN110@AttackAir:

; 3375 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+2784]
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 2768				; 00000ad0H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$1:
	lea	ecx, DWORD PTR _pDllTargetPlot$223730[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__unwindfunclet$?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$2:
	mov	eax, DWORD PTR $T231734[ebp]
	push	eax
	call	??3CvDllCombatInfo@@SAXPAX@Z		; CvDllCombatInfo::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$3:
	lea	ecx, DWORD PTR _pDllCombatInfo$223738[ebp]
	jmp	??1?$auto_ptr@VICvCombatInfo1@@@std@@QAE@XZ ; std::auto_ptr<ICvCombatInfo1>::~auto_ptr<ICvCombatInfo1>
__unwindfunclet$?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$5:
	lea	ecx, DWORD PTR _pDllTargetPlot$223749[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__unwindfunclet$?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$6:
	mov	eax, DWORD PTR $T231740[ebp]
	push	eax
	call	??3CvDllCombatInfo@@SAXPAX@Z		; CvDllCombatInfo::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$7:
	lea	ecx, DWORD PTR _pDllCombatInfo$223757[ebp]
	jmp	??1?$auto_ptr@VICvCombatInfo1@@@std@@QAE@XZ ; std::auto_ptr<ICvCombatInfo1>::~auto_ptr<ICvCombatInfo1>
__ehhandler$?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AttackAir@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z ENDP ; CvUnitCombat::AttackAir
PUBLIC	?AttackAirSweep@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z ; CvUnitCombat::AttackAirSweep
EXTRN	?GetTextKey@CvBaseInfo@@QBEPBDXZ:PROC		; CvBaseInfo::GetTextKey
EXTRN	?canAirSweepAt@CvUnit@@QBE_NHH@Z:PROC		; CvUnit::canAirSweepAt
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?AttackAirSweep@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackAirSweep@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackAirSweep@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackAirSweep@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackAirSweep@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$4
__ehfuncinfo$?AttackAirSweep@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?AttackAirSweep@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
xdata$x	ENDS
;	COMDAT ?AttackAirSweep@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z
_TEXT	SEGMENT
$T231949 = -1476					; size = 4
_eResult$ = -1476					; size = 4
tv466 = -1472						; size = 4
_isTargetVisibleToActivePlayer$223777 = -1472		; size = 1
$T231952 = -1468					; size = 4
_pDllCombatInfo$223788 = -1468				; size = 4
_pDllTargetPlot$223780 = -1468				; size = 4
_localizedText$223792 = -1464				; size = 80
_kCombatInfo$223772 = -1384				; size = 1372
__$EHRec$ = -12						; size = 12
_kAttacker$ = 8						; size = 4
_targetPlot$ = 12					; size = 4
___formal$ = 16						; size = 4
?AttackAirSweep@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z PROC ; CvUnitCombat::AttackAirSweep, COMDAT

; 3379 : {

	push	-1
	push	__ehhandler$?AttackAirSweep@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 1464				; 000005b8H
	push	ebp
	push	esi

; 3380 : 	//VALIDATE_OBJECT
; 3381 : 	CvAssert(kAttacker.getCombatTimer() == 0);
; 3382 : 
; 3383 : 	CvUnitCombat::ATTACK_RESULT eResult = CvUnitCombat::ATTACK_ABORTED;
; 3384 : 
; 3385 : 	// Can we actually hit the target?
; 3386 : 	if(!kAttacker.canAirSweepAt(targetPlot.getX(), targetPlot.getY()))

	mov	esi, DWORD PTR _kAttacker$[esp+1480]
	push	edi
	mov	edi, DWORD PTR _targetPlot$[esp+1484]
	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	eax
	push	ecx
	xor	ebp, ebp
	mov	ecx, esi
	mov	DWORD PTR _eResult$[esp+1496], ebp
	call	?canAirSweepAt@CvUnit@@QBE_NHH@Z	; CvUnit::canAirSweepAt
	test	al, al
	jne	SHORT $LN8@AttackAirS
	pop	edi
	pop	esi

; 3387 : 	{
; 3388 : 		return eResult;

	xor	eax, eax
	pop	ebp

; 3452 : 		}
; 3453 : 	}
; 3454 : 
; 3455 : 	return eResult;
; 3456 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+1476]
	mov	DWORD PTR fs:0, ecx
	add	esp, 1476				; 000005c4H
	ret	0
$LN8@AttackAirS:
	push	ebx

; 3389 : 	}
; 3390 : 
; 3391 : 	CvUnit* pInterceptor = kAttacker.GetBestInterceptor(targetPlot);

	push	ebp
	push	ebp
	push	ebp
	push	edi
	mov	ecx, esi
	call	?GetBestInterceptor@CvUnit@@QBEPAV1@ABVCvPlot@@PAV1@_N2@Z ; CvUnit::GetBestInterceptor

; 3392 : 	kAttacker.SetAutomateType(NO_AUTOMATE);

	push	-1
	mov	ecx, esi
	mov	ebx, eax
	call	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z ; CvUnit::SetAutomateType

; 3393 : 
; 3394 : 	// Any interceptor to sweep for?
; 3395 : 	if(pInterceptor != NULL)

	cmp	ebx, ebp
	je	$LN7@AttackAirS

; 3396 : 	{
; 3397 : 		kAttacker.setMadeAttack(true);

	push	1
	mov	ecx, esi
	call	?setMadeAttack@CvUnit@@QAEX_N@Z		; CvUnit::setMadeAttack

; 3398 : 		CvCombatInfo kCombatInfo;

	lea	ecx, DWORD PTR _kCombatInfo$223772[esp+1492]
	call	??0CvCombatInfo@@QAE@XZ			; CvCombatInfo::CvCombatInfo

; 3399 : 		CvUnitCombat::GenerateAirSweepCombatInfo(kAttacker, pInterceptor, targetPlot, &kCombatInfo);

	lea	eax, DWORD PTR _kCombatInfo$223772[esp+1492]
	push	eax
	push	edi
	push	ebx
	push	esi
	call	?GenerateAirSweepCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z ; CvUnitCombat::GenerateAirSweepCombatInfo
	add	esp, 16					; 00000010H

; 3400 : 		CvUnit* pkDefender = kCombatInfo.getUnit(BATTLE_UNIT_DEFENDER);

	push	1
	lea	ecx, DWORD PTR _kCombatInfo$223772[esp+1496]
	call	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit

; 3401 : 		pkDefender->SetAutomateType(NO_AUTOMATE);

	push	-1
	mov	ecx, eax
	call	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z ; CvUnit::SetAutomateType

; 3402 : 		CvAssertMsg(!kAttacker.isDelayedDeath() && !pkDefender->isDelayedDeath(), "Trying to battle and one of the units is already dead!");
; 3403 : 
; 3404 : 		uint uiParentEventID = 0;
; 3405 : 		bool bDoImmediate = CvPreGame::quickCombat();

	call	?quickCombat@CvPreGame@@YA_NXZ		; CvPreGame::quickCombat

; 3406 : 		if(!bDoImmediate)

	test	al, al
	jne	$LN6@AttackAirS

; 3407 : 		{
; 3408 : 			// Center camera here!
; 3409 : 			bool isTargetVisibleToActivePlayer = targetPlot.isActiveVisible(false);

	push	0
	mov	ecx, edi
	call	?isActiveVisible@CvPlot@@QBE_N_N@Z	; CvPlot::isActiveVisible
	mov	BYTE PTR _isTargetVisibleToActivePlayer$223777[esp+1492], al

; 3410 : 			if(isTargetVisibleToActivePlayer)

	test	al, al
	je	SHORT $LN39@AttackAirS

; 3411 : 			{
; 3412 : 				auto_ptr<ICvPlot1> pDllTargetPlot = GC.WrapPlotPointer(&targetPlot);

	push	edi
	lea	ecx, DWORD PTR $T231949[esp+1496]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ; CvGlobals::WrapPlotPointer
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR _pDllTargetPlot$223780[esp+1492], edi
	mov	eax, DWORD PTR $T231949[esp+1492]
	mov	DWORD PTR __$EHRec$[esp+1500], 0
	test	eax, eax
	je	SHORT $LN30@AttackAirS
	mov	edx, DWORD PTR [eax]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN30@AttackAirS:

; 3413 : 				GC.GetEngineUserInterface()->lookAt(pDllTargetPlot.get(), CAMERALOOKAT_NORMAL);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+272]
	push	0
	push	edi
	call	eax

; 3414 : 			}

	mov	DWORD PTR __$EHRec$[esp+1500], -1
	test	edi, edi
	je	SHORT $LN39@AttackAirS
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+4]
	push	edi
	call	edx
$LN39@AttackAirS:

; 3415 : 			kCombatInfo.setVisualizeCombat(isTargetVisibleToActivePlayer);

	mov	eax, DWORD PTR _isTargetVisibleToActivePlayer$223777[esp+1492]
	push	eax
	lea	ecx, DWORD PTR _kCombatInfo$223772[esp+1496]
	call	?setVisualizeCombat@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setVisualizeCombat

; 3416 : 
; 3417 : 			auto_ptr<ICvCombatInfo1> pDllCombatInfo(new CvDllCombatInfo(&kCombatInfo));

	push	12					; 0000000cH
	call	??2CvDllCombatInfo@@SAPAXI@Z		; CvDllCombatInfo::operator new
	add	esp, 4
	mov	DWORD PTR $T231952[esp+1492], eax
	mov	DWORD PTR __$EHRec$[esp+1500], 1
	test	eax, eax
	je	SHORT $LN11@AttackAirS
	lea	ecx, DWORD PTR _kCombatInfo$223772[esp+1492]
	push	ecx
	mov	ecx, eax
	call	??0CvDllCombatInfo@@QAE@PAVCvCombatInfo@@@Z ; CvDllCombatInfo::CvDllCombatInfo
	mov	edi, eax
	jmp	SHORT $LN12@AttackAirS
$LN11@AttackAirS:
	xor	edi, edi
$LN12@AttackAirS:
	mov	DWORD PTR _pDllCombatInfo$223788[esp+1492], edi

; 3418 : 			uiParentEventID = gDLL->GameplayUnitCombat(pDllCombatInfo.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+644]
	push	edi
	mov	DWORD PTR __$EHRec$[esp+1504], 2
	call	eax

; 3419 : 
; 3420 : 			// Set the combat units so that other missions do not continue until combat is over.
; 3421 : 			kAttacker.setCombatUnit(pInterceptor, true);

	push	1
	push	ebx
	mov	ecx, esi
	mov	ebp, eax
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 3422 : 			pInterceptor->setCombatUnit(&kAttacker, false);

	push	0
	push	esi
	mov	ecx, ebx
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 3423 : 			eResult = ATTACK_QUEUED;

	mov	DWORD PTR _eResult$[esp+1492], 2

; 3424 : 		}

	mov	DWORD PTR __$EHRec$[esp+1500], -1
	test	edi, edi
	je	SHORT $LN4@AttackAirS
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+4]
	push	edi
	call	edx

; 3427 : 
; 3428 : 		ResolveCombat(kCombatInfo, uiParentEventID);

	lea	eax, DWORD PTR _kCombatInfo$223772[esp+1492]
	push	ebp
	push	eax
	call	?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveCombat
	add	esp, 8

; 3429 : 	}
; 3430 : 	else

	jmp	$LN1@AttackAirS
$LN6@AttackAirS:

; 3425 : 		else
; 3426 : 			eResult = ATTACK_COMPLETED;

	mov	DWORD PTR _eResult$[esp+1492], 1
$LN4@AttackAirS:

; 3427 : 
; 3428 : 		ResolveCombat(kCombatInfo, uiParentEventID);

	lea	eax, DWORD PTR _kCombatInfo$223772[esp+1492]
	push	ebp
	push	eax
	call	?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveCombat
	add	esp, 8

; 3429 : 	}
; 3430 : 	else

	jmp	$LN1@AttackAirS
$LN7@AttackAirS:

; 3431 : 	{
; 3432 : 		// attempted to do a sweep in a plot that had no interceptors
; 3433 : 		// consume the movement and finish its moves
; 3434 : 		if(kAttacker.getOwner() == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, DWORD PTR [esi+40]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	edi, eax
	jne	$LN2@AttackAirS

; 3435 : 		{
; 3436 : 			Localization::String localizedText = Localization::Lookup("TXT_KEY_AIR_PATROL_FOUND_NOTHING");

	lea	ecx, DWORD PTR _localizedText$223792[esp+1492]
	push	OFFSET $SG223794
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 3437 : 			localizedText << kAttacker.getUnitInfo().GetTextKey();

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+1500], 3
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	lea	ecx, DWORD PTR _localizedText$223792[esp+1496]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 3438 : 			GC.GetEngineUserInterface()->AddMessage(0, kAttacker.getOwner(), false, GC.getEVENT_MESSAGE_TIME(), localizedText.toUTF8());

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [edi]
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	ebp, DWORD PTR [esi+40]
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _localizedText$223792[esp+1524]
	mov	DWORD PTR tv466[esp+1524], edx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	mov	eax, DWORD PTR tv466[esp+1528]
	mov	edx, DWORD PTR [eax+160]
	push	ebx
	push	0
	push	ebp
	push	0
	mov	ecx, edi
	call	edx

; 3439 : 		}

	lea	ecx, DWORD PTR _localizedText$223792[esp+1492]
	mov	DWORD PTR __$EHRec$[esp+1500], -1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN2@AttackAirS:

; 3440 : 
; 3441 : 		// Spend a move for this attack
; 3442 : 		kAttacker.changeMoves(-GC.getMOVE_DENOMINATOR());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	neg	eax
	push	eax
	mov	ecx, esi
	call	?changeMoves@CvUnit@@QAEXH@Z		; CvUnit::changeMoves

; 3443 : 
; 3444 : 		// Can't move or attack again
; 3445 : #ifdef NQ_UNIT_TURN_ENDS_ON_FINAL_ATTACK
; 3446 : 		if(!kAttacker.canMoveAfterAttacking() && kAttacker.isOutOfAttacks())

	mov	ecx, esi
	call	?canMoveAfterAttacking@CvUnit@@QBE_NXZ	; CvUnit::canMoveAfterAttacking
	test	al, al
	jne	SHORT $LN1@AttackAirS
	mov	ecx, esi
	call	?isOutOfAttacks@CvUnit@@QBE_NXZ		; CvUnit::isOutOfAttacks
	test	al, al
	je	SHORT $LN1@AttackAirS

; 3447 : #else
; 3448 : 		if(!kAttacker.canMoveAfterAttacking())
; 3449 : #endif
; 3450 : 		{
; 3451 : 			kAttacker.finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN1@AttackAirS:

; 3452 : 		}
; 3453 : 	}
; 3454 : 
; 3455 : 	return eResult;
; 3456 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+1492]
	mov	eax, DWORD PTR _eResult$[esp+1492]
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 1476				; 000005c4H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AttackAirSweep@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$1:
	lea	ecx, DWORD PTR _pDllTargetPlot$223780[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__unwindfunclet$?AttackAirSweep@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$2:
	mov	eax, DWORD PTR $T231952[ebp]
	push	eax
	call	??3CvDllCombatInfo@@SAXPAX@Z		; CvDllCombatInfo::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AttackAirSweep@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$3:
	lea	ecx, DWORD PTR _pDllCombatInfo$223788[ebp]
	jmp	??1?$auto_ptr@VICvCombatInfo1@@@std@@QAE@XZ ; std::auto_ptr<ICvCombatInfo1>::~auto_ptr<ICvCombatInfo1>
__unwindfunclet$?AttackAirSweep@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$4:
	lea	ecx, DWORD PTR _localizedText$223792[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__ehhandler$?AttackAirSweep@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$?AttackAirSweep@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AttackAirSweep@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z ENDP ; CvUnitCombat::AttackAirSweep
PUBLIC	?AttackCity@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z ; CvUnitCombat::AttackCity
EXTRN	?WaitFor@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@0@Z:PROC ; CvUnitMission::WaitFor
EXTRN	?GetHeadMissionData@CvUnit@@QAEPBUMissionData@@XZ:PROC ; CvUnit::GetHeadMissionData
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?AttackCity@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackCity@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackCity@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackCity@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackCity@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$5
__ehfuncinfo$?AttackCity@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?AttackCity@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
xdata$x	ENDS
;	COMDAT ?AttackCity@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z
_TEXT	SEGMENT
$T232096 = -1396					; size = 4
_pDllCombatInfo$223829 = -1396				; size = 4
_pDllPlot$223821 = -1396				; size = 4
$T232092 = -1396					; size = 4
_isTargetVisibleToActivePlayer$223815 = -1392		; size = 1
$T232091 = -1392					; size = 4
$T232093 = -1388					; size = 4
_kCombatInfo$223814 = -1384				; size = 1372
__$EHRec$ = -12						; size = 12
_kAttacker$ = 8						; size = 4
_plot$ = 12						; size = 4
_eOption$ = 16						; size = 4
?AttackCity@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z PROC ; CvUnitCombat::AttackCity, COMDAT

; 3460 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?AttackCity@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 1384				; 00000568H
	push	ebx

; 3461 : 	//VALIDATE_OBJECT
; 3462 : 
; 3463 : 	ATTACK_RESULT eResult = ATTACK_ABORTED;
; 3464 : 	CvCity* pCity = plot.getPlotCity();

	mov	ebx, DWORD PTR _plot$[esp+1396]
	mov	eax, DWORD PTR [ebx+104]
	push	ebp
	push	esi
	push	edi
	test	eax, eax
	jl	SHORT $LN99@AttackCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN99@AttackCity
	mov	ecx, DWORD PTR [ebx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	edi, eax

; 3465 : 	CvAssertMsg(pCity != NULL, "If this unit is attacking a NULL city then something funky is goin' down");
; 3466 : 	if(!pCity) return eResult;

	test	edi, edi
	jne	SHORT $LN9@AttackCity
$LN99@AttackCity:
	xor	eax, eax
	jmp	$LN10@AttackCity
$LN9@AttackCity:

; 3467 : 
; 3468 : 	kAttacker.SetAutomateType(NO_AUTOMATE);

	mov	esi, DWORD PTR _kAttacker$[esp+1408]
	push	-1
	mov	ecx, esi
	call	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z ; CvUnit::SetAutomateType

; 3469 : 
; 3470 : 	if(eOption != ATTACK_OPTION_NO_DEFENSIVE_SUPPORT)

	cmp	DWORD PTR _eOption$[esp+1408], 1
	je	$LN100@AttackCity

; 3471 : 	{
; 3472 : 		// See if the city has some supporting fire to fend off the attacker
; 3473 : 		CvUnit* pFireSupportUnit = GetFireSupportUnit(pCity->getOwner(), pCity->getX(), pCity->getY(), kAttacker.getX(), kAttacker.getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	mov	edx, DWORD PTR [edi+108]
	mov	ebp, DWORD PTR [edi+96]
	mov	edi, DWORD PTR [edi+84]
	push	eax
	push	ecx
	push	edx
	push	ebp
	push	edi
	call	?GetFireSupportUnit@CvUnitCombat@@SAPAVCvUnit@@W4PlayerTypes@@HHHH@Z ; CvUnitCombat::GetFireSupportUnit
	mov	edi, eax
	add	esp, 20					; 00000014H

; 3474 : 
; 3475 : 		ATTACK_RESULT eSupportResult = ATTACK_ABORTED;
; 3476 : 		if(pFireSupportUnit)

	test	edi, edi
	je	$LN100@AttackCity

; 3477 : 		{
; 3478 : 			eSupportResult = AttackRanged(*pFireSupportUnit, kAttacker.getX(), kAttacker.getY(), CvUnitCombat::ATTACK_OPTION_NO_DEFENSIVE_SUPPORT);

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	1
	push	eax
	push	ecx
	push	edi
	call	?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z ; CvUnitCombat::AttackRanged
	add	esp, 16					; 00000010H

; 3479 : 			// Turn off Fortify Turns, as this is the trigger for whether or not a ranged Unit can provide support fire (in addition to hasMadeAttack)
; 3480 : 			pFireSupportUnit->setFortifyTurns(0);

	push	0
	mov	ecx, edi
	mov	ebp, eax
	call	?setFortifyTurns@CvUnit@@QAEXH@Z	; CvUnit::setFortifyTurns

; 3481 : 		}
; 3482 : 
; 3483 : 		if(eSupportResult == ATTACK_QUEUED)

	cmp	ebp, 2
	jne	SHORT $LN100@AttackCity

; 3484 : 		{
; 3485 : 			// The supporting unit has queued their attack (against the attacker), we must have the attacker queue its attack.
; 3486 : 			// Also, flag the current mission that the next time through, the defender doesn't get any defensive support.
; 3487 : 			const_cast<MissionData*>(kAttacker.GetHeadMissionData())->iFlags |= MISSION_MODIFIER_NO_DEFENSIVE_SUPPORT;

	mov	ecx, esi
	call	?GetHeadMissionData@CvUnit@@QAEPBUMissionData@@XZ ; CvUnit::GetHeadMissionData
	or	DWORD PTR [eax+12], 256			; 00000100H
	add	eax, 12					; 0000000cH

; 3488 : 			CvUnitMission::WaitFor(&kAttacker, pFireSupportUnit);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, edi
	mov	DWORD PTR $T232091[esp+1420], esp
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+1436], 0
	mov	DWORD PTR $T232092[esp+1428], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	DWORD PTR __$EHRec$[esp+1436], -1
	call	?WaitFor@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@0@Z ; CvUnitMission::WaitFor
	add	esp, 16					; 00000010H

; 3489 : 			eResult = ATTACK_QUEUED;

	mov	esi, ebp

; 3490 : 		}
; 3491 : 	}
; 3492 : 
; 3493 : 	if(eResult != ATTACK_QUEUED)

	jmp	$LN5@AttackCity
$LN100@AttackCity:

; 3494 : 	{
; 3495 : 		kAttacker.setMadeAttack(true);

	push	1
	mov	ecx, esi
	call	?setMadeAttack@CvUnit@@QAEX_N@Z		; CvUnit::setMadeAttack

; 3496 : 
; 3497 : 		// We are doing a non-ranged attack on a city
; 3498 : 		CvCombatInfo kCombatInfo;

	lea	ecx, DWORD PTR _kCombatInfo$223814[esp+1412]
	call	??0CvCombatInfo@@QAE@XZ			; CvCombatInfo::CvCombatInfo

; 3499 : 		GenerateMeleeCombatInfo(kAttacker, NULL, plot, &kCombatInfo);

	lea	edx, DWORD PTR _kCombatInfo$223814[esp+1412]
	push	edx
	push	ebx
	push	0
	push	esi
	call	?GenerateMeleeCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z ; CvUnitCombat::GenerateMeleeCombatInfo
	add	esp, 16					; 00000010H

; 3500 : 		CvAssertMsg(!kAttacker.isDelayedDeath(), "Trying to battle and the attacker is already dead!");
; 3501 : 
; 3502 : 		// Send the combat message if the target plot is visible.
; 3503 : 		bool isTargetVisibleToActivePlayer = plot.isActiveVisible(false);

	push	0
	mov	ecx, ebx
	call	?isActiveVisible@CvPlot@@QBE_N_N@Z	; CvPlot::isActiveVisible
	mov	BYTE PTR _isTargetVisibleToActivePlayer$223815[esp+1412], al

; 3504 : 
; 3505 : 		uint uiParentEventID = 0;

	xor	ebp, ebp

; 3506 : 		bool bDoImmediate = CvPreGame::quickCombat();

	call	?quickCombat@CvPreGame@@YA_NXZ		; CvPreGame::quickCombat

; 3507 : 		if(!bDoImmediate)

	test	al, al
	jne	$LN4@AttackCity

; 3508 : 		{
; 3509 : 			// Center camera here!
; 3510 : 			if(isTargetVisibleToActivePlayer)

	cmp	BYTE PTR _isTargetVisibleToActivePlayer$223815[esp+1412], al
	je	SHORT $LN80@AttackCity

; 3511 : 			{
; 3512 : 				auto_ptr<ICvPlot1> pDllPlot = GC.WrapPlotPointer(&plot);

	push	ebx
	lea	eax, DWORD PTR $T232093[esp+1416]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ; CvGlobals::WrapPlotPointer
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR _pDllPlot$223821[esp+1412], edi
	mov	eax, DWORD PTR $T232093[esp+1412]
	mov	DWORD PTR __$EHRec$[esp+1420], 1
	test	eax, eax
	je	SHORT $LN71@AttackCity
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN71@AttackCity:

; 3513 : 				GC.GetEngineUserInterface()->lookAt(pDllPlot.get(), CAMERALOOKAT_NORMAL);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+272]
	push	0
	push	edi
	call	edx

; 3514 : 			}

	mov	DWORD PTR __$EHRec$[esp+1420], -1
	test	edi, edi
	je	SHORT $LN80@AttackCity
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	call	ecx
$LN80@AttackCity:

; 3515 : 			kCombatInfo.setVisualizeCombat(isTargetVisibleToActivePlayer);

	mov	edx, DWORD PTR _isTargetVisibleToActivePlayer$223815[esp+1412]
	push	edx
	lea	ecx, DWORD PTR _kCombatInfo$223814[esp+1416]
	call	?setVisualizeCombat@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setVisualizeCombat

; 3516 : 
; 3517 : 			auto_ptr<ICvCombatInfo1> pDllCombatInfo(new CvDllCombatInfo(&kCombatInfo));

	push	12					; 0000000cH
	call	??2CvDllCombatInfo@@SAPAXI@Z		; CvDllCombatInfo::operator new
	add	esp, 4
	mov	DWORD PTR $T232096[esp+1412], eax
	mov	DWORD PTR __$EHRec$[esp+1420], 2
	test	eax, eax
	je	SHORT $LN12@AttackCity
	lea	ecx, DWORD PTR _kCombatInfo$223814[esp+1412]
	push	ecx
	mov	ecx, eax
	call	??0CvDllCombatInfo@@QAE@PAVCvCombatInfo@@@Z ; CvDllCombatInfo::CvDllCombatInfo
	mov	edi, eax
	jmp	SHORT $LN13@AttackCity
$LN12@AttackCity:
	xor	edi, edi
$LN13@AttackCity:
	mov	DWORD PTR _pDllCombatInfo$223829[esp+1412], edi

; 3518 : 			uiParentEventID = gDLL->GameplayCityCombat(pDllCombatInfo.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+668]
	push	edi
	mov	DWORD PTR __$EHRec$[esp+1424], 3
	call	eax
	mov	ebp, eax

; 3519 : 
; 3520 : 			CvCity* pkDefender = plot.getPlotCity();

	mov	eax, DWORD PTR [ebx+104]
	test	eax, eax
	jl	SHORT $LN89@AttackCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN89@AttackCity
	mov	ecx, DWORD PTR [ebx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	ebx, eax
	jmp	SHORT $LN90@AttackCity
$LN89@AttackCity:
	xor	ebx, ebx
$LN90@AttackCity:

; 3521 : 			kAttacker.setCombatCity(pkDefender);

	push	ebx
	mov	ecx, esi
	call	?setCombatCity@CvUnit@@QAEXPAVCvCity@@@Z ; CvUnit::setCombatCity

; 3522 : 			if(pkDefender)

	test	ebx, ebx
	je	SHORT $LN2@AttackCity

; 3523 : 				pkDefender->setCombatUnit(&kAttacker);

	push	0
	push	esi
	mov	ecx, ebx
	call	?setCombatUnit@CvCity@@QAEXPAVCvUnit@@_N@Z ; CvCity::setCombatUnit
$LN2@AttackCity:

; 3524 : 			eResult = ATTACK_QUEUED;

	mov	esi, 2

; 3525 : 		}

	mov	DWORD PTR __$EHRec$[esp+1420], -1
	test	edi, edi
	je	SHORT $LN1@AttackCity
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+4]
	push	edi
	call	eax

; 3526 : 		else

	jmp	SHORT $LN1@AttackCity
$LN4@AttackCity:

; 3527 : 			eResult = ATTACK_COMPLETED;

	mov	esi, 1
$LN1@AttackCity:

; 3528 : 
; 3529 : 		ResolveCombat(kCombatInfo, uiParentEventID);

	lea	ecx, DWORD PTR _kCombatInfo$223814[esp+1412]
	push	ebp
	push	ecx
	call	?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveCombat
	add	esp, 8
$LN5@AttackCity:

; 3530 : 	}
; 3531 : 	return eResult;

	mov	eax, esi
$LN10@AttackCity:

; 3532 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+1412]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 1396				; 00000574H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AttackCity@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$0:
	mov	ecx, DWORD PTR $T232091[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?AttackCity@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$3:
	lea	ecx, DWORD PTR _pDllPlot$223821[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__unwindfunclet$?AttackCity@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$4:
	mov	eax, DWORD PTR $T232096[ebp]
	push	eax
	call	??3CvDllCombatInfo@@SAXPAX@Z		; CvDllCombatInfo::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AttackCity@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$5:
	lea	ecx, DWORD PTR _pDllCombatInfo$223829[ebp]
	jmp	??1?$auto_ptr@VICvCombatInfo1@@@std@@QAE@XZ ; std::auto_ptr<ICvCombatInfo1>::~auto_ptr<ICvCombatInfo1>
__ehhandler$?AttackCity@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$?AttackCity@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AttackCity@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z ENDP ; CvUnitCombat::AttackCity
PUBLIC	?insertAtEnd@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z ; FFastSmallFixedList<IDInfo,25,1,297,0>::insertAtEnd
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?insertAtEnd@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z
_TEXT	SEGMENT
_ptData$ = 8						; size = 4
?insertAtEnd@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z PROC ; FFastSmallFixedList<IDInfo,25,1,297,0>::insertAtEnd, COMDAT
; _this$ = ecx

; 1026 :     { 

	push	esi
	mov	esi, ecx

; 1027 :         mVec.push_back( *ptData );       

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+212], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN3@insertAtEn
	push	eax
	call	?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,25,1,297,0>::GrowSize
$LN3@insertAtEn:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN10@insertAtEn
	mov	ecx, DWORD PTR _ptData$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN10@insertAtEn:
	inc	DWORD PTR [esi+4]
	pop	esi

; 1028 :     };

	ret	4
?insertAtEnd@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z ENDP ; FFastSmallFixedList<IDInfo,25,1,297,0>::insertAtEnd
_TEXT	ENDS
PUBLIC	?clear@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXXZ ; FFastSmallFixedList<IDInfo,25,1,297,0>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXXZ PROC ; FFastSmallFixedList<IDInfo,25,1,297,0>::clear, COMDAT
; _this$ = ecx

; 849  :         mVec.resize( 0 );

	mov	DWORD PTR [ecx+4], 0

; 850  :     };

	ret	0
?clear@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXXZ ENDP ; FFastSmallFixedList<IDInfo,25,1,297,0>::clear
_TEXT	ENDS
PUBLIC	?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z ; CvUnitCombat::Attack
EXTRN	?canAdvance@CvUnit@@IBE_NABVCvPlot@@H@Z:PROC	; CvUnit::canAdvance
EXTRN	?getNameKey@CvPlayer@@QBEPBDXZ:PROC		; CvPlayer::getNameKey
EXTRN	__imp_??4String@Localization@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getCaptureUnitType@CvUnit@@QBE?AW4UnitTypes@@W4CivilizationTypes@@@Z:PROC ; CvUnit::getCaptureUnitType
EXTRN	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvPlayer::getCivilizationType
EXTRN	?IsCaptureWhileEmbarked@CvUnitEntry@@QBE_NXZ:PROC ; CvUnitEntry::IsCaptureWhileEmbarked
EXTRN	__imp_??0String@Localization@@QAE@XZ:PROC
EXTRN	?setDamage@CvUnit@@QAEHHW4PlayerTypes@@MPBVCvString@@@Z:PROC ; CvUnit::setDamage
EXTRN	?setCombatTimer@CvUnit@@QAEXH@Z:PROC		; CvUnit::setCombatTimer
EXTRN	?getTime@CvMissionInfo@@QBEHXZ:PROC		; CvMissionInfo::getTime
EXTRN	?getMissionInfo@CvGlobals@@QAEPAVCvMissionInfo@@W4MissionTypes@@@Z:PROC ; CvGlobals::getMissionInfo
EXTRN	?setPlot@CvMissionDefinition@@QAEXPBVCvPlot@@@Z:PROC ; CvMissionDefinition::setPlot
EXTRN	?setUnit@CvMissionDefinition@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z:PROC ; CvMissionDefinition::setUnit
EXTRN	?setMissionType@CvMissionDefinition@@QAEXW4MissionTypes@@@Z:PROC ; CvMissionDefinition::setMissionType
EXTRN	?getMISSION_SURRENDER@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_SURRENDER
EXTRN	?setMissionTime@CvMissionDefinition@@QAEXM@Z:PROC ; CvMissionDefinition::setMissionTime
EXTRN	?getCombatTimer@CvUnit@@QBEHXZ:PROC		; CvUnit::getCombatTimer
EXTRN	??0CvMissionDefinition@@QAE@XZ:PROC		; CvMissionDefinition::CvMissionDefinition
EXTRN	?DoWithdrawFromMelee@CvUnit@@IAE_NAAV1@@Z:PROC	; CvUnit::DoWithdrawFromMelee
EXTRN	?CanWithdrawFromMelee@CvUnit@@IAE_NAAV1@@Z:PROC	; CvUnit::CanWithdrawFromMelee
EXTRN	?getExtraWithdrawal@CvUnit@@QBEHXZ:PROC		; CvUnit::getExtraWithdrawal
EXTRN	?SetEverAttackedTutorial@CvGame@@QAEX_N@Z:PROC	; CvGame::SetEverAttackedTutorial
EXTRN	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z:PROC ; CvPlot::getBestDefender
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$8
	DD	06H
	DD	FLAT:__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$9
	DD	06H
	DD	FLAT:__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$10
	DD	06H
	DD	FLAT:__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$11
	DD	01H
	DD	FLAT:__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$12
	DD	01H
	DD	FLAT:__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$15
	DD	01H
	DD	FLAT:__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$16
	DD	01H
	DD	FLAT:__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$17
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
xdata$x	ENDS
;	COMDAT ?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z
_TEXT	SEGMENT
tv1197 = -1708						; size = 4
tv1195 = -1708						; size = 4
_isTargetVisibleToActivePlayer$223525 = -1708		; size = 1
$T232746 = -1708					; size = 4
$T232339 = -1708					; size = 4
$T232331 = -1708					; size = 4
_bAdvance$223512 = -1701				; size = 1
$T232759 = -1700					; size = 4
$T232340 = -1700					; size = 4
$T232338 = -1700					; size = 4
$T232343 = -1696					; size = 4
_pDllCombatInfo$223648 = -1696				; size = 4
_pDefenderPlot$223576 = -1696				; size = 4
tv284 = -1696						; size = 8
$T232325 = -1696					; size = 8
_pDefender$ = -1688					; size = 8
_kMission$223485 = -1680				; size = 28
$T232329 = -1680					; size = 28
$T232328 = -1680					; size = 28
_strBuffer$ = -1652					; size = 28
$T232337 = -1624					; size = 80
$T232336 = -1624					; size = 80
$T232334 = -1624					; size = 80
$T232333 = -1624					; size = 80
$T232330 = -1624					; size = 80
_strMessage$223489 = -1544				; size = 80
_strSummary$223490 = -1464				; size = 80
_kCombatInfo$ = -1384					; size = 1372
__$EHRec$ = -12						; size = 12
_kAttacker$ = 8						; size = 4
_targetPlot$ = 12					; size = 4
_eOption$ = 16						; size = 4
?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z PROC ; CvUnitCombat::Attack, COMDAT

; 2932 : {

	push	-1
	push	__ehhandler$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 1696				; 000006a0H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2933 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[esp+1724]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2934 : 
; 2935 : 	//VALIDATE_OBJECT
; 2936 : 	CvAssert(kAttacker.canMoveInto(targetPlot, CvUnit::MOVEFLAG_ATTACK | CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE));
; 2937 : 	CvAssert(kAttacker.getCombatTimer() == 0);
; 2938 : 
; 2939 : 	CvUnitCombat::ATTACK_RESULT eResult = CvUnitCombat::ATTACK_ABORTED;
; 2940 : 
; 2941 : 	CvAssert(kAttacker.getCombatTimer() == 0);
; 2942 : 	//	CvAssert(pDefender != NULL);
; 2943 : 	CvAssert(!kAttacker.isFighting());
; 2944 : 
; 2945 : 	// Unit that attacks loses his Fort bonus
; 2946 : 	kAttacker.setFortifyTurns(0);

	mov	edi, DWORD PTR _kAttacker$[esp+1720]
	push	0
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+1736], 0
	call	?setFortifyTurns@CvUnit@@QAEXH@Z	; CvUnit::setFortifyTurns

; 2947 : 
; 2948 : 	UnitHandle pDefender;

	xor	esi, esi
	mov	DWORD PTR _pDefender$[esp+1724], esi
	mov	BYTE PTR _pDefender$[esp+1728], 0

; 2949 : 	pDefender = targetPlot.getBestDefender(NO_PLAYER, kAttacker.getOwner(), &kAttacker, true);

	mov	eax, DWORD PTR [edi+40]
	mov	ebx, DWORD PTR _targetPlot$[esp+1720]
	push	esi
	push	esi
	push	esi
	push	1
	push	edi
	push	eax
	push	-1
	lea	eax, DWORD PTR $T232325[esp+1752]
	push	eax
	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+1764], 1
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	lea	ecx, DWORD PTR _pDefender$[esp+1724]
	mov	BYTE PTR __$EHRec$[esp+1732], 2
	cmp	eax, ecx
	je	SHORT $LN69@Attack
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR _pDefender$[esp+1724], esi
	test	esi, esi
	je	SHORT $LN69@Attack
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN69@Attack:
	mov	ecx, DWORD PTR $T232325[esp+1724]
	mov	BYTE PTR __$EHRec$[esp+1732], 1
	test	ecx, ecx
	je	SHORT $LN74@Attack
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN74@Attack:

; 2950 : 
; 2951 : 	// JAR - without pDefender, nothing in here is going to work, just crash
; 2952 : 	if(!pDefender)

	test	esi, esi
	jne	SHORT $LN30@Attack

; 2953 : 	{
; 2954 : 		return eResult;

	lea	ecx, DWORD PTR _strBuffer$[esp+1724]
	mov	DWORD PTR __$EHRec$[esp+1732], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	eax, eax
	jmp	$LN31@Attack
$LN30@Attack:

; 2955 : 	}
; 2956 : 
; 2957 : 	kAttacker.SetAutomateType(NO_AUTOMATE);

	push	-1
	mov	ecx, edi
	call	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z ; CvUnit::SetAutomateType

; 2958 : 	pDefender->SetAutomateType(NO_AUTOMATE);

	push	-1
	mov	ecx, esi
	call	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z ; CvUnit::SetAutomateType

; 2959 : 
; 2960 : 	// slewis - tutorial'd
; 2961 : 	if(kAttacker.getOwner() == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebp, DWORD PTR [edi+40]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	ebp, eax
	jne	SHORT $LN29@Attack

; 2962 : 	{
; 2963 : 		GC.getGame().SetEverAttackedTutorial(true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	1
	call	?SetEverAttackedTutorial@CvGame@@QAEX_N@Z ; CvGame::SetEverAttackedTutorial
$LN29@Attack:

; 2964 : 	}
; 2965 : 	// end tutorial'd
; 2966 : 
; 2967 : 	// handle the Zulu special thrown spear first attack
; 2968 : 	ATTACK_RESULT eFireSupportResult = ATTACK_ABORTED;
; 2969 : 	if (kAttacker.isRangedSupportFire() && pDefender->IsCanDefend())

	mov	ecx, edi
	call	?isRangedSupportFire@CvUnit@@QBE_NXZ	; CvUnit::isRangedSupportFire
	test	al, al
	je	SHORT $LN27@Attack
	push	0
	mov	ecx, esi
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	test	al, al
	je	SHORT $LN27@Attack

; 2970 : 	{
; 2971 : 		eFireSupportResult = AttackRanged(kAttacker, pDefender->getX(), pDefender->getY(), CvUnitCombat::ATTACK_OPTION_NO_DEFENSIVE_SUPPORT);

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	1
	push	eax
	push	ecx
	push	edi
	call	?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z ; CvUnitCombat::AttackRanged
	add	esp, 16					; 00000010H

; 2972 : 		if (pDefender->isDelayedDeath())

	mov	ecx, esi
	mov	ebp, eax
	call	?isDelayedDeath@CvUnit@@QBE_NXZ		; CvUnit::isDelayedDeath
	test	al, al
	je	SHORT $LN27@Attack

; 2973 : 		{
; 2974 : 			// Killed him, move to the plot if we can.
; 2975 : 			if(targetPlot.getNumVisibleEnemyDefenders(&kAttacker) == 0)

	push	edi
	mov	ecx, ebx
	call	?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z ; CvPlot::getNumVisibleEnemyDefenders
	test	eax, eax
	jne	SHORT $LN25@Attack

; 2976 : 			{
; 2977 : 				if (kAttacker.UnitMove(&targetPlot, true, &kAttacker, true))

	push	1
	push	edi
	push	1
	push	ebx
	mov	ecx, edi
	call	?UnitMove@CvUnit@@QAE_NPAVCvPlot@@_NPAV1@1@Z ; CvUnit::UnitMove
	test	al, al
	je	SHORT $LN25@Attack

; 2978 : 					kAttacker.finishMoves();	// Burn all the moves we have

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN25@Attack:

; 2979 : 			}
; 2980 : 			return eFireSupportResult;

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+1732], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	lea	ecx, DWORD PTR _strBuffer$[esp+1724]
	mov	DWORD PTR __$EHRec$[esp+1732], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, ebp
	jmp	$LN31@Attack
$LN27@Attack:

; 2981 : 		}
; 2982 : 	}
; 2983 : 
; 2984 : 	CvCombatInfo kCombatInfo;

	lea	ecx, DWORD PTR _kCombatInfo$[esp+1724]
	call	??0CvCombatInfo@@QAE@XZ			; CvCombatInfo::CvCombatInfo

; 2985 : 	GenerateMeleeCombatInfo(kAttacker, pDefender.pointer(), targetPlot, &kCombatInfo);

	lea	edx, DWORD PTR _kCombatInfo$[esp+1724]
	push	edx
	push	ebx
	push	esi
	push	edi
	call	?GenerateMeleeCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@PAV2@AAVCvPlot@@PAVCvCombatInfo@@@Z ; CvUnitCombat::GenerateMeleeCombatInfo
	add	esp, 16					; 00000010H

; 2986 : 
; 2987 : 	CvAssertMsg(!kAttacker.isDelayedDeath() && !pDefender->isDelayedDeath(), "Trying to battle and one of the units is already dead!");
; 2988 : 
; 2989 : #ifdef AUI_UNIT_FIX_NO_RETREAT_ON_CIVILIAN_GUARD
; 2990 : 	if (pDefender->getExtraWithdrawal() > 0 && pDefender->CanWithdrawFromMelee(kAttacker, &kCombatInfo))
; 2991 : #else
; 2992 : 	if(pDefender->getExtraWithdrawal() > 0 && pDefender->CanWithdrawFromMelee(kAttacker))

	mov	ecx, esi
	call	?getExtraWithdrawal@CvUnit@@QBEHXZ	; CvUnit::getExtraWithdrawal
	test	eax, eax
	jle	$LN24@Attack
	push	edi
	mov	ecx, esi
	call	?CanWithdrawFromMelee@CvUnit@@IAE_NAAV1@@Z ; CvUnit::CanWithdrawFromMelee
	test	al, al
	je	$LN24@Attack

; 2993 : #endif
; 2994 : 	{
; 2995 : 		pDefender->DoWithdrawFromMelee(kAttacker);

	push	edi
	mov	ecx, esi
	call	?DoWithdrawFromMelee@CvUnit@@IAE_NAAV1@@Z ; CvUnit::DoWithdrawFromMelee

; 2996 : 
; 2997 : 		if(kAttacker.getOwner() == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebp, DWORD PTR [edi+40]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	ebp, eax
	jne	SHORT $LN23@Attack

; 2998 : 		{
; 2999 : 			strBuffer = GetLocalizedText("TXT_KEY_MISC_ENEMY_UNIT_WITHDREW", pDefender->getNameKey());

	mov	ecx, esi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	push	eax
	lea	eax, DWORD PTR $T232328[esp+1728]
	push	OFFSET $SG223477
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+1728]
	mov	BYTE PTR __$EHRec$[esp+1736], 3
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T232328[esp+1724]
	mov	BYTE PTR __$EHRec$[esp+1732], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3000 : 			GC.GetEngineUserInterface()->AddMessage(0, kAttacker.getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+1724]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi+40]
	jmp	SHORT $LN347@Attack
$LN23@Attack:

; 3001 : 		}
; 3002 : 		else if(pDefender->getOwner() == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebp, DWORD PTR [esi+40]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	ebp, eax
	jne	SHORT $LN21@Attack

; 3003 : 		{
; 3004 : 			strBuffer = GetLocalizedText("TXT_KEY_MISC_FRIENDLY_UNIT_WITHDREW", pDefender->getNameKey());

	mov	ecx, esi
	call	?getNameKey@CvUnit@@QBEPBDXZ		; CvUnit::getNameKey
	push	eax
	lea	eax, DWORD PTR $T232329[esp+1728]
	push	OFFSET $SG223481
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+1728]
	mov	BYTE PTR __$EHRec$[esp+1736], 4
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T232329[esp+1724]
	mov	BYTE PTR __$EHRec$[esp+1732], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3005 : 			GC.GetEngineUserInterface()->AddMessage(0, pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+1724]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi+40]
$LN347@Attack:
	push	0
	mov	edx, DWORD PTR [ebp]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	push	0
	mov	ecx, ebp
	call	edx
$LN21@Attack:

; 3006 : 		}
; 3007 : 
; 3008 : 		// Move forward
; 3009 : 		if(targetPlot.getNumVisibleEnemyDefenders(&kAttacker) == 0)

	push	edi
	mov	ecx, ebx
	call	?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z ; CvPlot::getNumVisibleEnemyDefenders
	test	eax, eax
	jne	SHORT $LN20@Attack

; 3010 : 		{
; 3011 : 			kAttacker.UnitMove(&targetPlot, true, &kAttacker);

	push	eax
	push	edi
	push	1
	push	ebx
	mov	ecx, edi
	call	?UnitMove@CvUnit@@QAE_NPAVCvPlot@@_NPAV1@1@Z ; CvUnit::UnitMove
$LN20@Attack:

; 3012 : 		}
; 3013 : 
; 3014 : //		kAttacker.setMadeAttack(true);   /* EFB: Doesn't work, causes tactical AI to not dequeue this attack; but we've decided you don't lose your attack anyway */
; 3015 : 		eResult = ATTACK_COMPLETED;

	mov	edi, 1
	jmp	$LN4@Attack
$LN24@Attack:

; 3016 : 	}
; 3017 : 
; 3018 : 	else if(!pDefender->IsCanDefend())

	push	0
	mov	ecx, esi
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	test	al, al
	jne	$LN18@Attack

; 3019 : 	{
; 3020 : 		CvMissionDefinition kMission;

	lea	ecx, DWORD PTR _kMission$223485[esp+1724]
	call	??0CvMissionDefinition@@QAE@XZ		; CvMissionDefinition::CvMissionDefinition

; 3021 : 		kMission.setMissionTime(kAttacker.getCombatTimer() * gDLL->getSecsPerTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+408]
	call	edx
	fstp	QWORD PTR tv284[esp+1724]
	mov	ecx, edi
	call	?getCombatTimer@CvUnit@@QBEHXZ		; CvUnit::getCombatTimer
	mov	DWORD PTR tv1197[esp+1724], eax
	fild	DWORD PTR tv1197[esp+1724]
	push	ecx
	lea	ecx, DWORD PTR _kMission$223485[esp+1728]
	fmul	QWORD PTR tv284[esp+1728]
	fstp	DWORD PTR tv1195[esp+1728]
	fld	DWORD PTR tv1195[esp+1728]
	fstp	DWORD PTR [esp]
	call	?setMissionTime@CvMissionDefinition@@QAEXM@Z ; CvMissionDefinition::setMissionTime

; 3022 : 		kMission.setMissionType(CvTypes::getMISSION_SURRENDER());

	call	?getMISSION_SURRENDER@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SURRENDER
	push	eax
	lea	ecx, DWORD PTR _kMission$223485[esp+1728]
	call	?setMissionType@CvMissionDefinition@@QAEXW4MissionTypes@@@Z ; CvMissionDefinition::setMissionType

; 3023 : 		kMission.setUnit(BATTLE_UNIT_ATTACKER, &kAttacker);

	push	edi
	push	0
	lea	ecx, DWORD PTR _kMission$223485[esp+1732]
	call	?setUnit@CvMissionDefinition@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z ; CvMissionDefinition::setUnit

; 3024 : 		kMission.setUnit(BATTLE_UNIT_DEFENDER, pDefender.pointer());

	push	esi
	push	1
	lea	ecx, DWORD PTR _kMission$223485[esp+1732]
	call	?setUnit@CvMissionDefinition@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z ; CvMissionDefinition::setUnit

; 3025 : 		kMission.setPlot(&targetPlot);

	push	ebx
	lea	ecx, DWORD PTR _kMission$223485[esp+1728]
	call	?setPlot@CvMissionDefinition@@QAEXPBVCvPlot@@@Z ; CvMissionDefinition::setPlot

; 3026 : 
; 3027 : 		// Surrender mission
; 3028 : 		CvMissionInfo* pkSurrenderMission = GC.getMissionInfo(CvTypes::getMISSION_SURRENDER());

	call	?getMISSION_SURRENDER@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SURRENDER
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMissionInfo@CvGlobals@@QAEPAVCvMissionInfo@@W4MissionTypes@@@Z ; CvGlobals::getMissionInfo

; 3029 : 		if(pkSurrenderMission == NULL)

	test	eax, eax
	je	SHORT $LN16@Attack

; 3030 : 		{
; 3031 : 			CvAssert(false);
; 3032 : 		}
; 3033 : 		else
; 3034 : 		{
; 3035 : 			kAttacker.setCombatTimer(pkSurrenderMission->getTime());

	mov	ecx, eax
	call	?getTime@CvMissionInfo@@QBEHXZ		; CvMissionInfo::getTime
	push	eax
	mov	ecx, edi
	call	?setCombatTimer@CvUnit@@QAEXH@Z		; CvUnit::setCombatTimer
$LN16@Attack:

; 3036 : 		}
; 3037 : 
; 3038 : 		// Kill them!
; 3039 : 		pDefender->setDamage(GC.getMAX_HIT_POINTS());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	push	0
	push	ecx
	mov	DWORD PTR [esp], 0
	push	-1
	push	eax
	mov	ecx, esi
	call	?setDamage@CvUnit@@QAEHHW4PlayerTypes@@MPBVCvString@@@Z ; CvUnit::setDamage

; 3040 : 
; 3041 : 		Localization::String strMessage;

	mov	ebx, DWORD PTR __imp_??0String@Localization@@QAE@XZ
	lea	ecx, DWORD PTR _strMessage$223489[esp+1724]
	call	ebx

; 3042 : 		Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$223490[esp+1724]
	mov	BYTE PTR __$EHRec$[esp+1732], 5
	call	ebx

; 3043 : 
; 3044 : 		// Some units can't capture civilians. Embarked units are also not captured, they're simply killed. And some aren't a type that gets captured.
; 3045 : 		if(!kAttacker.isNoCapture() && (!pDefender->isEmbarked() || pDefender->getUnitInfo().IsCaptureWhileEmbarked()) && pDefender->getCaptureUnitType(GET_PLAYER(pDefender->getOwner()).getCivilizationType()) != NO_UNIT)

	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+1732], 6
	call	?isNoCapture@CvUnit@@QBE_NXZ		; CvUnit::isNoCapture
	test	al, al
	jne	$LN15@Attack
	cmp	BYTE PTR [esi+1652], al
	je	SHORT $LN14@Attack
	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?IsCaptureWhileEmbarked@CvUnitEntry@@QBE_NXZ ; CvUnitEntry::IsCaptureWhileEmbarked
	test	al, al
	je	$LN15@Attack
$LN14@Attack:
	mov	eax, DWORD PTR [esi+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	push	eax
	mov	ecx, esi
	call	?getCaptureUnitType@CvUnit@@QBE?AW4UnitTypes@@W4CivilizationTypes@@@Z ; CvUnit::getCaptureUnitType
	cmp	eax, -1
	je	$LN15@Attack

; 3046 : 		{
; 3047 : 			pDefender->setCapturingPlayer(kAttacker.getOwner());

	mov	eax, DWORD PTR [edi+40]
	push	eax
	mov	ecx, esi
	call	?setCapturingPlayer@CvUnit@@QAEXW4PlayerTypes@@@Z ; CvUnit::setCapturingPlayer

; 3048 : 
; 3049 : 			if(kAttacker.isBarbarian())

	mov	ecx, edi
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian

; 3050 : 			{
; 3051 : 				strMessage = Localization::Lookup("TXT_KEY_UNIT_CAPTURED_BARBS_DETAILED");

	mov	ebx, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	ecx, DWORD PTR $T232330[esp+1724]
	test	al, al
	je	$LN13@Attack
	push	OFFSET $SG223495
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$223489[esp+1728]
	mov	BYTE PTR __$EHRec$[esp+1736], 7
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	ebp, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR $T232330[esp+1724]
	mov	BYTE PTR __$EHRec$[esp+1732], 6
	call	ebp

; 3052 : 				strMessage << pDefender->getUnitInfo().GetTextKey() << GET_PLAYER(kAttacker.getOwner()).getNameKey();

	mov	eax, DWORD PTR [edi+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	ecx, esi
	mov	DWORD PTR $T232331[esp+1724], eax
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	lea	ecx, DWORD PTR _strMessage$223489[esp+1728]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	mov	edx, DWORD PTR $T232331[esp+1724]
	push	edx
	lea	ecx, DWORD PTR _strMessage$223489[esp+1728]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 3053 : 				strSummary = Localization::Lookup("TXT_KEY_UNIT_CAPTURED_BARBS");

	lea	eax, DWORD PTR $T232333[esp+1724]
	push	OFFSET $SG223499
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$223490[esp+1728]
	mov	BYTE PTR __$EHRec$[esp+1736], 8
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T232333[esp+1724]
	mov	BYTE PTR __$EHRec$[esp+1732], 6
	call	ebp

; 3054 : 			}
; 3055 : 			else

	jmp	$LN11@Attack
$LN13@Attack:

; 3056 : 			{
; 3057 : 				strMessage = Localization::Lookup("TXT_KEY_UNIT_CAPTURED_DETAILED");

	push	OFFSET $SG223502
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$223489[esp+1728]
	mov	BYTE PTR __$EHRec$[esp+1736], 9
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	ebp, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR $T232334[esp+1724]
	mov	BYTE PTR __$EHRec$[esp+1732], 6
	call	ebp

; 3058 : 				strMessage << pDefender->getUnitInfo().GetTextKey();

	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	lea	ecx, DWORD PTR _strMessage$223489[esp+1728]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 3059 : 				strSummary = Localization::Lookup("TXT_KEY_UNIT_CAPTURED");

	lea	edx, DWORD PTR $T232336[esp+1724]
	push	OFFSET $SG223505
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$223490[esp+1728]
	mov	BYTE PTR __$EHRec$[esp+1736], 10	; 0000000aH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T232336[esp+1724]
	mov	BYTE PTR __$EHRec$[esp+1732], 6
	call	ebp

; 3060 : 			}
; 3061 : 		}
; 3062 : 		// Unit was killed instead
; 3063 : 		else

	jmp	SHORT $LN11@Attack
$LN15@Attack:

; 3064 : 		{
; 3065 : 			strMessage = Localization::Lookup("TXT_KEY_UNIT_LOST");

	lea	eax, DWORD PTR $T232337[esp+1724]
	push	OFFSET $SG223508
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	ebx, DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	push	eax
	lea	ecx, DWORD PTR _strMessage$223489[esp+1728]
	mov	BYTE PTR __$EHRec$[esp+1736], 11	; 0000000bH
	call	ebx
	mov	ebp, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR $T232337[esp+1724]
	mov	BYTE PTR __$EHRec$[esp+1732], 6
	call	ebp

; 3066 : 			strSummary = strMessage;

	lea	ecx, DWORD PTR _strMessage$223489[esp+1724]
	push	ecx
	lea	ecx, DWORD PTR _strSummary$223490[esp+1728]
	call	ebx
$LN11@Attack:

; 3067 : 		}
; 3068 : 
; 3069 : 		CvNotifications* pNotification = GET_PLAYER(pDefender->getOwner()).GetNotifications();

	mov	eax, DWORD PTR [esi+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ebx, eax

; 3070 : 		if(pNotification)

	test	ebx, ebx
	je	SHORT $LN10@Attack

; 3071 : 			pNotification->Add(NOTIFICATION_UNIT_DIED, strMessage.toUTF8(), strSummary.toUTF8(), pDefender->getX(), pDefender->getY(), (int) pDefender->getUnitType(), pDefender->getOwner());

	mov	ecx, DWORD PTR [esi+76]
	mov	eax, DWORD PTR [esi+40]
	mov	edx, DWORD PTR [esi+88]
	mov	DWORD PTR $T232759[esp+1724], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR $T232746[esp+1728], edx
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	mov	edx, DWORD PTR $T232746[esp+1728]
	push	eax
	mov	eax, DWORD PTR $T232759[esp+1732]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _strSummary$223490[esp+1740]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMessage$223489[esp+1744]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	-16309126				; ff07247aH
	mov	ecx, ebx
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN10@Attack:

; 3072 : 
; 3073 : 		bool bAdvance;
; 3074 : 		bAdvance = kAttacker.canAdvance(targetPlot, ((pDefender->IsCanDefend()) ? 1 : 0));

	push	0
	mov	ecx, esi
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	mov	ebx, DWORD PTR _targetPlot$[esp+1720]
	xor	ecx, ecx
	test	al, al
	setne	cl
	push	ecx
	push	ebx
	mov	ecx, edi
	call	?canAdvance@CvUnit@@IBE_NABVCvPlot@@H@Z	; CvUnit::canAdvance

; 3075 : 
; 3076 : 		// Move forward
; 3077 : 		if(targetPlot.getNumVisibleEnemyDefenders(&kAttacker) == 0)

	push	edi
	mov	ecx, ebx
	mov	BYTE PTR _bAdvance$223512[esp+1728], al
	call	?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z ; CvPlot::getNumVisibleEnemyDefenders
	test	eax, eax
	jne	SHORT $LN9@Attack

; 3078 : 		{
; 3079 : 			kAttacker.UnitMove(&targetPlot, true, ((bAdvance) ? &kAttacker : NULL));

	movzx	edx, BYTE PTR _bAdvance$223512[esp+1724]
	neg	edx
	push	eax
	sbb	edx, edx
	and	edx, edi
	push	edx
	push	1
	push	ebx
	mov	ecx, edi
	call	?UnitMove@CvUnit@@QAE_NPAVCvPlot@@_NPAV1@1@Z ; CvUnit::UnitMove
$LN9@Attack:

; 3080 : 		}
; 3081 : 
; 3082 : 		// KWG: Should this be called? The defender is killed above and the unit.
; 3083 : 		//      If anything, the above code should be put in the ResolveCombat method.
; 3084 : 		ResolveCombat(kCombatInfo);

	lea	eax, DWORD PTR _kCombatInfo$[esp+1724]
	push	0
	push	eax
	call	?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveCombat
	add	esp, 8

; 3085 : 		eResult = ATTACK_COMPLETED;
; 3086 : 	}

	lea	ecx, DWORD PTR _strSummary$223490[esp+1724]
	mov	edi, 1
	mov	BYTE PTR __$EHRec$[esp+1732], 5
	call	ebp
	lea	ecx, DWORD PTR _strMessage$223489[esp+1724]
	mov	BYTE PTR __$EHRec$[esp+1732], 1
	call	ebp

; 3087 : 	else

	jmp	$LN4@Attack
$LN18@Attack:

; 3088 : 	{
; 3089 : 		ATTACK_RESULT eSupportResult = ATTACK_ABORTED;
; 3090 : 		if(eOption != ATTACK_OPTION_NO_DEFENSIVE_SUPPORT)

	cmp	DWORD PTR _eOption$[esp+1720], 1
	je	$LN337@Attack

; 3091 : 		{
; 3092 : 			// Ranged fire support from artillery units
; 3093 : 			CvUnit* pFireSupportUnit = GetFireSupportUnit(pDefender->getOwner(), pDefender->getX(), pDefender->getY(), kAttacker.getX(), kAttacker.getY());

	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	mov	edx, DWORD PTR [esi+88]
	mov	ebp, DWORD PTR [esi+76]
	mov	ebx, DWORD PTR [esi+40]
	push	eax
	push	ecx
	push	edx
	push	ebp
	push	ebx
	call	?GetFireSupportUnit@CvUnitCombat@@SAPAVCvUnit@@W4PlayerTypes@@HHHH@Z ; CvUnitCombat::GetFireSupportUnit
	mov	ebp, eax
	add	esp, 20					; 00000014H

; 3094 : 			if(pFireSupportUnit != NULL)

	test	ebp, ebp
	je	SHORT $LN337@Attack

; 3095 : 			{
; 3096 : 				CvAssertMsg(!pFireSupportUnit->isDelayedDeath(), "Supporting battle unit is already dead!");
; 3097 : 				eSupportResult = AttackRanged(*pFireSupportUnit, kAttacker.getX(), kAttacker.getY(), CvUnitCombat::ATTACK_OPTION_NO_DEFENSIVE_SUPPORT);

	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	push	1
	push	eax
	push	ecx
	push	ebp
	call	?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z ; CvUnitCombat::AttackRanged
	add	esp, 16					; 00000010H

; 3098 : 				// Turn off Fortify Turns, as this is the trigger for whether or not a ranged Unit can provide support fire (in addition to hasMadeAttack)
; 3099 : 				pFireSupportUnit->setFortifyTurns(0);

	push	0
	mov	ecx, ebp
	mov	ebx, eax
	call	?setFortifyTurns@CvUnit@@QAEXH@Z	; CvUnit::setFortifyTurns

; 3100 : 			}
; 3101 : 
; 3102 : 			if(eSupportResult == ATTACK_QUEUED)

	cmp	ebx, 2
	jne	SHORT $LN337@Attack

; 3103 : 			{
; 3104 : 				// The supporting unit has queued their attack (against the attacker), we must have the attacker queue its attack.
; 3105 : 				// Also, flag the current mission that the next time through, the defender doesn't get any defensive support.
; 3106 : 				const_cast<MissionData*>(kAttacker.GetHeadMissionData())->iFlags |= MISSION_MODIFIER_NO_DEFENSIVE_SUPPORT;

	mov	ecx, edi
	call	?GetHeadMissionData@CvUnit@@QAEPBUMissionData@@XZ ; CvUnit::GetHeadMissionData
	or	DWORD PTR [eax+12], 256			; 00000100H

; 3107 : 				CvUnitMission::WaitFor(&kAttacker, pFireSupportUnit);

	sub	esp, 8
	add	eax, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T232338[esp+1732], esp
	push	ebp
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T232339[esp+1740], esp
	push	edi
	mov	BYTE PTR __$EHRec$[esp+1752], 12	; 0000000cH
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	BYTE PTR __$EHRec$[esp+1748], 1
	call	?WaitFor@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@0@Z ; CvUnitMission::WaitFor
	add	esp, 16					; 00000010H

; 3108 : 				eResult = ATTACK_QUEUED;

	mov	edi, ebx

; 3109 : 			}
; 3110 : 		}
; 3111 : 
; 3112 : 		if(eResult != ATTACK_QUEUED)

	jmp	$LN4@Attack
$LN337@Attack:

; 3113 : 		{
; 3114 : 			kAttacker.setMadeAttack(true);

	push	1
	mov	ecx, edi
	call	?setMadeAttack@CvUnit@@QAEX_N@Z		; CvUnit::setMadeAttack

; 3115 : 
; 3116 : 			uint uiParentEventID = 0;
; 3117 : 			// Send the combat message if the target plot is visible.
; 3118 : 			bool isTargetVisibleToActivePlayer = targetPlot.isActiveVisible(false);

	mov	ecx, DWORD PTR _targetPlot$[esp+1720]
	xor	ebx, ebx
	push	ebx
	call	?isActiveVisible@CvPlot@@QBE_N_N@Z	; CvPlot::isActiveVisible
	mov	BYTE PTR _isTargetVisibleToActivePlayer$223525[esp+1724], al

; 3119 : 			bool quickCombat = CvPreGame::quickCombat();

	call	?quickCombat@CvPreGame@@YA_NXZ		; CvPreGame::quickCombat

; 3120 : 			if(!quickCombat)

	test	al, al
	jne	$LN3@Attack

; 3121 : 			{
; 3122 : 				// Center camera here!
; 3123 : 				if(isTargetVisibleToActivePlayer)

	cmp	BYTE PTR _isTargetVisibleToActivePlayer$223525[esp+1724], al
	je	SHORT $LN311@Attack

; 3124 : 				{
; 3125 : 					auto_ptr<ICvPlot1> pDefenderPlot = GC.WrapPlotPointer(pDefender->plot());

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	lea	ecx, DWORD PTR $T232340[esp+1728]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ; CvGlobals::WrapPlotPointer
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR _pDefenderPlot$223576[esp+1724], ebp
	mov	eax, DWORD PTR $T232340[esp+1724]
	mov	BYTE PTR __$EHRec$[esp+1732], 13	; 0000000dH
	test	eax, eax
	je	SHORT $LN302@Attack
	mov	edx, DWORD PTR [eax]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN302@Attack:

; 3126 : 					GC.GetEngineUserInterface()->lookAt(pDefenderPlot.get(), CAMERALOOKAT_NORMAL);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+272]
	push	0
	push	ebp
	call	eax

; 3127 : 				}

	mov	BYTE PTR __$EHRec$[esp+1732], 1
	test	ebp, ebp
	je	SHORT $LN311@Attack
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	ebp
	call	edx
$LN311@Attack:

; 3128 : 				kCombatInfo.setVisualizeCombat(isTargetVisibleToActivePlayer);

	mov	eax, DWORD PTR _isTargetVisibleToActivePlayer$223525[esp+1724]
	push	eax
	lea	ecx, DWORD PTR _kCombatInfo$[esp+1728]
	call	?setVisualizeCombat@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setVisualizeCombat

; 3129 : 
; 3130 : 				auto_ptr<ICvCombatInfo1> pDllCombatInfo(new CvDllCombatInfo(&kCombatInfo));

	push	12					; 0000000cH
	call	??2CvDllCombatInfo@@SAPAXI@Z		; CvDllCombatInfo::operator new
	add	esp, 4
	mov	DWORD PTR $T232343[esp+1724], eax
	mov	BYTE PTR __$EHRec$[esp+1732], 14	; 0000000eH
	test	eax, eax
	je	SHORT $LN33@Attack
	lea	ecx, DWORD PTR _kCombatInfo$[esp+1724]
	push	ecx
	mov	ecx, eax
	call	??0CvDllCombatInfo@@QAE@PAVCvCombatInfo@@@Z ; CvDllCombatInfo::CvDllCombatInfo
	mov	ebp, eax
	jmp	SHORT $LN34@Attack
$LN33@Attack:
	xor	ebp, ebp
$LN34@Attack:
	mov	DWORD PTR _pDllCombatInfo$223648[esp+1724], ebp

; 3131 : 				uiParentEventID = gDLL->GameplayUnitCombat(pDllCombatInfo.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+644]
	push	ebp
	mov	BYTE PTR __$EHRec$[esp+1736], 15	; 0000000fH
	call	eax

; 3132 : 
; 3133 : 				// Set the combat units so that other missions do not continue until combat is over.
; 3134 : 				kAttacker.setCombatUnit(pDefender.pointer(), true);

	push	1
	push	esi
	mov	ecx, edi
	mov	ebx, eax
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 3135 : 				pDefender->setCombatUnit(&kAttacker, false);

	push	0
	push	edi
	mov	ecx, esi
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 3136 : 
; 3137 : 				eResult = ATTACK_QUEUED;

	mov	edi, 2

; 3138 : 			}

	mov	BYTE PTR __$EHRec$[esp+1732], 1
	test	ebp, ebp
	je	SHORT $LN1@Attack
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	ebp
	call	edx

; 3139 : 			else

	jmp	SHORT $LN1@Attack
$LN3@Attack:

; 3140 : 				eResult = ATTACK_COMPLETED;

	mov	edi, 1
$LN1@Attack:

; 3141 : 
; 3142 : 			// Resolve combat here.
; 3143 : 			ResolveCombat(kCombatInfo, uiParentEventID);

	lea	eax, DWORD PTR _kCombatInfo$[esp+1724]
	push	ebx
	push	eax
	call	?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveCombat
	add	esp, 8
$LN4@Attack:

; 3144 : 
; 3145 : 		}
; 3146 : 	}
; 3147 : 
; 3148 : 	return eResult;

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+1732], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	lea	ecx, DWORD PTR _strBuffer$[esp+1724]
	mov	DWORD PTR __$EHRec$[esp+1732], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, edi
$LN31@Attack:

; 3149 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+1724]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 1708				; 000006acH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$1:
	lea	ecx, DWORD PTR _pDefender$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$2:
	lea	ecx, DWORD PTR $T232325[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$3:
	lea	ecx, DWORD PTR $T232328[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$4:
	lea	ecx, DWORD PTR $T232329[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$5:
	lea	ecx, DWORD PTR _strMessage$223489[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$6:
	lea	ecx, DWORD PTR _strSummary$223490[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$7:
	lea	ecx, DWORD PTR $T232330[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$8:
	lea	ecx, DWORD PTR $T232333[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$9:
	lea	ecx, DWORD PTR $T232334[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$10:
	lea	ecx, DWORD PTR $T232336[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$11:
	lea	ecx, DWORD PTR $T232337[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$12:
	mov	ecx, DWORD PTR $T232338[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$15:
	lea	ecx, DWORD PTR _pDefenderPlot$223576[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$16:
	mov	eax, DWORD PTR $T232343[ebp]
	push	eax
	call	??3CvDllCombatInfo@@SAXPAX@Z		; CvDllCombatInfo::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z$17:
	lea	ecx, DWORD PTR _pDllCombatInfo$223648[ebp]
	jmp	??1?$auto_ptr@VICvCombatInfo1@@@std@@QAE@XZ ; std::auto_ptr<ICvCombatInfo1>::~auto_ptr<ICvCombatInfo1>
__ehhandler$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Attack@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@AAVCvPlot@@W4ATTACK_OPTION@1@@Z ENDP ; CvUnitCombat::Attack
PUBLIC	??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FFastSmallFixedList<IDInfo,25,1,297,0>::FFastSmallFixedList<IDInfo,25,1,297,0>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ PROC ; FFastSmallFixedList<IDInfo,25,1,297,0>::FFastSmallFixedList<IDInfo,25,1,297,0>, COMDAT
; _this$ = ecx

; 841  :     FFastSmallFixedList()

	push	-1
	push	__ehhandler$??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+8], 25			; 00000019H
	mov	DWORD PTR [eax], ecx

; 842  :     {
; 843  :         clear();
; 844  :     };

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,25,1,297,0>::~FStaticVector<IDInfo,25,1,297,0>
__ehhandler$??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FFastSmallFixedList<IDInfo,25,1,297,0>::FFastSmallFixedList<IDInfo,25,1,297,0>
PUBLIC	?GenerateNuclearExplosionDamage@CvUnitCombat@@KAXPAVCvPlot@@HPAVCvUnit@@PAUCvCombatMemberEntry@@PAHH@Z ; CvUnitCombat::GenerateNuclearExplosionDamage
EXTRN	?isNukeImmune@CvUnit@@QBE_NXZ:PROC		; CvUnit::isNukeImmune
EXTRN	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z:PROC	; getUnit
EXTRN	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z:PROC ; CvPlot::nextUnitNode
EXTRN	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ:PROC	; CvPlot::headUnitNode
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GenerateNuclearExplosionDamage@CvUnitCombat@@KAXPAVCvPlot@@HPAVCvUnit@@PAUCvCombatMemberEntry@@PAHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GenerateNuclearExplosionDamage@CvUnitCombat@@KAXPAVCvPlot@@HPAVCvUnit@@PAUCvCombatMemberEntry@@PAHH@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GenerateNuclearExplosionDamage@CvUnitCombat@@KAXPAVCvPlot@@HPAVCvUnit@@PAUCvCombatMemberEntry@@PAHH@Z$0
__ehfuncinfo$?GenerateNuclearExplosionDamage@CvUnitCombat@@KAXPAVCvPlot@@HPAVCvUnit@@PAUCvCombatMemberEntry@@PAHH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GenerateNuclearExplosionDamage@CvUnitCombat@@KAXPAVCvPlot@@HPAVCvUnit@@PAUCvCombatMemberEntry@@PAHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
xdata$x	ENDS
;	COMDAT ?GenerateNuclearExplosionDamage@CvUnitCombat@@KAXPAVCvPlot@@HPAVCvUnit@@PAUCvCombatMemberEntry@@PAHH@Z
_TEXT	SEGMENT
tv1205 = -316						; size = 4
_iTotalDamage$223373 = -316				; size = 4
$T232997 = -316						; size = 4
_iNukeDamage$223352 = -316				; size = 4
$T233497 = -312						; size = 4
$T233359 = -312						; size = 4
$T233001 = -312						; size = 4
$T232999 = -312						; size = 4
$T233547 = -308						; size = 4
_pLoopCity$223218 = -308				; size = 4
_iDX$223208 = -304					; size = 4
$T233488 = -300						; size = 4
$T233232 = -300						; size = 4
$T233000 = -300						; size = 4
$T233615 = -296						; size = 4
$T233241 = -296						; size = 4
$T232998 = -296						; size = 4
_iBlastRadius$ = -292					; size = 4
_iDY$223212 = -288					; size = 4
_pUnitNode$223341 = -284				; size = 4
$T233163 = -280						; size = 4
$T233614 = -276						; size = 8
$T233358 = -268						; size = 8
tv773 = -260						; size = 4
_pLoopPlot$223216 = -256				; size = 4
tv769 = -252						; size = 4
$T233362 = -248						; size = 8
$T233675 = -240						; size = 8
_oldUnits$223340 = -232					; size = 216
__$EHRec$ = -12						; size = 12
_pkTargetPlot$ = 8					; size = 4
_iDamageLevel$ = 12					; size = 4
_pkAttacker$ = 16					; size = 4
_pkDamageArray$ = 20					; size = 4
_piDamageMembers$ = 24					; size = 4
_iMaxDamageMembers$ = 28				; size = 4
?GenerateNuclearExplosionDamage@CvUnitCombat@@KAXPAVCvPlot@@HPAVCvUnit@@PAUCvCombatMemberEntry@@PAHH@Z PROC ; CvUnitCombat::GenerateNuclearExplosionDamage, COMDAT

; 2613 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?GenerateNuclearExplosionDamage@CvUnitCombat@@KAXPAVCvPlot@@HPAVCvUnit@@PAUCvCombatMemberEntry@@PAHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 304				; 00000130H

; 2614 : 	int iBlastRadius = GC.getNUKE_BLAST_RADIUS();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6672

; 2615 : 
; 2616 : 	*piDamageMembers = 0;

	mov	ecx, DWORD PTR _piDamageMembers$[ebp]
	mov	DWORD PTR [ecx], 0
	push	ebx

; 2617 : 
; 2618 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2619 : 	int iMaxDX, iDX;
; 2620 : 	CvPlot* pLoopPlot;
; 2621 : 	for (int iDY = -iBlastRadius; iDY <= iBlastRadius; iDY++)
; 2622 : 	{
; 2623 : 		iMaxDX = iBlastRadius - MAX(0, iDY);
; 2624 : 		for (iDX = -iBlastRadius - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 2625 : 		{
; 2626 : 			// No need for range check because loops are set up properly
; 2627 : 			pLoopPlot = plotXY(pkTargetPlot->getX(), pkTargetPlot->getY(), iDX, iDY);
; 2628 : #else
; 2629 : 	for(int iDX = -(iBlastRadius); iDX <= iBlastRadius; iDX++)

	mov	ecx, eax
	neg	ecx
	cmp	ecx, eax
	push	esi
	push	edi
	mov	DWORD PTR _iBlastRadius$[esp+328], eax
	mov	DWORD PTR tv769[esp+328], ecx
	mov	DWORD PTR _iDX$223208[esp+328], ecx
	jg	$LN29@GenerateNu
	jmp	SHORT $LN31@GenerateNu
	npad	4
$LL309@GenerateNu:
	mov	eax, DWORD PTR _iBlastRadius$[esp+328]
	mov	ecx, DWORD PTR tv769[esp+328]
$LN31@GenerateNu:

; 2630 : 	{
; 2631 : 		for(int iDY = -(iBlastRadius); iDY <= iBlastRadius; iDY++)

	cmp	ecx, eax
	mov	DWORD PTR _iDY$223212[esp+328], ecx
	jg	$LN30@GenerateNu

; 2632 : 		{
; 2633 : 			CvPlot* pLoopPlot = plotXYWithRangeCheck(pkTargetPlot->getX(), pkTargetPlot->getY(), iDX, iDY, iBlastRadius);

	xor	edx, edx
	cmp	DWORD PTR _iDX$223208[esp+328], edx
	setge	dl
	mov	DWORD PTR tv773[esp+328], edx
$LL28@GenerateNu:
	mov	eax, DWORD PTR _iDY$223212[esp+328]
	xor	ecx, ecx
	test	eax, eax
	setge	cl
	cmp	DWORD PTR tv773[esp+328], ecx
	mov	ecx, DWORD PTR _iDX$223208[esp+328]
	jne	SHORT $LN43@GenerateNu
	test	ecx, ecx
	jge	SHORT $LN47@GenerateNu
	neg	ecx
$LN47@GenerateNu:
	test	eax, eax
	jge	SHORT $LN49@GenerateNu
	neg	eax
$LN49@GenerateNu:
	add	eax, ecx
	jmp	SHORT $LN54@GenerateNu
$LN43@GenerateNu:
	test	ecx, ecx
	jge	SHORT $LN51@GenerateNu
	neg	ecx
$LN51@GenerateNu:
	test	eax, eax
	jge	SHORT $LN53@GenerateNu
	neg	eax
$LN53@GenerateNu:
	cmp	ecx, eax
	jl	SHORT $LN54@GenerateNu
	mov	eax, ecx
$LN54@GenerateNu:
	cmp	eax, DWORD PTR _iBlastRadius$[esp+328]
	jg	$LN27@GenerateNu
	mov	edx, DWORD PTR _iDY$223212[esp+328]
	mov	eax, DWORD PTR _iDX$223208[esp+328]
	push	edx
	push	eax
	mov	eax, DWORD PTR _pkTargetPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	push	ecx
	push	edx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	ebx, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pLoopPlot$223216[esp+328], ebx

; 2634 : #endif
; 2635 : 
; 2636 : 			if(pLoopPlot != NULL)

	test	ebx, ebx
	je	$LN27@GenerateNu

; 2637 : 			{
; 2638 : 				CvCity* pLoopCity = pLoopPlot->getPlotCity();

	mov	eax, DWORD PTR [ebx+104]
	test	eax, eax
	jl	SHORT $LN56@GenerateNu
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN56@GenerateNu
	mov	ecx, DWORD PTR [ebx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	edi, eax
	mov	DWORD PTR _pLoopCity$223218[esp+328], eax
	jmp	SHORT $LN57@GenerateNu
$LN56@GenerateNu:
	xor	edi, edi
	mov	DWORD PTR _pLoopCity$223218[esp+328], edi
$LN57@GenerateNu:

; 2639 : 
; 2640 : 				FFastSmallFixedList<IDInfo, 25, true, c_eCiv5GameplayDLL > oldUnits;

	lea	edx, DWORD PTR _oldUnits$223340[esp+340]
	mov	DWORD PTR _oldUnits$223340[esp+336], 25	; 00000019H
	mov	DWORD PTR _oldUnits$223340[esp+328], edx
	mov	DWORD PTR _oldUnits$223340[esp+332], 0

; 2641 : 				IDInfo* pUnitNode = pLoopPlot->headUnitNode();

	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+336], 1
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	esi, eax

; 2642 : 
; 2643 : 				while(pUnitNode != NULL)

	test	esi, esi
	je	SHORT $LN23@GenerateNu
	npad	1
$LL24@GenerateNu:

; 2644 : 				{
; 2645 : 					oldUnits.insertAtEnd(pUnitNode);

	mov	eax, DWORD PTR _oldUnits$223340[esp+336]
	mov	BYTE PTR _oldUnits$223340[esp+540], 0
	cmp	DWORD PTR _oldUnits$223340[esp+332], eax
	jne	SHORT $LN79@GenerateNu
	push	eax
	lea	ecx, DWORD PTR _oldUnits$223340[esp+332]
	call	?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,25,1,297,0>::GrowSize
$LN79@GenerateNu:
	mov	eax, DWORD PTR _oldUnits$223340[esp+328]
	mov	ecx, DWORD PTR _oldUnits$223340[esp+332]
	lea	eax, DWORD PTR [eax+ecx*8]
	test	eax, eax
	je	SHORT $LN82@GenerateNu
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], ecx
$LN82@GenerateNu:
	inc	DWORD PTR _oldUnits$223340[esp+332]

; 2646 : 					pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);

	push	esi
	mov	ecx, ebx
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL24@GenerateNu
$LN23@GenerateNu:

; 2647 : 				}
; 2648 : 
; 2649 : 				pUnitNode = oldUnits.head();

	cmp	DWORD PTR _oldUnits$223340[esp+332], 0
	jbe	$LN21@GenerateNu
	mov	eax, DWORD PTR _oldUnits$223340[esp+328]
	mov	DWORD PTR _pUnitNode$223341[esp+328], eax

; 2650 : 
; 2651 : 				while(pUnitNode != NULL)

	test	eax, eax
	je	$LN21@GenerateNu
$LL22@GenerateNu:

; 2652 : 				{
; 2653 : 					CvUnit* pLoopUnit = ::getUnit(*pUnitNode);

	mov	esi, DWORD PTR _pUnitNode$223341[esp+328]
	push	esi
	call	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z	; getUnit

; 2654 : 					pUnitNode = oldUnits.next(pUnitNode);

	mov	ecx, DWORD PTR _oldUnits$223340[esp+332]
	sub	esi, ecx
	add	esi, 8
	sar	esi, 3
	mov	edi, eax
	mov	eax, esi
	add	esp, 4
	cmp	eax, DWORD PTR _oldUnits$223340[esp+332]
	jae	SHORT $LN99@GenerateNu
	lea	eax, DWORD PTR [ecx+eax*8]
	jmp	SHORT $LN320@GenerateNu
$LN99@GenerateNu:
	xor	eax, eax
$LN320@GenerateNu:
	mov	DWORD PTR $T233163[esp+328], eax
	mov	DWORD PTR _pUnitNode$223341[esp+328], eax

; 2655 : 
; 2656 : 					if(pLoopUnit != NULL)

	test	edi, edi
	je	$LN13@GenerateNu

; 2657 : 					{
; 2658 : 						if(pLoopUnit != pkAttacker)

	cmp	edi, DWORD PTR _pkAttacker$[ebp]
	je	$LN13@GenerateNu

; 2659 : 						{
; 2660 : 							if(!pLoopUnit->isNukeImmune() && !pLoopUnit->isDelayedDeath())

	mov	ecx, edi
	call	?isNukeImmune@CvUnit@@QBE_NXZ		; CvUnit::isNukeImmune
	test	al, al
	jne	$LN13@GenerateNu
	mov	ecx, edi
	call	?isDelayedDeath@CvUnit@@QBE_NXZ		; CvUnit::isDelayedDeath
	test	al, al
	jne	$LN13@GenerateNu

; 2661 : 							{
; 2662 : 								int iNukeDamage;
; 2663 : 								// How much destruction is unleashed on nearby Units?
; 2664 : 								if(iDamageLevel == 1 && pLoopPlot != pkTargetPlot)	// Nuke level 1, but NOT the plot that got hit directly (units there are killed)

	cmp	DWORD PTR _iDamageLevel$[ebp], 1
	jne	SHORT $LN17@GenerateNu
	mov	edx, DWORD PTR _pkTargetPlot$[ebp]
	cmp	DWORD PTR _pLoopPlot$223216[esp+328], edx
	je	SHORT $LN17@GenerateNu

; 2665 : 								{
; 2666 : 									iNukeDamage = (/*3*/ GC.getNUKE_UNIT_DAMAGE_BASE() + /*4*/ GC.getGame().getJonRandNum(GC.getNUKE_UNIT_DAMAGE_RAND_1(), "Nuke Damage 1") + /*4*/ GC.getGame().getJonRandNum(GC.getNUKE_UNIT_DAMAGE_RAND_2(), "Nuke Damage 2"));

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6628
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6624
	push	OFFSET $SG223354
	push	eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6632
	push	OFFSET $SG223355
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR tv1205[esp+336], eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	ebx, eax
	mov	eax, DWORD PTR tv1205[esp+328]
	add	eax, esi
	add	ebx, eax

; 2667 : 								}
; 2668 : 								// Wipe everything out
; 2669 : 								else

	jmp	SHORT $LN321@GenerateNu
$LN17@GenerateNu:

; 2670 : 								{
; 2671 : 									iNukeDamage = GC.getMAX_HIT_POINTS();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
$LN321@GenerateNu:

; 2672 : 								}
; 2673 : 
; 2674 : 								if(pLoopCity != NULL)

	mov	ecx, DWORD PTR _pLoopCity$223218[esp+328]
	mov	DWORD PTR _iNukeDamage$223352[esp+328], ebx
	test	ecx, ecx
	je	SHORT $LN15@GenerateNu

; 2675 : 								{
; 2676 : 									iNukeDamage *= std::max(0, (pLoopCity->getNukeModifier() + 100));

	call	?getNukeModifier@CvCity@@QBEHXZ		; CvCity::getNukeModifier
	add	eax, 100				; 00000064H
	mov	DWORD PTR $T232997[esp+328], eax
	test	eax, eax
	mov	DWORD PTR $T232998[esp+328], 0
	lea	eax, DWORD PTR $T232997[esp+328]
	jg	SHORT $LN121@GenerateNu
	lea	eax, DWORD PTR $T232998[esp+328]
$LN121@GenerateNu:
	mov	ecx, DWORD PTR [eax]
	imul	ecx, ebx

; 2677 : 									iNukeDamage /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iNukeDamage$223352[esp+328], eax
$LN15@GenerateNu:

; 2678 : 								}
; 2679 : 
; 2680 : 								CvCombatMemberEntry* pkDamageEntry = AddCombatMember(pkDamageArray, piDamageMembers, iMaxDamageMembers, pLoopUnit);

	mov	eax, DWORD PTR [edi+40]
	mov	ecx, DWORD PTR [edi+88]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR [edi+76]
	mov	DWORD PTR $T233232[esp+328], ecx
	mov	ecx, eax
	mov	DWORD PTR $T233241[esp+328], edx
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	mov	DWORD PTR $T233359[esp+328], eax
	lea	eax, DWORD PTR $T233362[esp+328]
	push	eax
	mov	ecx, edi
	call	?GetIDInfo@CvUnit@@QBE?AUIDInfo@@XZ	; CvUnit::GetIDInfo
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _piDamageMembers$[ebp]
	mov	DWORD PTR $T233358[esp+328], ecx
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _iMaxDamageMembers$[ebp]
	mov	DWORD PTR $T233358[esp+332], edx
	jge	$LN13@GenerateNu
	mov	ebx, ecx
	test	ecx, ecx
	jle	SHORT $LN298@GenerateNu
	mov	edx, DWORD PTR _pkDamageArray$[ebp]
	add	edx, 4
	npad	4
$LL146@GenerateNu:
	mov	esi, DWORD PTR [edx-4]
	dec	ebx
	cmp	esi, -1
	je	SHORT $LN143@GenerateNu
	mov	eax, DWORD PTR [edx]
	cmp	eax, -1
	je	SHORT $LN143@GenerateNu
	test	BYTE PTR [edx+4], 1
	jne	SHORT $LN143@GenerateNu
	cmp	eax, DWORD PTR $T233358[esp+332]
	jne	SHORT $LN143@GenerateNu
	cmp	esi, DWORD PTR $T233358[esp+328]
	je	$LN13@GenerateNu
$LN143@GenerateNu:
	add	edx, 36					; 00000024H
	test	ebx, ebx
	jne	SHORT $LL146@GenerateNu
$LN298@GenerateNu:
	mov	edx, DWORD PTR _pkDamageArray$[ebp]
	mov	eax, DWORD PTR $T233358[esp+328]
	lea	ecx, DWORD PTR [ecx+ecx*8]
	lea	esi, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR $T233358[esp+332]
	mov	DWORD PTR [esi], eax
	xor	eax, eax
	mov	edx, 65534				; 0000fffeH
	and	WORD PTR [esi+8], dx
	mov	DWORD PTR [esi+4], ecx
	mov	WORD PTR [esi+10], ax
	mov	ax, WORD PTR $T233241[esp+328]
	xor	ecx, ecx
	xor	edx, edx
	mov	WORD PTR [esi+12], cx
	mov	cx, WORD PTR $T233232[esp+328]
	mov	WORD PTR [esi+14], dx
	mov	edx, DWORD PTR $T233359[esp+328]
	mov	WORD PTR [esi+16], ax
	mov	eax, DWORD PTR _piDamageMembers$[ebp]
	mov	WORD PTR [esi+18], cx
	mov	DWORD PTR [esi+24], edx
	inc	DWORD PTR [eax]

; 2681 : 								if(pkDamageEntry)

	test	esi, esi
	je	SHORT $LN13@GenerateNu

; 2682 : 								{
; 2683 : 									pkDamageEntry->SetDamage(iNukeDamage);

	mov	ax, WORD PTR _iNukeDamage$223352[esp+328]
	mov	WORD PTR [esi+10], ax

; 2684 : 									pkDamageEntry->SetFinalDamage(std::min(iNukeDamage + pLoopUnit->getDamage(), GC.getMAX_HIT_POINTS()));

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, edi
	mov	DWORD PTR $T232999[esp+328], ebx
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	add	eax, DWORD PTR _iNukeDamage$223352[esp+328]
	mov	DWORD PTR $T233000[esp+328], eax
	cmp	ebx, eax
	lea	eax, DWORD PTR $T232999[esp+328]
	jl	SHORT $LN186@GenerateNu
	lea	eax, DWORD PTR $T233000[esp+328]
$LN186@GenerateNu:

; 2685 : 									pkDamageEntry->SetMaxHitPoints(GC.getMAX_HIT_POINTS());
; 2686 : 									if(pkAttacker)

	cmp	DWORD PTR _pkAttacker$[ebp], 0
	mov	eax, DWORD PTR [eax]
	mov	WORD PTR [esi+12], ax
	mov	cx, WORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	WORD PTR [esi+14], cx
	je	SHORT $LN13@GenerateNu

; 2687 : 										pLoopUnit->setCombatUnit(pkAttacker);

	mov	edx, DWORD PTR _pkAttacker$[ebp]
	push	0
	push	edx
	mov	ecx, edi
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit
$LN13@GenerateNu:

; 2650 : 
; 2651 : 				while(pUnitNode != NULL)

	cmp	DWORD PTR $T233163[esp+328], 0
	jne	$LL22@GenerateNu
	mov	edi, DWORD PTR _pLoopCity$223218[esp+328]
$LN21@GenerateNu:

; 2688 : 								}
; 2689 : 								else
; 2690 : 								{
; 2691 : 									CvAssertMsg(*piDamageMembers < iMaxDamageMembers, "Ran out of entries for the nuclear damage array");
; 2692 : 								}
; 2693 : 							}
; 2694 : 						}
; 2695 : 					}
; 2696 : 				}
; 2697 : 
; 2698 : 				if(pLoopCity != NULL)

	test	edi, edi
	je	$LN2@GenerateNu

; 2699 : 				{
; 2700 : 					bool bKillCity = false;
; 2701 : 
; 2702 : 					// Is the city wiped out? - no capitals!
; 2703 : 					if(!pLoopCity->IsOriginalCapital())

	mov	ecx, edi
	call	?IsOriginalCapital@CvCity@@QBE_NXZ	; CvCity::IsOriginalCapital
	test	al, al
	jne	SHORT $LN5@GenerateNu

; 2704 : 					{
; 2705 : 						if(iDamageLevel > 2)

	mov	eax, DWORD PTR _iDamageLevel$[ebp]
	cmp	eax, 2

; 2706 : 						{
; 2707 : 							bKillCity = true;

	jg	SHORT $LN299@GenerateNu

; 2708 : 						}
; 2709 : 						else if(iDamageLevel > 1)

	cmp	eax, 1
	jle	SHORT $LN5@GenerateNu

; 2710 : 						{
; 2711 : 							if(pLoopCity->getPopulation() < /*5*/ GC.getNUKE_LEVEL2_ELIM_POPULATION_THRESHOLD())

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6664
	mov	ecx, edi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, esi
	jge	SHORT $LN5@GenerateNu
$LN299@GenerateNu:

; 2712 : 							{
; 2713 : 								bKillCity = true;
; 2714 : 							}
; 2715 : 						}
; 2716 : 					}
; 2717 : 
; 2718 : 					int iTotalDamage;
; 2719 : 					if(bKillCity)
; 2720 : 					{
; 2721 : 						iTotalDamage = pLoopCity->GetMaxHitPoints();

	mov	ecx, edi
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints

; 2722 : 					}
; 2723 : 					else

	jmp	SHORT $LN322@GenerateNu
$LN5@GenerateNu:

; 2724 : 					{
; 2725 : 						// Add damage to the city
; 2726 : 						iTotalDamage = (pLoopCity->GetMaxHitPoints() - pLoopCity->getDamage()) * /*50*/ GC.getNUKE_CITY_HIT_POINT_DAMAGE();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6668
	mov	ecx, edi
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	mov	ecx, edi
	mov	esi, eax
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	sub	esi, eax
	imul	esi, ebx

; 2727 : 						iTotalDamage /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH

; 2728 : 
; 2729 : 						iTotalDamage += pLoopCity->getDamage();

	mov	ecx, edi
	add	esi, edx
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	add	esi, eax

; 2730 : 
; 2731 : 						// Can't bring a city below 1 HP
; 2732 : 						iTotalDamage = min(iTotalDamage, pLoopCity->GetMaxHitPoints() - 1);

	mov	ecx, edi
	mov	DWORD PTR _iTotalDamage$223373[esp+328], esi
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	dec	eax
	mov	DWORD PTR $T233001[esp+328], eax
	cmp	eax, esi
	lea	eax, DWORD PTR $T233001[esp+328]
	jl	SHORT $LN200@GenerateNu
	lea	eax, DWORD PTR _iTotalDamage$223373[esp+328]
$LN200@GenerateNu:
	mov	eax, DWORD PTR [eax]
$LN322@GenerateNu:

; 2733 : 					}
; 2734 : 
; 2735 : 					CvCombatMemberEntry* pkDamageEntry = AddCombatMember(pkDamageArray, piDamageMembers, iMaxDamageMembers, pLoopCity);

	mov	ecx, DWORD PTR [edi+108]
	mov	edx, DWORD PTR [edi+96]
	mov	DWORD PTR _iTotalDamage$223373[esp+328], eax
	mov	eax, DWORD PTR [edi+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233488[esp+328], ecx
	mov	ecx, eax
	mov	DWORD PTR $T233497[esp+328], edx
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	mov	DWORD PTR $T233615[esp+328], eax
	lea	eax, DWORD PTR $T233675[esp+328]
	push	eax
	mov	ecx, edi
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	mov	ecx, DWORD PTR [eax]
	mov	ebx, DWORD PTR _piDamageMembers$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T233614[esp+328], ecx
	mov	ecx, DWORD PTR [ebx]
	cmp	ecx, DWORD PTR _iMaxDamageMembers$[ebp]
	mov	DWORD PTR $T233614[esp+332], edx
	jge	$LN2@GenerateNu
	mov	DWORD PTR $T233547[esp+328], ecx
	test	ecx, ecx
	jle	SHORT $LN302@GenerateNu
	mov	edx, DWORD PTR _pkDamageArray$[ebp]
	add	edx, 4
	npad	1
$LL225@GenerateNu:
	mov	esi, DWORD PTR [edx-4]
	dec	DWORD PTR $T233547[esp+328]
	cmp	esi, -1
	je	SHORT $LN222@GenerateNu
	mov	eax, DWORD PTR [edx]
	cmp	eax, -1
	je	SHORT $LN222@GenerateNu
	test	BYTE PTR [edx+4], 1
	je	SHORT $LN222@GenerateNu
	cmp	eax, DWORD PTR $T233614[esp+332]
	jne	SHORT $LN222@GenerateNu
	cmp	esi, DWORD PTR $T233614[esp+328]
	je	$LN2@GenerateNu
$LN222@GenerateNu:
	add	edx, 36					; 00000024H
	cmp	DWORD PTR $T233547[esp+328], 0
	jne	SHORT $LL225@GenerateNu
$LN302@GenerateNu:
	mov	edx, DWORD PTR $T233614[esp+328]
	lea	eax, DWORD PTR [ecx+ecx*8]
	mov	ecx, DWORD PTR _pkDamageArray$[ebp]
	or	WORD PTR [ecx+eax*4+8], 1
	lea	esi, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR $T233614[esp+332]
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], eax
	xor	ecx, ecx
	xor	edx, edx
	xor	eax, eax
	mov	WORD PTR [esi+10], cx
	mov	cx, WORD PTR $T233497[esp+328]
	mov	WORD PTR [esi+12], dx
	mov	dx, WORD PTR $T233488[esp+328]
	mov	WORD PTR [esi+14], ax
	mov	eax, DWORD PTR $T233615[esp+328]
	mov	WORD PTR [esi+16], cx
	mov	WORD PTR [esi+18], dx
	mov	DWORD PTR [esi+24], eax
	inc	DWORD PTR [ebx]

; 2736 : 					if(pkDamageEntry)

	test	esi, esi
	je	SHORT $LN2@GenerateNu

; 2737 : 					{
; 2738 : 						pkDamageEntry->SetDamage(iTotalDamage - pLoopCity->getDamage());

	mov	ecx, edi
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	mov	edx, DWORD PTR _iTotalDamage$223373[esp+328]
	mov	ecx, edx
	sub	ecx, eax
	mov	WORD PTR [esi+10], cx

; 2739 : 						pkDamageEntry->SetFinalDamage(iTotalDamage);
; 2740 : 						pkDamageEntry->SetMaxHitPoints(pLoopCity->GetMaxHitPoints());

	mov	ecx, edi
	mov	WORD PTR [esi+12], dx
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	mov	WORD PTR [esi+14], ax

; 2741 : 
; 2742 : 						if(pkAttacker)

	mov	eax, DWORD PTR _pkAttacker$[ebp]
	test	eax, eax
	je	SHORT $LN2@GenerateNu

; 2743 : 							pLoopCity->setCombatUnit(pkAttacker);

	push	0
	push	eax
	mov	ecx, edi
	call	?setCombatUnit@CvCity@@QAEXPAVCvUnit@@_N@Z ; CvCity::setCombatUnit
$LN2@GenerateNu:

; 2744 : 					}
; 2745 : 					else
; 2746 : 					{
; 2747 : 						CvAssertMsg(*piDamageMembers < iMaxDamageMembers, "Ran out of entries for the nuclear damage array");
; 2748 : 					}
; 2749 : 				}
; 2750 : 			}

	mov	eax, DWORD PTR _oldUnits$223340[esp+328]
	lea	ecx, DWORD PTR _oldUnits$223340[esp+340]
	mov	DWORD PTR __$EHRec$[esp+336], -1
	cmp	eax, ecx
	je	SHORT $LN27@GenerateNu
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN27@GenerateNu:
	mov	eax, DWORD PTR _iDY$223212[esp+328]
	inc	eax
	cmp	eax, DWORD PTR _iBlastRadius$[esp+328]
	mov	DWORD PTR _iDY$223212[esp+328], eax
	jle	$LL28@GenerateNu
$LN30@GenerateNu:

; 2617 : 
; 2618 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2619 : 	int iMaxDX, iDX;
; 2620 : 	CvPlot* pLoopPlot;
; 2621 : 	for (int iDY = -iBlastRadius; iDY <= iBlastRadius; iDY++)
; 2622 : 	{
; 2623 : 		iMaxDX = iBlastRadius - MAX(0, iDY);
; 2624 : 		for (iDX = -iBlastRadius - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 2625 : 		{
; 2626 : 			// No need for range check because loops are set up properly
; 2627 : 			pLoopPlot = plotXY(pkTargetPlot->getX(), pkTargetPlot->getY(), iDX, iDY);
; 2628 : #else
; 2629 : 	for(int iDX = -(iBlastRadius); iDX <= iBlastRadius; iDX++)

	mov	eax, DWORD PTR _iDX$223208[esp+328]
	inc	eax
	cmp	eax, DWORD PTR _iBlastRadius$[esp+328]
	mov	DWORD PTR _iDX$223208[esp+328], eax
	jle	$LL309@GenerateNu
$LN29@GenerateNu:

; 2751 : 		}
; 2752 : 	}
; 2753 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+328]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GenerateNuclearExplosionDamage@CvUnitCombat@@KAXPAVCvPlot@@HPAVCvUnit@@PAUCvCombatMemberEntry@@PAHH@Z$1:
	lea	ecx, DWORD PTR _oldUnits$223340[ebp]
	jmp	??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,25,1,297,0>::~FStaticVector<IDInfo,25,1,297,0>
__unwindfunclet$?GenerateNuclearExplosionDamage@CvUnitCombat@@KAXPAVCvPlot@@HPAVCvUnit@@PAUCvCombatMemberEntry@@PAHH@Z$0:
	lea	ecx, DWORD PTR _oldUnits$223340[ebp]
	jmp	??1?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
__ehhandler$?GenerateNuclearExplosionDamage@CvUnitCombat@@KAXPAVCvPlot@@HPAVCvUnit@@PAUCvCombatMemberEntry@@PAHH@Z:
	mov	eax, OFFSET __ehfuncinfo$?GenerateNuclearExplosionDamage@CvUnitCombat@@KAXPAVCvPlot@@HPAVCvUnit@@PAUCvCombatMemberEntry@@PAHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GenerateNuclearExplosionDamage@CvUnitCombat@@KAXPAVCvPlot@@HPAVCvUnit@@PAUCvCombatMemberEntry@@PAHH@Z ENDP ; CvUnitCombat::GenerateNuclearExplosionDamage
PUBLIC	?GenerateNuclearCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@AAVCvPlot@@PAVCvCombatInfo@@@Z ; CvUnitCombat::GenerateNuclearCombatInfo
EXTRN	?setDamageMemberCount@CvCombatInfo@@QAEXH@Z:PROC ; CvCombatInfo::setDamageMemberCount
EXTRN	?getDamageMembers@CvCombatInfo@@QAEPAUCvCombatMemberEntry@@XZ:PROC ; CvCombatInfo::getDamageMembers
EXTRN	?getMaxDamageMemberCount@CvCombatInfo@@QBEHXZ:PROC ; CvCombatInfo::getMaxDamageMemberCount
EXTRN	?setAttackNuclearLevel@CvCombatInfo@@QAEXH@Z:PROC ; CvCombatInfo::setAttackNuclearLevel
EXTRN	?GetNukeDamageLevel@CvUnit@@QBEHXZ:PROC		; CvUnit::GetNukeDamageLevel
EXTRN	?setReconPlot@CvUnit@@QAEXPAVCvPlot@@@Z:PROC	; CvUnit::setReconPlot
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallHook
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC	; CvTeam::declareWar
EXTRN	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z:PROC ; CvUnit::isEnemy
EXTRN	?isNukeVictim@CvUnit@@QBE_NPBVCvPlot@@W4TeamTypes@@@Z:PROC ; CvUnit::isNukeVictim
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GenerateNuclearCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@AAVCvPlot@@PAVCvCombatInfo@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GenerateNuclearCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@AAVCvPlot@@PAVCvCombatInfo@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GenerateNuclearCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@AAVCvPlot@@PAVCvCombatInfo@@@Z$1
__ehfuncinfo$?GenerateNuclearCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@AAVCvPlot@@PAVCvCombatInfo@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GenerateNuclearCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@AAVCvPlot@@PAVCvCombatInfo@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
xdata$x	ENDS
;	COMDAT ?GenerateNuclearCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@AAVCvPlot@@PAVCvCombatInfo@@@Z
_TEXT	SEGMENT
_bWar$ = -112						; size = 1
_bBystander$ = -108					; size = 1
_iDamageMembers$ = -108					; size = 4
_strBuffer$ = -104					; size = 28
_abTeamsAffected$ = -76					; size = 64
__$EHRec$ = -12						; size = 12
_bResult$223034 = 8					; size = 1
_iPlotTeam$ = 8						; size = 4
_kAttacker$ = 8						; size = 4
_args$223033 = 12					; size = 4
_plot$ = 12						; size = 4
_pkCombatInfo$ = 16					; size = 4
?GenerateNuclearCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@AAVCvPlot@@PAVCvCombatInfo@@@Z PROC ; CvUnitCombat::GenerateNuclearCombatInfo, COMDAT

; 2332 : {

	push	-1
	push	__ehhandler$?GenerateNuclearCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@AAVCvPlot@@PAVCvCombatInfo@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	ebp
	push	esi

; 2333 : 	pkCombatInfo->setUnit(BATTLE_UNIT_ATTACKER, &kAttacker);

	mov	esi, DWORD PTR _pkCombatInfo$[esp+120]
	push	edi
	mov	edi, DWORD PTR _kAttacker$[esp+124]
	push	edi
	xor	ebx, ebx
	push	ebx
	mov	ecx, esi
	call	?setUnit@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z ; CvCombatInfo::setUnit

; 2334 : 	pkCombatInfo->setUnit(BATTLE_UNIT_DEFENDER, NULL);

	push	ebx
	push	1
	mov	ecx, esi
	call	?setUnit@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z ; CvCombatInfo::setUnit

; 2335 : 	pkCombatInfo->setPlot(&plot);

	mov	ebp, DWORD PTR _plot$[esp+124]
	push	ebp
	mov	ecx, esi
	call	?setPlot@CvCombatInfo@@QAEXPAVCvPlot@@@Z ; CvCombatInfo::setPlot

; 2336 : 
; 2337 : 	//////////////////////////////////////////////////////////////////////
; 2338 : 
; 2339 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[esp+128]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[esp+136], ebx
	npad	4
$LL11@GenerateNu@2:

; 2340 : 	bool abTeamsAffected[MAX_TEAMS];
; 2341 : 	int iI;
; 2342 : 	for(iI = 0; iI < MAX_TEAMS; iI++)
; 2343 : 	{
; 2344 : 		abTeamsAffected[iI] = kAttacker.isNukeVictim(&plot, ((TeamTypes)iI));

	push	ebx
	push	ebp
	mov	ecx, edi
	call	?isNukeVictim@CvUnit@@QBE_NPBVCvPlot@@W4TeamTypes@@@Z ; CvUnit::isNukeVictim
	mov	BYTE PTR _abTeamsAffected$[esp+ebx+128], al
	inc	ebx
	cmp	ebx, 64					; 00000040H
	jl	SHORT $LL11@GenerateNu@2

; 2345 : 	}
; 2346 : 
; 2347 : 	int iPlotTeam = plot.getTeam();

	movsx	eax, BYTE PTR [ebp+4]
	cmp	eax, -1
	je	SHORT $LN20@GenerateNu@2
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN27@GenerateNu@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _iPlotTeam$[esp+124], eax
	jmp	SHORT $LN19@GenerateNu@2
$LN27@GenerateNu@2:
	or	eax, -1
	mov	DWORD PTR _iPlotTeam$[esp+124], eax
	jmp	SHORT $LN19@GenerateNu@2
$LN20@GenerateNu@2:
	mov	DWORD PTR _iPlotTeam$[esp+124], -1
$LN19@GenerateNu@2:

; 2348 : 	bool bWar = false;

	mov	BYTE PTR _bWar$[esp+128], 0

; 2349 : 	bool bBystander = false;

	mov	BYTE PTR _bBystander$[esp+128], 0

; 2350 : 
; 2351 : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	xor	ebx, ebx
	npad	7
$LL78@GenerateNu@2:

; 2352 : 	{
; 2353 : 		if(abTeamsAffected[iI])

	cmp	BYTE PTR _abTeamsAffected$[esp+ebx+128], 0
	je	SHORT $LN7@GenerateNu@2

; 2354 : 		{
; 2355 : 			if(!kAttacker.isEnemy((TeamTypes)iI))

	push	0
	push	ebx
	mov	ecx, edi
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	test	al, al
	jne	SHORT $LN7@GenerateNu@2

; 2356 : 			{
; 2357 : 				GET_TEAM(kAttacker.getTeam()).declareWar(((TeamTypes)iI));

	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	ecx, eax
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	0
	push	ebx
	call	?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::declareWar

; 2358 : 
; 2359 : 				if (iPlotTeam == iI) 

	cmp	DWORD PTR _iPlotTeam$[esp+124], ebx
	jne	SHORT $LN3@GenerateNu@2

; 2360 : 				{
; 2361 : 					bWar = true;

	mov	BYTE PTR _bWar$[esp+128], 1

; 2362 : 				} 
; 2363 : 				else 

	jmp	SHORT $LN7@GenerateNu@2
$LN3@GenerateNu@2:

; 2364 : 				{
; 2365 : 					bBystander = true;

	mov	BYTE PTR _bBystander$[esp+128], 1
$LN7@GenerateNu@2:

; 2350 : 
; 2351 : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	inc	ebx
	cmp	ebx, 64					; 00000040H
	jl	SHORT $LL78@GenerateNu@2

; 2366 : 				}
; 2367 : 			}
; 2368 : 		}
; 2369 : 	}
; 2370 : 
; 2371 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	ebx, eax

; 2372 : 	if (pkScriptSystem) 

	test	ebx, ebx
	je	$LN1@GenerateNu@2

; 2373 : 	{	
; 2374 : 		CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$223033[esp+124]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 2375 : 
; 2376 : 		args->Push(kAttacker.getOwner());

	mov	eax, DWORD PTR [edi+40]
	mov	ecx, DWORD PTR _args$223033[esp+124]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR __$EHRec$[esp+140], 1
	call	eax

; 2377 : 		args->Push(plot.getX());

	mov	ecx, DWORD PTR _args$223033[esp+124]
	movsx	eax, WORD PTR [ebp]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+8]
	push	eax
	call	edx

; 2378 : 		args->Push(plot.getY());

	mov	ecx, DWORD PTR _args$223033[esp+124]
	movsx	edx, WORD PTR [ebp+2]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+8]
	push	edx
	call	eax

; 2379 : 		args->Push(bWar);

	mov	ecx, DWORD PTR _args$223033[esp+124]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _bWar$[esp+128]
	mov	edx, DWORD PTR [edx+16]
	push	eax
	call	edx

; 2380 : 		args->Push(bBystander);

	mov	ecx, DWORD PTR _args$223033[esp+124]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _bBystander$[esp+128]
	mov	eax, DWORD PTR [eax+16]
	push	edx
	call	eax

; 2381 : 
; 2382 : 		bool bResult;
; 2383 : 		LuaSupport::CallHook(pkScriptSystem, "NuclearDetonation", args.get(), bResult);

	mov	edx, DWORD PTR _args$223033[esp+124]
	lea	ecx, DWORD PTR _bResult$223034[esp+124]
	push	ecx
	push	edx
	push	OFFSET $SG223035
	push	ebx
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 2384 : 	}

	lea	ecx, DWORD PTR _args$223033[esp+124]
	mov	BYTE PTR __$EHRec$[esp+136], 0
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN1@GenerateNu@2:

; 2385 : 
; 2386 : 	kAttacker.setReconPlot(&plot);

	push	ebp
	mov	ecx, edi
	call	?setReconPlot@CvUnit@@QAEXPAVCvPlot@@@Z	; CvUnit::setReconPlot

; 2387 : 
; 2388 : 	//////////////////////////////////////////////////////////////////////
; 2389 : 
; 2390 : 	pkCombatInfo->setFinalDamage(BATTLE_UNIT_ATTACKER, 0);		// Total damage to the unit

	push	0
	push	0
	mov	ecx, esi
	call	?setFinalDamage@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFinalDamage

; 2391 : 	pkCombatInfo->setDamageInflicted(BATTLE_UNIT_ATTACKER, 0);	// Damage inflicted this round

	push	0
	push	0
	mov	ecx, esi
	call	?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setDamageInflicted

; 2392 : 	pkCombatInfo->setFinalDamage(BATTLE_UNIT_DEFENDER, 0);		// Total damage to the unit

	push	0
	push	1
	mov	ecx, esi
	call	?setFinalDamage@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFinalDamage

; 2393 : 	pkCombatInfo->setDamageInflicted(BATTLE_UNIT_DEFENDER, 0);	// Damage inflicted this round

	push	0
	push	1
	mov	ecx, esi
	call	?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setDamageInflicted

; 2394 : 
; 2395 : 	pkCombatInfo->setFearDamageInflicted(BATTLE_UNIT_ATTACKER, 0);

	push	0
	push	0
	mov	ecx, esi
	call	?setFearDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFearDamageInflicted

; 2396 : 
; 2397 : 	pkCombatInfo->setExperience(BATTLE_UNIT_ATTACKER, 0);

	push	0
	push	0
	mov	ecx, esi
	call	?setExperience@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setExperience

; 2398 : 	pkCombatInfo->setMaxExperienceAllowed(BATTLE_UNIT_ATTACKER, 0);

	push	0
	push	0
	mov	ecx, esi
	call	?setMaxExperienceAllowed@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setMaxExperienceAllowed

; 2399 : 	pkCombatInfo->setInBorders(BATTLE_UNIT_ATTACKER, plot.getOwner() != kAttacker.getOwner());	// Not really correct

	movsx	ecx, BYTE PTR [ebp+4]
	mov	eax, DWORD PTR [edi+40]
	cmp	ecx, eax
	setne	dl
	movzx	eax, dl
	push	eax
	push	0
	mov	ecx, esi
	call	?setInBorders@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setInBorders

; 2400 : #ifdef NQ_NO_GG_POINTS_FROM_CS_OR_BARBS
; 2401 : 	pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_ATTACKER, false); // Since experience earned is 0 anyway, no need to bother

	push	0
	push	0
	mov	ecx, esi
	call	?setUpdateGlobal@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setUpdateGlobal

; 2402 : #else
; 2403 : 	pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_ATTACKER, !kAttacker.isBarbarian());
; 2404 : #endif
; 2405 : 
; 2406 : 	pkCombatInfo->setExperience(BATTLE_UNIT_DEFENDER, 0);

	push	0
	push	1
	mov	ecx, esi
	call	?setExperience@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setExperience

; 2407 : 	pkCombatInfo->setMaxExperienceAllowed(BATTLE_UNIT_DEFENDER, 0);

	push	0
	push	1
	mov	ecx, esi
	call	?setMaxExperienceAllowed@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setMaxExperienceAllowed

; 2408 : 	pkCombatInfo->setInBorders(BATTLE_UNIT_DEFENDER, plot.getOwner() == kAttacker.getOwner());

	movsx	ecx, BYTE PTR [ebp+4]
	mov	eax, DWORD PTR [edi+40]
	cmp	ecx, eax
	sete	dl
	movzx	eax, dl
	push	eax
	push	1
	mov	ecx, esi
	call	?setInBorders@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setInBorders

; 2409 : 	pkCombatInfo->setUpdateGlobal(BATTLE_UNIT_DEFENDER, false);

	push	0
	push	1
	mov	ecx, esi
	call	?setUpdateGlobal@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setUpdateGlobal

; 2410 : 
; 2411 : 	pkCombatInfo->setAttackIsBombingMission(true);

	push	1
	mov	ecx, esi
	call	?setAttackIsBombingMission@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setAttackIsBombingMission

; 2412 : 	pkCombatInfo->setDefenderRetaliates(false);

	push	0
	mov	ecx, esi
	call	?setDefenderRetaliates@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setDefenderRetaliates

; 2413 : 	pkCombatInfo->setAttackNuclearLevel(kAttacker.GetNukeDamageLevel() + 1);

	mov	ecx, edi
	call	?GetNukeDamageLevel@CvUnit@@QBEHXZ	; CvUnit::GetNukeDamageLevel
	inc	eax
	push	eax
	mov	ecx, esi
	call	?setAttackNuclearLevel@CvCombatInfo@@QAEXH@Z ; CvCombatInfo::setAttackNuclearLevel

; 2414 : 
; 2415 : 	// Set all of the units in the blast radius to defenders and calculate their damage
; 2416 : 	int iDamageMembers = 0;
; 2417 : 	GenerateNuclearExplosionDamage(&plot, kAttacker.GetNukeDamageLevel(), &kAttacker, pkCombatInfo->getDamageMembers(), &iDamageMembers, pkCombatInfo->getMaxDamageMemberCount());

	mov	ecx, esi
	mov	DWORD PTR _iDamageMembers$[esp+128], 0
	call	?getMaxDamageMemberCount@CvCombatInfo@@QBEHXZ ; CvCombatInfo::getMaxDamageMemberCount
	push	eax
	lea	ecx, DWORD PTR _iDamageMembers$[esp+132]
	push	ecx
	mov	ecx, esi
	call	?getDamageMembers@CvCombatInfo@@QAEPAUCvCombatMemberEntry@@XZ ; CvCombatInfo::getDamageMembers
	push	eax
	push	edi
	mov	ecx, edi
	call	?GetNukeDamageLevel@CvUnit@@QBEHXZ	; CvUnit::GetNukeDamageLevel
	push	eax
	push	ebp
	call	?GenerateNuclearExplosionDamage@CvUnitCombat@@KAXPAVCvPlot@@HPAVCvUnit@@PAUCvCombatMemberEntry@@PAHH@Z ; CvUnitCombat::GenerateNuclearExplosionDamage

; 2418 : 	pkCombatInfo->setDamageMemberCount(iDamageMembers);

	mov	edx, DWORD PTR _iDamageMembers$[esp+152]
	add	esp, 24					; 00000018H
	push	edx
	mov	ecx, esi
	call	?setDamageMemberCount@CvCombatInfo@@QAEXH@Z ; CvCombatInfo::setDamageMemberCount

; 2419 : 
; 2420 : 	GC.GetEngineUserInterface()->setDirty(UnitInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	19					; 00000013H
	call	edx

; 2421 : }

	lea	ecx, DWORD PTR _strBuffer$[esp+128]
	mov	DWORD PTR __$EHRec$[esp+136], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+128]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 112				; 00000070H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GenerateNuclearCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@AAVCvPlot@@PAVCvCombatInfo@@@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GenerateNuclearCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@AAVCvPlot@@PAVCvCombatInfo@@@Z$1:
	lea	ecx, DWORD PTR _args$223033[ebp-4]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?GenerateNuclearCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@AAVCvPlot@@PAVCvCombatInfo@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GenerateNuclearCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@AAVCvPlot@@PAVCvCombatInfo@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GenerateNuclearCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@AAVCvPlot@@PAVCvCombatInfo@@@Z ENDP ; CvUnitCombat::GenerateNuclearCombatInfo
PUBLIC	?ApplyNuclearExplosionDamage@CvUnitCombat@@SAIPAVCvPlot@@HPAVCvUnit@@@Z ; CvUnitCombat::ApplyNuclearExplosionDamage
; Function compile flags: /Ogtpy
;	COMDAT ?ApplyNuclearExplosionDamage@CvUnitCombat@@SAIPAVCvPlot@@HPAVCvUnit@@@Z
_TEXT	SEGMENT
_iDamageMembers$ = -2308				; size = 4
_kDamageMembers$ = -2304				; size = 2304
_pkTargetPlot$ = 8					; size = 4
_iDamageLevel$ = 12					; size = 4
___formal$ = 16						; size = 4
?ApplyNuclearExplosionDamage@CvUnitCombat@@SAIPAVCvPlot@@HPAVCvUnit@@@Z PROC ; CvUnitCombat::ApplyNuclearExplosionDamage, COMDAT

; 2425 : {

	sub	esp, 2308				; 00000904H
	push	ebx
	push	esi

; 2426 : 	CvCombatMemberEntry kDamageMembers[MAX_NUKE_DAMAGE_MEMBERS];

	or	ecx, -1
	push	edi
	mov	edx, 63					; 0000003fH
	lea	eax, DWORD PTR _kDamageMembers$[esp+2328]
	xor	esi, esi
$LL4@ApplyNucle@2:
	xor	edi, edi
	mov	DWORD PTR [eax-8], ecx
	mov	DWORD PTR [eax-4], ecx
	mov	WORD PTR [eax], di
	mov	WORD PTR [eax+2], di
	mov	WORD PTR [eax+4], di
	mov	WORD PTR [eax+6], di
	mov	WORD PTR [eax+8], di
	mov	WORD PTR [eax+10], di
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], esi
	mov	DWORD PTR [eax+24], esi
	add	eax, 36					; 00000024H
	sub	edx, 1
	jns	SHORT $LL4@ApplyNucle@2

; 2427 : 	int iDamageMembers = 0;
; 2428 : 	GenerateNuclearExplosionDamage(pkTargetPlot, iDamageLevel, NULL, &kDamageMembers[0], &iDamageMembers, MAX_NUKE_DAMAGE_MEMBERS);

	mov	edi, DWORD PTR _iDamageLevel$[esp+2316]
	mov	ebx, DWORD PTR _pkTargetPlot$[esp+2316]
	push	64					; 00000040H
	lea	eax, DWORD PTR _iDamageMembers$[esp+2324]
	push	eax
	lea	ecx, DWORD PTR _kDamageMembers$[esp+2328]
	push	ecx
	push	esi
	push	edi
	push	ebx
	mov	DWORD PTR _iDamageMembers$[esp+2344], esi
	call	?GenerateNuclearExplosionDamage@CvUnitCombat@@KAXPAVCvPlot@@HPAVCvUnit@@PAUCvCombatMemberEntry@@PAHH@Z ; CvUnitCombat::GenerateNuclearExplosionDamage

; 2429 : 	return ApplyNuclearExplosionDamage(&kDamageMembers[0], iDamageMembers, NULL, pkTargetPlot, iDamageLevel);

	mov	edx, DWORD PTR _iDamageMembers$[esp+2344]
	push	edi
	push	ebx
	push	esi
	push	edx
	lea	eax, DWORD PTR _kDamageMembers$[esp+2360]
	push	eax
	call	?ApplyNuclearExplosionDamage@CvUnitCombat@@KAIPBUCvCombatMemberEntry@@HPAVCvUnit@@PAVCvPlot@@H@Z ; CvUnitCombat::ApplyNuclearExplosionDamage
	add	esp, 44					; 0000002cH
	pop	edi
	pop	esi
	pop	ebx

; 2430 : }

	add	esp, 2308				; 00000904H
	ret	0
?ApplyNuclearExplosionDamage@CvUnitCombat@@SAIPAVCvPlot@@HPAVCvUnit@@@Z ENDP ; CvUnitCombat::ApplyNuclearExplosionDamage
_TEXT	ENDS
PUBLIC	?AttackNuclear@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z ; CvUnitCombat::AttackNuclear
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?AttackNuclear@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackNuclear@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackNuclear@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackNuclear@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z$3
__ehfuncinfo$?AttackNuclear@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?AttackNuclear@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitcombat.cpp
xdata$x	ENDS
;	COMDAT ?AttackNuclear@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z
_TEXT	SEGMENT
_isTargetVisibleToActivePlayer$223870 = -1396		; size = 1
$T233950 = -1392					; size = 4
_pDllCombatInfo$223894 = -1392				; size = 4
_pDllPlot$223882 = -1392				; size = 4
$T233947 = -1388					; size = 4
_kCombatInfo$ = -1384					; size = 1372
__$EHRec$ = -12						; size = 12
_kAttacker$ = 8						; size = 4
_iX$ = 12						; size = 4
_iY$ = 16						; size = 4
___formal$ = 20						; size = 4
?AttackNuclear@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z PROC ; CvUnitCombat::AttackNuclear, COMDAT

; 3579 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?AttackNuclear@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z
	push	eax

; 3580 : 	ATTACK_RESULT eResult = ATTACK_ABORTED;
; 3581 : 
; 3582 : 	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 1384				; 00000568H
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	eax, -2147483647			; 80000001H
	je	$LN112@AttackNucl
	mov	ebp, DWORD PTR _iY$[esp+1408]
	cmp	ebp, -2147483647			; 80000001H
	je	SHORT $LN112@AttackNucl
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	dl, dl
	je	SHORT $LN114@AttackNucl
	test	eax, eax
	jge	SHORT $LN39@AttackNucl
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN41@AttackNucl
$LN39@AttackNucl:
	cmp	eax, ecx
	jl	SHORT $LN114@AttackNucl
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN41@AttackNucl
$LN114@AttackNucl:
	mov	esi, eax
$LN41@AttackNucl:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN117@AttackNucl
	test	ebp, ebp
	jge	SHORT $LN49@AttackNucl
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN51@AttackNucl
$LN49@AttackNucl:
	cmp	ebp, edi
	jl	SHORT $LN117@AttackNucl
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN51@AttackNucl
$LN117@AttackNucl:
	mov	edx, ebp
$LN51@AttackNucl:
	test	esi, esi
	jl	SHORT $LN112@AttackNucl
	cmp	esi, ecx
	jge	SHORT $LN112@AttackNucl
	test	edx, edx
	jl	SHORT $LN112@AttackNucl
	cmp	edx, edi
	jge	SHORT $LN112@AttackNucl
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	mov	esi, ecx

; 3583 : 	if(NULL == pPlot)

	jne	SHORT $LN14@AttackNucl
$LN112@AttackNucl:

; 3584 : 		return eResult;

	xor	eax, eax
	jmp	$LN15@AttackNucl
$LN14@AttackNucl:

; 3585 : 
; 3586 : 	bool bDoImmediate = CvPreGame::quickCombat();

	call	?quickCombat@CvPreGame@@YA_NXZ		; CvPreGame::quickCombat

; 3587 : 	CvCombatInfo kCombatInfo;

	lea	ecx, DWORD PTR _kCombatInfo$[esp+1412]
	mov	bl, al
	call	??0CvCombatInfo@@QAE@XZ			; CvCombatInfo::CvCombatInfo

; 3588 : 	CvUnitCombat::GenerateNuclearCombatInfo(kAttacker, *pPlot, &kCombatInfo);

	mov	edi, DWORD PTR _kAttacker$[esp+1408]
	lea	eax, DWORD PTR _kCombatInfo$[esp+1412]
	push	eax
	push	esi
	push	edi
	call	?GenerateNuclearCombatInfo@CvUnitCombat@@SAXAAVCvUnit@@AAVCvPlot@@PAVCvCombatInfo@@@Z ; CvUnitCombat::GenerateNuclearCombatInfo
	add	esp, 12					; 0000000cH

; 3589 : 	CvAssertMsg(!kAttacker.isDelayedDeath(), "Trying to battle and the attacker is already dead!");
; 3590 : 	kAttacker.setMadeAttack(true);

	push	1
	mov	ecx, edi
	call	?setMadeAttack@CvUnit@@QAEX_N@Z		; CvUnit::setMadeAttack

; 3591 : 	uint uiParentEventID = 0;

	xor	ebp, ebp

; 3592 : 	if(!bDoImmediate)

	test	bl, bl
	jne	$LN13@AttackNucl

; 3593 : 	{
; 3594 : 		// Nuclear attacks are different in that you can target a plot you can't see, so check to see if the active player
; 3595 : 		// is involved in the combat
; 3596 : 		TeamTypes eActiveTeam = GC.getGame().getActiveTeam();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam

; 3597 : 
; 3598 : 		bool isTargetVisibleToActivePlayer = pPlot->isActiveVisible(false);

	push	0
	mov	ecx, esi
	mov	ebp, eax
	call	?isActiveVisible@CvPlot@@QBE_N_N@Z	; CvPlot::isActiveVisible
	mov	BYTE PTR _isTargetVisibleToActivePlayer$223870[esp+1412], al

; 3599 : 		if(!isTargetVisibleToActivePlayer)

	test	al, al
	jne	SHORT $LN118@AttackNucl

; 3600 : 		{
; 3601 : 			// Is the attacker part of the local team?
; 3602 : 			isTargetVisibleToActivePlayer = (kAttacker.getTeam() != NO_TEAM && eActiveTeam == kAttacker.getTeam());

	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	eax, -1
	je	SHORT $LN17@AttackNucl
	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	ebp, eax
	jne	SHORT $LN17@AttackNucl
	mov	BYTE PTR _isTargetVisibleToActivePlayer$223870[esp+1412], 1
	jmp	SHORT $LN118@AttackNucl
$LN17@AttackNucl:
	xor	bl, bl
	mov	BYTE PTR _isTargetVisibleToActivePlayer$223870[esp+1412], bl

; 3603 : 
; 3604 : 			if(!isTargetVisibleToActivePlayer)
; 3605 : 			{
; 3606 : 				// Are any of the teams effected by the blast in the local team?
; 3607 : 				for(int i = 0; i < MAX_TEAMS && !isTargetVisibleToActivePlayer; ++i)

	xor	edi, edi
$LL10@AttackNucl:
	test	bl, bl
	jne	SHORT $LN119@AttackNucl

; 3608 : 				{
; 3609 : 					if(kAttacker.isNukeVictim(pPlot, ((TeamTypes)i)))

	mov	ecx, DWORD PTR _kAttacker$[esp+1408]
	push	edi
	push	esi
	call	?isNukeVictim@CvUnit@@QBE_NPBVCvPlot@@W4TeamTypes@@@Z ; CvUnit::isNukeVictim
	test	al, al
	je	SHORT $LN9@AttackNucl

; 3610 : 					{
; 3611 : 						isTargetVisibleToActivePlayer = eActiveTeam == ((TeamTypes)i);

	cmp	ebp, edi
	sete	bl
$LN9@AttackNucl:
	inc	edi
	cmp	edi, 64					; 00000040H
	jl	SHORT $LL10@AttackNucl
	mov	BYTE PTR _isTargetVisibleToActivePlayer$223870[esp+1412], bl

; 3612 : 					}
; 3613 : 				}
; 3614 : 			}
; 3615 : 		}
; 3616 : 
; 3617 : 		if(isTargetVisibleToActivePlayer)

	test	bl, bl
	je	SHORT $LN115@AttackNucl
	jmp	SHORT $LN118@AttackNucl
$LN119@AttackNucl:

; 3610 : 					{
; 3611 : 						isTargetVisibleToActivePlayer = eActiveTeam == ((TeamTypes)i);

	mov	BYTE PTR _isTargetVisibleToActivePlayer$223870[esp+1412], bl
$LN118@AttackNucl:

; 3618 : 		{
; 3619 : 			auto_ptr<ICvPlot1> pDllPlot = GC.WrapPlotPointer(pPlot);

	push	esi
	lea	ecx, DWORD PTR $T233947[esp+1416]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ; CvGlobals::WrapPlotPointer
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pDllPlot$223882[esp+1412], edi
	mov	eax, DWORD PTR $T233947[esp+1412]
	mov	DWORD PTR __$EHRec$[esp+1420], 0
	test	eax, eax
	je	SHORT $LN75@AttackNucl
	mov	edx, DWORD PTR [eax]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN75@AttackNucl:

; 3620 : 			GC.GetEngineUserInterface()->lookAt(pDllPlot.get(), CAMERALOOKAT_NORMAL);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+272]
	push	0
	push	edi
	call	eax

; 3621 : 		}

	mov	DWORD PTR __$EHRec$[esp+1420], -1
	test	edi, edi
	je	SHORT $LN115@AttackNucl
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+4]
	push	edi
	call	edx
$LN115@AttackNucl:

; 3622 : 		kCombatInfo.setVisualizeCombat(isTargetVisibleToActivePlayer);

	mov	eax, DWORD PTR _isTargetVisibleToActivePlayer$223870[esp+1412]
	push	eax
	lea	ecx, DWORD PTR _kCombatInfo$[esp+1416]
	call	?setVisualizeCombat@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setVisualizeCombat

; 3623 : 
; 3624 : 		// Set a combat unit/city.  Not really needed for the combat since we are killing everyone, but it is currently the only way a unit is marked that it is 'in-combat'
; 3625 : 		if(pPlot->getPlotCity())

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN5@AttackNucl
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN5@AttackNucl
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	je	SHORT $LN5@AttackNucl

; 3626 : 			kAttacker.setCombatCity(pPlot->getPlotCity());

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN92@AttackNucl
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN92@AttackNucl
	mov	edx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	ecx, DWORD PTR _kAttacker$[esp+1408]
	push	eax
	call	?setCombatCity@CvUnit@@QAEXPAVCvCity@@@Z ; CvUnit::setCombatCity

; 3627 : 		else

	jmp	SHORT $LN2@AttackNucl

; 3626 : 			kAttacker.setCombatCity(pPlot->getPlotCity());

$LN92@AttackNucl:
	mov	ecx, DWORD PTR _kAttacker$[esp+1408]
	xor	eax, eax
	push	eax
	call	?setCombatCity@CvUnit@@QAEXPAVCvCity@@@Z ; CvUnit::setCombatCity

; 3627 : 		else

	jmp	SHORT $LN2@AttackNucl
$LN5@AttackNucl:

; 3628 : 		{
; 3629 : 			if(pPlot->getNumUnits())

	mov	ecx, esi
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	test	eax, eax
	je	SHORT $LN3@AttackNucl

; 3630 : 				kAttacker.setCombatUnit(pPlot->getUnitByIndex(0), true);

	push	1
	push	0
	mov	ecx, esi
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	ecx, DWORD PTR _kAttacker$[esp+1412]
	push	eax
	call	?setCombatUnit@CvUnit@@QAEXPAV1@_N@Z	; CvUnit::setCombatUnit

; 3631 : 			else

	jmp	SHORT $LN2@AttackNucl
$LN3@AttackNucl:

; 3632 : 				kAttacker.setAttackPlot(pPlot, false);

	mov	ecx, DWORD PTR _kAttacker$[esp+1408]
	push	0
	push	esi
	call	?setAttackPlot@CvUnit@@QAEXPBVCvPlot@@_N@Z ; CvUnit::setAttackPlot
$LN2@AttackNucl:

; 3633 : 		}
; 3634 : 
; 3635 : 		auto_ptr<ICvCombatInfo1> pDllCombatInfo(new CvDllCombatInfo(&kCombatInfo));

	push	12					; 0000000cH
	call	??2CvDllCombatInfo@@SAPAXI@Z		; CvDllCombatInfo::operator new
	add	esp, 4
	mov	DWORD PTR $T233950[esp+1412], eax
	mov	DWORD PTR __$EHRec$[esp+1420], 1
	test	eax, eax
	je	SHORT $LN19@AttackNucl
	lea	ecx, DWORD PTR _kCombatInfo$[esp+1412]
	push	ecx
	mov	ecx, eax
	call	??0CvDllCombatInfo@@QAE@PAVCvCombatInfo@@@Z ; CvDllCombatInfo::CvDllCombatInfo
	mov	esi, eax
	jmp	SHORT $LN20@AttackNucl
$LN19@AttackNucl:
	xor	esi, esi
$LN20@AttackNucl:
	mov	DWORD PTR _pDllCombatInfo$223894[esp+1412], esi

; 3636 : 		uiParentEventID = gDLL->GameplayUnitCombat(pDllCombatInfo.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+644]
	mov	edi, 2
	push	esi
	mov	DWORD PTR __$EHRec$[esp+1424], edi
	call	eax
	mov	ebp, eax

; 3637 : 
; 3638 : 		eResult = ATTACK_QUEUED;
; 3639 : 	}

	mov	DWORD PTR __$EHRec$[esp+1420], -1
	test	esi, esi
	je	SHORT $LN1@AttackNucl
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	call	edx

; 3640 : 	else

	jmp	SHORT $LN1@AttackNucl
$LN13@AttackNucl:

; 3641 : 	{
; 3642 : 		eResult = ATTACK_COMPLETED;
; 3643 : 		// Set the plot, just so the unit is marked as 'in-combat'
; 3644 : 		kAttacker.setAttackPlot(pPlot, false);

	mov	ecx, DWORD PTR _kAttacker$[esp+1408]
	push	0
	push	esi
	mov	edi, 1
	call	?setAttackPlot@CvUnit@@QAEXPBVCvPlot@@_N@Z ; CvUnit::setAttackPlot
$LN1@AttackNucl:

; 3645 : 	}
; 3646 : 
; 3647 : 	ResolveCombat(kCombatInfo,  uiParentEventID);

	lea	eax, DWORD PTR _kCombatInfo$[esp+1412]
	push	ebp
	push	eax
	call	?ResolveCombat@CvUnitCombat@@SAXABVCvCombatInfo@@I@Z ; CvUnitCombat::ResolveCombat
	add	esp, 8

; 3648 : 
; 3649 : 	return eResult;

	mov	eax, edi
$LN15@AttackNucl:

; 3650 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+1412]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 1396				; 00000574H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AttackNuclear@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z$1:
	lea	ecx, DWORD PTR _pDllPlot$223882[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__unwindfunclet$?AttackNuclear@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z$2:
	mov	eax, DWORD PTR $T233950[ebp]
	push	eax
	call	??3CvDllCombatInfo@@SAXPAX@Z		; CvDllCombatInfo::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AttackNuclear@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z$3:
	lea	ecx, DWORD PTR _pDllCombatInfo$223894[ebp]
	jmp	??1?$auto_ptr@VICvCombatInfo1@@@std@@QAE@XZ ; std::auto_ptr<ICvCombatInfo1>::~auto_ptr<ICvCombatInfo1>
__ehhandler$?AttackNuclear@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$?AttackNuclear@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AttackNuclear@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z ENDP ; CvUnitCombat::AttackNuclear
END
