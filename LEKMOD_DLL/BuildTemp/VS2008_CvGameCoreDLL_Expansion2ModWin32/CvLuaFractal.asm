; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	s:\Github\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\Lua\CvLuaFractal.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG217229 DB	'FRAC_WRAP_X', 00H
$SG217231 DB	'FRAC_WRAP_Y', 00H
$SG217233 DB	'FRAC_PERCENT', 00H
	ORG $+3
$SG217235 DB	'FRAC_POLAR', 00H
	ORG $+1
$SG217237 DB	'FRAC_CENTER_RIFT', 00H
	ORG $+3
$SG217239 DB	'FRAC_INVERT_HEIGHTS', 00H
$SG217246 DB	'Fractal', 00H
$SG217248 DB	'Fractal', 00H
$SG217249 DB	'Create', 00H
	ORG $+1
$SG217250 DB	'CreateRifts', 00H
$SG217272 DB	'GetHeight', 00H
	ORG $+2
$SG217273 DB	'BuildRidges', 00H
$SG217274 DB	'__index', 00H
$SG217275 DB	'__gc', 00H
	ORG $+3
$SG217325 DB	'Invalid number of arguments.', 00H
CONST	ENDS
PUBLIC	?HasFlag@@YA_NPAUlua_State@@HPBD@Z		; HasFlag
EXTRN	_lua_type:PROC
EXTRN	_lua_getfield:PROC
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluafractal.cpp
;	COMDAT ?HasFlag@@YA_NPAUlua_State@@HPBD@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
_flag$ = 16						; size = 4
?HasFlag@@YA_NPAUlua_State@@HPBD@Z PROC			; HasFlag, COMDAT

; 32   : 	lua_getfield(L, idx, flag);

	mov	eax, DWORD PTR _flag$[esp-4]
	mov	ecx, DWORD PTR _idx$[esp-4]
	push	esi
	mov	esi, DWORD PTR _L$[esp]
	push	eax
	push	ecx
	push	esi
	call	_lua_getfield

; 33   : 	return !lua_isnil(L, -1);

	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	esi

; 34   : }

	ret	0
?HasFlag@@YA_NPAUlua_State@@HPBD@Z ENDP			; HasFlag
_TEXT	ENDS
PUBLIC	?GetFractalFlags@@YAHPAUlua_State@@H@Z		; GetFractalFlags
EXTRN	_lua_settop:PROC
EXTRN	_lua_gettop:PROC
EXTRN	_luaL_checktype:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GetFractalFlags@@YAHPAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
?GetFractalFlags@@YAHPAUlua_State@@H@Z PROC		; GetFractalFlags, COMDAT

; 37   : {

	push	ebx
	push	ebp
	push	esi

; 38   : 	int flags = 0;
; 39   : 	luaL_checktype(L, idx, LUA_TTABLE);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	mov	edi, DWORD PTR _idx$[esp+12]
	push	5
	push	edi
	push	esi
	xor	ebx, ebx
	call	_luaL_checktype

; 40   : 
; 41   : 	const int top = lua_gettop(L);

	push	esi
	call	_lua_gettop

; 42   : 
; 43   : 	if(HasFlag(L, idx, "FRAC_WRAP_X"))

	push	OFFSET $SG217229
	push	edi
	push	esi
	mov	ebp, eax
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 36					; 00000024H
	test	eax, eax
	je	SHORT $LN6@GetFractal

; 44   : 		flags |= CvFractal::FRAC_WRAP_X;

	mov	ebx, 1
$LN6@GetFractal:

; 45   : 
; 46   : 	if(HasFlag(L, idx, "FRAC_WRAP_Y"))

	push	OFFSET $SG217231
	push	edi
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN5@GetFractal

; 47   : 		flags |= CvFractal::FRAC_WRAP_Y;

	or	ebx, 2
$LN5@GetFractal:

; 48   : 
; 49   : 	if(HasFlag(L, idx, "FRAC_PERCENT"))

	push	OFFSET $SG217233
	push	edi
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN4@GetFractal

; 50   : 		flags |= CvFractal::FRAC_PERCENT;

	or	ebx, 4
$LN4@GetFractal:

; 51   : 
; 52   : 	if(HasFlag(L, idx, "FRAC_POLAR"))

	push	OFFSET $SG217235
	push	edi
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN3@GetFractal

; 53   : 		flags |= CvFractal::FRAC_POLAR;

	or	ebx, 8
$LN3@GetFractal:

; 54   : 
; 55   : 	if(HasFlag(L, idx, "FRAC_CENTER_RIFT"))

	push	OFFSET $SG217237
	push	edi
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN2@GetFractal

; 56   : 		flags |= CvFractal::FRAC_CENTER_RIFT;

	or	ebx, 16					; 00000010H
$LN2@GetFractal:

; 57   : 
; 58   : 	if(HasFlag(L, idx, "FRAC_INVERT_HEIGHTS"))

	push	OFFSET $SG217239
	push	edi
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN1@GetFractal

; 59   : 		flags |= CvFractal::FRAC_INVERT_HEIGHTS;

	or	ebx, 32					; 00000020H
$LN1@GetFractal:

; 60   : 
; 61   : 	lua_settop(L, top);

	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 62   : 
; 63   : 	return flags;

	mov	eax, ebx
	pop	ebx

; 64   : }

	ret	0
?GetFractalFlags@@YAHPAUlua_State@@H@Z ENDP		; GetFractalFlags
_TEXT	ENDS
PUBLIC	?lDestroy@CvLuaFractal@@KAHPAUlua_State@@@Z	; CvLuaFractal::lDestroy
EXTRN	_lua_touserdata:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?lDestroy@CvLuaFractal@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lDestroy@CvLuaFractal@@KAHPAUlua_State@@@Z PROC	; CvLuaFractal::lDestroy, COMDAT

; 181  : {

	push	esi

; 182  : 	luaL_checktype(L, 1, LUA_TUSERDATA);

	mov	esi, DWORD PTR _L$[esp]
	push	7
	push	1
	push	esi
	call	_luaL_checktype

; 183  : 	CvFractal* pFractal = static_cast<CvFractal*>(lua_touserdata(L, 1));

	push	1
	push	esi
	call	_lua_touserdata

; 184  : 
; 185  : 	//explicitly call destructor since we used placement new
; 186  : 	pFractal->~CvFractal();

	mov	edx, DWORD PTR [eax]
	add	esp, 20					; 00000014H
	mov	ecx, eax
	mov	eax, DWORD PTR [edx]
	push	0
	call	eax

; 187  : 
; 188  : 	return 0;

	xor	eax, eax
	pop	esi

; 189  : }

	ret	0
?lDestroy@CvLuaFractal@@KAHPAUlua_State@@@Z ENDP	; CvLuaFractal::lDestroy
_TEXT	ENDS
PUBLIC	?lGetHeight@CvLuaFractal@@KAHPAUlua_State@@@Z	; CvLuaFractal::lGetHeight
EXTRN	?getHeightFromPercent@CvFractal@@QAEHH@Z:PROC	; CvFractal::getHeightFromPercent
EXTRN	_lua_pushinteger:PROC
EXTRN	?getHeight@CvFractal@@QAEHHH@Z:PROC		; CvFractal::getHeight
EXTRN	_lua_tointeger:PROC
EXTRN	_luaL_error:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?lGetHeight@CvLuaFractal@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetHeight@CvLuaFractal@@KAHPAUlua_State@@@Z PROC	; CvLuaFractal::lGetHeight, COMDAT

; 192  : {

	push	esi

; 193  : 	//assume 'self' was pushed
; 194  : 	luaL_checktype(L, 1, LUA_TUSERDATA);

	mov	esi, DWORD PTR _L$[esp]
	push	edi
	push	7
	push	1
	push	esi
	call	_luaL_checktype

; 195  : 	CvFractal* pFractal = static_cast<CvFractal*>(lua_touserdata(L, 1));

	push	1
	push	esi
	call	_lua_touserdata

; 196  : 
; 197  : 	int nargs = lua_gettop(L) - 1; //minus self

	push	esi
	mov	edi, eax
	call	_lua_gettop
	dec	eax
	add	esp, 24					; 00000018H

; 198  : 	switch(nargs)

	sub	eax, 1
	je	SHORT $LN3@lGetHeight
	sub	eax, 1
	je	SHORT $LN2@lGetHeight

; 213  : 	}
; 214  : 	break;
; 215  : 	default:
; 216  : 		luaL_error(L, "Invalid number of arguments.");

	push	OFFSET $SG217325
	push	esi
	call	_luaL_error
	add	esp, 8
	pop	edi

; 217  : 	}
; 218  : 
; 219  : 	return 1;

	mov	eax, 1
	pop	esi

; 220  : }

	ret	0
$LN2@lGetHeight:
	push	ebx

; 205  : 	}
; 206  : 	break;
; 207  : 	case 2:
; 208  : 	{
; 209  : 		int x = lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger

; 210  : 		int y = lua_tointeger(L, 3);

	push	3
	push	esi
	mov	ebx, eax
	call	_lua_tointeger
	add	esp, 16					; 00000010H

; 211  : 		int height = pFractal->getHeight(x, y);

	push	eax
	push	ebx
	mov	ecx, edi
	call	?getHeight@CvFractal@@QAEHHH@Z		; CvFractal::getHeight

; 212  : 		lua_pushinteger(L, height);

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	ebx
	pop	edi

; 217  : 	}
; 218  : 
; 219  : 	return 1;

	mov	eax, 1
	pop	esi

; 220  : }

	ret	0
$LN3@lGetHeight:

; 199  : 	{
; 200  : 	case 1:
; 201  : 	{
; 202  : 		int percentage = lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8

; 203  : 		int height = pFractal->getHeightFromPercent(percentage);

	push	eax
	mov	ecx, edi
	call	?getHeightFromPercent@CvFractal@@QAEHH@Z ; CvFractal::getHeightFromPercent

; 204  : 		lua_pushinteger(L, height);

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi

; 217  : 	}
; 218  : 
; 219  : 	return 1;

	mov	eax, 1
	pop	esi

; 220  : }

	ret	0
?lGetHeight@CvLuaFractal@@KAHPAUlua_State@@@Z ENDP	; CvLuaFractal::lGetHeight
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?lBuildRidges@CvLuaFractal@@KAHPAUlua_State@@@Z	; CvLuaFractal::lBuildRidges
EXTRN	?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z:PROC ; CvFractal::ridgeBuilder
EXTRN	?getMapRand@CvGame@@QAEAAVCvRandom@@XZ:PROC	; CvGame::getMapRand
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluafractal.cpp
;	COMDAT ?lBuildRidges@CvLuaFractal@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_iBlendRidge$ = -8					; size = 4
_flags$ = -4						; size = 4
_L$ = 8							; size = 4
?lBuildRidges@CvLuaFractal@@KAHPAUlua_State@@@Z PROC	; CvLuaFractal::lBuildRidges, COMDAT

; 93   : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi

; 94   : 	//assume 'self' was pushed
; 95   : 	luaL_checktype(L, 1, LUA_TUSERDATA);

	mov	esi, DWORD PTR _L$[esp+16]
	push	edi
	push	7
	push	1
	push	esi
	call	_luaL_checktype

; 96   : 	CvFractal* pFractal = static_cast<CvFractal*>(lua_touserdata(L, 1));

	push	1
	push	esi
	call	_lua_touserdata

; 97   : 	CvRandom& mapRand = GC.getGame().getMapRand();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	add	esp, 20					; 00000014H
	mov	edi, eax
	call	?getMapRand@CvGame@@QAEAAVCvRandom@@XZ	; CvGame::getMapRand

; 98   : 
; 99   : 	const int iNumSeeds		= lua_tointeger(L, 2);

	push	2
	push	esi
	mov	ebx, eax
	call	_lua_tointeger

; 100  : 	const int flags			= GetFractalFlags(L, 3);

	push	3
	push	esi
	mov	ebp, eax
	call	?GetFractalFlags@@YAHPAUlua_State@@H@Z	; GetFractalFlags

; 101  : 	const int iBlendRidge	= lua_tointeger(L, 4);

	push	4
	push	esi
	mov	DWORD PTR _flags$[esp+48], eax
	call	_lua_tointeger

; 102  : 	const int iBlendFract	= lua_tointeger(L, 5);

	push	5
	push	esi
	mov	DWORD PTR _iBlendRidge$[esp+56], eax
	call	_lua_tointeger

; 103  : 
; 104  : 	pFractal->ridgeBuilder(mapRand, iNumSeeds, flags, iBlendRidge, iBlendFract);

	mov	ecx, DWORD PTR _flags$[esp+56]
	add	esp, 32					; 00000020H
	push	eax
	mov	eax, DWORD PTR _iBlendRidge$[esp+28]
	push	eax
	push	ecx
	push	ebp
	push	ebx
	mov	ecx, edi
	call	?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z ; CvFractal::ridgeBuilder
	pop	edi
	pop	esi
	pop	ebp

; 105  : 	return 0;

	xor	eax, eax
	pop	ebx

; 106  : }

	add	esp, 8
	ret	0
?lBuildRidges@CvLuaFractal@@KAHPAUlua_State@@@Z ENDP	; CvLuaFractal::lBuildRidges
_TEXT	ENDS
PUBLIC	?CreateFractal@CvLuaFractal@@KAPAVCvFractal@@PAUlua_State@@@Z ; CvLuaFractal::CreateFractal
EXTRN	_lua_setmetatable:PROC
EXTRN	_lua_setfield:PROC
EXTRN	_lua_pushcclosure:PROC
EXTRN	_lua_pushvalue:PROC
EXTRN	_lua_createtable:PROC
EXTRN	??0CvFractal@@QAE@XZ:PROC			; CvFractal::CvFractal
EXTRN	_lua_newuserdata:PROC
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\new
xdata$x	SEGMENT
__unwindtable$?CreateFractal@CvLuaFractal@@KAPAVCvFractal@@PAUlua_State@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateFractal@CvLuaFractal@@KAPAVCvFractal@@PAUlua_State@@@Z$0
__ehfuncinfo$?CreateFractal@CvLuaFractal@@KAPAVCvFractal@@PAUlua_State@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateFractal@CvLuaFractal@@KAPAVCvFractal@@PAUlua_State@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluafractal.cpp
xdata$x	ENDS
;	COMDAT ?CreateFractal@CvLuaFractal@@KAPAVCvFractal@@PAUlua_State@@@Z
_TEXT	SEGMENT
_ptr$ = -20						; size = 4
$T217396 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_L$ = 8							; size = 4
?CreateFractal@CvLuaFractal@@KAPAVCvFractal@@PAUlua_State@@@Z PROC ; CvLuaFractal::CreateFractal, COMDAT

; 109  : {

	push	-1
	push	__ehhandler$?CreateFractal@CvLuaFractal@@KAPAVCvFractal@@PAUlua_State@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi

; 110  : 	//This will use Lua's memory manager and Lua is responsible for destruction.
; 111  : 	void* ptr = lua_newuserdata(L, sizeof(CvFractal));

	mov	esi, DWORD PTR _L$[esp+20]
	push	edi
	push	262184					; 00040028H
	push	esi
	call	_lua_newuserdata
	add	esp, 8
	mov	DWORD PTR _ptr$[esp+28], eax

; 112  : 	CvFractal* pFractal = new(ptr) CvFractal();

	mov	DWORD PTR $T217396[esp+28], eax
	mov	DWORD PTR __$EHRec$[esp+36], 0
	test	eax, eax
	je	SHORT $LN3@CreateFrac
	mov	ecx, eax
	call	??0CvFractal@@QAE@XZ			; CvFractal::CvFractal
	mov	edi, eax
	jmp	SHORT $LN4@CreateFrac
$LN3@CreateFrac:
	xor	edi, edi
$LN4@CreateFrac:

; 113  : 
; 114  : 	lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 115  : 
; 116  : 	//__index
; 117  : 	lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 118  : 
; 119  : 	lua_pushvalue(L, -3);				//push userdata as upvalue

	push	-3					; fffffffdH
	push	esi
	call	_lua_pushvalue

; 120  : 	lua_pushcclosure(L, lGetHeight, 1);

	push	1
	push	OFFSET ?lGetHeight@CvLuaFractal@@KAHPAUlua_State@@@Z ; CvLuaFractal::lGetHeight
	push	esi
	call	_lua_pushcclosure

; 121  : 	lua_setfield(L, -2, "GetHeight");

	push	OFFSET $SG217272
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 122  : 
; 123  : 	lua_pushvalue(L, -3);				//push userdata as upvalue

	push	-3					; fffffffdH
	push	esi
	call	_lua_pushvalue
	add	esp, 64					; 00000040H

; 124  : 	lua_pushcclosure(L, lBuildRidges, 1);

	push	1
	push	OFFSET ?lBuildRidges@CvLuaFractal@@KAHPAUlua_State@@@Z ; CvLuaFractal::lBuildRidges
	push	esi
	call	_lua_pushcclosure

; 125  : 	lua_setfield(L, -2, "BuildRidges");

	push	OFFSET $SG217273
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 126  : 
; 127  : 	lua_setfield(L, -2, "__index");

	push	OFFSET $SG217274
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 128  : 
; 129  : 	//__gc
; 130  : 	lua_pushcclosure(L, lDestroy, 0);

	push	0
	push	OFFSET ?lDestroy@CvLuaFractal@@KAHPAUlua_State@@@Z ; CvLuaFractal::lDestroy
	push	esi
	call	_lua_pushcclosure

; 131  : 	lua_setfield(L, -2, "__gc");

	push	OFFSET $SG217275
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 132  : 
; 133  : 	lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_setmetatable

; 134  : 
; 135  : 	return pFractal;
; 136  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	add	esp, 68					; 00000044H
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateFractal@CvLuaFractal@@KAPAVCvFractal@@PAUlua_State@@@Z$0:
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T217396[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?CreateFractal@CvLuaFractal@@KAPAVCvFractal@@PAUlua_State@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CreateFractal@CvLuaFractal@@KAPAVCvFractal@@PAUlua_State@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateFractal@CvLuaFractal@@KAPAVCvFractal@@PAUlua_State@@@Z ENDP ; CvLuaFractal::CreateFractal
PUBLIC	?lCreate@CvLuaFractal@@KAHPAUlua_State@@@Z	; CvLuaFractal::lCreate
EXTRN	?fracInit@CvFractal@@QAEXHHHAAVCvRandom@@HPAV1@HH@Z:PROC ; CvFractal::fracInit
; Function compile flags: /Ogtpy
;	COMDAT ?lCreate@CvLuaFractal@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_iFracXExp$ = -16					; size = 4
_flags$ = -12						; size = 4
_rand$ = -8						; size = 4
_iGrain$ = -4						; size = 4
_L$ = 8							; size = 4
?lCreate@CvLuaFractal@@KAHPAUlua_State@@@Z PROC		; CvLuaFractal::lCreate, COMDAT

; 139  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi

; 140  : 	CvFractal* pFractal = CreateFractal(L);

	mov	esi, DWORD PTR _L$[esp+24]
	push	edi
	push	esi
	call	?CreateFractal@CvLuaFractal@@KAPAVCvFractal@@PAUlua_State@@@Z ; CvLuaFractal::CreateFractal

; 141  : 
; 142  : 	const int iNewXs = lua_tointeger(L, 1);

	push	1
	push	esi
	mov	edi, eax
	call	_lua_tointeger

; 143  : 	const int iNewYs = lua_tointeger(L, 2);

	push	2
	push	esi
	mov	ebx, eax
	call	_lua_tointeger

; 144  : 	const int iGrain = lua_tointeger(L, 3);

	push	3
	push	esi
	mov	ebp, eax
	call	_lua_tointeger

; 145  : 	CvRandom& rand = GC.getGame().getMapRand();	//Temporary!!

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _iGrain$[esp+32], eax
	call	?getMapRand@CvGame@@QAEAAVCvRandom@@XZ	; CvGame::getMapRand

; 146  : 
; 147  : 	//calculate flags
; 148  : 	const int flags = GetFractalFlags(L, 4);

	push	4
	push	esi
	mov	DWORD PTR _rand$[esp+40], eax
	call	?GetFractalFlags@@YAHPAUlua_State@@H@Z	; GetFractalFlags

; 149  : 
; 150  : 	const int iFracXExp = lua_isnil(L, 5)? CvFractal::DEFAULT_FRAC_X_EXP : lua_tointeger(L, 5);

	push	5
	push	esi
	mov	DWORD PTR _flags$[esp+48], eax
	call	_lua_type
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN3@lCreate
	mov	DWORD PTR _iFracXExp$[esp+32], 7
	jmp	SHORT $LN4@lCreate
$LN3@lCreate:
	push	5
	push	esi
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _iFracXExp$[esp+32], eax
$LN4@lCreate:

; 151  : 	const int iFracYExp = lua_isnil(L, 6)? CvFractal::DEFAULT_FRAC_Y_EXP : lua_tointeger(L, 6);

	push	6
	push	esi
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@lCreate
	mov	eax, 6
	jmp	SHORT $LN6@lCreate
$LN5@lCreate:
	push	6
	push	esi
	call	_lua_tointeger
	add	esp, 8
$LN6@lCreate:

; 152  : 
; 153  : 
; 154  : 	pFractal->fracInit(iNewXs, iNewYs, iGrain, rand, flags, NULL, iFracXExp, iFracYExp);

	mov	ecx, DWORD PTR _flags$[esp+32]
	mov	edx, DWORD PTR _rand$[esp+32]
	push	eax
	mov	eax, DWORD PTR _iFracXExp$[esp+36]
	push	eax
	mov	eax, DWORD PTR _iGrain$[esp+40]
	push	0
	push	ecx
	push	edx
	push	eax
	push	ebp
	push	ebx
	mov	ecx, edi
	call	?fracInit@CvFractal@@QAEXHHHAAVCvRandom@@HPAV1@HH@Z ; CvFractal::fracInit
	pop	edi
	pop	esi
	pop	ebp

; 155  : 
; 156  : 	return 1;

	mov	eax, 1
	pop	ebx

; 157  : }

	add	esp, 16					; 00000010H
	ret	0
?lCreate@CvLuaFractal@@KAHPAUlua_State@@@Z ENDP		; CvLuaFractal::lCreate
_TEXT	ENDS
PUBLIC	?lCreateRifts@CvLuaFractal@@KAHPAUlua_State@@@Z	; CvLuaFractal::lCreateRifts
EXTRN	_luaL_optinteger:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?lCreateRifts@CvLuaFractal@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_iFracXExp$ = -20					; size = 4
_pRidgeFrac$ = -16					; size = 4
_flags$ = -12						; size = 4
_rand$ = -8						; size = 4
_iGrain$ = -4						; size = 4
_L$ = 8							; size = 4
?lCreateRifts@CvLuaFractal@@KAHPAUlua_State@@@Z PROC	; CvLuaFractal::lCreateRifts, COMDAT

; 160  : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi

; 161  : 	CvFractal* pFractal = CreateFractal(L);

	mov	esi, DWORD PTR _L$[esp+28]
	push	edi
	push	esi
	call	?CreateFractal@CvLuaFractal@@KAPAVCvFractal@@PAUlua_State@@@Z ; CvLuaFractal::CreateFractal

; 162  : 
; 163  : 	const int iNewXs = lua_tointeger(L, 1);

	push	1
	push	esi
	mov	edi, eax
	call	_lua_tointeger

; 164  : 	const int iNewYs = lua_tointeger(L, 2);

	push	2
	push	esi
	mov	ebx, eax
	call	_lua_tointeger

; 165  : 	const int iGrain = lua_tointeger(L, 3);

	push	3
	push	esi
	mov	ebp, eax
	call	_lua_tointeger

; 166  : 	CvRandom& rand = GC.getGame().getMapRand();	//Temporary!!

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _iGrain$[esp+36], eax
	call	?getMapRand@CvGame@@QAEAAVCvRandom@@XZ	; CvGame::getMapRand

; 167  : 
; 168  : 	//calculate flags
; 169  : 	const int flags = GetFractalFlags(L, 4);

	push	4
	push	esi
	mov	DWORD PTR _rand$[esp+44], eax
	call	?GetFractalFlags@@YAHPAUlua_State@@H@Z	; GetFractalFlags

; 170  : 
; 171  : 	CvFractal* pRidgeFrac = static_cast<CvFractal*>(lua_touserdata(L, 5));

	push	5
	push	esi
	mov	DWORD PTR _flags$[esp+52], eax
	call	_lua_touserdata

; 172  : 
; 173  : 	const int iFracXExp = luaL_optint(L, 6, CvFractal::DEFAULT_FRAC_X_EXP);

	push	7
	push	6
	push	esi
	mov	DWORD PTR _pRidgeFrac$[esp+64], eax
	call	_luaL_optinteger

; 174  : 	const int iFracYExp = luaL_optint(L, 7, CvFractal::DEFAULT_FRAC_Y_EXP);

	push	6
	push	7
	push	esi
	mov	DWORD PTR _iFracXExp$[esp+76], eax
	call	_luaL_optinteger

; 175  : 
; 176  : 	pFractal->fracInit(iNewXs, iNewYs, iGrain, rand, flags, pRidgeFrac, iFracXExp, iFracYExp);

	mov	ecx, DWORD PTR _pRidgeFrac$[esp+76]
	mov	edx, DWORD PTR _flags$[esp+76]
	add	esp, 40					; 00000028H
	push	eax
	mov	eax, DWORD PTR _iFracXExp$[esp+40]
	push	eax
	mov	eax, DWORD PTR _rand$[esp+44]
	push	ecx
	mov	ecx, DWORD PTR _iGrain$[esp+48]
	push	edx
	push	eax
	push	ecx
	push	ebp
	push	ebx
	mov	ecx, edi
	call	?fracInit@CvFractal@@QAEXHHHAAVCvRandom@@HPAV1@HH@Z ; CvFractal::fracInit
	pop	edi
	pop	esi
	pop	ebp

; 177  : 	return 1;

	mov	eax, 1
	pop	ebx

; 178  : }

	add	esp, 20					; 00000014H
	ret	0
?lCreateRifts@CvLuaFractal@@KAHPAUlua_State@@@Z ENDP	; CvLuaFractal::lCreateRifts
_TEXT	ENDS
PUBLIC	?pRegister@CvLuaFractal@@KAHPAUlua_State@@@Z	; CvLuaFractal::pRegister
; Function compile flags: /Ogtpy
;	COMDAT ?pRegister@CvLuaFractal@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?pRegister@CvLuaFractal@@KAHPAUlua_State@@@Z PROC	; CvLuaFractal::pRegister, COMDAT

; 73   : {

	push	esi

; 74   : 	lua_getglobal(L, "Fractal");

	mov	esi, DWORD PTR _L$[esp]
	push	OFFSET $SG217246
	push	-10002					; ffffd8eeH
	push	esi
	call	_lua_getfield

; 75   : 	if(lua_isnil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN1@pRegister

; 76   : 	{
; 77   : 		lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 78   : 		lua_createtable(L, 0, 3);

	push	3
	push	0
	push	esi
	call	_lua_createtable

; 79   : 		lua_pushvalue(L, -1);

	push	-1
	push	esi
	call	_lua_pushvalue

; 80   : 		lua_setglobal(L, "Fractal");

	push	OFFSET $SG217248
	push	-10002					; ffffd8eeH
	push	esi
	call	_lua_setfield
	add	esp, 40					; 00000028H
$LN1@pRegister:

; 81   : 	}
; 82   : 
; 83   : 	lua_pushcclosure(L, lCreate, 0);

	push	0
	push	OFFSET ?lCreate@CvLuaFractal@@KAHPAUlua_State@@@Z ; CvLuaFractal::lCreate
	push	esi
	call	_lua_pushcclosure

; 84   : 	lua_setfield(L, -2, "Create");

	push	OFFSET $SG217249
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 85   : 
; 86   : 	lua_pushcclosure(L, lCreateRifts, 0);

	push	0
	push	OFFSET ?lCreateRifts@CvLuaFractal@@KAHPAUlua_State@@@Z ; CvLuaFractal::lCreateRifts
	push	esi
	call	_lua_pushcclosure

; 87   : 	lua_setfield(L, -2, "CreateRifts");

	push	OFFSET $SG217250
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield
	add	esp, 48					; 00000030H

; 88   : 
; 89   : 	return 0;

	xor	eax, eax
	pop	esi

; 90   : }

	ret	0
?pRegister@CvLuaFractal@@KAHPAUlua_State@@@Z ENDP	; CvLuaFractal::pRegister
_TEXT	ENDS
PUBLIC	?Register@CvLuaFractal@@SAXPAUlua_State@@@Z	; CvLuaFractal::Register
EXTRN	?CCallWithErrorHandling@Details@FLua@@YA_NPAUlua_State@@P6AH0@ZPAX@Z:PROC ; FLua::Details::CCallWithErrorHandling
; Function compile flags: /Ogtpy
;	COMDAT ?Register@CvLuaFractal@@SAXPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?Register@CvLuaFractal@@SAXPAUlua_State@@@Z PROC	; CvLuaFractal::Register, COMDAT

; 69   : 	FLua::Details::CCallWithErrorHandling(L, pRegister);

	mov	eax, DWORD PTR _L$[esp-4]
	push	0
	push	OFFSET ?pRegister@CvLuaFractal@@KAHPAUlua_State@@@Z ; CvLuaFractal::pRegister
	push	eax
	call	?CCallWithErrorHandling@Details@FLua@@YA_NPAUlua_State@@P6AH0@ZPAX@Z ; FLua::Details::CCallWithErrorHandling
	add	esp, 12					; 0000000cH

; 70   : }

	ret	0
?Register@CvLuaFractal@@SAXPAUlua_State@@@Z ENDP	; CvLuaFractal::Register
_TEXT	ENDS
END
