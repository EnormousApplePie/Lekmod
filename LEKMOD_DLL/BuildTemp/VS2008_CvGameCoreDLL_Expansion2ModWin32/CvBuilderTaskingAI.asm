; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvBuilderTaskingAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG218239 DB	'// Empire Unhappy! //', 00H
	ORG $+2
$SG218246 DB	'// ', 00H
$SG218249 DB	' \\', 00H
$SG218261 DB	'food       ', 00H
$SG218263 DB	'production ', 00H
$SG218265 DB	'science    ', 00H
$SG218267 DB	'gold       ', 00H
$SG218269 DB	'culture    ', 00H
$SG218271 DB	'faith      ', 00H
$SG218275 DB	'%d, %d', 00H
	ORG $+1
$SG218277 DB	' *', 00H
	ORG $+1
$SG218279 DB	'\\ end ', 00H
$SG218280 DB	' //', 00H
$SG218464 DB	'end of plot list', 00H
	ORG $+3
$SG218472 DB	'unitx: %d unity: %d, plotx: %d ploty: %d, can''t find pa'
	DB	'th', 00H
	ORG $+2
$SG218488 DB	'unitx: %d unity: %d, plotx: %d ploty: %d, Evaluating out'
	DB	' of territory plot, can''t find path', 00H
$SG218492 DB	'x: %d y: %d, Evaluating out of territory plot', 00H
	ORG $+2
$SG218571 DB	'Helps rush, %d', 00H
	ORG $+1
$SG218577 DB	'%d, Build Time Weight, %d, Weight, %d', 00H
	ORG $+6
$SG218614 DB	'Weight,!pImprovement->IsImprovementResourceTrade(eResour'
	DB	'ce),%s,%i,,,%i, %i', 00H
	ORG $+5
$SG218621 DB	'Weight,eImprovement == pPlot->getImprovementType(),%s,%i'
	DB	',,,%i, %i', 00H
	ORG $+6
$SG218629 DB	'Weight,Improvement Type Blocked by Special Improvement,%'
	DB	's,,,,%i, %i', 00H
$SG218634 DB	'Weight,!pUnit->canBuild(),%s,,,,%i, %i', 00H
	ORG $+1
$SG218645 DB	'Weight,Marsh Remove,%s,,,,%i, %i', 00H
	ORG $+3
$SG218651 DB	'Weight,Jungle Remove,%s,,,,%i, %i', 00H
	ORG $+2
$SG218659 DB	'Weight,Keep Forests,%s,,,,%i, %i', 00H
	ORG $+3
$SG218665 DB	'Weight,Negative Score,%s,%i,,,%i, %i', 00H
	ORG $+3
$SG218679 DB	'Weight,Directive Score Added,%s,,,,%i, %i, %i, %d', 00H
	ORG $+2
$SG218718 DB	'AddRouteDirectives, adding, x: %d y: %d, Weight, %d', 00H
$SG218777 DB	'FLAVOR_GROWTH', 00H
	ORG $+2
$SG218782 DB	'FLAVOR_PRODUCTION', 00H
	ORG $+2
$SG218787 DB	'FLAVOR_GOLD', 00H
$SG218792 DB	'FLAVOR_SCIENCE', 00H
	ORG $+1
$SG218797 DB	'FLAVOR_CULTURE', 00H
	ORG $+1
$SG218810 DB	'BuildTimeWeight, %d, Weight, %d', 00H
$SG218815 DB	'Add chop directives, Weight is zero!', 00H
	ORG $+3
$SG218865 DB	'x: %d y: %d,,Impassable tile. Toss out', 00H
	ORG $+1
$SG218887 DB	'unitx: %d unity: %d, plotx: %d ploty: %d, plot area: %d,'
	DB	' unit area: %d,,Plot areas don''t match and can''t embark', 00H
$SG218889 DB	',This is weird', 00H
	ORG $+1
$SG218891 DB	',This is normal', 00H
$SG218897 DB	'x: %d y: %d,,Somebody has a mission here, ', 00H
	ORG $+1
$SG218903 DB	'plotX: %d plotY: %d, danger: %d,, bailing due to danger', 00H
$SG219140 DB	',', 00H
	ORG $+2
$SG218908 DB	'plotX: %d plotY: %d,, this tile is full with another uni'
	DB	't. bailing!', 00H
$SG219135 DB	'BuilderTaskingLog.csv', 00H
	ORG $+2
$SG219141 DB	'%d,', 00H
$SG219149 DB	'BuilderTaskingYieldLog.csv', 00H
	ORG $+1
$SG219154 DB	',', 00H
	ORG $+2
$SG219155 DB	'%d,', 00H
$SG219170 DB	'Flavor, %s, %d,', 00H
$SG219173 DB	'Flavor, %s, %d,', 00H
$SG219188 DB	'%d,', 00H
$SG219189 DB	'No directives!', 00H
	ORG $+1
$SG219201 DB	'%d,', 00H
$SG219202 DB	'Evaluating,', 00H
$SG219208 DB	'BUILD_IMPROVEMENT_ON_RESOURCE,', 00H
	ORG $+1
$SG219210 DB	'BUILD_IMPROVEMENT,', 00H
	ORG $+1
$SG219212 DB	'REPAIR,', 00H
$SG219214 DB	'BUILD_ROUTE,', 00H
	ORG $+3
$SG219216 DB	'CHOP', 00H
	ORG $+3
$SG219217 DB	',', 00H
	ORG $+2
$SG219221 DB	',', 00H
	ORG $+2
$SG219223 DB	',', 00H
	ORG $+2
$SG219225 DB	',', 00H
	ORG $+2
$SG219241 DB	',', 00H
	ORG $+2
$SG219242 DB	'%d,%d,', 00H
	ORG $+1
$SG219243 DB	'%d,', 00H
$SG219244 DB	'%d,', 00H
$SG219246 DB	', Chosen!', 00H
	ORG $+2
$SG219266 DB	'Plot Yield Update, %s, %i, %i, %i', 00H
	ORG $+2
$SG219285 DB	'Plot Projected Yield Update, %s, %i, %i, %i', 00H
CONST	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?Uninit@CvBuilderTaskingAI@@QAEXXZ		; CvBuilderTaskingAI::Uninit
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
;	COMDAT ?Uninit@CvBuilderTaskingAI@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvBuilderTaskingAI@@QAEXXZ PROC			; CvBuilderTaskingAI::Uninit, COMDAT
; _this$ = ecx

; 107  : 	m_eRepairBuild = NO_BUILD;
; 108  : 	m_pPlayer = NULL;

	xor	eax, eax
	or	edx, -1
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx], eax

; 109  : 	m_bLogging = false;

	mov	BYTE PTR [ecx+58392], al

; 110  : 	m_iNumCities = -1;

	mov	DWORD PTR [ecx+58396], edx

; 111  : 	m_pTargetPlot = NULL;

	mov	DWORD PTR [ecx+58400], eax

; 112  : #ifdef AUI_WARNING_FIXES
; 113  : 	m_eFalloutFeature = NO_FEATURE;
; 114  : 	m_eFalloutRemove = NO_BUILD;
; 115  : #ifndef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 116  : 	m_bKeepJungle = false;
; 117  : 	m_bKeepMarshes = false;
; 118  : #endif
; 119  : #endif
; 120  : }

	ret	0
?Uninit@CvBuilderTaskingAI@@QAEXXZ ENDP			; CvBuilderTaskingAI::Uninit
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?CorrectWeight@@YAHH@Z				; CorrectWeight
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
;	COMDAT ?CorrectWeight@@YAHH@Z
_TEXT	SEGMENT
_iWeight$ = 8						; size = 4
?CorrectWeight@@YAHH@Z PROC				; CorrectWeight, COMDAT

; 729  : 	if(iWeight < -1000)

	mov	eax, DWORD PTR _iWeight$[esp-4]
	cmp	eax, -1000				; fffffc18H
	jge	SHORT $LN1@CorrectWei

; 730  : 	{
; 731  : 		return MAX_INT;

	mov	eax, 2147483647				; 7fffffffH
$LN1@CorrectWei:

; 732  : 	}
; 733  : 	else
; 734  : 	{
; 735  : 		return iWeight;
; 736  : 	}
; 737  : }

	ret	0
?CorrectWeight@@YAHH@Z ENDP				; CorrectWeight
_TEXT	ENDS
PUBLIC	?GetBuildCostWeight@CvBuilderTaskingAI@@QAEHHPAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::GetBuildCostWeight
EXTRN	?getBuildCost@CvPlayer@@QBEHPBVCvPlot@@W4BuildTypes@@@Z:PROC ; CvPlayer::getBuildCost
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildCostWeight@CvBuilderTaskingAI@@QAEHHPAVCvPlot@@W4BuildTypes@@@Z
_TEXT	SEGMENT
_iWeight$ = 8						; size = 4
_pPlot$ = 12						; size = 4
_eBuild$ = 16						; size = 4
?GetBuildCostWeight@CvBuilderTaskingAI@@QAEHHPAVCvPlot@@W4BuildTypes@@@Z PROC ; CvBuilderTaskingAI::GetBuildCostWeight, COMDAT
; _this$ = ecx

; 2614 : 	int iBuildCost = m_pPlayer->getBuildCost(pPlot, eBuild);

	mov	eax, DWORD PTR _eBuild$[esp-4]
	mov	edx, DWORD PTR _pPlot$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	push	edx
	call	?getBuildCost@CvPlayer@@QBEHPBVCvPlot@@W4BuildTypes@@@Z ; CvPlayer::getBuildCost
	mov	ecx, eax

; 2615 : 	if(iBuildCost > 0)
; 2616 : 	{
; 2617 : 		iWeight = (iWeight * 100) / iBuildCost;

	mov	eax, DWORD PTR _iWeight$[esp-4]
	imul	eax, 100				; 00000064H
	test	ecx, ecx
	jle	SHORT $LN1@GetBuildCo
	cdq
	idiv	ecx
$LN1@GetBuildCo:

; 2618 : 	}
; 2619 : 	else
; 2620 : 	{
; 2621 : 		//if (m_bLogging)
; 2622 : 		//{
; 2623 : 		//	LogInfo("Build cost is zero", m_pPlayer);
; 2624 : 		//}
; 2625 : 		iWeight = (iWeight * 100);
; 2626 : 	}
; 2627 : 	return iWeight;
; 2628 : }

	ret	12					; 0000000cH
?GetBuildCostWeight@CvBuilderTaskingAI@@QAEHHPAVCvPlot@@W4BuildTypes@@@Z ENDP ; CvBuilderTaskingAI::GetBuildCostWeight
_TEXT	ENDS
PUBLIC	?GetWorkingCity@CvBuilderTaskingAI@@QAEPAVCvCity@@PAVCvPlot@@@Z ; CvBuilderTaskingAI::GetWorkingCity
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z:PROC ; CvCityCitizens::IsCanWork
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ:PROC	; CvPlot::getWorkingCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetWorkingCity@CvBuilderTaskingAI@@QAEPAVCvCity@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_iLoop$219032 = 8					; size = 4
_pPlot$ = 8						; size = 4
?GetWorkingCity@CvBuilderTaskingAI@@QAEPAVCvCity@@PAVCvPlot@@@Z PROC ; CvBuilderTaskingAI::GetWorkingCity, COMDAT
; _this$ = ecx

; 2880 : {

	push	ebx

; 2881 : #ifdef AUI_WARNING_FIXES
; 2882 : 	CvCity* pCity = pPlot->getWorkingCity();
; 2883 : 	if (!pCity)
; 2884 : #else
; 2885 : 	CvCity* pCity = NULL;
; 2886 : 	if(pPlot->getWorkingCity())

	mov	ebx, DWORD PTR _pPlot$[esp]
	push	ebp
	push	edi
	mov	edi, ecx
	mov	ecx, ebx
	xor	ebp, ebp
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	test	eax, eax
	je	SHORT $LN6@GetWorking

; 2887 : 	{
; 2888 : 		pCity = pPlot->getWorkingCity();

	mov	ecx, ebx
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	pop	edi
	pop	ebp
	pop	ebx

; 2910 : }

	ret	4
$LN6@GetWorking:

; 2889 : 	}
; 2890 : 	else
; 2891 : #endif
; 2892 : 	{
; 2893 : 		CvCity* pLoopCity;
; 2894 : 		int iLoop;
; 2895 : 		for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [edi]
	push	esi
	push	0
	lea	eax, DWORD PTR _iLoop$219032[esp+16]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN12@GetWorking
$LL4@GetWorking:

; 2896 : 		{
; 2897 : 			if(pLoopCity->GetCityCitizens()->IsCanWork(pPlot))

	push	ebx
	mov	ecx, esi
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z ; CvCityCitizens::IsCanWork
	test	al, al
	jne	SHORT $LN10@GetWorking
	push	0
	lea	ecx, DWORD PTR _iLoop$219032[esp+16]
	push	ecx
	mov	ecx, DWORD PTR [edi]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL4@GetWorking
$LN12@GetWorking:
	pop	esi
	pop	edi

; 2898 : 			{
; 2899 : #ifdef AUI_WARNING_FIXES
; 2900 : 				return pLoopCity;
; 2901 : #else
; 2902 : 				pCity = pLoopCity;
; 2903 : 				break;
; 2904 : #endif
; 2905 : 			}
; 2906 : 		}
; 2907 : 	}
; 2908 : 
; 2909 : 	return pCity;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 2910 : }

	ret	4
$LN10@GetWorking:

; 2898 : 			{
; 2899 : #ifdef AUI_WARNING_FIXES
; 2900 : 				return pLoopCity;
; 2901 : #else
; 2902 : 				pCity = pLoopCity;
; 2903 : 				break;
; 2904 : #endif
; 2905 : 			}
; 2906 : 		}
; 2907 : 	}
; 2908 : 
; 2909 : 	return pCity;

	mov	eax, esi
	pop	esi
	pop	edi
	pop	ebp
	pop	ebx

; 2910 : }

	ret	4
?GetWorkingCity@CvBuilderTaskingAI@@QAEPAVCvCity@@PAVCvPlot@@@Z ENDP ; CvBuilderTaskingAI::GetWorkingCity
_TEXT	ENDS
PUBLIC	?ScorePlot@CvBuilderTaskingAI@@QAEHXZ		; CvBuilderTaskingAI::ScorePlot
EXTRN	?IsOriginalCapital@CvCity@@QBE_NXZ:PROC		; CvCity::IsOriginalCapital
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?GetYieldDeltaTimes100@CvCityStrategyAI@@QAEFW4YieldTypes@@@Z:PROC ; CvCityStrategyAI::GetYieldDeltaTimes100
EXTRN	?GetFocusYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ:PROC ; CvCityStrategyAI::GetFocusYield
EXTRN	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ:PROC ; CvCity::GetCityStrategyAI
; Function compile flags: /Ogtpy
;	COMDAT ?ScorePlot@CvBuilderTaskingAI@@QAEHXZ
_TEXT	SEGMENT
_bAnyNegativeMultiplier$ = -21				; size = 1
_iScore$ = -20						; size = 4
_pCityStrategy$ = -16					; size = 4
_eFocusYield$ = -12					; size = 4
_this$ = -8						; size = 4
_pCity$ = -4						; size = 4
?ScorePlot@CvBuilderTaskingAI@@QAEHXZ PROC		; CvBuilderTaskingAI::ScorePlot, COMDAT
; _this$ = ecx

; 2950 : {

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	mov	ebp, ecx

; 2951 : 	if(!m_pTargetPlot)

	mov	ecx, DWORD PTR [ebp+58400]
	xor	ebx, ebx
	mov	DWORD PTR _this$[esp+32], ebp
	cmp	ecx, ebx
	jne	SHORT $LN19@ScorePlot
$LN29@ScorePlot:
	pop	ebp

; 2952 : 	{
; 2953 : 		return -1;

	or	eax, -1
	pop	ebx

; 3082 : }

	add	esp, 24					; 00000018H
	ret	0
$LN19@ScorePlot:

; 2954 : 	}
; 2955 : 
; 2956 : 	CvCity* pCity = m_pTargetPlot->getWorkingCity();

	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	mov	DWORD PTR _pCity$[esp+32], eax

; 2957 : #ifdef AUI_WORKER_SCORE_PLOT_NO_SCORE_FROM_RAZE
; 2958 : 	if (!pCity || pCity->IsRazing())
; 2959 : #else
; 2960 : 	if(!pCity)

	cmp	eax, ebx

; 2961 : #endif
; 2962 : 	{
; 2963 : 		return -1;

	je	SHORT $LN29@ScorePlot
	push	esi

; 2964 : 	}
; 2965 : 
; 2966 : 	CvCityStrategyAI* pCityStrategy = pCity->GetCityStrategyAI();

	mov	ecx, eax
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	esi, eax
	mov	DWORD PTR _pCityStrategy$[esp+36], esi

; 2967 : 	if(!pCityStrategy)

	cmp	esi, ebx
	jne	SHORT $LN17@ScorePlot
	pop	esi
	pop	ebp

; 2968 : 	{
; 2969 : 		return -1;

	or	eax, -1
	pop	ebx

; 3082 : }

	add	esp, 24					; 00000018H
	ret	0
$LN17@ScorePlot:
	push	edi

; 2985 : 	bool bAnyNegativeMultiplier = false;
; 2986 : 	YieldTypes eFocusYield = pCityStrategy->GetFocusYield();

	mov	ecx, esi
	mov	DWORD PTR _iScore$[esp+40], ebx
	mov	BYTE PTR _bAnyNegativeMultiplier$[esp+40], bl
	call	?GetFocusYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ ; CvCityStrategyAI::GetFocusYield
	mov	DWORD PTR _eFocusYield$[esp+40], eax
	add	ebp, 58428				; 0000e43cH
	jmp	SHORT $LN16@ScorePlot
$LL25@ScorePlot:

; 2970 : 	}
; 2971 : 
; 2972 : #ifdef AUI_WORKER_SCORE_PLOT_CHOP
; 2973 : 	CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);
; 2974 : 	if (!pkBuild)
; 2975 : 	{
; 2976 : 		return -1;
; 2977 : 	}
; 2978 : 	FeatureTypes ePlotFeature = m_pTargetPlot->getFeatureType();
; 2979 : #endif
; 2980 : 
; 2981 : #ifdef AUI_WORKER_SCORE_PLOT_MULTIPLY_SCORE_IF_WOULD_WORK
; 2982 : 	bool bWouldBeWorked = m_pTargetPlot->isBeingWorked();
; 2983 : #endif
; 2984 : 	int iScore = 0;

	mov	esi, DWORD PTR _pCityStrategy$[esp+40]
$LN16@ScorePlot:

; 2987 : 	for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)
; 2988 : 	{
; 2989 : 		int iMultiplier = pCityStrategy->GetYieldDeltaTimes100((YieldTypes)ui);

	push	ebx
	mov	ecx, esi
	call	?GetYieldDeltaTimes100@CvCityStrategyAI@@QAEFW4YieldTypes@@@Z ; CvCityStrategyAI::GetYieldDeltaTimes100

; 2990 : 		int iAbsMultiplier = abs(iMultiplier);
; 2991 : 		int iYieldDelta = m_aiProjectedPlotYields[ui] - m_aiCurrentPlotYields[ui];

	mov	edi, DWORD PTR [ebp]
	movsx	esi, ax
	mov	eax, esi
	cdq
	xor	eax, edx
	mov	ecx, edi
	sub	ecx, DWORD PTR [ebp-24]
	sub	eax, edx

; 2992 : #ifdef AUI_WORKER_SCORE_PLOT_CHOP
; 2993 : 		double dFlatBonus = 0;
; 2994 : 		if (ePlotFeature != NO_FEATURE && pkBuild->isFeatureRemove(ePlotFeature) && ui == YIELD_PRODUCTION && iYieldDelta >= 0)
; 2995 : 		{
; 2996 : 			dFlatBonus = AUI_WORKER_SCORE_PLOT_CHOP;
; 2997 : 		}
; 2998 : #endif
; 2999 : 
; 3000 : 		// the multiplier being lower than zero means that we need more of this resource
; 3001 : 		if(iMultiplier < 0)

	test	esi, esi
	jge	SHORT $LN13@ScorePlot

; 3002 : 		{
; 3003 : 			bAnyNegativeMultiplier = true;

	mov	BYTE PTR _bAnyNegativeMultiplier$[esp+40], 1

; 3004 : 			if(iYieldDelta > 0)  // this would be an improvement to the yield

	test	ecx, ecx
	jle	SHORT $LN28@ScorePlot

; 3005 : 			{
; 3006 : #ifdef AUI_WORKER_SCORE_PLOT_CHOP
; 3007 : 				iScore += int((m_aiProjectedPlotYields[ui] + dFlatBonus) * iAbsMultiplier + 0.5);
; 3008 : 			}
; 3009 : 			else if (iYieldDelta < 0)  // the yield would go down
; 3010 : 			{
; 3011 : 				iScore += int((iYieldDelta + dFlatBonus) * iAbsMultiplier - 0.5);
; 3012 : 			}
; 3013 : 		}
; 3014 : 		else
; 3015 : 		{
; 3016 : 			if (iYieldDelta >= 0)
; 3017 : 			{
; 3018 : 				iScore += int(m_aiProjectedPlotYields[ui] + dFlatBonus + 0.5); // provide a nominal score to plots that improve anything
; 3019 : 			}
; 3020 : 			else if (iYieldDelta < 0)
; 3021 : 			{
; 3022 : 				iScore += int((iYieldDelta + dFlatBonus) * iAbsMultiplier - 0.5);
; 3023 : #else
; 3024 : 				iScore += m_aiProjectedPlotYields[ui] * iAbsMultiplier;

	imul	edi, eax
	add	DWORD PTR _iScore$[esp+40], edi
	jmp	SHORT $LN15@ScorePlot
$LN28@ScorePlot:

; 3025 : 			}
; 3026 : 			else if(iYieldDelta < 0)  // the yield would go down

	jge	SHORT $LN15@ScorePlot
$LN24@ScorePlot:

; 3036 : 			}
; 3037 : 			else if(iYieldDelta < 0)
; 3038 : 			{
; 3039 : 				iScore += iYieldDelta * iAbsMultiplier;

	imul	ecx, eax
	add	DWORD PTR _iScore$[esp+40], ecx
$LN15@ScorePlot:
	inc	ebx
	add	ebp, 4
	cmp	ebx, 6
	jb	SHORT $LL25@ScorePlot

; 3040 : #endif
; 3041 : 			}
; 3042 : 		}
; 3043 : 	}
; 3044 : 
; 3045 : 	if(!bAnyNegativeMultiplier && eFocusYield != NO_YIELD)

	cmp	BYTE PTR _bAnyNegativeMultiplier$[esp+40], 0
	pop	edi
	jne	SHORT $LN26@ScorePlot
	mov	ecx, DWORD PTR _eFocusYield$[esp+36]
	cmp	ecx, -1
	je	SHORT $LN26@ScorePlot

; 3046 : 	{
; 3047 : 		int iYieldDelta = m_aiProjectedPlotYields[eFocusYield] - m_aiCurrentPlotYields[eFocusYield];

	mov	edx, DWORD PTR _this$[esp+36]
	mov	eax, DWORD PTR [edx+ecx*4+58428]
	mov	esi, eax
	sub	esi, DWORD PTR [edx+ecx*4+58404]

; 3048 : 		if(iYieldDelta > 0)

	test	esi, esi
	jle	SHORT $LN26@ScorePlot

; 3049 : 		{
; 3050 : #ifdef AUI_WORKER_SCORE_PLOT_EFFECT_FROM_CITY_FOCUS
; 3051 : 			iScore += m_aiProjectedPlotYields[eFocusYield] * AUI_WORKER_SCORE_PLOT_EFFECT_FROM_CITY_FOCUS;
; 3052 : #else
; 3053 : 			iScore += m_aiProjectedPlotYields[eFocusYield] * 100;

	imul	eax, 100				; 00000064H
	add	DWORD PTR _iScore$[esp+36], eax
$LN26@ScorePlot:

; 3054 : #endif
; 3055 : 		}
; 3056 : 	}
; 3057 : 
; 3058 : #ifndef AUI_WORKER_SCORE_PLOT_NO_CAPITOL_FAVORING
; 3059 : 	if (pCity->isCapital()) // this is our capital and needs emphasis

	mov	esi, DWORD PTR _pCity$[esp+36]
	mov	ecx, esi
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	je	SHORT $LN3@ScorePlot

; 3060 : 	{
; 3061 : 		iScore *= 8;

	mov	eax, DWORD PTR _iScore$[esp+36]
	pop	esi
	lea	ecx, DWORD PTR [eax*8]
	pop	ebp
	mov	DWORD PTR _iScore$[esp+28], ecx

; 3066 : 	}
; 3067 : #endif
; 3068 : #ifdef AUI_WORKER_SCORE_PLOT_MULTIPLY_SCORE_IF_WOULD_WORK
; 3069 : 	if (bWouldBeWorked)
; 3070 : 	{
; 3071 : 		iScore *= AUI_WORKER_SCORE_PLOT_MULTIPLY_SCORE_IF_WOULD_WORK;
; 3072 : 	}
; 3073 : #endif
; 3074 : #ifdef AUI_WORKER_SCORE_PLOT_REDUCED_PUPPET_SCORE
; 3075 : 	if (pCity->IsPuppet())
; 3076 : 	{
; 3077 : 		iScore /= AUI_WORKER_SCORE_PLOT_REDUCED_PUPPET_SCORE;
; 3078 : 	}
; 3079 : #endif
; 3080 : 
; 3081 : 	return iScore;

	mov	eax, ecx
	pop	ebx

; 3082 : }

	add	esp, 24					; 00000018H
	ret	0
$LN13@ScorePlot:

; 3027 : 			{
; 3028 : 				iScore += iYieldDelta * iAbsMultiplier;
; 3029 : 			}
; 3030 : 		}
; 3031 : 		else
; 3032 : 		{
; 3033 : 			if(iYieldDelta >= 0)

	test	ecx, ecx
	jl	SHORT $LN24@ScorePlot

; 3034 : 			{
; 3035 : 				iScore += m_aiProjectedPlotYields[ui]; // provide a nominal score to plots that improve anything

	add	DWORD PTR _iScore$[esp+40], edi
	jmp	SHORT $LN15@ScorePlot
$LN3@ScorePlot:

; 3062 : 	}
; 3063 : 	else if (pCity->IsOriginalCapital()) // this was a particularly good city and needs a little emphasis

	mov	ecx, esi
	call	?IsOriginalCapital@CvCity@@QBE_NXZ	; CvCity::IsOriginalCapital
	test	al, al
	je	SHORT $LN1@ScorePlot

; 3064 : 	{
; 3065 : 		iScore *= 2;

	mov	edx, DWORD PTR _iScore$[esp+36]
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR _iScore$[esp+36], eax
$LN1@ScorePlot:

; 3066 : 	}
; 3067 : #endif
; 3068 : #ifdef AUI_WORKER_SCORE_PLOT_MULTIPLY_SCORE_IF_WOULD_WORK
; 3069 : 	if (bWouldBeWorked)
; 3070 : 	{
; 3071 : 		iScore *= AUI_WORKER_SCORE_PLOT_MULTIPLY_SCORE_IF_WOULD_WORK;
; 3072 : 	}
; 3073 : #endif
; 3074 : #ifdef AUI_WORKER_SCORE_PLOT_REDUCED_PUPPET_SCORE
; 3075 : 	if (pCity->IsPuppet())
; 3076 : 	{
; 3077 : 		iScore /= AUI_WORKER_SCORE_PLOT_REDUCED_PUPPET_SCORE;
; 3078 : 	}
; 3079 : #endif
; 3080 : 
; 3081 : 	return iScore;

	mov	eax, DWORD PTR _iScore$[esp+36]
	pop	esi
	pop	ebp
	pop	ebx

; 3082 : }

	add	esp, 24					; 00000018H
	ret	0
?ScorePlot@CvBuilderTaskingAI@@QAEHXZ ENDP		; CvBuilderTaskingAI::ScorePlot
_TEXT	ENDS
PUBLIC	?GetBuildTypeFromImprovement@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@W4ImprovementTypes@@@Z ; CvBuilderTaskingAI::GetBuildTypeFromImprovement
EXTRN	?getImprovement@CvBuildInfo@@QBEHXZ:PROC	; CvBuildInfo::getImprovement
EXTRN	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z:PROC ; CvGlobals::getBuildInfo
EXTRN	?getNumBuildInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildInfos
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildTypeFromImprovement@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@W4ImprovementTypes@@@Z
_TEXT	SEGMENT
_eImprovement$ = 8					; size = 4
?GetBuildTypeFromImprovement@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@W4ImprovementTypes@@@Z PROC ; CvBuilderTaskingAI::GetBuildTypeFromImprovement, COMDAT
; _this$ = ecx

; 3089 : {

	push	esi
	push	edi

; 3090 : #ifdef AUI_WARNING_FIXES
; 3091 : 	for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 3092 : #else
; 3093 : 	for(int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	SHORT $LN2@GetBuildTy
	mov	edi, DWORD PTR _eImprovement$[esp+4]
	npad	10
$LL4@GetBuildTy:

; 3094 : #endif
; 3095 : 	{
; 3096 : 		BuildTypes eBuild = (BuildTypes)iBuildIndex;
; 3097 : 		CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 3098 : 
; 3099 : 		if(NULL != pkBuild && eImprovement == (ImprovementTypes)pkBuild->getImprovement())

	test	eax, eax
	je	SHORT $LN3@GetBuildTy
	mov	ecx, eax
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	cmp	edi, eax
	je	SHORT $LN8@GetBuildTy
$LN3@GetBuildTy:

; 3090 : #ifdef AUI_WARNING_FIXES
; 3091 : 	for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 3092 : #else
; 3093 : 	for(int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	esi, eax
	jl	SHORT $LL4@GetBuildTy
$LN2@GetBuildTy:
	pop	edi

; 3102 : 		}
; 3103 : 	}
; 3104 : 
; 3105 : 	return NO_BUILD;

	or	eax, -1
	pop	esi

; 3106 : }

	ret	4
$LN8@GetBuildTy:
	pop	edi

; 3100 : 		{
; 3101 : 			return eBuild;

	mov	eax, esi
	pop	esi

; 3106 : }

	ret	4
?GetBuildTypeFromImprovement@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@W4ImprovementTypes@@@Z ENDP ; CvBuilderTaskingAI::GetBuildTypeFromImprovement
_TEXT	ENDS
PUBLIC	?GetRepairBuild@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@XZ ; CvBuilderTaskingAI::GetRepairBuild
EXTRN	?isRepair@CvBuildInfo@@QBE_NXZ:PROC		; CvBuildInfo::isRepair
; Function compile flags: /Ogtpy
;	COMDAT ?GetRepairBuild@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@XZ
_TEXT	SEGMENT
?GetRepairBuild@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@XZ PROC ; CvBuilderTaskingAI::GetRepairBuild, COMDAT
; _this$ = ecx

; 3113 : {

	push	esi

; 3114 : #ifdef AUI_WARNING_FIXES
; 3115 : 	for (uint i = 0; i < GC.getNumBuildInfos(); i++)
; 3116 : #else
; 3117 : 	for(int i = 0; i < GC.getNumBuildInfos(); i++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	SHORT $LN2@GetRepairB
$LL4@GetRepairB:

; 3118 : #endif
; 3119 : 	{
; 3120 : 		BuildTypes eBuild = (BuildTypes)i;
; 3121 : 		CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 3122 : 
; 3123 : 		if(NULL != pkBuild && pkBuild->isRepair())

	test	eax, eax
	je	SHORT $LN3@GetRepairB
	mov	ecx, eax
	call	?isRepair@CvBuildInfo@@QBE_NXZ		; CvBuildInfo::isRepair
	test	al, al
	jne	SHORT $LN8@GetRepairB
$LN3@GetRepairB:

; 3114 : #ifdef AUI_WARNING_FIXES
; 3115 : 	for (uint i = 0; i < GC.getNumBuildInfos(); i++)
; 3116 : #else
; 3117 : 	for(int i = 0; i < GC.getNumBuildInfos(); i++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	esi, eax
	jl	SHORT $LL4@GetRepairB
$LN2@GetRepairB:

; 3126 : 		}
; 3127 : 	}
; 3128 : 
; 3129 : 	return NO_BUILD;

	or	eax, -1
	pop	esi

; 3130 : }

	ret	0
$LN8@GetRepairB:

; 3124 : 		{
; 3125 : 			return eBuild;

	mov	eax, esi
	pop	esi

; 3130 : }

	ret	0
?GetRepairBuild@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@XZ ENDP ; CvBuilderTaskingAI::GetRepairBuild
_TEXT	ENDS
PUBLIC	??A?$BaseVector@H$00@@QAEAAHI@Z			; BaseVector<int,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@H$00@@QAEAAHI@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@H$00@@QAEAAHI@Z PROC			; BaseVector<int,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@H$00@@QAEAAHI@Z ENDP			; BaseVector<int,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@H$00@@QBEIXZ			; BaseVector<int,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@H$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@H$00@@QBEIXZ PROC			; BaseVector<int,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@H$00@@QBEIXZ ENDP			; BaseVector<int,1>::size
_TEXT	ENDS
PUBLIC	??1?$BaseVector@H$00@@QAE@XZ			; BaseVector<int,1>::~BaseVector<int,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@H$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@H$00@@QAE@XZ PROC			; BaseVector<int,1>::~BaseVector<int,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@H$00@@QAE@XZ ENDP			; BaseVector<int,1>::~BaseVector<int,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@H$00@@IAE@XZ			; BaseVector<int,1>::BaseVector<int,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@H$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@H$00@@IAE@XZ PROC			; BaseVector<int,1>::BaseVector<int,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@H$00@@IAE@XZ ENDP			; BaseVector<int,1>::BaseVector<int,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@H$00@@IAEXPAHI@Z		; BaseVector<int,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@H$00@@IAEXPAHI@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@H$00@@IAEXPAHI@Z PROC		; BaseVector<int,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@H$00@@IAEXPAHI@Z ENDP		; BaseVector<int,1>::Destroy
_TEXT	ENDS
PUBLIC	?Copy@?$BaseVector@H$00@@IAEXABV1@@Z		; BaseVector<int,1>::Copy
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Copy@?$BaseVector@H$00@@IAEXABV1@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@H$00@@IAEXABV1@@Z PROC		; BaseVector<int,1>::Copy, COMDAT
; _this$ = ecx

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	eax, DWORD PTR _RHS$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 231  : 		if( bPODType ){
; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);

	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	add	edx, edx
	add	edx, edx
	push	edx
	push	eax
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 233  : 		}else{
; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){
; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );
; 236  : 			}
; 237  : 		}
; 238  : 	};

	ret	4
?Copy@?$BaseVector@H$00@@IAEXABV1@@Z ENDP		; BaseVector<int,1>::Copy
_TEXT	ENDS
PUBLIC	?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget, COMDAT
; _this$ = ecx

; 52   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 53   : 		m_targets.insert(&target);
; 54   : #endif
; 55   : 	}

	ret	4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
_TEXT	ENDS
PUBLIC	?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
; Function compile flags: /Ogtpy
;	COMDAT ?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget, COMDAT
; _this$ = ecx

; 63   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 64   : 		m_targets.erase(&target);
; 65   : #endif
; 66   : 	}

	ret	4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
_TEXT	ENDS
PUBLIC	??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@IAEPAHI@Z ; FStaticVector<int,14592,1,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ DB 'c:\users\eno'
	DB	'rmousapplepie\documents\github\lekmod\lekmod_dll\fireplace\in'
	DB	'clude\fireworks\FFastVector.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@IAEPAHI@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@IAEPAHI@Z PROC ; FStaticVector<int,14592,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 14592				; 00003900H
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 14592		; 00003900H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@IAEPAHI@Z ENDP ; FStaticVector<int,14592,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@IAEXPAHI@Z ; FStaticVector<int,14592,1,297,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@IAEXPAHI@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@IAEXPAHI@Z PROC ; FStaticVector<int,14592,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@IAEXPAHI@Z ENDP ; FStaticVector<int,14592,1,297,0>::Free
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@I@Z ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@I@Z PROC ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*8]

; 137  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QBEIXZ ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QBEIXZ PROC ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QBEIXZ ENDP ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@XZ ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@XZ PROC ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@XZ ENDP ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@XZ ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@XZ PROC ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@XZ ENDP ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::end
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEPAHI@Z ; FStaticVector<int,64,1,297,0>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEPAHI@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEPAHI@Z PROC ; FStaticVector<int,64,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 64					; 00000040H
	jbe	SHORT $LN2@Alloc@2

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@2:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 64			; 00000040H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEPAHI@Z ENDP ; FStaticVector<int,64,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXPAHI@Z ; FStaticVector<int,64,1,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXPAHI@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXPAHI@Z PROC ; FStaticVector<int,64,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@2

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@2:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXPAHI@Z ENDP ; FStaticVector<int,64,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@I@Z ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 100				; 00000064H
	jbe	SHORT $LN2@Alloc@3

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	lea	eax, DWORD PTR [edi+edi*2]
	add	eax, eax
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@3:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 100			; 00000064H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@IAE@XZ ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@IAE@XZ PROC ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@IAE@XZ ENDP ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@I@Z ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@I@Z PROC ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::Destroy
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@ABU01@@Z ; CvWeightedVector<BuilderDirective,100,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@ABU01@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0WeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@ABU01@@Z PROC ; CvWeightedVector<BuilderDirective,100,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 37   : 		{

	mov	eax, ecx
	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ecx

; 38   : 		}

	ret	4
??0WeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@ABU01@@Z ENDP ; CvWeightedVector<BuilderDirective,100,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ; std::_Dist_type<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z PROC ; std::_Dist_type<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ENDP ; std::_Dist_type<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@Z ; std::_Val_type<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@Z PROC ; std::_Val_type<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@Z ENDP ; std::_Val_type<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@H@Z ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@H@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@H@Z PROC ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT
; _this$ = ecx

; 526  : 	_Temp_iterator(_PDFT _Count = 0)

	mov	eax, ecx

; 527  : 		{	// construct from desired temporary buffer size
; 528  : 		_Buf._Begin = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 529  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 530  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 531  : 		_Buf._Size = _Count;	// memorize size for lazy allocation

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	DWORD PTR [eax+12], ecx

; 532  : 		_Pbuf = &_Buf;

	mov	DWORD PTR [eax+16], eax

; 533  : 		}

	ret	4
??0?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@H@Z ENDP ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Destroy@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ; std::_Destroy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z PROC ; std::_Destroy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ENDP ; std::_Destroy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$return_temporary_buffer@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ; std::return_temporary_buffer<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$return_temporary_buffer@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z
_TEXT	SEGMENT
__Pbuf$ = 8						; size = 4
??$return_temporary_buffer@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z PROC ; std::return_temporary_buffer<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 39   : 	operator delete(_Pbuf);

	jmp	??3@YAXPAX@Z				; operator delete
??$return_temporary_buffer@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ENDP ; std::return_temporary_buffer<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ; std::_Iter_cat<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z PROC ; std::_Iter_cat<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ENDP ; std::_Iter_cat<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Distance2@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Distance2@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>, COMDAT

; 1867 : 
; 1868 :  #if _HAS_ITERATOR_DEBUGGING
; 1869 : 	if (_First != _Last)
; 1870 : 		{	// check for null pointers
; 1871 : 		_DEBUG_POINTER(_First);
; 1872 : 		_DEBUG_POINTER(_Last);
; 1873 : 		}
; 1874 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1875 : 
; 1876 : 	_Off += _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	DWORD PTR [eax], ecx

; 1877 : 	}

	ret	0
??$_Distance2@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??MWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QBE_NABU01@@Z ; CvWeightedVector<BuilderDirective,100,1>::WeightedElement::operator<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??MWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QBE_NABU01@@Z
_TEXT	SEGMENT
_b2$ = 8						; size = 4
??MWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QBE_NABU01@@Z PROC ; CvWeightedVector<BuilderDirective,100,1>::WeightedElement::operator<, COMDAT
; _this$ = ecx

; 45   : 			// Reverse of the normal direction because we want highest weight first in our list
; 46   : 			return m_iWeight > b2.m_iWeight;

	mov	eax, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _b2$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+20]
	setg	cl
	mov	al, cl

; 47   : 		};

	ret	4
??MWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QBE_NABU01@@Z ENDP ; CvWeightedVector<BuilderDirective,100,1>::WeightedElement::operator<
_TEXT	ENDS
PUBLIC	?_Init@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV12@XZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Init
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Init@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?_Init@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV12@XZ PROC ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Init, COMDAT
; _this$ = ecx

; 591  : 		{	// set pointer at beginning of buffer

	mov	eax, ecx

; 592  : 		_Pbuf->_Current = _Pbuf->_Begin;

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], edx

; 593  : 		return (*this);
; 594  : 		}

	ret	0
?_Init@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV12@XZ ENDP ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Init
_TEXT	ENDS
PUBLIC	?_First@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QBEPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@XZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_First
; Function compile flags: /Ogtpy
;	COMDAT ?_First@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QBEPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@XZ
_TEXT	SEGMENT
?_First@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QBEPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@XZ PROC ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_First, COMDAT
; _this$ = ecx

; 598  : 		return (_Pbuf->_Begin);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]

; 599  : 		}

	ret	0
?_First@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QBEPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@XZ ENDP ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_First
_TEXT	ENDS
PUBLIC	?_Last@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QBEPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@XZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Last
; Function compile flags: /Ogtpy
;	COMDAT ?_Last@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QBEPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@XZ
_TEXT	SEGMENT
?_Last@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QBEPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@XZ PROC ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Last, COMDAT
; _this$ = ecx

; 603  : 		return (_Pbuf->_Current);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]

; 604  : 		}

	ret	0
?_Last@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QBEPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@XZ ENDP ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Last
_TEXT	ENDS
PUBLIC	??0?$pair@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@ABH@Z ; std::pair<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>::pair<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@ABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@ABH@Z PROC ; std::pair<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>::pair<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@ABH@Z ENDP ; std::pair<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>::pair<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@ABV01@@Z ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator=, COMDAT
; _this$ = ecx

; 556  : 		{	// assign _Right (share active buffer)

	mov	eax, ecx

; 557  : 		_Pbuf = _Right._Pbuf;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 558  : 		return (*this);
; 559  : 		}

	ret	4
??4?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator=
_TEXT	ENDS
PUBLIC	??$_Advance@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@std@@YAXAAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Advance@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@std@@YAXAAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@std@@YAXAAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@std@@YAXAAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$swap@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z ; std::swap<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z
_TEXT	SEGMENT
__Tmp$220404 = -24					; size = 24
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z PROC ; std::swap<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	esp, 24					; 00000018H
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	ebx, DWORD PTR [eax+12]
	push	ebp
	mov	ebp, DWORD PTR [eax+16]
	mov	DWORD PTR __Tmp$220404[esp+48], ebp
	mov	ebp, DWORD PTR [eax+20]
	mov	DWORD PTR __Tmp$220404[esp+52], ebp

; 21   : 
; 22   : 		_Left = _Right;

	mov	ebp, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebp
	mov	ebp, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ebp
	mov	ebp, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ebp

; 23   : 		_Right = _Tmp;

	mov	eax, DWORD PTR __Tmp$220404[esp+56]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR __Tmp$220404[esp+60]
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+12], ebx
	pop	ebp
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+20], edx
	pop	ebx
$LN1@swap:

; 24   : 		}
; 25   : 	}

	add	esp, 24					; 00000018H
	ret	0
??$swap@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z ENDP ; std::swap<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@ABV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Iter_random<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@ABV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@ABV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z PROC ; std::_Iter_random<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@ABV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ENDP ; std::_Iter_random<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@AAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Ptr_cat<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@AAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@AAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z PROC ; std::_Ptr_cat<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@AAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ENDP ; std::_Ptr_cat<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z ; std::_Iter_random<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z PROC ; std::_Iter_random<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z ENDP ; std::_Iter_random<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??D?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??D?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator*, COMDAT
; _this$ = ecx

; 576  : 		{	// pretend to return designated value

	mov	eax, ecx

; 577  : 		return (*this);
; 578  : 		}

	ret	0
??D?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator*
_TEXT	ENDS
PUBLIC	??E?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator++, COMDAT
; _this$ = ecx

; 581  : 		{	// pretend to preincrement

	mov	eax, ecx

; 582  : 		return (*this);
; 583  : 		}

	ret	0
??E?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator++
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z ; std::_Iter_random<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z PROC ; std::_Iter_random<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z ENDP ; std::_Iter_random<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z ; std::_Ptr_cat<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z PROC ; std::_Ptr_cat<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z ENDP ; std::_Ptr_cat<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-24]
	sub	ecx, 24					; 00000018H
	mov	DWORD PTR [eax-24], esi
	mov	esi, DWORD PTR [ecx+4]
	sub	eax, 24					; 00000018H
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt
	push	esi
$LL3@Copy_opt:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], esi
	add	ecx, 24					; 00000018H
	add	eax, 24					; 00000018H
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt
	pop	esi
$LN1@Copy_opt:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@ABU12@@Z ; std::_Construct<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@ABU12@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@ABU12@@Z PROC ; std::_Construct<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ecx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@ABU12@@Z ENDP ; std::_Construct<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0ABV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Iter_random<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0ABV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0ABV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z PROC ; std::_Iter_random<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0ABV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ENDP ; std::_Iter_random<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
_TEXT	ENDS
PUBLIC	??$_Rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00PAH0@Z ; std::_Rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00PAH0@Z
_TEXT	SEGMENT
tv289 = -28						; size = 4
__Holeval$220644 = -24					; size = 24
__First$ = 8						; size = 4
tv175 = 12						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00PAH0@Z PROC ; std::_Rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	ecx, DWORD PTR __Mid$[esp-4]
	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+40]
	sub	ecx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx

; 1683 : 	_Diff _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp+40]
	sar	edx, 2
	mov	ebx, edx
	sub	ecx, edi
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	ebp, ecx

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	esi, ebx
	test	ebx, ebx
	je	SHORT $LN7@Rotate
$LL8@Rotate:

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	mov	eax, ebp
	cdq
	idiv	esi

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	ebp, esi
	mov	esi, edx
	test	edx, edx
	jne	SHORT $LL8@Rotate
$LN7@Rotate:

; 1689 : 		}
; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	cmp	ebp, ecx
	jge	$LN3@Rotate

; 1692 : 		for (; 0 < _Count; --_Count)

	test	ebp, ebp
	jle	$LN3@Rotate
	lea	eax, DWORD PTR [ebx+ebx*2]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	mov	edx, 20					; 00000014H
	lea	ecx, DWORD PTR [ebp+ebp*2]
	sub	edx, eax
	mov	DWORD PTR tv175[esp+40], eax
	lea	edi, DWORD PTR [edi+ecx*8]
	mov	DWORD PTR tv289[esp+44], edx
	jmp	SHORT $LN5@Rotate
	npad	1
$LL25@Rotate:
	mov	edx, DWORD PTR tv289[esp+44]
$LN5@Rotate:

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;
; 1695 : 			_RanIt _Next = _Hole;
; 1696 : 			_Ty _Holeval = *_Hole;

	mov	esi, DWORD PTR [edi]
	mov	DWORD PTR __Holeval$220644[esp+44], esi
	mov	esi, DWORD PTR [edi+4]
	mov	DWORD PTR __Holeval$220644[esp+48], esi
	mov	esi, DWORD PTR [edi+8]
	mov	DWORD PTR __Holeval$220644[esp+52], esi
	mov	esi, DWORD PTR [edi+12]
	mov	DWORD PTR __Holeval$220644[esp+56], esi
	mov	esi, DWORD PTR [edi+16]
	mov	DWORD PTR __Holeval$220644[esp+60], esi
	lea	esi, DWORD PTR [edi+eax]
	mov	edx, DWORD PTR [edx+esi]
	mov	ecx, edi
	mov	DWORD PTR __Holeval$220644[esp+64], edx

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	cmp	esi, DWORD PTR __Last$[esp+40]
	jne	SHORT $LN11@Rotate
	mov	esi, DWORD PTR __First$[esp+40]
$LN11@Rotate:

; 1698 : 			while (_Next1 != _Hole)

	cmp	esi, edi
	je	SHORT $LN24@Rotate
$LL2@Rotate:

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+8], eax
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+16], eax
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [ecx+20], edx

; 1701 : 				_Next = _Next1;
; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	edx, DWORD PTR __Last$[esp+40]
	sub	edx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebx, eax
	mov	ecx, esi
	jge	SHORT $LN13@Rotate
	add	esi, DWORD PTR tv175[esp+40]
	jmp	SHORT $LN14@Rotate
$LN13@Rotate:
	mov	edx, ebx
	sub	edx, eax
	lea	eax, DWORD PTR [edx+edx*2]
	mov	edx, DWORD PTR __First$[esp+40]
	lea	esi, DWORD PTR [edx+eax*8]
$LN14@Rotate:

; 1698 : 			while (_Next1 != _Hole)

	cmp	esi, edi
	jne	SHORT $LL2@Rotate
	mov	eax, DWORD PTR tv175[esp+40]
$LN24@Rotate:

; 1704 : 				}
; 1705 : 			*_Next = _Holeval;

	mov	edx, DWORD PTR __Holeval$220644[esp+44]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR __Holeval$220644[esp+48]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR __Holeval$220644[esp+52]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR __Holeval$220644[esp+56]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR __Holeval$220644[esp+60]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR __Holeval$220644[esp+64]
	dec	ebp
	sub	edi, 24					; 00000018H
	mov	DWORD PTR [ecx+20], edx
	test	ebp, ebp
	jg	$LL25@Rotate
$LN3@Rotate:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1706 : 			}
; 1707 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00PAH0@Z ENDP ; std::_Rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	?GetCString@CvString@@QBEPBDXZ			; CvString::GetCString
; Function compile flags: /Ogtpy
;	COMDAT ?GetCString@CvString@@QBEPBDXZ
_TEXT	SEGMENT
?GetCString@CvString@@QBEPBDXZ PROC			; CvString::GetCString, COMDAT
; _this$ = ecx

; 42   : 	const char* GetCString() const 	{ return c_str(); }

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetCString@CvString@@QBEPBDXZ ENDP			; CvString::GetCString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getNumFlavorTypes@CvGlobals@@QAEHXZ		; CvGlobals::getNumFlavorTypes
; Function compile flags: /Ogtpy
;	COMDAT ?getNumFlavorTypes@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumFlavorTypes@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumFlavorTypes, COMDAT
; _this$ = ecx

; 804  : 		return m_iNumFlavorTypes;

	mov	eax, DWORD PTR [ecx+1764]

; 805  : 	}

	ret	0
?getNumFlavorTypes@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumFlavorTypes
_TEXT	ENDS
PUBLIC	?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z ; CvGlobals::getFlavorTypes
; Function compile flags: /Ogtpy
;	COMDAT ?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z PROC ; CvGlobals::getFlavorTypes, COMDAT
; _this$ = ecx

; 812  : 		CvAssert(e > -1); /*CvAssert(e < GC.getNumFlavorTypes())*/;
; 813  : 		return m_paszFlavorTypes[e];

	mov	eax, DWORD PTR _e$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+1760]
	lea	eax, DWORD PTR [eax+edx*4]

; 814  : 	}

	ret	4
?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z ENDP ; CvGlobals::getFlavorTypes
_TEXT	ENDS
PUBLIC	?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_FOOD@CvGlobals@@QAEHXZ ; CvGlobals::getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_FOOD
; Function compile flags: /Ogtpy
;	COMDAT ?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_FOOD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_FOOD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_FOOD, COMDAT
; _this$ = ecx

; 1169 : 		return m_iBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_FOOD;

	mov	eax, DWORD PTR [ecx+2104]

; 1170 : 	}

	ret	0
?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_FOOD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_FOOD
_TEXT	ENDS
PUBLIC	?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_PRODUCTION@CvGlobals@@QAEHXZ ; CvGlobals::getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_PRODUCTION
; Function compile flags: /Ogtpy
;	COMDAT ?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_PRODUCTION@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_PRODUCTION@CvGlobals@@QAEHXZ PROC ; CvGlobals::getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_PRODUCTION, COMDAT
; _this$ = ecx

; 1173 : 		return m_iBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_PRODUCTION;

	mov	eax, DWORD PTR [ecx+2108]

; 1174 : 	}

	ret	0
?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_PRODUCTION@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_PRODUCTION
_TEXT	ENDS
PUBLIC	?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_GOLD@CvGlobals@@QAEHXZ ; CvGlobals::getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_GOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_GOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_GOLD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_GOLD, COMDAT
; _this$ = ecx

; 1177 : 		return m_iBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_GOLD;

	mov	eax, DWORD PTR [ecx+2112]

; 1178 : 	}

	ret	0
?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_GOLD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_GOLD
_TEXT	ENDS
PUBLIC	?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_SCIENCE@CvGlobals@@QAEHXZ ; CvGlobals::getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_SCIENCE
; Function compile flags: /Ogtpy
;	COMDAT ?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_SCIENCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_SCIENCE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_SCIENCE, COMDAT
; _this$ = ecx

; 1181 : 		return m_iBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_SCIENCE;

	mov	eax, DWORD PTR [ecx+2116]

; 1182 : 	}

	ret	0
?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_SCIENCE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_SCIENCE
_TEXT	ENDS
PUBLIC	?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_CULTURE@CvGlobals@@QAEHXZ ; CvGlobals::getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_CULTURE
; Function compile flags: /Ogtpy
;	COMDAT ?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_CULTURE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_CULTURE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_CULTURE, COMDAT
; _this$ = ecx

; 1185 : 		return m_iBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_CULTURE;

	mov	eax, DWORD PTR [ecx+2120]

; 1186 : 	}

	ret	0
?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_CULTURE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_CULTURE
_TEXT	ENDS
PUBLIC	?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_LUXURY_RESOURCE@CvGlobals@@QAEHXZ ; CvGlobals::getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_LUXURY_RESOURCE
; Function compile flags: /Ogtpy
;	COMDAT ?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_LUXURY_RESOURCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_LUXURY_RESOURCE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_LUXURY_RESOURCE, COMDAT
; _this$ = ecx

; 1189 : 		return m_iBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_LUXURY_RESOURCE;

	mov	eax, DWORD PTR [ecx+2124]

; 1190 : 	}

	ret	0
?getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_LUXURY_RESOURCE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_LUXURY_RESOURCE
_TEXT	ENDS
PUBLIC	?getBUILDER_TASKING_BASELINE_BUILD_IMPROVEMENTS@CvGlobals@@QAEHXZ ; CvGlobals::getBUILDER_TASKING_BASELINE_BUILD_IMPROVEMENTS
; Function compile flags: /Ogtpy
;	COMDAT ?getBUILDER_TASKING_BASELINE_BUILD_IMPROVEMENTS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBUILDER_TASKING_BASELINE_BUILD_IMPROVEMENTS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getBUILDER_TASKING_BASELINE_BUILD_IMPROVEMENTS, COMDAT
; _this$ = ecx

; 1205 : 		return m_iBUILDER_TASKING_BASELINE_BUILD_IMPROVEMENTS;

	mov	eax, DWORD PTR [ecx+2140]

; 1206 : 	}

	ret	0
?getBUILDER_TASKING_BASELINE_BUILD_IMPROVEMENTS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getBUILDER_TASKING_BASELINE_BUILD_IMPROVEMENTS
_TEXT	ENDS
PUBLIC	?getBUILDER_TASKING_BASELINE_BUILD_RESOURCE_IMPROVEMENTS@CvGlobals@@QAEHXZ ; CvGlobals::getBUILDER_TASKING_BASELINE_BUILD_RESOURCE_IMPROVEMENTS
; Function compile flags: /Ogtpy
;	COMDAT ?getBUILDER_TASKING_BASELINE_BUILD_RESOURCE_IMPROVEMENTS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBUILDER_TASKING_BASELINE_BUILD_RESOURCE_IMPROVEMENTS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getBUILDER_TASKING_BASELINE_BUILD_RESOURCE_IMPROVEMENTS, COMDAT
; _this$ = ecx

; 1209 : 		return m_iBUILDER_TASKING_BASELINE_BUILD_RESOURCE_IMPROVEMENTS;

	mov	eax, DWORD PTR [ecx+2144]

; 1210 : 	}

	ret	0
?getBUILDER_TASKING_BASELINE_BUILD_RESOURCE_IMPROVEMENTS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getBUILDER_TASKING_BASELINE_BUILD_RESOURCE_IMPROVEMENTS
_TEXT	ENDS
PUBLIC	?getBUILDER_TASKING_BASELINE_BUILD_ROUTES@CvGlobals@@QAEHXZ ; CvGlobals::getBUILDER_TASKING_BASELINE_BUILD_ROUTES
; Function compile flags: /Ogtpy
;	COMDAT ?getBUILDER_TASKING_BASELINE_BUILD_ROUTES@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBUILDER_TASKING_BASELINE_BUILD_ROUTES@CvGlobals@@QAEHXZ PROC ; CvGlobals::getBUILDER_TASKING_BASELINE_BUILD_ROUTES, COMDAT
; _this$ = ecx

; 1213 : 		return m_iBUILDER_TASKING_BASELINE_BUILD_ROUTES;

	mov	eax, DWORD PTR [ecx+2148]

; 1214 : 	}

	ret	0
?getBUILDER_TASKING_BASELINE_BUILD_ROUTES@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getBUILDER_TASKING_BASELINE_BUILD_ROUTES
_TEXT	ENDS
PUBLIC	?getBUILDER_TASKING_BASELINE_REPAIR@CvGlobals@@QAEHXZ ; CvGlobals::getBUILDER_TASKING_BASELINE_REPAIR
; Function compile flags: /Ogtpy
;	COMDAT ?getBUILDER_TASKING_BASELINE_REPAIR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBUILDER_TASKING_BASELINE_REPAIR@CvGlobals@@QAEHXZ PROC ; CvGlobals::getBUILDER_TASKING_BASELINE_REPAIR, COMDAT
; _this$ = ecx

; 1217 : 		return m_iBUILDER_TASKING_BASELINE_REPAIR;

	mov	eax, DWORD PTR [ecx+2152]

; 1218 : 	}

	ret	0
?getBUILDER_TASKING_BASELINE_REPAIR@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getBUILDER_TASKING_BASELINE_REPAIR
_TEXT	ENDS
PUBLIC	?getBUILDER_TASKING_BASELINE_SCRUB_FALLOUT@CvGlobals@@QAEHXZ ; CvGlobals::getBUILDER_TASKING_BASELINE_SCRUB_FALLOUT
; Function compile flags: /Ogtpy
;	COMDAT ?getBUILDER_TASKING_BASELINE_SCRUB_FALLOUT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBUILDER_TASKING_BASELINE_SCRUB_FALLOUT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getBUILDER_TASKING_BASELINE_SCRUB_FALLOUT, COMDAT
; _this$ = ecx

; 1221 : 		return m_iBUILDER_TASKING_BASELINE_SCRUB_FALLOUT;

	mov	eax, DWORD PTR [ecx+2156]

; 1222 : 	}

	ret	0
?getBUILDER_TASKING_BASELINE_SCRUB_FALLOUT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getBUILDER_TASKING_BASELINE_SCRUB_FALLOUT
_TEXT	ENDS
PUBLIC	?getBUILDER_TASKING_BASELINE_ADDS_CULTURE@CvGlobals@@QAEHXZ ; CvGlobals::getBUILDER_TASKING_BASELINE_ADDS_CULTURE
; Function compile flags: /Ogtpy
;	COMDAT ?getBUILDER_TASKING_BASELINE_ADDS_CULTURE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBUILDER_TASKING_BASELINE_ADDS_CULTURE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getBUILDER_TASKING_BASELINE_ADDS_CULTURE, COMDAT
; _this$ = ecx

; 1225 : 		return m_iBUILDER_TASKING_BASELINE_ADDS_CULTURE;

	mov	eax, DWORD PTR [ecx+2160]

; 1226 : 	}

	ret	0
?getBUILDER_TASKING_BASELINE_ADDS_CULTURE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getBUILDER_TASKING_BASELINE_ADDS_CULTURE
_TEXT	ENDS
PUBLIC	?getINDUSTRIAL_ROUTE_PRODUCTION_MOD@CvGlobals@@QAEHXZ ; CvGlobals::getINDUSTRIAL_ROUTE_PRODUCTION_MOD
; Function compile flags: /Ogtpy
;	COMDAT ?getINDUSTRIAL_ROUTE_PRODUCTION_MOD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getINDUSTRIAL_ROUTE_PRODUCTION_MOD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getINDUSTRIAL_ROUTE_PRODUCTION_MOD, COMDAT
; _this$ = ecx

; 5508 : 		return m_iINDUSTRIAL_ROUTE_PRODUCTION_MOD;

	mov	eax, DWORD PTR [ecx+6432]

; 5509 : 	}

	ret	0
?getINDUSTRIAL_ROUTE_PRODUCTION_MOD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getINDUSTRIAL_ROUTE_PRODUCTION_MOD
_TEXT	ENDS
PUBLIC	?getPLOT_UNIT_LIMIT@CvGlobals@@QAEHXZ		; CvGlobals::getPLOT_UNIT_LIMIT
; Function compile flags: /Ogtpy
;	COMDAT ?getPLOT_UNIT_LIMIT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPLOT_UNIT_LIMIT@CvGlobals@@QAEHXZ PROC		; CvGlobals::getPLOT_UNIT_LIMIT, COMDAT
; _this$ = ecx

; 6485 : 		return m_iPLOT_UNIT_LIMIT;

	mov	eax, DWORD PTR [ecx+7356]

; 6486 : 	}

	ret	0
?getPLOT_UNIT_LIMIT@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getPLOT_UNIT_LIMIT
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_ROUTE_QUEST_WEIGHT@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_ROUTE_QUEST_WEIGHT
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_ROUTE_QUEST_WEIGHT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_ROUTE_QUEST_WEIGHT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMINOR_CIV_ROUTE_QUEST_WEIGHT, COMDAT
; _this$ = ecx

; 6969 : 		return m_iMINOR_CIV_ROUTE_QUEST_WEIGHT;

	mov	eax, DWORD PTR [ecx+7840]

; 6970 : 	}

	ret	0
?getMINOR_CIV_ROUTE_QUEST_WEIGHT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMINOR_CIV_ROUTE_QUEST_WEIGHT
_TEXT	ENDS
PUBLIC	?getNUKE_FEATURE@CvGlobals@@QAEHXZ		; CvGlobals::getNUKE_FEATURE
; Function compile flags: /Ogtpy
;	COMDAT ?getNUKE_FEATURE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUKE_FEATURE@CvGlobals@@QAEHXZ PROC			; CvGlobals::getNUKE_FEATURE, COMDAT
; _this$ = ecx

; 7187 : 		return m_iNUKE_FEATURE;

	mov	eax, DWORD PTR [ecx+8404]

; 7188 : 	}

	ret	0
?getNUKE_FEATURE@CvGlobals@@QAEHXZ ENDP			; CvGlobals::getNUKE_FEATURE
_TEXT	ENDS
PUBLIC	?getCITY_CONNECTIONS_CONNECT_TO_CAPITAL@CvGlobals@@QAEHXZ ; CvGlobals::getCITY_CONNECTIONS_CONNECT_TO_CAPITAL
; Function compile flags: /Ogtpy
;	COMDAT ?getCITY_CONNECTIONS_CONNECT_TO_CAPITAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getCITY_CONNECTIONS_CONNECT_TO_CAPITAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getCITY_CONNECTIONS_CONNECT_TO_CAPITAL, COMDAT
; _this$ = ecx

; 7499 : 		return m_iCITY_CONNECTIONS_CONNECT_TO_CAPITAL;

	mov	eax, DWORD PTR [ecx+8188]

; 7500 : 	}

	ret	0
?getCITY_CONNECTIONS_CONNECT_TO_CAPITAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getCITY_CONNECTIONS_CONNECT_TO_CAPITAL
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@isCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax

; 249  : 	}

	ret	0
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al

; 249  : 	}

	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?isMountain@CvPlot@@QBE_NXZ			; CvPlot::isMountain
; Function compile flags: /Ogtpy
;	COMDAT ?isMountain@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isMountain@CvPlot@@QBE_NXZ PROC			; CvPlot::isMountain, COMDAT
; _this$ = ecx

; 422  : 		return (PlotTypes)m_ePlotType == PLOT_MOUNTAIN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], al
	sete	al

; 423  : 	};

	ret	0
?isMountain@CvPlot@@QBE_NXZ ENDP			; CvPlot::isMountain
_TEXT	ENDS
PUBLIC	?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ	; CvPlot::getTerrainType
; Function compile flags: /Ogtpy
;	COMDAT ?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ
_TEXT	SEGMENT
?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ PROC	; CvPlot::getTerrainType, COMDAT
; _this$ = ecx

; 431  : 		return (TerrainTypes)m_eTerrainType;

	movsx	eax, BYTE PTR [ecx+6]

; 432  : 	}

	ret	0
?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ ENDP	; CvPlot::getTerrainType
_TEXT	ENDS
PUBLIC	?isImpassable@CvPlot@@QBE_NXZ			; CvPlot::isImpassable
; Function compile flags: /Ogtpy
;	COMDAT ?isImpassable@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isImpassable@CvPlot@@QBE_NXZ PROC			; CvPlot::isImpassable, COMDAT
; _this$ = ecx

; 444  : 		return m_bIsImpassable;

	mov	al, BYTE PTR [ecx+462]
	shr	al, 7

; 445  : 	}

	ret	0
?isImpassable@CvPlot@@QBE_NXZ ENDP			; CvPlot::isImpassable
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@getPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 537  : 	}

	ret	0
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax

; 537  : 	}

	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?numPlots@CvMap@@QBEHXZ				; CvMap::numPlots
; Function compile flags: /Ogtpy
;	COMDAT ?numPlots@CvMap@@QBEHXZ
_TEXT	SEGMENT
?numPlots@CvMap@@QBEHXZ PROC				; CvMap::numPlots, COMDAT
; _this$ = ecx

; 170  : 		return m_iGridSize;

	mov	eax, DWORD PTR [ecx+4028]

; 171  : 	}

	ret	0
?numPlots@CvMap@@QBEHXZ ENDP				; CvMap::numPlots
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z		; CvMap::plotByIndex
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z PROC		; CvMap::plotByIndex, COMDAT
; _this$ = ecx

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	mov	eax, DWORD PTR _iIndex$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@plotByInde
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN3@plotByInde
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 264  : 	}

	ret	4
$LN3@plotByInde:

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	xor	eax, eax

; 264  : 	}

	ret	4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z ENDP		; CvMap::plotByIndex
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	?IsMoveFriendlyWoodsAsRoad@CvPlayerTraits@@QBE_NXZ ; CvPlayerTraits::IsMoveFriendlyWoodsAsRoad
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
;	COMDAT ?IsMoveFriendlyWoodsAsRoad@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
?IsMoveFriendlyWoodsAsRoad@CvPlayerTraits@@QBE_NXZ PROC	; CvPlayerTraits::IsMoveFriendlyWoodsAsRoad, COMDAT
; _this$ = ecx

; 753  : 		return m_bMoveFriendlyWoodsAsRoad;

	mov	al, BYTE PTR [ecx+333]

; 754  : 	};

	ret	0
?IsMoveFriendlyWoodsAsRoad@CvPlayerTraits@@QBE_NXZ ENDP	; CvPlayerTraits::IsMoveFriendlyWoodsAsRoad
_TEXT	ENDS
PUBLIC	?IsEmbarkedAllWater@CvPlayerTraits@@QBE_NXZ	; CvPlayerTraits::IsEmbarkedAllWater
; Function compile flags: /Ogtpy
;	COMDAT ?IsEmbarkedAllWater@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
?IsEmbarkedAllWater@CvPlayerTraits@@QBE_NXZ PROC	; CvPlayerTraits::IsEmbarkedAllWater, COMDAT
; _this$ = ecx

; 765  : 		return m_bEmbarkedAllWater;

	mov	al, BYTE PTR [ecx+336]

; 766  : 	};

	ret	0
?IsEmbarkedAllWater@CvPlayerTraits@@QBE_NXZ ENDP	; CvPlayerTraits::IsEmbarkedAllWater
_TEXT	ENDS
PUBLIC	?IsFaithFromUnimprovedForest@CvPlayerTraits@@QBE_NXZ ; CvPlayerTraits::IsFaithFromUnimprovedForest
; Function compile flags: /Ogtpy
;	COMDAT ?IsFaithFromUnimprovedForest@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
?IsFaithFromUnimprovedForest@CvPlayerTraits@@QBE_NXZ PROC ; CvPlayerTraits::IsFaithFromUnimprovedForest, COMDAT
; _this$ = ecx

; 815  : 		return m_bFaithFromUnimprovedForest;

	mov	al, BYTE PTR [ecx+341]

; 816  : 	};

	ret	0
?IsFaithFromUnimprovedForest@CvPlayerTraits@@QBE_NXZ ENDP ; CvPlayerTraits::IsFaithFromUnimprovedForest
_TEXT	ENDS
PUBLIC	?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ	; CvAStar::GetLastNode
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.h
;	COMDAT ?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ
_TEXT	SEGMENT
?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ PROC	; CvAStar::GetLastNode, COMDAT
; _this$ = ecx

; 98   : 		return m_pBest;

	mov	eax, DWORD PTR [ecx+96]

; 99   : 	}

	ret	0
?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ ENDP	; CvAStar::GetLastNode
_TEXT	ENDS
PUBLIC	??0BuilderDirective@@QAE@XZ			; BuilderDirective::BuilderDirective
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.h
;	COMDAT ??0BuilderDirective@@QAE@XZ
_TEXT	SEGMENT
??0BuilderDirective@@QAE@XZ PROC			; BuilderDirective::BuilderDirective, COMDAT
; _this$ = ecx

; 46   : 	{

	mov	eax, ecx
	or	ecx, -1
	mov	edx, ecx
	mov	DWORD PTR [eax], 6
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	WORD PTR [eax+12], dx
	mov	WORD PTR [eax+14], dx
	mov	WORD PTR [eax+16], cx

; 47   : 	}

	ret	0
??0BuilderDirective@@QAE@XZ ENDP			; BuilderDirective::BuilderDirective
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvUnit>::get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvUnit>::get
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ	; FAutoVariable<int,CvUnit>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::get
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ		; FAutoVariable<int,CvUnit>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::operator int const &
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ		; FAutoVariable<char,CvPlot>::operator char const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ
_TEXT	SEGMENT
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ PROC		; FAutoVariable<char,CvPlot>::operator char const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ ENDP		; FAutoVariable<char,CvPlot>::operator char const &
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDY$ = -12						; size = 4
tv320 = -8						; size = 4
tv357 = -4						; size = 4
_iX1$ = 8						; size = 4
_iDX$ = 12						; size = 4
_iY1$ = 12						; size = 4
$T221689 = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	sub	esp, 12					; 0000000cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	ecx, DWORD PTR _iX2$[esp+8]
	sub	ecx, DWORD PTR _iX1$[esp+8]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edi+4056], 0
	mov	edx, DWORD PTR [edi+4020]
	mov	DWORD PTR tv320[esp+28], ecx
	je	SHORT $LN18@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN20@plotDistan
	sub	ecx, edx
	jmp	SHORT $LN18@plotDistan
$LN20@plotDistan:
	neg	eax
	cmp	ecx, eax
	jge	SHORT $LN18@plotDistan
	add	ecx, edx
$LN18@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ebp, DWORD PTR _iY2$[esp+24]
	sub	ebp, DWORD PTR _iY1$[esp+24]
	cmp	BYTE PTR [edi+4057], 0
	mov	eax, DWORD PTR [edi+4024]
	je	SHORT $LN32@plotDistan
	mov	edx, eax
	shr	edx, 1
	cmp	ebp, edx
	jle	SHORT $LN34@plotDistan
	mov	ebx, ebp
	sub	ebx, eax
	mov	DWORD PTR $T221689[esp+24], ebx
	jmp	SHORT $LN36@plotDistan
$LN34@plotDistan:
	neg	edx
	cmp	ebp, edx
	jge	SHORT $LN32@plotDistan
	lea	ebx, DWORD PTR [eax+ebp]
	mov	DWORD PTR $T221689[esp+24], ebx
	jmp	SHORT $LN36@plotDistan
$LN32@plotDistan:
	mov	ebx, ebp
	mov	DWORD PTR $T221689[esp+24], ebp
$LN36@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebx
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx

; 149  : 
; 150  : #ifdef GAMECOREUTILS_FIX_PLOT_DISTANCE
; 151  : 	const CvMap& kMap = GC.getMap();
; 152  : 	// equidistant column joint fix (on X-wrapped maps):
; 153  : 	if ((kMap.isWrapX()) && (abs(iWrappedDX * 2) == kMap.getGridWidth()) && (iDY % 2 != 0) && ((iY1 % 2 == 0) == (iWrappedDX > (kMap.getGridWidth() >> 2))))

	cmp	BYTE PTR [edi+4056], 0
	mov	DWORD PTR _iDY$[esp+28], esi
	je	$LN77@plotDistan
	lea	eax, DWORD PTR [ecx+ecx]
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+4020]
	xor	ebx, edx
	sub	ebx, edx
	cmp	ebx, eax
	jne	SHORT $LN73@plotDistan
	mov	edx, esi
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN79@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN79@plotDistan:
	je	SHORT $LN73@plotDistan
	sar	eax, 2
	xor	edx, edx
	cmp	ecx, eax
	mov	eax, DWORD PTR _iY1$[esp+24]
	setg	dl
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN80@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN80@plotDistan:

; 154  : 	{
; 155  : 		iWrappedDX *= -1;  // change polarity

	mov	ebx, DWORD PTR $T221689[esp+24]
	neg	eax
	sbb	eax, eax
	inc	eax
	cmp	eax, edx
	jne	SHORT $LN5@plotDistan
	neg	ecx
	jmp	SHORT $LN5@plotDistan
$LN73@plotDistan:
	mov	ebx, DWORD PTR $T221689[esp+24]
$LN5@plotDistan:

; 156  : 	}
; 157  : 	if ((kMap.isWrapX()) && (abs(iWrappedDX * 2) == kMap.getGridWidth()) && (abs(iWrappedDY) < abs(iY2 - iY1)) && (iDY % 2 == 0) && (iX2 - iX1 < 0))

	cmp	BYTE PTR [edi+4056], 0
	je	$LN77@plotDistan
	lea	eax, DWORD PTR [ecx+ecx]
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, DWORD PTR [edi+4020]
	jne	SHORT $LN75@plotDistan
	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	esi, eax
	jge	SHORT $LN75@plotDistan
	mov	edx, DWORD PTR _iDY$[esp+28]
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN81@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN81@plotDistan:
	jne	SHORT $LN75@plotDistan
	cmp	DWORD PTR tv320[esp+28], 0
	jge	SHORT $LN75@plotDistan

; 158  : 	{
; 159  : 		iWrappedDX *= -1;  // change polarity

	neg	ecx
$LN75@plotDistan:

; 160  : 	}
; 161  : 	// special case when map is toroidal AND map height is odd
; 162  : 	// TODO works but ugly
; 163  : 	if ((kMap.isWrapX()) && (kMap.getGridHeight() % 2 != 0) && (iY1 % 2 == kMap.getGridWidth() % 2) && (iY2 % 2 == 0) &&
; 164  : 		(abs(iWrappedDY) < abs(iY2 - iY1)) && (abs(iX2 - iX1) == kMap.getGridWidth() / 2 + ((kMap.getGridWidth() % 2 == 1) && (iX2 - iX1 > 0)) ? 1 : 0))

	cmp	BYTE PTR [edi+4056], 0
	je	$LN77@plotDistan
	mov	eax, DWORD PTR [edi+4024]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN82@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN82@plotDistan:
	je	$LN77@plotDistan
	mov	edi, DWORD PTR [edi+4020]
	mov	DWORD PTR tv357[esp+28], edi
	and	edi, -2147483647			; 80000001H
	jns	SHORT $LN83@plotDistan
	dec	edi
	or	edi, -2					; fffffffeH
	inc	edi
$LN83@plotDistan:
	mov	edx, DWORD PTR _iY1$[esp+24]
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN84@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN84@plotDistan:
	cmp	edx, edi
	jne	SHORT $LN77@plotDistan
	mov	eax, DWORD PTR _iY2$[esp+24]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN85@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN85@plotDistan:
	jne	SHORT $LN77@plotDistan
	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	esi, eax
	jge	SHORT $LN77@plotDistan
	cmp	edi, 1
	jne	SHORT $LN76@plotDistan
	cmp	DWORD PTR tv320[esp+28], 0
	jle	SHORT $LN76@plotDistan
	mov	esi, edi
	jmp	SHORT $LN9@plotDistan
$LN76@plotDistan:
	xor	esi, esi
$LN9@plotDistan:
	mov	eax, DWORD PTR tv320[esp+28]
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR tv357[esp+28]
	xor	edi, edx
	sub	edi, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, esi
	cmp	edi, eax
	jne	SHORT $LN77@plotDistan

; 165  : 	{
; 166  : 		iWrappedDX -= (iWrappedDX > 0) - (iWrappedDX < 0);  // decrease regardless of polarity

	xor	edx, edx
	test	ecx, ecx
	setl	dl
	xor	eax, eax
	test	ecx, ecx
	setg	al
	sub	edx, eax
	add	ecx, edx
$LN77@plotDistan:

; 167  : 	}
; 168  : #endif
; 169  : 
; 170  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 171  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	mov	eax, DWORD PTR _iY1$[esp+24]
	test	eax, eax
	jge	SHORT $LN88@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN88@plotDistan:
	mov	edi, DWORD PTR _iX1$[esp+24]

; 172  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	edx, DWORD PTR _iY1$[esp+24]
	sar	eax, 1
	mov	esi, edi
	sub	esi, eax
	lea	eax, DWORD PTR [ebx+edx]
	test	eax, eax
	jge	SHORT $LN89@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN89@plotDistan:
	sar	eax, 1
	sub	ecx, eax
	add	ecx, edi

; 173  : 
; 174  : #ifdef GAMECOREUTILS_FIX_PLOT_DISTANCE
; 175  : 	// obvious bug
; 176  : 	iDX = abs(iHX2 - iHX1);

	sub	ecx, esi
	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx

; 177  : #else
; 178  : 	iDX = abs(dxWrap(iHX2 - iHX1));
; 179  : #endif
; 180  : 
; 181  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 182  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 183  : #else
; 184  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebx, ebx
	setge	cl
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp+12], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 185  : #endif
; 186  : 	{
; 187  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp+12]
	add	eax, edx

; 195  : #endif
; 196  : 	}
; 197  : }

	add	esp, 12					; 0000000cH
	ret	0
$LN2@plotDistan:

; 188  : 	}
; 189  : 	else
; 190  : 	{
; 191  : #ifdef NQM_FAST_COMP
; 192  : 		return (MAX(iDX, iDY));
; 193  : #else
; 194  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp+12]
	lea	eax, DWORD PTR _iDY$[esp+12]
	jl	SHORT $LN71@plotDistan
	lea	eax, DWORD PTR _iDX$[esp+8]
$LN71@plotDistan:
	mov	eax, DWORD PTR [eax]

; 195  : #endif
; 196  : 	}
; 197  : }

	add	esp, 12					; 0000000cH
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	?Write@CvBuilderTaskingAI@@QAEXAAVFDataStream@@@Z ; CvBuilderTaskingAI::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4BuildTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
;	COMDAT ?Write@CvBuilderTaskingAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
$T221794 = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvBuilderTaskingAI@@QAEXAAVFDataStream@@@Z PROC	; CvBuilderTaskingAI::Write, COMDAT
; _this$ = ecx

; 160  : {

	push	ecx
	push	ebx
	push	esi
	push	edi

; 161  : 	// Current version number
; 162  : 	uint uiVersion = 2;
; 163  : 	kStream << uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+12]
	lea	eax, DWORD PTR _uiVersion$[esp+16]
	mov	ebx, ecx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+20], 2
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 164  : 
; 165  : 	kStream << m_eRepairBuild;

	lea	ecx, DWORD PTR [ebx+4]
	push	ecx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4BuildTypes@@@Z ; operator<<

; 166  : 
; 167  : 	// non-territory plots
; 168  : 	kStream << m_aiNonTerritoryPlots.size();

	mov	edx, DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+4
	add	esp, 8
	lea	eax, DWORD PTR $T221794[esp+12]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T221794[esp+16], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 169  : 	for(uint ui = 0; ui < m_aiNonTerritoryPlots.size(); ui++)

	xor	esi, esi
	cmp	DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+4, esi
	jbe	SHORT $LN1@Write
	npad	5
$LL3@Write:
	mov	ecx, DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A
	lea	edx, DWORD PTR [ecx+esi*4]

; 170  : 	{
; 171  : 		kStream << m_aiNonTerritoryPlots[ui];

	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	esi
	cmp	esi, DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+4
	jb	SHORT $LL3@Write
$LN1@Write:

; 172  : 	}
; 173  : 
; 174  : #ifndef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 175  : 	kStream << m_bKeepMarshes;

	lea	eax, DWORD PTR [ebx+58460]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 176  : 	kStream << m_bKeepJungle;

	add	ebx, 58461				; 0000e45dH
	push	ebx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	pop	edi
	pop	esi
	pop	ebx

; 177  : #endif
; 178  : }

	pop	ecx
	ret	4
?Write@CvBuilderTaskingAI@@QAEXAAVFDataStream@@@Z ENDP	; CvBuilderTaskingAI::Write
_TEXT	ENDS
PUBLIC	?GetPlotYield@@YAHPAVCvPlot@@W4YieldTypes@@@Z	; GetPlotYield
EXTRN	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z:PROC ; CvPlot::calculateNatureYield
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlotYield@@YAHPAVCvPlot@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
_eYield$ = 12						; size = 4
?GetPlotYield@@YAHPAVCvPlot@@W4YieldTypes@@@Z PROC	; GetPlotYield, COMDAT

; 285  : 	if(pPlot->getTerrainType() == NO_TERRAIN)

	mov	ecx, DWORD PTR _pPlot$[esp-4]
	cmp	BYTE PTR [ecx+6], -1
	jne	SHORT $LN1@GetPlotYie

; 286  : 	{
; 287  : 		return 0;

	xor	eax, eax

; 291  : }

	ret	0
$LN1@GetPlotYie:

; 288  : 	}
; 289  : 
; 290  : 	return pPlot->calculateNatureYield(eYield, NO_TEAM);;

	mov	eax, DWORD PTR _eYield$[esp-4]
	push	0
	push	-1
	push	eax
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield

; 291  : }

	ret	0
?GetPlotYield@@YAHPAVCvPlot@@W4YieldTypes@@@Z ENDP	; GetPlotYield
_TEXT	ENDS
PUBLIC	?GetFalloutFeature@CvBuilderTaskingAI@@QAE?AW4FeatureTypes@@XZ ; CvBuilderTaskingAI::GetFalloutFeature
; Function compile flags: /Ogtpy
;	COMDAT ?GetFalloutFeature@CvBuilderTaskingAI@@QAE?AW4FeatureTypes@@XZ
_TEXT	SEGMENT
?GetFalloutFeature@CvBuilderTaskingAI@@QAE?AW4FeatureTypes@@XZ PROC ; CvBuilderTaskingAI::GetFalloutFeature, COMDAT
; _this$ = ecx

; 3138 : 	return static_cast<FeatureTypes>(GC.getNUKE_FEATURE());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8404

; 3139 : }

	ret	0
?GetFalloutFeature@CvBuilderTaskingAI@@QAE?AW4FeatureTypes@@XZ ENDP ; CvBuilderTaskingAI::GetFalloutFeature
_TEXT	ENDS
PUBLIC	?GetFalloutRemove@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@XZ ; CvBuilderTaskingAI::GetFalloutRemove
EXTRN	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z:PROC	; CvBuildInfo::isFeatureRemove
; Function compile flags: /Ogtpy
;	COMDAT ?GetFalloutRemove@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@XZ
_TEXT	SEGMENT
?GetFalloutRemove@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@XZ PROC ; CvBuilderTaskingAI::GetFalloutRemove, COMDAT
; _this$ = ecx

; 3146 : {

	push	edi

; 3147 : 	FeatureTypes eFalloutFeature = m_eFalloutFeature;

	mov	edi, DWORD PTR [ecx+58452]

; 3148 : 	if(eFalloutFeature == NO_FEATURE)

	cmp	edi, -1
	jne	SHORT $LN5@GetFallout

; 3149 : 	{
; 3150 : 		eFalloutFeature = GetFalloutFeature();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8404

; 3151 : 	}
; 3152 : 
; 3153 : 	if(eFalloutFeature == NO_FEATURE)

	cmp	edi, -1
	jne	SHORT $LN5@GetFallout

; 3154 : 	{
; 3155 : 		return NO_BUILD;

	or	eax, edi
	pop	edi

; 3173 : }

	ret	0
$LN5@GetFallout:
	push	esi

; 3156 : 	}
; 3157 : 
; 3158 : #ifdef AUI_WARNING_FIXES
; 3159 : 	for (uint iBuild = 0; iBuild < GC.getNumBuildInfos(); iBuild++)
; 3160 : #else
; 3161 : 	for(int iBuild = 0; iBuild < GC.getNumBuildInfos(); iBuild++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	SHORT $LN2@GetFallout
	npad	4
$LL4@GetFallout:

; 3162 : #endif
; 3163 : 	{
; 3164 : 		BuildTypes eBuild = (BuildTypes)iBuild;
; 3165 : 		CvBuildInfo* pBuildInfo = GC.getBuildInfo(eBuild);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 3166 : 		if(NULL != pBuildInfo && pBuildInfo->isFeatureRemove(eFalloutFeature))

	test	eax, eax
	je	SHORT $LN3@GetFallout
	push	edi
	mov	ecx, eax
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	test	al, al
	jne	SHORT $LN14@GetFallout
$LN3@GetFallout:

; 3156 : 	}
; 3157 : 
; 3158 : #ifdef AUI_WARNING_FIXES
; 3159 : 	for (uint iBuild = 0; iBuild < GC.getNumBuildInfos(); iBuild++)
; 3160 : #else
; 3161 : 	for(int iBuild = 0; iBuild < GC.getNumBuildInfos(); iBuild++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	esi, eax
	jl	SHORT $LL4@GetFallout
$LN2@GetFallout:
	pop	esi

; 3169 : 		}
; 3170 : 	}
; 3171 : 
; 3172 : 	return NO_BUILD;

	or	eax, -1
	pop	edi

; 3173 : }

	ret	0
$LN14@GetFallout:

; 3167 : 		{
; 3168 : 			return eBuild;

	mov	eax, esi
	pop	esi
	pop	edi

; 3173 : }

	ret	0
?GetFalloutRemove@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@XZ ENDP ; CvBuilderTaskingAI::GetFalloutRemove
_TEXT	ENDS
PUBLIC	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	?GetBuilderAILogging@CvGlobals@@QAE_NXZ:PROC	; CvGlobals::GetBuilderAILogging
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z
_TEXT	SEGMENT
_strLog$ = -124						; size = 28
_strPlayerName$ = -96					; size = 28
_strTemp$ = -68						; size = 28
_strFileName$ = -40					; size = 28
__$EHRec$ = -12						; size = 12
_strNewLogStr$ = 8					; size = 28
_pPlayer$ = 36						; size = 4
___formal$ = 40						; size = 1
?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z PROC ; CvBuilderTaskingAI::LogInfo, COMDAT

; 3181 : {

	push	-1
	push	__ehhandler$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 112				; 00000070H

; 3182 : 	if(!(GC.getLogging() && GC.getAILogging() && GC.GetBuilderAILogging()))

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+132], 0
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@LogInfo
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@LogInfo
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuilderAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::GetBuilderAILogging
	test	al, al
	je	$LN1@LogInfo
	push	esi

; 3185 : 	}
; 3186 : 
; 3187 : 	// Open the log file
; 3188 : 	CvString strFileName = "BuilderTaskingLog.csv";

	push	OFFSET $SG219135
	lea	ecx, DWORD PTR _strFileName$[esp+132]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[esp+136], 1

; 3189 : 	FILogFile* pLog;
; 3190 : 	pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strFileName$[esp+128]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax

; 3191 : 
; 3192 : 	CvString strLog, strTemp;

	lea	ecx, DWORD PTR _strLog$[esp+128]
	mov	esi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$[esp+128]
	mov	BYTE PTR __$EHRec$[esp+136], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3193 : 
; 3194 : 	CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$[esp+128]
	mov	BYTE PTR __$EHRec$[esp+136], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3195 : 	strPlayerName = pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR _pPlayer$[esp+124]
	mov	BYTE PTR __$EHRec$[esp+136], 4
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strPlayerName$[esp+128]
	test	eax, eax
	je	SHORT $LN30@LogInfo
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN29@LogInfo
$LN30@LogInfo:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN29@LogInfo:

; 3196 : 	strLog += strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$[esp+128]
	push	ecx
	lea	ecx, DWORD PTR _strLog$[esp+132]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3197 : 	strLog += ",";

	push	OFFSET $SG219140
	lea	ecx, DWORD PTR _strLog$[esp+132]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3198 : 
; 3199 : 	strTemp.Format("%d,", GC.getGame().getGameTurn()); // turn

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	lea	edx, DWORD PTR _strTemp$[esp+132]
	push	OFFSET $SG219141
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 3200 : 	strLog += strTemp;

	lea	eax, DWORD PTR _strTemp$[esp+128]
	push	eax
	lea	ecx, DWORD PTR _strLog$[esp+132]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3201 : 	strLog += strNewLogStr;

	lea	ecx, DWORD PTR _strNewLogStr$[esp+124]
	push	ecx
	lea	ecx, DWORD PTR _strLog$[esp+132]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3202 : 	pLog->Msg(strLog);

	lea	ecx, DWORD PTR _strLog$[esp+128]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	esi
	call	eax
	add	esp, 8

; 3203 : }

	lea	ecx, DWORD PTR _strPlayerName$[esp+128]
	mov	BYTE PTR __$EHRec$[esp+136], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$[esp+128]
	mov	BYTE PTR __$EHRec$[esp+136], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLog$[esp+128]
	mov	BYTE PTR __$EHRec$[esp+136], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strFileName$[esp+128]
	mov	BYTE PTR __$EHRec$[esp+136], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strNewLogStr$[esp+124]
	mov	DWORD PTR __$EHRec$[esp+136], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	mov	ecx, DWORD PTR __$EHRec$[esp+124]
	mov	DWORD PTR fs:0, ecx
	add	esp, 124				; 0000007cH
	ret	0
$LN1@LogInfo:

; 3183 : 	{
; 3184 : 		return;

	lea	ecx, DWORD PTR _strNewLogStr$[esp+120]
	mov	DWORD PTR __$EHRec$[esp+132], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3203 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+124]
	mov	DWORD PTR fs:0, ecx
	add	esp, 124				; 0000007cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z$0:
	lea	ecx, DWORD PTR _strNewLogStr$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z$1:
	lea	ecx, DWORD PTR _strFileName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z$2:
	lea	ecx, DWORD PTR _strLog$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z$3:
	lea	ecx, DWORD PTR _strTemp$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z$4:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ENDP ; CvBuilderTaskingAI::LogInfo
PUBLIC	?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z ; CvBuilderTaskingAI::LogYieldInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_strLog$ = -124						; size = 28
_strPlayerName$ = -96					; size = 28
_strTemp$ = -68						; size = 28
_strFileName$ = -40					; size = 28
__$EHRec$ = -12						; size = 12
_strNewLogStr$ = 8					; size = 28
_pPlayer$ = 36						; size = 4
?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z PROC ; CvBuilderTaskingAI::LogYieldInfo, COMDAT

; 3210 : {

	push	-1
	push	__ehhandler$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 112				; 00000070H

; 3211 : 	if(!(GC.getLogging() && GC.getAILogging() && GC.GetBuilderAILogging()))

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+132], 0
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@LogYieldIn
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@LogYieldIn
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuilderAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::GetBuilderAILogging
	test	al, al
	je	$LN1@LogYieldIn
	push	esi

; 3214 : 	}
; 3215 : 
; 3216 : 	// Open the log file
; 3217 : 	CvString strFileName = "BuilderTaskingYieldLog.csv";

	push	OFFSET $SG219149
	lea	ecx, DWORD PTR _strFileName$[esp+132]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[esp+136], 1

; 3218 : 	FILogFile* pLog;
; 3219 : 	pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strFileName$[esp+128]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax

; 3220 : 
; 3221 : 	CvString strLog, strTemp;

	lea	ecx, DWORD PTR _strLog$[esp+128]
	mov	esi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$[esp+128]
	mov	BYTE PTR __$EHRec$[esp+136], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3222 : 
; 3223 : 	CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$[esp+128]
	mov	BYTE PTR __$EHRec$[esp+136], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3224 : 	strPlayerName = pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR _pPlayer$[esp+124]
	mov	BYTE PTR __$EHRec$[esp+136], 4
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strPlayerName$[esp+128]
	test	eax, eax
	je	SHORT $LN30@LogYieldIn
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN29@LogYieldIn
$LN30@LogYieldIn:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN29@LogYieldIn:

; 3225 : 	strLog += strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$[esp+128]
	push	ecx
	lea	ecx, DWORD PTR _strLog$[esp+132]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3226 : 	strLog += ",";

	push	OFFSET $SG219154
	lea	ecx, DWORD PTR _strLog$[esp+132]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3227 : 
; 3228 : 	strTemp.Format("%d,", GC.getGame().getGameTurn()); // turn

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	lea	edx, DWORD PTR _strTemp$[esp+132]
	push	OFFSET $SG219155
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 3229 : 	strLog += strTemp;

	lea	eax, DWORD PTR _strTemp$[esp+128]
	push	eax
	lea	ecx, DWORD PTR _strLog$[esp+132]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3230 : 	strLog += strNewLogStr;

	lea	ecx, DWORD PTR _strNewLogStr$[esp+124]
	push	ecx
	lea	ecx, DWORD PTR _strLog$[esp+132]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3231 : 	pLog->Msg(strLog);

	lea	ecx, DWORD PTR _strLog$[esp+128]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	esi
	call	eax
	add	esp, 8

; 3232 : }

	lea	ecx, DWORD PTR _strPlayerName$[esp+128]
	mov	BYTE PTR __$EHRec$[esp+136], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$[esp+128]
	mov	BYTE PTR __$EHRec$[esp+136], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLog$[esp+128]
	mov	BYTE PTR __$EHRec$[esp+136], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strFileName$[esp+128]
	mov	BYTE PTR __$EHRec$[esp+136], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strNewLogStr$[esp+124]
	mov	DWORD PTR __$EHRec$[esp+136], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	mov	ecx, DWORD PTR __$EHRec$[esp+124]
	mov	DWORD PTR fs:0, ecx
	add	esp, 124				; 0000007cH
	ret	0
$LN1@LogYieldIn:

; 3212 : 	{
; 3213 : 		return;

	lea	ecx, DWORD PTR _strNewLogStr$[esp+120]
	mov	DWORD PTR __$EHRec$[esp+132], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3232 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+124]
	mov	DWORD PTR fs:0, ecx
	add	esp, 124				; 0000007cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z$0:
	lea	ecx, DWORD PTR _strNewLogStr$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z$1:
	lea	ecx, DWORD PTR _strFileName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z$2:
	lea	ecx, DWORD PTR _strLog$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z$3:
	lea	ecx, DWORD PTR _strTemp$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z$4:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z ENDP ; CvBuilderTaskingAI::LogYieldInfo
PUBLIC	?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z ; CvBuilderTaskingAI::LogFlavors
EXTRN	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z:PROC ; CvFlavorManager::GetPersonalityIndividualFlavor
EXTRN	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ:PROC ; CvPlayer::GetFlavorManager
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z$1
__ehfuncinfo$?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z
_TEXT	SEGMENT
_strLog$ = -68						; size = 28
_strTemp$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
$T222009 = 8						; size = 4
$T222008 = 8						; size = 4
_eFlavor$ = 8						; size = 4
?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z PROC ; CvBuilderTaskingAI::LogFlavors, COMDAT
; _this$ = ecx

; 3236 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 56					; 00000038H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 3237 : 	if(!m_bLogging)

	cmp	BYTE PTR [edi+58392], 0
	je	$LN7@LogFlavors

; 3238 : 	{
; 3239 : 		return;
; 3240 : 	}
; 3241 : 
; 3242 : 	// Open the log file
; 3243 : 	CvString strLog;

	lea	ecx, DWORD PTR _strLog$[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	ebp, ebp

; 3244 : 	CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], ebp
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3245 : 
; 3246 : 	// Dump out the setting for each flavor
; 3247 : 	if(eFlavor == NO_FLAVOR)

	mov	esi, DWORD PTR _eFlavor$[esp+80]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	cmp	esi, -1
	jne	$LN5@LogFlavors

; 3248 : 	{
; 3249 : 		for(int iI = 0; iI < GC.getNumFlavorTypes(); iI++)

	xor	esi, esi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, ebp
	jle	$LN1@LogFlavors
$LL4@LogFlavors:

; 3250 : 		{
; 3251 : 			strLog.clear();

	lea	ecx, DWORD PTR _strLog$[esp+84]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 3252 : 			strTemp.Format("Flavor, %s, %d,", GC.getFlavorTypes((FlavorTypes)iI).GetCString(), m_pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor((FlavorTypes)iI));

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	lea	ecx, DWORD PTR [eax+ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi]
	push	esi
	mov	ebx, eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	push	eax
	push	ebx
	lea	ecx, DWORD PTR _strTemp$[esp+92]
	push	OFFSET $SG219170
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3253 : 			strLog += strTemp;

	lea	edx, DWORD PTR _strTemp$[esp+84]
	push	edx
	lea	ecx, DWORD PTR _strLog$[esp+88]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3254 : 			LogInfo(strLog, m_pPlayer);

	mov	eax, DWORD PTR [edi]
	push	0
	push	eax
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strLog$[esp+120]
	mov	DWORD PTR $T222008[esp+116], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	inc	esi
	add	esp, 36					; 00000024H
	add	ebp, 28					; 0000001cH
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL4@LogFlavors

; 3255 : 		}
; 3256 : 	}
; 3257 : 	else

	jmp	SHORT $LN1@LogFlavors
$LN5@LogFlavors:

; 3258 : 	{
; 3259 : 		strLog.clear();

	lea	ecx, DWORD PTR _strLog$[esp+84]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 3260 : 		strTemp.Format("Flavor, %s, %d,", GC.getFlavorTypes(eFlavor).GetCString(), m_pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavor));

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	lea	ecx, DWORD PTR [ecx+eax*4]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi]
	push	esi
	mov	ebx, eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	push	eax
	push	ebx
	lea	edx, DWORD PTR _strTemp$[esp+92]
	push	OFFSET $SG219173
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3261 : 		strLog += strTemp;

	lea	eax, DWORD PTR _strTemp$[esp+84]
	push	eax
	lea	ecx, DWORD PTR _strLog$[esp+88]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3262 : 		LogInfo(strLog, m_pPlayer);

	mov	ecx, DWORD PTR [edi]
	push	ebp
	push	ecx
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strLog$[esp+120]
	mov	DWORD PTR $T222009[esp+116], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H
$LN1@LogFlavors:

; 3263 : 	}
; 3264 : }

	lea	ecx, DWORD PTR _strTemp$[esp+84]
	mov	BYTE PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLog$[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@LogFlavors:
	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 68					; 00000044H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z$0:
	lea	ecx, DWORD PTR _strLog$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z$1:
	lea	ecx, DWORD PTR _strTemp$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z ENDP ; CvBuilderTaskingAI::LogFlavors
PUBLIC	?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z ; CvBuilderTaskingAI::UpdateCurrentPlotYields
EXTRN	?toString@FSerialization@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABW4YieldTypes@@@Z:PROC ; FSerialization::toString
EXTRN	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z:PROC	; CvPlot::getYield
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z$1
__ehfuncinfo$?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
$T222072 = -72						; size = 4
_strLog$219258 = -68					; size = 28
$T222071 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_yield$219259 = 8					; size = 4
_pPlot$ = 8						; size = 4
?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z PROC ; CvBuilderTaskingAI::UpdateCurrentPlotYields, COMDAT
; _this$ = ecx

; 3411 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3412 : 	m_pTargetPlot = pPlot;

	mov	edi, DWORD PTR _pPlot$[esp+84]
	mov	ebx, ecx
	mov	DWORD PTR [ebx+58400], edi

; 3413 : 	for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	xor	esi, esi
	lea	ebp, DWORD PTR [ebx+58404]
$LL4@UpdateCurr:

; 3414 : 	{
; 3415 : 		m_aiCurrentPlotYields[ui] = pPlot->getYield((YieldTypes)ui);

	push	esi
	mov	ecx, edi
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	mov	DWORD PTR [ebp], eax

; 3416 : 
; 3417 : 		if(m_bLogging){

	cmp	BYTE PTR [ebx+58392], 0
	je	$LN3@UpdateCurr

; 3418 : 			CvString strLog;

	lea	ecx, DWORD PTR _strLog$219258[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3419 : 			YieldTypes yield = (YieldTypes) ui;
; 3420 : 			strLog.Format("Plot Yield Update, %s, %i, %i, %i", FSerialization::toString(yield).c_str(), m_aiCurrentPlotYields[ui], pPlot->getX(), pPlot->getY());

	lea	eax, DWORD PTR _yield$219259[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T222071[esp+92]
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+104], 0
	mov	DWORD PTR _yield$219259[esp+92], esi
	call	?toString@FSerialization@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABW4YieldTypes@@@Z ; FSerialization::toString
	add	esp, 8
	movsx	ecx, WORD PTR [edi+2]
	movsx	edx, WORD PTR [edi]
	push	ecx
	push	edx
	mov	edx, DWORD PTR [ebp]
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+108], 1
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLog$219258[esp+104]
	push	OFFSET $SG219266
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H
	lea	ecx, DWORD PTR $T222071[esp+88]
	mov	BYTE PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3421 : 			LogYieldInfo(strLog, m_pPlayer);

	mov	ecx, DWORD PTR [ebx]
	push	ecx
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strLog$219258[esp+120]
	mov	DWORD PTR $T222072[esp+120], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z ; CvBuilderTaskingAI::LogYieldInfo
	add	esp, 32					; 00000020H

; 3422 : 		}

	lea	ecx, DWORD PTR _strLog$219258[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@UpdateCurr:
	inc	esi
	add	ebp, 4
	cmp	esi, 6
	jb	$LL4@UpdateCurr

; 3423 : 	}
; 3424 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 72					; 00000048H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _strLog$219258[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z$1:
	lea	ecx, DWORD PTR $T222071[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z ENDP ; CvBuilderTaskingAI::UpdateCurrentPlotYields
PUBLIC	?clear@?$BaseVector@H$00@@QAEXXZ		; BaseVector<int,1>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?clear@?$BaseVector@H$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@H$00@@QAEXXZ PROC			; BaseVector<int,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@H$00@@QAEXXZ ENDP			; BaseVector<int,1>::clear
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 147  : 		if(m_target) 

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	jmp	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@FObjectHan:

; 150  : 		}
; 151  : 	}

	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z PROC	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 156  : 	{

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx
	mov	BYTE PTR [esi+4], 0

; 157  : 		OBJECT_HANDLE_STACK;
; 158  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@2

; 159  : 		{
; 160  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@2:

; 161  : 		}
; 162  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ENDP	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,14592,1,297,0>::FStaticVector<int,14592,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ PROC	; FStaticVector<int,14592,1,297,0>::FStaticVector<int,14592,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 14592		; 00003900H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ ENDP	; FStaticVector<int,14592,1,297,0>::FStaticVector<int,14592,1,297,0>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,14592,1,297,0>::~FStaticVector<int,14592,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ PROC	; FStaticVector<int,14592,1,297,0>::~FStaticVector<int,14592,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ ENDP	; FStaticVector<int,14592,1,297,0>::~FStaticVector<int,14592,1,297,0>
_TEXT	ENDS
PUBLIC	??4?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<int,14592,1,297,0>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAEXABV0@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
??4?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAEXABV0@@Z PROC ; FStaticVector<int,14592,1,297,0>::operator=, COMDAT
; _this$ = ecx

; 620  : 	void operator = (const THIS_TYPE& RHS){

	push	ebp

; 621  : 		if( m_uiCurrMaxSize <= RHS.m_uiCurrSize){

	mov	ebp, DWORD PTR _RHS$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	cmp	eax, DWORD PTR [ebp+4]
	ja	SHORT $LN2@operator@2

; 622  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	push	ebx
	lea	ebx, DWORD PTR [esi+12]
	push	edi
	cmp	eax, ebx
	je	SHORT $LN5@operator@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN5@operator@2:

; 623  : 			m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	edi, DWORD PTR [ebp+8]
	cmp	edi, 14592				; 00003900H
	jbe	SHORT $LN16@operator@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	ecx, DWORD PTR [edi*4]
	push	4
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN15@operator@2
$LN16@operator@2:
	mov	eax, ebx
	mov	DWORD PTR [esi+8], 14592		; 00003900H
$LN15@operator@2:
	pop	edi
	mov	DWORD PTR [esi], eax
	pop	ebx
$LN2@operator@2:

; 624  : 		}else{
; 625  : 			Destroy(m_pData, m_uiCurrSize);
; 626  : 		}
; 627  : 		Copy(RHS);

	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [esi+4], edx
	mov	eax, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [esi]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebp

; 628  : 	};

	ret	4
??4?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAEXABV0@@Z ENDP ; FStaticVector<int,14592,1,297,0>::operator=
_TEXT	ENDS
PUBLIC	?GetElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QBEABUBuilderDirective@@I@Z ; CvWeightedVector<BuilderDirective,100,1>::GetElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?GetElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QBEABUBuilderDirective@@I@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QBEABUBuilderDirective@@I@Z PROC ; CvWeightedVector<BuilderDirective,100,1>::GetElement, COMDAT
; _this$ = ecx

; 64   : 		assert(iIndex < m_pItems.size());
; 65   : 		return m_pItems[iIndex].m_Element;

	mov	eax, DWORD PTR _iIndex$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*8]

; 66   : 	};

	ret	4
?GetElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QBEABUBuilderDirective@@I@Z ENDP ; CvWeightedVector<BuilderDirective,100,1>::GetElement
_TEXT	ENDS
PUBLIC	?size@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEHXZ ; CvWeightedVector<BuilderDirective,100,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEHXZ
_TEXT	SEGMENT
?size@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEHXZ PROC ; CvWeightedVector<BuilderDirective,100,1>::size, COMDAT
; _this$ = ecx

; 134  : 		return m_pItems.size();

	mov	eax, DWORD PTR [ecx+4]

; 135  : 	};

	ret	0
?size@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEHXZ ENDP ; CvWeightedVector<BuilderDirective,100,1>::size
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ	; FStaticVector<int,64,1,297,0>::FStaticVector<int,64,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ PROC	; FStaticVector<int,64,1,297,0>::FStaticVector<int,64,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ ENDP	; FStaticVector<int,64,1,297,0>::FStaticVector<int,64,1,297,0>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ	; FStaticVector<int,64,1,297,0>::~FStaticVector<int,64,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ PROC	; FStaticVector<int,64,1,297,0>::~FStaticVector<int,64,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@2:

; 619  : 	};

	ret	0
??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ ENDP	; FStaticVector<int,64,1,297,0>::~FStaticVector<int,64,1,297,0>
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,14592,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<int,14592,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN31@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 14592				; 00003900H
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize
$LN15@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 14592		; 00003900H
$LN14@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+58380], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<int,14592,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 100			; 00000064H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAEXXZ ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAEXXZ PROC ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAEXXZ ENDP ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::clear
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@XZ ; CvWeightedVector<BuilderDirective,100,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@XZ
_TEXT	SEGMENT
??0WeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@XZ PROC ; CvWeightedVector<BuilderDirective,100,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	mov	eax, ecx
	or	ecx, -1
	mov	edx, ecx
	mov	DWORD PTR [eax], 6
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	WORD PTR [eax+12], dx
	mov	WORD PTR [eax+14], dx
	mov	WORD PTR [eax+16], cx
	mov	DWORD PTR [eax+20], 0

; 32   : 		}

	ret	0
??0WeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@XZ ENDP ; CvWeightedVector<BuilderDirective,100,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,64,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<int,64,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@2
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@2
	npad	6
$LL8@GrowSize@2:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize@2

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@2

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@2
$LN31@GrowSize@2:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@2:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 64					; 00000040H
	jbe	SHORT $LN15@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize@2
$LN15@GrowSize@2:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 64			; 00000040H
$LN14@GrowSize@2:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize@2:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+268], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<int,64,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@I@Z ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@3

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@3:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::Free
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@XZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::~_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@XZ PROC ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::~_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT
; _this$ = ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN9@Temp_itera

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;
; 549  : 				_Next != _Buf._Hiwater; ++_Next)
; 550  : 				_Destroy(&*_Next);
; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN9@Temp_itera:

; 552  : 			}
; 553  : 		}

	ret	0
??1?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@XZ ENDP ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::~_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Distance@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0AAH@Z ; std::_Distance<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0AAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0AAH@Z PROC ; std::_Distance<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>, COMDAT

; 1893 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	DWORD PTR [eax], ecx

; 1894 : 	}

	ret	0
??$_Distance@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0AAH@Z ENDP ; std::_Distance<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$advance@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@std@@YAXAAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@Z ; std::advance<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$advance@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@std@@YAXAAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@std@@YAXAAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@Z PROC ; std::advance<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@std@@YAXAAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@Z ENDP ; std::advance<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$get_temporary_buffer@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@0@H@Z ; std::get_temporary_buffer<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$get_temporary_buffer@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@0@H@Z
_TEXT	SEGMENT
$T222451 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T222456 = 12						; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@0@H@Z PROC ; std::get_temporary_buffer<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	sub	esp, 12					; 0000000cH
	push	esi

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	mov	esi, DWORD PTR __Count$[esp+12]
	test	esi, esi
	jg	SHORT $LN7@get_tempor

; 23   : 		_Count = 0;

	xor	esi, esi
$LN5@get_tempor:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN15@get_tempor
$LL4@get_tempor:

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	lea	edx, DWORD PTR [esi+esi*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	ecx, eax
	add	esp, 8
	test	ecx, ecx
	jne	SHORT $LN15@get_tempor
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	test	esi, esi
	jg	SHORT $LL4@get_tempor
$LN15@get_tempor:

; 30   : 			break;
; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 33   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN7@get_tempor:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	esi
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN5@get_tempor

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T222456[esp+12]
	push	eax
	lea	ecx, DWORD PTR $T222451[esp+20]
	mov	DWORD PTR $T222456[esp+16], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T222451[esp+20]
	push	ecx
	mov	DWORD PTR $T222451[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN18@get_tempor:
$LN17@get_tempor:
	int	3
??$get_temporary_buffer@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@0@H@Z ENDP ; std::get_temporary_buffer<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@ABV01@@Z ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@ABV01@@Z PROC ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT
; _this$ = ecx

; 535  : 	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)

	mov	eax, ecx

; 536  : 		{	// construct from _Right (share active buffer)
; 537  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 538  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 539  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 540  : 		_Buf._Size = 0;

	mov	DWORD PTR [eax+12], ecx

; 541  : 		*this = _Right;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 542  : 		}

	ret	4
??0?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@ABV01@@Z ENDP ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z ; std::iter_swap<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z PROC ; std::iter_swap<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	jmp	??$swap@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z ; std::swap<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z ENDP ; std::iter_swap<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00@Z ; stdext::unchecked_copy_backward<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00@Z
_TEXT	SEGMENT
$T222482 = -4						; size = 1
__Cat$222488 = -4					; size = 1
$T222484 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00@Z PROC ; stdext::unchecked_copy_backward<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	BYTE PTR $T222482[esp+4], 0
	mov	eax, DWORD PTR $T222482[esp+4]
	mov	ecx, DWORD PTR __Cat$222488[esp+4]
	mov	edx, DWORD PTR $T222484[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>

; 3639 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00@Z ENDP ; stdext::unchecked_copy_backward<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Merge_backward@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge_backward@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T222535 = 8						; size = 1
__Cat$222540 = 8					; size = 1
$T222537 = 8						; size = 1
$T222510 = 8						; size = 1
__Cat$222515 = 8					; size = 1
$T222512 = 8						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Merge_backward@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>, COMDAT

; 2711 : 	for (; ; )
; 2712 : 		if (_First1 == _Last1)

	mov	ecx, DWORD PTR __Last1$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	edx, DWORD PTR __Last2$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __First1$[esp+4]
	push	edi
	mov	edi, DWORD PTR __First2$[esp+8]
	cmp	esi, ecx
	je	SHORT $LN27@Merge_back
	npad	5
$LL8@Merge_back:

; 2714 : 		else if (_First2 == _Last2)

	cmp	edi, edx
	je	$LN28@Merge_back

; 2716 : 		else if (_DEBUG_LT(*--_Last2, *--_Last1))

	mov	ebx, DWORD PTR [edx-4]
	sub	edx, 24					; 00000018H
	sub	ecx, 24					; 00000018H

; 2717 : 			*--_Dest = *_Last1, ++_Last2;

	sub	eax, 24					; 00000018H
	cmp	ebx, DWORD PTR [ecx+20]
	jle	SHORT $LN2@Merge_back
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebx
	mov	ebx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ebx
	mov	ebx, DWORD PTR [ecx+20]
	add	edx, 24					; 00000018H

; 2718 : 		else

	jmp	SHORT $LN30@Merge_back
$LN2@Merge_back:

; 2719 : 			*--_Dest = *_Last2, ++_Last1;

	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ebx
	mov	ebx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], ebx
	mov	ebx, DWORD PTR [edx+20]
	add	ecx, 24					; 00000018H
$LN30@Merge_back:
	mov	DWORD PTR [eax+20], ebx
	cmp	esi, ecx
	jne	SHORT $LL8@Merge_back
$LN27@Merge_back:

; 2713 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	BYTE PTR $T222510[esp+8], 0
	mov	ecx, DWORD PTR $T222510[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Cat$222515[esp+12]
	push	ecx
	mov	ecx, DWORD PTR $T222512[esp+16]
	push	ecx
	push	eax
	push	edx
	push	edi

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	call	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebx

; 2720 : 	}

	ret	0
$LN28@Merge_back:

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	BYTE PTR $T222535[esp+8], 0
	mov	edx, DWORD PTR $T222535[esp+8]
	push	edx
	mov	edx, DWORD PTR __Cat$222540[esp+12]
	push	edx
	mov	edx, DWORD PTR $T222537[esp+16]
	push	edx
	push	eax
	push	ecx
	push	esi
	call	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebx

; 2720 : 	}

	ret	0
??$_Merge_backward@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Lower_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z ; std::_Lower_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Lower_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Lower_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z PROC ; std::_Lower_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement,int>, COMDAT

; 2253 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2254 : 	_Diff _Count = 0;
; 2255 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN22@Lower_boun
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+20]
$LL4@Lower_boun:

; 2258 : 		{	// divide and conquer, find half that contains answer
; 2259 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2260 : 		_FwdIt _Mid = _First;
; 2261 : 		std::advance(_Mid, _Count2);

	lea	edx, DWORD PTR [eax+eax*2]

; 2262 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2263 : 
; 2264 : 		if (_DEBUG_LT(*_Mid, _Val))

	cmp	DWORD PTR [esi+edx*8+20], edi
	lea	edx, DWORD PTR [esi+edx*8]
	jle	SHORT $LN2@Lower_boun

; 2265 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	lea	esi, DWORD PTR [edx+24]
	or	edx, -1
	sub	edx, eax
	add	ecx, edx

; 2266 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2267 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Lower_boun:

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Lower_boun
	pop	edi
$LN22@Lower_boun:

; 2268 : 		}
; 2269 : 	return (_First);

	mov	eax, esi
	pop	esi

; 2270 : 	}

	ret	0
??$_Lower_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z ENDP ; std::_Lower_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement,int>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z ; std::_Upper_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Upper_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Upper_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z PROC ; std::_Upper_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement,int>, COMDAT

; 2325 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2326 : 	_Diff _Count = 0;
; 2327 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 2328 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN22@Upper_boun
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+20]
$LL4@Upper_boun:

; 2329 : 		{	// divide and conquer, find half that contains answer
; 2330 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2331 : 		_FwdIt _Mid = _First;
; 2332 : 		std::advance(_Mid, _Count2);

	lea	edx, DWORD PTR [eax+eax*2]

; 2333 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2334 : 
; 2335 : 		if (!_DEBUG_LT(_Val, *_Mid))

	cmp	edi, DWORD PTR [esi+edx*8+20]
	lea	edx, DWORD PTR [esi+edx*8]
	jg	SHORT $LN2@Upper_boun

; 2336 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	lea	esi, DWORD PTR [edx+24]
	or	edx, -1
	sub	edx, eax
	add	ecx, edx

; 2337 : 		else

	jmp	SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2338 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Upper_boun:

; 2328 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Upper_boun
	pop	edi
$LN22@Upper_boun:

; 2339 : 		}
; 2340 : 	return (_First);

	mov	eax, esi
	pop	esi

; 2341 : 	}

	ret	0
??$_Upper_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z ENDP ; std::_Upper_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement,int>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00@Z ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00@Z
_TEXT	SEGMENT
$T222645 = -4						; size = 1
__Cat$222650 = -4					; size = 1
$T222647 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00@Z PROC ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	BYTE PTR $T222645[esp+4], 0
	mov	eax, DWORD PTR $T222645[esp+4]
	mov	ecx, DWORD PTR __Cat$222650[esp+4]
	mov	edx, DWORD PTR $T222647[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>

; 3607 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00@Z ENDP ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@ABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@ABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??4?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@ABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z PROC ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	mov	eax, ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN2@operator@3

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [edx], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], esi
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], ecx
	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 24			; 00000018H
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
$LN2@operator@3:

; 565  : 		else
; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;
; 569  : 			_Construct(_Ptr, _Val);

	mov	edx, ecx
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN7@operator@3
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], esi
	mov	esi, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], esi
	mov	esi, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], esi
	mov	edx, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], edx
$LN7@operator@3:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 24			; 00000018H
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+8], edx
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
??4?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@ABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ENDP ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator=
_TEXT	ENDS
PUBLIC	??$_Rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>, COMDAT

; 1713 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __Mid$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00PAH0@Z ; std::_Rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 1714 : 	}

	ret	0
??$_Rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?GetID@CvUnit@@QBEHXZ				; CvUnit::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?GetID@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvUnit@@QBEHXZ PROC				; CvUnit::GetID, COMDAT
; _this$ = ecx

; 662  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+100]

; 663  : 	}

	ret	0
?GetID@CvUnit@@QBEHXZ ENDP				; CvUnit::GetID
_TEXT	ENDS
PUBLIC	?getX@CvUnit@@QBEHXZ				; CvUnit::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getX@CvUnit@@QBEHXZ PROC				; CvUnit::getX, COMDAT
; _this$ = ecx

; 673  : 		return m_iX.get();

	mov	eax, DWORD PTR [ecx+76]

; 674  : 	}

	ret	0
?getX@CvUnit@@QBEHXZ ENDP				; CvUnit::getX
_TEXT	ENDS
PUBLIC	?getY@CvUnit@@QBEHXZ				; CvUnit::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getY@CvUnit@@QBEHXZ PROC				; CvUnit::getY, COMDAT
; _this$ = ecx

; 678  : 		return m_iY.get();

	mov	eax, DWORD PTR [ecx+88]

; 679  : 	}

	ret	0
?getY@CvUnit@@QBEHXZ ENDP				; CvUnit::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ	; CvUnit::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ PROC		; CvUnit::getOwner, COMDAT
; _this$ = ecx

; 1046 : 		return m_eOwner.get();

	mov	eax, DWORD PTR [ecx+40]

; 1047 : 	}

	ret	0
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ENDP		; CvUnit::getOwner
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ	; CvCity::getOwner
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ PROC		; CvCity::getOwner, COMDAT
; _this$ = ecx

; 604  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+84]

; 605  : 	}

	ret	0
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ENDP		; CvCity::getOwner
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1172 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1173 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1182 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1183 : 	}

	ret	0

; 1182 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1183 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ	; CvPlot::getFeatureType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ
_TEXT	SEGMENT
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ PROC	; CvPlot::getFeatureType, COMDAT
; _this$ = ecx

; 435  : #ifdef AUI_WARNING_FIXES
; 436  : 		int f = m_eFeatureType;
; 437  : #else
; 438  : 		char f = m_eFeatureType;
; 439  : #endif
; 440  : 		return (FeatureTypes)f;

	movsx	eax, BYTE PTR [ecx+432]

; 441  : 	}

	ret	0
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ ENDP	; CvPlot::getFeatureType
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z	; CvMap::plotCheckInvalid
; Function compile flags: /Ogtpy
;	COMDAT ?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z PROC	; CvMap::plotCheckInvalid, COMDAT
; _this$ = ecx

; 282  : 	{

	push	esi

; 283  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	esi, DWORD PTR _iX$[esp]
	cmp	esi, -2147483647			; 80000001H
	je	SHORT $LN1@plotCheckI
	mov	edx, DWORD PTR _iY$[esp]
	cmp	edx, -2147483647			; 80000001H
	je	SHORT $LN1@plotCheckI

; 286  : 		}
; 287  : 		return &(m_pMapPlots[plotNum(iX, iY)]);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, edx
	add	eax, esi
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	pop	esi

; 288  : 	}

	ret	8
$LN1@plotCheckI:

; 284  : 		{
; 285  : 			return NULL;

	xor	eax, eax
	pop	esi

; 288  : 	}

	ret	8
?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z ENDP	; CvMap::plotCheckInvalid
_TEXT	ENDS
PUBLIC	??0CvBuilderTaskingAI@@QAE@XZ			; CvBuilderTaskingAI::CvBuilderTaskingAI
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
;	COMDAT ??0CvBuilderTaskingAI@@QAE@XZ
_TEXT	SEGMENT
??0CvBuilderTaskingAI@@QAE@XZ PROC			; CvBuilderTaskingAI::CvBuilderTaskingAI, COMDAT
; _this$ = ecx

; 31   : {

	mov	eax, ecx
	xor	edx, edx
	lea	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], 14592		; 00003900H

; 32   : 	Uninit();

	or	ecx, -1
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax], edx
	mov	BYTE PTR [eax+58392], dl
	mov	DWORD PTR [eax+58396], ecx
	mov	DWORD PTR [eax+58400], edx

; 33   : }

	ret	0
??0CvBuilderTaskingAI@@QAE@XZ ENDP			; CvBuilderTaskingAI::CvBuilderTaskingAI
_TEXT	ENDS
PUBLIC	??1CvBuilderTaskingAI@@QAE@XZ			; CvBuilderTaskingAI::~CvBuilderTaskingAI
; Function compile flags: /Ogtpy
;	COMDAT ??1CvBuilderTaskingAI@@QAE@XZ
_TEXT	SEGMENT
??1CvBuilderTaskingAI@@QAE@XZ PROC			; CvBuilderTaskingAI::~CvBuilderTaskingAI, COMDAT
; _this$ = ecx

; 38   : 	Uninit();

	xor	eax, eax
	or	edx, -1
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx], eax
	mov	BYTE PTR [ecx+58392], al
	mov	DWORD PTR [ecx+58396], edx
	mov	DWORD PTR [ecx+58400], eax

; 39   : }

	mov	eax, DWORD PTR [ecx+8]
	add	ecx, 20					; 00000014H
	cmp	eax, ecx
	je	SHORT $LN8@CvBuilderT
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN8@CvBuilderT:
	ret	0
??1CvBuilderTaskingAI@@QAE@XZ ENDP			; CvBuilderTaskingAI::~CvBuilderTaskingAI
_TEXT	ENDS
PUBLIC	?Init@CvBuilderTaskingAI@@QAEXPAVCvPlayer@@@Z	; CvBuilderTaskingAI::Init
EXTRN	?GetFeatureMakesValid@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::GetFeatureMakesValid
EXTRN	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvPlayer::getCivilizationType
EXTRN	?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvImprovementEntry::GetRequiredCivilization
EXTRN	?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsSpecificCivRequired
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvBuilderTaskingAI@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?Init@CvBuilderTaskingAI@@QAEXPAVCvPlayer@@@Z PROC	; CvBuilderTaskingAI::Init, COMDAT
; _this$ = ecx

; 44   : 	m_pPlayer = pPlayer;

	mov	eax, DWORD PTR _pPlayer$[esp-4]
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], eax

; 45   : 	m_eRepairBuild = GetRepairBuild();

	call	?GetRepairBuild@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@XZ ; CvBuilderTaskingAI::GetRepairBuild
	mov	DWORD PTR [esi+4], eax

; 46   : 	m_eFalloutFeature = GetFalloutFeature();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8404
	mov	DWORD PTR [esi+58452], ecx

; 47   : 	m_eFalloutRemove = GetFalloutRemove();

	mov	ecx, esi
	call	?GetFalloutRemove@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@XZ ; CvBuilderTaskingAI::GetFalloutRemove
	mov	DWORD PTR [esi+58456], eax

; 48   : 
; 49   : 	m_aiNonTerritoryPlots.clear();

	xor	ebx, ebx

; 50   : 	m_bLogging = GC.getLogging() && GC.getAILogging() && GC.GetBuilderAILogging();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+4, ebx
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN14@Init
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN14@Init
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuilderAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::GetBuilderAILogging
	test	al, al
	je	SHORT $LN14@Init
	lea	eax, DWORD PTR [ebx+1]
	jmp	SHORT $LN15@Init
$LN14@Init:
	xor	eax, eax
$LN15@Init:

; 51   : 	m_iNumCities = -1;
; 52   : 	m_pTargetPlot = NULL;
; 53   : 
; 54   : #ifndef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 55   : 	// special case code so the Dutch don't remove marshes
; 56   : 	m_bKeepMarshes = false;
; 57   : 	// special case code so Brazil doesn't remove jungle
; 58   : 	m_bKeepJungle = false;
; 59   : 
; 60   : #ifdef AUI_WARNING_FIXES
; 61   : 	for (uint i = 0; i < GC.getNumBuildInfos(); i++)
; 62   : #else
; 63   : 	for(int i = 0; i < GC.getNumBuildInfos(); i++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR [esi+58392], al
	mov	DWORD PTR [esi+58396], -1
	mov	DWORD PTR [esi+58400], ebx
	mov	BYTE PTR [esi+58460], bl
	mov	BYTE PTR [esi+58461], bl
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	$LN9@Init
	push	ebp
	push	edi
	npad	6
$LL31@Init:

; 64   : #endif
; 65   : 	{
; 66   : 		BuildTypes eBuild = (BuildTypes)i;
; 67   : 		CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 68   : 		if(!pkBuild)

	test	eax, eax
	je	SHORT $LN10@Init

; 69   : 		{
; 70   : 			continue;
; 71   : 		}
; 72   : 		
; 73   : 		ImprovementTypes eImprovement = (ImprovementTypes)pkBuild->getImprovement();

	mov	ecx, eax
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement

; 74   : 		if(eImprovement == NO_IMPROVEMENT)

	cmp	eax, -1
	je	SHORT $LN10@Init

; 75   : 		{
; 76   : 			continue;
; 77   : 		}
; 78   : 
; 79   : 		CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	edi, eax

; 80   : 		if(pkImprovementInfo == NULL)

	test	edi, edi
	je	SHORT $LN10@Init

; 81   : 		{
; 82   : 			continue;
; 83   : 		}
; 84   : 
; 85   : 		if(pkImprovementInfo->IsSpecificCivRequired())

	mov	ecx, edi
	call	?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsSpecificCivRequired
	test	al, al
	je	SHORT $LN10@Init

; 86   : 		{
; 87   : 			CivilizationTypes eCiv = pkImprovementInfo->GetRequiredCivilization();

	mov	ecx, edi
	call	?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ ; CvImprovementEntry::GetRequiredCivilization

; 88   : 			if(eCiv == pPlayer->getCivilizationType())

	mov	ecx, DWORD PTR _pPlayer$[esp+12]
	mov	ebp, eax
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	cmp	ebp, eax
	jne	SHORT $LN10@Init

; 89   : 			{
; 90   : 				if(pkImprovementInfo->GetFeatureMakesValid(FEATURE_MARSH))

	push	2
	mov	ecx, edi
	call	?GetFeatureMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::GetFeatureMakesValid
	test	al, al
	je	SHORT $LN3@Init

; 91   : 				{
; 92   : 					m_bKeepMarshes = true;

	mov	BYTE PTR [esi+58460], 1
	jmp	SHORT $LN10@Init
$LN3@Init:

; 93   : 				}
; 94   : 				else if (pkImprovementInfo->GetFeatureMakesValid(FEATURE_JUNGLE))

	push	1
	mov	ecx, edi
	call	?GetFeatureMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::GetFeatureMakesValid
	test	al, al
	je	SHORT $LN10@Init

; 95   : 				{
; 96   : 					m_bKeepJungle = true;

	mov	BYTE PTR [esi+58461], 1
$LN10@Init:

; 51   : 	m_iNumCities = -1;
; 52   : 	m_pTargetPlot = NULL;
; 53   : 
; 54   : #ifndef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 55   : 	// special case code so the Dutch don't remove marshes
; 56   : 	m_bKeepMarshes = false;
; 57   : 	// special case code so Brazil doesn't remove jungle
; 58   : 	m_bKeepJungle = false;
; 59   : 
; 60   : #ifdef AUI_WARNING_FIXES
; 61   : 	for (uint i = 0; i < GC.getNumBuildInfos(); i++)
; 62   : #else
; 63   : 	for(int i = 0; i < GC.getNumBuildInfos(); i++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	ebx, eax
	jl	$LL31@Init
	pop	edi
	pop	ebp
$LN9@Init:
	pop	esi
	pop	ebx

; 97   : 				}
; 98   : 			}
; 99   : 		}
; 100  : 	}
; 101  : #endif
; 102  : }

	ret	4
?Init@CvBuilderTaskingAI@@QAEXPAVCvPlayer@@@Z ENDP	; CvBuilderTaskingAI::Init
_TEXT	ENDS
PUBLIC	?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z ; CvBuilderTaskingAI::ShouldBuilderConsiderPlot
EXTRN	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z:PROC ; CvPlot::getNumFriendlyUnitsOfType
EXTRN	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z:PROC		; CvUnit::atPlot
EXTRN	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z:PROC	; CvPlayer::GetPlotDanger
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	?CanEverEmbark@CvUnit@@QBE_NXZ:PROC		; CvUnit::CanEverEmbark
EXTRN	?GetMissionAIPlot@CvUnit@@QAEPAVCvPlot@@XZ:PROC	; CvUnit::GetMissionAIPlot
EXTRN	?isAdjacentToArea@CvPlot@@QBE_NPBVCvArea@@@Z:PROC ; CvPlot::isAdjacentToArea
EXTRN	?area@CvPlot@@QBEPAVCvArea@@XZ:PROC		; CvPlot::area
EXTRN	?area@CvUnit@@QBEPAVCvArea@@XZ:PROC		; CvUnit::area
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$8
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z
_TEXT	SEGMENT
$T223059 = -72						; size = 4
_strLog$218902 = -68					; size = 28
_strLog$218896 = -68					; size = 28
_strLog$218886 = -68					; size = 28
_strLog$218864 = -68					; size = 28
_strLog$218907 = -40					; size = 28
__$EHRec$ = -12						; size = 12
$T223050 = 8						; size = 4
_pUnit$ = 8						; size = 4
$T223041 = 12						; size = 4
$T222972 = 12						; size = 4
$T222968 = 12						; size = 4
_pPlot$ = 12						; size = 4
?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z PROC ; CvBuilderTaskingAI::ShouldBuilderConsiderPlot, COMDAT
; _this$ = ecx

; 2414 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	push	ebp
	push	esi

; 2415 : 	// if plot is impassable, bail!
; 2416 : #ifdef AUI_WORKER_FIX_SHOULD_CONSIDER_PLOT_FLYING_WORKER_DISREGARDS_PEAKS
; 2417 : 	if (!pUnit->canMoveAllTerrain() && ((pPlot->isImpassable() && !pUnit->canMoveImpassable()) ||
; 2418 : 		(pPlot->isMountain() && !pUnit->IsHoveringUnit() && !m_pPlayer->GetPlayerTraits()->IsAbleToCrossMountains())))
; 2419 : #else
; 2420 : 	if(pPlot->isImpassable() || pPlot->isMountain())

	mov	esi, DWORD PTR _pPlot$[esp+80]
	test	BYTE PTR [esi+462], 128			; 00000080H
	push	edi
	mov	ebp, ecx
	jne	$LN27@ShouldBuil
	cmp	BYTE PTR [esi+5], 0
	je	$LN27@ShouldBuil

; 2429 : 		return false;
; 2430 : 	}
; 2431 : 
; 2432 : 	// can't build on plots others own (unless inside a minor)
; 2433 : 	PlayerTypes eOwner = pPlot->getOwner();

	movsx	eax, BYTE PTR [esi+4]

; 2434 : 	if(eOwner != NO_PLAYER && eOwner != m_pPlayer->GetID() && !GET_PLAYER(eOwner).isMinorCiv())

	cmp	eax, -1
	je	SHORT $LN25@ShouldBuil
	mov	ecx, DWORD PTR [ebp]
	cmp	eax, DWORD PTR [ecx+44]
	je	SHORT $LN25@ShouldBuil
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al

; 2435 : 	{
; 2436 : 		return false;

	je	$LN26@ShouldBuil
$LN25@ShouldBuil:

; 2437 : 	}
; 2438 : 
; 2439 : 	// workers should not be able to work in plots that do not match their default domain
; 2440 : 	switch(pUnit->getDomainType())

	mov	edi, DWORD PTR _pUnit$[esp+84]
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	sub	eax, 0
	mov	cl, 3
	je	SHORT $LN20@ShouldBuil
	sub	eax, 2
	jne	SHORT $LN19@ShouldBuil

; 2441 : 	{
; 2442 : 	case DOMAIN_LAND:
; 2443 : 		if(pPlot->isWater())

	cmp	BYTE PTR [esi+5], cl
	jne	SHORT $LN19@ShouldBuil

; 2444 : 		{
; 2445 : 			return false;

	jmp	$LN26@ShouldBuil
$LN20@ShouldBuil:

; 2446 : 		}
; 2447 : 		break;
; 2448 : 	case DOMAIN_SEA:
; 2449 : 		if(!pPlot->isWater())

	cmp	BYTE PTR [esi+5], cl

; 2450 : 		{
; 2451 : 			return false;

	jne	$LN26@ShouldBuil
$LN19@ShouldBuil:

; 2452 : 		}
; 2453 : 		break;
; 2454 : 	default:
; 2455 : 		break;
; 2456 : 	}
; 2457 : 
; 2458 : 	// need more planning for amphibious units
; 2459 : 	// we should include here the ability for work boats to cross to other areas with cities
; 2460 : 	if(pPlot->area() != pUnit->area())

	mov	ecx, edi
	call	?area@CvUnit@@QBEPAVCvArea@@XZ		; CvUnit::area
	mov	ecx, esi
	mov	ebx, eax
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	cmp	eax, ebx
	je	SHORT $LN12@ShouldBuil

; 2461 : 	{
; 2462 : #ifdef AUI_WORKER_FIX_SHOULD_CONSIDER_PLOT_WORK_BOATS_CONSIDER_ALL_SEA_PLOTS
; 2463 : 		if (pUnit->getDomainType() != DOMAIN_SEA && !pUnit->CanEverEmbark())
; 2464 : 		{
; 2465 : 			if (m_bLogging)
; 2466 : 			{
; 2467 : 				CvString strLog;
; 2468 : 				strLog.Format("unitx: %d unity: %d, plotx: %d ploty: %d, plot area: %d, unit area: %d,,Plot areas don't match and can't embark", pUnit->getX(), pUnit->getY(), pPlot->getX(), pPlot->getY(), pPlot->area(), pUnit->area());
; 2469 : 				if (pPlot->isWater() == pUnit->plot()->isWater())
; 2470 : 				{
; 2471 : 					strLog += ",This is weird";
; 2472 : 				}
; 2473 : 				else
; 2474 : 				{
; 2475 : 					strLog += ",This is normal";
; 2476 : 				}
; 2477 : 				LogInfo(strLog, m_pPlayer);
; 2478 : 			}
; 2479 : 			return false;
; 2480 : 		}
; 2481 : #else
; 2482 : 		bool bCanCrossToNewArea = false;
; 2483 : 
; 2484 : 		if(pUnit->getDomainType() == DOMAIN_SEA)

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType

; 2485 : 		{
; 2486 : 			if(pPlot->isAdjacentToArea(pUnit->area()))

	mov	ecx, edi
	test	eax, eax
	jne	SHORT $LN16@ShouldBuil
	call	?area@CvUnit@@QBEPAVCvArea@@XZ		; CvUnit::area
	push	eax
	mov	ecx, esi
	call	?isAdjacentToArea@CvPlot@@QBE_NPBVCvArea@@@Z ; CvPlot::isAdjacentToArea
	test	al, al
	je	SHORT $LN136@ShouldBuil
$LN12@ShouldBuil:

; 2516 : 		}
; 2517 : #endif
; 2518 : 	}
; 2519 : 
; 2520 : #ifndef AUI_WORKER_FIX_SHOULD_BUILDER_CONSIDER_PLOT_EXISTING_BUILD_MISSIONS_SHIFT
; 2521 : 	// check to see if someone already has a mission here
; 2522 : 	if(pUnit->GetMissionAIPlot() != pPlot)

	mov	ecx, edi
	call	?GetMissionAIPlot@CvUnit@@QAEPAVCvPlot@@XZ ; CvUnit::GetMissionAIPlot
	cmp	eax, esi
	je	$LN7@ShouldBuil

; 2523 : 	{
; 2524 : 		if(m_pPlayer->AI_plotTargetMissionAIs(pPlot, MISSIONAI_BUILD) > 0)

	mov	ecx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+64]
	push	0
	push	18					; 00000012H
	push	esi
	call	edx
	test	eax, eax
	jle	$LN7@ShouldBuil

; 2525 : 		{
; 2526 : 			if(m_bLogging)

	cmp	BYTE PTR [ebp+58392], 0
	je	$LN26@ShouldBuil

; 2527 : 			{
; 2528 : 				CvString strLog;

	lea	ecx, DWORD PTR _strLog$218896[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2529 : 				strLog.Format("x: %d y: %d,,Somebody has a mission here, ", pPlot->getX(), pPlot->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strLog$218896[esp+96]
	push	OFFSET $SG218897
	push	edx
	mov	DWORD PTR __$EHRec$[esp+112], 2
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2530 : 				LogInfo(strLog, m_pPlayer, true);

	push	1

; 2531 : 			}
; 2532 : 
; 2533 : 			return false;

	jmp	$LN141@ShouldBuil
$LN16@ShouldBuil:

; 2487 : 			{
; 2488 : 				bCanCrossToNewArea = true;
; 2489 : 			}
; 2490 : 		}
; 2491 : 		else
; 2492 : 		{
; 2493 : 			if(pUnit->CanEverEmbark())

	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	test	al, al

; 2494 : 			{
; 2495 : 				bCanCrossToNewArea = true;
; 2496 : 			}
; 2497 : 		}
; 2498 : 
; 2499 : 		if(!bCanCrossToNewArea)

	jne	SHORT $LN12@ShouldBuil
$LN136@ShouldBuil:

; 2500 : 		{
; 2501 : 			if(m_bLogging)

	cmp	BYTE PTR [ebp+58392], 0
	je	$LN26@ShouldBuil

; 2502 : 			{
; 2503 : 				CvString strLog;

	lea	ecx, DWORD PTR _strLog$218886[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2504 : 				strLog.Format("unitx: %d unity: %d, plotx: %d ploty: %d, plot area: %d, unit area: %d,,Plot areas don't match and can't embark", pUnit->getX(), pUnit->getY(), pPlot->getX(), pPlot->getY(), pPlot->area(), pUnit->area());

	mov	ecx, DWORD PTR [edi+76]
	movsx	edx, WORD PTR [esi]
	mov	eax, DWORD PTR [edi+88]
	movsx	ebx, WORD PTR [esi+2]
	mov	DWORD PTR $T223059[esp+88], ecx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+96], 1
	mov	DWORD PTR $T223041[esp+84], edx
	mov	DWORD PTR $T223050[esp+84], eax
	call	?area@CvUnit@@QBEPAVCvArea@@XZ		; CvUnit::area
	push	eax
	mov	ecx, esi
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	edx, DWORD PTR $T223041[esp+88]
	mov	ecx, DWORD PTR $T223059[esp+92]
	push	eax
	mov	eax, DWORD PTR $T223050[esp+92]
	push	ebx
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strLog$218886[esp+112]
	push	OFFSET $SG218887
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 32					; 00000020H

; 2505 : 				if(pPlot->isWater() == pUnit->plot()->isWater())

	cmp	BYTE PTR [esi+5], 3
	mov	ecx, edi
	sete	bl
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	BYTE PTR [eax+5], 3

; 2506 : 				{
; 2507 : 					strLog += ",This is weird";

	lea	ecx, DWORD PTR _strLog$218886[esp+88]
	sete	al
	cmp	bl, al
	jne	SHORT $LN10@ShouldBuil
	push	OFFSET $SG218889

; 2508 : 				}
; 2509 : 				else
; 2510 : 				{
; 2511 : 					strLog += ",This is normal";

	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 2512 : 				}
; 2513 : 				LogInfo(strLog, m_pPlayer);

	mov	ecx, DWORD PTR [ebp]
	push	0
	push	ecx

; 2514 : 			}
; 2515 : 			return false;

	jmp	$LN140@ShouldBuil
$LN10@ShouldBuil:

; 2508 : 				}
; 2509 : 				else
; 2510 : 				{
; 2511 : 					strLog += ",This is normal";

	push	OFFSET $SG218891
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 2512 : 				}
; 2513 : 				LogInfo(strLog, m_pPlayer);

	mov	ecx, DWORD PTR [ebp]
	push	0
	push	ecx

; 2514 : 			}
; 2515 : 			return false;

	jmp	$LN140@ShouldBuil
$LN7@ShouldBuil:

; 2534 : 		}
; 2535 : 	}
; 2536 : #endif
; 2537 : 
; 2538 : #if defined(AUI_WORKER_SHOULD_BUILDER_CONSIDER_PLOT_MAXIMUM_DANGER_BASED_ON_UNIT_STRENGTH)
; 2539 : if ((!pUnit->IsCombatUnit() && m_pPlayer->GetPlotDanger(*pPlot) > 0) ||
; 2540 : 	m_pPlayer->GetPlotDanger(*pPlot) > pUnit->GetBaseCombatStrengthConsideringDamage() * AUI_WORKER_SHOULD_BUILDER_CONSIDER_PLOT_MAXIMUM_DANGER_BASED_ON_UNIT_STRENGTH)
; 2541 : #else
; 2542 : if (m_pPlayer->GetPlotDanger(*pPlot) > 0)

	mov	ecx, DWORD PTR [ebp]
	push	esi
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	test	eax, eax
	jle	SHORT $LN4@ShouldBuil

; 2543 : #endif
; 2544 : 	if(m_pPlayer->GetPlotDanger(*pPlot) > 0)

	mov	ecx, DWORD PTR [ebp]
	push	esi
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	test	eax, eax
	jle	SHORT $LN4@ShouldBuil

; 2545 : 	{
; 2546 : 		if(m_bLogging)

	cmp	BYTE PTR [ebp+58392], 0
	je	$LN26@ShouldBuil

; 2547 : 		{
; 2548 : 			CvString strLog;

	lea	ecx, DWORD PTR _strLog$218902[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2549 : 			strLog.Format("plotX: %d plotY: %d, danger: %d,, bailing due to danger", pPlot->getX(), pPlot->getY(), m_pPlayer->GetPlotDanger(*pPlot));

	mov	ecx, DWORD PTR [ebp]
	movsx	edi, WORD PTR [esi+2]
	movsx	ebx, WORD PTR [esi]
	push	esi
	mov	DWORD PTR __$EHRec$[esp+100], 3
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	push	eax
	push	edi
	push	ebx
	lea	eax, DWORD PTR _strLog$218902[esp+100]
	push	OFFSET $SG218903
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 2550 : 			LogInfo(strLog, m_pPlayer, true);

	mov	ecx, DWORD PTR [ebp]
	add	esp, 20					; 00000014H
	push	1
	push	ecx

; 2551 : 		}
; 2552 : 
; 2553 : 		return false;

	jmp	$LN140@ShouldBuil
$LN4@ShouldBuil:

; 2554 : 	}
; 2555 : 
; 2556 : 	if(!pUnit->atPlot(*pPlot) && pPlot->getNumFriendlyUnitsOfType(pUnit) >= GC.getPLOT_UNIT_LIMIT())

	push	esi
	mov	ecx, edi
	call	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z	; CvUnit::atPlot
	test	al, al
	jne	SHORT $LN2@ShouldBuil
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7356
	push	1
	push	edi
	mov	ecx, esi
	call	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
	cmp	eax, ebx
	jl	SHORT $LN2@ShouldBuil

; 2557 : 	{
; 2558 : 		if(m_bLogging)

	cmp	BYTE PTR [ebp+58392], 0
	je	$LN26@ShouldBuil

; 2559 : 		{
; 2560 : 			CvString strLog;

	lea	ecx, DWORD PTR _strLog$218907[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2561 : 			strLog.Format("plotX: %d plotY: %d,, this tile is full with another unit. bailing!", pPlot->getX(), pPlot->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strLog$218907[esp+96]
	push	OFFSET $SG218908
	push	edx
	mov	DWORD PTR __$EHRec$[esp+112], 4
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 2562 : 			LogInfo(strLog, m_pPlayer, true);

	mov	eax, DWORD PTR [ebp]
	add	esp, 16					; 00000010H
	push	1
	push	eax
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strLog$218907[esp+124]
	mov	DWORD PTR $T222972[esp+120], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo

; 2563 : 		}

	lea	ecx, DWORD PTR _strLog$218907[esp+124]

; 2564 : 
; 2565 : 		return false;

	jmp	SHORT $LN142@ShouldBuil
$LN2@ShouldBuil:

; 2566 : 	}
; 2567 : 
; 2568 : 	return true;

	mov	al, 1

; 2569 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 72					; 00000048H
	ret	8
$LN27@ShouldBuil:

; 2421 : #endif
; 2422 : 	{
; 2423 : 		if(m_bLogging)

	cmp	BYTE PTR [ebp+58392], 0
	je	SHORT $LN26@ShouldBuil

; 2424 : 		{
; 2425 : 			CvString strLog;

	lea	ecx, DWORD PTR _strLog$218864[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2426 : 			strLog.Format("x: %d y: %d,,Impassable tile. Toss out", pPlot->getX(), pPlot->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strLog$218864[esp+96]
	push	OFFSET $SG218865
	push	edx
	mov	DWORD PTR __$EHRec$[esp+112], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2427 : 			LogInfo(strLog, m_pPlayer);

	push	0
$LN141@ShouldBuil:
	mov	eax, DWORD PTR [ebp]
	push	eax
$LN140@ShouldBuil:
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strLog$218864[esp+124]
	mov	DWORD PTR $T222968[esp+120], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo

; 2428 : 		}

	lea	ecx, DWORD PTR _strLog$218864[esp+124]
$LN142@ShouldBuil:
	add	esp, 36					; 00000024H
	mov	DWORD PTR __$EHRec$[esp+96], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN26@ShouldBuil:

; 2569 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	edi
	pop	esi
	pop	ebp
	xor	al, al
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 72					; 00000048H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$4:
	lea	ecx, DWORD PTR _strLog$218896[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$2:
	lea	ecx, DWORD PTR _strLog$218886[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$6:
	lea	ecx, DWORD PTR _strLog$218902[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$8:
	lea	ecx, DWORD PTR _strLog$218907[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _strLog$218864[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z ENDP ; CvBuilderTaskingAI::ShouldBuilderConsiderPlot
PUBLIC	?FindTurnsAway@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@@Z ; CvBuilderTaskingAI::FindTurnsAway
; Function compile flags: /Ogtpy
;	COMDAT ?FindTurnsAway@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_pPlot$ = 12						; size = 4
?FindTurnsAway@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@@Z PROC ; CvBuilderTaskingAI::FindTurnsAway, COMDAT
; _this$ = ecx

; 2573 : {

	push	esi

; 2574 : 	// If this plot is far away, we'll just use its distance as an estimate of the time to get there (to avoid hitting the path finder)
; 2575 : 	// We'll be sure to check later to make sure we have a real path before we execute this
; 2576 : 	if(pUnit->getDomainType() == DOMAIN_LAND && pUnit->plot()->area() != pPlot->area() && !pUnit->CanEverEmbark())

	mov	esi, DWORD PTR _pUnit$[esp]
	push	edi
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	mov	edi, DWORD PTR _pPlot$[esp+4]
	cmp	eax, 2
	jne	SHORT $LN1@FindTurnsA
	push	ebx
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, edi
	mov	ebx, eax
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	cmp	ebx, eax
	pop	ebx
	je	SHORT $LN1@FindTurnsA
	mov	ecx, esi
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	test	al, al
	jne	SHORT $LN1@FindTurnsA
	pop	edi

; 2577 : 	{
; 2578 : 		return -1;

	or	eax, -1
	pop	esi

; 2592 : #else
; 2593 : 	if(iPlotDistance >= GC.getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE())
; 2594 : 	{
; 2595 : 		return iPlotDistance;
; 2596 : 	}
; 2597 : 	else
; 2598 : 	{
; 2599 : 		int iResult = TurnsToReachTarget(pUnit, pPlot);
; 2600 : 		if(iResult == MAX_INT)
; 2601 : 		{
; 2602 : 			return -1;
; 2603 : 		}
; 2604 : 
; 2605 : 		return iResult;
; 2606 : 	}
; 2607 : #endif
; 2608 : #endif
; 2609 : }

	ret	8
$LN1@FindTurnsA:

; 2579 : 	}
; 2580 : 
; 2581 : #ifdef AUI_WORKER_FIND_TURNS_AWAY_USES_PATHFINDER
; 2582 : 	int iPlotDistance = TurnsToReachTarget(pUnit, pPlot, true /*bReusePaths*/, AUI_WORKER_FIND_TURNS_AWAY_USES_PATHFINDER /*bIgnoreUnits*/);
; 2583 : 	if (iPlotDistance < MAX_INT)
; 2584 : 		return iPlotDistance;
; 2585 : 	else
; 2586 : 		return -1;
; 2587 : #else
; 2588 : 	int iPlotDistance = plotDistance(pUnit->getX(), pUnit->getY(), pPlot->getX(), pPlot->getY());
; 2589 : #if 1
; 2590 : 	// Always return the raw distance
; 2591 : 	return iPlotDistance;

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	mov	edx, DWORD PTR [esi+88]
	push	eax
	mov	eax, DWORD PTR [esi+76]
	push	ecx
	push	edx
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi

; 2592 : #else
; 2593 : 	if(iPlotDistance >= GC.getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE())
; 2594 : 	{
; 2595 : 		return iPlotDistance;
; 2596 : 	}
; 2597 : 	else
; 2598 : 	{
; 2599 : 		int iResult = TurnsToReachTarget(pUnit, pPlot);
; 2600 : 		if(iResult == MAX_INT)
; 2601 : 		{
; 2602 : 			return -1;
; 2603 : 		}
; 2604 : 
; 2605 : 		return iResult;
; 2606 : 	}
; 2607 : #endif
; 2608 : #endif
; 2609 : }

	ret	8
?FindTurnsAway@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@@Z ENDP ; CvBuilderTaskingAI::FindTurnsAway
_TEXT	ENDS
PUBLIC	?GetBuildTimeWeight@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@_NH@Z ; CvBuilderTaskingAI::GetBuildTimeWeight
EXTRN	?getFeatureTime@CvBuildInfo@@QBEHH@Z:PROC	; CvBuildInfo::getFeatureTime
EXTRN	?getBuildTurnsLeft@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@HH@Z:PROC ; CvPlot::getBuildTurnsLeft
EXTRN	?workRate@CvUnit@@QBEH_NW4BuildTypes@@@Z:PROC	; CvUnit::workRate
EXTRN	?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::getBuildTime
EXTRN	?IsRoutePillaged@CvPlot@@QBE_NXZ:PROC		; CvPlot::IsRoutePillaged
EXTRN	?getRoute@CvBuildInfo@@QBEHXZ:PROC		; CvBuildInfo::getRoute
EXTRN	?IsImprovementPillaged@CvPlot@@QBE_NXZ:PROC	; CvPlot::IsImprovementPillaged
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildTimeWeight@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@_NH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iBuildTurnsLeft$ = 12					; size = 4
_pPlot$ = 12						; size = 4
_iBuildTimeNormal$ = 16					; size = 4
_eBuild$ = 16						; size = 4
_bIgnoreFeatureTime$ = 20				; size = 1
_iAdditionalTime$ = 24					; size = 4
?GetBuildTimeWeight@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@_NH@Z PROC ; CvBuilderTaskingAI::GetBuildTimeWeight, COMDAT
; _this$ = ecx

; 2632 : {

	push	ebx
	push	ebp
	push	esi

; 2633 : 	// if we need to repair this plot, replace the build with a repair build
; 2634 : 	if((GC.getBuildInfo(eBuild)->getImprovement() != NO_IMPROVEMENT && pPlot->IsImprovementPillaged()) || (GC.getBuildInfo(eBuild)->getRoute() != NO_ROUTE && pPlot->IsRoutePillaged()))

	mov	esi, DWORD PTR _eBuild$[esp+8]
	push	edi
	mov	edi, ecx
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	ebx, DWORD PTR _pPlot$[esp+12]
	cmp	eax, -1
	je	SHORT $LN4@GetBuildTi
	mov	ecx, ebx
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	test	al, al
	jne	SHORT $LN5@GetBuildTi
$LN4@GetBuildTi:
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	cmp	eax, -1
	je	SHORT $LN6@GetBuildTi
	mov	ecx, ebx
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	test	al, al
	je	SHORT $LN6@GetBuildTi
$LN5@GetBuildTi:

; 2635 : 	{
; 2636 : 		// find a repair directive to replace
; 2637 : 		// find the repair build
; 2638 : 		eBuild = m_eRepairBuild;

	mov	esi, DWORD PTR [edi+4]
$LN6@GetBuildTi:

; 2639 : 	}
; 2640 : 
; 2641 : 	int iBuildTimeNormal = pPlot->getBuildTime(eBuild, m_pPlayer->GetID());

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	push	esi
	mov	ecx, ebx
	call	?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ; CvPlot::getBuildTime

; 2642 : 	int iBuildTurnsLeft = pPlot->getBuildTurnsLeft(eBuild, m_pPlayer->GetID(), pUnit->workRate(true), pUnit->workRate(true));

	mov	ecx, DWORD PTR [edi]
	mov	edi, DWORD PTR [ecx+44]
	mov	ebp, DWORD PTR _pUnit$[esp+12]
	push	-1
	mov	ebx, eax
	push	1
	mov	ecx, ebp
	mov	DWORD PTR _iBuildTimeNormal$[esp+20], ebx
	call	?workRate@CvUnit@@QBEH_NW4BuildTypes@@@Z ; CvUnit::workRate
	push	eax
	push	-1
	push	1
	mov	ecx, ebp
	call	?workRate@CvUnit@@QBEH_NW4BuildTypes@@@Z ; CvUnit::workRate
	mov	ebp, DWORD PTR _pPlot$[esp+16]
	push	eax
	push	edi
	push	esi
	mov	ecx, ebp
	call	?getBuildTurnsLeft@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@HH@Z ; CvPlot::getBuildTurnsLeft
	mov	DWORD PTR _iBuildTurnsLeft$[esp+12], eax

; 2643 : 	int iBuildTime = min(iBuildTimeNormal, iBuildTurnsLeft);

	cmp	eax, ebx
	lea	eax, DWORD PTR _iBuildTurnsLeft$[esp+12]
	jl	SHORT $LN20@GetBuildTi
	lea	eax, DWORD PTR _iBuildTimeNormal$[esp+12]
$LN20@GetBuildTi:
	mov	edi, DWORD PTR [eax]

; 2644 : 	if(iBuildTime <= 0)

	test	edi, edi
	jg	SHORT $LN3@GetBuildTi

; 2645 : 	{
; 2646 : 		iBuildTime = 1;

	mov	edi, 1
$LN3@GetBuildTi:

; 2647 : 	}
; 2648 : 
; 2649 : 	if(bIgnoreFeatureTime)

	cmp	BYTE PTR _bIgnoreFeatureTime$[esp+12], 0
	je	SHORT $LN1@GetBuildTi

; 2650 : 	{
; 2651 : 		if(pPlot->getFeatureType() != NO_FEATURE)

	mov	al, BYTE PTR [ebp+432]
	cmp	al, -1
	je	SHORT $LN1@GetBuildTi

; 2652 : 		{
; 2653 : 			iBuildTime -= GC.getBuildInfo(eBuild)->getFeatureTime(pPlot->getFeatureType());

	movsx	edx, al
	push	edx
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getFeatureTime@CvBuildInfo@@QBEHH@Z	; CvBuildInfo::getFeatureTime
	sub	edi, eax
$LN1@GetBuildTi:

; 2654 : 		}
; 2655 : 	}
; 2656 : 
; 2657 : 	iBuildTime += iAdditionalTime;

	mov	eax, DWORD PTR _iAdditionalTime$[esp+12]
	add	edi, eax

; 2658 : 
; 2659 : 	return 10000 / iBuildTime;

	mov	eax, 10000				; 00002710H
	cdq
	idiv	edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2660 : }

	ret	20					; 00000014H
?GetBuildTimeWeight@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@_NH@Z ENDP ; CvBuilderTaskingAI::GetBuildTimeWeight
_TEXT	ENDS
PUBLIC	?GetResourceWeight@CvBuilderTaskingAI@@QAEHW4ResourceTypes@@W4ImprovementTypes@@H@Z ; CvBuilderTaskingAI::GetResourceWeight
EXTRN	?getNumResourceUsed@CvPlayer@@QBEHW4ResourceTypes@@@Z:PROC ; CvPlayer::getNumResourceUsed
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?getTechCityTrade@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getTechCityTrade
EXTRN	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z:PROC ; CvPlayer::getNumResourceAvailable
EXTRN	?getHappiness@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getHappiness
EXTRN	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ:PROC ; CvResourceInfo::getResourceUsage
EXTRN	?GetFlavorValue@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetFlavorValue
EXTRN	?getFlavorValue@CvResourceInfo@@QBEHH@Z:PROC	; CvResourceInfo::getFlavorValue
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceWeight@CvBuilderTaskingAI@@QAEHW4ResourceTypes@@W4ImprovementTypes@@H@Z
_TEXT	SEGMENT
_iWeight$ = -8						; size = 4
_this$ = -4						; size = 4
_eResource$ = 8						; size = 4
_eImprovement$ = 12					; size = 4
_iQuantity$ = 16					; size = 4
?GetResourceWeight@CvBuilderTaskingAI@@QAEHW4ResourceTypes@@W4ImprovementTypes@@H@Z PROC ; CvBuilderTaskingAI::GetResourceWeight, COMDAT
; _this$ = ecx

; 2664 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2665 : 	int iWeight = 0;
; 2666 : 	CvResourceInfo* pkResource = GC.getResourceInfo(eResource);

	mov	edi, DWORD PTR _eResource$[esp+20]
	mov	ebx, ecx
	xor	esi, esi
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+28], ebx
	mov	DWORD PTR _iWeight$[esp+28], esi
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ebp, eax

; 2667 : 	if(pkResource == NULL)

	cmp	ebp, esi
	jne	SHORT $LN16@GetResourc
	pop	edi
	pop	esi
	pop	ebp

; 2668 : 	{
; 2669 : 		return 0;

	xor	eax, eax
	pop	ebx

; 2761 : }

	add	esp, 8
	ret	12					; 0000000cH
$LN16@GetResourc:

; 2670 : 	}
; 2671 : 
; 2672 : 	for(int i = 0; i < GC.getNumFlavorTypes(); i++)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, esi
	jle	SHORT $LN13@GetResourc
	npad	4
$LL15@GetResourc:

; 2673 : 	{
; 2674 : 		int iResourceFlavor = pkResource->getFlavorValue((FlavorTypes)i);

	push	esi
	mov	ecx, ebp
	call	?getFlavorValue@CvResourceInfo@@QBEHH@Z	; CvResourceInfo::getFlavorValue

; 2675 : 		int iPersonalityFlavorValue = m_pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor((FlavorTypes)i);

	mov	ecx, DWORD PTR [ebx]
	push	esi
	mov	edi, eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	mov	ebx, eax

; 2676 : 		int iResult = iResourceFlavor * iPersonalityFlavorValue;

	imul	eax, edi

; 2677 : 
; 2678 : 		if(iResult > 0)

	test	eax, eax
	jle	SHORT $LN37@GetResourc

; 2679 : 		{
; 2680 : 			iWeight += iResult;

	add	DWORD PTR _iWeight$[esp+24], eax
$LN37@GetResourc:

; 2681 : 		}
; 2682 : 
; 2683 : 		int iImprovementFlavor = 1;
; 2684 : 		if(eImprovement != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _eImprovement$[esp+20]
	mov	eax, 1
	cmp	ecx, -1
	je	SHORT $LN11@GetResourc

; 2685 : 		{
; 2686 : 			iImprovementFlavor = GC.getImprovementInfo(eImprovement)->GetFlavorValue(i);

	push	esi
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetFlavorValue@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetFlavorValue
$LN11@GetResourc:

; 2687 : 		}
; 2688 : 
; 2689 : 		int iUsableByCityWeight = iPersonalityFlavorValue * iImprovementFlavor;

	imul	eax, ebx

; 2690 : 		if(iUsableByCityWeight > 0)

	test	eax, eax
	jle	SHORT $LN14@GetResourc

; 2691 : 		{
; 2692 : 			iWeight += iUsableByCityWeight;

	add	DWORD PTR _iWeight$[esp+24], eax
$LN14@GetResourc:

; 2670 : 	}
; 2671 : 
; 2672 : 	for(int i = 0; i < GC.getNumFlavorTypes(); i++)

	mov	ebx, DWORD PTR _this$[esp+24]
	inc	esi
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL15@GetResourc
	mov	edi, DWORD PTR _eResource$[esp+20]
$LN13@GetResourc:

; 2693 : 		}
; 2694 : 	}
; 2695 : 
; 2696 : 	// if the empire is unhappy (or close to it) and this is a luxury resource the player doesn't have, provide a super bonus to getting it
; 2697 : 	if(pkResource->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	mov	ecx, ebp
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage

; 2698 : 	{
; 2699 : 		int iModifier = GC.getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_LUXURY_RESOURCE() * pkResource->getHappiness();

	mov	ecx, ebp
	cmp	eax, 2
	jne	SHORT $LN9@GetResourc
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2124
	call	?getHappiness@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getHappiness

; 2700 : #ifdef AUI_WORKER_GET_RESOURCE_WEIGHT_CONSIDER_EXTRAS_FOR_HAPPINESS_FROM_RESOURCE
; 2701 : 		iModifier += GC.getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_LUXURY_RESOURCE() * m_pPlayer->GetExtraHappinessPerLuxury();
; 2702 : #endif
; 2703 : 
; 2704 : 		//if (m_pPlayer->IsEmpireUnhappy() || m_pPlayer->GetExcessHappiness() <= 2)
; 2705 : 		//{
; 2706 : 		//}
; 2707 : 		if(m_pPlayer->getNumResourceAvailable(eResource) == 0)

	mov	ecx, DWORD PTR [ebx]
	mov	esi, eax
	mov	eax, DWORD PTR _eResource$[esp+20]
	imul	esi, edi
	push	1
	push	eax
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	test	eax, eax
	je	$LN1@GetResourc

; 2708 : 		{
; 2709 : 			// full bonus
; 2710 : #ifdef AUI_WORKER_GET_RESOURCE_WEIGHT_CONSIDER_EXTRAS_FOR_HAPPINESS_FROM_RESOURCE
; 2711 : 			if (m_pPlayer->GetPlayerTraits()->GetLuxuryHappinessRetention() > 0)
; 2712 : 				iModifier = iModifier * (m_pPlayer->GetPlayerTraits()->GetLuxuryHappinessRetention() + pkResource->getHappiness()) / pkResource->getHappiness();
; 2713 : 			iModifier += GC.getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_LUXURY_RESOURCE() * GC.getHAPPINESS_PER_EXTRA_LUXURY();
; 2714 : #endif
; 2715 : #ifdef AUI_WORKER_GET_RESOURCE_WEIGHT_INCREASE_UNOWNED_LUXURY_WEIGHT
; 2716 : 			if (m_pPlayer->GetExcessHappiness() < -GC.getVERY_UNHAPPY_THRESHOLD())
; 2717 : 			{
; 2718 : 				iModifier = int(iModifier * pow(AUI_WORKER_GET_RESOURCE_WEIGHT_INCREASE_UNOWNED_LUXURY_WEIGHT, 1.0 - (double)m_pPlayer->GetExcessHappiness() / -(double)GC.getVERY_UNHAPPY_THRESHOLD()) + 0.5);
; 2719 : 			}
; 2720 : #endif
; 2721 : 		}
; 2722 : 		else
; 2723 : 		{
; 2724 : 			iModifier = (iModifier * 3) / 4; // 3/4ths the awesome bonus, so that we pick up extra resources 

	lea	eax, DWORD PTR [esi+esi*2]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	esi, eax

; 2744 : 				}
; 2745 : 				else
; 2746 : 				{
; 2747 : 					// if we don't have any of it
; 2748 : #ifdef AUI_WORKER_TWEAKED_DONT_HAVE_MULTIPLIER
; 2749 : 					iMultiplyingAmount *= AUI_WORKER_TWEAKED_DONT_HAVE_MULTIPLIER;
; 2750 : #else
; 2751 : 					iMultiplyingAmount *= 4;
; 2752 : #endif
; 2753 : 				}
; 2754 : 			}
; 2755 : 
; 2756 : 			iWeight *= iMultiplyingAmount;

	imul	esi, DWORD PTR _iWeight$[esp+24]
	pop	edi
	mov	DWORD PTR _iWeight$[esp+20], esi

; 2757 : 		}
; 2758 : 	}
; 2759 : 
; 2760 : 	return iWeight;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 2761 : }

	add	esp, 8
	ret	12					; 0000000cH
$LN9@GetResourc:

; 2725 : 		}
; 2726 : 
; 2727 : 		iWeight *= iModifier;
; 2728 : 	}
; 2729 : 	else if(pkResource->getResourceUsage() == RESOURCEUSAGE_STRATEGIC && pkResource->getTechCityTrade())

	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 1
	jne	SHORT $LN38@GetResourc
	mov	ecx, ebp
	call	?getTechCityTrade@CvResourceInfo@@QBEHXZ ; CvResourceInfo::getTechCityTrade
	test	eax, eax
	je	SHORT $LN38@GetResourc

; 2730 : 	{
; 2731 : 		bool bHasTech = GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->HasTech((TechTypes) pkResource->getTechCityTrade());

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN27@GetResourc
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN28@GetResourc
$LN27@GetResourc:
	or	eax, -1
$LN28@GetResourc:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, ebp
	mov	esi, eax
	call	?getTechCityTrade@CvResourceInfo@@QBEHXZ ; CvResourceInfo::getTechCityTrade
	push	eax
	mov	ecx, esi
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech

; 2732 : 		if(bHasTech)

	test	al, al
	je	SHORT $LN38@GetResourc

; 2733 : 		{
; 2734 : 			// measure quantity
; 2735 : 			int iMultiplyingAmount = iQuantity * 200;

	mov	esi, DWORD PTR _iQuantity$[esp+20]

; 2736 : 
; 2737 : 			// if we don't have any currently available
; 2738 : 			if(m_pPlayer->getNumResourceAvailable(eResource) == 0)

	mov	ecx, DWORD PTR [ebx]
	imul	esi, 200				; 000000c8H
	push	1
	push	edi
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	test	eax, eax
	jne	SHORT $LN1@GetResourc

; 2739 : 			{
; 2740 : 				// if we have some of the strategic resource, but all is used
; 2741 : 				if(m_pPlayer->getNumResourceUsed(eResource) > 0)

	mov	ecx, DWORD PTR [ebx]
	push	edi
	call	?getNumResourceUsed@CvPlayer@@QBEHW4ResourceTypes@@@Z ; CvPlayer::getNumResourceUsed

; 2742 : 				{
; 2743 : 					iMultiplyingAmount *= 4;

	add	esi, esi
	add	esi, esi
$LN1@GetResourc:

; 2744 : 				}
; 2745 : 				else
; 2746 : 				{
; 2747 : 					// if we don't have any of it
; 2748 : #ifdef AUI_WORKER_TWEAKED_DONT_HAVE_MULTIPLIER
; 2749 : 					iMultiplyingAmount *= AUI_WORKER_TWEAKED_DONT_HAVE_MULTIPLIER;
; 2750 : #else
; 2751 : 					iMultiplyingAmount *= 4;
; 2752 : #endif
; 2753 : 				}
; 2754 : 			}
; 2755 : 
; 2756 : 			iWeight *= iMultiplyingAmount;

	imul	esi, DWORD PTR _iWeight$[esp+24]
	mov	DWORD PTR _iWeight$[esp+24], esi
$LN38@GetResourc:

; 2757 : 		}
; 2758 : 	}
; 2759 : 
; 2760 : 	return iWeight;

	mov	eax, DWORD PTR _iWeight$[esp+24]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2761 : }

	add	esp, 8
	ret	12					; 0000000cH
?GetResourceWeight@CvBuilderTaskingAI@@QAEHW4ResourceTypes@@W4ImprovementTypes@@H@Z ENDP ; CvBuilderTaskingAI::GetResourceWeight
_TEXT	ENDS
PUBLIC	?IsImprovementBeneficial@CvBuilderTaskingAI@@QAE_NPAVCvPlot@@ABVCvBuildInfo@@W4YieldTypes@@_N@Z ; CvBuilderTaskingAI::IsImprovementBeneficial
EXTRN	?calculateImprovementYieldChange@CvPlot@@QBEHW4ImprovementTypes@@W4YieldTypes@@W4PlayerTypes@@_NW4RouteTypes@@@Z:PROC ; CvPlot::calculateImprovementYieldChange
EXTRN	?getYieldChange@CvRouteInfo@@QBEHH@Z:PROC	; CvRouteInfo::getYieldChange
EXTRN	?GetYieldChange@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetYieldChange
EXTRN	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z:PROC ; CvGlobals::getRouteInfo
EXTRN	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ:PROC ; CvPlot::getRouteType
; Function compile flags: /Ogtpy
;	COMDAT ?IsImprovementBeneficial@CvBuilderTaskingAI@@QAE_NPAVCvPlot@@ABVCvBuildInfo@@W4YieldTypes@@_N@Z
_TEXT	SEGMENT
_pkPlotRouteInfo$ = -56					; size = 4
_eImprovement$ = -52					; size = 4
_aiImprovedYieldTypes$ = -48				; size = 24
_aiNaturalYieldTypes$ = -24				; size = 24
_bIgnoreFeature$219005 = 8				; size = 1
_pPlot$ = 8						; size = 4
_bFeatureNeedsRemove$ = 12				; size = 1
_kBuild$ = 12						; size = 4
_eYield$ = 16						; size = 4
_bIsBreakEvenOK$ = 20					; size = 1
?IsImprovementBeneficial@CvBuilderTaskingAI@@QAE_NPAVCvPlot@@ABVCvBuildInfo@@W4YieldTypes@@_N@Z PROC ; CvBuilderTaskingAI::IsImprovementBeneficial, COMDAT
; _this$ = ecx

; 2766 : {

	sub	esp, 56					; 00000038H
	push	ebx
	push	ebp
	push	esi

; 2767 : 	const ImprovementTypes eImprovement = (ImprovementTypes)kBuild.getImprovement();

	mov	esi, DWORD PTR _kBuild$[esp+64]
	mov	ebx, ecx
	push	edi
	mov	ecx, esi
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement

; 2768 : 
; 2769 : 	const FeatureTypes eFeature = pPlot->getFeatureType();

	mov	ebp, DWORD PTR _pPlot$[esp+68]
	mov	edi, eax
	movsx	eax, BYTE PTR [ebp+432]
	mov	DWORD PTR _eImprovement$[esp+72], edi

; 2770 : 
; 2771 : 	bool bFeatureNeedsRemove = false;

	mov	BYTE PTR _bFeatureNeedsRemove$[esp+68], 0

; 2772 : 
; 2773 : 	if(eFeature != NO_FEATURE)

	cmp	eax, -1
	je	SHORT $LN61@IsImprovem

; 2774 : 	{
; 2775 : 		if(kBuild.isFeatureRemove(eFeature))

	push	eax
	mov	ecx, esi
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	test	al, al
	je	SHORT $LN61@IsImprovem

; 2776 : 		{
; 2777 : 			bFeatureNeedsRemove = true;

	mov	BYTE PTR _bFeatureNeedsRemove$[esp+68], 1
$LN61@IsImprovem:

; 2778 : 		}
; 2779 : 	}
; 2780 : 
; 2781 : 	CvImprovementEntry* pkImprovementInfo = NULL;
; 2782 : 	if(eImprovement != NO_IMPROVEMENT)

	cmp	edi, -1
	je	$LN1@IsImprovem

; 2783 : 	{
; 2784 : 		pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	esi, eax

; 2785 : 	}
; 2786 : 	CvAssert(pkImprovementInfo);
; 2787 : 
; 2788 : 	//This can technically happen if a build as passed in that doesn't contain an improvement..
; 2789 : 	//Returning false isn't the ideal error approach, but there's nothing better to do atm.
; 2790 : 	if(pkImprovementInfo == NULL)

	xor	edi, edi
	cmp	esi, edi

; 2791 : 	{
; 2792 : 		return false;

	je	$LN1@IsImprovem

; 2793 : 	}
; 2794 : 
; 2795 : 	CvRouteInfo* pkPlotRouteInfo = NULL;
; 2796 : 	if(pPlot->getRouteType() != NO_ROUTE)

	mov	ecx, ebp
	mov	DWORD PTR _pkPlotRouteInfo$[esp+72], edi
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, -1
	je	SHORT $LN20@IsImprovem

; 2797 : 	{
; 2798 : 		pkPlotRouteInfo = GC.getRouteInfo(pPlot->getRouteType());

	mov	ecx, ebp
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	DWORD PTR _pkPlotRouteInfo$[esp+72], eax
$LN20@IsImprovem:

; 2799 : 	}
; 2800 : 
; 2801 : 
; 2802 : 	int aiNaturalYieldTypes[NUM_YIELD_TYPES];
; 2803 : 	int aiImprovedYieldTypes[NUM_YIELD_TYPES];
; 2804 : 
; 2805 : 	// hacky solution for the great artist's landmark.
; 2806 : 	// if an improvement generates culture, then it is beneficial
; 2807 : 	if(pkImprovementInfo->GetYieldChange(YIELD_CULTURE) > 0)

	push	4
	mov	ecx, esi
	call	?GetYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetYieldChange
	test	eax, eax

; 2808 : 	{
; 2809 : 		return true;

	jg	$LN55@IsImprovem

; 2810 : 	}
; 2811 : 
; 2812 : 	for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	xor	esi, esi
	jmp	SHORT $LN18@IsImprovem
	npad	5
$LL60@IsImprovem:
	xor	edi, edi
$LN18@IsImprovem:

; 2813 : 	{
; 2814 : 		// calculate natural yields
; 2815 : 		aiNaturalYieldTypes[ui] = 0;
; 2816 : 		aiNaturalYieldTypes[ui] = pPlot->calculateNatureYield((YieldTypes)ui, m_pPlayer->getTeam());

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+44]
	mov	DWORD PTR _aiNaturalYieldTypes$[esp+esi*4+72], edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN35@IsImprovem
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN36@IsImprovem
$LN35@IsImprovem:
	or	eax, -1
$LN36@IsImprovem:
	push	edi
	push	eax
	push	esi
	mov	ecx, ebp
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield

; 2817 : 
; 2818 : 		// calculate improvement yields
; 2819 : 		aiImprovedYieldTypes[ui] = 0;
; 2820 : 
; 2821 : 		bool bIgnoreFeature = false;
; 2822 : 		if(bFeatureNeedsRemove)

	cmp	BYTE PTR _bFeatureNeedsRemove$[esp+68], 0
	mov	DWORD PTR _aiNaturalYieldTypes$[esp+esi*4+72], eax
	mov	DWORD PTR _aiImprovedYieldTypes$[esp+esi*4+72], edi
	mov	BYTE PTR _bIgnoreFeature$219005[esp+68], 0
	je	SHORT $LN15@IsImprovem

; 2823 : 		{
; 2824 : 			bIgnoreFeature = true;

	mov	BYTE PTR _bIgnoreFeature$219005[esp+68], 1
$LN15@IsImprovem:

; 2825 : 		}
; 2826 : 
; 2827 : 		aiImprovedYieldTypes[ui] = pPlot->calculateNatureYield((YieldTypes)ui, m_pPlayer->getTeam(), bIgnoreFeature);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN44@IsImprovem
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN45@IsImprovem
$LN44@IsImprovem:
	or	eax, -1
$LN45@IsImprovem:
	mov	ecx, DWORD PTR _bIgnoreFeature$219005[esp+68]
	push	ecx
	push	eax
	push	esi
	mov	ecx, ebp
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield

; 2828 : 		if(pkPlotRouteInfo)

	mov	ecx, DWORD PTR _pkPlotRouteInfo$[esp+72]
	mov	edi, eax
	mov	DWORD PTR _aiImprovedYieldTypes$[esp+esi*4+72], edi
	test	ecx, ecx
	je	SHORT $LN14@IsImprovem

; 2829 : 		{
; 2830 : 			aiImprovedYieldTypes[ui] += pkPlotRouteInfo->getYieldChange(ui);

	push	esi
	call	?getYieldChange@CvRouteInfo@@QBEHH@Z	; CvRouteInfo::getYieldChange
	add	eax, edi
	mov	DWORD PTR _aiImprovedYieldTypes$[esp+esi*4+72], eax
$LN14@IsImprovem:

; 2831 : 		}
; 2832 : 		aiImprovedYieldTypes[ui] += pPlot->calculateImprovementYieldChange(eImprovement, (YieldTypes)ui, m_pPlayer->GetID(), false /*bOptimal*/);

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+44]
	push	2
	push	0
	push	eax
	mov	eax, DWORD PTR _eImprovement$[esp+84]
	push	esi
	push	eax
	mov	ecx, ebp
	call	?calculateImprovementYieldChange@CvPlot@@QBEHW4ImprovementTypes@@W4YieldTypes@@W4PlayerTypes@@_NW4RouteTypes@@@Z ; CvPlot::calculateImprovementYieldChange
	add	DWORD PTR _aiImprovedYieldTypes$[esp+esi*4+72], eax
	inc	esi
	cmp	esi, 6
	jb	$LL60@IsImprovem

; 2833 : 	}
; 2834 : 
; 2835 : 	if(eYield == NO_YIELD)

	mov	eax, DWORD PTR _eYield$[esp+68]
	cmp	eax, -1
	jne	SHORT $LN13@IsImprovem

; 2836 : 	{
; 2837 : 		// if any of the yields are increased from their natural state, then the improvement is considered a success
; 2838 : 		for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	mov	cl, BYTE PTR _bIsBreakEvenOK$[esp+68]
	xor	eax, eax
	npad	5
$LL12@IsImprovem:

; 2839 : 		{
; 2840 : 			if(bIsBreakEvenOK)
; 2841 : 			{
; 2842 : 				if(aiImprovedYieldTypes[ui] >= aiNaturalYieldTypes[ui])

	mov	edx, DWORD PTR _aiImprovedYieldTypes$[esp+eax+72]
	test	cl, cl
	je	SHORT $LN9@IsImprovem
	cmp	edx, DWORD PTR _aiNaturalYieldTypes$[esp+eax+72]
	jge	SHORT $LN55@IsImprovem

; 2843 : 				{
; 2844 : 					return true;
; 2845 : 				}
; 2846 : 			}
; 2847 : 			else

	jmp	SHORT $LN11@IsImprovem
$LN9@IsImprovem:

; 2848 : 			{
; 2849 : 				if(aiImprovedYieldTypes[ui] > aiNaturalYieldTypes[ui])

	cmp	edx, DWORD PTR _aiNaturalYieldTypes$[esp+eax+72]
	jg	SHORT $LN55@IsImprovem
$LN11@IsImprovem:

; 2836 : 	{
; 2837 : 		// if any of the yields are increased from their natural state, then the improvement is considered a success
; 2838 : 		for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	add	eax, 4
	cmp	eax, 24					; 00000018H
	jb	SHORT $LL12@IsImprovem
	pop	edi
	pop	esi
	pop	ebp

; 2870 : 			}
; 2871 : 		}
; 2872 : 	}
; 2873 : 
; 2874 : 	return false;

	xor	al, al
	pop	ebx

; 2875 : }

	add	esp, 56					; 00000038H
	ret	16					; 00000010H
$LN13@IsImprovem:

; 2850 : 				{
; 2851 : 					return true;
; 2852 : 				}
; 2853 : 			}
; 2854 : 		}
; 2855 : 	}
; 2856 : 	else
; 2857 : 	{
; 2858 : 		if(bIsBreakEvenOK)

	cmp	BYTE PTR _bIsBreakEvenOK$[esp+68], 0
	je	SHORT $LN4@IsImprovem

; 2859 : 		{
; 2860 : 			if(aiImprovedYieldTypes[eYield] >= aiNaturalYieldTypes[eYield])

	mov	ecx, DWORD PTR _aiImprovedYieldTypes$[esp+eax*4+72]
	cmp	ecx, DWORD PTR _aiNaturalYieldTypes$[esp+eax*4+72]
	jl	SHORT $LN1@IsImprovem
$LN55@IsImprovem:
	pop	edi
	pop	esi
	pop	ebp

; 2861 : 			{
; 2862 : 				return true;

	mov	al, 1
	pop	ebx

; 2875 : }

	add	esp, 56					; 00000038H
	ret	16					; 00000010H
$LN4@IsImprovem:

; 2863 : 			}
; 2864 : 		}
; 2865 : 		else
; 2866 : 		{
; 2867 : 			if(aiImprovedYieldTypes[eYield] > aiNaturalYieldTypes[eYield])

	mov	edx, DWORD PTR _aiImprovedYieldTypes$[esp+eax*4+72]
	cmp	edx, DWORD PTR _aiNaturalYieldTypes$[esp+eax*4+72]

; 2868 : 			{
; 2869 : 				return true;

	jg	SHORT $LN55@IsImprovem
$LN1@IsImprovem:
	pop	edi
	pop	esi
	pop	ebp

; 2870 : 			}
; 2871 : 		}
; 2872 : 	}
; 2873 : 
; 2874 : 	return false;

	xor	al, al
	pop	ebx

; 2875 : }

	add	esp, 56					; 00000038H
	ret	16					; 00000010H
?IsImprovementBeneficial@CvBuilderTaskingAI@@QAE_NPAVCvPlot@@ABVCvBuildInfo@@W4YieldTypes@@_N@Z ENDP ; CvBuilderTaskingAI::IsImprovementBeneficial
_TEXT	ENDS
PUBLIC	?DoesBuildHelpRush@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::DoesBuildHelpRush
EXTRN	?getOrderFromQueue@CvCity@@QAEPAUOrderData@@H@Z:PROC ; CvCity::getOrderFromQueue
EXTRN	?getOrderQueueLength@CvCity@@QAEHXZ:PROC	; CvCity::getOrderQueueLength
EXTRN	?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z:PROC ; CvPlot::getFeatureProduction
; Function compile flags: /Ogtpy
;	COMDAT ?DoesBuildHelpRush@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@@Z
_TEXT	SEGMENT
_pCity$ = -4						; size = 4
_pUnit$ = 8						; size = 4
_pPlot$ = 12						; size = 4
_eBuild$ = 16						; size = 4
?DoesBuildHelpRush@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@@Z PROC ; CvBuilderTaskingAI::DoesBuildHelpRush, COMDAT
; _this$ = ecx

; 2914 : {

	push	ecx

; 2915 : 	CvCity* pCity = NULL;
; 2916 : 	int iProduction = pPlot->getFeatureProduction(eBuild, pUnit->getOwner(), &pCity);

	mov	eax, DWORD PTR _pUnit$[esp]
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _eBuild$[esp]
	lea	ecx, DWORD PTR _pCity$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$[esp+4]
	push	eax
	push	edx
	mov	DWORD PTR _pCity$[esp+16], 0
	call	?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ; CvPlot::getFeatureProduction

; 2917 : 	if(iProduction <= 0)

	test	eax, eax
	jg	SHORT $LN4@DoesBuildH
$LN11@DoesBuildH:

; 2918 : 	{
; 2919 : 		return false;

	xor	al, al

; 2935 : 	{
; 2936 : 		// this order should not be rushed
; 2937 : 		return false;
; 2938 : 	}
; 2939 : 
; 2940 : 	return true;
; 2941 : }

	pop	ecx
	ret	12					; 0000000cH
$LN4@DoesBuildH:

; 2920 : 	}
; 2921 : 
; 2922 : 	if(!pCity)

	mov	ecx, DWORD PTR _pCity$[esp+4]
	test	ecx, ecx

; 2923 : 	{
; 2924 : 		// this chop does not benefit any city
; 2925 : 		return false;

	je	SHORT $LN11@DoesBuildH

; 2926 : 	}
; 2927 : 
; 2928 : 	if(pCity->getOrderQueueLength() <= 0)

	call	?getOrderQueueLength@CvCity@@QAEHXZ	; CvCity::getOrderQueueLength
	test	eax, eax

; 2929 : 	{
; 2930 : 		// nothing in the build queue
; 2931 : 		return false;

	jle	SHORT $LN11@DoesBuildH

; 2932 : 	}
; 2933 : 
; 2934 : 	if(!(pCity->getOrderFromQueue(0)->bRush))

	mov	ecx, DWORD PTR _pCity$[esp+4]
	push	0
	call	?getOrderFromQueue@CvCity@@QAEPAUOrderData@@H@Z ; CvCity::getOrderFromQueue
	cmp	BYTE PTR [eax+13], 0
	setne	al

; 2935 : 	{
; 2936 : 		// this order should not be rushed
; 2937 : 		return false;
; 2938 : 	}
; 2939 : 
; 2940 : 	return true;
; 2941 : }

	pop	ecx
	ret	12					; 0000000cH
?DoesBuildHelpRush@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@@Z ENDP ; CvBuilderTaskingAI::DoesBuildHelpRush
_TEXT	ENDS
PUBLIC	?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z ; CvBuilderTaskingAI::LogDirective
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z:PROC
EXTRN	?getNumResource@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumResource
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z$1
__ehfuncinfo$?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z
_TEXT	SEGMENT
_this$ = -72						; size = 4
_strLog$ = -68						; size = 28
_strTemp$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_directive$ = 8						; size = 20
_pUnit$ = 28						; size = 4
_iWeight$ = 32						; size = 4
$T223366 = 36						; size = 4
_bChosen$ = 36						; size = 1
?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z PROC ; CvBuilderTaskingAI::LogDirective, COMDAT
; _this$ = ecx

; 3295 : {

	push	-1
	push	__ehhandler$?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH

; 3296 : 	if(!m_bLogging)

	cmp	BYTE PTR [ecx+58392], 0
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+88], ecx
	je	$LN23@LogDirecti

; 3297 : 	{
; 3298 : 		return;
; 3299 : 	}
; 3300 : 
; 3301 : 	CvString strLog;

	lea	ecx, DWORD PTR _strLog$[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3302 : 	CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3303 : 
; 3304 : 	strTemp.Format("%d,", pUnit->GetID()); // unit id

	mov	eax, DWORD PTR _pUnit$[esp+84]
	mov	eax, DWORD PTR [eax+100]
	push	eax
	lea	ecx, DWORD PTR _strTemp$[esp+92]
	push	OFFSET $SG219201
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+108], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 3305 : 	strLog += strTemp;

	lea	edx, DWORD PTR _strTemp$[esp+88]
	push	edx
	lea	ecx, DWORD PTR _strLog$[esp+92]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3306 : 
; 3307 : 	strLog += "Evaluating,";

	push	OFFSET $SG219202
	lea	ecx, DWORD PTR _strLog$[esp+92]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3308 : 
; 3309 : 	switch(directive.m_eDirective)

	mov	eax, DWORD PTR _directive$[esp+84]
	cmp	eax, 4
	ja	SHORT $LN20@LogDirecti
	jmp	DWORD PTR $LN197@LogDirecti[eax*4]
$LN19@LogDirecti:

; 3310 : 	{
; 3311 : 	case BuilderDirective::BUILD_IMPROVEMENT_ON_RESOURCE:
; 3312 : 		strLog += "BUILD_IMPROVEMENT_ON_RESOURCE,";

	push	OFFSET $SG219208

; 3313 : 		break;

	jmp	SHORT $LN191@LogDirecti
$LN18@LogDirecti:

; 3314 : 	case BuilderDirective::BUILD_IMPROVEMENT:
; 3315 : 		strLog += "BUILD_IMPROVEMENT,";

	push	OFFSET $SG219210

; 3316 : 		break;

	jmp	SHORT $LN191@LogDirecti
$LN17@LogDirecti:

; 3317 : 	case BuilderDirective::REPAIR:
; 3318 : 		strLog += "REPAIR,";

	push	OFFSET $SG219212

; 3319 : 		break;

	jmp	SHORT $LN191@LogDirecti
$LN16@LogDirecti:

; 3320 : 	case BuilderDirective::BUILD_ROUTE:
; 3321 : 		strLog += "BUILD_ROUTE,";

	push	OFFSET $SG219214

; 3322 : 		break;

	jmp	SHORT $LN191@LogDirecti
$LN15@LogDirecti:

; 3323 : 	case BuilderDirective::CHOP:
; 3324 : 		strLog += "CHOP";

	push	OFFSET $SG219216
$LN191@LogDirecti:
	lea	ecx, DWORD PTR _strLog$[esp+92]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN20@LogDirecti:

; 3325 : 	}
; 3326 : 
; 3327 : 	strLog += GC.getBuildInfo(directive.m_eBuild)->GetType();

	mov	eax, DWORD PTR _directive$[esp+88]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLog$[esp+92]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3328 : 	strLog += ",";

	push	OFFSET $SG219217
	lea	ecx, DWORD PTR _strLog$[esp+92]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3329 : 
; 3330 : 	if(directive.m_eResource != NO_RESOURCE)

	mov	eax, DWORD PTR _directive$[esp+92]
	cmp	eax, -1
	je	$LN14@LogDirecti

; 3331 : 	{
; 3332 : 		CvResourceInfo* pkResourceInfo = GC.getResourceInfo(directive.m_eResource);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 3333 : 		if(pkResourceInfo)

	test	eax, eax
	je	$LN12@LogDirecti

; 3334 : 		{
; 3335 : 			strLog += pkResourceInfo->GetType();

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLog$[esp+92]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3336 : 			strLog += ",";

	push	OFFSET $SG219221
	lea	ecx, DWORD PTR _strLog$[esp+92]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3337 : 			CvPlot* pPlot = GC.getMap().plot(directive.m_sX, directive.m_sY);

	movsx	eax, WORD PTR _directive$[esp+96]
	movsx	ebp, WORD PTR _directive$[esp+98]
	cmp	eax, -2147483647			; 80000001H
	je	$LN44@LogDirecti
	cmp	ebp, -2147483647			; 80000001H
	je	SHORT $LN44@LogDirecti
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	dl, dl
	je	SHORT $LN54@LogDirecti
	test	eax, eax
	jge	SHORT $LN56@LogDirecti
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN58@LogDirecti
$LN56@LogDirecti:
	cmp	eax, ecx
	jl	SHORT $LN54@LogDirecti
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN58@LogDirecti
$LN54@LogDirecti:
	mov	esi, eax
$LN58@LogDirecti:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN64@LogDirecti
	test	ebp, ebp
	jge	SHORT $LN66@LogDirecti
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN68@LogDirecti
$LN66@LogDirecti:
	cmp	ebp, edi
	jl	SHORT $LN64@LogDirecti
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN68@LogDirecti
$LN64@LogDirecti:
	mov	edx, ebp
$LN68@LogDirecti:
	test	esi, esi
	jl	SHORT $LN44@LogDirecti
	cmp	esi, ecx
	jge	SHORT $LN44@LogDirecti
	test	edx, edx
	jl	SHORT $LN44@LogDirecti
	cmp	edx, edi
	jge	SHORT $LN44@LogDirecti
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	jmp	SHORT $LN46@LogDirecti
$LN44@LogDirecti:
	xor	ecx, ecx
$LN46@LogDirecti:

; 3338 : #ifdef AUI_WARNING_FIXES
; 3339 : 			strTemp.Format("%d,", pPlot->getNumResource());
; 3340 : 			strLog += strTemp;
; 3341 : #else
; 3342 : 			strLog += pPlot->getNumResource();

	call	?getNumResource@CvPlot@@QBEHXZ		; CvPlot::getNumResource
	push	eax
	lea	ecx, DWORD PTR _strLog$[esp+92]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z

; 3343 : #endif
; 3344 : 			strLog += ",";

	push	OFFSET $SG219223

; 3345 : 		}
; 3346 : 	}
; 3347 : 	else

	jmp	SHORT $LN192@LogDirecti
$LN14@LogDirecti:

; 3348 : 	{
; 3349 : 		strLog += ",";

	push	OFFSET $SG219225
$LN192@LogDirecti:
	lea	ecx, DWORD PTR _strLog$[esp+92]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN12@LogDirecti:

; 3350 : 	}
; 3351 : 
; 3352 : 	if(directive.m_eDirective == BuilderDirective::REPAIR)

	cmp	DWORD PTR _directive$[esp+84], 3

; 3353 : 	{
; 3354 : 		CvPlot* pPlot = GC.getMap().plot(directive.m_sX, directive.m_sY);

	movsx	ebp, WORD PTR _directive$[esp+98]
	movsx	eax, WORD PTR _directive$[esp+96]
	jne	$LN11@LogDirecti
	cmp	eax, -2147483647			; 80000001H
	je	$LN84@LogDirecti
	cmp	ebp, -2147483647			; 80000001H
	je	SHORT $LN84@LogDirecti
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	dl, dl
	je	SHORT $LN94@LogDirecti
	test	eax, eax
	jge	SHORT $LN96@LogDirecti
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN98@LogDirecti
$LN96@LogDirecti:
	cmp	eax, ecx
	jl	SHORT $LN94@LogDirecti
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN98@LogDirecti
$LN94@LogDirecti:
	mov	esi, eax
$LN98@LogDirecti:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN104@LogDirecti
	test	ebp, ebp
	jge	SHORT $LN106@LogDirecti
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN108@LogDirecti
$LN106@LogDirecti:
	cmp	ebp, edi
	jl	SHORT $LN104@LogDirecti
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN108@LogDirecti
$LN104@LogDirecti:
	mov	edx, ebp
$LN108@LogDirecti:
	test	esi, esi
	jl	SHORT $LN84@LogDirecti
	cmp	esi, ecx
	jge	SHORT $LN84@LogDirecti
	test	edx, edx
	jl	SHORT $LN84@LogDirecti
	cmp	edx, edi
	jge	SHORT $LN84@LogDirecti
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	mov	esi, ecx
	jmp	SHORT $LN86@LogDirecti
$LN84@LogDirecti:
	xor	esi, esi
$LN86@LogDirecti:

; 3355 : 		if(pPlot->IsImprovementPillaged())

	mov	ecx, esi
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged

; 3356 : 		{
; 3357 : 			if(pPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, esi
	test	al, al

; 3358 : 			{
; 3359 : 				CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(pPlot->getImprovementType());
; 3360 : 				if(pkImprovementInfo)
; 3361 : 				{
; 3362 : 					strLog += pkImprovementInfo->GetType();
; 3363 : 				}
; 3364 : 			}
; 3365 : 		}
; 3366 : 		else

	jne	$LN195@LogDirecti

; 3367 : 		{
; 3368 : 			if(pPlot->getRouteType() != NO_ROUTE)

	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, -1
	je	$LN2@LogDirecti

; 3369 : 			{
; 3370 : 				CvRouteInfo* pkRouteInfo = GC.getRouteInfo(pPlot->getRouteType());

	mov	ecx, esi
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo

; 3371 : 				if(pkRouteInfo)
; 3372 : 				{
; 3373 : 					strLog += pkRouteInfo->GetType();
; 3374 : 				}
; 3375 : 			}
; 3376 : 		}
; 3377 : 	}
; 3378 : 	else

	jmp	$LN196@LogDirecti
$LN11@LogDirecti:

; 3379 : 	{
; 3380 : 		CvPlot* pPlot = GC.getMap().plot(directive.m_sX, directive.m_sY);

	cmp	eax, -2147483647			; 80000001H
	je	$LN128@LogDirecti
	cmp	ebp, -2147483647			; 80000001H
	je	SHORT $LN128@LogDirecti
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	dl, dl
	je	SHORT $LN138@LogDirecti
	test	eax, eax
	jge	SHORT $LN140@LogDirecti
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN142@LogDirecti
$LN140@LogDirecti:
	cmp	eax, ecx
	jl	SHORT $LN138@LogDirecti
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN142@LogDirecti
$LN138@LogDirecti:
	mov	esi, eax
$LN142@LogDirecti:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN148@LogDirecti
	test	ebp, ebp
	jge	SHORT $LN150@LogDirecti
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN152@LogDirecti
$LN150@LogDirecti:
	cmp	ebp, edi
	jl	SHORT $LN148@LogDirecti
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN152@LogDirecti
$LN148@LogDirecti:
	mov	edx, ebp
$LN152@LogDirecti:
	test	esi, esi
	jl	SHORT $LN128@LogDirecti
	cmp	esi, ecx
	jge	SHORT $LN128@LogDirecti
	test	edx, edx
	jl	SHORT $LN128@LogDirecti
	cmp	edx, edi
	jge	SHORT $LN128@LogDirecti
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	mov	esi, ecx
	jmp	SHORT $LN130@LogDirecti
$LN128@LogDirecti:
	xor	esi, esi
$LN130@LogDirecti:

; 3381 : 		if(pPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, esi
$LN195@LogDirecti:
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN2@LogDirecti

; 3382 : 		{
; 3383 : 			CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(pPlot->getImprovementType());

	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
$LN196@LogDirecti:

; 3384 : 			if(pkImprovementInfo)

	test	eax, eax
	je	SHORT $LN2@LogDirecti

; 3385 : 			{
; 3386 : 				strLog += pkImprovementInfo->GetType();

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLog$[esp+92]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@LogDirecti:

; 3387 : 			}
; 3388 : 		}
; 3389 : 	}
; 3390 : 	strLog += ",";

	push	OFFSET $SG219241
	lea	ecx, DWORD PTR _strLog$[esp+92]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3391 : 
; 3392 : 	strTemp.Format("%d,%d,", directive.m_sX, directive.m_sY);

	movsx	ecx, WORD PTR _directive$[esp+98]
	movsx	edx, WORD PTR _directive$[esp+96]
	push	ecx
	push	edx
	lea	eax, DWORD PTR _strTemp$[esp+96]
	push	OFFSET $SG219242
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3393 : 	strLog += strTemp;

	lea	ecx, DWORD PTR _strTemp$[esp+88]
	push	ecx
	lea	ecx, DWORD PTR _strLog$[esp+92]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3394 : 
; 3395 : 	strTemp.Format("%d,", directive.m_sMoveTurnsAway);

	movsx	edx, WORD PTR _directive$[esp+100]
	push	edx
	lea	eax, DWORD PTR _strTemp$[esp+92]
	push	OFFSET $SG219243
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 3396 : 	strLog += strTemp;

	lea	ecx, DWORD PTR _strTemp$[esp+88]
	push	ecx
	lea	ecx, DWORD PTR _strLog$[esp+92]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3397 : 
; 3398 : 	strTemp.Format("%d,", iWeight);

	mov	edx, DWORD PTR _iWeight$[esp+84]
	push	edx
	lea	eax, DWORD PTR _strTemp$[esp+92]
	push	OFFSET $SG219244
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 3399 : 	strLog += strTemp;

	lea	ecx, DWORD PTR _strTemp$[esp+88]
	push	ecx
	lea	ecx, DWORD PTR _strLog$[esp+92]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3400 : 
; 3401 : 	if(bChosen)

	cmp	BYTE PTR _bChosen$[esp+84], 0
	je	SHORT $LN1@LogDirecti

; 3402 : 	{
; 3403 : 		strLog += (", Chosen!");

	push	OFFSET $SG219246
	lea	ecx, DWORD PTR _strLog$[esp+92]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN1@LogDirecti:

; 3404 : 	}
; 3405 : 
; 3406 : 	LogInfo(strLog, m_pPlayer, GET_PLAYER(pUnit->getOwner()).isHuman());

	mov	edx, DWORD PTR _pUnit$[esp+84]
	mov	eax, DWORD PTR [edx+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	mov	ecx, DWORD PTR _this$[esp+88]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, al
	push	eax
	push	edx
	sub	esp, 28					; 0000001cH
	lea	eax, DWORD PTR _strLog$[esp+124]
	mov	DWORD PTR $T223366[esp+120], esp
	mov	ecx, esp
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 3407 : }

	lea	ecx, DWORD PTR _strTemp$[esp+88]
	mov	BYTE PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLog$[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN23@LogDirecti:
	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 72					; 00000048H
	ret	32					; 00000020H
	npad	1
$LN197@LogDirecti:
	DD	$LN19@LogDirecti
	DD	$LN18@LogDirecti
	DD	$LN16@LogDirecti
	DD	$LN17@LogDirecti
	DD	$LN15@LogDirecti
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z$0:
	lea	ecx, DWORD PTR _strLog$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z$1:
	lea	ecx, DWORD PTR _strTemp$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z ENDP ; CvBuilderTaskingAI::LogDirective
PUBLIC	?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::UpdateProjectedPlotYields
EXTRN	?getYieldWithBuild@CvPlot@@QBEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z:PROC ; CvPlot::getYieldWithBuild
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z$1
__ehfuncinfo$?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z
_TEXT	SEGMENT
_yield$219282 = -76					; size = 4
$T223775 = -72						; size = 4
_strLog$219281 = -68					; size = 28
$T223774 = -40						; size = 28
__$EHRec$ = -12						; size = 12
$T223773 = 8						; size = 4
_pPlot$ = 8						; size = 4
_eBuild$ = 12						; size = 4
?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z PROC ; CvBuilderTaskingAI::UpdateProjectedPlotYields, COMDAT
; _this$ = ecx

; 3428 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	ebp

; 3429 : 	if(pPlot != m_pTargetPlot)

	mov	ebp, DWORD PTR _pPlot$[esp+80]
	mov	ebx, ecx
	push	esi
	push	edi
	cmp	ebp, DWORD PTR [ebx+58400]
	je	SHORT $LN5@UpdateProj

; 3430 : 	{
; 3431 : 		UpdateCurrentPlotYields(pPlot);

	push	ebp
	call	?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z ; CvBuilderTaskingAI::UpdateCurrentPlotYields
$LN5@UpdateProj:

; 3432 : 	}
; 3433 : 
; 3434 : 	for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	xor	edi, edi

; 3435 : 	{
; 3436 : 		m_aiProjectedPlotYields[ui] = pPlot->getYieldWithBuild(eBuild, (YieldTypes)ui, false, m_pPlayer->GetID());
; 3437 : 		m_aiProjectedPlotYields[ui] = max(m_aiProjectedPlotYields[ui], 0);

	mov	DWORD PTR $T223773[esp+88], edi
	lea	esi, DWORD PTR [ebx+58428]
$LN4@UpdateProj:
	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _eBuild$[esp+88]
	push	eax
	push	0
	push	edi
	push	ecx
	mov	ecx, ebp
	call	?getYieldWithBuild@CvPlot@@QBEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z ; CvPlot::getYieldWithBuild
	mov	DWORD PTR [esi], eax
	test	eax, eax
	lea	eax, DWORD PTR $T223773[esp+88]
	jl	SHORT $LN18@UpdateProj
	mov	eax, esi
$LN18@UpdateProj:
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [esi], edx

; 3438 : #ifdef AUI_WORKER_FIX_CELTIC_IMPROVE_UNIMPROVED_FORESTS
; 3439 : 		if (ui == YIELD_FAITH && m_pPlayer->GetPlayerTraits()->IsFaithFromUnimprovedForest() && pPlot->getImprovementType() == NO_IMPROVEMENT)
; 3440 : 		{
; 3441 : 			CvBuildInfo* pBuildInfo = GC.getBuildInfo(eBuild);
; 3442 : 			if (pBuildInfo && (pBuildInfo->getImprovement() != NO_IMPROVEMENT || pBuildInfo->isFeatureRemove(FEATURE_FOREST)))
; 3443 : 			{
; 3444 : 				CvCity* pNextCity = pPlot->GetAdjacentCity();
; 3445 : 				if (pNextCity && pNextCity->getOwner() == m_pPlayer->GetID())
; 3446 : 				{
; 3447 : 					int iNeighboringForestCount = 1;
; 3448 : 					CvPlot* pAdjacentPlot = NULL;
; 3449 : 					for (int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
; 3450 : 					{
; 3451 : 						pAdjacentPlot = pNextCity->plot()->getNeighboringPlot((DirectionTypes)iI);
; 3452 : 						if (pAdjacentPlot && pAdjacentPlot != pPlot && pAdjacentPlot->getFeatureType() == FEATURE_FOREST && pPlot->getImprovementType() == NO_IMPROVEMENT)
; 3453 : 						{
; 3454 : 							ResourceTypes eAdjacentResource = pPlot->getResourceType(m_pPlayer->getTeam());
; 3455 : 							if (eAdjacentResource == NO_RESOURCE || GC.getResourceInfo(eAdjacentResource)->getResourceUsage() == RESOURCEUSAGE_BONUS)
; 3456 : 							{
; 3457 : 								iNeighboringForestCount++;
; 3458 : 							}
; 3459 : 						}
; 3460 : 					}
; 3461 : 					if (iNeighboringForestCount == 3 || iNeighboringForestCount == 1)
; 3462 : 					{
; 3463 : 						m_aiProjectedPlotYields[YIELD_FAITH] -= 1;
; 3464 : 					}
; 3465 : 				}
; 3466 : 			}
; 3467 : 		}
; 3468 : #endif
; 3469 : 
; 3470 : 		if(m_bLogging){

	cmp	BYTE PTR [ebx+58392], 0
	je	$LN3@UpdateProj

; 3471 : 			CvString strLog;

	lea	ecx, DWORD PTR _strLog$219281[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3472 : 			YieldTypes yield = (YieldTypes) ui;
; 3473 : 			strLog.Format("Plot Projected Yield Update, %s, %i, %i, %i", FSerialization::toString(yield).c_str(), m_aiProjectedPlotYields[ui], pPlot->getX(), pPlot->getY());

	lea	eax, DWORD PTR _yield$219282[esp+92]
	push	eax
	lea	ecx, DWORD PTR $T223774[esp+96]
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+108], 0
	mov	DWORD PTR _yield$219282[esp+100], edi
	call	?toString@FSerialization@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABW4YieldTypes@@@Z ; FSerialization::toString
	add	esp, 8
	movsx	ecx, WORD PTR [ebp+2]
	movsx	edx, WORD PTR [ebp]
	push	ecx
	push	edx
	mov	edx, DWORD PTR [esi]
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+112], 1
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLog$219281[esp+108]
	push	OFFSET $SG219285
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H
	lea	ecx, DWORD PTR $T223774[esp+92]
	mov	BYTE PTR __$EHRec$[esp+100], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3474 : 			LogYieldInfo(strLog, m_pPlayer);

	mov	ecx, DWORD PTR [ebx]
	push	ecx
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strLog$219281[esp+124]
	mov	DWORD PTR $T223775[esp+124], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z ; CvBuilderTaskingAI::LogYieldInfo
	add	esp, 32					; 00000020H

; 3475 : 		}

	lea	ecx, DWORD PTR _strLog$219281[esp+92]
	mov	DWORD PTR __$EHRec$[esp+100], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@UpdateProj:
	inc	edi
	add	esi, 4
	cmp	edi, 6
	jb	$LN4@UpdateProj

; 3476 : 	}
; 3477 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+92]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 76					; 0000004cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z$0:
	lea	ecx, DWORD PTR _strLog$219281[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z$1:
	lea	ecx, DWORD PTR $T223774[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z ENDP ; CvBuilderTaskingAI::UpdateProjectedPlotYields
PUBLIC	?push_back@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAEIABH@Z ; FStaticVector<int,14592,1,297,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAEIABH@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAEIABH@Z PROC ; FStaticVector<int,14592,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+58380], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,14592,1,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAEIABH@Z ENDP ; FStaticVector<int,14592,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?GetWeight@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QBEHI@Z ; CvWeightedVector<BuilderDirective,100,1>::GetWeight
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?GetWeight@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QBEHI@Z
_TEXT	SEGMENT
_elem$ = -24						; size = 24
_iIndex$ = 8						; size = 4
?GetWeight@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QBEHI@Z PROC ; CvWeightedVector<BuilderDirective,100,1>::GetWeight, COMDAT
; _this$ = ecx

; 70   : 	{

	sub	esp, 24					; 00000018H

; 71   : 		WeightedElement elem;
; 72   : 		assert(iIndex < m_pItems.size());
; 73   : 		elem = m_pItems[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp+20]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	mov	edx, DWORD PTR [ecx+eax*8]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _elem$[esp+24], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _elem$[esp+28], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _elem$[esp+32], edx
	mov	edx, DWORD PTR [eax+16]

; 74   : 		return elem.m_iWeight;

	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _elem$[esp+36], ecx
	mov	DWORD PTR _elem$[esp+40], edx

; 75   : 	}

	add	esp, 24					; 00000018H
	ret	4
?GetWeight@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QBEHI@Z ENDP ; CvWeightedVector<BuilderDirective,100,1>::GetWeight
_TEXT	ENDS
PUBLIC	?clear@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEXXZ ; CvWeightedVector<BuilderDirective,100,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEXXZ PROC ; CvWeightedVector<BuilderDirective,100,1>::clear, COMDAT
; _this$ = ecx

; 116  : 		m_pItems.clear();

	mov	DWORD PTR [ecx+4], 0

; 117  : 	};

	ret	0
?clear@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEXXZ ENDP ; CvWeightedVector<BuilderDirective,100,1>::clear
_TEXT	ENDS
PUBLIC	?resize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEXI@Z ; FStaticVector<int,64,1,297,0>::resize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?resize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEXI@Z
_TEXT	SEGMENT
_uiNewSize$ = 8						; size = 4
?resize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEXI@Z PROC ; FStaticVector<int,64,1,297,0>::resize, COMDAT
; _this$ = ecx

; 666  : 	{

	push	esi
	push	edi

; 667  : 		if( m_uiCurrMaxSize < uiNewSize ){

	mov	edi, DWORD PTR _uiNewSize$[esp+4]
	mov	esi, ecx
	cmp	DWORD PTR [esi+8], edi
	jae	SHORT $LN4@resize

; 668  : 			GrowSize(uiNewSize);

	push	edi
	call	?GrowSize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,64,1,297,0>::GrowSize
$LN4@resize:

; 669  : 		}
; 670  : 		m_uiCurrSize = uiNewSize;

	mov	DWORD PTR [esi+4], edi
	pop	edi
	pop	esi

; 671  : 	};

	ret	4
?resize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEXI@Z ENDP ; FStaticVector<int,64,1,297,0>::resize
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEIABH@Z ; FStaticVector<int,64,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEIABH@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEIABH@Z PROC ; FStaticVector<int,64,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+268], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,64,1,297,0>::GrowSize
$LN1@push_back@2:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back@2
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEIABH@Z ENDP ; FStaticVector<int,64,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@3:

; 619  : 	};

	ret	0
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN33@GrowSize@3
	mov	DWORD PTR [esi+8], 1
$LN33@GrowSize@3:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@3
	npad	6
$LL8@GrowSize@3:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN34@GrowSize@3

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@3

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@3
$LN34@GrowSize@3:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@3:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 100				; 00000064H
	jbe	SHORT $LN16@GrowSize@3
	push	798					; 0000031eH
	lea	eax, DWORD PTR [ebp+ebp*2]
	add	eax, eax
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN15@GrowSize@3
$LN16@GrowSize@3:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 100			; 00000064H
$LN15@GrowSize@3:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+eax*2]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN36@GrowSize@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN36@GrowSize@3:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+2412], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::GrowSize
_TEXT	ENDS
PUBLIC	?_Maxlen@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEHXZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Maxlen
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Maxlen@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEHXZ
_TEXT	SEGMENT
__Pair$219775 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@Maxlen
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jle	SHORT $LN5@Maxlen

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	push	eax
	lea	eax, DWORD PTR __Pair$219775[esp+16]
	push	eax
	call	??$get_temporary_buffer@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@0@H@Z ; std::get_temporary_buffer<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$219775[esp+20]
	mov	DWORD PTR [ecx], eax

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx+4], eax

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+8], eax

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$219775[esp+24]
	mov	DWORD PTR [edx+12], eax

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+12]
	add	esp, 8
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN4@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, eax
	mov	eax, DWORD PTR [edx+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN5@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
?_Maxlen@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Maxlen
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z
_TEXT	SEGMENT
__Val$219987 = -24					; size = 24
$T223989 = 8						; size = 1
__First$ = 8						; size = 4
__Cat$223993 = 12					; size = 1
$T223991 = 12						; size = 1
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __Last$[esp-4]
	sub	esp, 24					; 00000018H
	push	edi
	mov	edi, DWORD PTR __First$[esp+24]
	cmp	edi, eax
	je	$LN6@Insertion_
	push	esi

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	esi, DWORD PTR [edi+24]
	cmp	esi, eax
	je	$LN26@Insertion_
	push	ebx
	push	ebp
$LL7@Insertion_:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	mov	ebp, DWORD PTR [esi+20]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	ebp, DWORD PTR [edi+20]
	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR __Val$219987[esp+44], ecx
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __Val$219987[esp+48], edx
	mov	edx, DWORD PTR [esi+16]
	mov	eax, esi
	mov	DWORD PTR __Val$219987[esp+52], ecx
	mov	DWORD PTR __Val$219987[esp+56], edx
	jle	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	ecx, DWORD PTR __Cat$223993[esp+36]
	mov	edx, DWORD PTR $T223991[esp+36]
	mov	BYTE PTR $T223989[esp+36], 0
	mov	eax, DWORD PTR $T223989[esp+36]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR [esi+24]
	push	eax
	push	esi
	push	edi
	call	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>

; 2977 : 				*_First = _Val;

	mov	ecx, DWORD PTR __Val$219987[esp+68]
	mov	edx, DWORD PTR __Val$219987[esp+72]
	mov	eax, DWORD PTR __Val$219987[esp+76]
	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], ecx
	mov	ecx, DWORD PTR __Val$219987[esp+80]
	mov	DWORD PTR [edi+8], edx
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi+16], ecx
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+20], ebp

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	ebp, DWORD PTR [esi-4]
	lea	ecx, DWORD PTR [esi-24]
	jle	SHORT $LN1@Insertion_
$LL3@Insertion_:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, ecx
	sub	ecx, 24					; 00000018H
	cmp	ebp, DWORD PTR [ecx+20]
	jg	SHORT $LL3@Insertion_
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	ecx, DWORD PTR __Val$219987[esp+44]
	mov	edx, DWORD PTR __Val$219987[esp+48]
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR __Val$219987[esp+52]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR __Val$219987[esp+56]
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+20], ebp
$LN4@Insertion_:
	add	esi, 24					; 00000018H
	cmp	esi, DWORD PTR __Last$[esp+36]
	jne	$LL7@Insertion_
	pop	ebp
	pop	ebx
$LN26@Insertion_:
	pop	esi
$LN6@Insertion_:
	pop	edi

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Unchecked_merge_backward@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000@Z ; stdext::_Unchecked_merge_backward<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_merge_backward@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000@Z
_TEXT	SEGMENT
$T224011 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
??$_Unchecked_merge_backward@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000@Z PROC ; stdext::_Unchecked_merge_backward<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>, COMDAT

; 5202 : 	{

	push	ecx

; 5203 : 		return _STD _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Dest$[esp]
	mov	edx, DWORD PTR __Last2$[esp]
	mov	BYTE PTR $T224011[esp+4], 0
	mov	eax, DWORD PTR $T224011[esp+4]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First1$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Merge_backward@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>

; 5204 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_merge_backward@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000@Z ENDP ; stdext::_Unchecked_merge_backward<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$lower_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@@Z ; std::lower_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$lower_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$lower_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@@Z PROC ; std::lower_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 2276 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Lower_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z ; std::_Lower_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement,int>
	add	esp, 16					; 00000010H

; 2277 : 		_Lower_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2278 : 	return _First;
; 2279 : 	}

	ret	0
??$lower_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@@Z ENDP ; std::lower_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$upper_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@@Z ; std::upper_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$upper_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$upper_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@@Z PROC ; std::upper_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 2347 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Upper_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z ; std::_Upper_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement,int>
	add	esp, 16					; 00000010H

; 2348 : 		_Upper_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2349 : 	return _First;
; 2350 : 	}

	ret	0
??$upper_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@@Z ENDP ; std::upper_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T224029 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ecx
	push	ebx
	push	esi

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	esi, DWORD PTR __First$[esp+8]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+12]
	xor	ebx, ebx
	mov	DWORD PTR $T224029[esp+16], ebx
	cmp	esi, edi
	je	SHORT $LN1@Copy_opt@2
$LL3@Copy_opt@2:

; 2472 : 		*_Dest = *_First;

	push	esi
	lea	ecx, DWORD PTR __Dest$[esp+16]
	call	??4?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@ABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator=
	add	esi, 24					; 00000018H
	cmp	esi, edi
	jne	SHORT $LL3@Copy_opt@2
$LN1@Copy_opt@2:

; 2473 : 	return (_Dest);

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	eax, DWORD PTR __Dest$[esp+28]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], ebx
	cmp	eax, ebx
	je	SHORT $LN31@Copy_opt@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN31@Copy_opt@2:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 2474 : 	}

	pop	ecx
	ret	0
??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	edx, DWORD PTR __First1$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Last1$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Last2$[esp+8]
	cmp	edx, esi
	je	$LN16@Merge
	npad	1
$LL5@Merge:
	cmp	ecx, edi
	je	SHORT $LN3@Merge

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	ebx, DWORD PTR [ecx+20]
	cmp	ebx, DWORD PTR [edx+20]
	jle	SHORT $LN2@Merge

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebx
	mov	ebx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ebx
	mov	ebx, DWORD PTR [ecx+20]
	add	ecx, 24					; 00000018H

; 2516 : 		else

	jmp	SHORT $LN40@Merge
$LN2@Merge:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ebx
	mov	ebx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], ebx
	mov	ebx, DWORD PTR [edx+20]
	add	edx, 24					; 00000018H
$LN40@Merge:
	mov	DWORD PTR [eax+20], ebx
	add	eax, 24					; 00000018H
	cmp	edx, esi
	jne	SHORT $LL5@Merge
$LN3@Merge:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	cmp	edx, esi
	je	SHORT $LN16@Merge
$LL18@Merge:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ebx
	mov	ebx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], ebx
	mov	ebx, DWORD PTR [edx+20]
	mov	DWORD PTR [eax+20], ebx
	add	edx, 24					; 00000018H
	add	eax, 24					; 00000018H
	cmp	edx, esi
	jne	SHORT $LL18@Merge
$LN16@Merge:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	cmp	ecx, edi
	je	SHORT $LN27@Merge
$LL29@Merge:
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	add	ecx, 24					; 00000018H
	add	eax, 24					; 00000018H
	cmp	ecx, edi
	jne	SHORT $LL29@Merge
$LN27@Merge:
	pop	edi
	pop	esi
	pop	ebx

; 2521 : 	}

	ret	0
??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z ; std::rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z PROC ; std::rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>, COMDAT

; 1719 : 	if (_First != _Mid && _Mid != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Mid$[esp-4]
	cmp	edx, eax
	je	SHORT $LN6@rotate
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN6@rotate

; 1720 : 		_Rotate(_CHECKED_BASE(_First), _CHECKED_BASE(_Mid), _CHECKED_BASE(_Last), _Iter_cat(_First));

	push	0
	push	0
	push	ecx
	push	eax
	push	edx
	call	??$_Rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00PAH0@Z ; std::_Rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN6@rotate:

; 1721 : 	}

	ret	0
??$rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z ENDP ; std::rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?Read@CvBuilderTaskingAI@@QAEXAAVFDataStream@@@Z ; CvBuilderTaskingAI::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4BuildTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
;	COMDAT ?Read@CvBuilderTaskingAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_uiNumSlots$ = 8					; size = 4
_kStream$ = 8						; size = 4
?Read@CvBuilderTaskingAI@@QAEXAAVFDataStream@@@Z PROC	; CvBuilderTaskingAI::Read, COMDAT
; _this$ = ecx

; 124  : {

	push	ecx
	push	ebp
	push	esi
	push	edi

; 125  : 	// Version number to maintain backwards compatibility
; 126  : 	uint uiVersion;
; 127  : 	kStream >> uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+12]
	lea	eax, DWORD PTR _uiVersion$[esp+16]
	mov	ebp, ecx
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 128  : 
; 129  : 	kStream >> m_eRepairBuild;

	lea	ecx, DWORD PTR [ebp+4]
	push	ecx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4BuildTypes@@@Z ; operator>>
	add	esp, 8

; 130  : 
; 131  : 	uint uiNumSlots;
; 132  : 
; 133  : 	// non-territory plots
; 134  : 	kStream >> uiNumSlots;

	lea	edx, DWORD PTR _uiNumSlots$[esp+12]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 135  : 	m_aiNonTerritoryPlots.resize(uiNumSlots);

	mov	eax, DWORD PTR _uiNumSlots$[esp+12]
	mov	esi, eax
	cmp	DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+8, eax
	jae	SHORT $LN12@Read
	push	eax
	mov	ecx, OFFSET ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A ; CvBuilderTaskingAI::m_aiNonTerritoryPlots
	call	?GrowSize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,64,1,297,0>::GrowSize
	mov	eax, DWORD PTR _uiNumSlots$[esp+12]
$LN12@Read:
	mov	DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+4, esi

; 136  : 
; 137  : 	for(uint ui = 0; ui < uiNumSlots; ui++)

	xor	esi, esi
	test	eax, eax
	jbe	SHORT $LN3@Read
	npad	8
$LL5@Read:
	mov	eax, DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A
	lea	ecx, DWORD PTR [eax+esi*4]

; 138  : 	{
; 139  : 		kStream >> m_aiNonTerritoryPlots[ui];

	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	inc	esi
	cmp	esi, DWORD PTR _uiNumSlots$[esp+12]
	jb	SHORT $LL5@Read
$LN3@Read:

; 140  : 	}
; 141  : 
; 142  : #ifndef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 143  : 	kStream >> m_bKeepMarshes;

	lea	edx, DWORD PTR [ebp+58460]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 144  : 	if (uiVersion >= 2)

	cmp	DWORD PTR _uiVersion$[esp+16], 2
	jb	SHORT $LN2@Read

; 145  : 	{
; 146  : 		kStream >> m_bKeepJungle;

	lea	eax, DWORD PTR [ebp+58461]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 147  : 	}
; 148  : 	else

	jmp	SHORT $LN25@Read
$LN2@Read:

; 149  : 	{
; 150  : 		m_bKeepJungle = false;

	mov	BYTE PTR [ebp+58461], 0
$LN25@Read:
	pop	edi
	pop	esi

; 151  : 	}
; 152  : #endif
; 153  : 		
; 154  : 	m_iNumCities = -1; //Force everyone to do an CvBuilderTaskingAI::Update() after loading
; 155  : 	m_pTargetPlot = NULL;		//Force everyone to recalculate current yields after loading.

	mov	DWORD PTR [ebp+58400], 0
	mov	DWORD PTR [ebp+58396], -1
	pop	ebp

; 156  : }

	pop	ecx
	ret	4
?Read@CvBuilderTaskingAI@@QAEXAAVFDataStream@@@Z ENDP	; CvBuilderTaskingAI::Read
_TEXT	ENDS
PUBLIC	?ConnectCitiesToCapital@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z ; CvBuilderTaskingAI::ConnectCitiesToCapital
EXTRN	?SetBuilderAIScratchPadPlayer@CvPlot@@QAEXW4PlayerTypes@@@Z:PROC ; CvPlot::SetBuilderAIScratchPadPlayer
EXTRN	?SetBuilderAIScratchPadTurn@CvPlot@@QAEXF@Z:PROC ; CvPlot::SetBuilderAIScratchPadTurn
EXTRN	?SetBuilderAIScratchPadRoute@CvPlot@@QAEXW4RouteTypes@@@Z:PROC ; CvPlot::SetBuilderAIScratchPadRoute
EXTRN	?SetBuilderAIScratchPadValue@CvPlot@@QAEXF@Z:PROC ; CvPlot::SetBuilderAIScratchPadValue
EXTRN	?GetBuilderAIScratchPadValue@CvPlot@@QBEFXZ:PROC ; CvPlot::GetBuilderAIScratchPadValue
EXTRN	?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ:PROC ; CvPlot::GetBuilderAIScratchPadPlayer
EXTRN	?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ:PROC	; CvPlot::GetBuilderAIScratchPadTurn
EXTRN	?getYieldRate@CvCity@@QBEHW4YieldTypes@@_N@Z:PROC ; CvCity::getYieldRate
EXTRN	?calculateGoldRate@CvPlayer@@QBEHXZ:PROC	; CvPlayer::calculateGoldRate
EXTRN	?GetPlayerResponsibleForRoute@CvPlot@@QBE?AW4PlayerTypes@@XZ:PROC ; CvPlot::GetPlayerResponsibleForRoute
EXTRN	?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::IsTradeRoute
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
EXTRN	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z:PROC	; CvAStar::GeneratePath
EXTRN	?GetBuildRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::GetBuildRouteFinder
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
EXTRN	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ:PROC	; CvRouteInfo::GetGoldMaintenance
EXTRN	?GetCityConnectionRouteGoldTimes100@CvTreasury@@QBEHPAVCvCity@@@Z:PROC ; CvTreasury::GetCityConnectionRouteGoldTimes100
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?IsCapitalConnectedToCity@CvPlayer@@QAE_NPAVCvCity@@W4RouteTypes@@@Z:PROC ; CvPlayer::IsCapitalConnectedToCity
EXTRN	?IsIndustrialRouteToCapital@CvCity@@QBE_NXZ:PROC ; CvCity::IsIndustrialRouteToCapital
EXTRN	?GetIndustrialRoute@CvGame@@QBE?AW4RouteTypes@@XZ:PROC ; CvGame::GetIndustrialRoute
; Function compile flags: /Ogtpy
;	COMDAT ?ConnectCitiesToCapital@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z
_TEXT	SEGMENT
_bMajorMinorConnection$ = -18				; size = 1
_bIndustrialRoute$ = -17				; size = 1
_this$ = -16						; size = 4
_iPlotsNeeded$ = -12					; size = 4
_iGoldForRoute$ = -8					; size = 4
$T224224 = -4						; size = 4
_iMaintenancePerTile$ = -4				; size = 4
_sValue$ = 8						; size = 2
$T224223 = 8						; size = 4
$T224221 = 8						; size = 4
_iRoadLength$ = 8					; size = 4
_pPlayerCapital$ = 8					; size = 4
_iGameTurn$ = 12					; size = 4
_iValue$218344 = 12					; size = 4
$T224222 = 12						; size = 4
_pTargetCity$ = 12					; size = 4
_eRoute$ = 16						; size = 4
?ConnectCitiesToCapital@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z PROC ; CvBuilderTaskingAI::ConnectCitiesToCapital, COMDAT
; _this$ = ecx

; 294  : {

	sub	esp, 20					; 00000014H
	push	ebx

; 295  : 	bool bMajorMinorConnection = false;
; 296  : 	if(pTargetCity->getOwner() != pPlayerCapital->getOwner())

	mov	ebx, DWORD PTR _pPlayerCapital$[esp+20]
	push	ebp
	mov	ebp, DWORD PTR _pTargetCity$[esp+24]
	mov	eax, DWORD PTR [ebp+84]
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+36], edi
	mov	BYTE PTR _bMajorMinorConnection$[esp+36], 0
	cmp	eax, DWORD PTR [ebx+84]
	je	SHORT $LN37@ConnectCit

; 297  : 	{
; 298  : 		bMajorMinorConnection = true;

	mov	BYTE PTR _bMajorMinorConnection$[esp+36], 1
$LN37@ConnectCit:

; 299  : 	}
; 300  : 
; 301  : 	bool bIndustrialRoute = false;
; 302  : 	if(GC.getGame().GetIndustrialRoute() == eRoute)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	BYTE PTR _bIndustrialRoute$[esp+36], 0
	call	?GetIndustrialRoute@CvGame@@QBE?AW4RouteTypes@@XZ ; CvGame::GetIndustrialRoute
	mov	esi, DWORD PTR _eRoute$[esp+32]
	cmp	eax, esi
	jne	SHORT $LN35@ConnectCit

; 303  : 	{
; 304  : 		bIndustrialRoute = true;
; 305  : 	}
; 306  : 
; 307  : 	// if we already have a connection, bail out
; 308  : 	if(bIndustrialRoute && pTargetCity->IsIndustrialRouteToCapital())

	mov	ecx, ebp
	mov	BYTE PTR _bIndustrialRoute$[esp+36], 1
	call	?IsIndustrialRouteToCapital@CvCity@@QBE_NXZ ; CvCity::IsIndustrialRouteToCapital
	test	al, al
	jne	$LN153@ConnectCit
$LN35@ConnectCit:

; 309  : 	{
; 310  : 		return;
; 311  : 	}
; 312  : 	else if(m_pPlayer->IsCapitalConnectedToCity(pTargetCity, eRoute))

	mov	ecx, DWORD PTR [edi]
	push	esi
	push	ebp
	call	?IsCapitalConnectedToCity@CvPlayer@@QAE_NPAVCvCity@@W4RouteTypes@@@Z ; CvPlayer::IsCapitalConnectedToCity
	test	al, al
	jne	$LN153@ConnectCit

; 313  : 	{
; 314  : 		return;
; 315  : 	}
; 316  : 
; 317  : 	int iGoldForRoute = 0;

	mov	DWORD PTR _iGoldForRoute$[esp+36], 0

; 318  : 	if(!bMajorMinorConnection)

	cmp	BYTE PTR _bMajorMinorConnection$[esp+36], al
	jne	SHORT $LN32@ConnectCit

; 319  : 	{
; 320  : 		iGoldForRoute = m_pPlayer->GetTreasury()->GetCityConnectionRouteGoldTimes100(pTargetCity) / 100;

	mov	ecx, DWORD PTR [edi]
	push	ebp
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetCityConnectionRouteGoldTimes100@CvTreasury@@QBEHPAVCvCity@@@Z ; CvTreasury::GetCityConnectionRouteGoldTimes100
	mov	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iGoldForRoute$[esp+36], eax
$LN32@ConnectCit:

; 321  : 	}
; 322  : 
; 323  : 	CvRouteInfo* pRouteInfo = GC.getRouteInfo(eRoute);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo

; 324  : 	if(!pRouteInfo)

	test	eax, eax
	je	$LN153@ConnectCit

; 325  : 	{
; 326  : 		return;
; 327  : 	}
; 328  : 	int iMaintenancePerTile = pRouteInfo->GetGoldMaintenance();

	mov	ecx, eax
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	mov	DWORD PTR _iMaintenancePerTile$[esp+36], eax

; 329  : 	if(iMaintenancePerTile < 0)  // div by zero check

	test	eax, eax
	jl	$LN153@ConnectCit

; 330  : 	{
; 331  : 		return;
; 332  : 	}
; 333  : 
; 334  : 	// build a path between the two cities
; 335  : 	int iPathfinderFlags = m_pPlayer->GetID();
; 336  : 	int iRouteValue = eRoute + 1;
; 337  : 	// assuming that there are fewer than 256 players
; 338  : 	iPathfinderFlags |= (iRouteValue << 8);

	mov	ecx, DWORD PTR [edi]
	inc	esi
	shl	esi, 8
	or	esi, DWORD PTR [ecx+44]

; 339  : 	bool bFoundPath = GC.GetBuildRouteFinder().GeneratePath(pPlayerCapital->plot()->getX(), pPlayerCapital->plot()->getY(), pTargetCity->plot()->getX(), pTargetCity->plot()->getY(), iPathfinderFlags);

	mov	ecx, ebp
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	movsx	edi, WORD PTR [eax+2]
	mov	ecx, ebp
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	movsx	ebp, WORD PTR [eax]
	mov	ecx, ebx
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, DWORD PTR _pPlayerCapital$[esp+32]
	movsx	ebx, WORD PTR [eax+2]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	movsx	eax, WORD PTR [eax]
	push	0
	push	esi
	push	edi
	push	ebp
	push	ebx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuildRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetBuildRouteFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath

; 340  : 
; 341  : 	//  if no path, then bail!
; 342  : 	if(!bFoundPath)

	test	al, al
	je	$LN153@ConnectCit

; 343  : 	{
; 344  : 		return;
; 345  : 	}
; 346  : 
; 347  : 	// walk the path
; 348  : 	CvPlot* pPlot = NULL;
; 349  : 
; 350  : 	// go through the route to see how long it is and how many plots already have roads
; 351  : 	int iRoadLength = 0;

	xor	edi, edi

; 352  : 	int iPlotsNeeded = 0;
; 353  : 	CvAStarNode* pNode = GC.GetBuildRouteFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iRoadLength$[esp+32], edi
	mov	DWORD PTR _iPlotsNeeded$[esp+36], edi
	call	?GetBuildRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetBuildRouteFinder
	mov	ebp, DWORD PTR [eax+96]

; 354  : #ifdef AUI_WORKER_INCA_HILLS
; 355  : 	bool bIncaBonusActive = (m_pPlayer->GetPlayerTraits()->IsNoHillsImprovementMaintenance() && !m_pPlayer->isHuman());
; 356  : #endif
; 357  : 	while(pNode)

	cmp	ebp, edi
	je	$LN153@ConnectCit
$LL28@ConnectCit:

; 358  : 	{
; 359  : 		pPlot = GC.getMap().plotCheckInvalid(pNode->m_iX, pNode->m_iY);

	movsx	eax, WORD PTR [ebp+80]
	movsx	ecx, WORD PTR [ebp+82]
	cmp	eax, -2147483647			; 80000001H
	je	SHORT $LN66@ConnectCit
	cmp	ecx, -2147483647			; 80000001H
	je	SHORT $LN66@ConnectCit
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	esi, DWORD PTR [edx+4020]
	imul	esi, ecx
	add	esi, eax
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [edx+4068]
	jmp	SHORT $LN68@ConnectCit
$LN66@ConnectCit:
	xor	esi, esi
$LN68@ConnectCit:

; 360  : 		pNode = pNode->m_pParent;

	mov	ebp, DWORD PTR [ebp+24]

; 361  : 		if(!pPlot)

	test	esi, esi
	je	$LN152@ConnectCit

; 362  : 		{
; 363  : 			break;
; 364  : 		}
; 365  : 
; 366  : 		CvCity* pCity = pPlot->getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN155@ConnectCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN155@ConnectCit
	mov	edx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 367  : 		if(NULL != pCity && pCity->getTeam() == m_pPlayer->getTeam())

	test	eax, eax
	je	SHORT $LN155@ConnectCit
	mov	ebx, DWORD PTR _this$[esp+36]
	mov	ecx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ecx+44]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN83@ConnectCit
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN84@ConnectCit
$LN83@ConnectCit:
	or	edi, -1
$LN84@ConnectCit:
	mov	ecx, eax
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	cmp	eax, edi
	je	SHORT $LN160@ConnectCit
	jmp	SHORT $LN159@ConnectCit
$LN155@ConnectCit:
	mov	ebx, DWORD PTR _this$[esp+36]
$LN159@ConnectCit:

; 368  : 		{
; 369  : 			continue;
; 370  : 		}
; 371  : 
; 372  : #ifdef AUI_WORKER_INCA_HILLS
; 373  : 		if (!bIncaBonusActive || !pPlot->isHills())
; 374  : 		{
; 375  : #endif
; 376  : 		if(pPlot->getRouteType() == eRoute && !pPlot->IsRoutePillaged())

	mov	ecx, esi
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, DWORD PTR _eRoute$[esp+32]
	jne	SHORT $LN24@ConnectCit
	mov	ecx, esi
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	test	al, al
	jne	SHORT $LN24@ConnectCit

; 377  : 		{
; 378  : 			// if this is already a trade route or someone else built it, we can count is as free
; 379  : 			if(pPlot->IsTradeRoute(m_pPlayer->GetID()) || pPlot->GetPlayerResponsibleForRoute() != m_pPlayer->GetID())

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, esi
	call	?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsTradeRoute
	test	al, al
	jne	SHORT $LN160@ConnectCit
	mov	ecx, DWORD PTR [ebx]
	mov	edi, DWORD PTR [ecx+44]
	mov	ecx, esi
	call	?GetPlayerResponsibleForRoute@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForRoute
	cmp	eax, edi
	jne	SHORT $LN160@ConnectCit

; 380  : 			{
; 381  : 				continue;
; 382  : 			}
; 383  : 			iRoadLength++;

	inc	DWORD PTR _iRoadLength$[esp+32]

; 384  : 		}
; 385  : 		else

	jmp	SHORT $LN160@ConnectCit
$LN24@ConnectCit:

; 386  : 		{
; 387  : 			iRoadLength++;

	mov	eax, 1
	add	DWORD PTR _iRoadLength$[esp+32], eax

; 388  : 			iPlotsNeeded++;

	add	DWORD PTR _iPlotsNeeded$[esp+36], eax
$LN160@ConnectCit:
	mov	edi, DWORD PTR _iRoadLength$[esp+32]
	test	ebp, ebp
	jne	$LL28@ConnectCit
$LN152@ConnectCit:

; 389  : 		}
; 390  : #ifdef AUI_WORKER_INCA_HILLS
; 391  : 		}
; 392  : #endif
; 393  : 	}
; 394  : 
; 395  : #ifdef AUI_WORKER_INCA_HILLS
; 396  : 	int iFreeIncaRoadLength = 0;
; 397  : 	if (bIncaBonusActive)
; 398  : 	{
; 399  : 		if (iRoadLength == 0)
; 400  : 		{
; 401  : 			iRoadLength = 1;
; 402  : 			iFreeIncaRoadLength = 1;
; 403  : 		}
; 404  : 		if (iPlotsNeeded == 0)
; 405  : 		{
; 406  : 			iPlotsNeeded = 1;
; 407  : 		}
; 408  : 	}
; 409  : #endif
; 410  : 
; 411  : 	// This is very odd
; 412  : 	if(iRoadLength <= 0 || iPlotsNeeded <= 0)

	test	edi, edi
	jle	$LN153@ConnectCit
	mov	ebx, DWORD PTR _iPlotsNeeded$[esp+36]
	test	ebx, ebx
	jle	$LN153@ConnectCit

; 413  : 	{
; 414  : 		return;
; 415  : 	}
; 416  : 
; 417  : 
; 418  : #ifdef AUI_WARNING_FIXES
; 419  : 	int sValue = -1;
; 420  : #else
; 421  : 	short sValue = -1;
; 422  : #endif
; 423  : #ifdef AUI_WORKER_FIX_CONNECT_CITIES_TO_CAPITOL_CONSIDER_MAINTENANCE_MODIFIERS
; 424  : #ifdef AUI_WORKER_INCA_HILLS
; 425  : 	int iTotalMaintenance = (iRoadLength - iFreeIncaRoadLength) * iMaintenancePerTile;
; 426  : #else
; 427  : 	int iTotalMaintenance = iRoadLength * iMaintenancePerTile;
; 428  : #endif
; 429  : 	// Player modifier
; 430  : 	iTotalMaintenance *= (100 + m_pPlayer->GetRouteGoldMaintenanceMod());
; 431  : 	iTotalMaintenance /= 100;
; 432  : 	// Handicap
; 433  : 	iTotalMaintenance *= m_pPlayer->getHandicapInfo().getRouteCostPercent();
; 434  : 	iTotalMaintenance /= 100;
; 435  : #ifdef AUI_WORKER_INCA_HILLS
; 436  : 	int iProfit = iGoldForRoute - iTotalMaintenance;
; 437  : #else
; 438  : 	int iProfit = iGoldForRoute - iTotalMaintenance;
; 439  : #endif
; 440  : #elif defined(AUI_WORKER_INCA_HILLS)
; 441  : 	int iProfit = iGoldForRoute - ((iRoadLength - iFreeIncaRoadLength) * iMaintenancePerTile);
; 442  : #else
; 443  : 	int iProfit = iGoldForRoute - (iRoadLength * iMaintenancePerTile);

	mov	ecx, DWORD PTR _iMaintenancePerTile$[esp+36]
	mov	eax, DWORD PTR _iGoldForRoute$[esp+36]
	mov	edx, edi
	imul	edx, ecx
	mov	esi, eax
	sub	esi, edx

; 444  : #endif
; 445  : 	if(bIndustrialRoute)

	cmp	BYTE PTR _bIndustrialRoute$[esp+36], 0
	je	SHORT $LN18@ConnectCit

; 446  : 	{
; 447  : 		if(iProfit >= 0)

	test	esi, esi
	jl	SHORT $LN17@ConnectCit

; 448  : 		{
; 449  : #ifdef AUI_WARNING_FIXES
; 450  : 			sValue = MAX_INT;
; 451  : #else
; 452  : 			sValue = MAX_SHORT;

	mov	DWORD PTR _sValue$[esp+32], 32767	; 00007fffH
	jmp	$LN11@ConnectCit
$LN17@ConnectCit:

; 453  : #endif
; 454  : 		}
; 455  : 		else if(m_pPlayer->calculateGoldRate() + iProfit >= 0)

	mov	eax, DWORD PTR _this$[esp+36]
	mov	ecx, DWORD PTR [eax]
	call	?calculateGoldRate@CvPlayer@@QBEHXZ	; CvPlayer::calculateGoldRate
	add	eax, esi
	js	$LN153@ConnectCit

; 456  : 		{
; 457  : 			sValue = pTargetCity->getYieldRate(YIELD_PRODUCTION, false) * GC.getINDUSTRIAL_ROUTE_PRODUCTION_MOD();

	mov	ecx, DWORD PTR _pTargetCity$[esp+32]
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6432
	push	0
	push	1
	call	?getYieldRate@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRate
	imul	eax, esi
	movzx	ecx, ax
	mov	DWORD PTR _sValue$[esp+32], ecx

; 458  : 		}
; 459  : 		else
; 460  : 		{
; 461  : 			return;
; 462  : 		}

	jmp	SHORT $LN11@ConnectCit
$LN18@ConnectCit:

; 463  : 	}
; 464  : 	else if(bMajorMinorConnection)

	cmp	BYTE PTR _bMajorMinorConnection$[esp+36], 0
	je	SHORT $LN12@ConnectCit

; 465  : 	{
; 466  : #ifdef AUI_WARNING_FIXES
; 467  : 		sValue = MIN(GC.getMINOR_CIV_ROUTE_QUEST_WEIGHT() / iPlotsNeeded, MAX_INT);
; 468  : #else
; 469  : 		sValue = min(GC.getMINOR_CIV_ROUTE_QUEST_WEIGHT() / iPlotsNeeded, MAX_SHORT);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7840
	cdq
	idiv	ebx
	mov	DWORD PTR $T224221[esp+32], 32767	; 00007fffH
	mov	DWORD PTR $T224222[esp+32], eax
	cmp	eax, 32767				; 00007fffH
	lea	eax, DWORD PTR $T224221[esp+32]
	jg	SHORT $LN103@ConnectCit
	lea	eax, DWORD PTR $T224222[esp+32]
$LN103@ConnectCit:
	movzx	edx, WORD PTR [eax]
	mov	DWORD PTR _sValue$[esp+32], edx

; 470  : #endif
; 471  : 	}
; 472  : 	else // normal route

	jmp	SHORT $LN11@ConnectCit
$LN12@ConnectCit:

; 473  : 	{
; 474  : 		// is this route worth building?
; 475  : 		if(iProfit < 0)

	test	esi, esi
	jl	$LN153@ConnectCit

; 476  : 		{
; 477  : 			return;
; 478  : 		}
; 479  : 
; 480  : #ifdef AUI_WORKER_FIX_CONNECT_CITIES_TO_CAPITOL_CONSIDER_MAINTENANCE_MODIFIERS
; 481  : 		int iValue = iGoldForRoute * 100 * iRoadLength;
; 482  : 		if (iTotalMaintenance + iRoadLength > iFreeIncaRoadLength)
; 483  : 			iValue /= (iTotalMaintenance + iRoadLength - iFreeIncaRoadLength);
; 484  : 		iValue /= iPlotsNeeded;
; 485  : #else
; 486  : 		int iValue = (iGoldForRoute * 100) / (iRoadLength * (iMaintenancePerTile + 1));

	imul	eax, 100				; 00000064H
	inc	ecx
	imul	ecx, edi
	cdq
	idiv	ecx

; 487  : #ifdef AUI_WORKER_INCA_HILLS
; 488  : 		iValue = (iValue * iRoadLength * (1 + iFreeIncaRoadLength * iMaintenancePerTile)) / iPlotsNeeded;
; 489  : #else
; 490  : 		iValue = (iValue * iRoadLength) / iPlotsNeeded;
; 491  : #endif
; 492  : #endif
; 493  : #ifdef AUI_WARNING_FIXES
; 494  : 		sValue = MIN(iValue, MAX_INT);
; 495  : #else
; 496  : 		sValue = min(iValue, MAX_SHORT);

	mov	DWORD PTR $T224223[esp+32], 32767	; 00007fffH
	imul	eax, edi
	cdq
	idiv	ebx
	mov	DWORD PTR _iValue$218344[esp+32], eax
	cmp	eax, 32767				; 00007fffH
	lea	eax, DWORD PTR $T224223[esp+32]
	jg	SHORT $LN107@ConnectCit
	lea	eax, DWORD PTR _iValue$218344[esp+32]
$LN107@ConnectCit:
	movzx	eax, WORD PTR [eax]
	mov	DWORD PTR _sValue$[esp+32], eax
$LN11@ConnectCit:

; 497  : #endif
; 498  : 	}
; 499  : 
; 500  : 	pPlot = NULL;
; 501  : 	pNode = GC.GetBuildRouteFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuildRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetBuildRouteFinder

; 502  : 
; 503  : 	int iGameTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebp, DWORD PTR [eax+96]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR _iGameTurn$[esp+32], eax

; 504  : 
; 505  : 	while(pNode)

	test	ebp, ebp
	je	$LN153@ConnectCit
	npad	12
$LL9@ConnectCit:

; 506  : 	{
; 507  : 		pPlot = GC.getMap().plotCheckInvalid(pNode->m_iX, pNode->m_iY);

	movsx	eax, WORD PTR [ebp+80]
	movsx	ecx, WORD PTR [ebp+82]
	cmp	eax, -2147483647			; 80000001H
	je	SHORT $LN114@ConnectCit
	cmp	ecx, -2147483647			; 80000001H
	je	SHORT $LN114@ConnectCit
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	esi, DWORD PTR [edx+4020]
	imul	esi, ecx
	add	esi, eax
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [edx+4068]
	jmp	SHORT $LN116@ConnectCit
$LN114@ConnectCit:
	xor	esi, esi
$LN116@ConnectCit:

; 508  : 		pNode = pNode->m_pParent;

	mov	ebp, DWORD PTR [ebp+24]

; 509  : 
; 510  : 		if(!pPlot)

	test	esi, esi
	je	$LN153@ConnectCit

; 511  : 		{
; 512  : 			break;
; 513  : 		}
; 514  : 
; 515  : 		if(pPlot->getRouteType() == eRoute && !pPlot->IsRoutePillaged())

	mov	ecx, esi
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	mov	ebx, DWORD PTR _eRoute$[esp+32]
	cmp	eax, ebx
	jne	SHORT $LN6@ConnectCit
	mov	ecx, esi
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	test	al, al
	je	$LN158@ConnectCit
$LN6@ConnectCit:

; 516  : 		{
; 517  : 			continue;
; 518  : 		}
; 519  : 
; 520  : 		// if we already know about this plot, continue on
; 521  : 		if(pPlot->GetBuilderAIScratchPadTurn() == iGameTurn && pPlot->GetBuilderAIScratchPadPlayer() == m_pPlayer->GetID())

	mov	ecx, esi
	call	?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ ; CvPlot::GetBuilderAIScratchPadTurn
	movsx	ecx, ax
	cmp	ecx, DWORD PTR _iGameTurn$[esp+32]
	jne	SHORT $LN157@ConnectCit
	mov	edx, DWORD PTR _this$[esp+36]
	mov	eax, DWORD PTR [edx]
	mov	edi, DWORD PTR [eax+44]
	mov	ecx, esi
	call	?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetBuilderAIScratchPadPlayer
	cmp	eax, edi
	jne	SHORT $LN157@ConnectCit

; 522  : 		{
; 523  : 			if(sValue > pPlot->GetBuilderAIScratchPadValue())

	mov	ecx, esi
	call	?GetBuilderAIScratchPadValue@CvPlot@@QBEFXZ ; CvPlot::GetBuilderAIScratchPadValue
	cmp	WORD PTR _sValue$[esp+32], ax
	jle	$LN158@ConnectCit

; 524  : 			{
; 525  : 				pPlot->SetBuilderAIScratchPadValue(sValue);

	mov	ecx, DWORD PTR _sValue$[esp+32]
	push	ecx
	mov	ecx, esi
	call	?SetBuilderAIScratchPadValue@CvPlot@@QAEXF@Z ; CvPlot::SetBuilderAIScratchPadValue

; 526  : 				pPlot->SetBuilderAIScratchPadRoute(eRoute);

	push	ebx
	mov	ecx, esi
	call	?SetBuilderAIScratchPadRoute@CvPlot@@QAEXW4RouteTypes@@@Z ; CvPlot::SetBuilderAIScratchPadRoute

; 527  : 			}
; 528  : 			continue;

	jmp	SHORT $LN158@ConnectCit
$LN157@ConnectCit:

; 529  : 		}
; 530  : 
; 531  : 		// mark nodes and reset values
; 532  : 		pPlot->SetBuilderAIScratchPadTurn(iGameTurn);

	mov	edx, DWORD PTR _iGameTurn$[esp+32]
	push	edx
	mov	ecx, esi
	call	?SetBuilderAIScratchPadTurn@CvPlot@@QAEXF@Z ; CvPlot::SetBuilderAIScratchPadTurn

; 533  : 		pPlot->SetBuilderAIScratchPadPlayer(m_pPlayer->GetID());

	mov	edi, DWORD PTR _this$[esp+36]
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	mov	ecx, esi
	call	?SetBuilderAIScratchPadPlayer@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetBuilderAIScratchPadPlayer

; 534  : 		pPlot->SetBuilderAIScratchPadValue(sValue);

	mov	edx, DWORD PTR _sValue$[esp+32]
	push	edx
	mov	ecx, esi
	call	?SetBuilderAIScratchPadValue@CvPlot@@QAEXF@Z ; CvPlot::SetBuilderAIScratchPadValue

; 535  : 		pPlot->SetBuilderAIScratchPadRoute(eRoute);

	push	ebx
	mov	ecx, esi
	call	?SetBuilderAIScratchPadRoute@CvPlot@@QAEXW4RouteTypes@@@Z ; CvPlot::SetBuilderAIScratchPadRoute

; 536  : 
; 537  : 		// add nodes that are not in territory to extra list
; 538  : 		// minors should not build out of their borders when they are doing a major/minor connection, only when connecting their two cities
; 539  : 		if(!(m_pPlayer->isMinorCiv() && bMajorMinorConnection))

	mov	ecx, DWORD PTR [edi]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN2@ConnectCit
	cmp	BYTE PTR _bMajorMinorConnection$[esp+36], 0
	jne	SHORT $LN158@ConnectCit
$LN2@ConnectCit:

; 540  : 		{
; 541  : 			if(pPlot->getOwner() != m_pPlayer->GetID())

	movsx	eax, BYTE PTR [esi+4]
	mov	ecx, DWORD PTR [edi]
	cmp	eax, DWORD PTR [ecx+44]
	je	SHORT $LN158@ConnectCit

; 542  : 			{
; 543  : 				m_aiNonTerritoryPlots.push_back(GC.getMap().plotNum(pPlot->getX(), pPlot->getY()));

	movsx	edx, WORD PTR [esi+2]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	edx, DWORD PTR [eax+4020]
	movsx	ecx, WORD PTR [esi]
	add	edx, ecx
	mov	DWORD PTR $T224224[esp+36], edx
	lea	edx, DWORD PTR $T224224[esp+36]
	push	edx
	mov	ecx, OFFSET ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A ; CvBuilderTaskingAI::m_aiNonTerritoryPlots
	call	?push_back@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEIABH@Z ; FStaticVector<int,64,1,297,0>::push_back
$LN158@ConnectCit:

; 504  : 
; 505  : 	while(pNode)

	test	ebp, ebp
	jne	$LL9@ConnectCit
$LN153@ConnectCit:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 544  : 			}
; 545  : 		}
; 546  : 	}
; 547  : }

	add	esp, 20					; 00000014H
	ret	12					; 0000000cH
?ConnectCitiesToCapital@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z ENDP ; CvBuilderTaskingAI::ConnectCitiesToCapital
_TEXT	ENDS
PUBLIC	?ConnectCitiesForScenario@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z ; CvBuilderTaskingAI::ConnectCitiesForScenario
EXTRN	?IsCityConnectedToCity@CvPlayer@@QAE_NPAVCvCity@@0W4RouteTypes@@_N@Z:PROC ; CvPlayer::IsCityConnectedToCity
; Function compile flags: /Ogtpy
;	COMDAT ?ConnectCitiesForScenario@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
$T224522 = 8						; size = 4
_iGameTurn$ = 8						; size = 4
_pCity1$ = 8						; size = 4
_pNode$ = 12						; size = 4
_pCity2$ = 12						; size = 4
_eRoute$ = 16						; size = 4
?ConnectCitiesForScenario@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z PROC ; CvBuilderTaskingAI::ConnectCitiesForScenario, COMDAT
; _this$ = ecx

; 550  : {

	push	ecx
	push	ebx

; 551  : 	// don't connect cities from different owners
; 552  : 	if(pCity1->getOwner() != pCity2->getOwner())

	mov	ebx, DWORD PTR _pCity2$[esp+4]
	push	ebp
	push	edi
	mov	edi, DWORD PTR _pCity1$[esp+12]
	mov	eax, DWORD PTR [edi+84]
	mov	ebp, ecx
	mov	DWORD PTR _this$[esp+16], ebp
	cmp	eax, DWORD PTR [ebx+84]
	jne	$LN80@ConnectCit@2

; 553  : 	{
; 554  : 		return;
; 555  : 	}
; 556  : 
; 557  : 	// if we already have a connection, bail out
; 558  : 	if (m_pPlayer->IsCityConnectedToCity(pCity1, pCity2, eRoute, true))

	mov	ecx, DWORD PTR [ebp]
	push	esi
	mov	esi, DWORD PTR _eRoute$[esp+16]
	push	1
	push	esi
	push	ebx
	push	edi
	call	?IsCityConnectedToCity@CvPlayer@@QAE_NPAVCvCity@@0W4RouteTypes@@_N@Z ; CvPlayer::IsCityConnectedToCity
	test	al, al
	jne	$LN87@ConnectCit@2

; 559  : 	{
; 560  : 		return;
; 561  : 	}
; 562  : 
; 563  : 	// build a path between the two cities
; 564  : 	int iPathfinderFlags = m_pPlayer->GetID();
; 565  : 	int iRouteValue = eRoute + 1;
; 566  : 	// assuming that there are fewer than 256 players
; 567  : 	iPathfinderFlags |= (iRouteValue << 8);

	mov	ecx, DWORD PTR [ebp]
	inc	esi
	shl	esi, 8
	or	esi, DWORD PTR [ecx+44]

; 568  : 	bool bFoundPath = GC.GetBuildRouteFinder().GeneratePath(pCity1->plot()->getX(), pCity1->plot()->getY(), pCity2->plot()->getX(), pCity2->plot()->getY(), iPathfinderFlags);

	mov	ecx, ebx
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	movsx	ebp, WORD PTR [eax+2]
	mov	ecx, ebx
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	movsx	ebx, WORD PTR [eax]
	mov	ecx, edi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	movsx	edx, WORD PTR [eax+2]
	mov	ecx, edi
	mov	DWORD PTR $T224522[esp+16], edx
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	movsx	eax, WORD PTR [eax]
	mov	ecx, DWORD PTR $T224522[esp+16]
	push	0
	push	esi
	push	ebp
	push	ebx
	push	ecx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuildRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetBuildRouteFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath

; 569  : 
; 570  : 	//  if no path, then bail!
; 571  : 	if(!bFoundPath)

	test	al, al
	je	$LN87@ConnectCit@2

; 572  : 	{
; 573  : 		return;
; 574  : 	}
; 575  : 
; 576  : 	CvPlot* pPlot = NULL;
; 577  : 	CvAStarNode* pNode = GC.GetBuildRouteFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuildRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetBuildRouteFinder

; 578  : 	int iGameTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, DWORD PTR [eax+96]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR _iGameTurn$[esp+16], eax

; 579  : 
; 580  : 	while(pNode)

	test	edi, edi
	je	$LN87@ConnectCit@2
	jmp	SHORT $LN6@ConnectCit@2
	npad	6
$LL84@ConnectCit@2:
	mov	edi, DWORD PTR _pNode$[esp+16]
$LN6@ConnectCit@2:

; 581  : 	{
; 582  : 		pPlot = GC.getMap().plotCheckInvalid(pNode->m_iX, pNode->m_iY);

	movsx	eax, WORD PTR [edi+80]
	movsx	ecx, WORD PTR [edi+82]
	cmp	eax, -2147483647			; 80000001H
	je	SHORT $LN38@ConnectCit@2
	cmp	ecx, -2147483647			; 80000001H
	je	SHORT $LN38@ConnectCit@2
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	esi, DWORD PTR [edx+4020]
	imul	esi, ecx
	add	esi, eax
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [edx+4068]
	jmp	SHORT $LN40@ConnectCit@2
$LN38@ConnectCit@2:
	xor	esi, esi
$LN40@ConnectCit@2:

; 583  : 		pNode = pNode->m_pParent;

	mov	edx, DWORD PTR [edi+24]
	mov	DWORD PTR _pNode$[esp+16], edx

; 584  : 
; 585  : 		if(!pPlot)

	test	esi, esi
	je	$LN87@ConnectCit@2

; 586  : 		{
; 587  : 			break;
; 588  : 		}
; 589  : 
; 590  : 		if(pPlot->getRouteType() == eRoute && !pPlot->IsRoutePillaged())

	mov	ecx, esi
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	mov	ebp, DWORD PTR _eRoute$[esp+16]
	cmp	eax, ebp
	jne	SHORT $LN3@ConnectCit@2
	mov	ecx, esi
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	test	al, al
	je	$LN86@ConnectCit@2
$LN3@ConnectCit@2:

; 591  : 		{
; 592  : 			continue;
; 593  : 		}
; 594  : 
; 595  : 		// if we already know about this plot, continue on
; 596  : 		if(pPlot->GetBuilderAIScratchPadTurn() == iGameTurn && pPlot->GetBuilderAIScratchPadPlayer() == m_pPlayer->GetID())

	mov	ecx, esi
	call	?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ ; CvPlot::GetBuilderAIScratchPadTurn
	mov	edi, DWORD PTR _this$[esp+20]
	cwde
	cmp	eax, DWORD PTR _iGameTurn$[esp+16]
	jne	SHORT $LN85@ConnectCit@2
	mov	ecx, DWORD PTR [edi]
	mov	ebx, DWORD PTR [ecx+44]
	mov	ecx, esi
	call	?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetBuilderAIScratchPadPlayer
	cmp	eax, ebx
	je	$LN86@ConnectCit@2
$LN85@ConnectCit@2:

; 597  : 		{
; 598  : 			continue;
; 599  : 		}
; 600  : 
; 601  : 		// mark nodes and reset values
; 602  : 		pPlot->SetBuilderAIScratchPadTurn(iGameTurn);

	mov	edx, DWORD PTR _iGameTurn$[esp+16]
	push	edx
	mov	ecx, esi
	call	?SetBuilderAIScratchPadTurn@CvPlot@@QAEXF@Z ; CvPlot::SetBuilderAIScratchPadTurn

; 603  : 		pPlot->SetBuilderAIScratchPadPlayer(m_pPlayer->GetID());

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	mov	ecx, esi
	call	?SetBuilderAIScratchPadPlayer@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetBuilderAIScratchPadPlayer

; 604  : 		pPlot->SetBuilderAIScratchPadValue(1000);

	push	1000					; 000003e8H
	mov	ecx, esi
	call	?SetBuilderAIScratchPadValue@CvPlot@@QAEXF@Z ; CvPlot::SetBuilderAIScratchPadValue

; 605  : 		pPlot->SetBuilderAIScratchPadRoute(eRoute);

	push	ebp
	mov	ecx, esi
	call	?SetBuilderAIScratchPadRoute@CvPlot@@QAEXW4RouteTypes@@@Z ; CvPlot::SetBuilderAIScratchPadRoute

; 606  : 
; 607  : 		// add nodes that are not in territory to extra list
; 608  : 		if(pPlot->getOwner() != m_pPlayer->GetID())

	movsx	edx, BYTE PTR [esi+4]
	mov	eax, DWORD PTR [edi]
	cmp	edx, DWORD PTR [eax+44]
	je	SHORT $LN86@ConnectCit@2

; 609  : 		{
; 610  : 			m_aiNonTerritoryPlots.push_back(GC.getMap().plotNum(pPlot->getX(), pPlot->getY()));

	movsx	edi, WORD PTR [esi+2]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	edi, DWORD PTR [ecx+4020]
	movsx	edx, WORD PTR [esi]
	mov	eax, DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+8
	add	edi, edx
	mov	BYTE PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+268, 0
	cmp	DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+4, eax
	jne	SHORT $LN70@ConnectCit@2
	push	eax
	mov	ecx, OFFSET ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A ; CvBuilderTaskingAI::m_aiNonTerritoryPlots
	call	?GrowSize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,64,1,297,0>::GrowSize
$LN70@ConnectCit@2:
	mov	eax, DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A
	mov	ecx, DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+4
	lea	eax, DWORD PTR [eax+ecx*4]
	test	eax, eax
	je	SHORT $LN73@ConnectCit@2
	mov	DWORD PTR [eax], edi
$LN73@ConnectCit@2:
	inc	DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+4
$LN86@ConnectCit@2:

; 579  : 
; 580  : 	while(pNode)

	cmp	DWORD PTR _pNode$[esp+16], 0
	jne	$LL84@ConnectCit@2
$LN87@ConnectCit@2:
	pop	esi
$LN80@ConnectCit@2:
	pop	edi
	pop	ebp
	pop	ebx

; 611  : 		}
; 612  : 	}
; 613  : }

	pop	ecx
	ret	12					; 0000000cH
?ConnectCitiesForScenario@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z ENDP ; CvBuilderTaskingAI::ConnectCitiesForScenario
_TEXT	ENDS
PUBLIC	?UpdateRoutePlots@CvBuilderTaskingAI@@QAEXXZ	; CvBuilderTaskingAI::UpdateRoutePlots
EXTRN	?GetCityFromIndex@CvCityConnections@@QAEPAVCvCity@@H@Z:PROC ; CvCityConnections::GetCityFromIndex
EXTRN	?getTechPrereq@CvBuildInfo@@QBEHXZ:PROC		; CvBuildInfo::getTechPrereq
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
EXTRN	?getBestRoute@CvPlayer@@QBE?AW4RouteTypes@@PAVCvPlot@@@Z:PROC ; CvPlayer::getBestRoute
EXTRN	?GetNumConnectableCities@CvCityConnections@@QAEIXZ:PROC ; CvCityConnections::GetNumConnectableCities
EXTRN	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ:PROC ; CvPlayer::GetCityConnections
; Function compile flags: /Ogtpy
;	COMDAT ?UpdateRoutePlots@CvBuilderTaskingAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_uiFirstCityIndex$218412 = -24				; size = 4
_i$218397 = -20						; size = 4
_iLoopUnit$ = -16					; size = 4
_eRoute$218405 = -12					; size = 4
_eBestRoute$ = -8					; size = 4
tv287 = -4						; size = 4
?UpdateRoutePlots@CvBuilderTaskingAI@@QAEXXZ PROC	; CvBuilderTaskingAI::UpdateRoutePlots, COMDAT
; _this$ = ecx

; 617  : {

	sub	esp, 28					; 0000001cH
	push	ebp
	push	edi
	mov	ebp, ecx

; 618  : 	m_aiNonTerritoryPlots.clear();

	xor	edi, edi
	mov	DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+4, edi

; 619  : 
; 620  : 	// if there are fewer than 2 cities, we don't need to run this function
; 621  : 	if(m_pPlayer->GetCityConnections()->GetNumConnectableCities() < 2)

	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR _this$[esp+36], ebp
	call	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ ; CvPlayer::GetCityConnections
	mov	ecx, eax
	call	?GetNumConnectableCities@CvCityConnections@@QAEIXZ ; CvCityConnections::GetNumConnectableCities
	cmp	eax, 2
	jb	$LN18@UpdateRout

; 622  : 	{
; 623  : 		return;
; 624  : 	}
; 625  : 
; 626  : 	RouteTypes eBestRoute = m_pPlayer->getBestRoute();

	mov	ecx, DWORD PTR [ebp]
	push	edi
	call	?getBestRoute@CvPlayer@@QBE?AW4RouteTypes@@PAVCvPlot@@@Z ; CvPlayer::getBestRoute
	mov	DWORD PTR _eBestRoute$[esp+36], eax

; 627  : 	if(eBestRoute == NO_ROUTE)

	cmp	eax, -1
	je	$LN18@UpdateRout

; 628  : 	{
; 629  : 		return;
; 630  : 	}
; 631  : 
; 632  : 	// find a builder, if I don't have a builder, bail!
; 633  : 	CvUnit* pBuilder = NULL;
; 634  : 	CvUnit* pLoopUnit;
; 635  : 	int iLoopUnit;
; 636  : 	for(pLoopUnit = m_pPlayer->firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoopUnit))

	mov	ecx, DWORD PTR [ebp]
	push	esi
	push	edi
	lea	eax, DWORD PTR _iLoopUnit$[esp+44]
	push	eax
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	cmp	esi, edi
	je	$LN76@UpdateRout
	npad	6
$LL25@UpdateRout:

; 637  : 	{
; 638  : 		if(pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER)

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 2
	je	SHORT $LN67@UpdateRout
	push	edi
	lea	ecx, DWORD PTR _iLoopUnit$[esp+44]
	push	ecx
	mov	ecx, DWORD PTR [ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	cmp	esi, edi
	jne	SHORT $LL25@UpdateRout
	pop	esi
	pop	edi
	pop	ebp

; 721  : 				}
; 722  : 			}
; 723  : 		}
; 724  : 	}
; 725  : }

	add	esp, 28					; 0000001cH
	ret	0
$LN67@UpdateRout:

; 639  : 		{
; 640  : 			pBuilder = pLoopUnit;
; 641  : 			break;
; 642  : 		}
; 643  : 	}
; 644  : 
; 645  : 	// If there's no builder, bail!
; 646  : 	if(!pBuilder)

	cmp	esi, edi
	je	$LN76@UpdateRout

; 647  : 	{
; 648  : 		return;
; 649  : 	}
; 650  : 
; 651  : 	// updating plots that are part of the road network
; 652  : 	CvCityConnections* pCityConnections = m_pPlayer->GetCityConnections();

	mov	ecx, DWORD PTR [ebp]
	push	ebx
	call	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ ; CvPlayer::GetCityConnections

; 653  : 
; 654  : #ifdef AUI_WARNING_FIXES
; 655  : 	for (uint i = 0; i < GC.getNumBuildInfos(); i++)
; 656  : #else
; 657  : 	for(int i = 0; i < GC.getNumBuildInfos(); i++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebx, eax
	mov	DWORD PTR _i$218397[esp+44], edi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	$LN77@UpdateRout
$LL20@UpdateRout:

; 658  : #endif
; 659  : 	{
; 660  : 		BuildTypes eBuild = (BuildTypes)i;
; 661  : 		CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 662  : 		if(!pkBuild)

	test	eax, eax
	je	$LN19@UpdateRout

; 663  : 		{
; 664  : 			continue;
; 665  : 		}
; 666  : 
; 667  : 		RouteTypes eRoute = (RouteTypes)pkBuild->getRoute();

	mov	ecx, eax
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	mov	DWORD PTR _eRoute$218405[esp+44], eax

; 668  : 		if(eRoute == NO_ROUTE)

	cmp	eax, -1
	je	$LN19@UpdateRout

; 669  : 		{
; 670  : 			continue;
; 671  : 		}
; 672  : 
; 673  : 		if(GC.getBuildInfo(eBuild)->getTechPrereq() != NO_TECH)

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getTechPrereq@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getTechPrereq
	cmp	eax, -1
	je	SHORT $LN14@UpdateRout

; 674  : 		{
; 675  : 			bool bHasTech = GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->HasTech((TechTypes)GC.getBuildInfo(eBuild)->getTechPrereq());

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN42@UpdateRout
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN43@UpdateRout
$LN42@UpdateRout:
	or	eax, -1
$LN43@UpdateRout:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	esi, eax
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getTechPrereq@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getTechPrereq
	push	eax
	mov	ecx, esi
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech

; 676  : 			if(!bHasTech)

	test	al, al
	je	$LN19@UpdateRout
$LN14@UpdateRout:

; 677  : 			{
; 678  : 				continue;
; 679  : 			}
; 680  : 		}
; 681  : 
; 682  : 		for(uint uiFirstCityIndex = 0; uiFirstCityIndex < pCityConnections->m_aiCityPlotIDs.size(); uiFirstCityIndex++)

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR _uiFirstCityIndex$218412[esp+44], 0
	test	eax, eax
	jbe	$LN19@UpdateRout
$LL72@UpdateRout:

; 683  : 		{
; 684  : 			for(uint uiSecondCityIndex = uiFirstCityIndex + 1; uiSecondCityIndex < pCityConnections->m_aiCityPlotIDs.size(); uiSecondCityIndex++)

	mov	ebp, DWORD PTR _uiFirstCityIndex$218412[esp+44]
	inc	ebp
	mov	DWORD PTR tv287[esp+44], ebp
	cmp	ebp, eax
	jae	$LN12@UpdateRout
$LL73@UpdateRout:

; 685  : 			{
; 686  : 				// get the two cities
; 687  : 				CvCity* pFirstCity  = pCityConnections->GetCityFromIndex(uiFirstCityIndex);

	mov	eax, DWORD PTR _uiFirstCityIndex$218412[esp+44]
	push	eax
	mov	ecx, ebx
	call	?GetCityFromIndex@CvCityConnections@@QAEPAVCvCity@@H@Z ; CvCityConnections::GetCityFromIndex

; 688  : 				CvCity* pSecondCity = pCityConnections->GetCityFromIndex(uiSecondCityIndex);

	push	ebp
	mov	ecx, ebx
	mov	esi, eax
	call	?GetCityFromIndex@CvCityConnections@@QAEPAVCvCity@@H@Z ; CvCityConnections::GetCityFromIndex
	mov	edi, eax

; 689  : 				CvCity* pPlayerCapitalCity = NULL;
; 690  : 				CvCity* pTargetCity = NULL;
; 691  : 
; 692  : 				if(!pFirstCity || !pSecondCity)

	test	esi, esi
	je	SHORT $LN9@UpdateRout
	test	edi, edi
	je	SHORT $LN9@UpdateRout

; 693  : 				{
; 694  : 					continue;
; 695  : 				}
; 696  : 
; 697  : 				bool bConnectOnlyCapitals = (bool)GC.getCITY_CONNECTIONS_CONNECT_TO_CAPITAL();

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8188, 0

; 698  : 				if (bConnectOnlyCapitals)

	je	SHORT $LN5@UpdateRout

; 699  : 				{
; 700  : 					// only need to build roads to the capital
; 701  : 					if(!pFirstCity->isCapital() && !pSecondCity->isCapital())

	mov	ecx, esi
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	jne	SHORT $LN4@UpdateRout
	mov	ecx, edi
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	je	SHORT $LN9@UpdateRout
$LN4@UpdateRout:

; 702  : 					{
; 703  : 						continue;
; 704  : 					}
; 705  : 
; 706  : 					if(pFirstCity->isCapital() && pFirstCity->getOwner() == m_pPlayer->GetID())

	mov	ecx, esi
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	je	SHORT $LN74@UpdateRout
	mov	ecx, DWORD PTR _this$[esp+44]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi+84]
	cmp	eax, DWORD PTR [edx+44]
	jne	SHORT $LN74@UpdateRout

; 707  : 					{
; 708  : 						pPlayerCapitalCity = pFirstCity;
; 709  : 						pTargetCity = pSecondCity;
; 710  : 					}
; 711  : 					else
; 712  : 					{
; 713  : 						pPlayerCapitalCity = pSecondCity;
; 714  : 						pTargetCity = pFirstCity;
; 715  : 					}
; 716  : 					ConnectCitiesToCapital(pPlayerCapitalCity, pTargetCity, eRoute);

	mov	ecx, DWORD PTR _eRoute$218405[esp+44]
	mov	eax, esi
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+48]
	mov	esi, edi
	push	esi
	push	eax
	call	?ConnectCitiesToCapital@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z ; CvBuilderTaskingAI::ConnectCitiesToCapital

; 717  : 				}
; 718  : 				else

	jmp	SHORT $LN9@UpdateRout
$LN74@UpdateRout:

; 707  : 					{
; 708  : 						pPlayerCapitalCity = pFirstCity;
; 709  : 						pTargetCity = pSecondCity;
; 710  : 					}
; 711  : 					else
; 712  : 					{
; 713  : 						pPlayerCapitalCity = pSecondCity;
; 714  : 						pTargetCity = pFirstCity;
; 715  : 					}
; 716  : 					ConnectCitiesToCapital(pPlayerCapitalCity, pTargetCity, eRoute);

	mov	ecx, DWORD PTR _eRoute$218405[esp+44]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+48]
	mov	eax, edi
	push	esi
	push	eax
	call	?ConnectCitiesToCapital@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z ; CvBuilderTaskingAI::ConnectCitiesToCapital

; 717  : 				}
; 718  : 				else

	jmp	SHORT $LN9@UpdateRout
$LN5@UpdateRout:

; 719  : 				{
; 720  : 					ConnectCitiesForScenario(pFirstCity, pSecondCity, eBestRoute);

	mov	edx, DWORD PTR _eBestRoute$[esp+44]
	mov	ecx, DWORD PTR _this$[esp+44]
	push	edx
	push	edi
	push	esi
	call	?ConnectCitiesForScenario@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z ; CvBuilderTaskingAI::ConnectCitiesForScenario
$LN9@UpdateRout:
	inc	ebp
	cmp	ebp, DWORD PTR [ebx+16]
	jb	$LL73@UpdateRout
	mov	edi, DWORD PTR _i$218397[esp+44]
	mov	ebp, DWORD PTR tv287[esp+44]
$LN12@UpdateRout:
	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR _uiFirstCityIndex$218412[esp+44], ebp
	cmp	ebp, eax
	jb	$LL72@UpdateRout

; 677  : 			{
; 678  : 				continue;
; 679  : 			}
; 680  : 		}
; 681  : 
; 682  : 		for(uint uiFirstCityIndex = 0; uiFirstCityIndex < pCityConnections->m_aiCityPlotIDs.size(); uiFirstCityIndex++)

	mov	ebp, DWORD PTR _this$[esp+44]
$LN19@UpdateRout:

; 653  : 
; 654  : #ifdef AUI_WARNING_FIXES
; 655  : 	for (uint i = 0; i < GC.getNumBuildInfos(); i++)
; 656  : #else
; 657  : 	for(int i = 0; i < GC.getNumBuildInfos(); i++)

	inc	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _i$218397[esp+44], edi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	edi, eax
	jl	$LL20@UpdateRout
$LN77@UpdateRout:
	pop	ebx
$LN76@UpdateRout:
	pop	esi
$LN18@UpdateRout:
	pop	edi
	pop	ebp

; 721  : 				}
; 722  : 			}
; 723  : 		}
; 724  : 	}
; 725  : }

	add	esp, 28					; 0000001cH
	ret	0
?UpdateRoutePlots@CvBuilderTaskingAI@@QAEXXZ ENDP	; CvBuilderTaskingAI::UpdateRoutePlots
_TEXT	ENDS
PUBLIC	?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z ; CvBuilderTaskingAI::LogDirectives
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z$1
__ehfuncinfo$?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z
_TEXT	SEGMENT
_elem$224767 = -92					; size = 24
_strLog$219186 = -68					; size = 28
_strTemp$219187 = -40					; size = 28
__$EHRec$ = -12						; size = 12
$T224732 = 8						; size = 4
_pUnit$ = 8						; size = 4
?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z PROC ; CvBuilderTaskingAI::LogDirectives, COMDAT
; _this$ = ecx

; 3268 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	ebp
	mov	ebp, ecx

; 3269 : 	if(!m_bLogging)

	cmp	BYTE PTR [ebp+58392], 0
	push	esi
	push	edi
	je	$LN1@LogDirecti@2

; 3270 : 	{
; 3271 : 		return;
; 3272 : 	}
; 3273 : 
; 3274 : 	if(m_aDirectives.size() > 0)

	mov	eax, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A+4
	xor	esi, esi
	cmp	eax, esi
	jle	$LN5@LogDirecti@2

; 3275 : 	{
; 3276 : 		for(int i = 0; i < m_aDirectives.size(); i++)

	xor	edi, edi
	cmp	eax, esi
	jle	$LN1@LogDirecti@2
	mov	ebx, DWORD PTR _pUnit$[esp+104]
	npad	8
$LL4@LogDirecti@2:

; 3277 : 		{
; 3278 : 			LogDirective(m_aDirectives.GetElement(i), pUnit, m_aDirectives.GetWeight(i));

	mov	eax, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A
	mov	ecx, DWORD PTR [esi+eax]
	mov	edx, DWORD PTR [esi+eax+4]
	mov	DWORD PTR _elem$224767[esp+108], ecx
	mov	ecx, DWORD PTR [esi+eax+8]
	mov	DWORD PTR _elem$224767[esp+116], ecx
	mov	ecx, DWORD PTR [esi+eax+16]
	mov	DWORD PTR _elem$224767[esp+124], ecx
	mov	ecx, DWORD PTR [esi+eax+20]
	push	0
	push	ecx
	mov	DWORD PTR _elem$224767[esp+120], edx
	mov	edx, DWORD PTR [esi+eax+12]
	mov	DWORD PTR _elem$224767[esp+128], edx
	mov	edx, DWORD PTR [esi+eax]
	push	ebx
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [esi+eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [esi+eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [esi+eax+12]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [ecx+12], edx
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, ebp
	call	?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z ; CvBuilderTaskingAI::LogDirective
	inc	edi
	add	esi, 24					; 00000018H
	cmp	edi, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A+4
	jl	SHORT $LL4@LogDirecti@2

; 3292 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+108]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 92					; 0000005cH
	ret	4
$LN5@LogDirecti@2:

; 3279 : 		}
; 3280 : 	}
; 3281 : 	else
; 3282 : 	{
; 3283 : 		CvString strLog;

	lea	ecx, DWORD PTR _strLog$219186[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3284 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$219187[esp+108]
	mov	DWORD PTR __$EHRec$[esp+116], esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3285 : 
; 3286 : 		strTemp.Format("%d,", pUnit->GetID()); // unit id

	mov	ecx, DWORD PTR _pUnit$[esp+104]
	mov	eax, DWORD PTR [ecx+100]
	push	eax
	lea	edx, DWORD PTR _strTemp$219187[esp+112]
	push	OFFSET $SG219188
	push	edx
	mov	BYTE PTR __$EHRec$[esp+128], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 3287 : 		strLog += strTemp;

	lea	eax, DWORD PTR _strTemp$219187[esp+108]
	push	eax
	lea	ecx, DWORD PTR _strLog$219186[esp+112]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3288 : 
; 3289 : 		strLog += "No directives!";

	push	OFFSET $SG219189
	lea	ecx, DWORD PTR _strLog$219186[esp+112]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3290 : 		LogInfo(strLog, m_pPlayer);

	mov	ecx, DWORD PTR [ebp]
	push	esi
	push	ecx
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strLog$219186[esp+144]
	mov	DWORD PTR $T224732[esp+140], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 3291 : 	}

	lea	ecx, DWORD PTR _strTemp$219187[esp+108]
	mov	BYTE PTR __$EHRec$[esp+116], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLog$219186[esp+108]
	mov	DWORD PTR __$EHRec$[esp+116], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@LogDirecti@2:

; 3292 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+108]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 92					; 0000005cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z$0:
	lea	ecx, DWORD PTR _strLog$219186[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z$1:
	lea	ecx, DWORD PTR _strTemp$219187[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z ENDP ; CvBuilderTaskingAI::LogDirectives
PUBLIC	??0?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@XZ ; CvWeightedVector<BuilderDirective,100,1>::CvWeightedVector<BuilderDirective,100,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@XZ
_TEXT	SEGMENT
??0?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@XZ PROC ; CvWeightedVector<BuilderDirective,100,1>::CvWeightedVector<BuilderDirective,100,1>, COMDAT
; _this$ = ecx

; 52   : 	CvWeightedVector(void)

	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 100			; 00000064H
	mov	DWORD PTR [eax], ecx

; 53   : 	{
; 54   : 	};

	ret	0
??0?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@XZ ENDP ; CvWeightedVector<BuilderDirective,100,1>::CvWeightedVector<BuilderDirective,100,1>
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@XZ ; CvWeightedVector<BuilderDirective,100,1>::~CvWeightedVector<BuilderDirective,100,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@XZ PROC ; CvWeightedVector<BuilderDirective,100,1>::~CvWeightedVector<BuilderDirective,100,1>, COMDAT
; _this$ = ecx

; 59   : 	};

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@CvWeighted
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvWeighted:
	ret	0
??1?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@XZ ENDP ; CvWeightedVector<BuilderDirective,100,1>::~CvWeightedVector<BuilderDirective,100,1>
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z PROC ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+2412], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@3

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::GrowSize
$LN1@push_back@3:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@3
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ecx
$LN4@push_back@3:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z ; std::_Insertion_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z PROC ; std::_Insertion_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z ENDP ; std::_Insertion_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z
_TEXT	SEGMENT
$T224913 = -4						; size = 1
$T224920 = -4						; size = 4
$T224916 = -4						; size = 4
__Cat$224924 = 8					; size = 1
$T224915 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z PROC ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T224920[esp+8], ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$224924[esp+4]
	mov	edx, DWORD PTR $T224915[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T224913[esp+12], bl
	mov	eax, DWORD PTR $T224913[esp+12]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+20]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR $T224916[esp+44], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+40]
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN27@unchecked_
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN27@unchecked_:
	mov	eax, esi

; 3607 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z ENDP ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000@Z ; stdext::unchecked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000@Z
_TEXT	SEGMENT
$T224964 = -4						; size = 1
$T224965 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000@Z PROC ; stdext::unchecked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Dest$[esp]
	mov	BYTE PTR $T224964[esp+4], 0
	mov	eax, DWORD PTR $T224964[esp+4]
	mov	ecx, DWORD PTR $T224965[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+16]
	push	ecx
	push	edx
	push	eax
	call	??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>

; 5117 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000@Z ENDP ; stdext::unchecked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Buffered_rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z
_TEXT	SEGMENT
$T224976 = -20						; size = 20
$T224974 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
$T225148 = 20						; size = 1
__Cat$225152 = 20					; size = 1
$T225150 = 20						; size = 1
$T225115 = 20						; size = 1
__Cat$225119 = 20					; size = 1
$T225117 = 20						; size = 1
$T225059 = 20						; size = 1
__Cat$225063 = 20					; size = 1
$T225061 = 20						; size = 1
$T225026 = 20						; size = 1
__Cat$225030 = 20					; size = 1
$T225028 = 20						; size = 1
$T224975 = 20						; size = 4
$T224973 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z PROC ; std::_Buffered_rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Count2$[esp+24]
	push	esi
	mov	esi, DWORD PTR __Tempbuf$[esp+28]
	push	edi
	mov	edi, DWORD PTR __Count1$[esp+32]
	cmp	edi, ebp
	jg	$LN4@Buffered_r
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEHXZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Maxlen
	cmp	edi, eax
	jg	$LN4@Buffered_r

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	ebp, DWORD PTR __Mid$[esp+32]
	mov	edi, DWORD PTR __First$[esp+32]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T224973[esp+52], esp
	push	ebp
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T224974[esp+60]
	push	edi
	push	eax
	call	??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
	mov	eax, DWORD PTR $T224974[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN25@Buffered_r
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Buffered_r:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	BYTE PTR $T225026[esp+32], bl
	mov	ecx, DWORD PTR $T225026[esp+32]
	mov	edx, DWORD PTR __Cat$225030[esp+32]
	mov	eax, DWORD PTR $T225028[esp+32]
	push	ecx
	push	edx
	push	eax
	push	edi
	mov	edi, DWORD PTR __Last$[esp+48]
	push	edi
	push	ebp
	call	??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	esi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [esi]
	mov	BYTE PTR $T225059[esp+56], bl
	mov	ecx, DWORD PTR $T225059[esp+56]
	mov	edx, DWORD PTR __Cat$225063[esp+56]
	push	ecx
	mov	ecx, DWORD PTR $T225061[esp+60]
	push	edx
	push	ecx
	push	edi
	push	eax
	push	esi
	call	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>
	add	esp, 48					; 00000030H

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN4@Buffered_r:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEHXZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Maxlen
	cmp	ebp, eax
	jg	$LN2@Buffered_r

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR __Last$[esp+32]
	mov	ebp, DWORD PTR __Mid$[esp+32]
	mov	DWORD PTR [eax+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T224975[esp+52], esp
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR [esi+16]
	lea	edx, DWORD PTR $T224976[esp+60]
	push	ebp
	push	edx
	mov	DWORD PTR [eax+16], ecx
	call	??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
	mov	eax, DWORD PTR $T224976[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN57@Buffered_r
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Buffered_r:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	BYTE PTR $T225115[esp+32], bl
	mov	eax, DWORD PTR $T225115[esp+32]
	mov	ecx, DWORD PTR __Cat$225119[esp+32]
	mov	edx, DWORD PTR $T225117[esp+32]
	push	eax
	push	ecx
	push	edx
	push	edi
	mov	edi, DWORD PTR __First$[esp+48]
	push	ebp
	push	edi
	call	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	esi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [esi]
	mov	BYTE PTR $T225148[esp+56], bl
	mov	ecx, DWORD PTR $T225148[esp+56]
	mov	edx, DWORD PTR __Cat$225152[esp+56]
	push	ecx
	mov	ecx, DWORD PTR $T225150[esp+60]
	push	edx
	push	ecx
	push	edi
	push	eax
	push	esi
	call	??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>
	add	esp, 48					; 00000030H

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN2@Buffered_r:

; 2696 : 		}
; 2697 : 	else
; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	esi, DWORD PTR __First$[esp+32]
	mov	eax, DWORD PTR __Mid$[esp+32]
	cmp	esi, eax
	je	SHORT $LN80@Buffered_r
	mov	ecx, DWORD PTR __Last$[esp+32]
	cmp	eax, ecx
	je	SHORT $LN80@Buffered_r
	xor	ebx, ebx
	push	ebx
	push	ebx
	push	ecx
	push	eax
	push	esi
	call	??$_Rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00PAH0@Z ; std::_Rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN80@Buffered_r:

; 2700 : 		std::advance(_First, _Count2);

	lea	edx, DWORD PTR [ebp+ebp*2]

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	lea	eax, DWORD PTR [esi+edx*8]
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Buffered_rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ENDP ; std::_Buffered_rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T225261 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
$T225337 = 24						; size = 1
$T225338 = 24						; size = 1
$T225262 = 24						; size = 1
__Count$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	push	ecx

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	edx, DWORD PTR __Count$[esp]
	mov	eax, DWORD PTR __Dest$[esp]
	mov	ecx, DWORD PTR __First$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Chunk$[esp+4]
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp+ebp]
	cmp	edi, edx
	jg	SHORT $LN3@Chunked_me
	lea	ebp, DWORD PTR [ebp+ebp*2]
	add	ebp, ebp
	add	ebp, ebp
	add	ebp, ebp
	push	ebx
	npad	9
$LL50@Chunked_me:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	mov	BYTE PTR $T225261[esp+20], 0
	mov	ebx, DWORD PTR $T225261[esp+20]
	push	ebx
	mov	ebx, DWORD PTR $T225262[esp+20]
	push	ebx
	lea	edx, DWORD PTR [ecx+ebp]
	push	eax
	lea	esi, DWORD PTR [edx+ebp]
	push	esi
	push	edx
	push	edx
	push	ecx
	call	??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>
	mov	edx, DWORD PTR __Count$[esp+44]
	sub	edx, edi
	add	esp, 28					; 0000001cH
	cmp	edx, edi

; 3297 : 		_First = _Mid2;

	mov	ecx, esi
	mov	DWORD PTR __Count$[esp+16], edx
	jge	SHORT $LL50@Chunked_me
	mov	ebp, DWORD PTR __Chunk$[esp+16]
	pop	ebx
$LN3@Chunked_me:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	cmp	edx, ebp
	jg	SHORT $LN2@Chunked_me

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	edx, DWORD PTR __Last$[esp+12]
	cmp	ecx, edx
	je	SHORT $LN41@Chunked_me
	sub	eax, ecx
$LL32@Chunked_me:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax+ecx], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+ecx+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+ecx+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+ecx+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+ecx+16], esi
	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+ecx+20], esi
	add	ecx, 24					; 00000018H
	cmp	ecx, edx
	jne	SHORT $LL32@Chunked_me
	pop	edi
	pop	esi
	pop	ebp

; 3308 : 		}
; 3309 : 	}

	pop	ecx
	ret	0
$LN2@Chunked_me:

; 3302 : 	else
; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);
; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	BYTE PTR $T225337[esp+12], 0
	mov	esi, DWORD PTR $T225337[esp+12]
	push	esi
	mov	esi, DWORD PTR $T225338[esp+16]
	push	esi
	push	eax
	mov	eax, DWORD PTR __Last$[esp+24]
	push	eax
	lea	edx, DWORD PTR [ebp+ebp*2]
	lea	edx, DWORD PTR [ecx+edx*8]
	push	edx
	push	edx
	push	ecx
	call	??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
$LN41@Chunked_me:
	pop	edi
	pop	esi
	pop	ebp

; 3308 : 		}
; 3309 : 	}

	pop	ecx
	ret	0
??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T225363 = -24						; size = 4
$T225356 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
$T225357 = 12						; size = 4
$T225355 = 12						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,std::forward_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	ebp, DWORD PTR __Last1$[esp+28]
	push	esi
	mov	esi, DWORD PTR __First1$[esp+32]
	xor	ebx, ebx
	push	edi
	mov	edi, DWORD PTR __First2$[esp+36]
	mov	DWORD PTR $T225363[esp+40], ebx
	cmp	esi, ebp
	je	SHORT $LN3@Merge@2
	npad	3
$LL4@Merge@2:
	cmp	edi, DWORD PTR __Last2$[esp+36]
	je	SHORT $LN3@Merge@2

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	eax, DWORD PTR [edi+20]
	cmp	eax, DWORD PTR [esi+20]

; 2515 : 			*_Dest = *_First2, ++_First2;

	lea	ecx, DWORD PTR __Dest$[esp+36]
	jle	SHORT $LN2@Merge@2
	push	edi
	call	??4?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@ABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator=
	add	edi, 24					; 00000018H

; 2516 : 		else

	jmp	SHORT $LN1@Merge@2
$LN2@Merge@2:

; 2517 : 			*_Dest = *_First1, ++_First1;

	push	esi
	call	??4?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@ABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator=
	add	esi, 24					; 00000018H
$LN1@Merge@2:

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	cmp	esi, ebp
	jne	SHORT $LL4@Merge@2
$LN3@Merge@2:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T225355[esp+56], esp
	push	ebp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+76]
	lea	edx, DWORD PTR $T225356[esp+64]
	push	esi
	push	edx
	mov	DWORD PTR [eax+16], ecx
	call	??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR __Dest$[esp+84], eax
	mov	eax, DWORD PTR $T225356[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN36@Merge@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN36@Merge@2:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __Last2$[esp+36]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+36]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T225357[esp+56], esp
	push	edx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+76]
	push	edi
	push	esi
	mov	DWORD PTR [eax+16], ecx
	call	??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
	mov	eax, DWORD PTR __Dest$[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN57@Merge@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Merge@2:

; 2521 : 	}

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	?Update@CvBuilderTaskingAI@@QAEXXZ		; CvBuilderTaskingAI::Update
EXTRN	?GetBestYieldAverageTimes100@CvCityStrategyAI@@QAEGW4YieldTypes@@@Z:PROC ; CvCityStrategyAI::GetBestYieldAverageTimes100
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
EXTRN	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::IsEmpireUnhappy
EXTRN	?UpdateBestYields@CvCityStrategyAI@@QAEXXZ:PROC	; CvCityStrategyAI::UpdateBestYields
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?Update@CvBuilderTaskingAI@@QAEXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Update@CvBuilderTaskingAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Update@CvBuilderTaskingAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$3
	DD	02H
	DD	FLAT:__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$4
	DD	02H
	DD	FLAT:__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$6
	DD	04H
	DD	FLAT:__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?Update@CvBuilderTaskingAI@@QAEXXZ
_TEXT	SEGMENT
_bShowOutput$218236 = -160				; size = 1
$T225451 = -160						; size = 4
$T225450 = -160						; size = 4
$T225449 = -160						; size = 4
$T225447 = -160						; size = 4
_iLoop$ = -156						; size = 4
_strYield$218255 = -152					; size = 28
_str$218245 = -124					; size = 28
$T225448 = -96						; size = 28
_str$218238 = -96					; size = 28
_strCityName$218247 = -68				; size = 28
_strNumbers$218272 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?Update@CvBuilderTaskingAI@@QAEXXZ PROC			; CvBuilderTaskingAI::Update, COMDAT
; _this$ = ecx

; 182  : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?Update@CvBuilderTaskingAI@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 148				; 00000094H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 183  : 	UpdateRoutePlots();

	call	?UpdateRoutePlots@CvBuilderTaskingAI@@QAEXXZ ; CvBuilderTaskingAI::UpdateRoutePlots

; 184  : 	m_iNumCities = m_pPlayer->getNumCities();

	mov	ecx, DWORD PTR [edi]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities

; 185  : 
; 186  : 	int iLoop;
; 187  : 	CvCity* pCity;
; 188  : 	for(pCity = m_pPlayer->firstCity(&iLoop); pCity != NULL; pCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [edi+58396], eax
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+180]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN18@Update
$LL20@Update:

; 189  : 	{
; 190  : 		pCity->GetCityStrategyAI()->UpdateBestYields();

	mov	ecx, eax
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?UpdateBestYields@CvCityStrategyAI@@QAEXXZ ; CvCityStrategyAI::UpdateBestYields
	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+180]
	push	ecx
	mov	ecx, DWORD PTR [edi]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL20@Update
$LN18@Update:

; 191  : 	}
; 192  : 
; 193  : 	if(m_bLogging)

	cmp	BYTE PTR [edi+58392], 0
	je	$LN13@Update

; 194  : 	{
; 195  : 		bool bShowOutput = m_pPlayer->isHuman();

	mov	ecx, DWORD PTR [edi]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman

; 196  : 
; 197  : 		if(m_pPlayer->IsEmpireUnhappy())

	mov	ecx, DWORD PTR [edi]
	mov	BYTE PTR _bShowOutput$218236[esp+176], al
	call	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ	; CvPlayer::IsEmpireUnhappy
	mov	ebx, DWORD PTR _bShowOutput$218236[esp+176]
	test	al, al
	je	SHORT $LN16@Update

; 198  : 		{
; 199  : 			CvString str = "// Empire Unhappy! //";

	push	OFFSET $SG218239
	lea	ecx, DWORD PTR _str$218238[esp+180]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 200  : 			LogInfo(str, m_pPlayer, bShowOutput);

	mov	edx, DWORD PTR [edi]
	push	ebx
	push	edx
	sub	esp, 28					; 0000001cH
	lea	eax, DWORD PTR _str$218238[esp+212]
	mov	DWORD PTR $T225447[esp+212], esp
	mov	ecx, esp
	push	eax
	mov	DWORD PTR __$EHRec$[esp+224], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 201  : 		}

	lea	ecx, DWORD PTR _str$218238[esp+176]
	mov	DWORD PTR __$EHRec$[esp+184], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN16@Update:

; 202  : 
; 203  : 		// show crisis states
; 204  : 		CvCity* pLoopCity;
; 205  : 		for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+180]
	push	ecx
	mov	ecx, DWORD PTR [edi]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebp, eax
	test	ebp, ebp
	je	$LN13@Update
$LN15@Update:

; 206  : 		{
; 207  : 			CvString str;

	lea	ecx, DWORD PTR _str$218245[esp+176]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 208  : 			str += "// ";

	push	OFFSET $SG218246
	lea	ecx, DWORD PTR _str$218245[esp+180]
	mov	DWORD PTR __$EHRec$[esp+188], 1
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 209  : 			CvString strCityName;

	lea	ecx, DWORD PTR _strCityName$218247[esp+176]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 210  : 			strCityName = pLoopCity->getName();

	lea	edx, DWORD PTR $T225448[esp+176]
	push	edx
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+188], 2
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _strCityName$218247[esp+180]
	mov	BYTE PTR __$EHRec$[esp+188], 3
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T225448[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 211  : 			str += strCityName;

	lea	eax, DWORD PTR _strCityName$218247[esp+176]
	push	eax
	lea	ecx, DWORD PTR _str$218245[esp+180]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 212  : 			str += " \\\\";

	push	OFFSET $SG218249
	lea	ecx, DWORD PTR _str$218245[esp+180]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 213  : 
; 214  : 			LogInfo(str, m_pPlayer, bShowOutput);

	mov	ecx, DWORD PTR [edi]
	push	ebx
	push	ecx
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _str$218245[esp+212]
	mov	DWORD PTR $T225449[esp+212], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 215  : 
; 216  : #ifdef AUI_WARNING_FIXES
; 217  : 			for (int ui = 0; ui < NUM_YIELD_TYPES; ui++)
; 218  : #else
; 219  : 			for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	xor	esi, esi
	npad	6
$LL12@Update:

; 220  : #endif
; 221  : 			{
; 222  : 				//double fYield = pLoopCity->GetCityStrategyAI()->GetYieldAverage((YieldTypes)ui);
; 223  : 				//double fYieldDeficient = pLoopCity->GetCityStrategyAI()->GetDeficientYieldValue((YieldTypes)ui);
; 224  : 				CvString strYield;

	lea	ecx, DWORD PTR _strYield$218255[esp+176]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+184], 4

; 225  : 				switch(ui)

	cmp	esi, 5
	ja	SHORT $LN81@Update
	jmp	DWORD PTR $LN119@Update[esi*4]
$LN7@Update:

; 226  : 				{
; 227  : 				case YIELD_FOOD:
; 228  : 					strYield = "food       ";

	push	OFFSET $SG218261

; 229  : 					break;

	jmp	SHORT $LN118@Update
$LN6@Update:

; 230  : 				case YIELD_PRODUCTION:
; 231  : 					strYield = "production ";

	push	OFFSET $SG218263

; 232  : 					break;

	jmp	SHORT $LN118@Update
$LN5@Update:

; 233  : 				case YIELD_SCIENCE:
; 234  : 					strYield = "science    ";

	push	OFFSET $SG218265

; 235  : 					break;

	jmp	SHORT $LN118@Update
$LN4@Update:

; 236  : 				case YIELD_GOLD:
; 237  : 					strYield = "gold       ";

	push	OFFSET $SG218267

; 238  : 					break;

	jmp	SHORT $LN118@Update
$LN3@Update:

; 239  : 				case YIELD_CULTURE:
; 240  : 					strYield = "culture    ";

	push	OFFSET $SG218269

; 241  : 					break;

	jmp	SHORT $LN118@Update
$LN2@Update:

; 242  : 				case YIELD_FAITH:
; 243  : 					strYield = "faith      ";

	push	OFFSET $SG218271
$LN118@Update:
	lea	ecx, DWORD PTR _strYield$218255[esp+180]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN81@Update:

; 244  : 					break;
; 245  : 				}
; 246  : 
; 247  : 				CvString strNumbers;

	lea	ecx, DWORD PTR _strNumbers$218272[esp+176]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 248  : 				strNumbers.Format("%d, %d", pLoopCity->GetCityStrategyAI()->GetBestYieldAverageTimes100((YieldTypes)ui), pLoopCity->GetCityStrategyAI()->GetYieldDeltaTimes100((YieldTypes)ui));

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+188], 5
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetYieldDeltaTimes100@CvCityStrategyAI@@QAEFW4YieldTypes@@@Z ; CvCityStrategyAI::GetYieldDeltaTimes100
	cwde
	push	eax
	push	esi
	mov	ecx, ebp
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetBestYieldAverageTimes100@CvCityStrategyAI@@QAEGW4YieldTypes@@@Z ; CvCityStrategyAI::GetBestYieldAverageTimes100
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR _strNumbers$218272[esp+184]
	push	OFFSET $SG218275
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 249  : 
; 250  : 				//int iYieldAdjusted = (int)workerround(fYield * 100);
; 251  : 				//int iYieldDeficientAdjacent = (int)workerround(fYieldDeficient * 100);
; 252  : 
; 253  : 				//strNumbers.Format("%d / %d", iYieldAdjusted, iYieldDeficientAdjacent);
; 254  : 				strYield += strNumbers;

	lea	eax, DWORD PTR _strNumbers$218272[esp+176]
	push	eax
	lea	ecx, DWORD PTR _strYield$218255[esp+180]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 255  : 
; 256  : 				if(ui == pLoopCity->GetCityStrategyAI()->GetFocusYield())

	mov	ecx, ebp
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetFocusYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ ; CvCityStrategyAI::GetFocusYield
	cmp	esi, eax
	jne	SHORT $LN1@Update

; 257  : 				{
; 258  : 					strYield += " *";

	push	OFFSET $SG218277
	lea	ecx, DWORD PTR _strYield$218255[esp+180]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN1@Update:

; 259  : 				}
; 260  : 
; 261  : 				//if (iYieldAdjusted < iYieldDeficientAdjacent)
; 262  : 				//{
; 263  : 				//if (GetDeficientYield(pLoopCity, false) != GetDeficientYield(pLoopCity, true))
; 264  : 				//{
; 265  : 				//	strYield += "  Problem, but happiness over is overriding it";
; 266  : 				//}
; 267  : 				//else
; 268  : 				//{
; 269  : 				//	strYield += "  PROBLEM!!";
; 270  : 				//}
; 271  : 				//}
; 272  : 				LogInfo(strYield, m_pPlayer, bShowOutput);

	mov	ecx, DWORD PTR [edi]
	push	ebx
	push	ecx
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strYield$218255[esp+212]
	mov	DWORD PTR $T225450[esp+212], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 273  : 			}

	lea	ecx, DWORD PTR _strNumbers$218272[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strYield$218255[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	inc	esi
	cmp	esi, 6
	jb	$LL12@Update

; 274  : 
; 275  : 			str = "\\\\ end ";

	push	OFFSET $SG218279
	lea	ecx, DWORD PTR _str$218245[esp+180]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : 			str += strCityName;

	lea	eax, DWORD PTR _strCityName$218247[esp+176]
	push	eax
	lea	ecx, DWORD PTR _str$218245[esp+180]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 277  : 			str += " //";

	push	OFFSET $SG218280
	lea	ecx, DWORD PTR _str$218245[esp+180]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 278  : 			LogInfo(str, m_pPlayer, bShowOutput);

	mov	ecx, DWORD PTR [edi]
	push	ebx
	push	ecx
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _str$218245[esp+212]
	mov	DWORD PTR $T225451[esp+212], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 279  : 		}

	lea	ecx, DWORD PTR _strCityName$218247[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _str$218245[esp+176]
	mov	DWORD PTR __$EHRec$[esp+184], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR [edi]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+180]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebp, eax
	test	ebp, ebp
	jne	$LN15@Update
$LN13@Update:

; 280  : 	}
; 281  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+176]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 160				; 000000a0H
	ret	0
	npad	1
$LN119@Update:
	DD	$LN7@Update
	DD	$LN6@Update
	DD	$LN4@Update
	DD	$LN5@Update
	DD	$LN3@Update
	DD	$LN2@Update
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _str$218238[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$2:
	lea	ecx, DWORD PTR _str$218245[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$3:
	lea	ecx, DWORD PTR _strCityName$218247[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$4:
	lea	ecx, DWORD PTR $T225448[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$6:
	lea	ecx, DWORD PTR _strYield$218255[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$7:
	lea	ecx, DWORD PTR _strNumbers$218272[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?Update@CvBuilderTaskingAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?Update@CvBuilderTaskingAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Update@CvBuilderTaskingAI@@QAEXXZ ENDP			; CvBuilderTaskingAI::Update
PUBLIC	?push_back@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEIABUBuilderDirective@@H@Z ; CvWeightedVector<BuilderDirective,100,1>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?push_back@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEIABUBuilderDirective@@H@Z
_TEXT	SEGMENT
_weightedElem$ = -24					; size = 24
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEIABUBuilderDirective@@H@Z PROC ; CvWeightedVector<BuilderDirective,100,1>::push_back, COMDAT
; _this$ = ecx

; 103  : 	{

	sub	esp, 24					; 00000018H

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;
; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[esp+20]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _weightedElem$[esp+24], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _weightedElem$[esp+28], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _weightedElem$[esp+32], edx
	mov	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR _weightedElem$[esp+40], eax
	mov	DWORD PTR _weightedElem$[esp+36], edx

; 108  : 		weightedElem.m_iWeight = iWeight;

	mov	edx, DWORD PTR _iWeight$[esp+20]

; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	lea	eax, DWORD PTR _weightedElem$[esp+24]
	push	eax
	mov	DWORD PTR _weightedElem$[esp+48], edx
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::push_back

; 111  : 	};

	add	esp, 24					; 00000018H
	ret	8
?push_back@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEIABUBuilderDirective@@H@Z ENDP ; CvWeightedVector<BuilderDirective,100,1>::push_back
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Buffered_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z
_TEXT	SEGMENT
__Firstn$219913 = -28					; size = 4
__Midn$219933 = -24					; size = 4
$T225601 = -20						; size = 20
$T225599 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
tv368 = 20						; size = 4
__Count1$ = 20						; size = 4
$T225711 = 24						; size = 1
$T225660 = 24						; size = 1
$T225661 = 24						; size = 1
$T225600 = 24						; size = 4
$T225598 = 24						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z PROC ; std::_Buffered_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 2759 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<

	sub	esp, 28					; 0000001cH
	push	ebx

; 2760 : 	if (_Count1 + _Count2 == 2)

	mov	ebx, DWORD PTR __Count1$[esp+28]
	push	ebp
	mov	ebp, DWORD PTR __Mid$[esp+32]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+40]
	lea	eax, DWORD PTR [ebx+edi]
	cmp	eax, 2
	je	$LN103@Buffered_m
	jmp	SHORT $LN98@Buffered_m
$LL110@Buffered_m:
	mov	edi, DWORD PTR __Count2$[esp+40]
	mov	ebx, DWORD PTR __Count1$[esp+40]
$LN98@Buffered_m:

; 2764 : 		}
; 2765 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	cmp	ebx, edi
	mov	esi, DWORD PTR __Tempbuf$[esp+40]
	jg	SHORT $LN6@Buffered_m
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEHXZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Maxlen
	cmp	ebx, eax
	jle	$LN104@Buffered_m
$LN6@Buffered_m:

; 2769 : 		}
; 2770 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEHXZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Maxlen
	cmp	edi, eax
	jle	$LN105@Buffered_m

; 2775 : 		}
; 2776 : 	else
; 2777 : 		{	// buffer too small, divide and conquer
; 2778 : 		_BidIt _Firstn, _Lastn;
; 2779 : 		_Diff _Count1n, _Count2n;
; 2780 : 
; 2781 : 		if (_Count2 < _Count1)

	cmp	edi, ebx

; 2782 : 			{	// left larger, cut it in half and partition right to match
; 2783 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2784 : 			_Firstn = _First;
; 2785 : 			std::advance(_Firstn, _Count1n);
; 2786 : 			_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);

	push	0
	jge	SHORT $LN2@Buffered_m
	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __First$[esp+44]
	mov	edi, eax
	sar	edi, 1
	lea	ecx, DWORD PTR [edi+edi*2]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	DWORD PTR __Firstn$219913[esp+52], eax
	mov	eax, DWORD PTR __Last$[esp+48]
	push	eax
	push	ebp
	call	??$_Lower_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z ; std::_Lower_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement,int>
	mov	ebx, eax

; 2787 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	ecx, ebx
	sub	ecx, ebp
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx

; 2788 : 			}
; 2789 : 		else

	mov	ecx, DWORD PTR __Firstn$219913[esp+60]
	sar	edx, 2
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esp, 16					; 00000010H
	add	esi, edx
	jmp	SHORT $LN96@Buffered_m
$LN2@Buffered_m:

; 2790 : 			{	// right larger, cut it in half and partition left to match
; 2791 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	eax, edi

; 2792 : 			_Lastn = _Mid;
; 2793 : 			std::advance(_Lastn, _Count2n);
; 2794 : 			_Firstn = std::upper_bound(_First, _Mid, *_Lastn);

	mov	edi, DWORD PTR __First$[esp+44]
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	lea	ecx, DWORD PTR [esi+esi*2]
	lea	ebx, DWORD PTR [ebp+ecx*8]
	push	ebx
	push	ebp
	push	edi
	call	??$_Upper_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z ; std::_Upper_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement,int>
	mov	ecx, eax

; 2795 : 			_Distance(_First, _Firstn, _Count1n);

	mov	edx, ecx
	sub	edx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Firstn$219913[esp+44], ecx
	add	edi, edx
$LN96@Buffered_m:

; 2796 : 			}
; 2797 : 
; 2798 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2799 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	edx, DWORD PTR __Tempbuf$[esp+40]
	mov	eax, DWORD PTR __Count1$[esp+40]
	push	edx
	push	esi
	sub	eax, edi
	push	eax
	push	ebx
	push	ebp
	push	ecx
	mov	DWORD PTR tv368[esp+64], eax
	call	??$_Buffered_rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Buffered_rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>

; 2800 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2801 : 			_Count1n, _Count2n, _Tempbuf);	// merge each new part

	mov	ecx, DWORD PTR __Tempbuf$[esp+64]
	mov	edx, DWORD PTR __Firstn$219913[esp+68]
	push	ecx
	push	esi
	push	edi
	push	eax
	mov	DWORD PTR __Midn$219933[esp+84], eax
	mov	eax, DWORD PTR __First$[esp+80]
	push	edx
	push	eax
	call	??$_Buffered_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Buffered_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>

; 2802 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2803 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);

	mov	eax, DWORD PTR __Count2$[esp+88]
	mov	ecx, DWORD PTR tv368[esp+88]
	mov	edx, DWORD PTR __Midn$219933[esp+92]
	sub	eax, esi
	mov	DWORD PTR __Count1$[esp+88], ecx
	add	ecx, eax
	add	esp, 48					; 00000030H
	mov	DWORD PTR __Count2$[esp+40], eax
	mov	ebp, ebx
	mov	DWORD PTR __First$[esp+40], edx
	cmp	ecx, 2
	jne	$LL110@Buffered_m
$LN103@Buffered_m:

; 2761 : 		{	// order two one-element partitions
; 2762 : 		if (_DEBUG_LT(*_Mid, *_First))

	mov	ecx, DWORD PTR [ebp+20]
	mov	eax, DWORD PTR __First$[esp+40]
	cmp	ecx, DWORD PTR [eax+20]
	jle	$LN3@Buffered_m

; 2763 : 			std::iter_swap(_First, _Mid);

	push	ebp
	push	eax
	call	??$swap@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z ; std::swap<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 8

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN104@Buffered_m:

; 2766 : 		{	// buffer left partition, then merge
; 2767 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR __First$[esp+40]
	mov	DWORD PTR [eax+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T225598[esp+60], esp
	xor	ebx, ebx
	push	ebp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR [esi+16]
	lea	edx, DWORD PTR $T225599[esp+68]
	push	edi
	push	edx
	mov	DWORD PTR [eax+16], ecx
	call	??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
	mov	eax, DWORD PTR $T225599[esp+76]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN34@Buffered_m
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@Buffered_m:

; 2768 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);

	mov	edx, DWORD PTR __Last$[esp+40]
	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T225660[esp+40], 0
	mov	eax, DWORD PTR $T225660[esp+40]
	mov	ecx, DWORD PTR $T225661[esp+40]
	push	eax
	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	edi
	push	edx
	push	ebp
	push	eax
	push	ecx
	call	??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN105@Buffered_m:

; 2771 : 		{	// buffer right partition, then merge
; 2772 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR __Last$[esp+40]
	mov	DWORD PTR [eax+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T225600[esp+60], esp
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR [esi+16]
	lea	edx, DWORD PTR $T225601[esp+68]
	push	ebp
	push	edx
	mov	DWORD PTR [eax+16], ecx
	call	??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
	mov	eax, DWORD PTR $T225601[esp+76]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN58@Buffered_m
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN58@Buffered_m:

; 2773 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid,
; 2774 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last);

	mov	esi, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	mov	BYTE PTR $T225711[esp+40], 0
	mov	eax, DWORD PTR $T225711[esp+40]
	push	eax
	mov	eax, DWORD PTR __First$[esp+44]
	push	edi
	push	ecx
	push	edx
	push	ebp
	push	eax
	call	??$_Merge_backward@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
	add	esp, 24					; 00000018H
$LN3@Buffered_m:

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
??$_Buffered_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ENDP ; std::_Buffered_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HH@Z ; stdext::_Unchecked_chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HH@Z
_TEXT	SEGMENT
$T225817 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	mov	BYTE PTR $T225817[esp+4], 0
	mov	eax, DWORD PTR $T225817[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>

; 5254 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V12@@Z ; stdext::unchecked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V12@@Z
_TEXT	SEGMENT
$T225821 = -4						; size = 1
$T225827 = -4						; size = 4
$T225823 = -4						; size = 4
$T225822 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V12@@Z PROC ; stdext::unchecked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T225827[esp+8], ebx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T225822[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T225821[esp+12], bl
	mov	eax, DWORD PTR $T225821[esp+12]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+16]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last2$[esp+36]
	mov	edx, DWORD PTR __Last1$[esp+36]
	mov	DWORD PTR $T225823[esp+40], esp
	push	eax
	mov	eax, DWORD PTR __First1$[esp+40]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+56]
	add	esp, 48					; 00000030H
	cmp	eax, ebx
	je	SHORT $LN25@unchecked_@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@unchecked_@2:
	mov	eax, esi

; 5117 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V12@@Z ENDP ; stdext::unchecked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
_TEXT	ENDS
PUBLIC	?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddImprovingResourcesDirectives
EXTRN	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z:PROC ; CvUnit::canBuild
EXTRN	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::IsImprovementResourceTrade
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?HasSpecialImprovement@CvPlot@@QBE_NXZ:PROC	; CvPlot::HasSpecialImprovement
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$2
__ehfuncinfo$?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
_TEXT	SEGMENT
_eExistingPlotImprovement$ = -112			; size = 4
_eResource$ = -108					; size = 4
_iBuildTimeWeight$218563 = -104				; size = 4
_iInvestedImprovementTime$218551 = -104			; size = 4
_eDirectiveType$218548 = -100				; size = 4
_iBuildIndex$ = -96					; size = 4
_pLogCity$218566 = -92					; size = 4
_eImprovement$218536 = -92				; size = 4
_directive$218574 = -88					; size = 20
_strLog$218570 = -68					; size = 28
_strTemp$218576 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
$T225868 = 12						; size = 4
$T225867 = 12						; size = 4
_iProduction$218567 = 12				; size = 4
_iBuildIndex2$218555 = 12				; size = 4
_pPlot$ = 12						; size = 4
_iMoveTurnsAway$ = 16					; size = 4
?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z PROC ; CvBuilderTaskingAI::AddImprovingResourcesDirectives, COMDAT
; _this$ = ecx

; 1008 : {

	push	-1
	push	__ehhandler$?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	ebp

; 1009 : #ifdef AUI_WARNING_FIXES
; 1010 : 	if (!pUnit)
; 1011 : 		return;
; 1012 : #endif
; 1013 : 
; 1014 : 	ImprovementTypes eExistingPlotImprovement = pPlot->getImprovementType();

	mov	ebp, DWORD PTR _pPlot$[esp+116]
	push	esi
	mov	esi, ecx
	push	edi
	mov	ecx, ebp
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	mov	DWORD PTR _eExistingPlotImprovement$[esp+128], eax

; 1015 : 
; 1016 : 	// Do we have a special improvement here? (great person improvement, gifted improvement from major civ)
; 1017 : 	if(eExistingPlotImprovement != NO_IMPROVEMENT && pPlot->HasSpecialImprovement() && !pPlot->IsImprovementPillaged())

	cmp	eax, -1
	je	SHORT $LN28@AddImprovi
	mov	ecx, ebp
	call	?HasSpecialImprovement@CvPlot@@QBE_NXZ	; CvPlot::HasSpecialImprovement
	test	al, al
	je	SHORT $LN28@AddImprovi
	mov	ecx, ebp
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	test	al, al
	je	$LN17@AddImprovi
$LN28@AddImprovi:

; 1018 : 	{
; 1019 : 		return;
; 1020 : 	}
; 1021 : 
; 1022 : 	// check to see if a resource is here. If not, bail out!
; 1023 : 	ResourceTypes eResource = pPlot->getResourceType(m_pPlayer->getTeam());

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN39@AddImprovi
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN40@AddImprovi
$LN39@AddImprovi:
	or	eax, -1
$LN40@AddImprovi:
	push	eax
	mov	ecx, ebp
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[esp+128], eax

; 1024 : 	if(eResource == NO_RESOURCE)

	cmp	eax, -1
	je	$LN17@AddImprovi

; 1025 : 	{
; 1026 : 		return;
; 1027 : 	}
; 1028 : 
; 1029 : 	CvResourceInfo* pkResource = GC.getResourceInfo(eResource);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 1030 : 	if(pkResource->getResourceUsage() == RESOURCEUSAGE_BONUS)

	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	test	eax, eax
	je	$LN17@AddImprovi

; 1031 : 	{
; 1032 : 		// evaluate bonus resources as normal improvements
; 1033 : 		return;
; 1034 : 	}
; 1035 : 
; 1036 : #ifdef AUI_WORKER_FIX_SHOULD_BUILDER_CONSIDER_PLOT_EXISTING_BUILD_MISSIONS_SHIFT
; 1037 : 	// check to see if someone already has a conflicting mission here
; 1038 : 	if (pUnit->GetMissionAIPlot() != pPlot)
; 1039 : 	{
; 1040 : 		int iLoop;
; 1041 : 		for (CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))
; 1042 : 		{
; 1043 : 			if (pUnit == pLoopUnit)
; 1044 : 			{
; 1045 : 				continue;
; 1046 : 			}
; 1047 : 
; 1048 : 			CvPlot* pMissionPlot = pLoopUnit->GetMissionAIPlot();
; 1049 : 			if (!pMissionPlot)
; 1050 : 			{
; 1051 : 				continue;
; 1052 : 			}
; 1053 : 
; 1054 : 			MissionAITypes eGroupMissionAI = pLoopUnit->GetMissionAIType();
; 1055 : 			if (eGroupMissionAI != MISSIONAI_BUILD)
; 1056 : 			{
; 1057 : 				continue;
; 1058 : 			}
; 1059 : 
; 1060 : 			if (pPlot->getX() == pMissionPlot->getX() && pPlot->getY() == pMissionPlot->getY())
; 1061 : 			{
; 1062 : 				BuildTypes eOtherBuild = pLoopUnit->getBuildType();
; 1063 : 				CvBuildInfo* pkBuild = GC.getBuildInfo(eOtherBuild);
; 1064 : 				if (pkBuild != NULL)
; 1065 : 				{
; 1066 : 					ImprovementTypes eImprovement = (ImprovementTypes)pkBuild->getImprovement();
; 1067 : 					if (eImprovement != NO_IMPROVEMENT || (eOtherBuild == m_eRepairBuild && eExistingPlotImprovement != NO_IMPROVEMENT))
; 1068 : 					{
; 1069 : 						if (m_bLogging)
; 1070 : 						{
; 1071 : 							CvString strLog;
; 1072 : 							strLog.Format("x: %d y: %d, Somebody has a conflicting mission here.", pPlot->getX(), pPlot->getY());
; 1073 : 							LogInfo(strLog, m_pPlayer, true);
; 1074 : 						}
; 1075 : 						return;
; 1076 : 					}
; 1077 : 				}
; 1078 : 			}
; 1079 : 		}
; 1080 : 	}
; 1081 : #endif
; 1082 : 
; 1083 : 	// loop through the build types to find one that we can use
; 1084 : 	BuildTypes eBuild;
; 1085 : 	BuildTypes eOriginalBuild;
; 1086 : #ifdef AUI_WARNING_FIXES
; 1087 : 	uint iBuildIndex;
; 1088 : #else
; 1089 : 	int iBuildIndex;
; 1090 : #endif
; 1091 : 	for(iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	xor	ebx, ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iBuildIndex$[esp+128], ebx
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	$LN17@AddImprovi
$LN25@AddImprovi:

; 1092 : 	{
; 1093 : 		eBuild = (BuildTypes)iBuildIndex;
; 1094 : 		CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 1095 : 		if(pkBuild == NULL)

	test	eax, eax
	je	$LN24@AddImprovi

; 1096 : 			continue;
; 1097 : 
; 1098 : 		eOriginalBuild = eBuild;
; 1099 : 		ImprovementTypes eImprovement = (ImprovementTypes)pkBuild->getImprovement();

	mov	ecx, eax
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	edi, eax
	mov	DWORD PTR _eImprovement$218536[esp+128], edi

; 1100 : 		if(eImprovement == NO_IMPROVEMENT)

	cmp	edi, -1
	je	$LN24@AddImprovi

; 1101 : 		{
; 1102 : 			continue;
; 1103 : 		}
; 1104 : 
; 1105 : 		CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo

; 1106 : 		if(pkImprovementInfo == NULL || !pkImprovementInfo->IsImprovementResourceTrade(eResource))

	test	eax, eax
	je	$LN24@AddImprovi
	mov	ecx, DWORD PTR _eResource$[esp+128]
	push	ecx
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	test	al, al
	je	$LN24@AddImprovi

; 1107 : 		{
; 1108 : 			continue;
; 1109 : 		}
; 1110 : 
; 1111 : 		if(eImprovement == eExistingPlotImprovement)

	mov	eax, DWORD PTR _eExistingPlotImprovement$[esp+128]
	cmp	edi, eax
	jne	SHORT $LN18@AddImprovi

; 1112 : 		{
; 1113 : 			if(pPlot->IsImprovementPillaged())

	mov	ecx, ebp
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	test	al, al
	je	$LN17@AddImprovi

; 1114 : 			{
; 1115 : 				eBuild = m_eRepairBuild;

	mov	ebx, DWORD PTR [esi+4]

; 1116 : 			}
; 1117 : 			else
; 1118 : 			{
; 1119 : 				// this plot already has the appropriate improvement to use the resource
; 1120 : 				break;
; 1121 : 			}
; 1122 : 		}
; 1123 : 		else

	jmp	SHORT $LN14@AddImprovi
$LN18@AddImprovi:

; 1124 : 		{
; 1125 : 			// Do we have a special improvement here? (great person improvement, gifted improvement from major civ)
; 1126 : 			if (eExistingPlotImprovement != NO_IMPROVEMENT && pPlot->HasSpecialImprovement())

	cmp	eax, -1
	je	SHORT $LN14@AddImprovi
	mov	ecx, ebp
	call	?HasSpecialImprovement@CvPlot@@QBE_NXZ	; CvPlot::HasSpecialImprovement
	test	al, al
	jne	$LN24@AddImprovi
$LN14@AddImprovi:

; 1127 : 				continue;
; 1128 : 		}
; 1129 : 
; 1130 : 		if(!pUnit->canBuild(pPlot, eBuild))

	mov	ecx, DWORD PTR _pUnit$[esp+124]
	push	1
	push	0
	push	ebx
	push	ebp
	call	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z ; CvUnit::canBuild
	test	al, al
	je	$LN17@AddImprovi

; 1131 : 		{
; 1132 : 			break;
; 1133 : 		}
; 1134 : 
; 1135 : 		BuilderDirective::BuilderDirectiveType eDirectiveType = BuilderDirective::BUILD_IMPROVEMENT_ON_RESOURCE;
; 1136 : 		int iWeight = GC.getBUILDER_TASKING_BASELINE_BUILD_RESOURCE_IMPROVEMENTS();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2144
	mov	DWORD PTR _eDirectiveType$218548[esp+128], 0

; 1137 : 		if(eBuild == m_eRepairBuild)

	cmp	ebx, DWORD PTR [esi+4]
	jne	SHORT $LN46@AddImprovi

; 1138 : 		{
; 1139 : 			eDirectiveType = BuilderDirective::REPAIR;
; 1140 : 			iWeight = GC.getBUILDER_TASKING_BASELINE_REPAIR();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2152
	mov	DWORD PTR _eDirectiveType$218548[esp+128], 3
$LN46@AddImprovi:

; 1141 : 		}
; 1142 : 
; 1143 : 		iWeight = GetBuildCostWeight(iWeight, pPlot, eBuild);

	push	ebx
	push	ebp
	push	eax
	mov	ecx, esi
	call	?GetBuildCostWeight@CvBuilderTaskingAI@@QAEHHPAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::GetBuildCostWeight
	mov	edi, eax

; 1144 : 
; 1145 : 		// this is to deal with when the plot is already improved with another improvement that doesn't enable the resource
; 1146 : 		int iInvestedImprovementTime = 0;

	xor	eax, eax

; 1147 : 		if(eExistingPlotImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eExistingPlotImprovement$[esp+128], -1
	mov	DWORD PTR _iInvestedImprovementTime$218551[esp+128], eax
	je	SHORT $LN6@AddImprovi

; 1148 : 		{
; 1149 : 			BuildTypes eExistingBuild = NO_BUILD;
; 1150 : 			BuildTypes eBuild2 = NO_BUILD;
; 1151 : #ifdef AUI_WARNING_FIXES
; 1152 : 			for (uint iBuildIndex2 = 0; iBuildIndex2 < GC.getNumBuildInfos(); iBuildIndex2++)
; 1153 : #else
; 1154 : 			for(int iBuildIndex2 = 0; iBuildIndex2 < GC.getNumBuildInfos(); iBuildIndex2++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iBuildIndex2$218555[esp+124], eax
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	SHORT $LN6@AddImprovi
	npad	8
$LL10@AddImprovi:

; 1155 : #endif
; 1156 : 			{
; 1157 : 				eBuild2 = (BuildTypes)iBuildIndex2;
; 1158 : 				CvBuildInfo* pkBuild2 = GC.getBuildInfo(eBuild2);

	mov	edx, DWORD PTR _iBuildIndex2$218555[esp+124]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 1159 : 				if(pkBuild2 && pkBuild2->getImprovement() == eExistingPlotImprovement)

	test	eax, eax
	je	SHORT $LN9@AddImprovi
	mov	ecx, eax
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	cmp	eax, DWORD PTR _eExistingPlotImprovement$[esp+128]
	je	SHORT $LN98@AddImprovi
$LN9@AddImprovi:

; 1148 : 		{
; 1149 : 			BuildTypes eExistingBuild = NO_BUILD;
; 1150 : 			BuildTypes eBuild2 = NO_BUILD;
; 1151 : #ifdef AUI_WARNING_FIXES
; 1152 : 			for (uint iBuildIndex2 = 0; iBuildIndex2 < GC.getNumBuildInfos(); iBuildIndex2++)
; 1153 : #else
; 1154 : 			for(int iBuildIndex2 = 0; iBuildIndex2 < GC.getNumBuildInfos(); iBuildIndex2++)

	inc	DWORD PTR _iBuildIndex2$218555[esp+124]
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _iBuildIndex2$218555[esp+124], eax
	jl	SHORT $LL10@AddImprovi

; 1127 : 				continue;
; 1128 : 		}
; 1129 : 
; 1130 : 		if(!pUnit->canBuild(pPlot, eBuild))

	jmp	SHORT $LN6@AddImprovi
$LN98@AddImprovi:

; 1160 : 				{
; 1161 : 					eExistingBuild = eBuild2;
; 1162 : 					break;
; 1163 : 				}
; 1164 : 			}
; 1165 : 
; 1166 : 			if(eExistingBuild != NO_BUILD)

	mov	ecx, DWORD PTR _iBuildIndex2$218555[esp+124]
	cmp	ecx, -1
	je	SHORT $LN6@AddImprovi

; 1167 : 			{
; 1168 : 				iInvestedImprovementTime = pPlot->getBuildTime(eExistingBuild, m_pPlayer->GetID());

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	push	ecx
	mov	ecx, ebp
	call	?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ; CvPlot::getBuildTime
	mov	DWORD PTR _iInvestedImprovementTime$218551[esp+128], eax
$LN6@AddImprovi:

; 1169 : 			}
; 1170 : 		}
; 1171 : 
; 1172 : 		int iBuildTimeWeight = GetBuildTimeWeight(pUnit, pPlot, eBuild, DoesBuildHelpRush(pUnit, pPlot, eBuild), iInvestedImprovementTime + iMoveTurnsAway);

	mov	ecx, DWORD PTR _iMoveTurnsAway$[esp+124]
	mov	edx, DWORD PTR _iInvestedImprovementTime$218551[esp+128]
	mov	eax, DWORD PTR _pUnit$[esp+124]
	add	edx, ecx
	push	edx
	push	ebx
	push	ebp
	push	eax
	mov	ecx, esi
	call	?DoesBuildHelpRush@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::DoesBuildHelpRush
	mov	edx, DWORD PTR _pUnit$[esp+128]
	movzx	ecx, al
	push	ecx
	push	ebx
	push	ebp
	push	edx
	mov	ecx, esi
	call	?GetBuildTimeWeight@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@_NH@Z ; CvBuilderTaskingAI::GetBuildTimeWeight

; 1173 : 		iWeight += iBuildTimeWeight;

	add	edi, eax

; 1174 : 		iWeight = CorrectWeight(iWeight);

	cmp	edi, -1000				; fffffc18H
	mov	DWORD PTR _iBuildTimeWeight$218563[esp+128], eax
	jge	SHORT $LN53@AddImprovi
	mov	edi, 2147483647				; 7fffffffH
$LN53@AddImprovi:

; 1175 : 
; 1176 : 		iWeight += GetResourceWeight(eResource, eImprovement, pPlot->getNumResource());

	mov	ecx, ebp
	call	?getNumResource@CvPlot@@QBEHXZ		; CvPlot::getNumResource
	mov	ecx, DWORD PTR _eResource$[esp+128]
	push	eax
	mov	eax, DWORD PTR _eImprovement$218536[esp+132]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?GetResourceWeight@CvBuilderTaskingAI@@QAEHW4ResourceTypes@@W4ImprovementTypes@@H@Z ; CvBuilderTaskingAI::GetResourceWeight
	add	edi, eax

; 1177 : 		iWeight = CorrectWeight(iWeight);

	cmp	edi, -1000				; fffffc18H
	jge	SHORT $LN57@AddImprovi
	mov	edi, 2147483647				; 7fffffffH
$LN57@AddImprovi:

; 1178 : 
; 1179 : 		UpdateProjectedPlotYields(pPlot, eBuild);

	push	ebx
	push	ebp
	mov	ecx, esi
	call	?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::UpdateProjectedPlotYields

; 1180 : #ifdef AUI_WORKER_SCORE_PLOT_CHOP
; 1181 : 		int iScore = ScorePlot(eBuild);
; 1182 : #else
; 1183 : 		int iScore = ScorePlot();

	mov	ecx, esi
	call	?ScorePlot@CvBuilderTaskingAI@@QAEHXZ	; CvBuilderTaskingAI::ScorePlot

; 1184 : #endif
; 1185 : 		if(iScore > 0)

	test	eax, eax
	jle	SHORT $LN61@AddImprovi

; 1186 : 		{
; 1187 : 			iWeight *= iScore;

	imul	eax, edi
	mov	edi, eax

; 1188 : 			iWeight = CorrectWeight(iWeight);

	cmp	edi, -1000				; fffffc18H
	jge	SHORT $LN61@AddImprovi
	mov	edi, 2147483647				; 7fffffffH
$LN61@AddImprovi:

; 1189 : 		}
; 1190 : 
; 1191 : 		{
; 1192 : 			CvCity* pLogCity = NULL;
; 1193 : 			int iProduction = pPlot->getFeatureProduction(eBuild, pUnit->getOwner(), &pLogCity);

	mov	edx, DWORD PTR _pUnit$[esp+124]
	mov	eax, DWORD PTR [edx+40]
	lea	ecx, DWORD PTR _pLogCity$218566[esp+128]
	push	ecx
	push	eax
	push	ebx
	mov	ecx, ebp
	mov	DWORD PTR _pLogCity$218566[esp+140], 0
	call	?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ; CvPlot::getFeatureProduction

; 1194 : 			if(DoesBuildHelpRush(pUnit, pPlot, eBuild))

	mov	edx, DWORD PTR _pUnit$[esp+124]
	push	ebx
	push	ebp
	push	edx
	mov	ecx, esi
	mov	DWORD PTR _iProduction$218567[esp+136], eax
	call	?DoesBuildHelpRush@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::DoesBuildHelpRush
	test	al, al
	je	SHORT $LN3@AddImprovi

; 1195 : 			{
; 1196 : 				iWeight += iProduction; // a nominal benefit for choosing this production

	add	edi, DWORD PTR _iProduction$218567[esp+124]

; 1197 : 
; 1198 : 				if(m_bLogging)

	cmp	BYTE PTR [esi+58392], 0
	je	SHORT $LN3@AddImprovi

; 1199 : 				{
; 1200 : 					CvString strLog;

	lea	ecx, DWORD PTR _strLog$218570[esp+128]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1201 : 					strLog.Format("Helps rush, %d", iProduction);

	mov	eax, DWORD PTR _iProduction$218567[esp+124]
	push	eax
	lea	ecx, DWORD PTR _strLog$218570[esp+132]
	push	OFFSET $SG218571
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+148], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1202 : 					LogInfo(strLog, m_pPlayer);

	mov	edx, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	push	0
	push	edx
	sub	esp, 28					; 0000001cH
	lea	eax, DWORD PTR _strLog$218570[esp+164]
	mov	DWORD PTR $T225867[esp+160], esp
	mov	ecx, esp
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 1203 : 				}

	lea	ecx, DWORD PTR _strLog$218570[esp+128]
	mov	DWORD PTR __$EHRec$[esp+136], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@AddImprovi:

; 1204 : 			}
; 1205 : 		}
; 1206 : 
; 1207 : 		if(iWeight <= 0)

	test	edi, edi
	jle	$LN24@AddImprovi

; 1208 : 		{
; 1209 : 			continue;
; 1210 : 		}
; 1211 : 
; 1212 : 		BuilderDirective directive;
; 1213 : 		directive.m_eDirective = eDirectiveType;
; 1214 : 		directive.m_eBuild = eBuild;
; 1215 : 		directive.m_eResource = eResource;
; 1216 : 		directive.m_sX = pPlot->getX();
; 1217 : 		directive.m_sY = pPlot->getY();
; 1218 : 		//directive.m_iGoldCost = m_pPlayer->getBuildCost(pPlot, eBuild);
; 1219 : 		directive.m_sMoveTurnsAway = iMoveTurnsAway;
; 1220 : 
; 1221 : 		if(m_bLogging)

	cmp	BYTE PTR [esi+58392], 0
	mov	ecx, DWORD PTR _eDirectiveType$218548[esp+128]
	mov	edx, DWORD PTR _eResource$[esp+128]
	mov	ax, WORD PTR [ebp]
	mov	DWORD PTR _directive$218574[esp+128], ecx
	mov	cx, WORD PTR [ebp+2]
	mov	DWORD PTR _directive$218574[esp+136], edx
	mov	dx, WORD PTR _iMoveTurnsAway$[esp+124]
	mov	DWORD PTR _directive$218574[esp+132], ebx
	mov	WORD PTR _directive$218574[esp+140], ax
	mov	WORD PTR _directive$218574[esp+142], cx
	mov	WORD PTR _directive$218574[esp+144], dx
	je	SHORT $LN1@AddImprovi

; 1222 : 		{
; 1223 : 			CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$218576[esp+128]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1224 : 			strTemp.Format("%d, Build Time Weight, %d, Weight, %d", pUnit->GetID(), iBuildTimeWeight, iWeight);

	mov	ecx, DWORD PTR _iBuildTimeWeight$218563[esp+128]
	mov	eax, DWORD PTR _pUnit$[esp+124]
	mov	eax, DWORD PTR [eax+100]
	push	edi
	push	ecx
	push	eax
	lea	edx, DWORD PTR _strTemp$218576[esp+140]
	push	OFFSET $SG218577
	push	edx
	mov	DWORD PTR __$EHRec$[esp+156], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1225 : 			LogInfo(strTemp, m_pPlayer);

	mov	eax, DWORD PTR [esi]
	add	esp, 20					; 00000014H
	push	0
	push	eax
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strTemp$218576[esp+164]
	mov	DWORD PTR $T225868[esp+160], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 1226 : 		}

	lea	ecx, DWORD PTR _strTemp$218576[esp+128]
	mov	DWORD PTR __$EHRec$[esp+136], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@AddImprovi:

; 1227 : 
; 1228 : 		m_aDirectives.push_back(directive, iWeight);

	push	edi
	lea	eax, DWORD PTR _directive$218574[esp+132]
	push	eax
	mov	ecx, OFFSET ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A ; CvBuilderTaskingAI::m_aDirectives
	call	?push_back@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEIABUBuilderDirective@@H@Z ; CvWeightedVector<BuilderDirective,100,1>::push_back
$LN24@AddImprovi:
	mov	ebx, DWORD PTR _iBuildIndex$[esp+128]
	inc	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iBuildIndex$[esp+128], ebx
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	ebx, eax
	jl	$LN25@AddImprovi
$LN17@AddImprovi:

; 1229 : 	}
; 1230 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+128]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 112				; 00000070H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$0:
	lea	ecx, DWORD PTR _strLog$218570[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$2:
	lea	ecx, DWORD PTR _strTemp$218576[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ENDP ; CvBuilderTaskingAI::AddImprovingResourcesDirectives
PUBLIC	?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddImprovingPlotsDirectives
EXTRN	?ComputeCultureFromAdjacentImprovement@CvPlot@@QBEHAAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvPlot::ComputeCultureFromAdjacentImprovement
EXTRN	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetCultureAdjacentSameType
EXTRN	?isOption@CvPlayer@@QBE_NW4PlayerOptionTypes@@@Z:PROC ; CvPlayer::isOption
EXTRN	?GetAdjacentCity@CvPlot@@QBEPAVCvCity@@_N@Z:PROC ; CvPlot::GetAdjacentCity
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?isWithinTeamCityRadius@CvPlot@@QBE_NW4TeamTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::isWithinTeamCityRadius
EXTRN	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ:PROC	; CvUnit::getTeam
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$16
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
_TEXT	SEGMENT
_bWillRemoveForestOrJungle$218636 = -129		; size = 1
_iBuildIndex$ = -128					; size = 4
_iScore$218661 = -124					; size = 4
_pkBuild$218604 = -124					; size = 4
_eImprovement$218606 = -120				; size = 4
_pImprovement$218609 = -116				; size = 4
_eResource$ = -112					; size = 4
$T226244 = -108						; size = 4
$T226219 = -108						; size = 4
$T226185 = -108						; size = 4
_eDirectiveType$218667 = -108				; size = 4
$T226008 = -108						; size = 4
_eExistingImprovement$ = -104				; size = 4
$T226330 = -100						; size = 4
$T226307 = -100						; size = 4
$T226282 = -100						; size = 4
$T226011 = -100						; size = 4
$T226009 = -100						; size = 4
_eFeature$218637 = -100					; size = 4
$T226004 = -100						; size = 4
$T226003 = -100						; size = 4
_directive$218676 = -96					; size = 20
_strTemp$218644 = -96					; size = 28
_strTemp$218633 = -96					; size = 28
_strTemp$218628 = -96					; size = 28
_strTemp$218620 = -96					; size = 28
_strTemp$218613 = -96					; size = 28
_strTemp$218664 = -68					; size = 28
_strTemp$218658 = -68					; size = 28
_strTemp$218650 = -68					; size = 28
_strTemp$218678 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
_pPlot$ = 12						; size = 4
_iMoveTurnsAway$ = 16					; size = 4
?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z PROC ; CvBuilderTaskingAI::AddImprovingPlotsDirectives, COMDAT
; _this$ = ecx

; 1234 : {

	push	-1
	push	__ehhandler$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 120				; 00000078H
	push	ebx
	push	ebp
	push	esi

; 1235 : 	ImprovementTypes eExistingImprovement = pPlot->getImprovementType();

	mov	esi, DWORD PTR _pPlot$[esp+140]
	push	edi
	mov	edi, ecx
	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	mov	ebx, eax
	mov	DWORD PTR _eExistingImprovement$[esp+148], ebx

; 1236 : 
; 1237 : 	// Do we have a special improvement here? (great person improvement, gifted improvement from major civ)
; 1238 : 	if(eExistingImprovement != NO_IMPROVEMENT && pPlot->HasSpecialImprovement() && !pPlot->IsImprovementPillaged())

	cmp	ebx, -1
	je	SHORT $LN49@AddImprovi@2
	mov	ecx, esi
	call	?HasSpecialImprovement@CvPlot@@QBE_NXZ	; CvPlot::HasSpecialImprovement
	test	al, al
	je	SHORT $LN49@AddImprovi@2
	mov	ecx, esi
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	test	al, al
	je	$LN39@AddImprovi@2
$LN49@AddImprovi@2:

; 1239 : 	{
; 1240 : 		return;
; 1241 : 	}
; 1242 : 
; 1243 : 	// if it's not within a city radius
; 1244 : 	if(!pPlot->isWithinTeamCityRadius(pUnit->getTeam()))

	mov	ecx, DWORD PTR _pUnit$[esp+144]
	push	-1
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, esi
	call	?isWithinTeamCityRadius@CvPlot@@QBE_NW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlot::isWithinTeamCityRadius
	test	al, al
	je	$LN39@AddImprovi@2

; 1245 : 	{
; 1246 : 		return;
; 1247 : 	}
; 1248 : 
; 1249 : 	// check to see if a non-bonus resource is here. if so, bail out!
; 1250 : 	ResourceTypes eResource = pPlot->getResourceType(m_pPlayer->getTeam());

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN74@AddImprovi@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN75@AddImprovi@2
$LN74@AddImprovi@2:
	or	eax, -1
$LN75@AddImprovi@2:
	push	eax
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[esp+148], eax

; 1251 : 	if(eResource != NO_RESOURCE)

	cmp	eax, -1
	je	SHORT $LN46@AddImprovi@2

; 1252 : 	{
; 1253 : 		if(GC.getResourceInfo(eResource)->getResourceUsage() != RESOURCEUSAGE_BONUS)

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	test	eax, eax
	jne	$LN39@AddImprovi@2
$LN46@AddImprovi@2:

; 1254 : 		{
; 1255 : 			return;
; 1256 : 		}
; 1257 : 	}
; 1258 : #ifdef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 1259 : 	FeatureTypes eFeature = pPlot->getFeatureType();
; 1260 : #endif
; 1261 : 
; 1262 : 	// celtic rule: if this is a forest tile next to a city, do not improve this tile with a normal improvement
; 1263 : 	if (m_pPlayer->GetPlayerTraits()->IsFaithFromUnimprovedForest() && eExistingImprovement == NO_IMPROVEMENT)

	mov	ecx, DWORD PTR [edi]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	al, BYTE PTR [eax+341]
	test	al, al
	je	SHORT $LN43@AddImprovi@2
	cmp	ebx, -1
	jne	SHORT $LN43@AddImprovi@2

; 1264 : 	{
; 1265 : 		CvCity* pNextCity = pPlot->GetAdjacentCity();

	push	0
	mov	ecx, esi
	call	?GetAdjacentCity@CvPlot@@QBEPAVCvCity@@_N@Z ; CvPlot::GetAdjacentCity

; 1266 : 		if (pNextCity && pNextCity->getOwner() == m_pPlayer->GetID())

	test	eax, eax
	je	SHORT $LN43@AddImprovi@2
	mov	eax, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR [edi]
	cmp	eax, DWORD PTR [ecx+44]
	jne	SHORT $LN43@AddImprovi@2

; 1267 : 		{
; 1268 : #ifdef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 1269 : 			if (eFeature == FEATURE_FOREST)
; 1270 : #else
; 1271 : 			if (pPlot->getFeatureType() == FEATURE_FOREST)

	cmp	BYTE PTR [esi+432], 5
	je	$LN39@AddImprovi@2
$LN43@AddImprovi@2:

; 1272 : #endif
; 1273 : 			{
; 1274 : 				return;
; 1275 : 			}
; 1276 : 		}
; 1277 : 	}
; 1278 : 
; 1279 : #ifdef AUI_WORKER_FIX_SHOULD_BUILDER_CONSIDER_PLOT_EXISTING_BUILD_MISSIONS_SHIFT
; 1280 : 	// check to see if someone already has a conflicting mission here
; 1281 : 	if (pUnit->GetMissionAIPlot() != pPlot)
; 1282 : 	{
; 1283 : 		int iLoop;
; 1284 : 		for (CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))
; 1285 : 		{
; 1286 : 			if (pUnit == pLoopUnit)
; 1287 : 			{
; 1288 : 				continue;
; 1289 : 			}
; 1290 : 
; 1291 : 			CvPlot* pMissionPlot = pLoopUnit->GetMissionAIPlot();
; 1292 : 			if (!pMissionPlot)
; 1293 : 			{
; 1294 : 				continue;
; 1295 : 			}
; 1296 : 
; 1297 : 			MissionAITypes eGroupMissionAI = pLoopUnit->GetMissionAIType();
; 1298 : 			if (eGroupMissionAI != MISSIONAI_BUILD)
; 1299 : 			{
; 1300 : 				continue;
; 1301 : 			}
; 1302 : 
; 1303 : 			if (pPlot->getX() == pMissionPlot->getX() && pPlot->getY() == pMissionPlot->getY())
; 1304 : 			{
; 1305 : 				BuildTypes eOtherBuild = pLoopUnit->getBuildType();
; 1306 : 				CvBuildInfo* pkBuild = GC.getBuildInfo(eOtherBuild);
; 1307 : 				if (pkBuild != NULL)
; 1308 : 				{
; 1309 : 					ImprovementTypes eImprovement = (ImprovementTypes)pkBuild->getImprovement();
; 1310 : 					if (eImprovement != NO_IMPROVEMENT || (eOtherBuild == m_eRepairBuild && eExistingImprovement != NO_IMPROVEMENT))
; 1311 : 					{
; 1312 : 						if (m_bLogging)
; 1313 : 						{
; 1314 : 							CvString strLog;
; 1315 : 							strLog.Format("x: %d y: %d, Somebody has a conflicting mission here.", pPlot->getX(), pPlot->getY());
; 1316 : 							LogInfo(strLog, m_pPlayer, true);
; 1317 : 						}
; 1318 : 						return;
; 1319 : 					}
; 1320 : 				}
; 1321 : 			}
; 1322 : 		}
; 1323 : 	}
; 1324 : #endif
; 1325 : 
; 1326 : 	CvCity* pCity = GetWorkingCity(pPlot);

	push	esi
	mov	ecx, edi
	call	?GetWorkingCity@CvBuilderTaskingAI@@QAEPAVCvCity@@PAVCvPlot@@@Z ; CvBuilderTaskingAI::GetWorkingCity

; 1327 : #ifndef AUI_WORKER_ADD_IMPROVING_PLOTS_DIRECTIVE_DEFENSIVES
; 1328 : 	if(!pCity)

	test	eax, eax
	je	$LN39@AddImprovi@2

; 1329 : 	{
; 1330 : 		return;
; 1331 : 	}
; 1332 : #endif
; 1333 : 
; 1334 : 	// loop through the build types to find one that we can use
; 1335 : 	BuildTypes eBuild;
; 1336 : 	BuildTypes eOriginalBuildType;
; 1337 : #ifdef AUI_WARNING_FIXES
; 1338 : 	uint iBuildIndex;
; 1339 : #else
; 1340 : 	int iBuildIndex;
; 1341 : #endif
; 1342 : #ifdef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 1343 : 	int iLoopScore;
; 1344 : 	int iBestUniqueImprovementWeight = 0;
; 1345 : 	for (uint iI = 0; iI < m_pPlayer->GetNumUniqueImprovements(); iI++)
; 1346 : 	{
; 1347 : 		ImprovementTypes eUniqueImprovement = m_pPlayer->GetUniqueImprovement(iI);
; 1348 : 		if (eUniqueImprovement != NO_IMPROVEMENT)
; 1349 : 		{
; 1350 : 			CvImprovementEntry* pUniqueImprovement = GC.getImprovementInfo(eUniqueImprovement);
; 1351 : 			if (pUniqueImprovement && pUniqueImprovement->IsRequiresFeature() && pUniqueImprovement->GetFeatureMakesValid(eFeature))
; 1352 : 			{
; 1353 : 				eBuild = m_pPlayer->GetUniqueImprovementBuild(iI);
; 1354 : #ifdef AUI_WORKER_ADD_IMPROVING_PLOTS_DIRECTIVE_DEFENSIVES
; 1355 : 				iLoopScore = 0;
; 1356 : 				if (pCity)
; 1357 : 				{
; 1358 : 					UpdateProjectedPlotYields(pPlot, eBuild);
; 1359 : #ifdef AUI_WORKER_SCORE_PLOT_CHOP
; 1360 : 					iLoopScore = ScorePlot(eBuild);
; 1361 : #else
; 1362 : 					iLoopScore = ScorePlot();
; 1363 : #endif
; 1364 : 				}
; 1365 : 				if (!pCity || iLoopScore > 0)
; 1366 : 				{
; 1367 : 					int iBaseDefenseBonus = (pPlot->isHills() || pPlot->isMountain() ? GC.getHILLS_EXTRA_DEFENSE() : GC.getFeatureInfo(eFeature)->getDefenseModifier());
; 1368 : 					iLoopScore += (pUniqueImprovement->GetDefenseModifier() + iBaseDefenseBonus) * pPlot->getStrategicValue() / (100 * GC.getCHOKEPOINT_STRATEGIC_VALUE());
; 1369 : 				}
; 1370 : #else
; 1371 : 				UpdateProjectedPlotYields(pPlot, eBuild);
; 1372 : #ifdef AUI_WORKER_SCORE_PLOT_CHOP
; 1373 : 				iLoopScore = ScorePlot(eBuild);
; 1374 : #else
; 1375 : 				iLoopScore = ScorePlot();
; 1376 : #endif
; 1377 : #endif
; 1378 : 				int iWeight = GC.getBUILDER_TASKING_BASELINE_BUILD_IMPROVEMENTS();
; 1379 : 				iWeight = GetBuildCostWeight(iWeight, pPlot, eBuild);
; 1380 : 				iWeight += GetBuildTimeWeight(pUnit, pPlot, eBuild, DoesBuildHelpRush(pUnit, pPlot, eBuild), iMoveTurnsAway);
; 1381 : 				iWeight *= iLoopScore;
; 1382 : 				iWeight = CorrectWeight(iWeight);
; 1383 : 
; 1384 : 				if (iWeight > iBestUniqueImprovementWeight)
; 1385 : 					iBestUniqueImprovementWeight = iWeight;
; 1386 : 			}
; 1387 : 		}
; 1388 : 	}
; 1389 : #endif
; 1390 : 	for(iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	xor	ebp, ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iBuildIndex$[esp+148], ebp
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	$LN39@AddImprovi@2
$LN41@AddImprovi@2:

; 1391 : 	{
; 1392 : 		eBuild = (BuildTypes)iBuildIndex;
; 1393 : 		eOriginalBuildType = eBuild;
; 1394 : 		CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuild$218604[esp+148], eax

; 1395 : 		if(pkBuild == NULL)

	test	eax, eax
	je	$LN40@AddImprovi@2

; 1396 : 		{
; 1397 : 			continue;
; 1398 : 		}
; 1399 : 
; 1400 : 		ImprovementTypes eImprovement = (ImprovementTypes)pkBuild->getImprovement();

	mov	ecx, eax
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	ebx, eax
	mov	DWORD PTR _eImprovement$218606[esp+148], ebx

; 1401 : 		if(eImprovement == NO_IMPROVEMENT)

	cmp	ebx, -1
	je	$LN40@AddImprovi@2

; 1402 : 		{
; 1403 : 			continue;
; 1404 : 		}
; 1405 : 
; 1406 : 		CvImprovementEntry* pImprovement = GC.getImprovementInfo(eImprovement);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo

; 1407 : 
; 1408 : #ifdef AUI_WORKER_ADD_IMPROVING_PLOTS_DIRECTIVE_DEFENSIVES
; 1409 : 		// If the improvement has no defensive effect, skip it
; 1410 : 		if (pImprovement->GetDefenseModifier() == 0 && !pCity)
; 1411 : 		{
; 1412 : 			continue;
; 1413 : 		}
; 1414 : #else
; 1415 : 		// if this improvement has a defense modifier, ignore it for now
; 1416 : 		//if(pImprovement->GetDefenseModifier() > 0)
; 1417 : 		//{
; 1418 : 		//	continue;
; 1419 : 		//}
; 1420 : #endif
; 1421 : 
; 1422 : #ifndef AUI_WORKER_FIX_IMPROVING_PLOTS_DIRECTIVE_DONT_REQUIRE_BONUS_RESOURCE_UNLOCKER
; 1423 : 		// for bonus resources, check to see if this is the improvement that connects it
; 1424 : 		if(eResource != NO_RESOURCE)

	mov	ecx, DWORD PTR _eResource$[esp+148]
	mov	DWORD PTR _pImprovement$218609[esp+148], eax
	cmp	ecx, -1
	je	$LN35@AddImprovi@2

; 1425 : 		{
; 1426 : 			if(!pImprovement->IsImprovementResourceTrade(eResource))

	push	ecx
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	test	al, al
	jne	$LN35@AddImprovi@2

; 1427 : 			{
; 1428 : 				if(m_bLogging){

	cmp	BYTE PTR [edi+58392], al
	je	$LN40@AddImprovi@2

; 1429 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$218613[esp+148]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1430 : 					strTemp.Format("Weight,!pImprovement->IsImprovementResourceTrade(eResource),%s,%i,,,%i, %i", GC.getBuildInfo(eBuild)->GetType(), eResource, pPlot->getX(), pPlot->getY());

	mov	edx, DWORD PTR _iBuildIndex$[esp+148]
	movsx	ebx, WORD PTR [esi+2]
	movsx	ebp, WORD PTR [esi]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+160], 0
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, DWORD PTR _eResource$[esp+148]
	push	ebx
	push	ebp
	push	ecx
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strTemp$218613[esp+164]
	push	OFFSET $SG218614
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H
$LN264@AddImprovi@2:

; 1431 : 					LogInfo(strTemp, m_pPlayer);

	mov	eax, DWORD PTR [edi]
	push	0
	push	eax
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strTemp$218613[esp+184]
	mov	DWORD PTR $T226003[esp+184], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo

; 1432 : 				}

	lea	ecx, DWORD PTR _strTemp$218613[esp+184]
$LN267@AddImprovi@2:
	add	esp, 36					; 00000024H
	mov	DWORD PTR __$EHRec$[esp+156], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1433 : 				continue;

	jmp	$LN40@AddImprovi@2
$LN35@AddImprovi@2:

; 1434 : 			}
; 1435 : 		}
; 1436 : #endif
; 1437 : 
; 1438 : 		if(eImprovement == pPlot->getImprovementType())

	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	ebx, eax
	jne	$LN33@AddImprovi@2

; 1439 : 		{
; 1440 : 			if(pPlot->IsImprovementPillaged())

	mov	ecx, esi
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	test	al, al
	je	SHORT $LN32@AddImprovi@2

; 1441 : 			{
; 1442 : 				eBuild = m_eRepairBuild;

	mov	ebp, DWORD PTR [edi+4]
$LN27@AddImprovi@2:

; 1467 : 				}
; 1468 : 			}
; 1469 : 		}
; 1470 : 
; 1471 : 		// Only check to make sure our unit can build this after possibly switching this to a repair build in the block of code above
; 1472 : 		if(!pUnit->canBuild(pPlot, eBuild))

	mov	ecx, DWORD PTR _pUnit$[esp+144]
	push	1
	push	0
	push	ebp
	push	esi
	call	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z ; CvUnit::canBuild
	test	al, al
	jne	$LN24@AddImprovi@2

; 1473 : 		{
; 1474 : 			if(m_bLogging){

	cmp	BYTE PTR [edi+58392], al
	je	$LN40@AddImprovi@2

; 1475 : 				CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$218633[esp+148]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1476 : 				strTemp.Format("Weight,!pUnit->canBuild(),%s,,,,%i, %i", GC.getBuildInfo(eBuild)->GetType(), pPlot->getX(), pPlot->getY());

	movsx	eax, WORD PTR [esi]
	movsx	ebx, WORD PTR [esi+2]
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+160], 3
	mov	DWORD PTR $T226185[esp+152], eax
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, DWORD PTR $T226185[esp+148]
	push	ebx
	push	ecx
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strTemp$218633[esp+160]
	push	OFFSET $SG218634
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 1477 : 				LogInfo(strTemp, m_pPlayer);
; 1478 : 			}
; 1479 : 			continue;

	jmp	$LN264@AddImprovi@2
$LN32@AddImprovi@2:

; 1443 : 			}
; 1444 : 			else
; 1445 : 			{
; 1446 : 				if(m_bLogging){

	cmp	BYTE PTR [edi+58392], 0
	je	$LN40@AddImprovi@2

; 1447 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$218620[esp+148]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1448 : 					strTemp.Format("Weight,eImprovement == pPlot->getImprovementType(),%s,%i,,,%i, %i", GC.getBuildInfo(eBuild)->GetType(), eImprovement, pPlot->getX(), pPlot->getY());

	mov	eax, DWORD PTR _iBuildIndex$[esp+148]
	movsx	ebp, WORD PTR [esi+2]
	movsx	ebx, WORD PTR [esi]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+160], 1
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, DWORD PTR _eImprovement$218606[esp+148]
	push	ebp
	push	ebx
	push	ecx
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strTemp$218620[esp+164]
	push	OFFSET $SG218621
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1449 : 					LogInfo(strTemp, m_pPlayer);

	mov	eax, DWORD PTR [edi]
	add	esp, 24					; 00000018H
	push	0
	push	eax
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strTemp$218620[esp+184]
	mov	DWORD PTR $T226004[esp+184], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 1450 : 				}

	lea	ecx, DWORD PTR _strTemp$218620[esp+148]
	mov	DWORD PTR __$EHRec$[esp+156], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1451 : 				continue;

	jmp	$LN40@AddImprovi@2
$LN33@AddImprovi@2:

; 1452 : 			}
; 1453 : 		}
; 1454 : 		else
; 1455 : 		{
; 1456 : 			// Do we have a special improvement here? (great person improvement, gifted improvement from major civ)
; 1457 : 			if (eExistingImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eExistingImprovement$[esp+148], -1
	je	$LN27@AddImprovi@2

; 1458 : 			{
; 1459 : 				if (pPlot->HasSpecialImprovement() || GET_PLAYER(pUnit->getOwner()).isOption(PLAYEROPTION_SAFE_AUTOMATION))

	mov	ecx, esi
	call	?HasSpecialImprovement@CvPlot@@QBE_NXZ	; CvPlot::HasSpecialImprovement
	test	al, al
	jne	SHORT $LN26@AddImprovi@2
	mov	eax, DWORD PTR _pUnit$[esp+144]
	mov	eax, DWORD PTR [eax+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	5
	mov	ecx, eax
	call	?isOption@CvPlayer@@QBE_NW4PlayerOptionTypes@@@Z ; CvPlayer::isOption
	test	al, al
	je	$LN27@AddImprovi@2
$LN26@AddImprovi@2:

; 1460 : 				{
; 1461 : 					if(m_bLogging){

	cmp	BYTE PTR [edi+58392], 0
	je	$LN40@AddImprovi@2

; 1462 : 						CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$218628[esp+148]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1463 : 						strTemp.Format("Weight,Improvement Type Blocked by Special Improvement,%s,,,,%i, %i", GC.getBuildInfo(eBuild)->GetType(), pPlot->getX(), pPlot->getY());

	mov	ecx, DWORD PTR _iBuildIndex$[esp+148]
	movsx	ebx, WORD PTR [esi+2]
	movsx	ebp, WORD PTR [esi]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+160], 2
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	push	ebx
	push	ebp
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strTemp$218628[esp+160]
	push	OFFSET $SG218629
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 1464 : 						LogInfo(strTemp, m_pPlayer);
; 1465 : 					}
; 1466 : 					continue;

	jmp	$LN264@AddImprovi@2
$LN24@AddImprovi@2:

; 1480 : 		}
; 1481 : 
; 1482 : 		bool bWillRemoveForestOrJungle = false;
; 1483 : #ifndef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 1484 : 		FeatureTypes eFeature = pPlot->getFeatureType();

	movsx	ebx, BYTE PTR [esi+432]
	mov	BYTE PTR _bWillRemoveForestOrJungle$218636[esp+148], 0
	mov	DWORD PTR _eFeature$218637[esp+148], ebx

; 1485 : #endif
; 1486 : 		if(eFeature == FEATURE_FOREST || eFeature == FEATURE_JUNGLE)

	cmp	ebx, 5
	je	SHORT $LN21@AddImprovi@2
	cmp	ebx, 1
	jne	SHORT $LN20@AddImprovi@2
$LN21@AddImprovi@2:

; 1487 : 		{
; 1488 : 			if(pkBuild->isFeatureRemove(eFeature))

	mov	ecx, DWORD PTR _pkBuild$218604[esp+148]
	push	ebx
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	test	al, al
	je	SHORT $LN20@AddImprovi@2

; 1489 : 			{
; 1490 : 				bWillRemoveForestOrJungle = true;

	mov	BYTE PTR _bWillRemoveForestOrJungle$218636[esp+148], 1
$LN20@AddImprovi@2:

; 1491 : 			}
; 1492 : 		}
; 1493 : 
; 1494 : #ifndef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 1495 : 		// special case for Dutch
; 1496 : 		if (m_bKeepMarshes && eFeature == FEATURE_MARSH)

	cmp	BYTE PTR [edi+58460], 0
	je	SHORT $LN18@AddImprovi@2
	cmp	ebx, 2
	jne	SHORT $LN18@AddImprovi@2

; 1497 : 		{
; 1498 : 			if (pkBuild->isFeatureRemove(FEATURE_MARSH))

	mov	ecx, DWORD PTR _pkBuild$218604[esp+148]
	push	ebx
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	test	al, al
	je	SHORT $LN18@AddImprovi@2

; 1499 : 			{
; 1500 : 				if(m_bLogging){

	cmp	BYTE PTR [edi+58392], 0
	je	$LN40@AddImprovi@2

; 1501 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$218644[esp+148]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1502 : 					strTemp.Format("Weight,Marsh Remove,%s,,,,%i, %i", GC.getBuildInfo(eBuild)->GetType(), pPlot->getX(), pPlot->getY());

	movsx	eax, WORD PTR [esi]
	movsx	ebx, WORD PTR [esi+2]
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+160], 4
	mov	DWORD PTR $T226219[esp+152], eax
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, DWORD PTR $T226219[esp+148]
	push	ebx
	push	ecx
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strTemp$218644[esp+160]
	push	OFFSET $SG218645
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 1503 : 					LogInfo(strTemp, m_pPlayer);
; 1504 : 				}
; 1505 : 				continue;

	jmp	$LN264@AddImprovi@2
$LN18@AddImprovi@2:

; 1506 : 			}
; 1507 : 		}
; 1508 : 
; 1509 : 		// special case for Brazil
; 1510 : 		if (m_bKeepJungle && eFeature == FEATURE_JUNGLE)

	cmp	BYTE PTR [edi+58461], 0
	je	$LN13@AddImprovi@2
	cmp	ebx, 1
	jne	$LN13@AddImprovi@2

; 1511 : 		{
; 1512 : 			if (pkBuild->isFeatureRemove(FEATURE_JUNGLE))

	mov	ecx, DWORD PTR _pkBuild$218604[esp+148]
	push	ebx
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	test	al, al
	je	$LN13@AddImprovi@2

; 1513 : 			{
; 1514 : 				if(m_bLogging){

	cmp	BYTE PTR [edi+58392], 0
	je	$LN14@AddImprovi@2

; 1515 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$218650[esp+148]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1516 : 					strTemp.Format("Weight,Jungle Remove,%s,,,,%i, %i", GC.getBuildInfo(eBuild)->GetType(), pPlot->getX(), pPlot->getY());

	movsx	eax, WORD PTR [esi]
	movsx	ebx, WORD PTR [esi+2]
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+160], 5
	mov	DWORD PTR $T226244[esp+152], eax
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, DWORD PTR $T226244[esp+148]
	push	ebx
	push	ecx
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strTemp$218650[esp+160]
	push	OFFSET $SG218651
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1517 : 					LogInfo(strTemp, m_pPlayer);

	mov	eax, DWORD PTR [edi]
	add	esp, 20					; 00000014H
	push	0
	push	eax
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strTemp$218650[esp+184]
	mov	DWORD PTR $T226008[esp+184], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 1518 : 				}

	lea	ecx, DWORD PTR _strTemp$218650[esp+148]
	mov	DWORD PTR __$EHRec$[esp+156], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ebx, DWORD PTR _eFeature$218637[esp+148]
$LN14@AddImprovi@2:

; 1519 : 				if (pPlot->getResourceType(m_pPlayer->getTeam()) == NO_RESOURCE)

	mov	ecx, DWORD PTR [edi]
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	$LN40@AddImprovi@2
$LN13@AddImprovi@2:

; 1520 : 				{
; 1521 : 					continue;
; 1522 : 				}
; 1523 : 			}
; 1524 : 		}
; 1525 : #endif
; 1526 : 
; 1527 : 		if(GET_PLAYER(pUnit->getOwner()).isOption(PLAYEROPTION_LEAVE_FORESTS))

	mov	eax, DWORD PTR _pUnit$[esp+144]
	mov	eax, DWORD PTR [eax+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	7
	mov	ecx, eax
	call	?isOption@CvPlayer@@QBE_NW4PlayerOptionTypes@@@Z ; CvPlayer::isOption
	test	al, al
	je	$LN10@AddImprovi@2

; 1528 : 		{
; 1529 : 			if(eFeature != NO_FEATURE)

	cmp	ebx, -1
	je	$LN10@AddImprovi@2

; 1530 : 			{
; 1531 : 				if(pkBuild->isFeatureRemove(eFeature))

	mov	ecx, DWORD PTR _pkBuild$218604[esp+148]
	push	ebx
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	test	al, al
	je	$LN10@AddImprovi@2

; 1532 : 				{
; 1533 : 					if(m_bLogging){

	cmp	BYTE PTR [edi+58392], 0
	je	$LN40@AddImprovi@2

; 1534 : 						CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$218658[esp+148]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1535 : 						strTemp.Format("Weight,Keep Forests,%s,,,,%i, %i", GC.getBuildInfo(eBuild)->GetType(), pPlot->getX(), pPlot->getY());

	movsx	ecx, WORD PTR [esi]
	movsx	ebx, WORD PTR [esi+2]
	mov	DWORD PTR $T226282[esp+148], ecx
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+160], 6
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	edx, DWORD PTR $T226282[esp+148]
	push	ebx
	push	edx
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strTemp$218658[esp+160]
	push	OFFSET $SG218659
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
$LN266@AddImprovi@2:

; 1536 : 						LogInfo(strTemp, m_pPlayer);

	mov	ecx, DWORD PTR [edi]
	push	0
	push	ecx
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strTemp$218658[esp+184]
	mov	DWORD PTR $T226009[esp+184], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo

; 1537 : 					}

	lea	ecx, DWORD PTR _strTemp$218658[esp+184]

; 1538 : 					continue;

	jmp	$LN267@AddImprovi@2
$LN10@AddImprovi@2:

; 1539 : 				}
; 1540 : 			}
; 1541 : 		}
; 1542 : 
; 1543 : #ifdef AUI_WORKER_ADD_IMPROVING_PLOTS_DIRECTIVE_DEFENSIVES
; 1544 : 		int iScore = 0;
; 1545 : 		if (pCity)
; 1546 : 		{
; 1547 : 			UpdateProjectedPlotYields(pPlot, eBuild);
; 1548 : #ifdef AUI_WORKER_SCORE_PLOT_CHOP
; 1549 : 			iScore = ScorePlot(eBuild);
; 1550 : #else
; 1551 : 			iScore = ScorePlot();
; 1552 : #endif
; 1553 : 		}
; 1554 : 		if (!pCity || iScore > 0)
; 1555 : 		{
; 1556 : 			int iBaseDefenseBonus = (pPlot->isHills() || pPlot->isMountain() ? GC.getHILLS_EXTRA_DEFENSE() :
; 1557 : 				(eFeature != NO_FEATURE && !pkBuild->isFeatureRemove(eFeature) ? GC.getFeatureInfo(eFeature)->getDefenseModifier() :
; 1558 : 					GC.getTerrainInfo(pPlot->getTerrainType())->getDefenseModifier() + GC.getFLAT_LAND_EXTRA_DEFENSE()));
; 1559 : 			iScore += (pImprovement->GetDefenseModifier() + iBaseDefenseBonus) * pPlot->getStrategicValue() / (100 * GC.getCHOKEPOINT_STRATEGIC_VALUE());
; 1560 : 		}
; 1561 : #else
; 1562 : 		UpdateProjectedPlotYields(pPlot, eBuild);

	push	ebp
	push	esi
	mov	ecx, edi
	call	?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::UpdateProjectedPlotYields

; 1563 : #ifdef AUI_WORKER_SCORE_PLOT_CHOP
; 1564 : 		int iScore = ScorePlot(eBuild);
; 1565 : #else
; 1566 : 		int iScore = ScorePlot();

	mov	ecx, edi
	call	?ScorePlot@CvBuilderTaskingAI@@QAEHXZ	; CvBuilderTaskingAI::ScorePlot
	mov	DWORD PTR _iScore$218661[esp+148], eax

; 1567 : #endif
; 1568 : #endif
; 1569 : 
; 1570 : 		// if we're going backward, bail out!
; 1571 : 		if(iScore <= 0)

	test	eax, eax
	jg	SHORT $LN8@AddImprovi@2

; 1572 : 		{
; 1573 : 			if(m_bLogging){

	cmp	BYTE PTR [edi+58392], 0
	je	$LN40@AddImprovi@2

; 1574 : 				CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$218664[esp+148]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1575 : 				strTemp.Format("Weight,Negative Score,%s,%i,,,%i, %i", GC.getBuildInfo(eBuild)->GetType(), iScore, pPlot->getX(), pPlot->getY());

	movsx	eax, WORD PTR [esi]
	movsx	ebx, WORD PTR [esi+2]
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+160], 7
	mov	DWORD PTR $T226307[esp+152], eax
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, DWORD PTR $T226307[esp+148]
	mov	edx, DWORD PTR _iScore$218661[esp+148]
	push	ebx
	push	ecx
	push	edx
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strTemp$218664[esp+164]
	push	OFFSET $SG218665
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 1576 : 				LogInfo(strTemp, m_pPlayer);
; 1577 : 			}
; 1578 : 			continue;

	jmp	$LN266@AddImprovi@2
$LN8@AddImprovi@2:

; 1579 : 		}
; 1580 : 
; 1581 : 		BuilderDirective::BuilderDirectiveType eDirectiveType = BuilderDirective::BUILD_IMPROVEMENT;
; 1582 : 		int iWeight = GC.getBUILDER_TASKING_BASELINE_BUILD_IMPROVEMENTS();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2140
	mov	DWORD PTR _eDirectiveType$218667[esp+148], 1

; 1583 : 		if(eBuild == m_eRepairBuild)

	cmp	ebp, DWORD PTR [edi+4]
	jne	SHORT $LN6@AddImprovi@2

; 1584 : 		{
; 1585 : 			eDirectiveType = BuilderDirective::REPAIR;
; 1586 : 			iWeight = GC.getBUILDER_TASKING_BASELINE_REPAIR();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2152
	mov	DWORD PTR _eDirectiveType$218667[esp+148], 3
	jmp	SHORT $LN3@AddImprovi@2
$LN6@AddImprovi@2:

; 1587 : 		}
; 1588 : 		else if(pImprovement->GetYieldChange(YIELD_CULTURE) > 0)

	mov	ecx, DWORD PTR _pImprovement$218609[esp+148]
	push	4
	call	?GetYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetYieldChange
	test	eax, eax
	jle	SHORT $LN3@AddImprovi@2

; 1589 : 		{
; 1590 : 			iWeight = GC.getBUILDER_TASKING_BASELINE_ADDS_CULTURE() * GC.getImprovementInfo(eImprovement)->GetYieldChange(YIELD_CULTURE);

	mov	ecx, DWORD PTR _eImprovement$218606[esp+148]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2160
	push	4
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR $T226330[esp+156], eax
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetYieldChange

; 1591 : 			int iAdjacentCulture = pImprovement->GetCultureAdjacentSameType();

	mov	ecx, DWORD PTR _pImprovement$218609[esp+148]
	mov	ebx, eax
	imul	ebx, DWORD PTR $T226330[esp+148]
	call	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureAdjacentSameType

; 1592 : 
; 1593 : 			if(iAdjacentCulture > 0)

	test	eax, eax
	jle	SHORT $LN3@AddImprovi@2

; 1594 : 			{
; 1595 : 				iScore *= (1 + pPlot->ComputeCultureFromAdjacentImprovement(*pImprovement, eImprovement));

	mov	edx, DWORD PTR _eImprovement$218606[esp+148]
	mov	eax, DWORD PTR _pImprovement$218609[esp+148]
	push	edx
	push	eax
	mov	ecx, esi
	call	?ComputeCultureFromAdjacentImprovement@CvPlot@@QBEHAAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvPlot::ComputeCultureFromAdjacentImprovement
	inc	eax
	imul	eax, DWORD PTR _iScore$218661[esp+148]
	mov	DWORD PTR _iScore$218661[esp+148], eax
$LN3@AddImprovi@2:

; 1596 : 			}
; 1597 : 		}
; 1598 : 
; 1599 : 		iWeight = GetBuildCostWeight(iWeight, pPlot, eBuild);

	push	ebp
	push	esi
	push	ebx
	mov	ecx, edi
	call	?GetBuildCostWeight@CvBuilderTaskingAI@@QAEHHPAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::GetBuildCostWeight

; 1600 : 		int iBuildTimeWeight = GetBuildTimeWeight(pUnit, pPlot, eBuild, DoesBuildHelpRush(pUnit, pPlot, eBuild), iMoveTurnsAway);

	mov	ecx, DWORD PTR _iMoveTurnsAway$[esp+144]
	mov	edx, DWORD PTR _pUnit$[esp+144]
	push	ecx
	push	ebp
	push	esi
	push	edx
	mov	ecx, edi
	mov	ebx, eax
	call	?DoesBuildHelpRush@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::DoesBuildHelpRush
	mov	ecx, DWORD PTR _pUnit$[esp+148]
	movzx	eax, al
	push	eax
	push	ebp
	push	esi
	push	ecx
	mov	ecx, edi
	call	?GetBuildTimeWeight@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@_NH@Z ; CvBuilderTaskingAI::GetBuildTimeWeight

; 1601 : 		iWeight += iBuildTimeWeight;
; 1602 : 		iWeight *= iScore;
; 1603 : 
; 1604 : 		if(m_pPlayer->GetPlayerTraits()->IsMoveFriendlyWoodsAsRoad() && bWillRemoveForestOrJungle)

	mov	ecx, DWORD PTR [edi]
	add	ebx, eax
	imul	ebx, DWORD PTR _iScore$218661[esp+148]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+333], 0
	je	SHORT $LN2@AddImprovi@2
	cmp	BYTE PTR _bWillRemoveForestOrJungle$218636[esp+148], 0
	je	SHORT $LN2@AddImprovi@2

; 1605 : 		{
; 1606 : 			iWeight = iWeight / 4;

	mov	eax, ebx
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	ebx, eax
$LN2@AddImprovi@2:

; 1607 : 		}
; 1608 : 
; 1609 : 		iWeight = CorrectWeight(iWeight);

	push	ebx
	call	?CorrectWeight@@YAHH@Z			; CorrectWeight
	add	esp, 4

; 1610 : 
; 1611 : #ifdef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 1612 : 		if (iWeight < iBestUniqueImprovementWeight && eFeature != NO_FEATURE && pkBuild->isFeatureRemove(eFeature))
; 1613 : 			continue;
; 1614 : #endif
; 1615 : 
; 1616 : 		BuilderDirective directive;

	lea	ecx, DWORD PTR _directive$218676[esp+148]
	mov	ebx, eax
	call	??0BuilderDirective@@QAE@XZ		; BuilderDirective::BuilderDirective

; 1617 : 
; 1618 : 		directive.m_eDirective = eDirectiveType;
; 1619 : 		directive.m_eBuild = eBuild;
; 1620 : 		directive.m_eResource = NO_RESOURCE;
; 1621 : 		directive.m_sX = pPlot->getX();
; 1622 : 		directive.m_sY = pPlot->getY();
; 1623 : 		directive.m_sMoveTurnsAway = iMoveTurnsAway;
; 1624 : 
; 1625 : 		if(m_bLogging)

	cmp	BYTE PTR [edi+58392], 0
	mov	edx, DWORD PTR _eDirectiveType$218667[esp+148]
	mov	ax, WORD PTR [esi]
	mov	cx, WORD PTR [esi+2]
	mov	DWORD PTR _directive$218676[esp+148], edx
	mov	dx, WORD PTR _iMoveTurnsAway$[esp+144]
	mov	DWORD PTR _directive$218676[esp+152], ebp
	mov	DWORD PTR _directive$218676[esp+156], -1
	mov	WORD PTR _directive$218676[esp+160], ax
	mov	WORD PTR _directive$218676[esp+162], cx
	mov	WORD PTR _directive$218676[esp+164], dx
	je	$LN1@AddImprovi@2

; 1626 : 		{
; 1627 : 			CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$218678[esp+148]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1628 : 			strTemp.Format("Weight,Directive Score Added,%s,,,,%i, %i, %i, %d", GC.getBuildInfo(eBuild)->GetType(), directive.m_sX, directive.m_sY, directive.m_sMoveTurnsAway, iWeight);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+160], 8
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	movsx	ecx, WORD PTR _iMoveTurnsAway$[esp+144]
	movsx	edx, WORD PTR _directive$218676[esp+162]
	push	ebx
	push	ecx
	movsx	ecx, WORD PTR _directive$218676[esp+168]
	push	edx
	push	ecx
	push	eax
	lea	edx, DWORD PTR _strTemp$218678[esp+168]
	push	OFFSET $SG218679
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1629 : 			LogInfo(strTemp, m_pPlayer);

	mov	eax, DWORD PTR [edi]
	add	esp, 28					; 0000001cH
	push	0
	push	eax
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strTemp$218678[esp+184]
	mov	DWORD PTR $T226011[esp+184], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 1630 : 		}

	lea	ecx, DWORD PTR _strTemp$218678[esp+148]
	mov	DWORD PTR __$EHRec$[esp+156], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@AddImprovi@2:

; 1631 : 
; 1632 : 		m_aDirectives.push_back(directive, iWeight);

	push	ebx
	lea	eax, DWORD PTR _directive$218676[esp+152]
	push	eax
	mov	ecx, OFFSET ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A ; CvBuilderTaskingAI::m_aDirectives
	call	?push_back@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEIABUBuilderDirective@@H@Z ; CvWeightedVector<BuilderDirective,100,1>::push_back
$LN40@AddImprovi@2:
	mov	ebp, DWORD PTR _iBuildIndex$[esp+148]
	inc	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iBuildIndex$[esp+148], ebp
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	ebp, eax
	jl	$LN41@AddImprovi@2
$LN39@AddImprovi@2:

; 1633 : 	}
; 1634 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+148]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 132				; 00000084H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$0:
	lea	ecx, DWORD PTR _strTemp$218613[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$6:
	lea	ecx, DWORD PTR _strTemp$218633[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$2:
	lea	ecx, DWORD PTR _strTemp$218620[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$4:
	lea	ecx, DWORD PTR _strTemp$218628[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$8:
	lea	ecx, DWORD PTR _strTemp$218644[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$10:
	lea	ecx, DWORD PTR _strTemp$218650[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$12:
	lea	ecx, DWORD PTR _strTemp$218658[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$14:
	lea	ecx, DWORD PTR _strTemp$218664[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$16:
	lea	ecx, DWORD PTR _strTemp$218678[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ENDP ; CvBuilderTaskingAI::AddImprovingPlotsDirectives
PUBLIC	?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddRouteDirectives
EXTRN	?GetBuilderAIScratchPadRoute@CvPlot@@QBE?AW4RouteTypes@@XZ:PROC ; CvPlot::GetBuilderAIScratchPadRoute
EXTRN	?GetBuilds@CvUnitEntry@@QBE_NH@Z:PROC		; CvUnitEntry::GetBuilds
EXTRN	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ:PROC	; CvUnit::getUnitInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$0
__ehfuncinfo$?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
_TEXT	SEGMENT
_this$ = -64						; size = 4
_directive$ = -60					; size = 20
_strTemp$218717 = -40					; size = 28
__$EHRec$ = -12						; size = 12
$T226386 = 8						; size = 4
_pUnit$ = 8						; size = 4
_eDirectiveType$ = 12					; size = 4
_pPlot$ = 12						; size = 4
_iMoveTurnsAway$ = 16					; size = 4
?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z PROC ; CvBuilderTaskingAI::AddRouteDirectives, COMDAT
; _this$ = ecx

; 1863 : {

	push	-1
	push	__ehhandler$?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 52					; 00000034H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+80], ecx

; 1864 : 	RouteTypes eBestRouteType = m_pPlayer->getBestRoute();

	mov	ecx, DWORD PTR [ecx]
	push	0
	call	?getBestRoute@CvPlayer@@QBE?AW4RouteTypes@@PAVCvPlot@@@Z ; CvPlayer::getBestRoute
	mov	edi, eax

; 1865 : 
; 1866 : 	// if the player can't build a route, bail out!
; 1867 : 	if(eBestRouteType == NO_ROUTE)

	cmp	edi, -1
	je	$LN17@AddRouteDi

; 1868 : 	{
; 1869 : 		return;
; 1870 : 	}
; 1871 : 
; 1872 : 	if(pPlot->getRouteType() == eBestRouteType && !pPlot->IsRoutePillaged())

	mov	esi, DWORD PTR _pPlot$[esp+76]
	mov	ecx, esi
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, edi
	jne	SHORT $LN15@AddRouteDi
	mov	ecx, esi
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	test	al, al
	je	$LN17@AddRouteDi
$LN15@AddRouteDi:

; 1873 : 	{
; 1874 : 		return;
; 1875 : 	}
; 1876 : 
; 1877 : #ifdef AUI_WARNING_FIXES
; 1878 : 	if (!pUnit)
; 1879 : 		return;
; 1880 : #endif
; 1881 : 
; 1882 : 	// the plot was not flagged this turn, so ignore
; 1883 : 	bool bShouldRoadThisTile = (pPlot->GetBuilderAIScratchPadTurn() == GC.getGame().getGameTurn()) && (pPlot->GetBuilderAIScratchPadPlayer() == pUnit->getOwner());

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ecx, esi
	call	?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ ; CvPlot::GetBuilderAIScratchPadTurn
	mov	ecx, edi
	movsx	ebp, ax
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	ebp, eax
	jne	$LN17@AddRouteDi
	mov	ebx, DWORD PTR _pUnit$[esp+76]
	mov	edi, DWORD PTR [ebx+40]
	mov	ecx, esi
	call	?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetBuilderAIScratchPadPlayer
	cmp	eax, edi

; 1884 : #ifdef AUI_WORKER_INCA_HILLS
; 1885 : 	bool bIncaBonusActive = (m_pPlayer->GetPlayerTraits()->IsNoHillsImprovementMaintenance() && !m_pPlayer->isHuman() && pPlot->getTerrainType() == TERRAIN_HILL);
; 1886 : 	if (!bShouldRoadThisTile && !bIncaBonusActive)
; 1887 : 	{
; 1888 : 		return;
; 1889 : 	}
; 1890 : #else
; 1891 : 	if(!bShouldRoadThisTile)

	jne	$LN17@AddRouteDi

; 1892 : 	{
; 1893 : 		return;
; 1894 : 	}
; 1895 : #endif
; 1896 : 
; 1897 : #ifdef AUI_WORKER_FIX_SHOULD_BUILDER_CONSIDER_PLOT_EXISTING_BUILD_MISSIONS_SHIFT
; 1898 : 	// check to see if someone already has a conflicting mission here
; 1899 : 	if (pUnit->GetMissionAIPlot() != pPlot)
; 1900 : 	{
; 1901 : 		int iLoop;
; 1902 : 		for (CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))
; 1903 : 		{
; 1904 : 			if (pUnit == pLoopUnit)
; 1905 : 			{
; 1906 : 				continue;
; 1907 : 			}
; 1908 : 
; 1909 : 			CvPlot* pMissionPlot = pLoopUnit->GetMissionAIPlot();
; 1910 : 			if (!pMissionPlot)
; 1911 : 			{
; 1912 : 				continue;
; 1913 : 			}
; 1914 : 
; 1915 : 			MissionAITypes eGroupMissionAI = pLoopUnit->GetMissionAIType();
; 1916 : 			if (eGroupMissionAI != MISSIONAI_BUILD)
; 1917 : 			{
; 1918 : 				continue;
; 1919 : 			}
; 1920 : 
; 1921 : 			if (pPlot->getX() == pMissionPlot->getX() && pPlot->getY() == pMissionPlot->getY())
; 1922 : 			{
; 1923 : 				BuildTypes eOtherBuild = pLoopUnit->getBuildType();
; 1924 : 				CvBuildInfo* pkBuild = GC.getBuildInfo(eOtherBuild);
; 1925 : 				if (pkBuild != NULL)
; 1926 : 				{
; 1927 : 					RouteTypes eOtherRoute = (RouteTypes)pkBuild->getRoute();
; 1928 : 					if (eOtherRoute != NO_ROUTE || (eOtherBuild == m_eRepairBuild && pPlot->IsRoutePillaged()))
; 1929 : 					{
; 1930 : 						if (m_bLogging)
; 1931 : 						{
; 1932 : 							CvString strLog;
; 1933 : 							strLog.Format("x: %d y: %d, Somebody has a conflicting mission here.", pPlot->getX(), pPlot->getY());
; 1934 : 							LogInfo(strLog, m_pPlayer, true);
; 1935 : 						}
; 1936 : 						return;
; 1937 : 					}
; 1938 : 				}
; 1939 : 			}
; 1940 : 		}
; 1941 : 	}
; 1942 : #endif
; 1943 : 
; 1944 : 	// find the route build
; 1945 : 	BuildTypes eRouteBuild = NO_BUILD;
; 1946 : 	if(pPlot->IsRoutePillaged())

	mov	ecx, esi
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	test	al, al
	je	$LN13@AddRouteDi

; 1947 : 	{
; 1948 : 		eRouteBuild = m_eRepairBuild;

	mov	eax, DWORD PTR _this$[esp+80]
	mov	ebp, DWORD PTR [eax+4]
$LN71@AddRouteDi:

; 1962 : 			{
; 1963 : 				eRouteBuild = eBuild;
; 1964 : 				break;
; 1965 : 			}
; 1966 : 		}
; 1967 : 	}
; 1968 : 
; 1969 : 	if(eRouteBuild == NO_BUILD)

	cmp	ebp, -1
	je	$LN17@AddRouteDi

; 1970 : 	{
; 1971 : 		return;
; 1972 : 	}
; 1973 : 
; 1974 : 	CvUnitEntry& kUnitInfo = pUnit->getUnitInfo();

	mov	ecx, ebx
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo

; 1975 : 	if(!kUnitInfo.GetBuilds(eRouteBuild))

	push	ebp
	mov	ecx, eax
	call	?GetBuilds@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetBuilds
	test	al, al
	je	$LN17@AddRouteDi

; 1976 : 	{
; 1977 : 		return;
; 1978 : 	}
; 1979 : 
; 1980 : 	if(GET_PLAYER(pUnit->getOwner()).isOption(PLAYEROPTION_LEAVE_FORESTS))

	mov	eax, DWORD PTR [ebx+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	7
	mov	ecx, eax
	call	?isOption@CvPlayer@@QBE_NW4PlayerOptionTypes@@@Z ; CvPlayer::isOption
	test	al, al
	je	SHORT $LN3@AddRouteDi

; 1981 : 	{
; 1982 : 		FeatureTypes eFeature = pPlot->getFeatureType();

	movsx	edi, BYTE PTR [esi+432]

; 1983 : 		if(eFeature != NO_FEATURE)

	cmp	edi, -1
	je	SHORT $LN3@AddRouteDi

; 1984 : 		{
; 1985 : 			CvBuildInfo* pkBuild = GC.getBuildInfo(eRouteBuild);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 1986 : 			if(pkBuild && pkBuild->isFeatureRemove(eFeature))

	test	eax, eax
	je	SHORT $LN3@AddRouteDi
	push	edi
	mov	ecx, eax
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	test	al, al
	jne	$LN17@AddRouteDi
$LN3@AddRouteDi:

; 1987 : 			{
; 1988 : 				return;
; 1989 : 			}
; 1990 : 		}
; 1991 : 	}
; 1992 : 
; 1993 : 	int iWeight = GC.getBUILDER_TASKING_BASELINE_BUILD_ROUTES();
; 1994 : 	BuilderDirective::BuilderDirectiveType eDirectiveType = BuilderDirective::BUILD_ROUTE;
; 1995 : 	if(eRouteBuild == m_eRepairBuild)

	mov	ecx, DWORD PTR _this$[esp+80]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2148
	mov	DWORD PTR _eDirectiveType$[esp+76], 2
	cmp	ebp, DWORD PTR [ecx+4]
	jne	SHORT $LN2@AddRouteDi

; 1996 : 	{
; 1997 : 		iWeight = GC.getBUILDER_TASKING_BASELINE_REPAIR();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2152

; 1998 : 		eDirectiveType = BuilderDirective::REPAIR;

	mov	DWORD PTR _eDirectiveType$[esp+76], 3
$LN2@AddRouteDi:

; 1999 : 	}
; 2000 : 
; 2001 : 	// int iTurnsAway = FindTurnsAway(pUnit, pPlot);
; 2002 : 	iWeight = iWeight / (iMoveTurnsAway/*iTurnsAway*/ + 1);

	mov	ebx, DWORD PTR _iMoveTurnsAway$[esp+76]
	cdq
	lea	ecx, DWORD PTR [ebx+1]
	idiv	ecx

; 2003 : 	iWeight = GetBuildCostWeight(iWeight, pPlot, eRouteBuild);

	mov	edx, DWORD PTR _this$[esp+80]
	mov	ecx, DWORD PTR [edx]
	push	ebp
	push	esi
	mov	edi, eax
	call	?getBuildCost@CvPlayer@@QBEHPBVCvPlot@@W4BuildTypes@@@Z ; CvPlayer::getBuildCost
	mov	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN44@AddRouteDi
	mov	eax, edi
	imul	eax, 100				; 00000064H
	cdq
	idiv	ecx
	mov	edi, eax
	jmp	SHORT $LN43@AddRouteDi
$LN13@AddRouteDi:

; 1949 : 	}
; 1950 : 	else
; 1951 : 	{
; 1952 : 		RouteTypes eRoute = pPlot->GetBuilderAIScratchPadRoute();

	mov	ecx, esi
	call	?GetBuilderAIScratchPadRoute@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::GetBuilderAIScratchPadRoute

; 1953 : #ifdef AUI_WARNING_FIXES
; 1954 : 		for (uint i = 0; i < GC.getNumBuildInfos(); i++)
; 1955 : #else
; 1956 : 		for(int i = 0; i < GC.getNumBuildInfos(); i++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	xor	ebp, ebp
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	$LN17@AddRouteDi
	npad	1
$LL11@AddRouteDi:

; 1957 : #endif
; 1958 : 		{
; 1959 : 			BuildTypes eBuild = (BuildTypes)i;
; 1960 : 			CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 1961 : 			if(pkBuild && pkBuild->getRoute() == eRoute)

	test	eax, eax
	je	SHORT $LN10@AddRouteDi
	mov	ecx, eax
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	cmp	eax, edi
	je	$LN71@AddRouteDi
$LN10@AddRouteDi:

; 1953 : #ifdef AUI_WARNING_FIXES
; 1954 : 		for (uint i = 0; i < GC.getNumBuildInfos(); i++)
; 1955 : #else
; 1956 : 		for(int i = 0; i < GC.getNumBuildInfos(); i++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebp
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	ebp, eax
	jl	SHORT $LL11@AddRouteDi

; 2031 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 64					; 00000040H
	ret	12					; 0000000cH

; 2003 : 	iWeight = GetBuildCostWeight(iWeight, pPlot, eRouteBuild);

$LN44@AddRouteDi:
	imul	edi, 100				; 00000064H
$LN43@AddRouteDi:

; 2004 : 	iWeight += GetBuildTimeWeight(pUnit, pPlot, eRouteBuild, false, iMoveTurnsAway);

	mov	eax, DWORD PTR _pUnit$[esp+76]
	mov	ecx, DWORD PTR _this$[esp+80]
	push	ebx
	push	0
	push	ebp
	push	esi
	push	eax
	call	?GetBuildTimeWeight@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@_NH@Z ; CvBuilderTaskingAI::GetBuildTimeWeight
	mov	ebx, eax

; 2005 : #ifdef AUI_WORKER_INCA_HILLS
; 2006 : 	if (!(bIncaBonusActive && pPlot->GetBuilderAIScratchPadValue() <= 0))
; 2007 : 	{
; 2008 : 		iWeight *= pPlot->GetBuilderAIScratchPadValue();
; 2009 : 	}
; 2010 : #else
; 2011 : 	iWeight *= pPlot->GetBuilderAIScratchPadValue();

	mov	ecx, esi
	add	ebx, edi
	call	?GetBuilderAIScratchPadValue@CvPlot@@QBEFXZ ; CvPlot::GetBuilderAIScratchPadValue
	movsx	edi, ax
	imul	edi, ebx

; 2012 : #endif
; 2013 : 	iWeight = CorrectWeight(iWeight);

	cmp	edi, -1000				; fffffc18H
	jge	SHORT $LN48@AddRouteDi
	mov	edi, 2147483647				; 7fffffffH
$LN48@AddRouteDi:

; 2014 : 
; 2015 : 	BuilderDirective directive;
; 2016 : 	directive.m_eDirective = eDirectiveType;

	mov	ecx, DWORD PTR _eDirectiveType$[esp+76]

; 2017 : 	directive.m_eBuild = eRouteBuild;
; 2018 : 	directive.m_eResource = NO_RESOURCE;
; 2019 : 	directive.m_sX = pPlot->getX();
; 2020 : 	directive.m_sY = pPlot->getY();
; 2021 : 	directive.m_sMoveTurnsAway = iMoveTurnsAway;
; 2022 : 
; 2023 : 	if(m_bLogging)

	mov	ebx, DWORD PTR _this$[esp+80]
	mov	dx, WORD PTR [esi]
	mov	ax, WORD PTR [esi+2]
	mov	DWORD PTR _directive$[esp+80], ecx
	mov	cx, WORD PTR _iMoveTurnsAway$[esp+76]
	mov	DWORD PTR _directive$[esp+84], ebp
	or	ebp, -1
	cmp	BYTE PTR [ebx+58392], 0
	mov	DWORD PTR _directive$[esp+88], ebp
	mov	WORD PTR _directive$[esp+92], dx
	mov	WORD PTR _directive$[esp+94], ax
	mov	WORD PTR _directive$[esp+96], cx
	je	SHORT $LN1@AddRouteDi

; 2024 : 	{
; 2025 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$218717[esp+80]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2026 : 		strTemp.Format("AddRouteDirectives, adding, x: %d y: %d, Weight, %d", pPlot->getX(), pPlot->getY(), iWeight);

	movsx	edx, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	push	edi
	push	edx
	push	eax
	lea	ecx, DWORD PTR _strTemp$218717[esp+92]
	push	OFFSET $SG218718
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+108], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 2027 : 		LogInfo(strTemp, m_pPlayer);

	mov	edx, DWORD PTR [ebx]
	add	esp, 20					; 00000014H
	push	0
	push	edx
	sub	esp, 28					; 0000001cH
	lea	eax, DWORD PTR _strTemp$218717[esp+116]
	mov	DWORD PTR $T226386[esp+112], esp
	mov	ecx, esp
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 2028 : 	}

	lea	ecx, DWORD PTR _strTemp$218717[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], ebp
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@AddRouteDi:

; 2029 : 
; 2030 : 	m_aDirectives.push_back(directive, iWeight);

	push	edi
	lea	ecx, DWORD PTR _directive$[esp+84]
	push	ecx
	mov	ecx, OFFSET ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A ; CvBuilderTaskingAI::m_aDirectives
	call	?push_back@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEIABUBuilderDirective@@H@Z ; CvWeightedVector<BuilderDirective,100,1>::push_back
$LN17@AddRouteDi:

; 2031 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 64					; 00000040H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$0:
	lea	ecx, DWORD PTR _strTemp$218717[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ENDP ; CvBuilderTaskingAI::AddRouteDirectives
PUBLIC	?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddChopDirectives
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
EXTRN	?getFeatureProduction@CvBuildInfo@@QBEHH@Z:PROC	; CvBuildInfo::getFeatureProduction
EXTRN	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z:PROC ; CvCityCitizens::IsWorkingPlot
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$0
__ehfuncinfo$?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
_TEXT	SEGMENT
_pFlavorManager$ = -92					; size = 4
_ui$218756 = -88					; size = 4
_iProduction$ = -88					; size = 4
_eFeature$ = -84					; size = 4
_iBuildIndex$218741 = -80				; size = 4
_pCity$ = -76						; size = 4
$T226613 = -72						; size = 4
$T226605 = -72						; size = 4
$T226597 = -72						; size = 4
$T226581 = -72						; size = 4
_iPreviousYield$218760 = -72				; size = 4
_this$ = -68						; size = 4
_iBuildTimeWeight$ = -64				; size = 4
_directive$218807 = -60					; size = 20
_strTemp$218809 = -40					; size = 28
__$EHRec$ = -12						; size = 12
$T226485 = 8						; size = 4
$T226484 = 8						; size = 4
_iWeight$ = 8						; size = 4
_pUnit$ = 8						; size = 4
_pPlot$ = 12						; size = 4
_iMoveTurnsAway$ = 16					; size = 4
?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z PROC ; CvBuilderTaskingAI::AddChopDirectives, COMDAT
; _this$ = ecx

; 2035 : {

	push	-1
	push	__ehhandler$?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2036 : #ifdef AUI_WARNING_FIXES
; 2037 : 	if (!pUnit || !pPlot)
; 2038 : 		return;
; 2039 : #endif
; 2040 : 	// if it's not within a city radius
; 2041 : 	if(!pPlot->isWithinTeamCityRadius(pUnit->getTeam()))

	mov	edi, DWORD PTR _pUnit$[esp+104]
	mov	ebp, ecx
	push	-1
	mov	ecx, edi
	mov	DWORD PTR _this$[esp+112], ebp
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	esi, DWORD PTR _pPlot$[esp+108]
	push	eax
	mov	ecx, esi
	call	?isWithinTeamCityRadius@CvPlot@@QBE_NW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlot::isWithinTeamCityRadius
	test	al, al
	je	$LN1@AddChopDir

; 2042 : 	{
; 2043 : 		return;
; 2044 : 	}
; 2045 : 
; 2046 : 	if(pPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	jne	$LN1@AddChopDir

; 2047 : 	{
; 2048 : 		return;
; 2049 : 	}
; 2050 : 
; 2051 : 	if(GET_PLAYER(pUnit->getOwner()).isOption(PLAYEROPTION_LEAVE_FORESTS))

	mov	eax, DWORD PTR [edi+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	7
	mov	ecx, eax
	call	?isOption@CvPlayer@@QBE_NW4PlayerOptionTypes@@@Z ; CvPlayer::isOption
	test	al, al
	jne	$LN1@AddChopDir

; 2052 : 	{
; 2053 : 		return;
; 2054 : 	}
; 2055 : 
; 2056 : 	// check to see if a resource is here. If so, bail out!
; 2057 : 	ResourceTypes eResource = pPlot->getResourceType(m_pPlayer->getTeam());

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN62@AddChopDir
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN63@AddChopDir
$LN62@AddChopDir:
	or	eax, -1
$LN63@AddChopDir:
	push	eax
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType

; 2058 : 	if(eResource != NO_RESOURCE)

	cmp	eax, -1
	jne	$LN1@AddChopDir

; 2059 : 	{
; 2060 : 		return;
; 2061 : 	}
; 2062 : 
; 2063 : 	CvCity* pCity = GetWorkingCity(pPlot);

	push	esi
	mov	ecx, ebp
	call	?GetWorkingCity@CvBuilderTaskingAI@@QAEPAVCvCity@@PAVCvPlot@@@Z ; CvBuilderTaskingAI::GetWorkingCity
	mov	DWORD PTR _pCity$[esp+108], eax

; 2064 : 	if(!pCity)

	test	eax, eax
	je	$LN1@AddChopDir

; 2065 : 	{
; 2066 : 		return;
; 2067 : 	}
; 2068 : 
; 2069 : 	if(pCity->GetCityCitizens()->IsWorkingPlot(pPlot))

	push	esi
	mov	ecx, eax
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ; CvCityCitizens::IsWorkingPlot
	test	al, al
	jne	$LN1@AddChopDir

; 2070 : 	{
; 2071 : 		return;
; 2072 : 	}
; 2073 : 
; 2074 : 	FeatureTypes eFeature = pPlot->getFeatureType();

	movsx	edi, BYTE PTR [esi+432]
	mov	DWORD PTR _eFeature$[esp+108], edi

; 2075 : 	if(eFeature == NO_FEATURE)

	cmp	edi, -1
	je	$LN1@AddChopDir

; 2076 : 	{
; 2077 : 		// no feature in this tile, so bail
; 2078 : 		return;
; 2079 : 	}
; 2080 : 
; 2081 : 	// celtic rule: if this is a forest tile next to a city, do not chop the trees
; 2082 : 	if (m_pPlayer->GetPlayerTraits()->IsFaithFromUnimprovedForest())

	mov	ecx, DWORD PTR [ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	al, BYTE PTR [eax+341]
	test	al, al
	je	SHORT $LN37@AddChopDir

; 2083 : 	{
; 2084 : 		CvCity* pAdjacentCity = pPlot->GetAdjacentCity();

	push	0
	mov	ecx, esi
	call	?GetAdjacentCity@CvPlot@@QBEPAVCvCity@@_N@Z ; CvPlot::GetAdjacentCity

; 2085 : 		if (pAdjacentCity && pAdjacentCity->getOwner() == m_pPlayer->GetID())

	test	eax, eax
	je	SHORT $LN37@AddChopDir
	mov	eax, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR [ebp]
	cmp	eax, DWORD PTR [ecx+44]
	jne	SHORT $LN37@AddChopDir

; 2086 : 		{
; 2087 : 			if (eFeature == FEATURE_FOREST)

	cmp	edi, 5
	je	$LN1@AddChopDir
$LN37@AddChopDir:

; 2088 : 			{
; 2089 : 				return;
; 2090 : 			}
; 2091 : 		}
; 2092 : 	}
; 2093 : 
; 2094 : #ifdef AUI_WORKER_FIX_SHOULD_BUILDER_CONSIDER_PLOT_EXISTING_BUILD_MISSIONS_SHIFT
; 2095 : 	// check to see if someone already has a conflicting mission here
; 2096 : 	if (pUnit->GetMissionAIPlot() != pPlot)
; 2097 : 	{
; 2098 : 		int iLoop;
; 2099 : 		for (CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))
; 2100 : 		{
; 2101 : 			if (pUnit == pLoopUnit)
; 2102 : 			{
; 2103 : 				continue;
; 2104 : 			}
; 2105 : 
; 2106 : 			CvPlot* pMissionPlot = pLoopUnit->GetMissionAIPlot();
; 2107 : 			if (!pMissionPlot)
; 2108 : 			{
; 2109 : 				continue;
; 2110 : 			}
; 2111 : 
; 2112 : 			MissionAITypes eGroupMissionAI = pLoopUnit->GetMissionAIType();
; 2113 : 			if (eGroupMissionAI != MISSIONAI_BUILD)
; 2114 : 			{
; 2115 : 				continue;
; 2116 : 			}
; 2117 : 
; 2118 : 			if (pPlot->getX() == pMissionPlot->getX() && pPlot->getY() == pMissionPlot->getY())
; 2119 : 			{
; 2120 : 				BuildTypes eOtherBuild = pLoopUnit->getBuildType();
; 2121 : 				CvBuildInfo* pkBuild = GC.getBuildInfo(eOtherBuild);
; 2122 : 				if (pkBuild != NULL && pkBuild->getImprovement() == NO_IMPROVEMENT && pkBuild->isFeatureRemove(eFeature))
; 2123 : 				{
; 2124 : 					if (m_bLogging)
; 2125 : 					{
; 2126 : 						CvString strLog;
; 2127 : 						strLog.Format("x: %d y: %d, Somebody has a conflicting mission here.", pPlot->getX(), pPlot->getY());
; 2128 : 						LogInfo(strLog, m_pPlayer, true);
; 2129 : 					}
; 2130 : 					return;
; 2131 : 				}
; 2132 : 			}
; 2133 : 		}
; 2134 : 	}
; 2135 : #endif
; 2136 : 
; 2137 : 	BuildTypes eChopBuild = NO_BUILD;
; 2138 : #ifdef AUI_WARNING_FIXES
; 2139 : 	for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 2140 : #else
; 2141 : 	for(int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	$LN1@AddChopDir
$LN36@AddChopDir:

; 2142 : #endif
; 2143 : 	{
; 2144 : 		BuildTypes eBuild = (BuildTypes)iBuildIndex;
; 2145 : 		CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ebx, eax

; 2146 : 		if(NULL != pkBuild && pkBuild->getImprovement() == NO_IMPROVEMENT && pkBuild->isFeatureRemove(eFeature) && pkBuild->getFeatureProduction(eFeature) > 0 && pUnit->canBuild(pPlot, eBuild))

	test	ebx, ebx
	je	SHORT $LN35@AddChopDir
	mov	ecx, ebx
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	cmp	eax, -1
	jne	SHORT $LN35@AddChopDir
	mov	edx, DWORD PTR _eFeature$[esp+108]
	push	edx
	mov	ecx, ebx
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	test	al, al
	je	SHORT $LN35@AddChopDir
	mov	eax, DWORD PTR _eFeature$[esp+108]
	push	eax
	mov	ecx, ebx
	call	?getFeatureProduction@CvBuildInfo@@QBEHH@Z ; CvBuildInfo::getFeatureProduction
	test	eax, eax
	jle	SHORT $LN35@AddChopDir
	mov	ebx, DWORD PTR _pUnit$[esp+104]
	push	1
	push	0
	push	edi
	push	esi
	mov	ecx, ebx
	call	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z ; CvUnit::canBuild
	test	al, al
	jne	SHORT $LN131@AddChopDir
$LN35@AddChopDir:

; 2088 : 			{
; 2089 : 				return;
; 2090 : 			}
; 2091 : 		}
; 2092 : 	}
; 2093 : 
; 2094 : #ifdef AUI_WORKER_FIX_SHOULD_BUILDER_CONSIDER_PLOT_EXISTING_BUILD_MISSIONS_SHIFT
; 2095 : 	// check to see if someone already has a conflicting mission here
; 2096 : 	if (pUnit->GetMissionAIPlot() != pPlot)
; 2097 : 	{
; 2098 : 		int iLoop;
; 2099 : 		for (CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))
; 2100 : 		{
; 2101 : 			if (pUnit == pLoopUnit)
; 2102 : 			{
; 2103 : 				continue;
; 2104 : 			}
; 2105 : 
; 2106 : 			CvPlot* pMissionPlot = pLoopUnit->GetMissionAIPlot();
; 2107 : 			if (!pMissionPlot)
; 2108 : 			{
; 2109 : 				continue;
; 2110 : 			}
; 2111 : 
; 2112 : 			MissionAITypes eGroupMissionAI = pLoopUnit->GetMissionAIType();
; 2113 : 			if (eGroupMissionAI != MISSIONAI_BUILD)
; 2114 : 			{
; 2115 : 				continue;
; 2116 : 			}
; 2117 : 
; 2118 : 			if (pPlot->getX() == pMissionPlot->getX() && pPlot->getY() == pMissionPlot->getY())
; 2119 : 			{
; 2120 : 				BuildTypes eOtherBuild = pLoopUnit->getBuildType();
; 2121 : 				CvBuildInfo* pkBuild = GC.getBuildInfo(eOtherBuild);
; 2122 : 				if (pkBuild != NULL && pkBuild->getImprovement() == NO_IMPROVEMENT && pkBuild->isFeatureRemove(eFeature))
; 2123 : 				{
; 2124 : 					if (m_bLogging)
; 2125 : 					{
; 2126 : 						CvString strLog;
; 2127 : 						strLog.Format("x: %d y: %d, Somebody has a conflicting mission here.", pPlot->getX(), pPlot->getY());
; 2128 : 						LogInfo(strLog, m_pPlayer, true);
; 2129 : 					}
; 2130 : 					return;
; 2131 : 				}
; 2132 : 			}
; 2133 : 		}
; 2134 : 	}
; 2135 : #endif
; 2136 : 
; 2137 : 	BuildTypes eChopBuild = NO_BUILD;
; 2138 : #ifdef AUI_WARNING_FIXES
; 2139 : 	for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 2140 : #else
; 2141 : 	for(int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	edi, eax
	jl	SHORT $LN36@AddChopDir

; 2291 : 		}
; 2292 : 	}
; 2293 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+108]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 92					; 0000005cH
	ret	12					; 0000000cH
$LN131@AddChopDir:

; 2088 : 			{
; 2089 : 				return;
; 2090 : 			}
; 2091 : 		}
; 2092 : 	}
; 2093 : 
; 2094 : #ifdef AUI_WORKER_FIX_SHOULD_BUILDER_CONSIDER_PLOT_EXISTING_BUILD_MISSIONS_SHIFT
; 2095 : 	// check to see if someone already has a conflicting mission here
; 2096 : 	if (pUnit->GetMissionAIPlot() != pPlot)
; 2097 : 	{
; 2098 : 		int iLoop;
; 2099 : 		for (CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))
; 2100 : 		{
; 2101 : 			if (pUnit == pLoopUnit)
; 2102 : 			{
; 2103 : 				continue;
; 2104 : 			}
; 2105 : 
; 2106 : 			CvPlot* pMissionPlot = pLoopUnit->GetMissionAIPlot();
; 2107 : 			if (!pMissionPlot)
; 2108 : 			{
; 2109 : 				continue;
; 2110 : 			}
; 2111 : 
; 2112 : 			MissionAITypes eGroupMissionAI = pLoopUnit->GetMissionAIType();
; 2113 : 			if (eGroupMissionAI != MISSIONAI_BUILD)
; 2114 : 			{
; 2115 : 				continue;
; 2116 : 			}
; 2117 : 
; 2118 : 			if (pPlot->getX() == pMissionPlot->getX() && pPlot->getY() == pMissionPlot->getY())
; 2119 : 			{
; 2120 : 				BuildTypes eOtherBuild = pLoopUnit->getBuildType();
; 2121 : 				CvBuildInfo* pkBuild = GC.getBuildInfo(eOtherBuild);
; 2122 : 				if (pkBuild != NULL && pkBuild->getImprovement() == NO_IMPROVEMENT && pkBuild->isFeatureRemove(eFeature))
; 2123 : 				{
; 2124 : 					if (m_bLogging)
; 2125 : 					{
; 2126 : 						CvString strLog;
; 2127 : 						strLog.Format("x: %d y: %d, Somebody has a conflicting mission here.", pPlot->getX(), pPlot->getY());
; 2128 : 						LogInfo(strLog, m_pPlayer, true);
; 2129 : 					}
; 2130 : 					return;
; 2131 : 				}
; 2132 : 			}
; 2133 : 		}
; 2134 : 	}
; 2135 : #endif
; 2136 : 
; 2137 : 	BuildTypes eChopBuild = NO_BUILD;
; 2138 : #ifdef AUI_WARNING_FIXES
; 2139 : 	for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 2140 : #else
; 2141 : 	for(int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	DWORD PTR _iBuildIndex$218741[esp+108], edi

; 2147 : 		{
; 2148 : 			eChopBuild = eBuild;
; 2149 : 			break;
; 2150 : 		}
; 2151 : 	}
; 2152 : 
; 2153 : 	if(eChopBuild == NO_BUILD)

	cmp	edi, -1
	je	$LN1@AddChopDir

; 2154 : 	{
; 2155 : 		// we couldn't find a build that removed the feature without a production benefit
; 2156 : 		return;
; 2157 : 	}
; 2158 : 
; 2159 : 	pCity = NULL;
; 2160 : 	int iProduction = pPlot->getFeatureProduction(eChopBuild, pUnit->getOwner(), &pCity);

	mov	eax, DWORD PTR [ebx+40]
	lea	ecx, DWORD PTR _pCity$[esp+108]
	push	ecx
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR _pCity$[esp+120], 0
	call	?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ; CvPlot::getFeatureProduction

; 2161 : 
; 2162 : 	if(!DoesBuildHelpRush(pUnit, pPlot, eChopBuild))

	push	edi
	push	esi
	push	ebx
	mov	ecx, ebp
	mov	DWORD PTR _iProduction$[esp+120], eax
	call	?DoesBuildHelpRush@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::DoesBuildHelpRush
	test	al, al
	je	$LN1@AddChopDir

; 2163 : 	{
; 2164 : 		return;
; 2165 : 	}
; 2166 : 
; 2167 : 	int iWeight = GC.getBUILDER_TASKING_BASELINE_REPAIR();
; 2168 : 	//int iTurnsAway = FindTurnsAway(pUnit, pPlot);
; 2169 : 	iWeight = iWeight / (iMoveTurnsAway/*iTurnsAway*/ + 1);

	mov	edx, DWORD PTR _iMoveTurnsAway$[esp+104]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2152
	lea	ecx, DWORD PTR [edx+1]
	cdq
	idiv	ecx

; 2170 : 	iWeight = GetBuildCostWeight(iWeight, pPlot, eChopBuild);

	push	edi
	push	esi
	mov	ecx, ebp
	push	eax
	call	?GetBuildCostWeight@CvBuilderTaskingAI@@QAEHHPAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::GetBuildCostWeight

; 2171 : 	int iBuildTimeWeight = GetBuildTimeWeight(pUnit, pPlot, eChopBuild, false, iMoveTurnsAway);

	mov	edx, DWORD PTR _iMoveTurnsAway$[esp+104]
	push	edx
	push	0
	push	edi
	mov	ebx, eax
	mov	eax, DWORD PTR _pUnit$[esp+116]
	push	esi
	push	eax
	mov	ecx, ebp
	call	?GetBuildTimeWeight@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@_NH@Z ; CvBuilderTaskingAI::GetBuildTimeWeight

; 2172 : 	iWeight += iBuildTimeWeight;
; 2173 : 	iWeight *= iProduction; // times the amount that the plot produces from the chopping
; 2174 : 
; 2175 : 	int iYieldDifferenceWeight = 0;
; 2176 : 	CvFlavorManager* pFlavorManager = m_pPlayer->GetFlavorManager();

	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR _iBuildTimeWeight$[esp+108], eax
	add	eax, ebx
	imul	eax, DWORD PTR _iProduction$[esp+108]
	mov	DWORD PTR _iWeight$[esp+104], eax
	xor	ebx, ebx
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager

; 2177 : 	for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	xor	edi, edi
	mov	DWORD PTR _pFlavorManager$[esp+108], eax
	mov	DWORD PTR _ui$218756[esp+108], edi
	jmp	SHORT $LN30@AddChopDir
	npad	3
$LL139@AddChopDir:
	mov	edi, DWORD PTR _ui$218756[esp+108]
$LN30@AddChopDir:

; 2178 : 	{
; 2179 : 		// calculate natural yields
; 2180 : 		int iPreviousYield = pPlot->calculateNatureYield((YieldTypes)ui, m_pPlayer->getTeam());

	mov	ecx, DWORD PTR [ebp]
	push	0
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	push	edi
	mov	ecx, esi
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield

; 2181 : 		int iNewYield = pPlot->calculateNatureYield((YieldTypes)ui, m_pPlayer->getTeam(), true /*bIgnoreFeature*/);

	mov	ecx, DWORD PTR [ebp]
	push	1
	mov	DWORD PTR _iPreviousYield$218760[esp+112], eax
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	push	edi
	mov	ecx, esi
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield

; 2182 : 		int iDeltaYield = iNewYield - iPreviousYield;

	sub	eax, DWORD PTR _iPreviousYield$218760[esp+108]
	mov	edi, eax

; 2183 : 
; 2184 : 		if(iDeltaYield == 0)

	je	$LN29@AddChopDir

; 2185 : 		{
; 2186 : 			continue;
; 2187 : 		}
; 2188 : 
; 2189 : 		for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	xor	esi, esi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, esi
	jle	$LN138@AddChopDir
	xor	ebp, ebp
	npad	6
$LL26@AddChopDir:

; 2190 : 		{
; 2191 : 			switch(ui)

	mov	eax, DWORD PTR _ui$218756[esp+108]
	cmp	eax, 4
	ja	$LN25@AddChopDir
	jmp	DWORD PTR $LN146@AddChopDir[eax*4]
$LN21@AddChopDir:

; 2192 : 			{
; 2193 : 			case YIELD_FOOD:
; 2194 : 				if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_GROWTH")

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	lea	eax, DWORD PTR [ecx+ebp]
	push	OFFSET $SG218777
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al
	je	$LN25@AddChopDir

; 2195 : 				{
; 2196 : 					iYieldDifferenceWeight += iDeltaYield * pFlavorManager->GetPersonalityIndividualFlavor((FlavorTypes)iFlavorLoop) * GC.getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_FOOD();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2104
	mov	DWORD PTR $T226581[esp+108], edx

; 2197 : 				}
; 2198 : 				break;

	jmp	$LN144@AddChopDir
$LN19@AddChopDir:

; 2199 : 			case YIELD_PRODUCTION:
; 2200 : 				if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_PRODUCTION")

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	add	eax, ebp
	push	OFFSET $SG218782
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al
	je	$LN25@AddChopDir

; 2201 : 				{
; 2202 : 					iYieldDifferenceWeight += iDeltaYield * pFlavorManager->GetPersonalityIndividualFlavor((FlavorTypes)iFlavorLoop) * GC.getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_PRODUCTION();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2108

; 2203 : 				}
; 2204 : 				break;

	jmp	SHORT $LN145@AddChopDir
$LN17@AddChopDir:

; 2205 : 			case YIELD_GOLD:
; 2206 : 				if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_GOLD")

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	lea	eax, DWORD PTR [edx+ebp]
	push	OFFSET $SG218787
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al
	je	SHORT $LN25@AddChopDir

; 2207 : 				{
; 2208 : 					iYieldDifferenceWeight += iDeltaYield * pFlavorManager->GetPersonalityIndividualFlavor((FlavorTypes)iFlavorLoop) * GC.getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_GOLD();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2112
	mov	DWORD PTR $T226597[esp+108], eax

; 2209 : 				}
; 2210 : 				break;

	jmp	SHORT $LN144@AddChopDir
$LN15@AddChopDir:

; 2211 : 			case YIELD_SCIENCE:
; 2212 : 				if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_SCIENCE")

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	lea	eax, DWORD PTR [ecx+ebp]
	push	OFFSET $SG218792
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al
	je	SHORT $LN25@AddChopDir

; 2213 : 				{
; 2214 : 					iYieldDifferenceWeight += iDeltaYield * pFlavorManager->GetPersonalityIndividualFlavor((FlavorTypes)iFlavorLoop) * GC.getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_SCIENCE();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2116
	mov	DWORD PTR $T226605[esp+108], edx

; 2215 : 				}
; 2216 : 				break;

	jmp	SHORT $LN144@AddChopDir
$LN13@AddChopDir:

; 2217 : 			case YIELD_CULTURE:
; 2218 : 				if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_CULTURE")

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	add	eax, ebp
	push	OFFSET $SG218797
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al
	je	SHORT $LN25@AddChopDir

; 2219 : 				{
; 2220 : 					iYieldDifferenceWeight += iDeltaYield * pFlavorManager->GetPersonalityIndividualFlavor((FlavorTypes)iFlavorLoop) * GC.getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_CULTURE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2120
$LN145@AddChopDir:
	mov	DWORD PTR $T226613[esp+108], ecx
$LN144@AddChopDir:
	mov	ecx, DWORD PTR _pFlavorManager$[esp+108]
	push	esi
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	imul	eax, DWORD PTR $T226613[esp+108]
	imul	eax, edi
	add	ebx, eax
$LN25@AddChopDir:
	inc	esi
	add	ebp, 28					; 0000001cH
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	$LL26@AddChopDir

; 2185 : 		{
; 2186 : 			continue;
; 2187 : 		}
; 2188 : 
; 2189 : 		for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	ebp, DWORD PTR _this$[esp+108]
$LN138@AddChopDir:
	mov	esi, DWORD PTR _pPlot$[esp+104]
$LN29@AddChopDir:

; 2177 : 	for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	mov	eax, DWORD PTR _ui$218756[esp+108]
	inc	eax
	mov	DWORD PTR _ui$218756[esp+108], eax
	cmp	eax, 6
	jb	$LL139@AddChopDir

; 2221 : 				}
; 2222 : 				break;
; 2223 : 			case YIELD_FAITH:
; 2224 : #ifdef AUI_WORKER_EVALUATE_FAITH
; 2225 : 				if (GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_RELIGION")
; 2226 : 				{
; 2227 : 					iYieldDifferenceWeight += iDeltaYield * pFlavorManager->GetPersonalityIndividualFlavor((FlavorTypes)iFlavorLoop) * GC.getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_CULTURE();
; 2228 : 				}
; 2229 : #else
; 2230 : 				//if (GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_SCIENCE")
; 2231 : 				//{
; 2232 : 				//	iYieldDifferenceWeight += iDeltaYield * pFlavorManager->GetPersonalityIndividualFlavor((FlavorTypes)iFlavorLoop) * GC.getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_SCIENCE();
; 2233 : 				//}
; 2234 : #endif
; 2235 : 				break;
; 2236 : 			}
; 2237 : 		}
; 2238 : 	}
; 2239 : 
; 2240 : 	// if we are going backwards, bail
; 2241 : 	if(iYieldDifferenceWeight < 0)

	test	ebx, ebx
	jl	$LN1@AddChopDir

; 2242 : 	{
; 2243 : 		return;
; 2244 : 	}
; 2245 : 
; 2246 : 	iWeight += iYieldDifferenceWeight;

	mov	edi, DWORD PTR _iWeight$[esp+104]

; 2247 : 
; 2248 : 	if (m_pPlayer->GetPlayerTraits()->IsMoveFriendlyWoodsAsRoad() && (eFeature == FEATURE_FOREST || eFeature == FEATURE_JUNGLE))

	mov	ecx, DWORD PTR [ebp]
	add	edi, ebx
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	al, BYTE PTR [eax+333]
	mov	ebx, DWORD PTR _eFeature$[esp+108]
	test	al, al
	je	SHORT $LN9@AddChopDir
	cmp	ebx, 5
	je	SHORT $LN8@AddChopDir
	cmp	ebx, 1
	jne	SHORT $LN9@AddChopDir
$LN8@AddChopDir:

; 2249 : 	{
; 2250 : 		iWeight = iWeight / 4;

	mov	eax, edi
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _iWeight$[esp+104], eax
	mov	edi, eax
$LN9@AddChopDir:

; 2251 : 	}
; 2252 : 	if (m_pPlayer->GetPlayerTraits()->IsFaithFromUnimprovedForest() && eFeature == FEATURE_FOREST)

	mov	ecx, DWORD PTR [ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+341], 0
	je	SHORT $LN7@AddChopDir
	cmp	ebx, 5
	jne	SHORT $LN7@AddChopDir

; 2253 : 	{
; 2254 : 		iWeight = iWeight / 4;

	mov	eax, edi
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _iWeight$[esp+104], eax
	mov	edi, eax
$LN7@AddChopDir:

; 2255 : 	}
; 2256 : #ifndef AUI_WORKER_NO_CHOP_BIAS
; 2257 : 	// this doesn't actually help them, but adds some historical flavor
; 2258 : 	if (m_pPlayer->GetPlayerTraits()->IsEmbarkedAllWater() && (eFeature == FEATURE_FOREST || eFeature == FEATURE_JUNGLE))

	mov	ecx, DWORD PTR [ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+336], 0
	je	SHORT $LN6@AddChopDir
	cmp	ebx, 5
	je	SHORT $LN5@AddChopDir
	cmp	ebx, 1
	jne	SHORT $LN6@AddChopDir
$LN5@AddChopDir:

; 2259 : 	{
; 2260 : 		iWeight = iWeight * 2;

	lea	edx, DWORD PTR [edi+edi]
	mov	DWORD PTR _iWeight$[esp+104], edx
	mov	edi, edx
$LN6@AddChopDir:

; 2261 : 	}
; 2262 : #endif
; 2263 : 
; 2264 : 	iWeight = CorrectWeight(iWeight);

	push	edi
	call	?CorrectWeight@@YAHH@Z			; CorrectWeight
	mov	edi, eax
	add	esp, 4

; 2265 : 
; 2266 : 	if(iWeight > 0)

	test	edi, edi
	jle	$LN4@AddChopDir

; 2267 : 	{
; 2268 : 		BuilderDirective directive;

	lea	ecx, DWORD PTR _directive$218807[esp+108]
	call	??0BuilderDirective@@QAE@XZ		; BuilderDirective::BuilderDirective

; 2269 : 		directive.m_eDirective = BuilderDirective::CHOP;
; 2270 : 		directive.m_eBuild = eChopBuild;

	mov	eax, DWORD PTR _iBuildIndex$218741[esp+108]

; 2271 : 		directive.m_eResource = NO_RESOURCE;
; 2272 : 		directive.m_sX = pPlot->getX();

	mov	cx, WORD PTR [esi]

; 2273 : 		directive.m_sY = pPlot->getY();

	mov	dx, WORD PTR [esi+2]
	mov	DWORD PTR _directive$218807[esp+112], eax

; 2274 : 		//directive.m_iGoldCost = m_pPlayer->getBuildCost(pPlot, eChopBuild);
; 2275 : 		directive.m_sMoveTurnsAway = iMoveTurnsAway;

	mov	ax, WORD PTR _iMoveTurnsAway$[esp+104]
	or	ebx, -1

; 2276 : 
; 2277 : 		if(m_bLogging)

	cmp	BYTE PTR [ebp+58392], 0
	mov	DWORD PTR _directive$218807[esp+108], 4
	mov	DWORD PTR _directive$218807[esp+116], ebx
	mov	WORD PTR _directive$218807[esp+120], cx
	mov	WORD PTR _directive$218807[esp+122], dx
	mov	WORD PTR _directive$218807[esp+124], ax
	je	SHORT $LN3@AddChopDir

; 2278 : 		{
; 2279 : 			CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$218809[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2280 : 			strTemp.Format("BuildTimeWeight, %d, Weight, %d", iBuildTimeWeight, iWeight);

	mov	ecx, DWORD PTR _iBuildTimeWeight$[esp+108]
	push	edi
	push	ecx
	lea	edx, DWORD PTR _strTemp$218809[esp+116]
	push	OFFSET $SG218810
	push	edx
	mov	DWORD PTR __$EHRec$[esp+132], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 2281 : 			LogInfo(strTemp, m_pPlayer);

	mov	eax, DWORD PTR [ebp]
	add	esp, 16					; 00000010H
	push	0
	push	eax
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strTemp$218809[esp+144]
	mov	DWORD PTR $T226484[esp+140], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 2282 : 		}

	lea	ecx, DWORD PTR _strTemp$218809[esp+108]
	mov	DWORD PTR __$EHRec$[esp+116], ebx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@AddChopDir:

; 2283 : 
; 2284 : 		m_aDirectives.push_back(directive, iWeight);

	push	edi
	lea	eax, DWORD PTR _directive$218807[esp+112]
	push	eax
	mov	ecx, OFFSET ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A ; CvBuilderTaskingAI::m_aDirectives
	call	?push_back@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEIABUBuilderDirective@@H@Z ; CvWeightedVector<BuilderDirective,100,1>::push_back

; 2291 : 		}
; 2292 : 	}
; 2293 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+108]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 92					; 0000005cH
	ret	12					; 0000000cH
$LN4@AddChopDir:

; 2285 : 	}
; 2286 : 	else
; 2287 : 	{
; 2288 : 		if(m_bLogging)

	cmp	BYTE PTR [ebp+58392], 0
	je	SHORT $LN1@AddChopDir

; 2289 : 		{
; 2290 : 			LogInfo("Add chop directives, Weight is zero!", m_pPlayer);

	mov	ecx, DWORD PTR [ebp]
	push	0
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T226485[esp+140], esp
	push	OFFSET $SG218815
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H
$LN1@AddChopDir:

; 2291 : 		}
; 2292 : 	}
; 2293 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+108]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 92					; 0000005cH
	ret	12					; 0000000cH
	npad	1
$LN146@AddChopDir:
	DD	$LN21@AddChopDir
	DD	$LN19@AddChopDir
	DD	$LN17@AddChopDir
	DD	$LN15@AddChopDir
	DD	$LN13@AddChopDir
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$0:
	lea	ecx, DWORD PTR _strTemp$218809[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ENDP ; CvBuilderTaskingAI::AddChopDirectives
PUBLIC	?AddRemoveUselessRoadDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddRemoveUselessRoadDirectives
EXTRN	?IsRemoveRoute@CvBuildInfo@@QBE_NXZ:PROC	; CvBuildInfo::IsRemoveRoute
; Function compile flags: /Ogtpy
;	COMDAT ?AddRemoveUselessRoadDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pUnit$ = 8						; size = 4
_pPlot$ = 12						; size = 4
_iMoveTurnsAway$ = 16					; size = 4
?AddRemoveUselessRoadDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z PROC ; CvBuilderTaskingAI::AddRemoveUselessRoadDirectives, COMDAT
; _this$ = ecx

; 2296 : {

	push	ecx
	push	ebp

; 2297 : 	// if it's not within a city radius
; 2298 : 	if(!pPlot->isWithinTeamCityRadius(pUnit->getTeam()))

	mov	ebp, DWORD PTR _pUnit$[esp+4]
	push	edi
	mov	DWORD PTR _this$[esp+12], ecx
	push	-1
	mov	ecx, ebp
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	edi, DWORD PTR _pPlot$[esp+12]
	push	eax
	mov	ecx, edi
	call	?isWithinTeamCityRadius@CvPlot@@QBE_NW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlot::isWithinTeamCityRadius
	test	al, al
	je	$LN2@AddRemoveU

; 2299 : 	{
; 2300 : 		return;
; 2301 : 	}
; 2302 : 
; 2303 : 	// don't try to remove the route under the city
; 2304 : 	if(pPlot->isCity())

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	jl	SHORT $LN38@AddRemoveU
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN38@AddRemoveU
	mov	ecx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	$LN2@AddRemoveU
$LN38@AddRemoveU:

; 2305 : 	{
; 2306 : 		return;
; 2307 : 	}
; 2308 : 
; 2309 : 	// nothing here to remove
; 2310 : 	if(pPlot->getRouteType() == NO_ROUTE)

	mov	ecx, edi
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, -1
	je	$LN2@AddRemoveU
	push	ebx
	push	esi

; 2311 : 	{
; 2312 : 		return;
; 2313 : 	}
; 2314 : 
; 2315 : 	// flagged this turn means this is a valid route plot
; 2316 : 	if(pPlot->GetBuilderAIScratchPadTurn() == GC.getGame().getGameTurn() && pPlot->GetBuilderAIScratchPadPlayer() == pUnit->getOwner())

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ecx, edi
	call	?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ ; CvPlot::GetBuilderAIScratchPadTurn
	mov	ecx, esi
	movsx	ebx, ax
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	ebx, eax
	jne	SHORT $LN8@AddRemoveU
	mov	esi, DWORD PTR [ebp+40]
	mov	ecx, edi
	call	?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetBuilderAIScratchPadPlayer
	cmp	eax, esi
	je	SHORT $LN39@AddRemoveU
$LN8@AddRemoveU:

; 2317 : 	{
; 2318 : 		return;
; 2319 : 	}
; 2320 : 
; 2321 : 	BuildTypes eRemoveRouteBuild = NO_BUILD;
; 2322 : #ifdef AUI_WARNING_FIXES
; 2323 : 	for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 2324 : #else
; 2325 : 	for(int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	SHORT $LN39@AddRemoveU
$LL7@AddRemoveU:

; 2326 : #endif
; 2327 : 	{
; 2328 : 		BuildTypes eBuild = (BuildTypes)iBuildIndex;
; 2329 : 		CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 2330 : 		if(NULL != pkBuild && pkBuild->IsRemoveRoute() && pUnit->canBuild(pPlot, eBuild))

	test	eax, eax
	je	SHORT $LN6@AddRemoveU
	mov	ecx, eax
	call	?IsRemoveRoute@CvBuildInfo@@QBE_NXZ	; CvBuildInfo::IsRemoveRoute
	test	al, al
	je	SHORT $LN6@AddRemoveU
	push	1
	push	0
	push	esi
	push	edi
	mov	ecx, ebp
	call	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z ; CvUnit::canBuild
	test	al, al
	jne	SHORT $LN36@AddRemoveU
$LN6@AddRemoveU:

; 2317 : 	{
; 2318 : 		return;
; 2319 : 	}
; 2320 : 
; 2321 : 	BuildTypes eRemoveRouteBuild = NO_BUILD;
; 2322 : #ifdef AUI_WARNING_FIXES
; 2323 : 	for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 2324 : #else
; 2325 : 	for(int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	esi, eax
	jl	SHORT $LL7@AddRemoveU
	pop	esi
	pop	ebx
	pop	edi
	pop	ebp

; 2349 : 	}
; 2350 : 
; 2351 : 	//int iWeight = GetWeightFromPlotYields(m_pPlayer, pPlot, eBuild, NULL, NO_YIELD, 100, NO_ROUTE) - GetWeightFromPlotYields(m_pPlayer, pPlot, eBuild, NULL, NO_YIELD, 10);
; 2352 : 	int iWeight = 0;
; 2353 : 	iWeight = CorrectWeight(iWeight);
; 2354 : 
; 2355 : 	if(iWeight > 0)
; 2356 : 	{
; 2357 : 		BuilderDirective directive;
; 2358 : 		directive.m_eDirective = BuilderDirective::REMOVE_ROAD;
; 2359 : 		directive.m_eBuild = eRemoveRouteBuild;
; 2360 : 		directive.m_eResource = NO_RESOURCE;
; 2361 : 		directive.m_sX = pPlot->getX();
; 2362 : 		directive.m_sY = pPlot->getY();
; 2363 : 		directive.m_sMoveTurnsAway = iMoveTurnsAway;
; 2364 : 
; 2365 : 		m_aDirectives.push_back(directive, iWeight);
; 2366 : 	}
; 2367 : 
; 2368 : }

	pop	ecx
	ret	12					; 0000000cH
$LN36@AddRemoveU:

; 2331 : 		{
; 2332 : 			eRemoveRouteBuild = eBuild;
; 2333 : 			break;
; 2334 : 		}
; 2335 : 	}
; 2336 : 
; 2337 : 
; 2338 : 	if(eRemoveRouteBuild == NO_BUILD)

	cmp	esi, -1
	je	SHORT $LN39@AddRemoveU

; 2339 : 	{
; 2340 : 		return;
; 2341 : 	}
; 2342 : 
; 2343 : 	// evaluate if removing the road helps anything
; 2344 : 	ImprovementTypes eImprovement = pPlot->getImprovementType();

	mov	ecx, edi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType

; 2345 : 	BuildTypes eBuild = NO_BUILD;
; 2346 : 	if(eImprovement != NO_IMPROVEMENT)

	cmp	eax, -1
	je	SHORT $LN39@AddRemoveU

; 2347 : 	{
; 2348 : 		eBuild = GetBuildTypeFromImprovement(eImprovement);

	mov	ecx, DWORD PTR _this$[esp+20]
	push	eax
	call	?GetBuildTypeFromImprovement@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@W4ImprovementTypes@@@Z ; CvBuilderTaskingAI::GetBuildTypeFromImprovement
$LN39@AddRemoveU:
	pop	esi
	pop	ebx
$LN2@AddRemoveU:
	pop	edi
	pop	ebp

; 2349 : 	}
; 2350 : 
; 2351 : 	//int iWeight = GetWeightFromPlotYields(m_pPlayer, pPlot, eBuild, NULL, NO_YIELD, 100, NO_ROUTE) - GetWeightFromPlotYields(m_pPlayer, pPlot, eBuild, NULL, NO_YIELD, 10);
; 2352 : 	int iWeight = 0;
; 2353 : 	iWeight = CorrectWeight(iWeight);
; 2354 : 
; 2355 : 	if(iWeight > 0)
; 2356 : 	{
; 2357 : 		BuilderDirective directive;
; 2358 : 		directive.m_eDirective = BuilderDirective::REMOVE_ROAD;
; 2359 : 		directive.m_eBuild = eRemoveRouteBuild;
; 2360 : 		directive.m_eResource = NO_RESOURCE;
; 2361 : 		directive.m_sX = pPlot->getX();
; 2362 : 		directive.m_sY = pPlot->getY();
; 2363 : 		directive.m_sMoveTurnsAway = iMoveTurnsAway;
; 2364 : 
; 2365 : 		m_aDirectives.push_back(directive, iWeight);
; 2366 : 	}
; 2367 : 
; 2368 : }

	pop	ecx
	ret	12					; 0000000cH
?AddRemoveUselessRoadDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ENDP ; CvBuilderTaskingAI::AddRemoveUselessRoadDirectives
_TEXT	ENDS
PUBLIC	?AddScrubFalloutDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddScrubFalloutDirectives
; Function compile flags: /Ogtpy
;	COMDAT ?AddScrubFalloutDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
_TEXT	SEGMENT
_directive$218855 = -20					; size = 20
_iBuildTimeWeight$218854 = 8				; size = 4
_pUnit$ = 8						; size = 4
_pPlot$ = 12						; size = 4
_iMoveTurnsAway$ = 16					; size = 4
?AddScrubFalloutDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z PROC ; CvBuilderTaskingAI::AddScrubFalloutDirectives, COMDAT
; _this$ = ecx

; 2372 : {

	sub	esp, 20					; 00000014H
	push	esi
	mov	esi, ecx

; 2373 : 	if(m_eFalloutFeature == NO_FEATURE || m_eFalloutRemove == NO_BUILD)

	or	eax, -1
	cmp	DWORD PTR [esi+58452], eax
	je	$LN3@AddScrubFa
	cmp	DWORD PTR [esi+58456], eax
	je	$LN3@AddScrubFa
	push	edi

; 2374 : 	{
; 2375 : 		return;
; 2376 : 	}
; 2377 : 
; 2378 : 	CvCity* pCity = GetWorkingCity(pPlot);

	mov	edi, DWORD PTR _pPlot$[esp+24]
	push	edi
	call	?GetWorkingCity@CvBuilderTaskingAI@@QAEPAVCvCity@@PAVCvPlot@@@Z ; CvBuilderTaskingAI::GetWorkingCity

; 2379 : 	if(!pCity)

	test	eax, eax
	je	$LN17@AddScrubFa

; 2380 : 	{
; 2381 : 		return;
; 2382 : 	}
; 2383 : 
; 2384 : 	if(pPlot->getFeatureType() == m_eFalloutFeature && pUnit->canBuild(pPlot, m_eFalloutRemove))

	movsx	eax, BYTE PTR [edi+432]
	cmp	eax, DWORD PTR [esi+58452]
	jne	$LN17@AddScrubFa
	mov	ecx, DWORD PTR [esi+58456]
	push	1
	push	0
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[esp+36]
	push	edi
	call	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z ; CvUnit::canBuild
	test	al, al
	je	$LN17@AddScrubFa

; 2385 : 	{
; 2386 : 		int iWeight = GC.getBUILDER_TASKING_BASELINE_SCRUB_FALLOUT();
; 2387 : 		//int iTurnsAway = FindTurnsAway(pUnit, pPlot);
; 2388 : 		iWeight = iWeight / (iMoveTurnsAway/*iTurnsAway*/ + 1);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2156
	push	ebx
	mov	ebx, DWORD PTR _iMoveTurnsAway$[esp+28]
	cdq
	lea	ecx, DWORD PTR [ebx+1]
	idiv	ecx

; 2389 : #ifdef AUI_WORKER_FIX_FALLOUT
; 2390 : 		// For scrubbing fallout, build times and build costs should be ignored because... well, it's fallout
; 2391 : 		// Max values returned from BuildCostWeight and BuildTimeWeight
; 2392 : 		iWeight *= 100;
; 2393 : 		iWeight += 10000 / (iMoveTurnsAway/*iTurnsAway*/ + 1);
; 2394 : #else
; 2395 : 		iWeight = GetBuildCostWeight(iWeight, pPlot, m_eFalloutRemove);

	mov	edx, DWORD PTR [esi+58456]
	push	ebp
	push	edx
	push	edi
	mov	ecx, esi
	push	eax
	call	?GetBuildCostWeight@CvBuilderTaskingAI@@QAEHHPAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::GetBuildCostWeight

; 2396 : 		int iBuildTimeWeight = GetBuildTimeWeight(pUnit, pPlot, m_eFalloutRemove, false, iMoveTurnsAway);

	mov	ecx, DWORD PTR _pUnit$[esp+32]
	push	ebx
	push	0
	mov	ebp, eax
	mov	eax, DWORD PTR [esi+58456]
	push	eax
	push	edi
	push	ecx
	mov	ecx, esi
	call	?GetBuildTimeWeight@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@_NH@Z ; CvBuilderTaskingAI::GetBuildTimeWeight

; 2397 : 		iWeight += iBuildTimeWeight;
; 2398 : #endif
; 2399 : 
; 2400 : 		BuilderDirective directive;

	lea	ecx, DWORD PTR _directive$218855[esp+36]
	mov	DWORD PTR _iBuildTimeWeight$218854[esp+32], eax
	call	??0BuilderDirective@@QAE@XZ		; BuilderDirective::BuilderDirective

; 2401 : 		directive.m_eDirective = BuilderDirective::CHOP;
; 2402 : 		directive.m_eBuild = m_eFalloutRemove;

	mov	edx, DWORD PTR [esi+58456]

; 2403 : 		directive.m_eResource = NO_RESOURCE;
; 2404 : 		directive.m_sX = pPlot->getX();

	mov	ax, WORD PTR [edi]

; 2405 : 		directive.m_sY = pPlot->getY();

	mov	cx, WORD PTR [edi+2]
	mov	DWORD PTR _directive$218855[esp+40], edx
	mov	edx, DWORD PTR _iBuildTimeWeight$218854[esp+32]
	add	edx, ebp
	mov	WORD PTR _directive$218855[esp+48], ax

; 2406 : 		directive.m_sMoveTurnsAway = iMoveTurnsAway;
; 2407 : 		m_aDirectives.push_back(directive, iWeight);

	push	edx
	lea	eax, DWORD PTR _directive$218855[esp+40]
	mov	WORD PTR _directive$218855[esp+54], cx
	push	eax
	mov	ecx, OFFSET ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A ; CvBuilderTaskingAI::m_aDirectives
	mov	DWORD PTR _directive$218855[esp+44], 4
	mov	DWORD PTR _directive$218855[esp+52], -1
	mov	WORD PTR _directive$218855[esp+60], bx
	call	?push_back@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEIABUBuilderDirective@@H@Z ; CvWeightedVector<BuilderDirective,100,1>::push_back
	pop	ebp
	pop	ebx
$LN17@AddScrubFa:
	pop	edi
$LN3@AddScrubFa:
	pop	esi

; 2408 : 	}
; 2409 : }

	add	esp, 20					; 00000014H
	ret	12					; 0000000cH
?AddScrubFalloutDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ENDP ; CvBuilderTaskingAI::AddScrubFalloutDirectives
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T226743 = -24						; size = 4
$T226748 = -20						; size = 20
$T226746 = -20						; size = 20
$T226744 = -20						; size = 20
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T226745 = 40						; size = 4
__Count$ = 40						; size = 4
___formal$ = 44						; size = 1
??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,int>, COMDAT

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Count$[esp+32]
	lea	ecx, DWORD PTR [eax+eax]
	xor	ebx, ebx
	cmp	ecx, esi
	push	edi
	jg	SHORT $LN3@Chunked_me@2
	lea	edi, DWORD PTR [eax+eax*2]
	add	edi, edi
	add	edi, edi
	add	edi, edi
$LL5@Chunked_me@2:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	lea	ecx, DWORD PTR [edi+edx]
	mov	DWORD PTR $T226743[esp+60], esp
	lea	esi, DWORD PTR [edi+ecx]
	push	esi
	push	ecx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ebp, DWORD PTR __Dest$[esp+80]
	push	ecx
	mov	DWORD PTR [eax+16], ebp
	push	edx
	lea	eax, DWORD PTR $T226744[esp+76]
	push	eax
	call	??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V12@@Z ; stdext::unchecked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T226744[esp+80]
	add	esp, 40					; 00000028H
	mov	DWORD PTR __Dest$[esp+52], ecx
	cmp	eax, ebx
	je	SHORT $LN41@Chunked_me@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Chunked_me@2:
	mov	eax, DWORD PTR __Chunk$[esp+36]

; 3297 : 		_First = _Mid2;

	mov	edx, esi
	mov	esi, DWORD PTR __Count$[esp+36]
	lea	ecx, DWORD PTR [eax+eax]
	sub	esi, ecx
	cmp	esi, ecx
	mov	DWORD PTR __Count$[esp+36], esi
	jge	SHORT $LL5@Chunked_me@2
$LN3@Chunked_me@2:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)
; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	cmp	esi, eax
	mov	DWORD PTR $T226745[esp+56], esp
	jg	SHORT $LN2@Chunked_me@2
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __Last$[esp+56]
	push	eax
	push	edx
	lea	ecx, DWORD PTR $T226746[esp+68]
	push	ecx
	call	??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
	add	esp, 32					; 00000020H

; 3302 : 	else

	jmp	SHORT $LN99@Chunked_me@2
$LN2@Chunked_me@2:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);

	lea	eax, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [edx+eax*8]

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	esi, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], esi
	mov	eax, DWORD PTR __Last$[esp+56]
	push	eax
	push	ecx
	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T226748[esp+76]
	push	ecx
	call	??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V12@@Z ; stdext::unchecked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
	add	esp, 40					; 00000028H
$LN99@Chunked_me@2:
	mov	eax, DWORD PTR $T226748[esp+40]
	cmp	eax, ebx
	je	SHORT $LN75@Chunked_me@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN75@Chunked_me@2:

; 3308 : 		}
; 3309 : 	}

	mov	eax, DWORD PTR __Dest$[esp+36]
	cmp	eax, ebx
	je	SHORT $LN85@Chunked_me@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN85@Chunked_me@2:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,int>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@HH@Z
_TEXT	SEGMENT
$T226930 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T226931 = 40						; size = 4
__Count$ = 40						; size = 4
??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	push	ebx
	xor	ebx, ebx
	mov	BYTE PTR $T226930[esp+8], bl
	mov	eax, DWORD PTR $T226930[esp+8]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+16]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR $T226931[esp+36], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+36]
	push	edx
	push	eax
	call	??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,int>

; 5254 : 	}

	mov	eax, DWORD PTR __Dest$[esp+44]
	add	esp, 40					; 00000028H
	cmp	eax, ebx
	je	SHORT $LN17@Unchecked_
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@Unchecked_:
	pop	ebx
	pop	ecx
	ret	0
??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,int>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Buffered_merge_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z
_TEXT	SEGMENT
$T227077 = -8						; size = 1
$T227048 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T227047 = 16						; size = 1
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Buffered_merge_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z PROC ; std::_Buffered_merge_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 3356 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3357 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp+20]
	xor	ebx, ebx
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN4@Buffered_m@2
	mov	ebp, edi
	shr	ebp, 5
	npad	5
$LL6@Buffered_m@2:

; 3358 : 		{	// sort chunks
; 3359 : 		_BidIt _Midend = _Mid;
; 3360 : 		std::advance(_Midend, (int)_ISORT_MAX);

	lea	esi, DWORD PTR [eax+768]

; 3361 : 
; 3362 : 		std::_Insertion_sort(_Mid, _Midend);

	push	ebx
	push	esi
	push	eax
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 12					; 0000000cH
	sub	ebp, 1

; 3363 : 		_Mid = _Midend;

	mov	eax, esi
	jne	SHORT $LL6@Buffered_m@2
$LN4@Buffered_m@2:

; 3364 : 		}
; 3365 : 	std::_Insertion_sort(_Mid, _Last);	// sort partial last chunk

	mov	ecx, DWORD PTR __Last$[esp+20]
	push	ebx
	push	ecx
	push	eax
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>

; 3366 : 
; 3367 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	esi, 32					; 00000020H
	add	esp, 12					; 0000000cH
	cmp	edi, esi
	jle	SHORT $LN1@Buffered_m@2
	mov	ebp, DWORD PTR __Tempbuf$[esp+20]
$LL3@Buffered_m@2:

; 3368 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3369 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3370 : 			_Chunk, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+20]
	mov	BYTE PTR $T227047[esp+20], bl
	mov	eax, DWORD PTR $T227047[esp+20]
	push	eax
	push	edi
	push	esi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR __Last$[esp+52]
	mov	DWORD PTR $T227048[esp+56], esp
	push	ecx
	push	edx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	call	??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,int>

; 3371 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3372 : 			_Chunk *= 2, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+60]
	mov	BYTE PTR $T227077[esp+64], bl
	mov	ecx, DWORD PTR $T227077[esp+64]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	add	esi, esi
	push	esi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>
	add	esi, esi
	add	esp, 64					; 00000040H
	cmp	esi, edi
	jl	SHORT $LL3@Buffered_m@2
$LN1@Buffered_m@2:

; 3373 : 		}
; 3374 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Buffered_merge_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ENDP ; std::_Buffered_merge_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z PROC ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 3381 : 	{	//  sort preserving order of equivalents, using operator<

	push	edi

; 3382 : 	if (_Count <= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp]
	cmp	edi, 32					; 00000020H
	jg	SHORT $LN4@Stable_sor

; 3383 : 		std::_Insertion_sort(_First, _Last);	// small

	mov	eax, DWORD PTR __Last$[esp]
	mov	ecx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 12					; 0000000cH
	pop	edi

; 3403 : 		}
; 3404 : 	}

	ret	0
$LN4@Stable_sor:
	push	ebx

; 3384 : 	else
; 3385 : 		{	// sort halves and merge
; 3386 : 		_Diff _Count2 = (_Count + 1) / 2;

	lea	eax, DWORD PTR [edi+1]
	cdq
	push	ebp

; 3387 : 		_BidIt _Mid = _First;
; 3388 : 		std::advance(_Mid, _Count2);
; 3389 : 
; 3390 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Tempbuf$[esp+8]
	sub	eax, edx
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR __First$[esp+12]
	sar	esi, 1
	lea	edx, DWORD PTR [esi+esi*2]
	mov	ecx, ebp
	lea	ebx, DWORD PTR [eax+edx*8]
	call	?_Maxlen@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEHXZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Maxlen
	cmp	esi, eax

; 3391 : 			{	// temp buffer big enough, sort each half using buffer
; 3392 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);

	push	ebp
	push	esi
	push	ebx
	jg	SHORT $LN2@Stable_sor
	mov	ecx, DWORD PTR __First$[esp+24]
	push	ecx
	call	??$_Buffered_merge_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Buffered_merge_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>

; 3393 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	edx, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	edi, esi
	push	edi
	push	edx
	push	ebx
	call	??$_Buffered_merge_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Buffered_merge_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>

; 3394 : 			}
; 3395 : 		else

	jmp	SHORT $LN17@Stable_sor
$LN2@Stable_sor:

; 3396 : 			{	// temp buffer not big enough, divide and conquer
; 3397 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	eax, DWORD PTR __First$[esp+24]
	push	eax
	call	??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>

; 3398 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	edi, esi
	push	edi
	push	ecx
	push	ebx
	call	??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
$LN17@Stable_sor:

; 3399 : 			}
; 3400 : 
; 3401 : 		_Buffered_merge(_First, _Mid, _Last,
; 3402 : 			_Count2, _Count - _Count2, _Tempbuf);	// merge sorted halves

	mov	edx, DWORD PTR __Last$[esp+44]
	mov	eax, DWORD PTR __First$[esp+44]
	add	esp, 32					; 00000020H
	push	ebp
	push	edi
	push	esi
	push	edx
	push	ebx
	push	eax
	call	??$_Buffered_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Buffered_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 24					; 00000018H
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 3403 : 		}
; 3404 : 	}

	ret	0
??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ENDP ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z$0
__ehfuncinfo$??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z PROC ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 3410 : 	{	// sort preserving order of equivalents, using operator<

	push	-1
	push	__ehhandler$??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 3411 : 	_Diff _Count = 0;
; 3412 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp+36]
	push	edi
	mov	edi, DWORD PTR __First$[esp+40]
	mov	ecx, esi
	sub	ecx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 3413 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	lea	eax, DWORD PTR [ecx+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	ebx, ebx
	mov	DWORD PTR __Tempbuf$[esp+56], eax
	lea	eax, DWORD PTR __Tempbuf$[esp+44]
	mov	DWORD PTR __Tempbuf$[esp+44], ebx
	mov	DWORD PTR __Tempbuf$[esp+48], ebx
	mov	DWORD PTR __Tempbuf$[esp+52], ebx
	mov	DWORD PTR __Tempbuf$[esp+60], eax

; 3414 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf);

	mov	edx, eax
	push	edx
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[esp+68], ebx
	call	??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>

; 3415 : 	}

	mov	eax, DWORD PTR __Tempbuf$[esp+60]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN20@Stable_sor@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN20@Stable_sor@2:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@XZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::~_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
__ehhandler$??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z ENDP ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
PUBLIC	??$stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z ; std::stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z PROC ; std::stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>, COMDAT

; 3420 : 	_DEBUG_RANGE(_First, _Last);
; 3421 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@stable_sor

; 3422 : 		{
; 3423 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN1@stable_sor:

; 3424 : 		}
; 3425 : 	}

	ret	0
??$stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0@Z ENDP ; std::stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?StableSortItems@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEXXZ ; CvWeightedVector<BuilderDirective,100,1>::StableSortItems
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?StableSortItems@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEXXZ
_TEXT	SEGMENT
?StableSortItems@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEXXZ PROC ; CvWeightedVector<BuilderDirective,100,1>::StableSortItems, COMDAT
; _this$ = ecx

; 145  : 		std::stable_sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [eax+ecx*8]
	cmp	eax, ecx
	je	SHORT $LN7@StableSort
	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN7@StableSort:

; 146  : 	}

	ret	0
?StableSortItems@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEXXZ ENDP ; CvWeightedVector<BuilderDirective,100,1>::StableSortItems
_TEXT	ENDS
PUBLIC	?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z ; CvBuilderTaskingAI::EvaluateBuilder
EXTRN	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z:PROC ; TurnsToReachTarget
EXTRN	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ:PROC ; CvPlayer::GetPlots
EXTRN	?GetPlotIndex@CvPlot@@QBEHXZ:PROC		; CvPlot::GetPlotIndex
EXTRN	?getBuildType@CvUnit@@QBE?AW4BuildTypes@@XZ:PROC ; CvUnit::getBuildType
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z$6
__ehfuncinfo$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z
_TEXT	SEGMENT
tv1512 = -88						; size = 4
_iAssignIndex$ = -84					; size = 4
_iBestWeight$ = -80					; size = 4
_i$218496 = -76						; size = 4
$T227208 = -76						; size = 4
$T227207 = -76						; size = 4
$T227206 = -76						; size = 4
_this$ = -72						; size = 4
_elem$227772 = -68					; size = 24
_elem$227751 = -68					; size = 24
_strLog$218487 = -68					; size = 28
_strLog$218471 = -68					; size = 28
_strLog$218463 = -68					; size = 28
_strLog$218491 = -40					; size = 28
__$EHRec$ = -12						; size = 12
tv1424 = 8						; size = 4
_ui$218475 = 8						; size = 4
$T227205 = 8						; size = 4
_uiPlotIndex$218457 = 8					; size = 4
_pUnit$ = 8						; size = 4
_paDirectives$ = 12					; size = 4
_uaDirectives$ = 16					; size = 4
_bOnlyKeepBest$ = 20					; size = 1
$T227727 = 24						; size = 4
$T227209 = 24						; size = 4
_bOnlyEvaluateWorkersPlot$ = 24				; size = 1
?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z PROC ; CvBuilderTaskingAI::EvaluateBuilder, COMDAT
; _this$ = ecx

; 741  : {

	push	-1
	push	__ehhandler$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	ebp
	mov	ebx, ecx

; 742  : 	// number of cities has changed mid-turn, so we need to re-evaluate what workers should do
; 743  : 	if(m_pPlayer->getNumCities() != m_iNumCities)

	mov	ecx, DWORD PTR [ebx]
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+104], ebx
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, DWORD PTR [ebx+58396]
	je	SHORT $LN40@EvaluateBu

; 744  : 	{
; 745  : 		Update();

	mov	ecx, ebx
	call	?Update@CvBuilderTaskingAI@@QAEXXZ	; CvBuilderTaskingAI::Update
$LN40@EvaluateBu:

; 746  : 	}
; 747  : 
; 748  : 	CvAssertMsg(uaDirectives > 0, "Need more than one directive");
; 749  : 
; 750  : 	for(uint ui = 0; ui < uaDirectives; ui++)

	mov	ecx, DWORD PTR _uaDirectives$[esp+100]
	mov	esi, DWORD PTR _paDirectives$[esp+100]
	xor	ebp, ebp
	cmp	ecx, ebp
	jbe	SHORT $LN37@EvaluateBu
	mov	eax, esi
	npad	8
$LL39@EvaluateBu:

; 751  : 	{
; 752  : 		paDirectives[ui].m_eDirective = BuilderDirective::NUM_DIRECTIVES;

	mov	DWORD PTR [eax], 6
	add	eax, 20					; 00000014H
	sub	ecx, 1
	jne	SHORT $LL39@EvaluateBu
$LN37@EvaluateBu:

; 753  : 	}
; 754  : 
; 755  : 	m_aDirectives.clear();
; 756  : 
; 757  : 	// check for no brainer bail-outs
; 758  : 	// if the builder is already building something
; 759  : #ifdef AUI_WORKER_EVALUATE_WORKER_RETREAT_AND_BUILD
; 760  : #ifdef AUI_DANGER_PLOTS_REMADE
; 761  : 	if (pUnit->getBuildType() != NO_BUILD && pUnit->GetCurrHitPoints() > m_pPlayer->GetPlotDanger(*pUnit->plot(), pUnit))
; 762  : #elif defined(AUI_WORKER_SHOULD_BUILDER_CONSIDER_PLOT_MAXIMUM_DANGER_BASED_ON_UNIT_STRENGTH)
; 763  : 	if (pUnit->getBuildType() != NO_BUILD && 
; 764  : 		((pUnit->IsCombatUnit() && pUnit->GetBaseCombatStrengthConsideringDamage() * AUI_WORKER_SHOULD_BUILDER_CONSIDER_PLOT_MAXIMUM_DANGER_BASED_ON_UNIT_STRENGTH > m_pPlayer->GetPlotDanger(*pUnit->plot())) ||
; 765  : 		(!pUnit->IsCombatUnit() && !m_pPlayer->IsPlotUnderImmediateThreat(*pUnit->plot()))))
; 766  : #else
; 767  : 	if (pUnit->getBuildType() != NO_BUILD && !m_pPlayer->IsPlotUnderImmediateThreat(*pUnit->plot())))
; 768  : #endif
; 769  : #else
; 770  : 	if(pUnit->getBuildType() != NO_BUILD)

	mov	edi, DWORD PTR _pUnit$[esp+100]
	mov	ecx, edi
	mov	DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A+4, ebp
	call	?getBuildType@CvUnit@@QBE?AW4BuildTypes@@XZ ; CvUnit::getBuildType
	cmp	eax, -1
	je	SHORT $LN36@EvaluateBu

; 771  : #endif
; 772  : 	{
; 773  : 		paDirectives[0].m_eDirective = BuilderDirective::BUILD_IMPROVEMENT;
; 774  : 		paDirectives[0].m_eBuild = pUnit->getBuildType();

	mov	ecx, edi
	mov	DWORD PTR [esi], 1
	call	?getBuildType@CvUnit@@QBE?AW4BuildTypes@@XZ ; CvUnit::getBuildType
	mov	DWORD PTR [esi+4], eax

; 775  : 		paDirectives[0].m_sX = pUnit->getX();

	mov	ax, WORD PTR [edi+76]
	mov	WORD PTR [esi+12], ax

; 776  : 		paDirectives[0].m_sY = pUnit->getY();

	mov	cx, WORD PTR [edi+88]

; 777  : 		//inDirective.m_sGoldCost = 0;
; 778  : 		paDirectives[0].m_sMoveTurnsAway = 0;

	xor	edx, edx
	mov	WORD PTR [esi+14], cx
	mov	WORD PTR [esi+16], dx

; 779  : 		return true;

	mov	al, 1

; 1000 : 	}
; 1001 : 
; 1002 : 	return false;
; 1003 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+104]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 88					; 00000058H
	ret	20					; 00000014H
$LN36@EvaluateBu:

; 780  : 	}
; 781  : 
; 782  : 	m_aiPlots.clear();
; 783  : 	if(bOnlyEvaluateWorkersPlot)

	cmp	BYTE PTR _bOnlyEvaluateWorkersPlot$[esp+100], 0
	lea	esi, DWORD PTR [ebx+8]
	mov	DWORD PTR [esi+4], ebp
	je	SHORT $LN35@EvaluateBu

; 784  : 	{
; 785  : 		// can't build on plots others own
; 786  : 		PlayerTypes eOwner = pUnit->plot()->getOwner();

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	eax, BYTE PTR [eax+4]

; 787  : 		if(eOwner == m_pPlayer->GetID())

	mov	ecx, DWORD PTR [ebx]
	cmp	eax, DWORD PTR [ecx+44]
	jne	SHORT $LN33@EvaluateBu

; 788  : 		{
; 789  : 			m_aiPlots.push_back(pUnit->plot()->GetPlotIndex());

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	ebp, eax
	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+58380], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN84@EvaluateBu
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,14592,1,297,0>::GrowSize
$LN84@EvaluateBu:
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edx*4]
	test	eax, eax
	je	SHORT $LN87@EvaluateBu
	mov	DWORD PTR [eax], ebp
$LN87@EvaluateBu:
	inc	DWORD PTR [esi+4]

; 790  : 		}
; 791  : 	}
; 792  : 	else

	jmp	SHORT $LN33@EvaluateBu
$LN35@EvaluateBu:

; 793  : 	{
; 794  : 		m_aiPlots = m_pPlayer->GetPlots();

	mov	ecx, DWORD PTR [ebx]
	call	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ ; CvPlayer::GetPlots
	push	eax
	mov	ecx, esi
	call	??4?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<int,14592,1,297,0>::operator=
$LN33@EvaluateBu:

; 795  : 	}
; 796  : 
; 797  : #ifdef AUI_WORKER_ADD_IMPROVING_MINOR_PLOTS_DIRECTIVES
; 798  : 	for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 799  : 	{
; 800  : 		CvBuildInfo* pkBuild = GC.getBuildInfo((BuildTypes)iBuildIndex);
; 801  : 		if (pkBuild)
; 802  : 		{
; 803  : 			ImprovementTypes eImprovement = (ImprovementTypes)pkBuild->getImprovement();
; 804  : 			if (eImprovement != NO_IMPROVEMENT)
; 805  : 			{
; 806  : 				CvImprovementEntry* pkImprovement = GC.getImprovementInfo(eImprovement);
; 807  : 				if (pkImprovement && pkImprovement->IsOnlyCityStateTerritory() && (!pkImprovement->IsSpecificCivRequired() || pkImprovement->GetRequiredCivilization() == m_pPlayer->getCivilizationType()))
; 808  : 				{
; 809  : 					for (int iJ = 0; iJ < MAX_CIV_PLAYERS; iJ++)
; 810  : 					{
; 811  : 						CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iJ);
; 812  : 						if (kLoopPlayer.isAlive() && kLoopPlayer.isMinorCiv() && !GET_TEAM(m_pPlayer->getTeam()).isAtWar(kLoopPlayer.getTeam()))
; 813  : 						{
; 814  : 							m_aiPlots.push_back(kLoopPlayer.GetPlots().begin(), kLoopPlayer.GetPlots().size());
; 815  : 						}
; 816  : 					}
; 817  : 					break;
; 818  : 				}
; 819  : 			}
; 820  : 		}
; 821  : 	}
; 822  : #endif
; 823  : 
; 824  : 	// go through all the plots the player has under their control
; 825  : 	for(uint uiPlotIndex = 0; uiPlotIndex < m_aiPlots.size(); uiPlotIndex++)

	mov	eax, DWORD PTR [ebx+12]
	xor	ecx, ecx
	mov	DWORD PTR _uiPlotIndex$218457[esp+100], ecx
	test	eax, eax
	jbe	$LN28@EvaluateBu
$LN32@EvaluateBu:

; 826  : 	{
; 827  : 		// when we encounter the first plot that is invalid, the rest of the list will be invalid
; 828  : 		if(m_aiPlots[uiPlotIndex] == -1)

	mov	edx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [edx+ecx*4]
	cmp	esi, -1
	je	$LN311@EvaluateBu

; 835  : 			break;
; 836  : 		}
; 837  : 
; 838  : 		CvPlot* pPlot = GC.getMap().plotByIndex(m_aiPlots[uiPlotIndex]);

	test	esi, esi
	jl	SHORT $LN112@EvaluateBu
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	esi, DWORD PTR [eax+4028]
	jge	SHORT $LN112@EvaluateBu
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [eax+4068]
	jmp	SHORT $LN113@EvaluateBu
$LN112@EvaluateBu:
	xor	esi, esi
$LN113@EvaluateBu:

; 839  : 
; 840  : 		if(!ShouldBuilderConsiderPlot(pUnit, pPlot))

	push	esi
	push	edi
	mov	ecx, ebx
	call	?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z ; CvBuilderTaskingAI::ShouldBuilderConsiderPlot
	test	al, al
	je	$LN31@EvaluateBu

; 841  : 		{
; 842  : 			continue;
; 843  : 		}
; 844  : 
; 845  : 		// distance weight
; 846  : 		// find how many turns the plot is away
; 847  : 		int iMoveTurnsAway = FindTurnsAway(pUnit, pPlot);

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN116@EvaluateBu
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, esi
	mov	ebp, eax
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	cmp	ebp, eax
	je	SHORT $LN116@EvaluateBu
	mov	ecx, edi
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	test	al, al
	je	SHORT $LN318@EvaluateBu
$LN116@EvaluateBu:
	movsx	edx, WORD PTR [esi+2]
	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	push	edx
	movsx	edx, WORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	mov	ebp, eax
	add	esp, 16					; 00000010H

; 848  : 		if(iMoveTurnsAway < 0)

	test	ebp, ebp
	jge	SHORT $LN26@EvaluateBu
$LN318@EvaluateBu:

; 849  : 		{
; 850  : 			if(m_bLogging)

	cmp	BYTE PTR [ebx+58392], 0
	je	$LN31@EvaluateBu

; 851  : 			{
; 852  : 				CvString strLog;

	lea	ecx, DWORD PTR _strLog$218471[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 853  : 				strLog.Format("unitx: %d unity: %d, plotx: %d ploty: %d, can't find path", pUnit->getX(), pUnit->getY(), pPlot->getX(), pPlot->getY());

	movsx	edx, WORD PTR [esi+2]
	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	push	edx
	movsx	edx, WORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	lea	eax, DWORD PTR _strLog$218471[esp+120]
	push	OFFSET $SG218472
	push	eax
	mov	DWORD PTR __$EHRec$[esp+136], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 854  : 				LogInfo(strLog, m_pPlayer);

	mov	ecx, DWORD PTR [ebx]
	add	esp, 24					; 00000018H
	push	0
	push	ecx
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strLog$218471[esp+140]
	mov	DWORD PTR $T227206[esp+140], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 855  : 			}

	lea	ecx, DWORD PTR _strLog$218471[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 856  : 
; 857  : 			continue;

	jmp	SHORT $LN31@EvaluateBu
$LN26@EvaluateBu:

; 858  : 		}
; 859  : 
; 860  : #ifdef AUI_WORKER_ADD_IMPROVING_MINOR_PLOTS_DIRECTIVES
; 861  : 		if (pPlot->getOwner() != m_pPlayer->GetID())
; 862  : 			AddImprovingMinorPlotsDirectives(pUnit, pPlot, iMoveTurnsAway);
; 863  : 		else
; 864  : 		{
; 865  : #endif
; 866  : 		UpdateCurrentPlotYields(pPlot);

	push	esi
	mov	ecx, ebx
	call	?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z ; CvBuilderTaskingAI::UpdateCurrentPlotYields

; 867  : 
; 868  : 		//AddRepairDirectives(pUnit, pPlot, iMoveTurnsAway);
; 869  : 		AddRouteDirectives(pUnit, pPlot, iMoveTurnsAway);

	push	ebp
	push	esi
	push	edi
	mov	ecx, ebx
	call	?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddRouteDirectives

; 870  : 		AddImprovingResourcesDirectives(pUnit, pPlot, iMoveTurnsAway);

	push	ebp
	push	esi
	push	edi
	mov	ecx, ebx
	call	?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddImprovingResourcesDirectives

; 871  : 		AddImprovingPlotsDirectives(pUnit, pPlot, iMoveTurnsAway);

	push	ebp
	push	esi
	push	edi
	mov	ecx, ebx
	call	?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddImprovingPlotsDirectives

; 872  : 		AddChopDirectives(pUnit, pPlot, iMoveTurnsAway);

	push	ebp
	push	esi
	push	edi
	mov	ecx, ebx
	call	?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddChopDirectives

; 873  : 		AddScrubFalloutDirectives(pUnit, pPlot, iMoveTurnsAway);

	push	ebp
	push	esi
	push	edi
	mov	ecx, ebx
	call	?AddScrubFalloutDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddScrubFalloutDirectives

; 874  : 		// only AIs have permission to remove roads
; 875  : 		if(!m_pPlayer->isHuman())

	mov	ecx, DWORD PTR [ebx]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
$LN31@EvaluateBu:
	mov	ecx, DWORD PTR _uiPlotIndex$218457[esp+100]
	inc	ecx
	mov	DWORD PTR _uiPlotIndex$218457[esp+100], ecx
	cmp	ecx, DWORD PTR [ebx+12]
	jb	$LN32@EvaluateBu

; 974  : 
; 975  : 		// if we shouldn't copy over any more directives, then break
; 976  : 		if(iAssignIndex >= (int)uaDirectives)

	jmp	SHORT $LN28@EvaluateBu
$LN311@EvaluateBu:

; 829  : 		{
; 830  : 			if(m_bLogging)

	cmp	BYTE PTR [ebx+58392], 0
	je	SHORT $LN28@EvaluateBu

; 831  : 			{
; 832  : 				CvString strLog = "end of plot list";

	push	OFFSET $SG218464
	lea	ecx, DWORD PTR _strLog$218463[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 833  : 				LogInfo(strLog, m_pPlayer);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	eax
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strLog$218463[esp+140]
	mov	DWORD PTR $T227205[esp+136], esp
	mov	ecx, esp
	push	edx
	mov	DWORD PTR __$EHRec$[esp+152], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 834  : 			}

	lea	ecx, DWORD PTR _strLog$218463[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN28@EvaluateBu:

; 876  : 		{
; 877  : 			//AddRemoveUselessRoadDirectives(pUnit, pPlot, iMoveTurnsAway);
; 878  : 		}
; 879  : #ifdef AUI_WORKER_ADD_IMPROVING_MINOR_PLOTS_DIRECTIVES
; 880  : 		}
; 881  : #endif
; 882  : 	}
; 883  : 
; 884  : 	// we need to evaluate the tiles outside of our territory to build roads
; 885  : 	for(uint ui = 0; ui < m_aiNonTerritoryPlots.size(); ui++)

	xor	eax, eax
	mov	DWORD PTR _ui$218475[esp+100], eax
	cmp	DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+4, eax
	jbe	$LN21@EvaluateBu
$LN23@EvaluateBu:

; 886  : 	{
; 887  : 		//FAssertMsg(!m_pPlayer->isMinorCiv(), "MinorCivs should have no nonterritory plots");
; 888  : 		CvPlot* pPlot = GC.getMap().plotByIndex(m_aiNonTerritoryPlots[ui]);

	mov	ecx, DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A
	mov	esi, DWORD PTR [ecx+eax*4]
	test	esi, esi
	jl	$LN22@EvaluateBu
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	esi, DWORD PTR [eax+4028]
	jge	$LN22@EvaluateBu
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [eax+4068]

; 889  : 		CvAssertMsg(pPlot != NULL, "Plot should not be NULL");
; 890  : 		if(!pPlot)

	test	esi, esi
	je	$LN22@EvaluateBu

; 891  : 			continue;
; 892  : 
; 893  : 		if(bOnlyEvaluateWorkersPlot)

	cmp	BYTE PTR _bOnlyEvaluateWorkersPlot$[esp+100], 0
	je	SHORT $LN18@EvaluateBu

; 894  : 		{
; 895  : 			if(pPlot != pUnit->plot())

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	esi, eax
	jne	$LN22@EvaluateBu
$LN18@EvaluateBu:

; 896  : 			{
; 897  : 				continue;
; 898  : 			}
; 899  : 		}
; 900  : 
; 901  : 		if(!ShouldBuilderConsiderPlot(pUnit, pPlot))

	push	esi
	push	edi
	mov	ecx, ebx
	call	?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z ; CvBuilderTaskingAI::ShouldBuilderConsiderPlot
	test	al, al
	je	$LN22@EvaluateBu

; 902  : 		{
; 903  : 			continue;
; 904  : 		}
; 905  : 
; 906  : 		// distance weight
; 907  : 		// find how many turns the plot is away
; 908  : 		int iMoveTurnsAway = FindTurnsAway(pUnit, pPlot);

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN164@EvaluateBu
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, esi
	mov	ebp, eax
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	cmp	ebp, eax
	je	SHORT $LN164@EvaluateBu
	mov	ecx, edi
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	test	al, al
	je	SHORT $LN319@EvaluateBu
$LN164@EvaluateBu:
	movsx	edx, WORD PTR [esi+2]
	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	push	edx
	movsx	edx, WORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	mov	ebp, eax
	add	esp, 16					; 00000010H

; 909  : 		if(iMoveTurnsAway < 0)

	test	ebp, ebp
	jge	SHORT $LN16@EvaluateBu
$LN319@EvaluateBu:

; 910  : 		{
; 911  : 			if(m_bLogging)

	cmp	BYTE PTR [ebx+58392], 0
	je	$LN22@EvaluateBu

; 912  : 			{
; 913  : 				CvString strLog;

	lea	ecx, DWORD PTR _strLog$218487[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 914  : 				strLog.Format("unitx: %d unity: %d, plotx: %d ploty: %d, Evaluating out of territory plot, can't find path", pUnit->getX(), pUnit->getY(), pPlot->getX(), pPlot->getY());

	movsx	edx, WORD PTR [esi+2]
	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	push	edx
	movsx	edx, WORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	lea	eax, DWORD PTR _strLog$218487[esp+120]
	push	OFFSET $SG218488
	push	eax
	mov	DWORD PTR __$EHRec$[esp+136], 2
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 915  : 				LogInfo(strLog, m_pPlayer);

	mov	ecx, DWORD PTR [ebx]
	add	esp, 24					; 00000018H
	push	0
	push	ecx
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strLog$218487[esp+140]
	mov	DWORD PTR $T227207[esp+140], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 916  : 			}

	lea	ecx, DWORD PTR _strLog$218487[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 917  : 
; 918  : 			continue;

	jmp	SHORT $LN22@EvaluateBu
$LN16@EvaluateBu:

; 919  : 		}
; 920  : 
; 921  : 		if(m_bLogging)

	cmp	BYTE PTR [ebx+58392], 0
	je	SHORT $LN14@EvaluateBu

; 922  : 		{
; 923  : 			CvString strLog;

	lea	ecx, DWORD PTR _strLog$218491[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 924  : 			strLog.Format("x: %d y: %d, Evaluating out of territory plot", pPlot->getX(), pPlot->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strLog$218491[esp+112]
	push	OFFSET $SG218492
	push	edx
	mov	DWORD PTR __$EHRec$[esp+128], 3
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 925  : 			LogInfo(strLog, m_pPlayer);

	mov	eax, DWORD PTR [ebx]
	add	esp, 16					; 00000010H
	push	0
	push	eax
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strLog$218491[esp+140]
	mov	DWORD PTR $T227208[esp+140], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 926  : 		}

	lea	ecx, DWORD PTR _strLog$218491[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN14@EvaluateBu:

; 927  : 
; 928  : 		//AddRepairDirectives(pUnit, pPlot, iMoveTurnsAway);
; 929  : 		AddRouteDirectives(pUnit, pPlot, iMoveTurnsAway);

	push	ebp
	push	esi
	push	edi
	mov	ecx, ebx
	call	?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddRouteDirectives
$LN22@EvaluateBu:
	mov	eax, DWORD PTR _ui$218475[esp+100]
	inc	eax
	mov	DWORD PTR _ui$218475[esp+100], eax
	cmp	eax, DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+4
	jb	$LN23@EvaluateBu
$LN21@EvaluateBu:

; 930  : 	}
; 931  : 
; 932  : 	m_aDirectives.StableSortItems();

	mov	eax, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A+4
	mov	edx, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [edx+ecx*8]
	xor	esi, esi
	cmp	edx, ecx
	je	SHORT $LN219@EvaluateBu
	push	esi
	push	esi
	push	ecx
	push	edx
	call	??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	mov	eax, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A+4
	add	esp, 16					; 00000010H
$LN219@EvaluateBu:

; 933  : 
; 934  : 	int iBestWeight = 0;
; 935  : 
; 936  : 	int iAssignIndex = 0;
; 937  : 	for(int i = 0; i < m_aDirectives.size(); i++)

	cmp	eax, esi
	mov	DWORD PTR _iBestWeight$[esp+104], esi
	mov	DWORD PTR _iAssignIndex$[esp+104], esi
	mov	DWORD PTR _i$218496[esp+104], esi
	jle	$LN312@EvaluateBu
	mov	ebx, DWORD PTR _paDirectives$[esp+100]
	xor	esi, esi
	mov	DWORD PTR tv1512[esp+104], ebx
	npad	10
$LL13@EvaluateBu:

; 938  : 	{
; 939  : 		// If this target was far away, we only estimated the time to get there.  We need to be sure we have a real path there
; 940  : 		CvPlot* pTarget = GC.getMap().plot(m_aDirectives.GetElement(i).m_sX, m_aDirectives.GetElement(i).m_sY);

	mov	eax, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A
	movsx	edx, WORD PTR [esi+eax+14]
	movsx	eax, WORD PTR [esi+eax+12]
	mov	DWORD PTR $T227727[esp+100], edx
	cmp	eax, -2147483647			; 80000001H
	je	$LN12@EvaluateBu
	cmp	edx, -2147483647			; 80000001H
	je	$LN12@EvaluateBu
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	dl, dl
	je	SHORT $LN250@EvaluateBu
	test	eax, eax
	jge	SHORT $LN252@EvaluateBu
	cdq
	idiv	ecx
	mov	ebp, edx
	add	ebp, ecx
	jmp	SHORT $LN254@EvaluateBu
$LN252@EvaluateBu:
	cmp	eax, ecx
	jl	SHORT $LN250@EvaluateBu
	cdq
	idiv	ecx
	mov	ebp, edx
	jmp	SHORT $LN254@EvaluateBu
$LN250@EvaluateBu:
	mov	ebp, eax
$LN254@EvaluateBu:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	edx, DWORD PTR [edx+4024]
	mov	DWORD PTR tv1424[esp+100], edx
	test	al, al
	je	SHORT $LN260@EvaluateBu
	mov	eax, DWORD PTR $T227727[esp+100]
	test	eax, eax
	jge	SHORT $LN262@EvaluateBu
	mov	ebx, DWORD PTR tv1424[esp+100]
	cdq
	idiv	ebx
	add	edx, ebx
	mov	ebx, DWORD PTR tv1512[esp+104]
	jmp	SHORT $LN264@EvaluateBu
$LN262@EvaluateBu:
	cmp	eax, edx
	jl	SHORT $LN260@EvaluateBu
	mov	eax, DWORD PTR $T227727[esp+100]
	mov	ebx, DWORD PTR tv1512[esp+104]
	cdq
	idiv	DWORD PTR tv1424[esp+100]
	jmp	SHORT $LN264@EvaluateBu
$LN260@EvaluateBu:
	mov	edx, DWORD PTR $T227727[esp+100]
$LN264@EvaluateBu:
	test	ebp, ebp
	jl	$LN12@EvaluateBu
	cmp	ebp, ecx
	jge	$LN12@EvaluateBu
	test	edx, edx
	jl	$LN12@EvaluateBu
	cmp	edx, DWORD PTR tv1424[esp+100]
	jge	$LN12@EvaluateBu
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, ebp
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]

; 941  : 		CvAssertMsg(pTarget != NULL, "Not expecting the target to be NULL");
; 942  : 		if(!pTarget)

	test	ecx, ecx
	je	$LN12@EvaluateBu

; 943  : 			continue;
; 944  : 
; 945  : #if 0	// KWG: We are now always doing a raw estimate when gathering the directives
; 946  : 		int iPlotDistance = plotDistance(pUnit->getX(), pUnit->getY(), pTarget->getX(), pTarget->getY());
; 947  : 		if(iPlotDistance >= GC.getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE())
; 948  : #endif
; 949  : 		{
; 950  : 			if(TurnsToReachTarget(pUnit, pTarget) == MAX_INT)

	push	0
	push	0
	push	0
	push	ecx
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T227209[esp+124], esp
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], 0
	test	edi, edi
	je	SHORT $LN281@EvaluateBu
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN281@EvaluateBu:
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	cmp	eax, 2147483647				; 7fffffffH
	je	$LN12@EvaluateBu

; 951  : 			{
; 952  : 				// No path, need to pick a new directive
; 953  : 				continue;
; 954  : 			}
; 955  : 		}
; 956  : 
; 957  : 		if(iBestWeight == 0)

	mov	eax, DWORD PTR _iBestWeight$[esp+104]
	mov	ecx, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A
	test	eax, eax
	jne	SHORT $LN8@EvaluateBu

; 958  : 		{
; 959  : 			iBestWeight = m_aDirectives.GetWeight(i);

	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [esi+ecx+4]
	mov	DWORD PTR _elem$227751[esp+104], edx
	mov	edx, DWORD PTR [esi+ecx+8]
	mov	DWORD PTR _elem$227751[esp+108], eax
	mov	eax, DWORD PTR [esi+ecx+12]
	mov	DWORD PTR _elem$227751[esp+112], edx
	mov	edx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR _elem$227751[esp+116], eax
	mov	eax, DWORD PTR [esi+ecx+20]
	mov	DWORD PTR _elem$227751[esp+120], edx
	mov	DWORD PTR _iBestWeight$[esp+104], eax
$LN8@EvaluateBu:

; 960  : 		}
; 961  : 
; 962  : 		if(bOnlyKeepBest)

	cmp	BYTE PTR _bOnlyKeepBest$[esp+100], 0
	je	SHORT $LN6@EvaluateBu

; 963  : 		{
; 964  : 			int iWeight = m_aDirectives.GetWeight(i);

	mov	edx, DWORD PTR [esi+ecx]
	mov	ebp, DWORD PTR [esi+ecx+20]
	mov	DWORD PTR _elem$227772[esp+104], edx
	mov	edx, DWORD PTR [esi+ecx+4]
	mov	DWORD PTR _elem$227772[esp+108], edx
	mov	edx, DWORD PTR [esi+ecx+8]
	mov	DWORD PTR _elem$227772[esp+112], edx
	mov	edx, DWORD PTR [esi+ecx+12]
	mov	DWORD PTR _elem$227772[esp+116], edx
	mov	edx, DWORD PTR [esi+ecx+16]

; 965  : 			if(iWeight < iBestWeight * 3 / 4)

	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _elem$227772[esp+120], edx
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	ebp, eax
	jl	SHORT $LN312@EvaluateBu
$LN6@EvaluateBu:

; 966  : 			{
; 967  : 				break;
; 968  : 			}
; 969  : 		}
; 970  : 
; 971  : 		BuilderDirective directive = m_aDirectives.GetElement(i);

	lea	eax, DWORD PTR [esi+ecx]

; 972  : 		paDirectives[iAssignIndex] = directive;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ebx], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ebx+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ebx+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ebx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ebx+16], eax

; 973  : 		iAssignIndex++;

	mov	eax, DWORD PTR _iAssignIndex$[esp+104]
	inc	eax
	add	ebx, 20					; 00000014H

; 974  : 
; 975  : 		// if we shouldn't copy over any more directives, then break
; 976  : 		if(iAssignIndex >= (int)uaDirectives)

	cmp	eax, DWORD PTR _uaDirectives$[esp+100]
	mov	DWORD PTR _iAssignIndex$[esp+104], eax
	mov	DWORD PTR tv1512[esp+104], ebx
	jge	SHORT $LN312@EvaluateBu
$LN12@EvaluateBu:

; 933  : 
; 934  : 	int iBestWeight = 0;
; 935  : 
; 936  : 	int iAssignIndex = 0;
; 937  : 	for(int i = 0; i < m_aDirectives.size(); i++)

	mov	eax, DWORD PTR _i$218496[esp+104]
	inc	eax
	add	esi, 24					; 00000018H
	cmp	eax, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A+4
	mov	DWORD PTR _i$218496[esp+104], eax
	jl	$LL13@EvaluateBu
$LN312@EvaluateBu:

; 977  : 		{
; 978  : 			break;
; 979  : 		}
; 980  : 	}
; 981  : 
; 982  : 	if(m_bLogging)

	mov	esi, DWORD PTR _this$[esp+104]
	cmp	BYTE PTR [esi+58392], 0
	je	SHORT $LN4@EvaluateBu

; 983  : 	{
; 984  : 		if(m_aDirectives.size() > 0)
; 985  : 		{
; 986  : 			//LogFlavors(NO_FLAVOR);
; 987  : 		}
; 988  : 
; 989  : 		LogDirectives(pUnit);

	push	edi
	mov	ecx, esi
	call	?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z ; CvBuilderTaskingAI::LogDirectives
$LN4@EvaluateBu:

; 990  : 	}
; 991  : 
; 992  : 	//if (m_aDirectives.size() > 0 && iAssignIndex > 0)
; 993  : 	if(iAssignIndex > 0)

	cmp	DWORD PTR _iAssignIndex$[esp+104], 0
	jle	SHORT $LN2@EvaluateBu

; 994  : 	{
; 995  : 		if(m_bLogging)

	cmp	BYTE PTR [esi+58392], 0
	je	SHORT $LN1@EvaluateBu

; 996  : 		{
; 997  : 			LogDirective(paDirectives[0], pUnit, -1, true /*bChosen*/);

	mov	ecx, DWORD PTR _paDirectives$[esp+100]
	mov	edx, DWORD PTR [ecx]
	push	1
	push	-1
	push	edi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, esi
	call	?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z ; CvBuilderTaskingAI::LogDirective
$LN1@EvaluateBu:

; 998  : 		}
; 999  : 		return true;

	mov	al, 1

; 1000 : 	}
; 1001 : 
; 1002 : 	return false;
; 1003 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+104]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 88					; 00000058H
	ret	20					; 00000014H
$LN2@EvaluateBu:
	mov	ecx, DWORD PTR __$EHRec$[esp+104]
	pop	edi
	pop	esi
	pop	ebp
	xor	al, al
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 88					; 00000058H
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z$2:
	lea	ecx, DWORD PTR _strLog$218471[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z$0:
	lea	ecx, DWORD PTR _strLog$218463[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z$4:
	lea	ecx, DWORD PTR _strLog$218487[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z$6:
	lea	ecx, DWORD PTR _strLog$218491[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z:
	mov	eax, OFFSET __ehfuncinfo$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z ENDP ; CvBuilderTaskingAI::EvaluateBuilder
PUBLIC	?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A ; CvBuilderTaskingAI::m_aDirectives
EXTRN	_atexit:PROC
_DATA	SEGMENT
?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A DD FLAT:?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A+12 ; CvBuilderTaskingAI::m_aDirectives
	DB	4 DUP(00H)
	DD	064H
; Function compile flags: /Ogtpy
_DATA	ENDS
;	COMDAT ??__E?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A@@YAXXZ
text$yc	SEGMENT
??__E?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A@@YAXXZ PROC ; `dynamic initializer for 'CvBuilderTaskingAI::m_aDirectives'', COMDAT

; 22   : CvWeightedVector<BuilderDirective, 100, true> CvBuilderTaskingAI::m_aDirectives;

	push	OFFSET ??__F?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A@@YAXXZ ; `dynamic atexit destructor for 'CvBuilderTaskingAI::m_aDirectives''
	call	_atexit
	pop	ecx
	ret	0
??__E?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A@@YAXXZ ENDP ; `dynamic initializer for 'CvBuilderTaskingAI::m_aDirectives''
text$yc	ENDS
PUBLIC	?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A ; CvBuilderTaskingAI::m_aiNonTerritoryPlots
_DATA	SEGMENT
	ORG $+2404
?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A DD FLAT:?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+12 ; CvBuilderTaskingAI::m_aiNonTerritoryPlots
	DB	4 DUP(00H)
	DD	040H
; Function compile flags: /Ogtpy
_DATA	ENDS
;	COMDAT ??__E?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A@@YAXXZ
text$yc	SEGMENT
??__E?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A@@YAXXZ PROC ; `dynamic initializer for 'CvBuilderTaskingAI::m_aiNonTerritoryPlots'', COMDAT

; 23   : FStaticVector<int, SAFE_ESTIMATE_NUM_EXTRA_PLOTS, true, c_eCiv5GameplayDLL, 0> CvBuilderTaskingAI::m_aiNonTerritoryPlots; // plots that we need to evaluate that are outside of our territory

	push	OFFSET ??__F?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A@@YAXXZ ; `dynamic atexit destructor for 'CvBuilderTaskingAI::m_aiNonTerritoryPlots''
	call	_atexit
	pop	ecx
	ret	0
??__E?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CvBuilderTaskingAI::m_aiNonTerritoryPlots''
; Function compile flags: /Ogtpy
text$yc	ENDS
;	COMDAT ??__F?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A@@YAXXZ
text$yd	SEGMENT
??__F?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CvBuilderTaskingAI::m_aiNonTerritoryPlots'', COMDAT
	mov	eax, DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A
	cmp	eax, OFFSET ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+12
	je	SHORT $LN5@m_aiNonTer
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN5@m_aiNonTer:
	ret	0
??__F?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CvBuilderTaskingAI::m_aiNonTerritoryPlots''
; Function compile flags: /Ogtpy
text$yd	ENDS
;	COMDAT ??__F?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A@@YAXXZ
text$yd	SEGMENT
??__F?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CvBuilderTaskingAI::m_aDirectives'', COMDAT
	mov	eax, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A
	cmp	eax, OFFSET ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A+12
	je	SHORT $LN8@m_aDirecti
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN8@m_aDirecti:
	ret	0
??__F?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CvBuilderTaskingAI::m_aDirectives''
text$yd	ENDS
CRT$XCU	SEGMENT
?m_aDirectives$initializer$@CvBuilderTaskingAI@@2P6AXXZA DD FLAT:??__E?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A@@YAXXZ ; CvBuilderTaskingAI::m_aDirectives$initializer$
?m_aiNonTerritoryPlots$initializer$@CvBuilderTaskingAI@@2P6AXXZA DD FLAT:??__E?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A@@YAXXZ ; CvBuilderTaskingAI::m_aiNonTerritoryPlots$initializer$
CRT$XCU	ENDS
END
