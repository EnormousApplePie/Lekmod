; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvMap.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_sgCvMapInstanceCount DD 01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
$SG235820 DB	'CvMap::init begin - world size=%s, climate=%s, sealevel='
	DB	'%s', 00H
	ORG $+1
$SG236028 DB	'Rand Plot Height', 00H
	ORG $+3
$SG236029 DB	'Rand Plot Width', 00H
$SG236271 DB	'Picking from random Resource Quantity types', 00H
$SG236590 DB	'FEATURE_EVEREST', 00H
$SG236593 DB	'FEATURE_CRATER', 00H
	ORG $+1
$SG236596 DB	'FEATURE_TITICACA', 00H
	ORG $+3
$SG236599 DB	'FEATURE_FUJI', 00H
	ORG $+3
$SG236602 DB	'FEATURE_MESA', 00H
	ORG $+3
$SG236605 DB	'FEATURE_REEF', 00H
	ORG $+3
$SG236608 DB	'FEATURE_VOLCANO', 00H
$SG236636 DB	'Randomly Placing Natural Wonders', 00H
	ORG $+3
$SG236702 DB	'Natural Wonder', 00H
	ORG $+1
$SG236715 DB	'Natural Wonder', 00H
CONST	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	??_7CvLandmass@@6B@				; CvLandmass::`vftable'
PUBLIC	??0CvLandmass@@QAE@XZ				; CvLandmass::CvLandmass
PUBLIC	??_R4CvLandmass@@6B@				; CvLandmass::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvLandmass@@@8				; CvLandmass `RTTI Type Descriptor'
PUBLIC	??_R3CvLandmass@@8				; CvLandmass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvLandmass@@8				; CvLandmass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvLandmass@@8			; CvLandmass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?read@CvLandmass@@UAEXAAVFDataStream@@@Z	; CvLandmass::read
PUBLIC	?write@CvLandmass@@UBEXAAVFDataStream@@@Z	; CvLandmass::write
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECvLandmass@@UAEPAXI@Z:PROC			; CvLandmass::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvLandmass@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CvLandmass@@8 DD FLAT:??_R0?AVCvLandmass@@@8 ; CvLandmass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvLandmass@@8
rdata$r	ENDS
;	COMDAT ??_R2CvLandmass@@8
rdata$r	SEGMENT
??_R2CvLandmass@@8 DD FLAT:??_R1A@?0A@EA@CvLandmass@@8	; CvLandmass::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvLandmass@@8
rdata$r	SEGMENT
??_R3CvLandmass@@8 DD 00H				; CvLandmass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvLandmass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvLandmass@@@8
_DATA	SEGMENT
??_R0?AVCvLandmass@@@8 DD FLAT:??_7type_info@@6B@	; CvLandmass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvLandmass@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvLandmass@@6B@
rdata$r	SEGMENT
??_R4CvLandmass@@6B@ DD 00H				; CvLandmass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvLandmass@@@8
	DD	FLAT:??_R3CvLandmass@@8
rdata$r	ENDS
;	COMDAT ??_7CvLandmass@@6B@
CONST	SEGMENT
??_7CvLandmass@@6B@ DD FLAT:??_R4CvLandmass@@6B@	; CvLandmass::`vftable'
	DD	FLAT:??_ECvLandmass@@UAEPAXI@Z
	DD	FLAT:?read@CvLandmass@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?write@CvLandmass@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvLandmass@@QAE@XZ
_TEXT	SEGMENT
??0CvLandmass@@QAE@XZ PROC				; CvLandmass::CvLandmass, COMDAT
; _this$ = ecx

; 39   : {

	mov	eax, ecx

; 40   : 	m_iID = -1;
; 41   : 	m_iNumTiles = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7CvLandmass@@6B@
	mov	DWORD PTR [eax+4], -1
	mov	DWORD PTR [eax+8], ecx

; 42   : 	m_bWater = true;

	mov	BYTE PTR [eax+13], 1

; 43   : 	m_cContinentType = 0;

	mov	BYTE PTR [eax+12], cl

; 44   : 	m_iCentroidX = 0;

	mov	DWORD PTR [eax+16], ecx

; 45   : 	m_iCentroidY = 0;

	mov	DWORD PTR [eax+20], ecx

; 46   : }

	ret	0
??0CvLandmass@@QAE@XZ ENDP				; CvLandmass::CvLandmass
_TEXT	ENDS
PUBLIC	??1CvLandmass@@UAE@XZ				; CvLandmass::~CvLandmass
; Function compile flags: /Ogtpy
;	COMDAT ??1CvLandmass@@UAE@XZ
_TEXT	SEGMENT
??1CvLandmass@@UAE@XZ PROC				; CvLandmass::~CvLandmass, COMDAT
; _this$ = ecx

; 50   : {

	mov	DWORD PTR [ecx], OFFSET ??_7CvLandmass@@6B@

; 51   : 
; 52   : }

	ret	0
??1CvLandmass@@UAE@XZ ENDP				; CvLandmass::~CvLandmass
_TEXT	ENDS
PUBLIC	?init@CvLandmass@@QAEXH_N@Z			; CvLandmass::init
; Function compile flags: /Ogtpy
;	COMDAT ?init@CvLandmass@@QAEXH_N@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
_bWater$ = 12						; size = 1
?init@CvLandmass@@QAEXH_N@Z PROC			; CvLandmass::init, COMDAT
; _this$ = ecx

; 57   : 	m_iID = iID;

	mov	eax, DWORD PTR _iID$[esp-4]

; 58   : 	m_iNumTiles = 0;
; 59   : 	m_bWater = bWater;

	mov	dl, BYTE PTR _bWater$[esp-4]
	mov	DWORD PTR [ecx+4], eax
	xor	eax, eax
	mov	DWORD PTR [ecx+8], eax
	mov	BYTE PTR [ecx+13], dl

; 60   : 	m_cContinentType = 0;

	mov	BYTE PTR [ecx+12], al

; 61   : 	m_iCentroidX = 0;

	mov	DWORD PTR [ecx+16], eax

; 62   : 	m_iCentroidY = 0;

	mov	DWORD PTR [ecx+20], eax

; 63   : }

	ret	8
?init@CvLandmass@@QAEXH_N@Z ENDP			; CvLandmass::init
_TEXT	ENDS
PUBLIC	?GetID@CvLandmass@@QBEHXZ			; CvLandmass::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvLandmass@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvLandmass@@QBEHXZ PROC				; CvLandmass::GetID, COMDAT
; _this$ = ecx

; 68   : 	return m_iID;

	mov	eax, DWORD PTR [ecx+4]

; 69   : }

	ret	0
?GetID@CvLandmass@@QBEHXZ ENDP				; CvLandmass::GetID
_TEXT	ENDS
PUBLIC	?SetID@CvLandmass@@QAEXH@Z			; CvLandmass::SetID
; Function compile flags: /Ogtpy
;	COMDAT ?SetID@CvLandmass@@QAEXH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?SetID@CvLandmass@@QAEXH@Z PROC				; CvLandmass::SetID, COMDAT
; _this$ = ecx

; 74   : 	m_iID = iID;

	mov	eax, DWORD PTR _iID$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 75   : }

	ret	4
?SetID@CvLandmass@@QAEXH@Z ENDP				; CvLandmass::SetID
_TEXT	ENDS
PUBLIC	?getNumTiles@CvLandmass@@QBEHXZ			; CvLandmass::getNumTiles
; Function compile flags: /Ogtpy
;	COMDAT ?getNumTiles@CvLandmass@@QBEHXZ
_TEXT	SEGMENT
?getNumTiles@CvLandmass@@QBEHXZ PROC			; CvLandmass::getNumTiles, COMDAT
; _this$ = ecx

; 80   : 	return m_iNumTiles;

	mov	eax, DWORD PTR [ecx+8]

; 81   : }

	ret	0
?getNumTiles@CvLandmass@@QBEHXZ ENDP			; CvLandmass::getNumTiles
_TEXT	ENDS
PUBLIC	?ChangeCentroidX@CvLandmass@@QAEXH@Z		; CvLandmass::ChangeCentroidX
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeCentroidX@CvLandmass@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeCentroidX@CvLandmass@@QAEXH@Z PROC		; CvLandmass::ChangeCentroidX, COMDAT
; _this$ = ecx

; 103  : 	m_iCentroidX = (m_iCentroidX + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+16], eax

; 104  : }

	ret	4
?ChangeCentroidX@CvLandmass@@QAEXH@Z ENDP		; CvLandmass::ChangeCentroidX
_TEXT	ENDS
PUBLIC	?ChangeCentroidY@CvLandmass@@QAEXH@Z		; CvLandmass::ChangeCentroidY
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeCentroidY@CvLandmass@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeCentroidY@CvLandmass@@QAEXH@Z PROC		; CvLandmass::ChangeCentroidY, COMDAT
; _this$ = ecx

; 109  : 	m_iCentroidY = (m_iCentroidY + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+20], eax

; 110  : }

	ret	4
?ChangeCentroidY@CvLandmass@@QAEXH@Z ENDP		; CvLandmass::ChangeCentroidY
_TEXT	ENDS
PUBLIC	?isWater@CvLandmass@@QBE_NXZ			; CvLandmass::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvLandmass@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvLandmass@@QBE_NXZ PROC			; CvLandmass::isWater, COMDAT
; _this$ = ecx

; 115  : 	return m_bWater;

	mov	al, BYTE PTR [ecx+13]

; 116  : }

	ret	0
?isWater@CvLandmass@@QBE_NXZ ENDP			; CvLandmass::isWater
_TEXT	ENDS
PUBLIC	?GetContinentType@CvLandmass@@QBEDXZ		; CvLandmass::GetContinentType
; Function compile flags: /Ogtpy
;	COMDAT ?GetContinentType@CvLandmass@@QBEDXZ
_TEXT	SEGMENT
?GetContinentType@CvLandmass@@QBEDXZ PROC		; CvLandmass::GetContinentType, COMDAT
; _this$ = ecx

; 132  : 	return m_cContinentType;

	mov	al, BYTE PTR [ecx+12]

; 133  : }

	ret	0
?GetContinentType@CvLandmass@@QBEDXZ ENDP		; CvLandmass::GetContinentType
_TEXT	ENDS
PUBLIC	?SetContinentType@CvLandmass@@QAEXD@Z		; CvLandmass::SetContinentType
; Function compile flags: /Ogtpy
;	COMDAT ?SetContinentType@CvLandmass@@QAEXD@Z
_TEXT	SEGMENT
_cContinent$ = 8					; size = 1
?SetContinentType@CvLandmass@@QAEXD@Z PROC		; CvLandmass::SetContinentType, COMDAT
; _this$ = ecx

; 142  : 	m_cContinentType = cContinent;

	mov	al, BYTE PTR _cContinent$[esp-4]
	mov	BYTE PTR [ecx+12], al

; 143  : }

	ret	4
?SetContinentType@CvLandmass@@QAEXD@Z ENDP		; CvLandmass::SetContinentType
_TEXT	ENDS
PUBLIC	?GetCentroidX@CvLandmass@@QAEHXZ		; CvLandmass::GetCentroidX
; Function compile flags: /Ogtpy
;	COMDAT ?GetCentroidX@CvLandmass@@QAEHXZ
_TEXT	SEGMENT
?GetCentroidX@CvLandmass@@QAEHXZ PROC			; CvLandmass::GetCentroidX, COMDAT
; _this$ = ecx

; 147  : {

	push	esi

; 148  : 	if(m_iNumTiles > 0)

	mov	esi, DWORD PTR [ecx+8]
	test	esi, esi
	jle	SHORT $LN1@GetCentroi

; 149  : 	{
; 150  : 		return m_iCentroidX / m_iNumTiles;

	mov	eax, DWORD PTR [ecx+16]
	cdq
	idiv	esi
	pop	esi

; 154  : }

	ret	0
$LN1@GetCentroi:

; 151  : 
; 152  : 	}
; 153  : 	return -1;

	or	eax, -1
	pop	esi

; 154  : }

	ret	0
?GetCentroidX@CvLandmass@@QAEHXZ ENDP			; CvLandmass::GetCentroidX
_TEXT	ENDS
PUBLIC	?GetCentroidY@CvLandmass@@QAEHXZ		; CvLandmass::GetCentroidY
; Function compile flags: /Ogtpy
;	COMDAT ?GetCentroidY@CvLandmass@@QAEHXZ
_TEXT	SEGMENT
?GetCentroidY@CvLandmass@@QAEHXZ PROC			; CvLandmass::GetCentroidY, COMDAT
; _this$ = ecx

; 158  : {

	push	esi

; 159  : 	if(m_iNumTiles > 0)

	mov	esi, DWORD PTR [ecx+8]
	test	esi, esi
	jle	SHORT $LN1@GetCentroi@2

; 160  : 	{
; 161  : 		return m_iCentroidY / m_iNumTiles;

	mov	eax, DWORD PTR [ecx+20]
	cdq
	idiv	esi
	pop	esi

; 165  : }

	ret	0
$LN1@GetCentroi@2:

; 162  : 
; 163  : 	}
; 164  : 	return -1;

	or	eax, -1
	pop	esi

; 165  : }

	ret	0
?GetCentroidY@CvLandmass@@QAEHXZ ENDP			; CvLandmass::GetCentroidY
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvLandmass@@@Z	; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvLandmass@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvLandmass@@@Z PROC	; operator<<, COMDAT

; 209  : 	readFrom.write(saveTo);

	mov	ecx, DWORD PTR _readFrom$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	esi
	mov	esi, DWORD PTR _saveTo$[esp]
	push	esi
	call	edx

; 210  : 	return saveTo;

	mov	eax, esi
	pop	esi

; 211  : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvLandmass@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvLandmass@@@Z	; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvLandmass@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvLandmass@@@Z PROC	; operator>>, COMDAT

; 216  : 	writeTo.read(loadFrom);

	mov	ecx, DWORD PTR _writeTo$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	esi
	call	edx

; 217  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 218  : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvLandmass@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	??_ECvPlot@@QAEPAXI@Z				; CvPlot::`vector deleting destructor'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??1CvPlot@@QAE@XZ:PROC				; CvPlot::~CvPlot
; Function compile flags: /Ogtpy
;	COMDAT ??_ECvPlot@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_ECvPlot@@QAEPAXI@Z PROC				; CvPlot::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1CvPlot@@QAE@XZ		; CvPlot::~CvPlot
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	484					; 000001e4H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector:
	call	??1CvPlot@@QAE@XZ			; CvPlot::~CvPlot
	test	bl, 1
	je	SHORT $LN1@vector
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_ECvPlot@@QAEPAXI@Z ENDP				; CvPlot::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getLandPlots@CvMap@@QAEHXZ			; CvMap::getLandPlots
; Function compile flags: /Ogtpy
;	COMDAT ?getLandPlots@CvMap@@QAEHXZ
_TEXT	SEGMENT
?getLandPlots@CvMap@@QAEHXZ PROC			; CvMap::getLandPlots, COMDAT
; _this$ = ecx

; 1263 : 	return m_iLandPlots;

	mov	eax, DWORD PTR [ecx+4032]

; 1264 : }

	ret	0
?getLandPlots@CvMap@@QAEHXZ ENDP			; CvMap::getLandPlots
_TEXT	ENDS
PUBLIC	?changeLandPlots@CvMap@@QAEXH@Z			; CvMap::changeLandPlots
; Function compile flags: /Ogtpy
;	COMDAT ?changeLandPlots@CvMap@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeLandPlots@CvMap@@QAEXH@Z PROC			; CvMap::changeLandPlots, COMDAT
; _this$ = ecx

; 1270 : #ifdef AUI_WARNING_FIXES
; 1271 : 	if (iChange < 0)
; 1272 : 		m_iLandPlots = (m_iLandPlots - abs(iChange));
; 1273 : 	else
; 1274 : #endif
; 1275 : 	m_iLandPlots = (m_iLandPlots + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+4032], eax

; 1276 : 	CvAssert(getLandPlots() >= 0);
; 1277 : }

	ret	4
?changeLandPlots@CvMap@@QAEXH@Z ENDP			; CvMap::changeLandPlots
_TEXT	ENDS
PUBLIC	?getOwnedPlots@CvMap@@QAEHXZ			; CvMap::getOwnedPlots
; Function compile flags: /Ogtpy
;	COMDAT ?getOwnedPlots@CvMap@@QAEHXZ
_TEXT	SEGMENT
?getOwnedPlots@CvMap@@QAEHXZ PROC			; CvMap::getOwnedPlots, COMDAT
; _this$ = ecx

; 1287 : 	return m_iOwnedPlots;

	mov	eax, DWORD PTR [ecx+4036]

; 1288 : }

	ret	0
?getOwnedPlots@CvMap@@QAEHXZ ENDP			; CvMap::getOwnedPlots
_TEXT	ENDS
PUBLIC	?changeOwnedPlots@CvMap@@QAEXH@Z		; CvMap::changeOwnedPlots
; Function compile flags: /Ogtpy
;	COMDAT ?changeOwnedPlots@CvMap@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeOwnedPlots@CvMap@@QAEXH@Z PROC			; CvMap::changeOwnedPlots, COMDAT
; _this$ = ecx

; 1294 : #ifdef AUI_WARNING_FIXES
; 1295 : 	if (iChange < 0)
; 1296 : 		m_iOwnedPlots = (m_iOwnedPlots - abs(iChange));
; 1297 : 	else
; 1298 : #endif
; 1299 : 	m_iOwnedPlots = (m_iOwnedPlots + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+4036], eax

; 1300 : 	CvAssert(getOwnedPlots() >= 0);
; 1301 : }

	ret	4
?changeOwnedPlots@CvMap@@QAEXH@Z ENDP			; CvMap::changeOwnedPlots
_TEXT	ENDS
PUBLIC	?getTopLatitude@CvMap@@QAEHXZ			; CvMap::getTopLatitude
; Function compile flags: /Ogtpy
;	COMDAT ?getTopLatitude@CvMap@@QAEHXZ
_TEXT	SEGMENT
?getTopLatitude@CvMap@@QAEHXZ PROC			; CvMap::getTopLatitude, COMDAT
; _this$ = ecx

; 1307 : 	return m_iTopLatitude;

	mov	eax, DWORD PTR [ecx+4040]

; 1308 : }

	ret	0
?getTopLatitude@CvMap@@QAEHXZ ENDP			; CvMap::getTopLatitude
_TEXT	ENDS
PUBLIC	?getBottomLatitude@CvMap@@QAEHXZ		; CvMap::getBottomLatitude
; Function compile flags: /Ogtpy
;	COMDAT ?getBottomLatitude@CvMap@@QAEHXZ
_TEXT	SEGMENT
?getBottomLatitude@CvMap@@QAEHXZ PROC			; CvMap::getBottomLatitude, COMDAT
; _this$ = ecx

; 1314 : 	return m_iBottomLatitude;

	mov	eax, DWORD PTR [ecx+4044]

; 1315 : }

	ret	0
?getBottomLatitude@CvMap@@QAEHXZ ENDP			; CvMap::getBottomLatitude
_TEXT	ENDS
PUBLIC	?getWorldSize@CvMap@@QAE?AW4WorldSizeTypes@@XZ	; CvMap::getWorldSize
EXTRN	?worldSize@CvPreGame@@YA?AW4WorldSizeTypes@@XZ:PROC ; CvPreGame::worldSize
; Function compile flags: /Ogtpy
;	COMDAT ?getWorldSize@CvMap@@QAE?AW4WorldSizeTypes@@XZ
_TEXT	SEGMENT
?getWorldSize@CvMap@@QAE?AW4WorldSizeTypes@@XZ PROC	; CvMap::getWorldSize, COMDAT
; _this$ = ecx

; 1320 : 	return CvPreGame::worldSize();

	jmp	?worldSize@CvPreGame@@YA?AW4WorldSizeTypes@@XZ ; CvPreGame::worldSize
?getWorldSize@CvMap@@QAE?AW4WorldSizeTypes@@XZ ENDP	; CvMap::getWorldSize
_TEXT	ENDS
PUBLIC	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ	; CvMap::getWorldInfo
EXTRN	?worldInfo@CvPreGame@@YAABVCvWorldInfo@@XZ:PROC	; CvPreGame::worldInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ
_TEXT	SEGMENT
?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ PROC		; CvMap::getWorldInfo, COMDAT
; _this$ = ecx

; 1326 : 	return CvPreGame::worldInfo();

	jmp	?worldInfo@CvPreGame@@YAABVCvWorldInfo@@XZ ; CvPreGame::worldInfo
?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ENDP		; CvMap::getWorldInfo
_TEXT	ENDS
PUBLIC	?getClimate@CvMap@@QAE?AW4ClimateTypes@@XZ	; CvMap::getClimate
EXTRN	?climate@CvPreGame@@YA?AW4ClimateTypes@@XZ:PROC	; CvPreGame::climate
; Function compile flags: /Ogtpy
;	COMDAT ?getClimate@CvMap@@QAE?AW4ClimateTypes@@XZ
_TEXT	SEGMENT
?getClimate@CvMap@@QAE?AW4ClimateTypes@@XZ PROC		; CvMap::getClimate, COMDAT
; _this$ = ecx

; 1332 : 	return CvPreGame::climate();

	jmp	?climate@CvPreGame@@YA?AW4ClimateTypes@@XZ ; CvPreGame::climate
?getClimate@CvMap@@QAE?AW4ClimateTypes@@XZ ENDP		; CvMap::getClimate
_TEXT	ENDS
PUBLIC	?getClimateInfo@CvMap@@QBEABVCvClimateInfo@@XZ	; CvMap::getClimateInfo
EXTRN	?climateInfo@CvPreGame@@YAABVCvClimateInfo@@XZ:PROC ; CvPreGame::climateInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getClimateInfo@CvMap@@QBEABVCvClimateInfo@@XZ
_TEXT	SEGMENT
?getClimateInfo@CvMap@@QBEABVCvClimateInfo@@XZ PROC	; CvMap::getClimateInfo, COMDAT
; _this$ = ecx

; 1338 : 	return CvPreGame::climateInfo();

	jmp	?climateInfo@CvPreGame@@YAABVCvClimateInfo@@XZ ; CvPreGame::climateInfo
?getClimateInfo@CvMap@@QBEABVCvClimateInfo@@XZ ENDP	; CvMap::getClimateInfo
_TEXT	ENDS
PUBLIC	?getSeaLevel@CvMap@@QAE?AW4SeaLevelTypes@@XZ	; CvMap::getSeaLevel
EXTRN	?seaLevel@CvPreGame@@YA?AW4SeaLevelTypes@@XZ:PROC ; CvPreGame::seaLevel
; Function compile flags: /Ogtpy
;	COMDAT ?getSeaLevel@CvMap@@QAE?AW4SeaLevelTypes@@XZ
_TEXT	SEGMENT
?getSeaLevel@CvMap@@QAE?AW4SeaLevelTypes@@XZ PROC	; CvMap::getSeaLevel, COMDAT
; _this$ = ecx

; 1344 : 	return CvPreGame::seaLevel();

	jmp	?seaLevel@CvPreGame@@YA?AW4SeaLevelTypes@@XZ ; CvPreGame::seaLevel
?getSeaLevel@CvMap@@QAE?AW4SeaLevelTypes@@XZ ENDP	; CvMap::getSeaLevel
_TEXT	ENDS
PUBLIC	?getSeaLevelInfo@CvMap@@QBEABVCvSeaLevelInfo@@XZ ; CvMap::getSeaLevelInfo
EXTRN	?seaLevelInfo@CvPreGame@@YAABVCvSeaLevelInfo@@XZ:PROC ; CvPreGame::seaLevelInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getSeaLevelInfo@CvMap@@QBEABVCvSeaLevelInfo@@XZ
_TEXT	SEGMENT
?getSeaLevelInfo@CvMap@@QBEABVCvSeaLevelInfo@@XZ PROC	; CvMap::getSeaLevelInfo, COMDAT
; _this$ = ecx

; 1350 : 	return CvPreGame::seaLevelInfo();

	jmp	?seaLevelInfo@CvPreGame@@YAABVCvSeaLevelInfo@@XZ ; CvPreGame::seaLevelInfo
?getSeaLevelInfo@CvMap@@QBEABVCvSeaLevelInfo@@XZ ENDP	; CvMap::getSeaLevelInfo
_TEXT	ENDS
PUBLIC	?getNumResources@CvMap@@QAEHW4ResourceTypes@@@Z	; CvMap::getNumResources
; Function compile flags: /Ogtpy
;	COMDAT ?getNumResources@CvMap@@QAEHW4ResourceTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getNumResources@CvMap@@QAEHW4ResourceTypes@@@Z PROC	; CvMap::getNumResources, COMDAT
; _this$ = ecx

; 1383 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 1384 : 	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 1385 : 	return m_paiNumResource[eIndex];

	mov	eax, DWORD PTR [ecx+4060]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1386 : }

	ret	4
?getNumResources@CvMap@@QAEHW4ResourceTypes@@@Z ENDP	; CvMap::getNumResources
_TEXT	ENDS
PUBLIC	?changeNumResources@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResources
; Function compile flags: /Ogtpy
;	COMDAT ?changeNumResources@CvMap@@QAEXW4ResourceTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeNumResources@CvMap@@QAEXW4ResourceTypes@@H@Z PROC ; CvMap::changeNumResources, COMDAT
; _this$ = ecx

; 1392 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 1393 : 	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 1394 : 	m_paiNumResource[eIndex] = (m_paiNumResource[eIndex] + iChange);

	mov	eax, DWORD PTR [ecx+4060]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	edx, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [eax+ecx*4], edx
	lea	eax, DWORD PTR [eax+ecx*4]

; 1395 : 	CvAssert(getNumResources(eIndex) >= 0);
; 1396 : }

	ret	8
?changeNumResources@CvMap@@QAEXW4ResourceTypes@@H@Z ENDP ; CvMap::changeNumResources
_TEXT	ENDS
PUBLIC	?getNumResourcesOnLand@CvMap@@QAEHW4ResourceTypes@@@Z ; CvMap::getNumResourcesOnLand
; Function compile flags: /Ogtpy
;	COMDAT ?getNumResourcesOnLand@CvMap@@QAEHW4ResourceTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getNumResourcesOnLand@CvMap@@QAEHW4ResourceTypes@@@Z PROC ; CvMap::getNumResourcesOnLand, COMDAT
; _this$ = ecx

; 1402 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 1403 : 	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 1404 : 	return m_paiNumResourceOnLand[eIndex];

	mov	eax, DWORD PTR [ecx+4064]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1405 : }

	ret	4
?getNumResourcesOnLand@CvMap@@QAEHW4ResourceTypes@@@Z ENDP ; CvMap::getNumResourcesOnLand
_TEXT	ENDS
PUBLIC	?changeNumResourcesOnLand@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResourcesOnLand
; Function compile flags: /Ogtpy
;	COMDAT ?changeNumResourcesOnLand@CvMap@@QAEXW4ResourceTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeNumResourcesOnLand@CvMap@@QAEXW4ResourceTypes@@H@Z PROC ; CvMap::changeNumResourcesOnLand, COMDAT
; _this$ = ecx

; 1411 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 1412 : 	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 1413 : 	m_paiNumResourceOnLand[eIndex] = (m_paiNumResourceOnLand[eIndex] + iChange);

	mov	eax, DWORD PTR [ecx+4064]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	edx, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [eax+ecx*4], edx
	lea	eax, DWORD PTR [eax+ecx*4]

; 1414 : 	CvAssert(getNumResourcesOnLand(eIndex) >= 0);
; 1415 : }

	ret	8
?changeNumResourcesOnLand@CvMap@@QAEXW4ResourceTypes@@H@Z ENDP ; CvMap::changeNumResourcesOnLand
_TEXT	ENDS
PUBLIC	?getArea@CvMap@@QAEPAVCvArea@@H@Z		; CvMap::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?getArea@CvMap@@QAEPAVCvArea@@H@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?getArea@CvMap@@QAEPAVCvArea@@H@Z PROC			; CvMap::getArea, COMDAT
; _this$ = ecx

; 1455 : 	return m_areas.GetAt(iID);

	add	ecx, 4112				; 00001010H
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	jmp	eax
?getArea@CvMap@@QAEPAVCvArea@@H@Z ENDP			; CvMap::getArea
_TEXT	ENDS
PUBLIC	?GetNumNaturalWonders@CvMap@@QBEHXZ		; CvMap::GetNumNaturalWonders
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumNaturalWonders@CvMap@@QBEHXZ
_TEXT	SEGMENT
?GetNumNaturalWonders@CvMap@@QBEHXZ PROC		; CvMap::GetNumNaturalWonders, COMDAT
; _this$ = ecx

; 1752 : 	return m_iNumNaturalWonders;

	mov	eax, DWORD PTR [ecx+4048]

; 1753 : }

	ret	0
?GetNumNaturalWonders@CvMap@@QBEHXZ ENDP		; CvMap::GetNumNaturalWonders
_TEXT	ENDS
PUBLIC	?ChangeNumNaturalWonders@CvMap@@QAEXH@Z		; CvMap::ChangeNumNaturalWonders
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeNumNaturalWonders@CvMap@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeNumNaturalWonders@CvMap@@QAEXH@Z PROC		; CvMap::ChangeNumNaturalWonders, COMDAT
; _this$ = ecx

; 1759 : 	m_iNumNaturalWonders += iChange;

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+4048], eax

; 1760 : }

	ret	4
?ChangeNumNaturalWonders@CvMap@@QAEXH@Z ENDP		; CvMap::ChangeNumNaturalWonders
_TEXT	ENDS
PUBLIC	?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z	; CvMap::getLandmass
; Function compile flags: /Ogtpy
;	COMDAT ?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z PROC		; CvMap::getLandmass, COMDAT
; _this$ = ecx

; 2324 : 	return m_landmasses.GetAt(iID);

	add	ecx, 4140				; 0000102cH
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	jmp	eax
?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z ENDP		; CvMap::getLandmass
_TEXT	ENDS
PUBLIC	?ChangeAIMapHint@CvMap@@QAEXH@Z			; CvMap::ChangeAIMapHint
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeAIMapHint@CvMap@@QAEXH@Z
_TEXT	SEGMENT
_iMapHint$ = 8						; size = 4
?ChangeAIMapHint@CvMap@@QAEXH@Z PROC			; CvMap::ChangeAIMapHint, COMDAT
; _this$ = ecx

; 2473 : 	m_iAIMapHints |= iMapHint;

	mov	eax, DWORD PTR _iMapHint$[esp-4]
	or	DWORD PTR [ecx+4052], eax

; 2474 : }

	ret	4
?ChangeAIMapHint@CvMap@@QAEXH@Z ENDP			; CvMap::ChangeAIMapHint
_TEXT	ENDS
PUBLIC	?GetAIMapHint@CvMap@@QAEHXZ			; CvMap::GetAIMapHint
; Function compile flags: /Ogtpy
;	COMDAT ?GetAIMapHint@CvMap@@QAEHXZ
_TEXT	SEGMENT
?GetAIMapHint@CvMap@@QAEHXZ PROC			; CvMap::GetAIMapHint, COMDAT
; _this$ = ecx

; 2479 : 	return m_iAIMapHints;

	mov	eax, DWORD PTR [ecx+4052]

; 2480 : }

	ret	0
?GetAIMapHint@CvMap@@QAEHXZ ENDP			; CvMap::GetAIMapHint
_TEXT	ENDS
PUBLIC	??A?$BaseVector@PAVCvPlot@@$00@@QAEAAPAVCvPlot@@I@Z ; BaseVector<CvPlot *,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@PAVCvPlot@@$00@@QAEAAPAVCvPlot@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@PAVCvPlot@@$00@@QAEAAPAVCvPlot@@I@Z PROC ; BaseVector<CvPlot *,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@PAVCvPlot@@$00@@QAEAAPAVCvPlot@@I@Z ENDP ; BaseVector<CvPlot *,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@PAVCvPlot@@$00@@QBEIXZ	; BaseVector<CvPlot *,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@PAVCvPlot@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@PAVCvPlot@@$00@@QBEIXZ PROC		; BaseVector<CvPlot *,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@PAVCvPlot@@$00@@QBEIXZ ENDP		; BaseVector<CvPlot *,1>::size
_TEXT	ENDS
PUBLIC	?GetIndexAfterLast@?$FFreeListArrayBase@VCvArea@@@@QAEHXZ ; FFreeListArrayBase<CvArea>::GetIndexAfterLast
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
;	COMDAT ?GetIndexAfterLast@?$FFreeListArrayBase@VCvArea@@@@QAEHXZ
_TEXT	SEGMENT
?GetIndexAfterLast@?$FFreeListArrayBase@VCvArea@@@@QAEHXZ PROC ; FFreeListArrayBase<CvArea>::GetIndexAfterLast, COMDAT
; _this$ = ecx

; 56   : 	int GetIndexAfterLast()	{	return m_iLastIndex + 1;	}

	mov	eax, DWORD PTR [ecx+12]
	inc	eax
	ret	0
?GetIndexAfterLast@?$FFreeListArrayBase@VCvArea@@@@QAEHXZ ENDP ; FFreeListArrayBase<CvArea>::GetIndexAfterLast
_TEXT	ENDS
PUBLIC	?GetCount@?$FFreeListArrayBase@VCvArea@@@@QBEHXZ ; FFreeListArrayBase<CvArea>::GetCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetCount@?$FFreeListArrayBase@VCvArea@@@@QBEHXZ
_TEXT	SEGMENT
?GetCount@?$FFreeListArrayBase@VCvArea@@@@QBEHXZ PROC	; FFreeListArrayBase<CvArea>::GetCount, COMDAT
; _this$ = ecx

; 74   : 	int GetCount()	const {	return m_iLastIndex - m_iFreeListCount + 1;	}

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [ecx+8]
	inc	eax
	ret	0
?GetCount@?$FFreeListArrayBase@VCvArea@@@@QBEHXZ ENDP	; FFreeListArrayBase<CvArea>::GetCount
_TEXT	ENDS
PUBLIC	?GetIndexAfterLast@?$FFreeListArrayBase@VCvLandmass@@@@QAEHXZ ; FFreeListArrayBase<CvLandmass>::GetIndexAfterLast
; Function compile flags: /Ogtpy
;	COMDAT ?GetIndexAfterLast@?$FFreeListArrayBase@VCvLandmass@@@@QAEHXZ
_TEXT	SEGMENT
?GetIndexAfterLast@?$FFreeListArrayBase@VCvLandmass@@@@QAEHXZ PROC ; FFreeListArrayBase<CvLandmass>::GetIndexAfterLast, COMDAT
; _this$ = ecx

; 56   : 	int GetIndexAfterLast()	{	return m_iLastIndex + 1;	}

	mov	eax, DWORD PTR [ecx+12]
	inc	eax
	ret	0
?GetIndexAfterLast@?$FFreeListArrayBase@VCvLandmass@@@@QAEHXZ ENDP ; FFreeListArrayBase<CvLandmass>::GetIndexAfterLast
_TEXT	ENDS
PUBLIC	?GetCount@?$FFreeListArrayBase@VCvLandmass@@@@QBEHXZ ; FFreeListArrayBase<CvLandmass>::GetCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetCount@?$FFreeListArrayBase@VCvLandmass@@@@QBEHXZ
_TEXT	SEGMENT
?GetCount@?$FFreeListArrayBase@VCvLandmass@@@@QBEHXZ PROC ; FFreeListArrayBase<CvLandmass>::GetCount, COMDAT
; _this$ = ecx

; 74   : 	int GetCount()	const {	return m_iLastIndex - m_iFreeListCount + 1;	}

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [ecx+8]
	inc	eax
	ret	0
?GetCount@?$FFreeListArrayBase@VCvLandmass@@@@QBEHXZ ENDP ; FFreeListArrayBase<CvLandmass>::GetCount
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UTradeConnection@@$0A@@@QAEAAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@UTradeConnection@@$0A@@@QAEAAUTradeConnection@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UTradeConnection@@$0A@@@QAEAAUTradeConnection@@I@Z PROC ; BaseVector<TradeConnection,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	imul	eax, 444				; 000001bcH
	add	eax, DWORD PTR [ecx]

; 131  : 	};

	ret	4
??A?$BaseVector@UTradeConnection@@$0A@@@QAEAAUTradeConnection@@I@Z ENDP ; BaseVector<TradeConnection,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UTradeConnection@@$0A@@@QBEIXZ ; BaseVector<TradeConnection,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UTradeConnection@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UTradeConnection@@$0A@@@QBEIXZ PROC	; BaseVector<TradeConnection,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UTradeConnection@@$0A@@@QBEIXZ ENDP	; BaseVector<TradeConnection,0>::size
_TEXT	ENDS
PUBLIC	??0?$ArrayWrapper@E@@QAE@HPAE@Z			; ArrayWrapper<unsigned char>::ArrayWrapper<unsigned char>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??0?$ArrayWrapper@E@@QAE@HPAE@Z
_TEXT	SEGMENT
_count$ = 8						; size = 4
_values$ = 12						; size = 4
??0?$ArrayWrapper@E@@QAE@HPAE@Z PROC			; ArrayWrapper<unsigned char>::ArrayWrapper<unsigned char>, COMDAT
; _this$ = ecx

; 378  : 		: m_values(values), m_count(count) {}

	mov	edx, DWORD PTR _count$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _values$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0?$ArrayWrapper@E@@QAE@HPAE@Z ENDP			; ArrayWrapper<unsigned char>::ArrayWrapper<unsigned char>
_TEXT	ENDS
PUBLIC	??0?$ArrayWrapper@$$CBE@@QAE@HPBE@Z		; ArrayWrapper<unsigned char const >::ArrayWrapper<unsigned char const >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$ArrayWrapper@$$CBE@@QAE@HPBE@Z
_TEXT	SEGMENT
_count$ = 8						; size = 4
_values$ = 12						; size = 4
??0?$ArrayWrapper@$$CBE@@QAE@HPBE@Z PROC		; ArrayWrapper<unsigned char const >::ArrayWrapper<unsigned char const >, COMDAT
; _this$ = ecx

; 378  : 		: m_values(values), m_count(count) {}

	mov	edx, DWORD PTR _count$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _values$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0?$ArrayWrapper@$$CBE@@QAE@HPBE@Z ENDP		; ArrayWrapper<unsigned char const >::ArrayWrapper<unsigned char const >
_TEXT	ENDS
PUBLIC	??1?$BaseVector@PAVCvPlot@@$00@@QAE@XZ		; BaseVector<CvPlot *,1>::~BaseVector<CvPlot *,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@PAVCvPlot@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@PAVCvPlot@@$00@@QAE@XZ PROC		; BaseVector<CvPlot *,1>::~BaseVector<CvPlot *,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@PAVCvPlot@@$00@@QAE@XZ ENDP		; BaseVector<CvPlot *,1>::~BaseVector<CvPlot *,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@PAVCvPlot@@$00@@IAE@XZ		; BaseVector<CvPlot *,1>::BaseVector<CvPlot *,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@PAVCvPlot@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@PAVCvPlot@@$00@@IAE@XZ PROC		; BaseVector<CvPlot *,1>::BaseVector<CvPlot *,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@PAVCvPlot@@$00@@IAE@XZ ENDP		; BaseVector<CvPlot *,1>::BaseVector<CvPlot *,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@PAVCvPlot@@$00@@IAEXPAPAVCvPlot@@I@Z ; BaseVector<CvPlot *,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@PAVCvPlot@@$00@@IAEXPAPAVCvPlot@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@PAVCvPlot@@$00@@IAEXPAPAVCvPlot@@I@Z PROC ; BaseVector<CvPlot *,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@PAVCvPlot@@$00@@IAEXPAPAVCvPlot@@I@Z ENDP ; BaseVector<CvPlot *,1>::Destroy
_TEXT	ENDS
PUBLIC	??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEPAPAVCvPlot@@I@Z ; FStaticVector<CvPlot *,1000,1,297,1>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
CONST	SEGMENT
??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ DB 'c:\users\eno'
	DB	'rmousapplepie\documents\github\lekmod\lekmod_dll\fireplace\in'
	DB	'clude\fireworks\FFastVector.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEPAPAVCvPlot@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEPAPAVCvPlot@@I@Z PROC ; FStaticVector<CvPlot *,1000,1,297,1>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 1000				; 000003e8H
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 1000			; 000003e8H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEPAPAVCvPlot@@I@Z ENDP ; FStaticVector<CvPlot *,1000,1,297,1>::Alloc
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEXPAPAVCvPlot@@I@Z ; FStaticVector<CvPlot *,1000,1,297,1>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEXPAPAVCvPlot@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEXPAPAVCvPlot@@I@Z PROC ; FStaticVector<CvPlot *,1000,1,297,1>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEXPAPAVCvPlot@@I@Z ENDP ; FStaticVector<CvPlot *,1000,1,297,1>::Free
_TEXT	ENDS
PUBLIC	?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ ; FFreeListTrashArray<CvArea>::Add
EXTRN	?SetID@CvArea@@QAEXH@Z:PROC			; CvArea::SetID
EXTRN	??0CvArea@@QAE@XZ:PROC				; CvArea::CvArea
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
xdata$x	SEGMENT
__unwindtable$?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ$0
__ehfuncinfo$?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ
_TEXT	SEGMENT
$T237999 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ PROC ; FFreeListTrashArray<CvArea>::Add, COMDAT
; _this$ = ecx

; 204  : {

	push	-1
	push	__ehhandler$?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 205  : 	int iIndex;
; 206  : 
; 207  : 	if (m_pArray == NULL) 

	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN5@Add

; 208  : 	{
; 209  : 		Init();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+4]
	push	8
	call	edx
$LN5@Add:

; 210  : 	}
; 211  : 
; 212  : 	if ((this->m_iLastIndex == this->m_iNumSlots - 1) &&
; 213  : 		(this->m_iFreeListCount == 0))

	mov	eax, DWORD PTR [esi+16]
	lea	ecx, DWORD PTR [eax-1]
	cmp	DWORD PTR [esi+12], ecx
	jne	SHORT $LN4@Add
	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN4@Add

; 214  : 	{
; 215  : 		if ((this->m_iNumSlots * FLTA_GROWTH_FACTOR) > FLTA_MAX_BUCKETS)

	lea	edx, DWORD PTR [eax+eax]
	cmp	edx, 8192				; 00002000H
	jle	SHORT $LN3@Add

; 216  : 		{
; 217  : 			return NULL;

	xor	eax, eax
	pop	esi

; 242  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
$LN3@Add:

; 218  : 		}
; 219  : 
; 220  : 		GrowArray();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+24]
	mov	ecx, esi
	call	edx
$LN4@Add:

; 221  : 	}
; 222  : 
; 223  : 	if (this->m_iFreeListCount > 0)

	mov	eax, DWORD PTR [esi+8]
	push	edi
	test	eax, eax
	jle	SHORT $LN2@Add

; 224  : 	{
; 225  : 		iIndex = this->m_iFreeListHead;

	mov	edi, DWORD PTR [esi+4]

; 226  : 		this->m_iFreeListHead = m_pArray[this->m_iFreeListHead].iNextFreeIndex;

	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [ecx+edi*8]

; 227  : 		this->m_iFreeListCount--;

	dec	eax
	mov	DWORD PTR [esi+4], edx
	mov	DWORD PTR [esi+8], eax

; 228  : 	}
; 229  : 	else

	jmp	SHORT $LN1@Add
$LN2@Add:

; 230  : 	{
; 231  : 		this->m_iLastIndex++;

	inc	DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+12]
$LN1@Add:

; 232  : 		iIndex = this->m_iLastIndex;
; 233  : 	}
; 234  : 
; 235  : 	m_pArray[iIndex].pData = FNEW( T, c_eMPoolTypeContainer, 0 );

	push	4232					; 00001088H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T237999[esp+24], eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	test	eax, eax
	je	SHORT $LN8@Add
	mov	ecx, eax
	call	??0CvArea@@QAE@XZ			; CvArea::CvArea
	jmp	SHORT $LN9@Add
$LN8@Add:
	xor	eax, eax
$LN9@Add:
	mov	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [ecx+edi*8+4], eax

; 236  : 	m_pArray[iIndex].iNextFreeIndex = FFreeList::INVALID_INDEX;

	mov	edx, DWORD PTR [esi+24]
	mov	DWORD PTR [edx+edi*8], -1

; 237  : 
; 238  : 	m_pArray[iIndex].pData->SetID(m_iCurrentID + iIndex);

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+edi*8+4]
	add	eax, edi
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	?SetID@CvArea@@QAEXH@Z			; CvArea::SetID

; 239  : 	m_iCurrentID += FLTA_MAX_BUCKETS;
; 240  : 
; 241  : 	return m_pArray[iIndex].pData;

	mov	edx, DWORD PTR [esi+24]
	add	DWORD PTR [esi+20], 8192		; 00002000H
	mov	eax, DWORD PTR [edx+edi*8+4]

; 242  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ$0:
	mov	eax, DWORD PTR $T237999[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ ENDP ; FFreeListTrashArray<CvArea>::Add
PUBLIC	?NextIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ; FFreeListArrayBase<CvArea>::NextIter
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
;	COMDAT ?NextIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z
_TEXT	SEGMENT
_pIterIdx$ = 8						; size = 4
?NextIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z PROC ; FFreeListArrayBase<CvArea>::NextIter, COMDAT
; _this$ = ecx

; 127  : {

	push	esi

; 128  : 	for( ; (*pIterIdx)<GetIndexAfterLast(); (*pIterIdx)++)

	mov	esi, DWORD PTR _pIterIdx$[esp]
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi+12]
	inc	eax
	cmp	DWORD PTR [esi], eax
	jge	SHORT $LN2@NextIter
$LL4@NextIter:

; 129  : 	{
; 130  : 		T* pObj = GetAt((*pIterIdx));

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+16]
	push	eax
	mov	ecx, edi
	call	edx
	inc	DWORD PTR [esi]

; 131  : 		if (pObj)

	test	eax, eax
	jne	SHORT $LN5@NextIter
	mov	eax, DWORD PTR [edi+12]
	inc	eax
	cmp	DWORD PTR [esi], eax
	jl	SHORT $LL4@NextIter
$LN2@NextIter:

; 132  : 		{
; 133  : 			(*pIterIdx)++;	// prime for next call
; 134  : 			return pObj;
; 135  : 		}
; 136  : 	}
; 137  : 	return NULL;

	xor	eax, eax
$LN5@NextIter:
	pop	edi
	pop	esi

; 138  : }

	ret	4
?NextIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ENDP ; FFreeListArrayBase<CvArea>::NextIter
_TEXT	ENDS
PUBLIC	?PrevIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ; FFreeListArrayBase<CvArea>::PrevIter
; Function compile flags: /Ogtpy
;	COMDAT ?PrevIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z
_TEXT	SEGMENT
_pIterIdx$ = 8						; size = 4
?PrevIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z PROC ; FFreeListArrayBase<CvArea>::PrevIter, COMDAT
; _this$ = ecx

; 151  : {

	push	esi

; 152  : 	for( ; (*pIterIdx)>=0; (*pIterIdx)--)

	mov	esi, DWORD PTR _pIterIdx$[esp]
	cmp	DWORD PTR [esi], 0
	push	edi
	mov	edi, ecx
	jl	SHORT $LN2@PrevIter
	npad	3
$LL4@PrevIter:

; 153  : 	{
; 154  : 		T* pObj = GetAt((*pIterIdx));

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, edi
	call	edx
	dec	DWORD PTR [esi]

; 155  : 		if (pObj)

	test	eax, eax
	jne	SHORT $LN5@PrevIter

; 152  : 	for( ; (*pIterIdx)>=0; (*pIterIdx)--)

	cmp	DWORD PTR [esi], eax
	jge	SHORT $LL4@PrevIter
$LN2@PrevIter:

; 156  : 		{
; 157  : 			(*pIterIdx)--;	// prime for next call
; 158  : 			return pObj;
; 159  : 		}
; 160  : 	}
; 161  : 	return NULL;

	xor	eax, eax
$LN5@PrevIter:
	pop	edi
	pop	esi

; 162  : }

	ret	4
?PrevIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ENDP ; FFreeListArrayBase<CvArea>::PrevIter
_TEXT	ENDS
PUBLIC	?Add@?$FFreeListTrashArray@VCvLandmass@@@@QAEPAVCvLandmass@@XZ ; FFreeListTrashArray<CvLandmass>::Add
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
;	COMDAT ?Add@?$FFreeListTrashArray@VCvLandmass@@@@QAEPAVCvLandmass@@XZ
_TEXT	SEGMENT
?Add@?$FFreeListTrashArray@VCvLandmass@@@@QAEPAVCvLandmass@@XZ PROC ; FFreeListTrashArray<CvLandmass>::Add, COMDAT
; _this$ = ecx

; 204  : {

	push	ebx
	push	esi
	mov	esi, ecx

; 205  : 	int iIndex;
; 206  : 
; 207  : 	if (m_pArray == NULL) 

	xor	ebx, ebx
	cmp	DWORD PTR [esi+24], ebx
	jne	SHORT $LN5@Add@2

; 208  : 	{
; 209  : 		Init();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+4]
	push	8
	call	edx
$LN5@Add@2:

; 210  : 	}
; 211  : 
; 212  : 	if ((this->m_iLastIndex == this->m_iNumSlots - 1) &&
; 213  : 		(this->m_iFreeListCount == 0))

	mov	eax, DWORD PTR [esi+16]
	lea	ecx, DWORD PTR [eax-1]
	cmp	DWORD PTR [esi+12], ecx
	jne	SHORT $LN4@Add@2
	cmp	DWORD PTR [esi+8], ebx
	jne	SHORT $LN4@Add@2

; 214  : 	{
; 215  : 		if ((this->m_iNumSlots * FLTA_GROWTH_FACTOR) > FLTA_MAX_BUCKETS)

	lea	edx, DWORD PTR [eax+eax]
	cmp	edx, 8192				; 00002000H
	jle	SHORT $LN3@Add@2
	pop	esi

; 216  : 		{
; 217  : 			return NULL;

	xor	eax, eax
	pop	ebx

; 242  : }

	ret	0
$LN3@Add@2:

; 218  : 		}
; 219  : 
; 220  : 		GrowArray();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+24]
	mov	ecx, esi
	call	edx
$LN4@Add@2:

; 221  : 	}
; 222  : 
; 223  : 	if (this->m_iFreeListCount > 0)

	mov	eax, DWORD PTR [esi+8]
	cmp	eax, ebx
	push	edi
	jle	SHORT $LN2@Add@2

; 224  : 	{
; 225  : 		iIndex = this->m_iFreeListHead;

	mov	edi, DWORD PTR [esi+4]

; 226  : 		this->m_iFreeListHead = m_pArray[this->m_iFreeListHead].iNextFreeIndex;

	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [ecx+edi*8]

; 227  : 		this->m_iFreeListCount--;

	dec	eax
	mov	DWORD PTR [esi+4], edx
	mov	DWORD PTR [esi+8], eax

; 228  : 	}
; 229  : 	else

	jmp	SHORT $LN1@Add@2
$LN2@Add@2:

; 230  : 	{
; 231  : 		this->m_iLastIndex++;

	inc	DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+12]
$LN1@Add@2:

; 232  : 		iIndex = this->m_iLastIndex;
; 233  : 	}
; 234  : 
; 235  : 	m_pArray[iIndex].pData = FNEW( T, c_eMPoolTypeContainer, 0 );

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN8@Add@2
	mov	DWORD PTR [eax], OFFSET ??_7CvLandmass@@6B@
	mov	DWORD PTR [eax+4], -1
	mov	DWORD PTR [eax+8], ebx
	mov	BYTE PTR [eax+13], 1
	mov	BYTE PTR [eax+12], bl
	mov	DWORD PTR [eax+16], ebx
	mov	DWORD PTR [eax+20], ebx
	jmp	SHORT $LN9@Add@2
$LN8@Add@2:
	xor	eax, eax
$LN9@Add@2:
	mov	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [ecx+edi*8+4], eax

; 236  : 	m_pArray[iIndex].iNextFreeIndex = FFreeList::INVALID_INDEX;

	mov	edx, DWORD PTR [esi+24]
	mov	DWORD PTR [edx+edi*8], -1

; 237  : 
; 238  : 	m_pArray[iIndex].pData->SetID(m_iCurrentID + iIndex);

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [ecx+edi*8+4]
	add	eax, edi
	mov	DWORD PTR [edx+4], eax

; 239  : 	m_iCurrentID += FLTA_MAX_BUCKETS;
; 240  : 
; 241  : 	return m_pArray[iIndex].pData;

	mov	eax, DWORD PTR [esi+24]
	add	DWORD PTR [esi+20], 8192		; 00002000H
	mov	eax, DWORD PTR [eax+edi*8+4]
	pop	edi
	pop	esi
	pop	ebx

; 242  : }

	ret	0
?Add@?$FFreeListTrashArray@VCvLandmass@@@@QAEPAVCvLandmass@@XZ ENDP ; FFreeListTrashArray<CvLandmass>::Add
_TEXT	ENDS
PUBLIC	?RemoveAt@?$FFreeListTrashArray@VCvLandmass@@@@QAE_NH@Z ; FFreeListTrashArray<CvLandmass>::RemoveAt
; Function compile flags: /Ogtpy
;	COMDAT ?RemoveAt@?$FFreeListTrashArray@VCvLandmass@@@@QAE_NH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?RemoveAt@?$FFreeListTrashArray@VCvLandmass@@@@QAE_NH@Z PROC ; FFreeListTrashArray<CvLandmass>::RemoveAt, COMDAT
; _this$ = ecx

; 322  : 	int iIndex;
; 323  : 
; 324  : 	if ((iID == FFreeList::INVALID_INDEX) || (m_pArray == NULL))

	mov	edx, DWORD PTR _iID$[esp-4]
	push	esi
	mov	esi, ecx
	cmp	edx, -1
	je	SHORT $LN5@RemoveAt
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN5@RemoveAt
	push	edi

; 327  : 	}
; 328  : 
; 329  : 	iIndex = (iID & FLTA_INDEX_MASK);

	mov	edi, edx
	and	edi, 8191				; 00001fffH

; 330  : 
; 331  : 	assert(iIndex >= 0);
; 332  : 
; 333  : 	if ((iIndex <= this->m_iLastIndex) && 
; 334  : 		(m_pArray[iIndex].pData != NULL))

	cmp	edi, DWORD PTR [esi+12]
	jg	SHORT $LN3@RemoveAt
	mov	ecx, DWORD PTR [eax+edi*8+4]
	test	ecx, ecx
	je	SHORT $LN3@RemoveAt

; 335  : 	{
; 336  : 		if (((iID & FLTA_ID_MASK) == 0) || (m_pArray[iIndex].pData->GetID() == iID))

	test	edx, -8192				; ffffe000H
	je	SHORT $LN2@RemoveAt
	cmp	DWORD PTR [ecx+4], edx
	jne	SHORT $LN3@RemoveAt
$LN2@RemoveAt:

; 337  : 		{
; 338  : 			delete m_pArray[iIndex].pData;

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx

; 339  : 			m_pArray[iIndex].pData = NULL;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+edi*8+4], 0

; 340  : 
; 341  : 			m_pArray[iIndex].iNextFreeIndex = this->m_iFreeListHead;

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [ecx+edi*8], edx

; 342  : 			this->m_iFreeListHead = iIndex;
; 343  : 			this->m_iFreeListCount++;

	inc	DWORD PTR [esi+8]
	mov	DWORD PTR [esi+4], edi
	pop	edi

; 344  : 
; 345  : 			return true;

	mov	al, 1
	pop	esi

; 354  : }

	ret	4
$LN3@RemoveAt:
	pop	edi

; 346  : 		}
; 347  : 		else
; 348  : 		{
; 349  : 			assert(false);
; 350  : 		}
; 351  : 	}
; 352  : 
; 353  : 	return false;

	xor	al, al
	pop	esi

; 354  : }

	ret	4
$LN5@RemoveAt:

; 325  : 	{
; 326  : 		return false;

	xor	al, al
	pop	esi

; 354  : }

	ret	4
?RemoveAt@?$FFreeListTrashArray@VCvLandmass@@@@QAE_NH@Z ENDP ; FFreeListTrashArray<CvLandmass>::RemoveAt
_TEXT	ENDS
PUBLIC	?NextIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ; FFreeListArrayBase<CvLandmass>::NextIter
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
;	COMDAT ?NextIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z
_TEXT	SEGMENT
_pIterIdx$ = 8						; size = 4
?NextIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z PROC ; FFreeListArrayBase<CvLandmass>::NextIter, COMDAT
; _this$ = ecx

; 127  : {

	push	esi

; 128  : 	for( ; (*pIterIdx)<GetIndexAfterLast(); (*pIterIdx)++)

	mov	esi, DWORD PTR _pIterIdx$[esp]
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi+12]
	inc	eax
	cmp	DWORD PTR [esi], eax
	jge	SHORT $LN2@NextIter@2
$LL4@NextIter@2:

; 129  : 	{
; 130  : 		T* pObj = GetAt((*pIterIdx));

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+16]
	push	eax
	mov	ecx, edi
	call	edx
	inc	DWORD PTR [esi]

; 131  : 		if (pObj)

	test	eax, eax
	jne	SHORT $LN5@NextIter@2
	mov	eax, DWORD PTR [edi+12]
	inc	eax
	cmp	DWORD PTR [esi], eax
	jl	SHORT $LL4@NextIter@2
$LN2@NextIter@2:

; 132  : 		{
; 133  : 			(*pIterIdx)++;	// prime for next call
; 134  : 			return pObj;
; 135  : 		}
; 136  : 	}
; 137  : 	return NULL;

	xor	eax, eax
$LN5@NextIter@2:
	pop	edi
	pop	esi

; 138  : }

	ret	4
?NextIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ENDP ; FFreeListArrayBase<CvLandmass>::NextIter
_TEXT	ENDS
PUBLIC	?PrevIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ; FFreeListArrayBase<CvLandmass>::PrevIter
; Function compile flags: /Ogtpy
;	COMDAT ?PrevIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z
_TEXT	SEGMENT
_pIterIdx$ = 8						; size = 4
?PrevIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z PROC ; FFreeListArrayBase<CvLandmass>::PrevIter, COMDAT
; _this$ = ecx

; 151  : {

	push	esi

; 152  : 	for( ; (*pIterIdx)>=0; (*pIterIdx)--)

	mov	esi, DWORD PTR _pIterIdx$[esp]
	cmp	DWORD PTR [esi], 0
	push	edi
	mov	edi, ecx
	jl	SHORT $LN2@PrevIter@2
	npad	3
$LL4@PrevIter@2:

; 153  : 	{
; 154  : 		T* pObj = GetAt((*pIterIdx));

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, edi
	call	edx
	dec	DWORD PTR [esi]

; 155  : 		if (pObj)

	test	eax, eax
	jne	SHORT $LN5@PrevIter@2

; 152  : 	for( ; (*pIterIdx)>=0; (*pIterIdx)--)

	cmp	DWORD PTR [esi], eax
	jge	SHORT $LL4@PrevIter@2
$LN2@PrevIter@2:

; 156  : 		{
; 157  : 			(*pIterIdx)--;	// prime for next call
; 158  : 			return pObj;
; 159  : 		}
; 160  : 	}
; 161  : 	return NULL;

	xor	eax, eax
$LN5@PrevIter@2:
	pop	edi
	pop	esi

; 162  : }

	ret	4
?PrevIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ENDP ; FFreeListArrayBase<CvLandmass>::PrevIter
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z		; SAFE_DELETE_ARRAY<int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z PROC			; SAFE_DELETE_ARRAY<int>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z ENDP			; SAFE_DELETE_ARRAY<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@VCvPlot@@@@YAXAAPAVCvPlot@@@Z ; SAFE_DELETE_ARRAY<CvPlot>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@VCvPlot@@@@YAXAAPAVCvPlot@@@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@VCvPlot@@@@YAXAAPAVCvPlot@@@Z PROC	; SAFE_DELETE_ARRAY<CvPlot>, COMDAT

; 311  : {

	push	edi

; 312  : 	delete[] pkInstanceArray;

	mov	edi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN10@SAFE_DELET
	mov	ecx, DWORD PTR [eax-4]
	push	esi
	lea	esi, DWORD PTR [eax-4]
	push	OFFSET ??1CvPlot@@QAE@XZ		; CvPlot::~CvPlot
	push	ecx
	push	484					; 000001e4H
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	pop	esi
$LN10@SAFE_DELET:

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@VCvPlot@@@@YAXAAPAVCvPlot@@@Z ENDP	; SAFE_DELETE_ARRAY<CvPlot>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@F@@YAXAAPAF@Z		; SAFE_DELETE_ARRAY<short>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@F@@YAXAAPAF@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@F@@YAXAAPAF@Z PROC			; SAFE_DELETE_ARRAY<short>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@F@@YAXAAPAF@Z ENDP			; SAFE_DELETE_ARRAY<short>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@D@@YAXAAPAD@Z		; SAFE_DELETE_ARRAY<char>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@D@@YAXAAPAD@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@D@@YAXAAPAD@Z PROC			; SAFE_DELETE_ARRAY<char>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@D@@YAXAAPAD@Z ENDP			; SAFE_DELETE_ARRAY<char>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z		; SAFE_DELETE_ARRAY<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z PROC		; SAFE_DELETE_ARRAY<bool>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z ENDP		; SAFE_DELETE_ARRAY<bool>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	??$?5K@FDataStream@@QAEAAV0@AAK@Z		; FDataStream::operator>><unsigned long>
EXTRN	?Read@FDataStream@@IAEXAAK@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5K@FDataStream@@QAEAAV0@AAK@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5K@FDataStream@@QAEAAV0@AAK@Z PROC			; FDataStream::operator>><unsigned long>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAK@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5K@FDataStream@@QAEAAV0@AAK@Z ENDP			; FDataStream::operator>><unsigned long>
_TEXT	ENDS
PUBLIC	??$?5G@FDataStream@@QAEAAV0@AAG@Z		; FDataStream::operator>><unsigned short>
EXTRN	?Read@FDataStream@@IAEXAAG@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5G@FDataStream@@QAEAAV0@AAG@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5G@FDataStream@@QAEAAV0@AAG@Z PROC			; FDataStream::operator>><unsigned short>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAG@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5G@FDataStream@@QAEAAV0@AAG@Z ENDP			; FDataStream::operator>><unsigned short>
_TEXT	ENDS
PUBLIC	??$?6K@FDataStream@@QAEAAV0@ABK@Z		; FDataStream::operator<<<unsigned long>
EXTRN	?Write@FDataStream@@IAEXABK@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6K@FDataStream@@QAEAAV0@ABK@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6K@FDataStream@@QAEAAV0@ABK@Z PROC			; FDataStream::operator<<<unsigned long>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABK@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6K@FDataStream@@QAEAAV0@ABK@Z ENDP			; FDataStream::operator<<<unsigned long>
_TEXT	ENDS
PUBLIC	??$?6G@FDataStream@@QAEAAV0@ABG@Z		; FDataStream::operator<<<unsigned short>
EXTRN	?Write@FDataStream@@IAEXABG@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6G@FDataStream@@QAEAAV0@ABG@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6G@FDataStream@@QAEAAV0@ABG@Z PROC			; FDataStream::operator<<<unsigned short>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABG@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6G@FDataStream@@QAEAAV0@ABG@Z ENDP			; FDataStream::operator<<<unsigned short>
_TEXT	ENDS
PUBLIC	?GetNumSlots@?$FFreeListTrashArray@VCvArea@@@@QBEHXZ ; FFreeListTrashArray<CvArea>::GetNumSlots
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
;	COMDAT ?GetNumSlots@?$FFreeListTrashArray@VCvArea@@@@QBEHXZ
_TEXT	SEGMENT
?GetNumSlots@?$FFreeListTrashArray@VCvArea@@@@QBEHXZ PROC ; FFreeListTrashArray<CvArea>::GetNumSlots, COMDAT
; _this$ = ecx

; 49   : 		return this->m_iNumSlots;

	mov	eax, DWORD PTR [ecx+16]

; 50   : 	}

	ret	0
?GetNumSlots@?$FFreeListTrashArray@VCvArea@@@@QBEHXZ ENDP ; FFreeListTrashArray<CvArea>::GetNumSlots
_TEXT	ENDS
PUBLIC	?GetLastIndex@?$FFreeListTrashArray@VCvArea@@@@QBEHXZ ; FFreeListTrashArray<CvArea>::GetLastIndex
; Function compile flags: /Ogtpy
;	COMDAT ?GetLastIndex@?$FFreeListTrashArray@VCvArea@@@@QBEHXZ
_TEXT	SEGMENT
?GetLastIndex@?$FFreeListTrashArray@VCvArea@@@@QBEHXZ PROC ; FFreeListTrashArray<CvArea>::GetLastIndex, COMDAT
; _this$ = ecx

; 54   : 		return this->m_iLastIndex;

	mov	eax, DWORD PTR [ecx+12]

; 55   : 	}

	ret	0
?GetLastIndex@?$FFreeListTrashArray@VCvArea@@@@QBEHXZ ENDP ; FFreeListTrashArray<CvArea>::GetLastIndex
_TEXT	ENDS
PUBLIC	?SetLastIndex@?$FFreeListTrashArray@VCvArea@@@@QAEXH@Z ; FFreeListTrashArray<CvArea>::SetLastIndex
; Function compile flags: /Ogtpy
;	COMDAT ?SetLastIndex@?$FFreeListTrashArray@VCvArea@@@@QAEXH@Z
_TEXT	SEGMENT
_iNewValue$ = 8						; size = 4
?SetLastIndex@?$FFreeListTrashArray@VCvArea@@@@QAEXH@Z PROC ; FFreeListTrashArray<CvArea>::SetLastIndex, COMDAT
; _this$ = ecx

; 58   : 		this->m_iLastIndex = iNewValue;

	mov	eax, DWORD PTR _iNewValue$[esp-4]
	mov	DWORD PTR [ecx+12], eax

; 59   : 	}

	ret	4
?SetLastIndex@?$FFreeListTrashArray@VCvArea@@@@QAEXH@Z ENDP ; FFreeListTrashArray<CvArea>::SetLastIndex
_TEXT	ENDS
PUBLIC	?GetFreeListHead@?$FFreeListTrashArray@VCvArea@@@@QBEHXZ ; FFreeListTrashArray<CvArea>::GetFreeListHead
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeListHead@?$FFreeListTrashArray@VCvArea@@@@QBEHXZ
_TEXT	SEGMENT
?GetFreeListHead@?$FFreeListTrashArray@VCvArea@@@@QBEHXZ PROC ; FFreeListTrashArray<CvArea>::GetFreeListHead, COMDAT
; _this$ = ecx

; 63   : 		return this->m_iFreeListHead;

	mov	eax, DWORD PTR [ecx+4]

; 64   : 	}

	ret	0
?GetFreeListHead@?$FFreeListTrashArray@VCvArea@@@@QBEHXZ ENDP ; FFreeListTrashArray<CvArea>::GetFreeListHead
_TEXT	ENDS
PUBLIC	?SetFreeListHead@?$FFreeListTrashArray@VCvArea@@@@QAEXH@Z ; FFreeListTrashArray<CvArea>::SetFreeListHead
; Function compile flags: /Ogtpy
;	COMDAT ?SetFreeListHead@?$FFreeListTrashArray@VCvArea@@@@QAEXH@Z
_TEXT	SEGMENT
_iNewValue$ = 8						; size = 4
?SetFreeListHead@?$FFreeListTrashArray@VCvArea@@@@QAEXH@Z PROC ; FFreeListTrashArray<CvArea>::SetFreeListHead, COMDAT
; _this$ = ecx

; 67   : 		this->m_iFreeListHead = iNewValue;

	mov	eax, DWORD PTR _iNewValue$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 68   : 	}

	ret	4
?SetFreeListHead@?$FFreeListTrashArray@VCvArea@@@@QAEXH@Z ENDP ; FFreeListTrashArray<CvArea>::SetFreeListHead
_TEXT	ENDS
PUBLIC	?GetFreeListCount@?$FFreeListTrashArray@VCvArea@@@@QBEHXZ ; FFreeListTrashArray<CvArea>::GetFreeListCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeListCount@?$FFreeListTrashArray@VCvArea@@@@QBEHXZ
_TEXT	SEGMENT
?GetFreeListCount@?$FFreeListTrashArray@VCvArea@@@@QBEHXZ PROC ; FFreeListTrashArray<CvArea>::GetFreeListCount, COMDAT
; _this$ = ecx

; 72   : 		return this->m_iFreeListCount;

	mov	eax, DWORD PTR [ecx+8]

; 73   : 	}

	ret	0
?GetFreeListCount@?$FFreeListTrashArray@VCvArea@@@@QBEHXZ ENDP ; FFreeListTrashArray<CvArea>::GetFreeListCount
_TEXT	ENDS
PUBLIC	?SetFreeListCount@?$FFreeListTrashArray@VCvArea@@@@QAEXH@Z ; FFreeListTrashArray<CvArea>::SetFreeListCount
; Function compile flags: /Ogtpy
;	COMDAT ?SetFreeListCount@?$FFreeListTrashArray@VCvArea@@@@QAEXH@Z
_TEXT	SEGMENT
_iNewValue$ = 8						; size = 4
?SetFreeListCount@?$FFreeListTrashArray@VCvArea@@@@QAEXH@Z PROC ; FFreeListTrashArray<CvArea>::SetFreeListCount, COMDAT
; _this$ = ecx

; 76   : 		this->m_iFreeListCount = iNewValue;

	mov	eax, DWORD PTR _iNewValue$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 77   : 	}

	ret	4
?SetFreeListCount@?$FFreeListTrashArray@VCvArea@@@@QAEXH@Z ENDP ; FFreeListTrashArray<CvArea>::SetFreeListCount
_TEXT	ENDS
PUBLIC	?GetCurrentID@?$FFreeListTrashArray@VCvArea@@@@QBEHXZ ; FFreeListTrashArray<CvArea>::GetCurrentID
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentID@?$FFreeListTrashArray@VCvArea@@@@QBEHXZ
_TEXT	SEGMENT
?GetCurrentID@?$FFreeListTrashArray@VCvArea@@@@QBEHXZ PROC ; FFreeListTrashArray<CvArea>::GetCurrentID, COMDAT
; _this$ = ecx

; 81   : 		return m_iCurrentID;

	mov	eax, DWORD PTR [ecx+20]

; 82   : 	}

	ret	0
?GetCurrentID@?$FFreeListTrashArray@VCvArea@@@@QBEHXZ ENDP ; FFreeListTrashArray<CvArea>::GetCurrentID
_TEXT	ENDS
PUBLIC	?SetCurrentID@?$FFreeListTrashArray@VCvArea@@@@QAEXH@Z ; FFreeListTrashArray<CvArea>::SetCurrentID
; Function compile flags: /Ogtpy
;	COMDAT ?SetCurrentID@?$FFreeListTrashArray@VCvArea@@@@QAEXH@Z
_TEXT	SEGMENT
_iNewValue$ = 8						; size = 4
?SetCurrentID@?$FFreeListTrashArray@VCvArea@@@@QAEXH@Z PROC ; FFreeListTrashArray<CvArea>::SetCurrentID, COMDAT
; _this$ = ecx

; 85   : 		assert((iNewValue & FLTA_INDEX_MASK) == 0);
; 86   : 		assert((iNewValue & FLTA_ID_MASK) != 0);
; 87   : 		m_iCurrentID = iNewValue;

	mov	eax, DWORD PTR _iNewValue$[esp-4]
	mov	DWORD PTR [ecx+20], eax

; 88   : 	}

	ret	4
?SetCurrentID@?$FFreeListTrashArray@VCvArea@@@@QAEXH@Z ENDP ; FFreeListTrashArray<CvArea>::SetCurrentID
_TEXT	ENDS
PUBLIC	?GetNextFreeIndex@?$FFreeListTrashArray@VCvArea@@@@QBEHH@Z ; FFreeListTrashArray<CvArea>::GetNextFreeIndex
; Function compile flags: /Ogtpy
;	COMDAT ?GetNextFreeIndex@?$FFreeListTrashArray@VCvArea@@@@QBEHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetNextFreeIndex@?$FFreeListTrashArray@VCvArea@@@@QBEHH@Z PROC ; FFreeListTrashArray<CvArea>::GetNextFreeIndex, COMDAT
; _this$ = ecx

; 92   : 		if ((iIndex >= GetNumSlots()) || (m_pArray == NULL))

	mov	edx, DWORD PTR _iIndex$[esp-4]
	cmp	edx, DWORD PTR [ecx+16]
	jge	SHORT $LN1@GetNextFre
	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	je	SHORT $LN1@GetNextFre

; 96   : 		}
; 97   : 		return m_pArray[iIndex].iNextFreeIndex;

	mov	eax, DWORD PTR [eax+edx*8]

; 98   : 	}

	ret	4
$LN1@GetNextFre:

; 93   : 		{
; 94   : 			assert(false);
; 95   : 			return FFreeList::INVALID_INDEX;

	or	eax, -1

; 98   : 	}

	ret	4
?GetNextFreeIndex@?$FFreeListTrashArray@VCvArea@@@@QBEHH@Z ENDP ; FFreeListTrashArray<CvArea>::GetNextFreeIndex
_TEXT	ENDS
PUBLIC	?SetNextFreeIndex@?$FFreeListTrashArray@VCvArea@@@@QAEXHH@Z ; FFreeListTrashArray<CvArea>::SetNextFreeIndex
; Function compile flags: /Ogtpy
;	COMDAT ?SetNextFreeIndex@?$FFreeListTrashArray@VCvArea@@@@QAEXHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetNextFreeIndex@?$FFreeListTrashArray@VCvArea@@@@QAEXHH@Z PROC ; FFreeListTrashArray<CvArea>::SetNextFreeIndex, COMDAT
; _this$ = ecx

; 101  : 		if ((iIndex >= GetNumSlots()) || (m_pArray == NULL))

	mov	edx, DWORD PTR _iIndex$[esp-4]
	cmp	edx, DWORD PTR [ecx+16]
	jge	SHORT $LN1@SetNextFre
	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	je	SHORT $LN1@SetNextFre

; 102  : 		{
; 103  : 			assert(false);
; 104  : 			return;
; 105  : 		}
; 106  : 		m_pArray[iIndex].iNextFreeIndex = iNewValue;

	mov	ecx, DWORD PTR _iNewValue$[esp-4]
	mov	DWORD PTR [eax+edx*8], ecx
$LN1@SetNextFre:

; 107  : 	}

	ret	8
?SetNextFreeIndex@?$FFreeListTrashArray@VCvArea@@@@QAEXHH@Z ENDP ; FFreeListTrashArray<CvArea>::SetNextFreeIndex
_TEXT	ENDS
PUBLIC	?GetIndexAfterLast@?$FFreeListArrayBase@VCvArea@@@@QBEHXZ ; FFreeListArrayBase<CvArea>::GetIndexAfterLast
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
;	COMDAT ?GetIndexAfterLast@?$FFreeListArrayBase@VCvArea@@@@QBEHXZ
_TEXT	SEGMENT
?GetIndexAfterLast@?$FFreeListArrayBase@VCvArea@@@@QBEHXZ PROC ; FFreeListArrayBase<CvArea>::GetIndexAfterLast, COMDAT
; _this$ = ecx

; 71   : 	int GetIndexAfterLast()	const {	return m_iLastIndex + 1;	}

	mov	eax, DWORD PTR [ecx+12]
	inc	eax
	ret	0
?GetIndexAfterLast@?$FFreeListArrayBase@VCvArea@@@@QBEHXZ ENDP ; FFreeListArrayBase<CvArea>::GetIndexAfterLast
_TEXT	ENDS
PUBLIC	?GetNumSlots@?$FFreeListTrashArray@VCvLandmass@@@@QBEHXZ ; FFreeListTrashArray<CvLandmass>::GetNumSlots
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
;	COMDAT ?GetNumSlots@?$FFreeListTrashArray@VCvLandmass@@@@QBEHXZ
_TEXT	SEGMENT
?GetNumSlots@?$FFreeListTrashArray@VCvLandmass@@@@QBEHXZ PROC ; FFreeListTrashArray<CvLandmass>::GetNumSlots, COMDAT
; _this$ = ecx

; 49   : 		return this->m_iNumSlots;

	mov	eax, DWORD PTR [ecx+16]

; 50   : 	}

	ret	0
?GetNumSlots@?$FFreeListTrashArray@VCvLandmass@@@@QBEHXZ ENDP ; FFreeListTrashArray<CvLandmass>::GetNumSlots
_TEXT	ENDS
PUBLIC	?GetLastIndex@?$FFreeListTrashArray@VCvLandmass@@@@QBEHXZ ; FFreeListTrashArray<CvLandmass>::GetLastIndex
; Function compile flags: /Ogtpy
;	COMDAT ?GetLastIndex@?$FFreeListTrashArray@VCvLandmass@@@@QBEHXZ
_TEXT	SEGMENT
?GetLastIndex@?$FFreeListTrashArray@VCvLandmass@@@@QBEHXZ PROC ; FFreeListTrashArray<CvLandmass>::GetLastIndex, COMDAT
; _this$ = ecx

; 54   : 		return this->m_iLastIndex;

	mov	eax, DWORD PTR [ecx+12]

; 55   : 	}

	ret	0
?GetLastIndex@?$FFreeListTrashArray@VCvLandmass@@@@QBEHXZ ENDP ; FFreeListTrashArray<CvLandmass>::GetLastIndex
_TEXT	ENDS
PUBLIC	?SetLastIndex@?$FFreeListTrashArray@VCvLandmass@@@@QAEXH@Z ; FFreeListTrashArray<CvLandmass>::SetLastIndex
; Function compile flags: /Ogtpy
;	COMDAT ?SetLastIndex@?$FFreeListTrashArray@VCvLandmass@@@@QAEXH@Z
_TEXT	SEGMENT
_iNewValue$ = 8						; size = 4
?SetLastIndex@?$FFreeListTrashArray@VCvLandmass@@@@QAEXH@Z PROC ; FFreeListTrashArray<CvLandmass>::SetLastIndex, COMDAT
; _this$ = ecx

; 58   : 		this->m_iLastIndex = iNewValue;

	mov	eax, DWORD PTR _iNewValue$[esp-4]
	mov	DWORD PTR [ecx+12], eax

; 59   : 	}

	ret	4
?SetLastIndex@?$FFreeListTrashArray@VCvLandmass@@@@QAEXH@Z ENDP ; FFreeListTrashArray<CvLandmass>::SetLastIndex
_TEXT	ENDS
PUBLIC	?GetFreeListHead@?$FFreeListTrashArray@VCvLandmass@@@@QBEHXZ ; FFreeListTrashArray<CvLandmass>::GetFreeListHead
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeListHead@?$FFreeListTrashArray@VCvLandmass@@@@QBEHXZ
_TEXT	SEGMENT
?GetFreeListHead@?$FFreeListTrashArray@VCvLandmass@@@@QBEHXZ PROC ; FFreeListTrashArray<CvLandmass>::GetFreeListHead, COMDAT
; _this$ = ecx

; 63   : 		return this->m_iFreeListHead;

	mov	eax, DWORD PTR [ecx+4]

; 64   : 	}

	ret	0
?GetFreeListHead@?$FFreeListTrashArray@VCvLandmass@@@@QBEHXZ ENDP ; FFreeListTrashArray<CvLandmass>::GetFreeListHead
_TEXT	ENDS
PUBLIC	?SetFreeListHead@?$FFreeListTrashArray@VCvLandmass@@@@QAEXH@Z ; FFreeListTrashArray<CvLandmass>::SetFreeListHead
; Function compile flags: /Ogtpy
;	COMDAT ?SetFreeListHead@?$FFreeListTrashArray@VCvLandmass@@@@QAEXH@Z
_TEXT	SEGMENT
_iNewValue$ = 8						; size = 4
?SetFreeListHead@?$FFreeListTrashArray@VCvLandmass@@@@QAEXH@Z PROC ; FFreeListTrashArray<CvLandmass>::SetFreeListHead, COMDAT
; _this$ = ecx

; 67   : 		this->m_iFreeListHead = iNewValue;

	mov	eax, DWORD PTR _iNewValue$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 68   : 	}

	ret	4
?SetFreeListHead@?$FFreeListTrashArray@VCvLandmass@@@@QAEXH@Z ENDP ; FFreeListTrashArray<CvLandmass>::SetFreeListHead
_TEXT	ENDS
PUBLIC	?GetFreeListCount@?$FFreeListTrashArray@VCvLandmass@@@@QBEHXZ ; FFreeListTrashArray<CvLandmass>::GetFreeListCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeListCount@?$FFreeListTrashArray@VCvLandmass@@@@QBEHXZ
_TEXT	SEGMENT
?GetFreeListCount@?$FFreeListTrashArray@VCvLandmass@@@@QBEHXZ PROC ; FFreeListTrashArray<CvLandmass>::GetFreeListCount, COMDAT
; _this$ = ecx

; 72   : 		return this->m_iFreeListCount;

	mov	eax, DWORD PTR [ecx+8]

; 73   : 	}

	ret	0
?GetFreeListCount@?$FFreeListTrashArray@VCvLandmass@@@@QBEHXZ ENDP ; FFreeListTrashArray<CvLandmass>::GetFreeListCount
_TEXT	ENDS
PUBLIC	?SetFreeListCount@?$FFreeListTrashArray@VCvLandmass@@@@QAEXH@Z ; FFreeListTrashArray<CvLandmass>::SetFreeListCount
; Function compile flags: /Ogtpy
;	COMDAT ?SetFreeListCount@?$FFreeListTrashArray@VCvLandmass@@@@QAEXH@Z
_TEXT	SEGMENT
_iNewValue$ = 8						; size = 4
?SetFreeListCount@?$FFreeListTrashArray@VCvLandmass@@@@QAEXH@Z PROC ; FFreeListTrashArray<CvLandmass>::SetFreeListCount, COMDAT
; _this$ = ecx

; 76   : 		this->m_iFreeListCount = iNewValue;

	mov	eax, DWORD PTR _iNewValue$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 77   : 	}

	ret	4
?SetFreeListCount@?$FFreeListTrashArray@VCvLandmass@@@@QAEXH@Z ENDP ; FFreeListTrashArray<CvLandmass>::SetFreeListCount
_TEXT	ENDS
PUBLIC	?GetCurrentID@?$FFreeListTrashArray@VCvLandmass@@@@QBEHXZ ; FFreeListTrashArray<CvLandmass>::GetCurrentID
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentID@?$FFreeListTrashArray@VCvLandmass@@@@QBEHXZ
_TEXT	SEGMENT
?GetCurrentID@?$FFreeListTrashArray@VCvLandmass@@@@QBEHXZ PROC ; FFreeListTrashArray<CvLandmass>::GetCurrentID, COMDAT
; _this$ = ecx

; 81   : 		return m_iCurrentID;

	mov	eax, DWORD PTR [ecx+20]

; 82   : 	}

	ret	0
?GetCurrentID@?$FFreeListTrashArray@VCvLandmass@@@@QBEHXZ ENDP ; FFreeListTrashArray<CvLandmass>::GetCurrentID
_TEXT	ENDS
PUBLIC	?SetCurrentID@?$FFreeListTrashArray@VCvLandmass@@@@QAEXH@Z ; FFreeListTrashArray<CvLandmass>::SetCurrentID
; Function compile flags: /Ogtpy
;	COMDAT ?SetCurrentID@?$FFreeListTrashArray@VCvLandmass@@@@QAEXH@Z
_TEXT	SEGMENT
_iNewValue$ = 8						; size = 4
?SetCurrentID@?$FFreeListTrashArray@VCvLandmass@@@@QAEXH@Z PROC ; FFreeListTrashArray<CvLandmass>::SetCurrentID, COMDAT
; _this$ = ecx

; 85   : 		assert((iNewValue & FLTA_INDEX_MASK) == 0);
; 86   : 		assert((iNewValue & FLTA_ID_MASK) != 0);
; 87   : 		m_iCurrentID = iNewValue;

	mov	eax, DWORD PTR _iNewValue$[esp-4]
	mov	DWORD PTR [ecx+20], eax

; 88   : 	}

	ret	4
?SetCurrentID@?$FFreeListTrashArray@VCvLandmass@@@@QAEXH@Z ENDP ; FFreeListTrashArray<CvLandmass>::SetCurrentID
_TEXT	ENDS
PUBLIC	?GetNextFreeIndex@?$FFreeListTrashArray@VCvLandmass@@@@QBEHH@Z ; FFreeListTrashArray<CvLandmass>::GetNextFreeIndex
; Function compile flags: /Ogtpy
;	COMDAT ?GetNextFreeIndex@?$FFreeListTrashArray@VCvLandmass@@@@QBEHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetNextFreeIndex@?$FFreeListTrashArray@VCvLandmass@@@@QBEHH@Z PROC ; FFreeListTrashArray<CvLandmass>::GetNextFreeIndex, COMDAT
; _this$ = ecx

; 92   : 		if ((iIndex >= GetNumSlots()) || (m_pArray == NULL))

	mov	edx, DWORD PTR _iIndex$[esp-4]
	cmp	edx, DWORD PTR [ecx+16]
	jge	SHORT $LN1@GetNextFre@2
	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	je	SHORT $LN1@GetNextFre@2

; 96   : 		}
; 97   : 		return m_pArray[iIndex].iNextFreeIndex;

	mov	eax, DWORD PTR [eax+edx*8]

; 98   : 	}

	ret	4
$LN1@GetNextFre@2:

; 93   : 		{
; 94   : 			assert(false);
; 95   : 			return FFreeList::INVALID_INDEX;

	or	eax, -1

; 98   : 	}

	ret	4
?GetNextFreeIndex@?$FFreeListTrashArray@VCvLandmass@@@@QBEHH@Z ENDP ; FFreeListTrashArray<CvLandmass>::GetNextFreeIndex
_TEXT	ENDS
PUBLIC	?SetNextFreeIndex@?$FFreeListTrashArray@VCvLandmass@@@@QAEXHH@Z ; FFreeListTrashArray<CvLandmass>::SetNextFreeIndex
; Function compile flags: /Ogtpy
;	COMDAT ?SetNextFreeIndex@?$FFreeListTrashArray@VCvLandmass@@@@QAEXHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetNextFreeIndex@?$FFreeListTrashArray@VCvLandmass@@@@QAEXHH@Z PROC ; FFreeListTrashArray<CvLandmass>::SetNextFreeIndex, COMDAT
; _this$ = ecx

; 101  : 		if ((iIndex >= GetNumSlots()) || (m_pArray == NULL))

	mov	edx, DWORD PTR _iIndex$[esp-4]
	cmp	edx, DWORD PTR [ecx+16]
	jge	SHORT $LN1@SetNextFre@2
	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	je	SHORT $LN1@SetNextFre@2

; 102  : 		{
; 103  : 			assert(false);
; 104  : 			return;
; 105  : 		}
; 106  : 		m_pArray[iIndex].iNextFreeIndex = iNewValue;

	mov	ecx, DWORD PTR _iNewValue$[esp-4]
	mov	DWORD PTR [eax+edx*8], ecx
$LN1@SetNextFre@2:

; 107  : 	}

	ret	8
?SetNextFreeIndex@?$FFreeListTrashArray@VCvLandmass@@@@QAEXHH@Z ENDP ; FFreeListTrashArray<CvLandmass>::SetNextFreeIndex
_TEXT	ENDS
PUBLIC	?GetIndexAfterLast@?$FFreeListArrayBase@VCvLandmass@@@@QBEHXZ ; FFreeListArrayBase<CvLandmass>::GetIndexAfterLast
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
;	COMDAT ?GetIndexAfterLast@?$FFreeListArrayBase@VCvLandmass@@@@QBEHXZ
_TEXT	SEGMENT
?GetIndexAfterLast@?$FFreeListArrayBase@VCvLandmass@@@@QBEHXZ PROC ; FFreeListArrayBase<CvLandmass>::GetIndexAfterLast, COMDAT
; _this$ = ecx

; 71   : 	int GetIndexAfterLast()	const {	return m_iLastIndex + 1;	}

	mov	eax, DWORD PTR [ecx+12]
	inc	eax
	ret	0
?GetIndexAfterLast@?$FFreeListArrayBase@VCvLandmass@@@@QBEHXZ ENDP ; FFreeListArrayBase<CvLandmass>::GetIndexAfterLast
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@E@@QAEPAEXZ		; ArrayWrapper<unsigned char>::getArray
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ?getArray@?$ArrayWrapper@E@@QAEPAEXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@E@@QAEPAEXZ PROC		; ArrayWrapper<unsigned char>::getArray, COMDAT
; _this$ = ecx

; 382  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 383  : 	}

	ret	0
?getArray@?$ArrayWrapper@E@@QAEPAEXZ ENDP		; ArrayWrapper<unsigned char>::getArray
_TEXT	ENDS
PUBLIC	?getCount@?$ArrayWrapper@E@@QBEHXZ		; ArrayWrapper<unsigned char>::getCount
; Function compile flags: /Ogtpy
;	COMDAT ?getCount@?$ArrayWrapper@E@@QBEHXZ
_TEXT	SEGMENT
?getCount@?$ArrayWrapper@E@@QBEHXZ PROC			; ArrayWrapper<unsigned char>::getCount, COMDAT
; _this$ = ecx

; 391  : 		return m_count;

	mov	eax, DWORD PTR [ecx+4]

; 392  : 	}

	ret	0
?getCount@?$ArrayWrapper@E@@QBEHXZ ENDP			; ArrayWrapper<unsigned char>::getCount
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@$$CBE@@QBEPBEXZ	; ArrayWrapper<unsigned char const >::getArray
; Function compile flags: /Ogtpy
;	COMDAT ?getArray@?$ArrayWrapper@$$CBE@@QBEPBEXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@$$CBE@@QBEPBEXZ PROC		; ArrayWrapper<unsigned char const >::getArray, COMDAT
; _this$ = ecx

; 386  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 387  : 	}

	ret	0
?getArray@?$ArrayWrapper@$$CBE@@QBEPBEXZ ENDP		; ArrayWrapper<unsigned char const >::getArray
_TEXT	ENDS
PUBLIC	?getCount@?$ArrayWrapper@$$CBE@@QBEHXZ		; ArrayWrapper<unsigned char const >::getCount
; Function compile flags: /Ogtpy
;	COMDAT ?getCount@?$ArrayWrapper@$$CBE@@QBEHXZ
_TEXT	SEGMENT
?getCount@?$ArrayWrapper@$$CBE@@QBEHXZ PROC		; ArrayWrapper<unsigned char const >::getCount, COMDAT
; _this$ = ecx

; 391  : 		return m_count;

	mov	eax, DWORD PTR [ecx+4]

; 392  : 	}

	ret	0
?getCount@?$ArrayWrapper@$$CBE@@QBEHXZ ENDP		; ArrayWrapper<unsigned char const >::getCount
_TEXT	ENDS
PUBLIC	??_7?$FFreeListArrayBase@VCvArea@@@@6B@		; FFreeListArrayBase<CvArea>::`vftable'
PUBLIC	??0?$FFreeListArrayBase@VCvArea@@@@QAE@XZ	; FFreeListArrayBase<CvArea>::FFreeListArrayBase<CvArea>
PUBLIC	??_R4?$FFreeListArrayBase@VCvArea@@@@6B@	; FFreeListArrayBase<CvArea>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$FFreeListArrayBase@VCvArea@@@@@8	; FFreeListArrayBase<CvArea> `RTTI Type Descriptor'
PUBLIC	??_R3?$FFreeListArrayBase@VCvArea@@@@8		; FFreeListArrayBase<CvArea>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$FFreeListArrayBase@VCvArea@@@@8		; FFreeListArrayBase<CvArea>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$FFreeListArrayBase@VCvArea@@@@8	; FFreeListArrayBase<CvArea>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_E?$FFreeListArrayBase@VCvArea@@@@UAEPAXI@Z:PROC ; FFreeListArrayBase<CvArea>::`vector deleting destructor'
EXTRN	__purecall:PROC
;	COMDAT ??_R1A@?0A@EA@?$FFreeListArrayBase@VCvArea@@@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
rdata$r	SEGMENT
??_R1A@?0A@EA@?$FFreeListArrayBase@VCvArea@@@@8 DD FLAT:??_R0?AV?$FFreeListArrayBase@VCvArea@@@@@8 ; FFreeListArrayBase<CvArea>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$FFreeListArrayBase@VCvArea@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$FFreeListArrayBase@VCvArea@@@@8
rdata$r	SEGMENT
??_R2?$FFreeListArrayBase@VCvArea@@@@8 DD FLAT:??_R1A@?0A@EA@?$FFreeListArrayBase@VCvArea@@@@8 ; FFreeListArrayBase<CvArea>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$FFreeListArrayBase@VCvArea@@@@8
rdata$r	SEGMENT
??_R3?$FFreeListArrayBase@VCvArea@@@@8 DD 00H		; FFreeListArrayBase<CvArea>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$FFreeListArrayBase@VCvArea@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$FFreeListArrayBase@VCvArea@@@@@8
_DATA	SEGMENT
??_R0?AV?$FFreeListArrayBase@VCvArea@@@@@8 DD FLAT:??_7type_info@@6B@ ; FFreeListArrayBase<CvArea> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$FFreeListArrayBase@VCvArea@@@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$FFreeListArrayBase@VCvArea@@@@6B@
rdata$r	SEGMENT
??_R4?$FFreeListArrayBase@VCvArea@@@@6B@ DD 00H		; FFreeListArrayBase<CvArea>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$FFreeListArrayBase@VCvArea@@@@@8
	DD	FLAT:??_R3?$FFreeListArrayBase@VCvArea@@@@8
rdata$r	ENDS
;	COMDAT ??_7?$FFreeListArrayBase@VCvArea@@@@6B@
CONST	SEGMENT
??_7?$FFreeListArrayBase@VCvArea@@@@6B@ DD FLAT:??_R4?$FFreeListArrayBase@VCvArea@@@@6B@ ; FFreeListArrayBase<CvArea>::`vftable'
	DD	FLAT:??_E?$FFreeListArrayBase@VCvArea@@@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0?$FFreeListArrayBase@VCvArea@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FFreeListArrayBase@VCvArea@@@@QAE@XZ PROC		; FFreeListArrayBase<CvArea>::FFreeListArrayBase<CvArea>, COMDAT
; _this$ = ecx

; 88   : {

	mov	eax, ecx

; 89   : 	m_iFreeListHead = FFreeList::FREE_LIST_INDEX;
; 90   : 	m_iFreeListCount = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7?$FFreeListArrayBase@VCvArea@@@@6B@
	mov	DWORD PTR [eax+4], -2			; fffffffeH
	mov	DWORD PTR [eax+8], ecx

; 91   : 	m_iLastIndex = FFreeList::INVALID_INDEX;

	mov	DWORD PTR [eax+12], -1

; 92   : 	m_iNumSlots = 0;

	mov	DWORD PTR [eax+16], ecx

; 93   : }

	ret	0
??0?$FFreeListArrayBase@VCvArea@@@@QAE@XZ ENDP		; FFreeListArrayBase<CvArea>::FFreeListArrayBase<CvArea>
_TEXT	ENDS
PUBLIC	??A?$FFreeListArrayBase@VCvArea@@@@QBEPBVCvArea@@H@Z ; FFreeListArrayBase<CvArea>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$FFreeListArrayBase@VCvArea@@@@QBEPBVCvArea@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
??A?$FFreeListArrayBase@VCvArea@@@@QBEPBVCvArea@@H@Z PROC ; FFreeListArrayBase<CvArea>::operator[], COMDAT
; _this$ = ecx

; 109  : 	return ( GetAt( iIndex ) );

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	jmp	eax
??A?$FFreeListArrayBase@VCvArea@@@@QBEPBVCvArea@@H@Z ENDP ; FFreeListArrayBase<CvArea>::operator[]
_TEXT	ENDS
PUBLIC	?Load@?$FFreeListTrashArray@VCvLandmass@@@@QAEXPAVCvLandmass@@@Z ; FFreeListTrashArray<CvLandmass>::Load
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
;	COMDAT ?Load@?$FFreeListTrashArray@VCvLandmass@@@@QAEXPAVCvLandmass@@@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
?Load@?$FFreeListTrashArray@VCvLandmass@@@@QAEXPAVCvLandmass@@@Z PROC ; FFreeListTrashArray<CvLandmass>::Load, COMDAT
; _this$ = ecx

; 386  : 	assert(pData != NULL);
; 387  : 	assert(m_pArray != NULL);
; 388  : 	if (!pData || !m_pArray) return;

	mov	edx, DWORD PTR _pData$[esp-4]
	test	edx, edx
	je	SHORT $LN1@Load
	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	je	SHORT $LN1@Load

; 389  : 
; 390  : 	assert((pData->GetID() & FLTA_ID_MASK) < m_iCurrentID);
; 391  : 
; 392  : 	int iIndex = (pData->GetID() & FLTA_INDEX_MASK);

	mov	ecx, DWORD PTR [edx+4]
	and	ecx, 8191				; 00001fffH

; 393  : 
; 394  : 	assert(iIndex < FLTA_MAX_BUCKETS);
; 395  : 	assert(iIndex <= this->m_iLastIndex);
; 396  : 	assert(m_pArray[iIndex].pData == NULL);
; 397  : 	assert(m_pArray[iIndex].iNextFreeIndex == FFreeList::INVALID_INDEX);
; 398  : 
; 399  : 	m_pArray[iIndex].pData = pData;

	mov	DWORD PTR [eax+ecx*8+4], edx
$LN1@Load:

; 400  : }

	ret	4
?Load@?$FFreeListTrashArray@VCvLandmass@@@@QAEXPAVCvLandmass@@@Z ENDP ; FFreeListTrashArray<CvLandmass>::Load
_TEXT	ENDS
PUBLIC	??_7?$FFreeListArrayBase@VCvLandmass@@@@6B@	; FFreeListArrayBase<CvLandmass>::`vftable'
PUBLIC	??0?$FFreeListArrayBase@VCvLandmass@@@@QAE@XZ	; FFreeListArrayBase<CvLandmass>::FFreeListArrayBase<CvLandmass>
PUBLIC	??_R4?$FFreeListArrayBase@VCvLandmass@@@@6B@	; FFreeListArrayBase<CvLandmass>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$FFreeListArrayBase@VCvLandmass@@@@@8	; FFreeListArrayBase<CvLandmass> `RTTI Type Descriptor'
PUBLIC	??_R3?$FFreeListArrayBase@VCvLandmass@@@@8	; FFreeListArrayBase<CvLandmass>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$FFreeListArrayBase@VCvLandmass@@@@8	; FFreeListArrayBase<CvLandmass>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$FFreeListArrayBase@VCvLandmass@@@@8 ; FFreeListArrayBase<CvLandmass>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_E?$FFreeListArrayBase@VCvLandmass@@@@UAEPAXI@Z:PROC ; FFreeListArrayBase<CvLandmass>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$FFreeListArrayBase@VCvLandmass@@@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
rdata$r	SEGMENT
??_R1A@?0A@EA@?$FFreeListArrayBase@VCvLandmass@@@@8 DD FLAT:??_R0?AV?$FFreeListArrayBase@VCvLandmass@@@@@8 ; FFreeListArrayBase<CvLandmass>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$FFreeListArrayBase@VCvLandmass@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$FFreeListArrayBase@VCvLandmass@@@@8
rdata$r	SEGMENT
??_R2?$FFreeListArrayBase@VCvLandmass@@@@8 DD FLAT:??_R1A@?0A@EA@?$FFreeListArrayBase@VCvLandmass@@@@8 ; FFreeListArrayBase<CvLandmass>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$FFreeListArrayBase@VCvLandmass@@@@8
rdata$r	SEGMENT
??_R3?$FFreeListArrayBase@VCvLandmass@@@@8 DD 00H	; FFreeListArrayBase<CvLandmass>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$FFreeListArrayBase@VCvLandmass@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$FFreeListArrayBase@VCvLandmass@@@@@8
_DATA	SEGMENT
??_R0?AV?$FFreeListArrayBase@VCvLandmass@@@@@8 DD FLAT:??_7type_info@@6B@ ; FFreeListArrayBase<CvLandmass> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$FFreeListArrayBase@VCvLandmass@@@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$FFreeListArrayBase@VCvLandmass@@@@6B@
rdata$r	SEGMENT
??_R4?$FFreeListArrayBase@VCvLandmass@@@@6B@ DD 00H	; FFreeListArrayBase<CvLandmass>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$FFreeListArrayBase@VCvLandmass@@@@@8
	DD	FLAT:??_R3?$FFreeListArrayBase@VCvLandmass@@@@8
rdata$r	ENDS
;	COMDAT ??_7?$FFreeListArrayBase@VCvLandmass@@@@6B@
CONST	SEGMENT
??_7?$FFreeListArrayBase@VCvLandmass@@@@6B@ DD FLAT:??_R4?$FFreeListArrayBase@VCvLandmass@@@@6B@ ; FFreeListArrayBase<CvLandmass>::`vftable'
	DD	FLAT:??_E?$FFreeListArrayBase@VCvLandmass@@@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0?$FFreeListArrayBase@VCvLandmass@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FFreeListArrayBase@VCvLandmass@@@@QAE@XZ PROC	; FFreeListArrayBase<CvLandmass>::FFreeListArrayBase<CvLandmass>, COMDAT
; _this$ = ecx

; 88   : {

	mov	eax, ecx

; 89   : 	m_iFreeListHead = FFreeList::FREE_LIST_INDEX;
; 90   : 	m_iFreeListCount = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7?$FFreeListArrayBase@VCvLandmass@@@@6B@
	mov	DWORD PTR [eax+4], -2			; fffffffeH
	mov	DWORD PTR [eax+8], ecx

; 91   : 	m_iLastIndex = FFreeList::INVALID_INDEX;

	mov	DWORD PTR [eax+12], -1

; 92   : 	m_iNumSlots = 0;

	mov	DWORD PTR [eax+16], ecx

; 93   : }

	ret	0
??0?$FFreeListArrayBase@VCvLandmass@@@@QAE@XZ ENDP	; FFreeListArrayBase<CvLandmass>::FFreeListArrayBase<CvLandmass>
_TEXT	ENDS
PUBLIC	??A?$FFreeListArrayBase@VCvLandmass@@@@QBEPBVCvLandmass@@H@Z ; FFreeListArrayBase<CvLandmass>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$FFreeListArrayBase@VCvLandmass@@@@QBEPBVCvLandmass@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
??A?$FFreeListArrayBase@VCvLandmass@@@@QBEPBVCvLandmass@@H@Z PROC ; FFreeListArrayBase<CvLandmass>::operator[], COMDAT
; _this$ = ecx

; 109  : 	return ( GetAt( iIndex ) );

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	jmp	eax
??A?$FFreeListArrayBase@VCvLandmass@@@@QBEPBVCvLandmass@@H@Z ENDP ; FFreeListArrayBase<CvLandmass>::operator[]
_TEXT	ENDS
PUBLIC	??$?5E@FDataStream@@QAEAAV0@AAE@Z		; FDataStream::operator>><unsigned char>
EXTRN	?Read@FDataStream@@IAEXAAE@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5E@FDataStream@@QAEAAV0@AAE@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5E@FDataStream@@QAEAAV0@AAE@Z PROC			; FDataStream::operator>><unsigned char>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAE@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5E@FDataStream@@QAEAAV0@AAE@Z ENDP			; FDataStream::operator>><unsigned char>
_TEXT	ENDS
PUBLIC	??$?6E@FDataStream@@QAEAAV0@ABE@Z		; FDataStream::operator<<<unsigned char>
EXTRN	?Write@FDataStream@@IAEXABE@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6E@FDataStream@@QAEAAV0@ABE@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6E@FDataStream@@QAEAAV0@ABE@Z PROC			; FDataStream::operator<<<unsigned char>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6E@FDataStream@@QAEAAV0@ABE@Z ENDP			; FDataStream::operator<<<unsigned char>
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::CvString, COMDAT
; _this$ = ecx

; 26   : 	CvString(const std::string& s): std::string(s) {}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp___vsnprintf:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?format@CvString@@SA?AV1@PBDZZ			; CvString::format
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?format@CvString@@SA?AV1@PBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?format@CvString@@SA?AV1@PBDZZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?format@CvString@@SA?AV1@PBDZZ$0
__ehfuncinfo$?format@CvString@@SA?AV1@PBDZZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?format@CvString@@SA?AV1@PBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?format@CvString@@SA?AV1@PBDZZ
_TEXT	SEGMENT
$T238280 = -44						; size = 4
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_fmt$ = 12						; size = 4
?format@CvString@@SA?AV1@PBDZZ PROC			; CvString::format, COMDAT

; 243  : {

	push	-1
	push	__ehhandler$?format@CvString@@SA?AV1@PBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	esi

; 244  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+48]
	mov	DWORD PTR $T238280[esp+48], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 245  : 	va_list args;
; 246  : 	va_start(args,fmt);
; 247  : 	formatv(result,fmt,args);

	mov	ecx, DWORD PTR _fmt$[esp+44]
	lea	eax, DWORD PTR _fmt$[esp+48]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+56]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+68], 1
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv

; 248  : 	va_end(args);
; 249  : 	return CvString(result);

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+56]
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR _result$[esp+48]
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	lea	ecx, DWORD PTR _result$[esp+48]
	mov	DWORD PTR $T238280[esp+48], 1
	mov	BYTE PTR __$EHRec$[esp+56], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 250  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?format@CvString@@SA?AV1@PBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?format@CvString@@SA?AV1@PBDZZ$1:
	mov	eax, DWORD PTR $T238280[ebp]
	and	eax, 1
	je	$LN5@format
	and	DWORD PTR $T238280[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@format:
	ret	0
__ehhandler$?format@CvString@@SA?AV1@PBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?format@CvString@@SA?AV1@PBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?format@CvString@@SA?AV1@PBDZZ ENDP			; CvString::format
PUBLIC	??0CvMapInitData@@QAE@HHHH_N0@Z			; CvMapInitData::CvMapInitData
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstructs.h
;	COMDAT ??0CvMapInitData@@QAE@HHHH_N0@Z
_TEXT	SEGMENT
_iGridW$ = 8						; size = 4
_iGridH$ = 12						; size = 4
_iTopLatitude$ = 16					; size = 4
_iBottomLatitude$ = 20					; size = 4
_bWrapX$ = 24						; size = 1
_bWrapY$ = 28						; size = 1
??0CvMapInitData@@QAE@HHHH_N0@Z PROC			; CvMapInitData::CvMapInitData, COMDAT
; _this$ = ecx

; 146  : 	{ }

	mov	edx, DWORD PTR _iGridH$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _iGridW$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _iTopLatitude$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _iBottomLatitude$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	cl, BYTE PTR _bWrapX$[esp-4]
	mov	DWORD PTR [eax+12], edx
	mov	dl, BYTE PTR _bWrapY$[esp-4]
	mov	BYTE PTR [eax+16], cl
	mov	BYTE PTR [eax+17], dl
	ret	24					; 00000018H
??0CvMapInitData@@QAE@HHHH_N0@Z ENDP			; CvMapInitData::CvMapInitData
_TEXT	ENDS
PUBLIC	?GetDescription@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetDescription
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetDescription@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetDescription@CvBaseInfo@@QBEPBDXZ PROC		; CvBaseInfo::GetDescription, COMDAT
; _this$ = ecx

; 64   : 		return m_strDescription.c_str();

	add	ecx, 36					; 00000024H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetDescription@CvBaseInfo@@QBEPBDXZ ENDP		; CvBaseInfo::GetDescription
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getPlotDirectionX@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionX
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionX@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionX@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionX, COMDAT
; _this$ = ecx

; 191  : 		return m_aiPlotDirectionX;

	lea	eax, DWORD PTR [ecx+112]

; 192  : 	}

	ret	0
?getPlotDirectionX@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionX
_TEXT	ENDS
PUBLIC	?getPlotDirectionY@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionY
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionY@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionY@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionY, COMDAT
; _this$ = ecx

; 195  : 		return m_aiPlotDirectionY;

	lea	eax, DWORD PTR [ecx+136]

; 196  : 	}

	ret	0
?getPlotDirectionY@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionY
_TEXT	ENDS
PUBLIC	?getLAKE_MAX_AREA_SIZE@CvGlobals@@QAEHXZ	; CvGlobals::getLAKE_MAX_AREA_SIZE
; Function compile flags: /Ogtpy
;	COMDAT ?getLAKE_MAX_AREA_SIZE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getLAKE_MAX_AREA_SIZE@CvGlobals@@QAEHXZ PROC		; CvGlobals::getLAKE_MAX_AREA_SIZE, COMDAT
; _this$ = ecx

; 5584 : 		return m_iLAKE_MAX_AREA_SIZE;

	mov	eax, DWORD PTR [ecx+6508]

; 5585 : 	}

	ret	0
?getLAKE_MAX_AREA_SIZE@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getLAKE_MAX_AREA_SIZE
_TEXT	ENDS
PUBLIC	?getNUM_RESOURCE_QUANTITY_TYPES@CvGlobals@@QAEHXZ ; CvGlobals::getNUM_RESOURCE_QUANTITY_TYPES
; Function compile flags: /Ogtpy
;	COMDAT ?getNUM_RESOURCE_QUANTITY_TYPES@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUM_RESOURCE_QUANTITY_TYPES@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNUM_RESOURCE_QUANTITY_TYPES, COMDAT
; _this$ = ecx

; 6092 : 		return m_iNUM_RESOURCE_QUANTITY_TYPES;

	mov	eax, DWORD PTR [ecx+7016]

; 6093 : 	}

	ret	0
?getNUM_RESOURCE_QUANTITY_TYPES@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNUM_RESOURCE_QUANTITY_TYPES
_TEXT	ENDS
PUBLIC	?getLAND_TERRAIN@CvGlobals@@QAEHXZ		; CvGlobals::getLAND_TERRAIN
; Function compile flags: /Ogtpy
;	COMDAT ?getLAND_TERRAIN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getLAND_TERRAIN@CvGlobals@@QAEHXZ PROC			; CvGlobals::getLAND_TERRAIN, COMDAT
; _this$ = ecx

; 7171 : 		return m_iLAND_TERRAIN;

	mov	eax, DWORD PTR [ecx+8388]

; 7172 : 	}

	ret	0
?getLAND_TERRAIN@CvGlobals@@QAEHXZ ENDP			; CvGlobals::getLAND_TERRAIN
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ; CvGlobals::GetEngineUserInterface
; Function compile flags: /Ogtpy
;	COMDAT ?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ
_TEXT	SEGMENT
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ PROC ; CvGlobals::GetEngineUserInterface, COMDAT
; _this$ = ecx

; 7713 : 		return m_pEngineUI;

	mov	eax, DWORD PTR [ecx+8568]

; 7714 : 	}

	ret	0
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ENDP ; CvGlobals::GetEngineUserInterface
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	??0CvAreaBoundaries@@QAE@XZ			; CvAreaBoundaries::CvAreaBoundaries
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarea.h
;	COMDAT ??0CvAreaBoundaries@@QAE@XZ
_TEXT	SEGMENT
??0CvAreaBoundaries@@QAE@XZ PROC			; CvAreaBoundaries::CvAreaBoundaries, COMDAT
; _this$ = ecx

; 24   : 	{

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 25   : 	}

	ret	0
??0CvAreaBoundaries@@QAE@XZ ENDP			; CvAreaBoundaries::CvAreaBoundaries
_TEXT	ENDS
PUBLIC	?GetID@CvArea@@QBEHXZ				; CvArea::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvArea@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvArea@@QBEHXZ PROC				; CvArea::GetID, COMDAT
; _this$ = ecx

; 54   : 		return m_iID;

	mov	eax, DWORD PTR [ecx+4]

; 55   : 	}

	ret	0
?GetID@CvArea@@QBEHXZ ENDP				; CvArea::GetID
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@isCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax

; 249  : 	}

	ret	0
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al

; 249  : 	}

	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getArea@CvPlot@@QBEHXZ				; CvPlot::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?getArea@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getArea@CvPlot@@QBEHXZ PROC				; CvPlot::getArea, COMDAT
; _this$ = ecx

; 324  : 		return m_iArea;

	mov	eax, DWORD PTR [ecx+356]

; 325  : 	}

	ret	0
?getArea@CvPlot@@QBEHXZ ENDP				; CvPlot::getArea
_TEXT	ENDS
PUBLIC	?getLandmass@CvPlot@@QBEHXZ			; CvPlot::getLandmass
; Function compile flags: /Ogtpy
;	COMDAT ?getLandmass@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getLandmass@CvPlot@@QBEHXZ PROC			; CvPlot::getLandmass, COMDAT
; _this$ = ecx

; 331  : 		return m_iLandmass;

	mov	eax, DWORD PTR [ecx+360]

; 332  : 	}

	ret	0
?getLandmass@CvPlot@@QBEHXZ ENDP			; CvPlot::getLandmass
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?isHills@CvPlot@@QBE_NXZ			; CvPlot::isHills
; Function compile flags: /Ogtpy
;	COMDAT ?isHills@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isHills@CvPlot@@QBE_NXZ PROC				; CvPlot::isHills, COMDAT
; _this$ = ecx

; 413  : 		return (PlotTypes)m_ePlotType == PLOT_HILLS;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 1
	sete	al

; 414  : 	};

	ret	0
?isHills@CvPlot@@QBE_NXZ ENDP				; CvPlot::isHills
_TEXT	ENDS
PUBLIC	?isMountain@CvPlot@@QBE_NXZ			; CvPlot::isMountain
; Function compile flags: /Ogtpy
;	COMDAT ?isMountain@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isMountain@CvPlot@@QBE_NXZ PROC			; CvPlot::isMountain, COMDAT
; _this$ = ecx

; 422  : 		return (PlotTypes)m_ePlotType == PLOT_MOUNTAIN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], al
	sete	al

; 423  : 	};

	ret	0
?isMountain@CvPlot@@QBE_NXZ ENDP			; CvPlot::isMountain
_TEXT	ENDS
PUBLIC	?isRiver@CvPlot@@QBE_NXZ			; CvPlot::isRiver
; Function compile flags: /Ogtpy
;	COMDAT ?isRiver@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isRiver@CvPlot@@QBE_NXZ PROC				; CvPlot::isRiver, COMDAT
; _this$ = ecx

; 426  : 		return m_iRiverCrossingCount > 0;

	xor	eax, eax
	cmp	BYTE PTR [ecx+457], al
	setg	al

; 427  : 	}

	ret	0
?isRiver@CvPlot@@QBE_NXZ ENDP				; CvPlot::isRiver
_TEXT	ENDS
PUBLIC	?isImpassable@CvPlot@@QBE_NXZ			; CvPlot::isImpassable
; Function compile flags: /Ogtpy
;	COMDAT ?isImpassable@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isImpassable@CvPlot@@QBE_NXZ PROC			; CvPlot::isImpassable, COMDAT
; _this$ = ecx

; 444  : 		return m_bIsImpassable;

	mov	al, BYTE PTR [ecx+462]
	shr	al, 7

; 445  : 	}

	ret	0
?isImpassable@CvPlot@@QBE_NXZ ENDP			; CvPlot::isImpassable
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@getPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 537  : 	}

	ret	0
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax

; 537  : 	}

	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?numPlots@CvMap@@QBEHXZ				; CvMap::numPlots
; Function compile flags: /Ogtpy
;	COMDAT ?numPlots@CvMap@@QBEHXZ
_TEXT	SEGMENT
?numPlots@CvMap@@QBEHXZ PROC				; CvMap::numPlots, COMDAT
; _this$ = ecx

; 170  : 		return m_iGridSize;

	mov	eax, DWORD PTR [ecx+4028]

; 171  : 	}

	ret	0
?numPlots@CvMap@@QBEHXZ ENDP				; CvMap::numPlots
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z		; CvMap::plotByIndex
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z PROC		; CvMap::plotByIndex, COMDAT
; _this$ = ecx

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	mov	eax, DWORD PTR _iIndex$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@plotByInde
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN3@plotByInde
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 264  : 	}

	ret	4
$LN3@plotByInde:

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	xor	eax, eax

; 264  : 	}

	ret	4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z ENDP		; CvMap::plotByIndex
_TEXT	ENDS
PUBLIC	?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z	; CvMap::plotByIndexUnchecked
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z PROC	; CvMap::plotByIndexUnchecked, COMDAT
; _this$ = ecx

; 268  : 		return &m_pMapPlots[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp-4]
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 269  : 	}

	ret	4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z ENDP	; CvMap::plotByIndexUnchecked
_TEXT	ENDS
PUBLIC	?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ	; CvAStar::GetLastNode
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.h
;	COMDAT ?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ
_TEXT	SEGMENT
?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ PROC	; CvAStar::GetLastNode, COMDAT
; _this$ = ecx

; 98   : 		return m_pBest;

	mov	eax, DWORD PTR [ecx+96]

; 99   : 	}

	ret	0
?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ ENDP	; CvAStar::GetLastNode
_TEXT	ENDS
PUBLIC	?SetData@CvAStar@@QAEXPBX@Z			; CvAStar::SetData
; Function compile flags: /Ogtpy
;	COMDAT ?SetData@CvAStar@@QAEXPBX@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
?SetData@CvAStar@@QAEXPBX@Z PROC			; CvAStar::SetData, COMDAT
; _this$ = ecx

; 202  : 		if(m_bDataChangeInvalidatesCache && m_pData != pData)

	cmp	BYTE PTR [ecx+80], 0
	mov	eax, DWORD PTR _pData$[esp-4]
	je	SHORT $LN4@SetData
	cmp	DWORD PTR [ecx+44], eax

; 205  : 		m_pData = pData;

	mov	DWORD PTR [ecx+44], eax
	je	SHORT $LN1@SetData

; 203  : #endif
; 204  : 			m_bForceReset = true;

	mov	BYTE PTR [ecx+78], 1

; 206  : #ifdef AUI_ASTAR_TURN_LIMITER
; 207  : 		m_iMaxTurns = iMaxTurns;
; 208  : #endif
; 209  : 	}

	ret	4
$LN4@SetData:

; 205  : 		m_pData = pData;

	mov	DWORD PTR [ecx+44], eax
$LN1@SetData:

; 206  : #ifdef AUI_ASTAR_TURN_LIMITER
; 207  : 		m_iMaxTurns = iMaxTurns;
; 208  : #endif
; 209  : 	}

	ret	4
?SetData@CvAStar@@QAEXPBX@Z ENDP			; CvAStar::SetData
_TEXT	ENDS
PUBLIC	?SetDataChangeInvalidatesCache@CvAStar@@QAE_N_N@Z ; CvAStar::SetDataChangeInvalidatesCache
; Function compile flags: /Ogtpy
;	COMDAT ?SetDataChangeInvalidatesCache@CvAStar@@QAE_N_N@Z
_TEXT	SEGMENT
_bState$ = 8						; size = 1
?SetDataChangeInvalidatesCache@CvAStar@@QAE_N_N@Z PROC	; CvAStar::SetDataChangeInvalidatesCache, COMDAT
; _this$ = ecx

; 235  : 		bool bOldState = m_bDataChangeInvalidatesCache;
; 236  : 		m_bDataChangeInvalidatesCache = bState;

	mov	dl, BYTE PTR _bState$[esp-4]
	mov	al, BYTE PTR [ecx+80]
	mov	BYTE PTR [ecx+80], dl

; 237  : 
; 238  : 		return bOldState;
; 239  : 	}

	ret	4
?SetDataChangeInvalidatesCache@CvAStar@@QAE_N_N@Z ENDP	; CvAStar::SetDataChangeInvalidatesCache
_TEXT	ENDS
PUBLIC	?SetValidFunc@CvAStar@@QAEXP6AHPAVCvAStarNode@@0HPBXPAV1@@Z@Z ; CvAStar::SetValidFunc
; Function compile flags: /Ogtpy
;	COMDAT ?SetValidFunc@CvAStar@@QAEXP6AHPAVCvAStarNode@@0HPBXPAV1@@Z@Z
_TEXT	SEGMENT
_newValidFunc$ = 8					; size = 4
?SetValidFunc@CvAStar@@QAEXP6AHPAVCvAStarNode@@0HPBXPAV1@@Z@Z PROC ; CvAStar::SetValidFunc, COMDAT
; _this$ = ecx

; 308  : 		udValid = newValidFunc;

	mov	eax, DWORD PTR _newValidFunc$[esp-4]
	mov	DWORD PTR [ecx+16], eax

; 309  : 	}

	ret	4
?SetValidFunc@CvAStar@@QAEXP6AHPAVCvAStarNode@@0HPBXPAV1@@Z@Z ENDP ; CvAStar::SetValidFunc
_TEXT	ENDS
PUBLIC	?SetNotifyListFunc@CvAStar@@QAEXP6AHPAVCvAStarNode@@0HPBXPAV1@@Z@Z ; CvAStar::SetNotifyListFunc
; Function compile flags: /Ogtpy
;	COMDAT ?SetNotifyListFunc@CvAStar@@QAEXP6AHPAVCvAStarNode@@0HPBXPAV1@@Z@Z
_TEXT	SEGMENT
_newNotifyListFunc$ = 8					; size = 4
?SetNotifyListFunc@CvAStar@@QAEXP6AHPAVCvAStarNode@@0HPBXPAV1@@Z@Z PROC ; CvAStar::SetNotifyListFunc, COMDAT
; _this$ = ecx

; 336  : 		udNotifyList = newNotifyListFunc;

	mov	eax, DWORD PTR _newNotifyListFunc$[esp-4]
	mov	DWORD PTR [ecx+24], eax

; 337  : 	}

	ret	4
?SetNotifyListFunc@CvAStar@@QAEXP6AHPAVCvAStarNode@@0HPBXPAV1@@Z@Z ENDP ; CvAStar::SetNotifyListFunc
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$FFreeListArrayBase@VCvArea@@@@UAE@XZ	; FFreeListArrayBase<CvArea>::~FFreeListArrayBase<CvArea>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
;	COMDAT ??1?$FFreeListArrayBase@VCvArea@@@@UAE@XZ
_TEXT	SEGMENT
??1?$FFreeListArrayBase@VCvArea@@@@UAE@XZ PROC		; FFreeListArrayBase<CvArea>::~FFreeListArrayBase<CvArea>, COMDAT
; _this$ = ecx

; 34   : 	virtual ~FFreeListArrayBase() {}

	mov	DWORD PTR [ecx], OFFSET ??_7?$FFreeListArrayBase@VCvArea@@@@6B@
	ret	0
??1?$FFreeListArrayBase@VCvArea@@@@UAE@XZ ENDP		; FFreeListArrayBase<CvArea>::~FFreeListArrayBase<CvArea>
_TEXT	ENDS
PUBLIC	??1?$FFreeListArrayBase@VCvLandmass@@@@UAE@XZ	; FFreeListArrayBase<CvLandmass>::~FFreeListArrayBase<CvLandmass>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FFreeListArrayBase@VCvLandmass@@@@UAE@XZ
_TEXT	SEGMENT
??1?$FFreeListArrayBase@VCvLandmass@@@@UAE@XZ PROC	; FFreeListArrayBase<CvLandmass>::~FFreeListArrayBase<CvLandmass>, COMDAT
; _this$ = ecx

; 34   : 	virtual ~FFreeListArrayBase() {}

	mov	DWORD PTR [ecx], OFFSET ??_7?$FFreeListArrayBase@VCvLandmass@@@@6B@
	ret	0
??1?$FFreeListArrayBase@VCvLandmass@@@@UAE@XZ ENDP	; FFreeListArrayBase<CvLandmass>::~FFreeListArrayBase<CvLandmass>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$FFreeListArrayBase@VCvArea@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$FFreeListArrayBase@VCvArea@@@@UAEPAXI@Z PROC	; FFreeListArrayBase<CvArea>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7?$FFreeListArrayBase@VCvArea@@@@6B@
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$FFreeListArrayBase@VCvArea@@@@UAEPAXI@Z ENDP	; FFreeListArrayBase<CvArea>::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$FFreeListArrayBase@VCvLandmass@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$FFreeListArrayBase@VCvLandmass@@@@UAEPAXI@Z PROC	; FFreeListArrayBase<CvLandmass>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7?$FFreeListArrayBase@VCvLandmass@@@@6B@
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$FFreeListArrayBase@VCvLandmass@@@@UAEPAXI@Z ENDP	; FFreeListArrayBase<CvLandmass>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ	; FAutoVariable<int,CvUnit>::get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::get
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
_TEXT	ENDS
PUBLIC	??_GCvArea@@QAEPAXI@Z				; CvArea::`scalar deleting destructor'
EXTRN	??1CvArea@@QAE@XZ:PROC				; CvArea::~CvArea
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvArea@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvArea@@QAEPAXI@Z PROC				; CvArea::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvArea@@QAE@XZ			; CvArea::~CvArea
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvArea@@QAEPAXI@Z ENDP				; CvArea::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??$?5D@FDataStream@@QAEAAV0@AAD@Z		; FDataStream::operator>><char>
EXTRN	?Read@FDataStream@@IAEXAAD@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5D@FDataStream@@QAEAAV0@AAD@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5D@FDataStream@@QAEAAV0@AAD@Z PROC			; FDataStream::operator>><char>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5D@FDataStream@@QAEAAV0@AAD@Z ENDP			; FDataStream::operator>><char>
_TEXT	ENDS
PUBLIC	??$?6D@FDataStream@@QAEAAV0@ABD@Z		; FDataStream::operator<<<char>
EXTRN	?Write@FDataStream@@IAEXABD@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6D@FDataStream@@QAEAAV0@ABD@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6D@FDataStream@@QAEAAV0@ABD@Z PROC			; FDataStream::operator<<<char>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6D@FDataStream@@QAEAAV0@ABD@Z ENDP			; FDataStream::operator<<<char>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@UFFreeListTrashArrayNode@?$FFreeListTrashArray@VCvArea@@@@@@YAXAAPAUFFreeListTrashArrayNode@?$FFreeListTrashArray@VCvArea@@@@@Z ; SAFE_DELETE_ARRAY<FFreeListTrashArray<CvArea>::FFreeListTrashArrayNode>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@UFFreeListTrashArrayNode@?$FFreeListTrashArray@VCvArea@@@@@@YAXAAPAUFFreeListTrashArrayNode@?$FFreeListTrashArray@VCvArea@@@@@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@UFFreeListTrashArrayNode@?$FFreeListTrashArray@VCvArea@@@@@@YAXAAPAUFFreeListTrashArrayNode@?$FFreeListTrashArray@VCvArea@@@@@Z PROC ; SAFE_DELETE_ARRAY<FFreeListTrashArray<CvArea>::FFreeListTrashArrayNode>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@UFFreeListTrashArrayNode@?$FFreeListTrashArray@VCvArea@@@@@@YAXAAPAUFFreeListTrashArrayNode@?$FFreeListTrashArray@VCvArea@@@@@Z ENDP ; SAFE_DELETE_ARRAY<FFreeListTrashArray<CvArea>::FFreeListTrashArrayNode>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@UFFreeListTrashArrayNode@?$FFreeListTrashArray@VCvLandmass@@@@@@YAXAAPAUFFreeListTrashArrayNode@?$FFreeListTrashArray@VCvLandmass@@@@@Z ; SAFE_DELETE_ARRAY<FFreeListTrashArray<CvLandmass>::FFreeListTrashArrayNode>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@UFFreeListTrashArrayNode@?$FFreeListTrashArray@VCvLandmass@@@@@@YAXAAPAUFFreeListTrashArrayNode@?$FFreeListTrashArray@VCvLandmass@@@@@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@UFFreeListTrashArrayNode@?$FFreeListTrashArray@VCvLandmass@@@@@@YAXAAPAUFFreeListTrashArrayNode@?$FFreeListTrashArray@VCvLandmass@@@@@Z PROC ; SAFE_DELETE_ARRAY<FFreeListTrashArray<CvLandmass>::FFreeListTrashArrayNode>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@UFFreeListTrashArrayNode@?$FFreeListTrashArray@VCvLandmass@@@@@@YAXAAPAUFFreeListTrashArrayNode@?$FFreeListTrashArray@VCvLandmass@@@@@Z ENDP ; SAFE_DELETE_ARRAY<FFreeListTrashArray<CvLandmass>::FFreeListTrashArrayNode>
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iDY$ = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[esp-4]
	sub	eax, DWORD PTR _iX1$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	edx, DWORD PTR [ebx+4020]
	push	ebp
	push	esi
	je	SHORT $LN13@plotDistan
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN15@plotDistan
	sub	eax, edx
	jmp	SHORT $LN13@plotDistan
$LN15@plotDistan:
	neg	ecx
	cmp	eax, ecx
	lea	ecx, DWORD PTR [edx+eax]
	jl	SHORT $LN17@plotDistan
$LN13@plotDistan:
	mov	ecx, eax
$LN17@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	eax, DWORD PTR _iY2$[esp+8]
	mov	esi, DWORD PTR [ebx+4024]
	push	edi
	mov	edi, DWORD PTR _iY1$[esp+12]
	sub	eax, edi
	cmp	BYTE PTR [ebx+4057], 0
	je	SHORT $LN27@plotDistan
	mov	edx, esi
	shr	edx, 1
	cmp	eax, edx
	jle	SHORT $LN29@plotDistan
	sub	eax, esi
	jmp	SHORT $LN27@plotDistan
$LN29@plotDistan:
	neg	edx
	cmp	eax, edx
	lea	ebp, DWORD PTR [esi+eax]
	jl	SHORT $LN31@plotDistan
$LN27@plotDistan:
	mov	ebp, eax
$LN31@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[esp+12], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	test	edi, edi
	jl	SHORT $LN35@plotDistan
	mov	eax, edi
	jmp	SHORT $LN59@plotDistan
$LN35@plotDistan:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN59@plotDistan:
	mov	esi, DWORD PTR _iX1$[esp+12]
	sar	eax, 1
	sub	esi, eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	lea	eax, DWORD PTR [edi+ebp]
	pop	edi
	test	eax, eax
	jge	SHORT $LN60@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN60@plotDistan:

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	edx, DWORD PTR [ebx+4020]
	sar	eax, 1
	sub	ecx, eax
	add	ecx, DWORD PTR _iX1$[esp+8]
	sub	ecx, esi
	cmp	BYTE PTR [ebx+4056], 0
	je	SHORT $LN49@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN51@plotDistan
	mov	eax, ecx
	sub	eax, edx
	jmp	SHORT $LN53@plotDistan
$LN51@plotDistan:
	neg	eax
	cmp	ecx, eax
	lea	eax, DWORD PTR [edx+ecx]
	jl	SHORT $LN53@plotDistan
$LN49@plotDistan:
	mov	eax, ecx
$LN53@plotDistan:
	cdq
	xor	eax, edx
	sub	eax, edx

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebp, ebp
	setge	cl
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp-4]
	add	eax, edx

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
$LN2@plotDistan:

; 163  : 	}
; 164  : 	else
; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp-4]
	lea	eax, DWORD PTR _iDY$[esp-4]
	jl	SHORT $LN58@plotDistan
	lea	eax, DWORD PTR _iDX$[esp-4]
$LN58@plotDistan:
	mov	eax, DWORD PTR [eax]

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvLandmass@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvLandmass@@UAEPAXI@Z PROC				; CvLandmass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvLandmass@@6B@
	je	SHORT $LN6@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvLandmass@@UAEPAXI@Z ENDP				; CvLandmass::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?isLake@CvLandmass@@QBE_NXZ			; CvLandmass::isLake
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.cpp
;	COMDAT ?isLake@CvLandmass@@QBE_NXZ
_TEXT	SEGMENT
?isLake@CvLandmass@@QBE_NXZ PROC			; CvLandmass::isLake, COMDAT
; _this$ = ecx

; 121  : 	return (m_bWater && (m_iNumTiles <= GC.getLAKE_MAX_AREA_SIZE()));

	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LN3@isLake
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6508
	jg	SHORT $LN3@isLake
	mov	eax, 1

; 122  : }

	ret	0
$LN3@isLake:

; 121  : 	return (m_bWater && (m_iNumTiles <= GC.getLAKE_MAX_AREA_SIZE()));

	xor	eax, eax

; 122  : }

	ret	0
?isLake@CvLandmass@@QBE_NXZ ENDP			; CvLandmass::isLake
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?read@CvLandmass@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?read@CvLandmass@@UAEXAAVFDataStream@@@Z PROC		; CvLandmass::read, COMDAT
; _this$ = ecx

; 170  : {

	push	esi
	push	edi

; 171  : 	// Version number to maintain backwards compatibility
; 172  : 	uint uiVersion;
; 173  : 	kStream >> uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+4]
	lea	eax, DWORD PTR _uiVersion$[esp+4]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 174  : 
; 175  : 	kStream >> m_iID;

	lea	ecx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 176  : 	kStream >> m_iNumTiles;

	lea	edx, DWORD PTR [esi+8]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 177  : 
; 178  : 	kStream >> m_iCentroidX;

	lea	eax, DWORD PTR [esi+16]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 179  : 	kStream >> m_iCentroidY;

	lea	ecx, DWORD PTR [esi+20]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 180  : 
; 181  : 	kStream >> m_bWater;

	lea	edx, DWORD PTR [esi+13]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 182  : 
; 183  : 	kStream >> m_cContinentType;

	add	esi, 12					; 0000000cH
	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read
	pop	edi
	pop	esi

; 184  : }

	ret	4
?read@CvLandmass@@UAEXAAVFDataStream@@@Z ENDP		; CvLandmass::read
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?write@CvLandmass@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?write@CvLandmass@@UBEXAAVFDataStream@@@Z PROC		; CvLandmass::write, COMDAT
; _this$ = ecx

; 188  : {

	push	ecx
	push	esi
	push	edi

; 189  : 	// Current version number
; 190  : 	uint uiVersion = 1;
; 191  : 	kStream << uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+8]
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+16], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 192  : 
; 193  : 	kStream << m_iID;

	lea	ecx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 194  : 	kStream << m_iNumTiles;

	lea	edx, DWORD PTR [esi+8]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 195  : 
; 196  : 	kStream << m_iCentroidX;

	lea	eax, DWORD PTR [esi+16]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 197  : 	kStream << m_iCentroidY;

	lea	ecx, DWORD PTR [esi+20]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 198  : 
; 199  : 	kStream << m_bWater;

	lea	edx, DWORD PTR [esi+13]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 200  : 
; 201  : 	kStream << m_cContinentType;

	add	esi, 12					; 0000000cH
	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write
	pop	edi
	pop	esi

; 202  : 
; 203  : }

	pop	ecx
	ret	4
?write@CvLandmass@@UBEXAAVFDataStream@@@Z ENDP		; CvLandmass::write
_TEXT	ENDS
PUBLIC	?InitPlots@CvMap@@IAEXXZ			; CvMap::InitPlots
EXTRN	?Init@CvPlotManager@@QAEXII@Z:PROC		; CvPlotManager::Init
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??0CvPlot@@QAE@XZ:PROC				; CvPlot::CvPlot
EXTRN	_memset:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
xdata$x	SEGMENT
__unwindtable$?InitPlots@CvMap@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InitPlots@CvMap@@IAEXXZ$0
__ehfuncinfo$?InitPlots@CvMap@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?InitPlots@CvMap@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.cpp
xdata$x	ENDS
;	COMDAT ?InitPlots@CvMap@@IAEXXZ
_TEXT	SEGMENT
_pVisibilityCount$ = -40				; size = 4
_pRevealedOwner$ = -36					; size = 4
_pRevealedImprovementType$ = -32			; size = 4
_pRevealedRouteType$ = -28				; size = 4
_pNoSettling$ = -24					; size = 4
_pResourceForceReveal$ = -20				; size = 4
tv410 = -16						; size = 4
tv210 = -16						; size = 4
$T238748 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?InitPlots@CvMap@@IAEXXZ PROC				; CvMap::InitPlots, COMDAT
; _this$ = ecx

; 265  : {

	push	-1
	push	__ehhandler$?InitPlots@CvMap@@IAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 266  : 	m_pMapPlots = FNEW(CvPlot[numPlots()], c_eCiv5GameplayDLL, 0);

	mov	edi, DWORD PTR [esi+4028]
	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 484				; 000001e4H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T238748[esp+56], eax
	mov	DWORD PTR __$EHRec$[esp+64], 0
	test	eax, eax
	je	SHORT $LN6@InitPlots
	push	OFFSET ??1CvPlot@@QAE@XZ		; CvPlot::~CvPlot
	push	OFFSET ??0CvPlot@@QAE@XZ		; CvPlot::CvPlot
	push	edi
	lea	ebx, DWORD PTR [eax+4]
	push	484					; 000001e4H
	push	ebx
	mov	DWORD PTR [eax], edi
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	eax, ebx
	jmp	SHORT $LN7@InitPlots
$LN6@InitPlots:
	xor	eax, eax
$LN7@InitPlots:

; 267  : 	//allocate all the memory we need up front
; 268  : 
; 269  : 	int iNumPlots = numPlots();

	mov	ebp, DWORD PTR [esi+4028]
	mov	DWORD PTR [esi+4068], eax

; 270  : 
; 271  : #ifdef AUI_WARNING_FIXES
; 272  : 	m_pYields					= FNEW(int[NUM_YIELD_TYPES*iNumPlots], c_eCiv5GameplayDLL, 0);
; 273  : 	m_pFoundValue				= FNEW(int[REALLY_MAX_PLAYERS*iNumPlots], c_eCiv5GameplayDLL, 0);
; 274  : 	m_pPlayerCityRadiusCount	= FNEW(int[REALLY_MAX_PLAYERS*iNumPlots], c_eCiv5GameplayDLL, 0);
; 275  : 	m_pVisibilityCount			= FNEW(int[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);
; 276  : 	m_pRevealedOwner			= FNEW(int[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);
; 277  : 	m_pRevealed					= FNEW(bool[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);
; 278  : 	m_pRevealedImprovementType	= FNEW(int[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);
; 279  : 	m_pRevealedRouteType		= FNEW(int[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);
; 280  : #else
; 281  : 	m_pYields					= FNEW(short[NUM_YIELD_TYPES*iNumPlots], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	lea	eax, DWORD PTR [ebp+ebp*2]
	add	eax, eax
	mov	edx, 2
	mul	edx
	seto	cl
	mov	DWORD PTR __$EHRec$[esp+64], -1
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 282  : 	m_pFoundValue				= FNEW(int[REALLY_MAX_PLAYERS*iNumPlots], c_eCiv5GameplayDLL, 0);

	lea	edi, DWORD PTR [ebp+ebp*4]
	mov	DWORD PTR [esi+4072], eax
	shl	edi, 4
	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 283  : 	m_pPlayerCityRadiusCount	= FNEW(char[REALLY_MAX_PLAYERS*iNumPlots], c_eCiv5GameplayDLL, 0);

	push	edi
	mov	DWORD PTR [esi+4076], eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+4080], eax

; 284  : 	m_pVisibilityCount			= FNEW(short[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 285  : 	m_pRevealedOwner			= FNEW(char[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);

	push	edi
	mov	DWORD PTR [esi+4084], eax
	call	??_U@YAPAXI@Z				; operator new[]

; 286  : 	m_pRevealed					= FNEW(bool[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);

	push	edi
	mov	DWORD PTR [esi+4088], eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+4092], eax

; 287  : 	m_pRevealedImprovementType  = FNEW(short[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+4096], eax

; 288  : 	m_pRevealedRouteType		= FNEW(short[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+4100], eax

; 289  : #endif
; 290  : 	m_pNoSettling				= FNEW(bool[MAX_MAJOR_CIVS*iNumPlots], c_eCiv5GameplayDLL, 0);

	mov	eax, ebp
	imul	eax, 22					; 00000016H
	push	eax
	mov	DWORD PTR tv410[esp+92], eax
	call	??_U@YAPAXI@Z				; operator new[]

; 291  : 	m_pResourceForceReveal		= FNEW(bool[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);

	push	edi
	mov	DWORD PTR [esi+4104], eax
	call	??_U@YAPAXI@Z				; operator new[]

; 292  : 
; 293  : 	memset(m_pYields, 0, NUM_YIELD_TYPES*iNumPlots*sizeof(short));

	mov	ecx, DWORD PTR [esi+4072]
	mov	DWORD PTR [esi+4108], eax
	lea	eax, DWORD PTR [ebp+ebp*2]
	add	eax, eax
	add	eax, eax
	push	eax
	push	0
	push	ecx
	call	_memset

; 294  : 	memset(m_pFoundValue, 0, REALLY_MAX_PLAYERS*iNumPlots*sizeof(int));

	mov	eax, DWORD PTR [esi+4076]
	lea	edx, DWORD PTR [ebp+ebp*4]
	shl	edx, 6
	push	edx
	push	0
	push	eax
	call	_memset

; 295  : 	memset(m_pPlayerCityRadiusCount, 0, REALLY_MAX_PLAYERS*iNumPlots*sizeof(char));

	mov	ecx, DWORD PTR [esi+4080]
	add	esp, 64					; 00000040H
	push	edi
	push	0
	push	ecx
	call	_memset

; 296  : 	memset(m_pVisibilityCount, 0,REALLY_MAX_TEAMS*iNumPlots *sizeof(short));

	mov	edx, DWORD PTR [esi+4084]
	lea	ebx, DWORD PTR [ebp+ebp*4]
	shl	ebx, 5
	push	ebx
	push	0
	push	edx
	call	_memset

; 297  : 	memset(m_pRevealedOwner, -1 ,REALLY_MAX_TEAMS*iNumPlots *sizeof(char));

	mov	eax, DWORD PTR [esi+4088]
	push	edi
	push	-1
	push	eax
	call	_memset

; 298  : 	memset(m_pRevealed, 0,REALLY_MAX_TEAMS*iNumPlots *sizeof(bool));

	mov	ecx, DWORD PTR [esi+4092]
	push	edi
	push	0
	push	ecx
	call	_memset

; 299  : 	memset(m_pRevealedImprovementType, 0,REALLY_MAX_TEAMS*iNumPlots *sizeof(short));

	mov	edx, DWORD PTR [esi+4096]
	push	ebx
	push	0
	push	edx
	call	_memset

; 300  : 	memset(m_pRevealedRouteType, 0,REALLY_MAX_TEAMS*iNumPlots *sizeof(short));

	mov	eax, DWORD PTR [esi+4100]
	push	ebx
	push	0
	push	eax
	call	_memset

; 301  : 	memset(m_pNoSettling, 0,MAX_MAJOR_CIVS*iNumPlots *sizeof(bool));

	mov	ecx, DWORD PTR tv410[esp+128]
	mov	edx, DWORD PTR [esi+4104]
	add	esp, 72					; 00000048H
	push	ecx
	push	0
	push	edx
	call	_memset

; 302  : 	memset(m_pResourceForceReveal, 0,REALLY_MAX_TEAMS*iNumPlots *sizeof(bool));

	mov	eax, DWORD PTR [esi+4108]
	push	edi
	push	0
	push	eax
	call	_memset

; 303  : 
; 304  : 
; 305  : #ifdef AUI_WARNING_FIXES
; 306  : 	int* pYields					= m_pYields;
; 307  : 	int* pFoundValue				= m_pFoundValue;
; 308  : 	int* pPlayerCityRadiusCount		= m_pPlayerCityRadiusCount;
; 309  : 	int* pVisibilityCount			= m_pVisibilityCount;
; 310  : 	int* pRevealedOwner				= m_pRevealedOwner;
; 311  : 	int* pRevealedImprovementType	= m_pRevealedImprovementType;
; 312  : 	int* pRevealedRouteType			= m_pRevealedRouteType;
; 313  : #else
; 314  : 	short* pYields					= m_pYields;
; 315  : 	int*   pFoundValue				= m_pFoundValue;
; 316  : 	char*  pPlayerCityRadiusCount   = m_pPlayerCityRadiusCount;
; 317  : 	short* pVisibilityCount			= m_pVisibilityCount;

	mov	eax, DWORD PTR [esi+4084]
	mov	ecx, DWORD PTR [esi+4072]
	mov	edx, DWORD PTR [esi+4076]
	mov	edi, DWORD PTR [esi+4080]
	mov	DWORD PTR _pVisibilityCount$[esp+80], eax

; 318  : 	char*  pRevealedOwner			= m_pRevealedOwner;

	mov	eax, DWORD PTR [esi+4088]
	mov	DWORD PTR _pRevealedOwner$[esp+80], eax

; 319  : 	short* pRevealedImprovementType = m_pRevealedImprovementType;

	mov	eax, DWORD PTR [esi+4096]
	mov	DWORD PTR _pRevealedImprovementType$[esp+80], eax

; 320  : 	short* pRevealedRouteType		= m_pRevealedRouteType;

	mov	eax, DWORD PTR [esi+4100]
	mov	DWORD PTR _pRevealedRouteType$[esp+80], eax

; 321  : #endif
; 322  : 	bool*  pNoSettling				= m_pNoSettling;

	mov	eax, DWORD PTR [esi+4104]
	mov	DWORD PTR _pNoSettling$[esp+80], eax

; 323  : 	bool*  pResourceForceReveal		= m_pResourceForceReveal;

	mov	eax, DWORD PTR [esi+4108]
	add	esp, 24					; 00000018H
	mov	DWORD PTR _pResourceForceReveal$[esp+56], eax

; 324  : 
; 325  : 	for(int i = 0; i < iNumPlots; i++)

	test	ebp, ebp
	jle	$LN1@InitPlots
	xor	eax, eax
	mov	DWORD PTR tv210[esp+56], ebp
	npad	5
$LL19@InitPlots:

; 326  : 	{
; 327  : 		m_pMapPlots[i].m_aiYield				= pYields;

	mov	ebx, DWORD PTR [esi+4068]

; 328  : 		m_pMapPlots[i].m_aiFoundValue			= pFoundValue;
; 329  : 		m_pMapPlots[i].m_aiPlayerCityRadiusCount= pPlayerCityRadiusCount;
; 330  : 		m_pMapPlots[i].m_aiVisibilityCount		= pVisibilityCount;

	mov	ebp, DWORD PTR _pVisibilityCount$[esp+56]
	mov	DWORD PTR [eax+ebx+144], ecx
	mov	ebx, DWORD PTR [esi+4068]
	mov	DWORD PTR [eax+ebx+148], edx
	mov	ebx, DWORD PTR [esi+4068]
	mov	DWORD PTR [eax+ebx+152], edi
	mov	ebx, DWORD PTR [esi+4068]
	mov	DWORD PTR [eax+ebx+156], ebp

; 331  : 		m_pMapPlots[i].m_aiRevealedOwner		= pRevealedOwner;

	mov	ebx, DWORD PTR [esi+4068]
	mov	ebp, DWORD PTR _pRevealedOwner$[esp+56]

; 332  : 
; 333  : 		m_pMapPlots[i].m_aeRevealedImprovementType	= pRevealedImprovementType;
; 334  : 		m_pMapPlots[i].m_aeRevealedRouteType		= pRevealedRouteType;
; 335  : 		m_pMapPlots[i].m_abNoSettling				= pNoSettling;
; 336  : 
; 337  : 		m_pMapPlots[i].m_abResourceForceReveal		= pResourceForceReveal;
; 338  : 
; 339  : 
; 340  : 		pYields					+= NUM_YIELD_TYPES;
; 341  : 		pFoundValue				+= REALLY_MAX_PLAYERS;
; 342  : 		pPlayerCityRadiusCount  += REALLY_MAX_PLAYERS;
; 343  : 		pVisibilityCount		+= REALLY_MAX_TEAMS;

	add	DWORD PTR _pVisibilityCount$[esp+56], 160 ; 000000a0H

; 344  : 		pRevealedOwner			+= REALLY_MAX_TEAMS;

	add	DWORD PTR _pRevealedOwner$[esp+56], 80	; 00000050H
	mov	DWORD PTR [eax+ebx+160], ebp
	mov	ebx, DWORD PTR [esi+4068]
	mov	ebp, DWORD PTR _pRevealedImprovementType$[esp+56]

; 345  : 		pRevealedImprovementType+= REALLY_MAX_TEAMS;

	add	DWORD PTR _pRevealedImprovementType$[esp+56], 160 ; 000000a0H
	mov	DWORD PTR [eax+ebx+164], ebp
	mov	ebx, DWORD PTR [esi+4068]
	mov	ebp, DWORD PTR _pRevealedRouteType$[esp+56]

; 346  : 		pRevealedRouteType		+= REALLY_MAX_TEAMS;

	add	DWORD PTR _pRevealedRouteType$[esp+56], 160 ; 000000a0H
	mov	DWORD PTR [eax+ebx+168], ebp
	mov	ebx, DWORD PTR [esi+4068]
	mov	ebp, DWORD PTR _pNoSettling$[esp+56]

; 347  : 		pNoSettling				+= MAX_MAJOR_CIVS;

	add	DWORD PTR _pNoSettling$[esp+56], 22	; 00000016H
	mov	DWORD PTR [eax+ebx+172], ebp
	mov	ebx, DWORD PTR _pResourceForceReveal$[esp+56]
	mov	ebp, DWORD PTR [esi+4068]
	mov	DWORD PTR [eax+ebp+176], ebx

; 348  : 		pResourceForceReveal	+= REALLY_MAX_TEAMS;

	add	ebx, 80					; 00000050H
	add	ecx, 12					; 0000000cH
	add	edx, 320				; 00000140H
	add	edi, 80					; 00000050H
	add	eax, 484				; 000001e4H
	sub	DWORD PTR tv210[esp+56], 1
	mov	DWORD PTR _pResourceForceReveal$[esp+56], ebx
	jne	$LL19@InitPlots
$LN1@InitPlots:

; 349  : 
; 350  : 	}
; 351  : 
; 352  : 	m_kPlotManager.Init(getGridWidth(), getGridHeight());

	mov	ecx, DWORD PTR [esi+4024]
	mov	edx, DWORD PTR [esi+4020]
	push	ecx
	push	edx
	lea	ecx, DWORD PTR [esi+4184]
	call	?Init@CvPlotManager@@QAEXII@Z		; CvPlotManager::Init

; 353  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InitPlots@CvMap@@IAEXXZ$0:
	mov	eax, DWORD PTR $T238748[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?InitPlots@CvMap@@IAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?InitPlots@CvMap@@IAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?InitPlots@CvMap@@IAEXXZ ENDP				; CvMap::InitPlots
PUBLIC	?uninit@CvMap@@QAEXXZ				; CvMap::uninit
EXTRN	?Uninit@CvPlotManager@@QAEXXZ:PROC		; CvPlotManager::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?uninit@CvMap@@QAEXXZ
_TEXT	SEGMENT
?uninit@CvMap@@QAEXXZ PROC				; CvMap::uninit, COMDAT
; _this$ = ecx

; 406  : {

	push	esi
	mov	esi, ecx

; 407  : 	SAFE_DELETE_ARRAY(m_paiNumResource);

	mov	eax, DWORD PTR [esi+4060]
	push	edi
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	edi, edi
	mov	DWORD PTR [esi+4060], edi

; 408  : 	SAFE_DELETE_ARRAY(m_paiNumResourceOnLand);

	mov	ecx, DWORD PTR [esi+4064]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+4064], edi

; 409  : 
; 410  : 	SAFE_DELETE_ARRAY(m_pMapPlots);

	mov	eax, DWORD PTR [esi+4068]
	add	esp, 8
	cmp	eax, edi
	je	SHORT $LN9@uninit
	mov	edx, DWORD PTR [eax-4]
	push	ebx
	lea	ebx, DWORD PTR [eax-4]
	push	OFFSET ??1CvPlot@@QAE@XZ		; CvPlot::~CvPlot
	push	edx
	push	484					; 000001e4H
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	push	ebx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	pop	ebx
$LN9@uninit:
	mov	DWORD PTR [esi+4068], edi

; 411  : 
; 412  : 
; 413  : 	SAFE_DELETE_ARRAY(m_pYields);

	mov	eax, DWORD PTR [esi+4072]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+4072], edi

; 414  : 	SAFE_DELETE_ARRAY(m_pFoundValue);

	mov	ecx, DWORD PTR [esi+4076]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+4076], edi

; 415  : 	SAFE_DELETE_ARRAY(m_pPlayerCityRadiusCount);

	mov	edx, DWORD PTR [esi+4080]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+4080], edi

; 416  : 	SAFE_DELETE_ARRAY(m_pVisibilityCount);

	mov	eax, DWORD PTR [esi+4084]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+4084], edi

; 417  : 	SAFE_DELETE_ARRAY(m_pRevealedOwner);

	mov	ecx, DWORD PTR [esi+4088]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+4088], edi

; 418  : 	SAFE_DELETE_ARRAY(m_pRevealed);

	mov	edx, DWORD PTR [esi+4092]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+4092], edi

; 419  : 	SAFE_DELETE_ARRAY(m_pRevealedImprovementType);

	mov	eax, DWORD PTR [esi+4096]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+4096], edi

; 420  : 	SAFE_DELETE_ARRAY(m_pRevealedRouteType);

	mov	ecx, DWORD PTR [esi+4100]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+4100], edi

; 421  : 	SAFE_DELETE_ARRAY(m_pNoSettling);

	mov	edx, DWORD PTR [esi+4104]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+4104], edi

; 422  : 	SAFE_DELETE_ARRAY(m_pResourceForceReveal);

	mov	eax, DWORD PTR [esi+4108]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+4108], edi

; 423  : 
; 424  : 	m_iGridWidth = 0;
; 425  : 	m_iGridHeight = 0;
; 426  : 	m_iGridSize = 0;
; 427  : 	m_iLandPlots = 0;
; 428  : 	m_iOwnedPlots = 0;
; 429  : 	m_iNumNaturalWonders = 0;
; 430  : 
; 431  : 	m_areas.Uninit();

	mov	edx, DWORD PTR [esi+4112]
	mov	eax, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [esi+4112]
	add	esp, 40					; 00000028H
	mov	DWORD PTR [esi+4020], edi
	mov	DWORD PTR [esi+4024], edi
	mov	DWORD PTR [esi+4028], edi
	mov	DWORD PTR [esi+4032], edi
	mov	DWORD PTR [esi+4036], edi
	mov	DWORD PTR [esi+4048], edi
	call	eax

; 432  : 	m_landmasses.Uninit();

	mov	edx, DWORD PTR [esi+4140]
	mov	eax, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [esi+4140]
	call	eax
	pop	edi

; 433  : 	m_kPlotManager.Uninit();

	lea	ecx, DWORD PTR [esi+4184]
	pop	esi
	jmp	?Uninit@CvPlotManager@@QAEXXZ		; CvPlotManager::Uninit
?uninit@CvMap@@QAEXXZ ENDP				; CvMap::uninit
_TEXT	ENDS
PUBLIC	?setup@CvMap@@IAEXXZ				; CvMap::setup
EXTRN	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ:PROC ; CvGlobals::GetTacticalAnalysisMapFinder
EXTRN	?TacticalAnalysisMapPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; TacticalAnalysisMapPathValid
EXTRN	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::GetInternationalTradeRouteWaterFinder
EXTRN	?TradeRouteWaterPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; TradeRouteWaterPathCost
EXTRN	?TradeRouteWaterValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; TradeRouteWaterValid
EXTRN	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::GetInternationalTradeRouteLandFinder
EXTRN	?TradeRouteHeuristic@@YAHHHHH@Z:PROC		; TradeRouteHeuristic
EXTRN	?TradeRouteLandPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; TradeRouteLandPathCost
EXTRN	?TradeRouteLandValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; TradeRouteLandValid
EXTRN	?TradePathInitialize@@YAXPBXPAVCvAStar@@@Z:PROC	; TradePathInitialize
EXTRN	?TradePathUninitialize@@YAXPBXPAVCvAStar@@@Z:PROC ; TradePathUninitialize
EXTRN	?GetBuildRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::GetBuildRouteFinder
EXTRN	?BuildRouteCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; BuildRouteCost
EXTRN	?BuildRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; BuildRouteValid
EXTRN	?getInfluenceFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::getInfluenceFinder
EXTRN	?InfluenceDestValid@@YAHHHPBXPAVCvAStar@@@Z:PROC ; InfluenceDestValid
EXTRN	?InfluenceHeuristic@@YAHHHHH@Z:PROC		; InfluenceHeuristic
EXTRN	?InfluenceCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; InfluenceCost
EXTRN	?InfluenceValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; InfluenceValid
EXTRN	?InfluenceAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; InfluenceAdd
EXTRN	?getAreaFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::getAreaFinder
EXTRN	?AreaValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; AreaValid
EXTRN	?JoinArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; JoinArea
EXTRN	?GetWaterRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::GetWaterRouteFinder
EXTRN	?WaterRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; WaterRouteValid
EXTRN	?getRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::getRouteFinder
EXTRN	?RouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; RouteValid
EXTRN	?RouteGetNumExtraChildren@@YAHPAVCvAStarNode@@PAVCvAStar@@@Z:PROC ; RouteGetNumExtraChildren
EXTRN	?RouteGetExtraChild@@YAHPAVCvAStarNode@@HAAH1PAVCvAStar@@@Z:PROC ; RouteGetExtraChild
EXTRN	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ:PROC ; CvGlobals::getStepFinder
EXTRN	?StepDestValid@@YAHHHPBXPAVCvAStar@@@Z:PROC	; StepDestValid
EXTRN	?StepHeuristic@@YAHHHHH@Z:PROC			; StepHeuristic
EXTRN	?StepCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; StepCost
EXTRN	?StepValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; StepValid
EXTRN	?StepAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; StepAdd
EXTRN	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z:PROC ; CvAStar::Initialize
EXTRN	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ:PROC ; CvGlobals::getIgnoreUnitsPathFinder
EXTRN	?IgnoreUnitsDestValid@@YAHHHPBXPAVCvAStar@@@Z:PROC ; IgnoreUnitsDestValid
EXTRN	?IgnoreUnitsCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; IgnoreUnitsCost
EXTRN	?IgnoreUnitsValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; IgnoreUnitsValid
EXTRN	?IgnoreUnitsPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; IgnoreUnitsPathAdd
EXTRN	?getInterfacePathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ:PROC ; CvGlobals::getInterfacePathFinder
EXTRN	?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z:PROC ; CvTwoLayerPathFinder::Initialize
EXTRN	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ:PROC ; CvGlobals::getPathFinder
EXTRN	?PathDest@@YAHHHPBXPAVCvAStar@@@Z:PROC		; PathDest
EXTRN	?PathDestValid@@YAHHHPBXPAVCvAStar@@@Z:PROC	; PathDestValid
EXTRN	?PathHeuristic@@YAHHHHH@Z:PROC			; PathHeuristic
EXTRN	?PathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; PathCost
EXTRN	?PathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; PathValid
EXTRN	?PathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; PathAdd
EXTRN	?PathNodeAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; PathNodeAdd
EXTRN	?UnitPathInitialize@@YAXPBXPAVCvAStar@@@Z:PROC	; UnitPathInitialize
EXTRN	?UnitPathUninitialize@@YAXPBXPAVCvAStar@@@Z:PROC ; UnitPathUninitialize
; Function compile flags: /Ogtpy
;	COMDAT ?setup@CvMap@@IAEXXZ
_TEXT	SEGMENT
$T239089 = -8						; size = 1
$T239073 = -8						; size = 1
$T239057 = -8						; size = 1
$T239041 = -8						; size = 1
$T239025 = -8						; size = 1
$T239009 = -8						; size = 1
$T238993 = -8						; size = 1
$T238977 = -8						; size = 1
$T238961 = -8						; size = 1
$T238940 = -8						; size = 1
$T238919 = -8						; size = 1
$T238894 = -8						; size = 1
$T239085 = -4						; size = 1
$T239069 = -4						; size = 1
$T239053 = -4						; size = 1
$T239037 = -4						; size = 1
$T239021 = -4						; size = 1
$T239005 = -4						; size = 1
$T238989 = -4						; size = 1
$T238973 = -4						; size = 1
$T238957 = -4						; size = 1
$T238936 = -4						; size = 1
$T238915 = -4						; size = 1
$T238898 = -4						; size = 1
?setup@CvMap@@IAEXXZ PROC				; CvMap::setup, COMDAT
; _this$ = ecx

; 522  : {

	sub	esp, 8
	push	ebx
	push	esi

; 523  : 	GC.getPathFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, PathDestValid, PathHeuristic, PathCost, PathValid, PathAdd, PathNodeAdd, UnitPathInitialize, UnitPathUninitialize, NULL);

	push	0
	push	OFFSET ?UnitPathUninitialize@@YAXPBXPAVCvAStar@@@Z ; UnitPathUninitialize
	push	OFFSET ?UnitPathInitialize@@YAXPBXPAVCvAStar@@@Z ; UnitPathInitialize
	push	OFFSET ?PathNodeAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathNodeAdd
	push	OFFSET ?PathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathAdd
	push	OFFSET ?PathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathValid
	mov	esi, ecx
	movzx	eax, BYTE PTR [esi+4057]
	movzx	ecx, BYTE PTR [esi+4056]
	push	OFFSET ?PathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathCost
	push	OFFSET ?PathHeuristic@@YAHHHHH@Z	; PathHeuristic
	push	OFFSET ?PathDestValid@@YAHHHPBXPAVCvAStar@@@Z ; PathDestValid
	mov	BYTE PTR $T238894[esp+52], al
	mov	edx, DWORD PTR $T238894[esp+52]
	mov	eax, DWORD PTR [esi+4024]
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	mov	BYTE PTR $T238898[esp+56], cl
	mov	ecx, DWORD PTR [esi+4020]
	push	edx
	mov	edx, DWORD PTR $T238898[esp+60]
	push	edx
	push	eax
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	ecx, eax
	call	?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z ; CvTwoLayerPathFinder::Initialize

; 524  : 	GC.getPathFinder().SetDataChangeInvalidatesCache(true);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder

; 525  : 	GC.getInterfacePathFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, PathDestValid, PathHeuristic, PathCost, PathValid, PathAdd, PathNodeAdd, UnitPathInitialize, UnitPathUninitialize, NULL);

	push	0
	push	OFFSET ?UnitPathUninitialize@@YAXPBXPAVCvAStar@@@Z ; UnitPathUninitialize
	push	OFFSET ?UnitPathInitialize@@YAXPBXPAVCvAStar@@@Z ; UnitPathInitialize
	push	OFFSET ?PathNodeAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathNodeAdd
	push	OFFSET ?PathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathAdd
	push	OFFSET ?PathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathValid
	push	OFFSET ?PathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathCost
	push	OFFSET ?PathHeuristic@@YAHHHHH@Z	; PathHeuristic
	mov	bl, 1
	mov	BYTE PTR [eax+80], bl
	movzx	eax, BYTE PTR [esi+4057]
	movzx	ecx, BYTE PTR [esi+4056]
	push	OFFSET ?PathDestValid@@YAHHHPBXPAVCvAStar@@@Z ; PathDestValid
	mov	BYTE PTR $T238915[esp+52], al
	mov	edx, DWORD PTR $T238915[esp+52]
	mov	eax, DWORD PTR [esi+4024]
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	mov	BYTE PTR $T238919[esp+56], cl
	mov	ecx, DWORD PTR [esi+4020]
	push	edx
	mov	edx, DWORD PTR $T238919[esp+60]
	push	edx
	push	eax
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInterfacePathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getInterfacePathFinder
	mov	ecx, eax
	call	?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z ; CvTwoLayerPathFinder::Initialize

; 526  : 	GC.getInterfacePathFinder().SetDataChangeInvalidatesCache(true);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInterfacePathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getInterfacePathFinder

; 527  : 	GC.getIgnoreUnitsPathFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest,  IgnoreUnitsDestValid, PathHeuristic, IgnoreUnitsCost, IgnoreUnitsValid, IgnoreUnitsPathAdd, NULL, NULL, NULL, UnitPathInitialize, UnitPathUninitialize, NULL);

	push	0
	push	OFFSET ?UnitPathUninitialize@@YAXPBXPAVCvAStar@@@Z ; UnitPathUninitialize
	push	OFFSET ?UnitPathInitialize@@YAXPBXPAVCvAStar@@@Z ; UnitPathInitialize
	push	0
	push	0
	push	0
	push	OFFSET ?IgnoreUnitsPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; IgnoreUnitsPathAdd
	push	OFFSET ?IgnoreUnitsValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; IgnoreUnitsValid
	mov	BYTE PTR [eax+80], bl
	movzx	eax, BYTE PTR [esi+4057]
	movzx	ecx, BYTE PTR [esi+4056]
	push	OFFSET ?IgnoreUnitsCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; IgnoreUnitsCost
	push	OFFSET ?PathHeuristic@@YAHHHHH@Z	; PathHeuristic
	mov	BYTE PTR $T238936[esp+56], al
	mov	eax, DWORD PTR [esi+4024]
	mov	edx, DWORD PTR $T238936[esp+56]
	push	OFFSET ?IgnoreUnitsDestValid@@YAHHHPBXPAVCvAStar@@@Z ; IgnoreUnitsDestValid
	mov	BYTE PTR $T238940[esp+60], cl
	mov	ecx, DWORD PTR [esi+4020]
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	push	edx
	mov	edx, DWORD PTR $T238940[esp+68]
	push	edx
	push	eax
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	ecx, eax
	call	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize

; 528  : 	GC.getIgnoreUnitsPathFinder().SetDataChangeInvalidatesCache(true);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder

; 529  : 	GC.getStepFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, StepDestValid, StepHeuristic, StepCost, StepValid, StepAdd, NULL, NULL, NULL, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ?StepAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; StepAdd
	push	OFFSET ?StepValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; StepValid
	push	OFFSET ?StepCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; StepCost
	mov	BYTE PTR [eax+80], bl
	movzx	eax, BYTE PTR [esi+4057]
	movzx	ecx, BYTE PTR [esi+4056]
	push	OFFSET ?StepHeuristic@@YAHHHHH@Z	; StepHeuristic
	push	OFFSET ?StepDestValid@@YAHHHPBXPAVCvAStar@@@Z ; StepDestValid
	mov	BYTE PTR $T238957[esp+60], al
	mov	edx, DWORD PTR $T238957[esp+60]
	mov	eax, DWORD PTR [esi+4024]
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	mov	BYTE PTR $T238961[esp+64], cl
	mov	ecx, DWORD PTR [esi+4020]
	push	edx
	mov	edx, DWORD PTR $T238961[esp+68]
	push	edx
	push	eax
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize

; 530  : 	GC.getRouteFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, NULL, NULL, NULL, RouteValid, NULL, NULL, RouteGetNumExtraChildren, RouteGetExtraChild, NULL, NULL, NULL);

	movzx	eax, BYTE PTR [esi+4057]
	movzx	ecx, BYTE PTR [esi+4056]
	push	0
	push	0
	push	0
	push	OFFSET ?RouteGetExtraChild@@YAHPAVCvAStarNode@@HAAH1PAVCvAStar@@@Z ; RouteGetExtraChild
	push	OFFSET ?RouteGetNumExtraChildren@@YAHPAVCvAStarNode@@PAVCvAStar@@@Z ; RouteGetNumExtraChildren
	push	0
	push	0
	push	OFFSET ?RouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; RouteValid
	push	0
	push	0
	push	0
	mov	BYTE PTR $T238973[esp+60], al
	mov	edx, DWORD PTR $T238973[esp+60]
	mov	eax, DWORD PTR [esi+4024]
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	mov	BYTE PTR $T238977[esp+64], cl
	mov	ecx, DWORD PTR [esi+4020]
	push	edx
	mov	edx, DWORD PTR $T238977[esp+68]
	push	edx
	push	eax
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getRouteFinder
	mov	ecx, eax
	call	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize

; 531  : 	GC.GetWaterRouteFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, NULL, NULL, NULL, WaterRouteValid, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

	movzx	eax, BYTE PTR [esi+4057]
	movzx	ecx, BYTE PTR [esi+4056]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	BYTE PTR $T238989[esp+40], al
	mov	eax, DWORD PTR [esi+4024]
	mov	BYTE PTR $T238993[esp+40], cl
	mov	ecx, DWORD PTR [esi+4020]
	push	0
	mov	edx, DWORD PTR $T238989[esp+44]
	push	OFFSET ?WaterRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; WaterRouteValid
	push	0
	push	0
	push	0
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	push	edx
	mov	edx, DWORD PTR $T238993[esp+68]
	push	edx
	push	eax
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetWaterRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetWaterRouteFinder
	mov	ecx, eax
	call	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize

; 532  : 	GC.getAreaFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, NULL, NULL, NULL, AreaValid, NULL, JoinArea, NULL, NULL, NULL, NULL, NULL);

	movzx	eax, BYTE PTR [esi+4057]
	movzx	ecx, BYTE PTR [esi+4056]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ?JoinArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; JoinArea
	push	0
	push	OFFSET ?AreaValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; AreaValid
	push	0
	push	0
	push	0
	mov	BYTE PTR $T239005[esp+60], al
	mov	edx, DWORD PTR $T239005[esp+60]
	mov	eax, DWORD PTR [esi+4024]
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	mov	BYTE PTR $T239009[esp+64], cl
	mov	ecx, DWORD PTR [esi+4020]
	push	edx
	mov	edx, DWORD PTR $T239009[esp+68]
	push	edx
	push	eax
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAreaFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getAreaFinder
	mov	ecx, eax
	call	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize

; 533  : 	GC.getInfluenceFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, InfluenceDestValid, InfluenceHeuristic, InfluenceCost, InfluenceValid, InfluenceAdd, NULL, NULL, NULL, NULL, NULL, NULL);

	movzx	eax, BYTE PTR [esi+4057]
	movzx	ecx, BYTE PTR [esi+4056]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ?InfluenceAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; InfluenceAdd
	push	OFFSET ?InfluenceValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; InfluenceValid
	push	OFFSET ?InfluenceCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; InfluenceCost
	push	OFFSET ?InfluenceHeuristic@@YAHHHHH@Z	; InfluenceHeuristic
	push	OFFSET ?InfluenceDestValid@@YAHHHPBXPAVCvAStar@@@Z ; InfluenceDestValid
	mov	BYTE PTR $T239021[esp+60], al
	mov	edx, DWORD PTR $T239021[esp+60]
	mov	eax, DWORD PTR [esi+4024]
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	mov	BYTE PTR $T239025[esp+64], cl
	mov	ecx, DWORD PTR [esi+4020]
	push	edx
	mov	edx, DWORD PTR $T239025[esp+68]
	push	edx
	push	eax
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfluenceFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getInfluenceFinder
	mov	ecx, eax
	call	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize

; 534  : 	GC.GetBuildRouteFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, NULL, NULL, BuildRouteCost, BuildRouteValid, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

	movzx	eax, BYTE PTR [esi+4057]
	movzx	ecx, BYTE PTR [esi+4056]
	push	0
	push	0
	push	0
	mov	BYTE PTR $T239037[esp+28], al
	mov	eax, DWORD PTR [esi+4024]
	mov	BYTE PTR $T239041[esp+28], cl
	mov	ecx, DWORD PTR [esi+4020]
	push	0
	mov	edx, DWORD PTR $T239037[esp+32]
	push	0
	push	0
	push	0
	push	OFFSET ?BuildRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; BuildRouteValid
	push	OFFSET ?BuildRouteCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; BuildRouteCost
	push	0
	push	0
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	push	edx
	mov	edx, DWORD PTR $T239041[esp+68]
	push	edx
	push	eax
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuildRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetBuildRouteFinder
	mov	ecx, eax
	call	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize

; 535  : 	GC.GetInternationalTradeRouteLandFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, NULL,	TradeRouteHeuristic, TradeRouteLandPathCost, TradeRouteLandValid, NULL, NULL, NULL, NULL, TradePathInitialize, TradePathUninitialize, NULL);

	movzx	eax, BYTE PTR [esi+4057]
	movzx	ecx, BYTE PTR [esi+4056]
	push	0
	push	OFFSET ?TradePathUninitialize@@YAXPBXPAVCvAStar@@@Z ; TradePathUninitialize
	push	OFFSET ?TradePathInitialize@@YAXPBXPAVCvAStar@@@Z ; TradePathInitialize
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ?TradeRouteLandValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; TradeRouteLandValid
	push	OFFSET ?TradeRouteLandPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; TradeRouteLandPathCost
	push	OFFSET ?TradeRouteHeuristic@@YAHHHHH@Z	; TradeRouteHeuristic
	push	0
	mov	BYTE PTR $T239053[esp+60], al
	mov	edx, DWORD PTR $T239053[esp+60]
	mov	eax, DWORD PTR [esi+4024]
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	mov	BYTE PTR $T239057[esp+64], cl
	mov	ecx, DWORD PTR [esi+4020]
	push	edx
	mov	edx, DWORD PTR $T239057[esp+68]
	push	edx
	push	eax
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteLandFinder
	mov	ecx, eax
	call	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize

; 536  : 	GC.GetInternationalTradeRouteWaterFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, NULL, TradeRouteHeuristic, TradeRouteWaterPathCost, TradeRouteWaterValid, NULL, NULL, NULL, NULL, TradePathInitialize, TradePathUninitialize, NULL);

	movzx	eax, BYTE PTR [esi+4057]
	movzx	ecx, BYTE PTR [esi+4056]
	push	0
	push	OFFSET ?TradePathUninitialize@@YAXPBXPAVCvAStar@@@Z ; TradePathUninitialize
	push	OFFSET ?TradePathInitialize@@YAXPBXPAVCvAStar@@@Z ; TradePathInitialize
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ?TradeRouteWaterValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; TradeRouteWaterValid
	push	OFFSET ?TradeRouteWaterPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; TradeRouteWaterPathCost
	push	OFFSET ?TradeRouteHeuristic@@YAHHHHH@Z	; TradeRouteHeuristic
	push	0
	mov	BYTE PTR $T239069[esp+60], al
	mov	edx, DWORD PTR $T239069[esp+60]
	mov	eax, DWORD PTR [esi+4024]
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	mov	BYTE PTR $T239073[esp+64], cl
	mov	ecx, DWORD PTR [esi+4020]
	push	edx
	mov	edx, DWORD PTR $T239073[esp+68]
	push	edx
	push	eax
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteWaterFinder
	mov	ecx, eax
	call	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize

; 537  : 	GC.GetTacticalAnalysisMapFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, PathDestValid, PathHeuristic, PathCost, TacticalAnalysisMapPathValid, PathAdd, PathNodeAdd, UnitPathInitialize, UnitPathUninitialize, NULL);

	movzx	eax, BYTE PTR [esi+4057]
	movzx	ecx, BYTE PTR [esi+4056]
	mov	BYTE PTR $T239085[esp+16], al
	mov	eax, DWORD PTR [esi+4024]
	mov	esi, DWORD PTR [esi+4020]
	mov	BYTE PTR $T239089[esp+16], cl
	push	0
	mov	edx, DWORD PTR $T239085[esp+20]
	mov	ecx, DWORD PTR $T239089[esp+20]
	push	OFFSET ?UnitPathUninitialize@@YAXPBXPAVCvAStar@@@Z ; UnitPathUninitialize
	push	OFFSET ?UnitPathInitialize@@YAXPBXPAVCvAStar@@@Z ; UnitPathInitialize
	push	OFFSET ?PathNodeAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathNodeAdd
	push	OFFSET ?PathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathAdd
	push	OFFSET ?TacticalAnalysisMapPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; TacticalAnalysisMapPathValid
	push	OFFSET ?PathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathCost
	push	OFFSET ?PathHeuristic@@YAHHHHH@Z	; PathHeuristic
	push	OFFSET ?PathDestValid@@YAHHHPBXPAVCvAStar@@@Z ; PathDestValid
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	push	edx
	push	ecx
	push	eax
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::GetTacticalAnalysisMapFinder
	mov	ecx, eax
	call	?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z ; CvTwoLayerPathFinder::Initialize

; 538  : 	GC.GetTacticalAnalysisMapFinder().SetDataChangeInvalidatesCache(true);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::GetTacticalAnalysisMapFinder
	pop	esi
	mov	BYTE PTR [eax+80], bl
	pop	ebx

; 539  : }

	add	esp, 8
	ret	0
?setup@CvMap@@IAEXXZ ENDP				; CvMap::setup
_TEXT	ENDS
PUBLIC	?setupGraphical@CvMap@@QAEXXZ			; CvMap::setupGraphical
EXTRN	?setupGraphical@CvPlot@@QAEXXZ:PROC		; CvPlot::setupGraphical
EXTRN	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ:PROC	; CvGlobals::IsGraphicsInitialized
; Function compile flags: /Ogtpy
;	COMDAT ?setupGraphical@CvMap@@QAEXXZ
_TEXT	SEGMENT
?setupGraphical@CvMap@@QAEXXZ PROC			; CvMap::setupGraphical, COMDAT
; _this$ = ecx

; 546  : {

	push	esi
	mov	esi, ecx

; 547  : 	if(!GC.IsGraphicsInitialized())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ ; CvGlobals::IsGraphicsInitialized
	test	al, al
	je	SHORT $LN1@setupGraph

; 548  : 		return;
; 549  : 
; 550  : 	if(m_pMapPlots != NULL)

	cmp	DWORD PTR [esi+4068], 0
	je	SHORT $LN1@setupGraph
	push	edi

; 551  : 	{
; 552  : #if defined(AUI_WARNING_FIXES) && defined(AUI_USE_OPENMP)
; 553  : #pragma omp parallel for
; 554  : 		for (int iI = 0; iI < (int)numPlots(); iI++)
; 555  : #elif defined(AUI_WARNING_FIXES)
; 556  : 		for (uint iI = 0; iI < numPlots(); iI++)
; 557  : #elif defined (AUI_USE_OPENMP)
; 558  : #pragma omp parallel for
; 559  : 		for (int iI = 0; iI < numPlots(); iI++)
; 560  : #else
; 561  : 		int iI;
; 562  : 		for(iI = 0; iI < numPlots(); iI++)

	xor	edi, edi
	cmp	DWORD PTR [esi+4028], edi
	jle	SHORT $LN14@setupGraph
	push	ebx
	xor	ebx, ebx
	npad	8
$LL3@setupGraph:

; 563  : #endif
; 564  : 		{
; 565  : 			plotByIndexUnchecked(iI)->setupGraphical();

	mov	ecx, DWORD PTR [esi+4068]
	add	ecx, ebx
	call	?setupGraphical@CvPlot@@QAEXXZ		; CvPlot::setupGraphical
	inc	edi
	add	ebx, 484				; 000001e4H
	cmp	edi, DWORD PTR [esi+4028]
	jl	SHORT $LL3@setupGraph
	pop	ebx
$LN14@setupGraph:
	pop	edi
$LN1@setupGraph:
	pop	esi

; 566  : 		}
; 567  : 	}
; 568  : }

	ret	0
?setupGraphical@CvMap@@QAEXXZ ENDP			; CvMap::setupGraphical
_TEXT	ENDS
PUBLIC	?erasePlots@CvMap@@QAEXXZ			; CvMap::erasePlots
EXTRN	?erase@CvPlot@@QAEX_N@Z:PROC			; CvPlot::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erasePlots@CvMap@@QAEXXZ
_TEXT	SEGMENT
?erasePlots@CvMap@@QAEXXZ PROC				; CvMap::erasePlots, COMDAT
; _this$ = ecx

; 573  : {

	push	esi
	push	edi
	mov	esi, ecx

; 574  : #ifdef AUI_WARNING_FIXES
; 575  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 576  : #else
; 577  : 	int iI;
; 578  : 
; 579  : 	for(iI = 0; iI < numPlots(); iI++)

	xor	edi, edi
	cmp	DWORD PTR [esi+4028], edi
	jle	SHORT $LN1@erasePlots
	push	ebx
	xor	ebx, ebx
$LL3@erasePlots:

; 580  : #endif
; 581  : 	{
; 582  : 		plotByIndexUnchecked(iI)->erase(true/*bEraseUnitsIfWater*/);

	mov	ecx, DWORD PTR [esi+4068]
	push	1
	add	ecx, ebx
	call	?erase@CvPlot@@QAEX_N@Z			; CvPlot::erase
	inc	edi
	add	ebx, 484				; 000001e4H
	cmp	edi, DWORD PTR [esi+4028]
	jl	SHORT $LL3@erasePlots
	pop	ebx
$LN1@erasePlots:
	pop	edi
	pop	esi

; 583  : 	}
; 584  : }

	ret	0
?erasePlots@CvMap@@QAEXXZ ENDP				; CvMap::erasePlots
_TEXT	ENDS
PUBLIC	?setRevealedPlots@CvMap@@QAEXW4TeamTypes@@_N1@Z	; CvMap::setRevealedPlots
EXTRN	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z:PROC ; CvPlot::setRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?setRevealedPlots@CvMap@@QAEXW4TeamTypes@@_N1@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
_bTerrainOnly$ = 16					; size = 1
?setRevealedPlots@CvMap@@QAEXW4TeamTypes@@_N1@Z PROC	; CvMap::setRevealedPlots, COMDAT
; _this$ = ecx

; 589  : {

	push	esi
	push	edi
	mov	esi, ecx

; 590  : #ifdef AUI_WARNING_FIXES
; 591  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 592  : #else
; 593  : 	int iI;
; 594  : 
; 595  : 	for(iI = 0; iI < numPlots(); iI++)

	xor	edi, edi
	cmp	DWORD PTR [esi+4028], edi
	jle	SHORT $LN1@setReveale
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _eTeam$[esp+12]
	xor	ebx, ebx
$LL3@setReveale:

; 596  : #endif
; 597  : 	{
; 598  : 		plotByIndexUnchecked(iI)->setRevealed(eTeam, bNewValue, bTerrainOnly);

	mov	eax, DWORD PTR _bTerrainOnly$[esp+12]
	mov	ecx, DWORD PTR _bNewValue$[esp+12]
	push	-1
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [esi+4068]
	push	ebp
	add	ecx, ebx
	call	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ; CvPlot::setRevealed
	inc	edi
	add	ebx, 484				; 000001e4H
	cmp	edi, DWORD PTR [esi+4028]
	jl	SHORT $LL3@setReveale
	pop	ebp
	pop	ebx
$LN1@setReveale:
	pop	edi
	pop	esi

; 599  : 	}
; 600  : }

	ret	12					; 0000000cH
?setRevealedPlots@CvMap@@QAEXW4TeamTypes@@_N1@Z ENDP	; CvMap::setRevealedPlots
_TEXT	ENDS
PUBLIC	?doTurn@CvMap@@QAEXXZ				; CvMap::doTurn
EXTRN	?doTurn@CvPlot@@QAEXXZ:PROC			; CvPlot::doTurn
; Function compile flags: /Ogtpy
;	COMDAT ?doTurn@CvMap@@QAEXXZ
_TEXT	SEGMENT
?doTurn@CvMap@@QAEXXZ PROC				; CvMap::doTurn, COMDAT
; _this$ = ecx

; 622  : {

	push	esi
	push	edi
	mov	esi, ecx

; 623  : #ifdef AUI_WARNING_FIXES
; 624  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 625  : #else
; 626  : 	int iI;
; 627  : 
; 628  : 	for(iI = 0; iI < numPlots(); iI++)

	xor	edi, edi
	cmp	DWORD PTR [esi+4028], edi
	jle	SHORT $LN1@doTurn
	push	ebx
	xor	ebx, ebx
$LL3@doTurn:

; 629  : #endif
; 630  : 	{
; 631  : 		plotByIndexUnchecked(iI)->doTurn();

	mov	ecx, DWORD PTR [esi+4068]
	add	ecx, ebx
	call	?doTurn@CvPlot@@QAEXXZ			; CvPlot::doTurn
	inc	edi
	add	ebx, 484				; 000001e4H
	cmp	edi, DWORD PTR [esi+4028]
	jl	SHORT $LL3@doTurn
	pop	ebx
$LN1@doTurn:
	pop	edi
	pop	esi

; 632  : 	}
; 633  : }

	ret	0
?doTurn@CvMap@@QAEXXZ ENDP				; CvMap::doTurn
_TEXT	ENDS
PUBLIC	?updateFog@CvMap@@QAEXXZ			; CvMap::updateFog
EXTRN	?updateFog@CvPlot@@QAEX_N@Z:PROC		; CvPlot::updateFog
; Function compile flags: /Ogtpy
;	COMDAT ?updateFog@CvMap@@QAEXXZ
_TEXT	SEGMENT
?updateFog@CvMap@@QAEXXZ PROC				; CvMap::updateFog, COMDAT
; _this$ = ecx

; 638  : {

	push	esi
	push	edi
	mov	esi, ecx

; 639  : #if defined(AUI_WARNING_FIXES) && defined(AUI_USE_OPENMP)
; 640  : #pragma omp parallel for
; 641  : 	for (int iI = 0; iI < (int)numPlots(); iI++)
; 642  : #elif defined(AUI_WARNING_FIXES)
; 643  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 644  : #elif defined(AUI_USE_OPENMP)
; 645  : #pragma omp parallel for
; 646  : 	for (int iI = 0; iI < numPlots(); iI++)
; 647  : #else
; 648  : 	int iI;
; 649  : 
; 650  : 	for(iI = 0; iI < numPlots(); iI++)

	xor	edi, edi
	cmp	DWORD PTR [esi+4028], edi
	jle	SHORT $LN1@updateFog
	push	ebx
	xor	ebx, ebx
$LL3@updateFog:

; 651  : #endif
; 652  : 	{
; 653  : 		plotByIndexUnchecked(iI)->updateFog();

	mov	ecx, DWORD PTR [esi+4068]
	push	0
	add	ecx, ebx
	call	?updateFog@CvPlot@@QAEX_N@Z		; CvPlot::updateFog
	inc	edi
	add	ebx, 484				; 000001e4H
	cmp	edi, DWORD PTR [esi+4028]
	jl	SHORT $LL3@updateFog
	pop	ebx
$LN1@updateFog:
	pop	edi
	pop	esi

; 654  : 	}
; 655  : }

	ret	0
?updateFog@CvMap@@QAEXXZ ENDP				; CvMap::updateFog
_TEXT	ENDS
PUBLIC	?updateVisibility@CvMap@@QAEXXZ			; CvMap::updateVisibility
EXTRN	?updateVisibility@CvPlot@@QAEXXZ:PROC		; CvPlot::updateVisibility
; Function compile flags: /Ogtpy
;	COMDAT ?updateVisibility@CvMap@@QAEXXZ
_TEXT	SEGMENT
?updateVisibility@CvMap@@QAEXXZ PROC			; CvMap::updateVisibility, COMDAT
; _this$ = ecx

; 671  : {

	push	esi
	push	edi
	mov	esi, ecx

; 672  : #if defined(AUI_WARNING_FIXES) && defined(AUI_USE_OPENMP)
; 673  : #pragma omp parallel for
; 674  : 	for (int iI = 0; iI < (int)numPlots(); iI++)
; 675  : #elif defined(AUI_WARNING_FIXES)
; 676  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 677  : #elif defined(AUI_USE_OPENMP)
; 678  : #pragma omp parallel for
; 679  : 	for (int iI = 0; iI < numPlots(); iI++)
; 680  : #else
; 681  : 	int iI;
; 682  : 
; 683  : 	for(iI = 0; iI < numPlots(); iI++)

	xor	edi, edi
	cmp	DWORD PTR [esi+4028], edi
	jle	SHORT $LN1@updateVisi
	push	ebx
	xor	ebx, ebx
$LL3@updateVisi:

; 684  : #endif
; 685  : 	{
; 686  : 		plotByIndexUnchecked(iI)->updateVisibility();

	mov	ecx, DWORD PTR [esi+4068]
	add	ecx, ebx
	call	?updateVisibility@CvPlot@@QAEXXZ	; CvPlot::updateVisibility
	inc	edi
	add	ebx, 484				; 000001e4H
	cmp	edi, DWORD PTR [esi+4028]
	jl	SHORT $LL3@updateVisi
	pop	ebx
$LN1@updateVisi:
	pop	edi
	pop	esi

; 687  : 	}
; 688  : }

	ret	0
?updateVisibility@CvMap@@QAEXXZ ENDP			; CvMap::updateVisibility
_TEXT	ENDS
PUBLIC	?updateLayout@CvMap@@QAEX_N@Z			; CvMap::updateLayout
EXTRN	?setLayoutDirty@CvPlot@@QAEX_N@Z:PROC		; CvPlot::setLayoutDirty
EXTRN	?updateLayout@CvPlot@@QAEX_N@Z:PROC		; CvPlot::updateLayout
EXTRN	?isLayoutDirty@CvPlot@@QBE_NXZ:PROC		; CvPlot::isLayoutDirty
; Function compile flags: /Ogtpy
;	COMDAT ?updateLayout@CvMap@@QAEX_N@Z
_TEXT	SEGMENT
_bDebug$ = 8						; size = 1
?updateLayout@CvMap@@QAEX_N@Z PROC			; CvMap::updateLayout, COMDAT
; _this$ = ecx

; 692  : {

	push	ebx
	push	edi
	mov	edi, ecx

; 693  : #ifdef AUI_WARNING_FIXES
; 694  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 695  : #else
; 696  : 	for(int iI = 0; iI < numPlots(); iI++)

	xor	ebx, ebx
	cmp	DWORD PTR [edi+4028], ebx
	jle	SHORT $LN2@updateLayo
	push	ebp
	push	esi
	xor	ebp, ebp
$LL4@updateLayo:

; 697  : #endif
; 698  : 	{
; 699  : 		CvPlot* pThisPlot = plotByIndexUnchecked(iI);

	mov	esi, DWORD PTR [edi+4068]
	add	esi, ebp

; 700  : 		if(pThisPlot && pThisPlot->isLayoutDirty())

	je	SHORT $LN3@updateLayo
	mov	ecx, esi
	call	?isLayoutDirty@CvPlot@@QBE_NXZ		; CvPlot::isLayoutDirty
	test	al, al
	je	SHORT $LN3@updateLayo

; 701  : 		{
; 702  : 			pThisPlot->updateLayout(bDebug);

	mov	eax, DWORD PTR _bDebug$[esp+12]
	push	eax
	mov	ecx, esi
	call	?updateLayout@CvPlot@@QAEX_N@Z		; CvPlot::updateLayout

; 703  : 			pThisPlot->setLayoutDirty(false);

	push	0
	mov	ecx, esi
	call	?setLayoutDirty@CvPlot@@QAEX_N@Z	; CvPlot::setLayoutDirty
$LN3@updateLayo:
	inc	ebx
	add	ebp, 484				; 000001e4H
	cmp	ebx, DWORD PTR [edi+4028]
	jl	SHORT $LL4@updateLayo
	pop	esi
	pop	ebp
$LN2@updateLayo:

; 704  : 		}
; 705  : 	}
; 706  : 	DLLUI->setDirty(PlotData_DIRTY_BIT,false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	0
	push	33					; 00000021H
	call	eax
	pop	edi
	pop	ebx

; 707  : }

	ret	4
?updateLayout@CvMap@@QAEX_N@Z ENDP			; CvMap::updateLayout
_TEXT	ENDS
PUBLIC	?updateSight@CvMap@@QAEX_N@Z			; CvMap::updateSight
EXTRN	?updateSight@CvPlot@@QAEX_N@Z:PROC		; CvPlot::updateSight
; Function compile flags: /Ogtpy
;	COMDAT ?updateSight@CvMap@@QAEX_N@Z
_TEXT	SEGMENT
_bIncrement$ = 8					; size = 1
?updateSight@CvMap@@QAEX_N@Z PROC			; CvMap::updateSight, COMDAT
; _this$ = ecx

; 711  : {

	push	esi
	push	edi
	mov	esi, ecx

; 712  : #ifdef AUI_WARNING_FIXES
; 713  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 714  : #else
; 715  : 	int iI;
; 716  : 
; 717  : 	for(iI = 0; iI < numPlots(); iI++)

	xor	edi, edi
	cmp	DWORD PTR [esi+4028], edi
	jle	SHORT $LN1@updateSigh
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _bIncrement$[esp+12]
	xor	ebx, ebx
$LL3@updateSigh:

; 718  : #endif
; 719  : 	{
; 720  : 		plotByIndexUnchecked(iI)->updateSight(bIncrement);

	mov	ecx, DWORD PTR [esi+4068]
	push	ebp
	add	ecx, ebx
	call	?updateSight@CvPlot@@QAEX_N@Z		; CvPlot::updateSight
	inc	edi
	add	ebx, 484				; 000001e4H
	cmp	edi, DWORD PTR [esi+4028]
	jl	SHORT $LL3@updateSigh
	pop	ebp
	pop	ebx
$LN1@updateSigh:
	pop	edi
	pop	esi

; 721  : 	}
; 722  : }

	ret	4
?updateSight@CvMap@@QAEX_N@Z ENDP			; CvMap::updateSight
_TEXT	ENDS
PUBLIC	?updateCenterUnit@CvMap@@QAEXXZ			; CvMap::updateCenterUnit
EXTRN	?updateCenterUnit@CvPlot@@QAEXXZ:PROC		; CvPlot::updateCenterUnit
; Function compile flags: /Ogtpy
;	COMDAT ?updateCenterUnit@CvMap@@QAEXXZ
_TEXT	SEGMENT
?updateCenterUnit@CvMap@@QAEXXZ PROC			; CvMap::updateCenterUnit, COMDAT
; _this$ = ecx

; 727  : {

	push	esi
	push	edi
	mov	esi, ecx

; 728  : #if defined(AUI_WARNING_FIXES) && defined(AUI_USE_OPENMP)
; 729  : #pragma omp parallel for
; 730  : 	for (int iI = 0; iI < (int)numPlots(); iI++)
; 731  : #elif defined(AUI_WARNING_FIXES)
; 732  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 733  : #elif defined(AUI_USE_OPENMP)
; 734  : #pragma omp parallel for
; 735  : 	for (int iI = 0; iI < numPlots(); iI++)
; 736  : #else
; 737  : 	int iI;
; 738  : 
; 739  : 	for(iI = 0; iI < numPlots(); iI++)

	xor	edi, edi
	cmp	DWORD PTR [esi+4028], edi
	jle	SHORT $LN1@updateCent
	push	ebx
	xor	ebx, ebx
$LL3@updateCent:

; 740  : #endif
; 741  : 	{
; 742  : 		plotByIndexUnchecked(iI)->updateCenterUnit();

	mov	ecx, DWORD PTR [esi+4068]
	add	ecx, ebx
	call	?updateCenterUnit@CvPlot@@QAEXXZ	; CvPlot::updateCenterUnit
	inc	edi
	add	ebx, 484				; 000001e4H
	cmp	edi, DWORD PTR [esi+4028]
	jl	SHORT $LL3@updateCent
	pop	ebx
$LN1@updateCent:
	pop	edi
	pop	esi

; 743  : 	}
; 744  : }

	ret	0
?updateCenterUnit@CvMap@@QAEXXZ ENDP			; CvMap::updateCenterUnit
_TEXT	ENDS
PUBLIC	?updateYield@CvMap@@QAEXXZ			; CvMap::updateYield
EXTRN	?updateYield@CvPlot@@QAEXXZ:PROC		; CvPlot::updateYield
; Function compile flags: /Ogtpy
;	COMDAT ?updateYield@CvMap@@QAEXXZ
_TEXT	SEGMENT
?updateYield@CvMap@@QAEXXZ PROC				; CvMap::updateYield, COMDAT
; _this$ = ecx

; 792  : {

	push	esi
	push	edi
	mov	esi, ecx

; 793  : #ifdef AUI_WARNING_FIXES
; 794  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 795  : #else
; 796  : 	int iI;
; 797  : 
; 798  : 	for(iI = 0; iI < numPlots(); iI++)

	xor	edi, edi
	cmp	DWORD PTR [esi+4028], edi
	jle	SHORT $LN1@updateYiel
	push	ebx
	xor	ebx, ebx
$LL3@updateYiel:

; 799  : #endif
; 800  : 	{
; 801  : 		plotByIndexUnchecked(iI)->updateYield();

	mov	ecx, DWORD PTR [esi+4068]
	add	ecx, ebx
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
	inc	edi
	add	ebx, 484				; 000001e4H
	cmp	edi, DWORD PTR [esi+4028]
	jl	SHORT $LL3@updateYiel
	pop	ebx
$LN1@updateYiel:
	pop	edi
	pop	esi

; 802  : 	}
; 803  : }

	ret	0
?updateYield@CvMap@@QAEXXZ ENDP				; CvMap::updateYield
_TEXT	ENDS
PUBLIC	?updateAdjacency@CvMap@@QAEXXZ			; CvMap::updateAdjacency
EXTRN	?isAdjacentToLand@CvPlot@@QBE_NXZ:PROC		; CvPlot::isAdjacentToLand
; Function compile flags: /Ogtpy
;	COMDAT ?updateAdjacency@CvMap@@QAEXXZ
_TEXT	SEGMENT
?updateAdjacency@CvMap@@QAEXXZ PROC			; CvMap::updateAdjacency, COMDAT
; _this$ = ecx

; 808  : {

	push	ebx
	push	edi
	mov	edi, ecx

; 809  : #if defined(AUI_WARNING_FIXES) && defined(AUI_USE_OPENMP)
; 810  : #pragma omp parallel for
; 811  : 	for (int iI = 0; iI < (int)numPlots(); iI++)
; 812  : #elif defined(AUI_WARNING_FIXES)
; 813  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 814  : #elif defined(AUI_USE_OPENMP)
; 815  : #pragma omp parallel for
; 816  : 	for (int iI = 0; iI < numPlots(); iI++)
; 817  : #else
; 818  : 	int iI;
; 819  : 
; 820  : 	for(iI = 0; iI < numPlots(); iI++)

	xor	ebx, ebx
	cmp	DWORD PTR [edi+4028], ebx
	jle	SHORT $LN1@updateAdja
	push	ebp
	push	esi
	xor	ebp, ebp
$LL3@updateAdja:

; 821  : #endif
; 822  : 	{
; 823  : 		CvPlot* pPlot = plotByIndexUnchecked(iI);

	mov	esi, DWORD PTR [edi+4068]
	add	esi, ebp

; 824  : 		pPlot->m_bIsAdjacentToLand = pPlot->isAdjacentToLand();

	mov	ecx, esi
	call	?isAdjacentToLand@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentToLand
	shl	al, 6
	xor	al, BYTE PTR [esi+462]
	inc	ebx
	and	al, 64					; 00000040H
	xor	BYTE PTR [esi+462], al
	add	ebp, 484				; 000001e4H
	cmp	ebx, DWORD PTR [edi+4028]
	jl	SHORT $LL3@updateAdja
	pop	esi
	pop	ebp
$LN1@updateAdja:
	pop	edi
	pop	ebx

; 825  : 	}
; 826  : }

	ret	0
?updateAdjacency@CvMap@@QAEXXZ ENDP			; CvMap::updateAdjacency
_TEXT	ENDS
PUBLIC	?verifyUnitValidPlot@CvMap@@QAEXXZ		; CvMap::verifyUnitValidPlot
EXTRN	?verifyUnitValidPlot@CvPlot@@QAEXXZ:PROC	; CvPlot::verifyUnitValidPlot
; Function compile flags: /Ogtpy
;	COMDAT ?verifyUnitValidPlot@CvMap@@QAEXXZ
_TEXT	SEGMENT
?verifyUnitValidPlot@CvMap@@QAEXXZ PROC			; CvMap::verifyUnitValidPlot, COMDAT
; _this$ = ecx

; 830  : {

	push	esi
	push	edi
	mov	esi, ecx

; 831  : #ifdef AUI_WARNING_FIXES
; 832  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 833  : #else
; 834  : 	int iI;
; 835  : 
; 836  : 	for(iI = 0; iI < numPlots(); iI++)

	xor	edi, edi
	cmp	DWORD PTR [esi+4028], edi
	jle	SHORT $LN1@verifyUnit
	push	ebx
	xor	ebx, ebx
$LL3@verifyUnit:

; 837  : #endif
; 838  : 	{
; 839  : 		plotByIndexUnchecked(iI)->verifyUnitValidPlot();

	mov	ecx, DWORD PTR [esi+4068]
	add	ecx, ebx
	call	?verifyUnitValidPlot@CvPlot@@QAEXXZ	; CvPlot::verifyUnitValidPlot
	inc	edi
	add	ebx, 484				; 000001e4H
	cmp	edi, DWORD PTR [esi+4028]
	jl	SHORT $LL3@verifyUnit
	pop	ebx
$LN1@verifyUnit:
	pop	edi
	pop	esi

; 840  : 	}
; 841  : }

	ret	0
?verifyUnitValidPlot@CvMap@@QAEXXZ ENDP			; CvMap::verifyUnitValidPlot
_TEXT	ENDS
PUBLIC	?getMapFractalFlags@CvMap@@QAEHXZ		; CvMap::getMapFractalFlags
; Function compile flags: /Ogtpy
;	COMDAT ?getMapFractalFlags@CvMap@@QAEHXZ
_TEXT	SEGMENT
?getMapFractalFlags@CvMap@@QAEHXZ PROC			; CvMap::getMapFractalFlags, COMDAT
; _this$ = ecx

; 1167 : 	int wrapX = 0;

	xor	edx, edx

; 1168 : 	if(isWrapX())

	cmp	BYTE PTR [ecx+4056], dl
	je	SHORT $LN2@getMapFrac

; 1169 : 	{
; 1170 : 		wrapX = (int)CvFractal::FRAC_WRAP_X;

	mov	edx, 1
$LN2@getMapFrac:

; 1171 : 	}
; 1172 : 
; 1173 : 	int wrapY = 0;

	xor	eax, eax

; 1174 : 	if(isWrapY())

	cmp	BYTE PTR [ecx+4057], al
	je	SHORT $LN1@getMapFrac

; 1175 : 	{
; 1176 : 		wrapY = (int)CvFractal::FRAC_WRAP_Y;

	mov	eax, 2
$LN1@getMapFrac:

; 1177 : 	}
; 1178 : 
; 1179 : 	return (wrapX | wrapY);

	or	eax, edx

; 1180 : }

	ret	0
?getMapFractalFlags@CvMap@@QAEHXZ ENDP			; CvMap::getMapFractalFlags
_TEXT	ENDS
PUBLIC	?plotX@CvMap@@QBEHH@Z				; CvMap::plotX
; Function compile flags: /Ogtpy
;	COMDAT ?plotX@CvMap@@QBEHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotX@CvMap@@QBEHH@Z PROC				; CvMap::plotX, COMDAT
; _this$ = ecx

; 1235 : 	return (iIndex % getGridWidth());

	mov	eax, DWORD PTR _iIndex$[esp-4]
	cdq
	idiv	DWORD PTR [ecx+4020]
	mov	eax, edx

; 1236 : }

	ret	4
?plotX@CvMap@@QBEHH@Z ENDP				; CvMap::plotX
_TEXT	ENDS
PUBLIC	?plotY@CvMap@@QBEHH@Z				; CvMap::plotY
; Function compile flags: /Ogtpy
;	COMDAT ?plotY@CvMap@@QBEHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotY@CvMap@@QBEHH@Z PROC				; CvMap::plotY, COMDAT
; _this$ = ecx

; 1242 : 	return (iIndex / getGridWidth());

	mov	eax, DWORD PTR _iIndex$[esp-4]
	cdq
	idiv	DWORD PTR [ecx+4020]

; 1243 : }

	ret	4
?plotY@CvMap@@QBEHH@Z ENDP				; CvMap::plotY
_TEXT	ENDS
PUBLIC	?maxPlotDistance@CvMap@@QAEHXZ			; CvMap::maxPlotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?maxPlotDistance@CvMap@@QAEHXZ
_TEXT	SEGMENT
$T239281 = -8						; size = 4
$T239286 = -4						; size = 4
?maxPlotDistance@CvMap@@QAEHXZ PROC			; CvMap::maxPlotDistance, COMDAT
; _this$ = ecx

; 1248 : {

	sub	esp, 8

; 1249 : #ifdef NQM_FAST_COMP
; 1250 : 	return MAX(1, plotDistance(0, 0, ((isWrapX()) ? (getGridWidth() / 2) : (getGridWidth() - 1)), ((isWrapY()) ? (getGridHeight() / 2) : (getGridHeight() - 1))));
; 1251 : #else
; 1252 : 	return std::max(1, plotDistance(0, 0, ((isWrapX()) ? (getGridWidth() / 2) : (getGridWidth() - 1)), ((isWrapY()) ? (getGridHeight() / 2) : (getGridHeight() - 1))));

	cmp	BYTE PTR [ecx+4057], 0
	push	esi
	je	SHORT $LN3@maxPlotDis
	mov	eax, DWORD PTR [ecx+4024]
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	jmp	SHORT $LN4@maxPlotDis
$LN3@maxPlotDis:
	mov	esi, DWORD PTR [ecx+4024]
	dec	esi
$LN4@maxPlotDis:
	cmp	BYTE PTR [ecx+4056], 0
	mov	eax, DWORD PTR [ecx+4020]
	je	SHORT $LN5@maxPlotDis
	cdq
	sub	eax, edx
	sar	eax, 1
	jmp	SHORT $LN6@maxPlotDis
$LN5@maxPlotDis:
	dec	eax
$LN6@maxPlotDis:
	push	esi
	push	eax
	push	0
	push	0
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T239281[esp+12], eax
	cmp	eax, 1
	mov	DWORD PTR $T239286[esp+12], 1
	pop	esi
	lea	eax, DWORD PTR $T239281[esp+8]
	jg	SHORT $LN23@maxPlotDis
	lea	eax, DWORD PTR $T239286[esp+8]
$LN23@maxPlotDis:
	mov	eax, DWORD PTR [eax]

; 1253 : #endif
; 1254 : }

	add	esp, 8
	ret	0
?maxPlotDistance@CvMap@@QAEHXZ ENDP			; CvMap::maxPlotDistance
_TEXT	ENDS
PUBLIC	?getRandomResourceQuantity@CvMap@@QAEHW4ResourceTypes@@@Z ; CvMap::getRandomResourceQuantity
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?getResourceQuantityType@CvResourceInfo@@QBEHH@Z:PROC ; CvResourceInfo::getResourceQuantityType
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getRandomResourceQuantity@CvMap@@QAEHW4ResourceTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getRandomResourceQuantity@CvMap@@QAEHW4ResourceTypes@@@Z PROC ; CvMap::getRandomResourceQuantity, COMDAT
; _this$ = ecx

; 1356 : 	CvResourceInfo* thisResourceInfo = GC.getResourceInfo(eIndex);

	mov	eax, DWORD PTR _eIndex$[esp-4]
	push	ebx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ebx, eax

; 1357 : 	if(thisResourceInfo == NULL)

	test	ebx, ebx
	jne	SHORT $LN5@getRandomR
	pop	ebx

; 1378 : }

	ret	4
$LN5@getRandomR:
	push	esi
	push	edi

; 1358 : 		return 0;
; 1359 : 
; 1360 : 	int iNumRands = 0;
; 1361 : 
; 1362 : 	// Find how many types of resources quantities there can be to pick from
; 1363 : 	for(int iLoop = 0; iLoop < GC.getNUM_RESOURCE_QUANTITY_TYPES(); iLoop++)

	xor	esi, esi
	xor	edi, edi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+7016, esi
	jle	SHORT $LN13@getRandomR
$LL4@getRandomR:

; 1364 : 	{
; 1365 : 		if(thisResourceInfo->getResourceQuantityType(iLoop) <= 0)

	push	esi
	mov	ecx, ebx
	call	?getResourceQuantityType@CvResourceInfo@@QBEHH@Z ; CvResourceInfo::getResourceQuantityType
	test	eax, eax
	jle	SHORT $LN13@getRandomR
	inc	esi

; 1366 : 		{
; 1367 : 			break;
; 1368 : 		}
; 1369 : 
; 1370 : 		iNumRands++;

	inc	edi
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7016
	jl	SHORT $LL4@getRandomR
$LN13@getRandomR:

; 1371 : 	}
; 1372 : 
; 1373 : 	CvAssertMsg(iNumRands > 0, "Resource should have at least 1 Quantity type to choose from")
; 1374 : 
; 1375 : 	int iRand = GC.getGame().getJonRandNum(iNumRands, "Picking from random Resource Quantity types");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG236271
	push	edi
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 1376 : 
; 1377 : 	return thisResourceInfo->getResourceQuantityType(iRand);

	push	eax
	mov	ecx, ebx
	call	?getResourceQuantityType@CvResourceInfo@@QBEHH@Z ; CvResourceInfo::getResourceQuantityType
	pop	edi
	pop	esi
	pop	ebx

; 1378 : }

	ret	4
?getRandomResourceQuantity@CvMap@@QAEHW4ResourceTypes@@@Z ENDP ; CvMap::getRandomResourceQuantity
_TEXT	ENDS
PUBLIC	?getIndexAfterLastArea@CvMap@@QAEHXZ		; CvMap::getIndexAfterLastArea
; Function compile flags: /Ogtpy
;	COMDAT ?getIndexAfterLastArea@CvMap@@QAEHXZ
_TEXT	SEGMENT
?getIndexAfterLastArea@CvMap@@QAEHXZ PROC		; CvMap::getIndexAfterLastArea, COMDAT
; _this$ = ecx

; 1420 : 	return m_areas.GetIndexAfterLast();

	mov	eax, DWORD PTR [ecx+4124]
	inc	eax

; 1421 : }

	ret	0
?getIndexAfterLastArea@CvMap@@QAEHXZ ENDP		; CvMap::getIndexAfterLastArea
_TEXT	ENDS
PUBLIC	?getNumAreas@CvMap@@QAEHXZ			; CvMap::getNumAreas
; Function compile flags: /Ogtpy
;	COMDAT ?getNumAreas@CvMap@@QAEHXZ
_TEXT	SEGMENT
?getNumAreas@CvMap@@QAEHXZ PROC				; CvMap::getNumAreas, COMDAT
; _this$ = ecx

; 1427 : 	return m_areas.GetCount();

	mov	eax, DWORD PTR [ecx+4124]
	sub	eax, DWORD PTR [ecx+4120]
	inc	eax

; 1428 : }

	ret	0
?getNumAreas@CvMap@@QAEHXZ ENDP				; CvMap::getNumAreas
_TEXT	ENDS
PUBLIC	?addArea@CvMap@@QAEPAVCvArea@@XZ		; CvMap::addArea
; Function compile flags: /Ogtpy
;	COMDAT ?addArea@CvMap@@QAEPAVCvArea@@XZ
_TEXT	SEGMENT
?addArea@CvMap@@QAEPAVCvArea@@XZ PROC			; CvMap::addArea, COMDAT
; _this$ = ecx

; 1462 : 	return m_areas.Add();

	add	ecx, 4112				; 00001010H
	jmp	?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ ; FFreeListTrashArray<CvArea>::Add
?addArea@CvMap@@QAEPAVCvArea@@XZ ENDP			; CvMap::addArea
_TEXT	ENDS
PUBLIC	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z		; CvMap::nextArea
; Function compile flags: /Ogtpy
;	COMDAT ?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z
_TEXT	SEGMENT
_pIterIdx$ = 8						; size = 4
_bRev$ = 12						; size = 1
?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z PROC		; CvMap::nextArea, COMDAT
; _this$ = ecx

; 1483 : 	return !bRev ? m_areas.NextIter(pIterIdx) : m_areas.PrevIter(pIterIdx);

	add	ecx, 4112				; 00001010H
	cmp	BYTE PTR _bRev$[esp-4], 0
	jne	SHORT $LN3@nextArea
	mov	eax, DWORD PTR _pIterIdx$[esp-4]
	push	eax
	call	?NextIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ; FFreeListArrayBase<CvArea>::NextIter

; 1484 : }

	ret	8
$LN3@nextArea:

; 1483 : 	return !bRev ? m_areas.NextIter(pIterIdx) : m_areas.PrevIter(pIterIdx);

	mov	edx, DWORD PTR _pIterIdx$[esp-4]
	push	edx
	call	?PrevIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ; FFreeListArrayBase<CvArea>::PrevIter

; 1484 : }

	ret	8
?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z ENDP		; CvMap::nextArea
_TEXT	ENDS
PUBLIC	?calculateInfluenceDistance@CvMap@@QAEHPAVCvPlot@@0H_N@Z ; CvMap::calculateInfluenceDistance
EXTRN	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z:PROC	; CvAStar::GeneratePath
; Function compile flags: /Ogtpy
;	COMDAT ?calculateInfluenceDistance@CvMap@@QAEHPAVCvPlot@@0H_N@Z
_TEXT	SEGMENT
_pSource$ = 8						; size = 4
_pDest$ = 12						; size = 4
_iMaxRange$ = 16					; size = 4
_bCorrectButSlower$ = 20				; size = 1
?calculateInfluenceDistance@CvMap@@QAEHPAVCvPlot@@0H_N@Z PROC ; CvMap::calculateInfluenceDistance, COMDAT
; _this$ = ecx

; 1508 : {

	push	esi
	push	edi

; 1509 : 	CvAStarNode* pNode;
; 1510 : 
; 1511 : 	if(pSource == NULL || pDest == NULL)

	mov	edi, DWORD PTR _pSource$[esp+4]
	test	edi, edi
	je	SHORT $LN3@calculateI
	mov	esi, DWORD PTR _pDest$[esp+4]
	test	esi, esi
	je	SHORT $LN3@calculateI

; 1514 : 	}
; 1515 : 
; 1516 : #ifdef AUI_MAP_FIX_CALCULATE_INFLUENCE_DISTANCE_REUSE_PATHFINDER
; 1517 : 	bCorrectButSlower = false;
; 1518 : 	if (m_pLastInfluenceSourcePlot != pSource)
; 1519 : 	{
; 1520 : 		m_pLastInfluenceSourcePlot = pSource;
; 1521 : 		bCorrectButSlower = true;
; 1522 : 	}
; 1523 : #endif
; 1524 : 
; 1525 : 	GC.getInfluenceFinder().SetData(&iMaxRange);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfluenceFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getInfluenceFinder
	cmp	BYTE PTR [eax+80], 0
	je	SHORT $LN7@calculateI
	lea	ecx, DWORD PTR _iMaxRange$[esp+4]
	cmp	DWORD PTR [eax+44], ecx
	je	SHORT $LN7@calculateI
	mov	BYTE PTR [eax+78], 1
$LN7@calculateI:

; 1526 : 	if(GC.getInfluenceFinder().GeneratePath(pSource->getX(), pSource->getY(), pDest->getX(), pDest->getY(), 0, !bCorrectButSlower))

	cmp	BYTE PTR _bCorrectButSlower$[esp+4], 0
	lea	edx, DWORD PTR _iMaxRange$[esp+4]
	mov	DWORD PTR [eax+44], edx
	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	movsx	esi, WORD PTR [edi+2]
	movsx	edi, WORD PTR [edi]
	sete	dl
	movzx	edx, dl
	push	edx
	push	0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfluenceFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getInfluenceFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	test	al, al
	je	SHORT $LN3@calculateI

; 1527 : 	{
; 1528 : 		pNode = GC.getInfluenceFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfluenceFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getInfluenceFinder
	mov	eax, DWORD PTR [eax+96]

; 1529 : 
; 1530 : 		if(pNode != NULL)

	test	eax, eax
	je	SHORT $LN3@calculateI

; 1531 : 		{
; 1532 : 			return pNode->m_iKnownCost;

	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi

; 1533 : 		}
; 1534 : 	}
; 1535 : 
; 1536 : 	return -1; // no passable path exists
; 1537 : }

	ret	16					; 00000010H
$LN3@calculateI:
	pop	edi

; 1512 : 	{
; 1513 : 		return -1;

	or	eax, -1
	pop	esi

; 1533 : 		}
; 1534 : 	}
; 1535 : 
; 1536 : 	return -1; // no passable path exists
; 1537 : }

	ret	16					; 00000010H
?calculateInfluenceDistance@CvMap@@QAEHPAVCvPlot@@0H_N@Z ENDP ; CvMap::calculateInfluenceDistance
_TEXT	ENDS
PUBLIC	?calculateAreas@CvMap@@QAEXXZ			; CvMap::calculateAreas
EXTRN	?setAreaBoundaries@CvArea@@QAEXUCvAreaBoundaries@@@Z:PROC ; CvArea::setAreaBoundaries
EXTRN	?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ:PROC ; CvArea::getAreaBoundaries
EXTRN	?setArea@CvPlot@@QAEXH@Z:PROC			; CvPlot::setArea
EXTRN	?SetMountains@CvArea@@QAEX_N@Z:PROC		; CvArea::SetMountains
EXTRN	?init@CvArea@@QAEXH_N@Z:PROC			; CvArea::init
; Function compile flags: /Ogtpy
;	COMDAT ?calculateAreas@CvMap@@QAEXXZ
_TEXT	SEGMENT
tv334 = -24						; size = 4
_iI$ = -20						; size = 4
_boundaries$236552 = -16				; size = 16
?calculateAreas@CvMap@@QAEXXZ PROC			; CvMap::calculateAreas, COMDAT
; _this$ = ecx

; 1680 : {

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp

; 1681 : 	CvPlot* pLoopPlot;
; 1682 : 	CvArea* pArea;
; 1683 : 	int iArea;
; 1684 : #ifdef AUI_WARNING_FIXES
; 1685 : 	for (uint iI = 0; iI < numPlots(); iI++)
; 1686 : #else
; 1687 : 	int iI;
; 1688 : 
; 1689 : 	for(iI = 0; iI < numPlots(); iI++)

	xor	eax, eax
	mov	ebx, ecx
	cmp	DWORD PTR [ebx+4028], eax
	push	esi
	push	edi
	mov	DWORD PTR _iI$[esp+40], eax
	jle	$LN11@calculateA
	mov	DWORD PTR tv334[esp+40], eax
	npad	1
$LL13@calculateA:

; 1690 : #endif
; 1691 : 	{
; 1692 : 		pLoopPlot = plotByIndexUnchecked(iI);

	mov	esi, DWORD PTR [ebx+4068]
	add	esi, DWORD PTR tv334[esp+40]

; 1693 : 		CvAssertMsg(pLoopPlot != NULL, "LoopPlot is not assigned a valid value");
; 1694 : 
; 1695 : 		if(!pLoopPlot) continue;

	je	$LN12@calculateA

; 1696 : 
; 1697 : 		if(pLoopPlot->getArea() == FFreeList::INVALID_INDEX)

	mov	eax, DWORD PTR [esi+356]
	cmp	eax, -1
	jne	$LN9@calculateA

; 1698 : 		{
; 1699 : 			pArea = addArea();

	lea	ecx, DWORD PTR [ebx+4112]
	call	?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ ; FFreeListTrashArray<CvArea>::Add

; 1700 : 			pArea->init(pArea->GetID(), pLoopPlot->isWater());

	cmp	BYTE PTR [esi+5], 3
	mov	edi, eax
	mov	edx, DWORD PTR [edi+4]
	sete	al
	movzx	ecx, al
	push	ecx
	push	edx
	mov	ecx, edi
	call	?init@CvArea@@QAEXH_N@Z			; CvArea::init

; 1701 : 
; 1702 : 			pArea->SetMountains(pLoopPlot->isMountain());

	cmp	BYTE PTR [esi+5], 0
	sete	al
	movzx	ecx, al
	push	ecx
	mov	ecx, edi
	call	?SetMountains@CvArea@@QAEX_N@Z		; CvArea::SetMountains

; 1703 : 
; 1704 : 			iArea = pArea->GetID();

	mov	ebp, DWORD PTR [edi+4]

; 1705 : 
; 1706 : 			pLoopPlot->setArea(iArea);

	push	ebp
	mov	ecx, esi
	call	?setArea@CvPlot@@QAEXH@Z		; CvPlot::setArea

; 1707 : 
; 1708 : 			GC.getAreaFinder().GeneratePath(pLoopPlot->getX(), pLoopPlot->getY(), -1, -1, iArea);

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	0
	push	ebp
	push	-1
	push	-1
	push	eax
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAreaFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getAreaFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath

; 1709 : 
; 1710 : 			CvAreaBoundaries boundaries;
; 1711 : 			boundaries.m_iEastEdge = pLoopPlot->getX();
; 1712 : 			boundaries.m_iWestEdge = pLoopPlot->getX();
; 1713 : 			boundaries.m_iNorthEdge = pLoopPlot->getY();

	movsx	edx, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]

; 1714 : 			boundaries.m_iSouthEdge = pLoopPlot->getY();
; 1715 : 			pArea->setAreaBoundaries(boundaries);

	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, edi

; 1716 : 		}
; 1717 : 
; 1718 : 		// Update area boundaries if they've grown
; 1719 : 		else

	jmp	$LN60@calculateA
$LN9@calculateA:

; 1720 : 		{
; 1721 : 			int iX, iY;
; 1722 : 			CvAreaBoundaries boundaries = getArea(pLoopPlot->getArea())->getAreaBoundaries();

	lea	edx, DWORD PTR _boundaries$236552[esp+40]
	lea	edi, DWORD PTR [ebx+4112]
	push	edx
	mov	edx, DWORD PTR [edi]
	push	eax
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, edi
	call	eax
	mov	ecx, eax
	call	?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ ; CvArea::getAreaBoundaries

; 1723 : 			iX = pLoopPlot->getX();

	movsx	eax, WORD PTR [esi]

; 1724 : 			iY = pLoopPlot->getY();
; 1725 : 
; 1726 : 			if(iX < boundaries.m_iWestEdge)

	cmp	eax, DWORD PTR _boundaries$236552[esp+52]
	movsx	ecx, WORD PTR [esi+2]
	jge	SHORT $LN7@calculateA

; 1727 : 			{
; 1728 : 				boundaries.m_iWestEdge = iX;

	mov	DWORD PTR _boundaries$236552[esp+52], eax
	jmp	SHORT $LN1@calculateA
$LN7@calculateA:

; 1729 : 			}
; 1730 : 			else if(iX > boundaries.m_iEastEdge)

	cmp	eax, DWORD PTR _boundaries$236552[esp+48]
	jle	SHORT $LN5@calculateA

; 1731 : 			{
; 1732 : 				boundaries.m_iEastEdge = iX;

	mov	DWORD PTR _boundaries$236552[esp+48], eax
	jmp	SHORT $LN1@calculateA
$LN5@calculateA:

; 1733 : 			}
; 1734 : 			else if(iY < boundaries.m_iSouthEdge)

	cmp	ecx, DWORD PTR _boundaries$236552[esp+44]
	jge	SHORT $LN3@calculateA

; 1735 : 			{
; 1736 : 				boundaries.m_iSouthEdge = iY;

	mov	DWORD PTR _boundaries$236552[esp+44], ecx
	jmp	SHORT $LN1@calculateA
$LN3@calculateA:

; 1737 : 			}
; 1738 : 			else if(iY > boundaries.m_iNorthEdge)

	cmp	ecx, DWORD PTR _boundaries$236552[esp+40]
	jle	SHORT $LN1@calculateA

; 1739 : 			{
; 1740 : 				boundaries.m_iNorthEdge = iY;

	mov	DWORD PTR _boundaries$236552[esp+40], ecx
$LN1@calculateA:

; 1741 : 			}
; 1742 : 			getArea(pLoopPlot->getArea())->setAreaBoundaries(boundaries);

	mov	esi, DWORD PTR [esi+356]
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+16]
	push	esi
	mov	ecx, edi
	call	eax
	mov	ecx, DWORD PTR _boundaries$236552[esp+40]
	sub	esp, 16					; 00000010H
	mov	edx, esp
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR _boundaries$236552[esp+60]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _boundaries$236552[esp+64]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, DWORD PTR _boundaries$236552[esp+68]
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, eax
$LN60@calculateA:
	call	?setAreaBoundaries@CvArea@@QAEXUCvAreaBoundaries@@@Z ; CvArea::setAreaBoundaries
$LN12@calculateA:

; 1681 : 	CvPlot* pLoopPlot;
; 1682 : 	CvArea* pArea;
; 1683 : 	int iArea;
; 1684 : #ifdef AUI_WARNING_FIXES
; 1685 : 	for (uint iI = 0; iI < numPlots(); iI++)
; 1686 : #else
; 1687 : 	int iI;
; 1688 : 
; 1689 : 	for(iI = 0; iI < numPlots(); iI++)

	mov	eax, DWORD PTR _iI$[esp+40]
	add	DWORD PTR tv334[esp+40], 484		; 000001e4H
	inc	eax
	cmp	eax, DWORD PTR [ebx+4028]
	mov	DWORD PTR _iI$[esp+40], eax
	jl	$LL13@calculateA
$LN11@calculateA:

; 1743 : 		}
; 1744 : 	}
; 1745 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
?calculateAreas@CvMap@@QAEXXZ ENDP			; CvMap::calculateAreas
_TEXT	ENDS
PUBLIC	?getIndexAfterLastLandmass@CvMap@@QAEHXZ	; CvMap::getIndexAfterLastLandmass
; Function compile flags: /Ogtpy
;	COMDAT ?getIndexAfterLastLandmass@CvMap@@QAEHXZ
_TEXT	SEGMENT
?getIndexAfterLastLandmass@CvMap@@QAEHXZ PROC		; CvMap::getIndexAfterLastLandmass, COMDAT
; _this$ = ecx

; 2289 : 	return m_landmasses.GetIndexAfterLast();

	mov	eax, DWORD PTR [ecx+4152]
	inc	eax

; 2290 : }

	ret	0
?getIndexAfterLastLandmass@CvMap@@QAEHXZ ENDP		; CvMap::getIndexAfterLastLandmass
_TEXT	ENDS
PUBLIC	?getNumLandmasses@CvMap@@QAEHXZ			; CvMap::getNumLandmasses
; Function compile flags: /Ogtpy
;	COMDAT ?getNumLandmasses@CvMap@@QAEHXZ
_TEXT	SEGMENT
?getNumLandmasses@CvMap@@QAEHXZ PROC			; CvMap::getNumLandmasses, COMDAT
; _this$ = ecx

; 2296 : 	return m_landmasses.GetCount();

	mov	eax, DWORD PTR [ecx+4152]
	sub	eax, DWORD PTR [ecx+4148]
	inc	eax

; 2297 : }

	ret	0
?getNumLandmasses@CvMap@@QAEHXZ ENDP			; CvMap::getNumLandmasses
_TEXT	ENDS
PUBLIC	?addLandmass@CvMap@@QAEPAVCvLandmass@@XZ	; CvMap::addLandmass
; Function compile flags: /Ogtpy
;	COMDAT ?addLandmass@CvMap@@QAEPAVCvLandmass@@XZ
_TEXT	SEGMENT
?addLandmass@CvMap@@QAEPAVCvLandmass@@XZ PROC		; CvMap::addLandmass, COMDAT
; _this$ = ecx

; 2331 : 	return m_landmasses.Add();

	add	ecx, 4140				; 0000102cH
	jmp	?Add@?$FFreeListTrashArray@VCvLandmass@@@@QAEPAVCvLandmass@@XZ ; FFreeListTrashArray<CvLandmass>::Add
?addLandmass@CvMap@@QAEPAVCvLandmass@@XZ ENDP		; CvMap::addLandmass
_TEXT	ENDS
PUBLIC	?deleteLandmass@CvMap@@QAEXH@Z			; CvMap::deleteLandmass
; Function compile flags: /Ogtpy
;	COMDAT ?deleteLandmass@CvMap@@QAEXH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?deleteLandmass@CvMap@@QAEXH@Z PROC			; CvMap::deleteLandmass, COMDAT
; _this$ = ecx

; 2338 : 	m_landmasses.RemoveAt(iID);

	add	ecx, 4140				; 0000102cH
	jmp	?RemoveAt@?$FFreeListTrashArray@VCvLandmass@@@@QAE_NH@Z ; FFreeListTrashArray<CvLandmass>::RemoveAt
?deleteLandmass@CvMap@@QAEXH@Z ENDP			; CvMap::deleteLandmass
_TEXT	ENDS
PUBLIC	?nextLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z	; CvMap::nextLandmass
; Function compile flags: /Ogtpy
;	COMDAT ?nextLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z
_TEXT	SEGMENT
_pIterIdx$ = 8						; size = 4
_bRev$ = 12						; size = 1
?nextLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z PROC	; CvMap::nextLandmass, COMDAT
; _this$ = ecx

; 2352 : 	return !bRev ? m_landmasses.NextIter(pIterIdx) : m_landmasses.PrevIter(pIterIdx);

	add	ecx, 4140				; 0000102cH
	cmp	BYTE PTR _bRev$[esp-4], 0
	jne	SHORT $LN3@nextLandma
	mov	eax, DWORD PTR _pIterIdx$[esp-4]
	push	eax
	call	?NextIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ; FFreeListArrayBase<CvLandmass>::NextIter

; 2353 : }

	ret	8
$LN3@nextLandma:

; 2352 : 	return !bRev ? m_landmasses.NextIter(pIterIdx) : m_landmasses.PrevIter(pIterIdx);

	mov	edx, DWORD PTR _pIterIdx$[esp-4]
	push	edx
	call	?PrevIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ; FFreeListArrayBase<CvLandmass>::PrevIter

; 2353 : }

	ret	8
?nextLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z ENDP	; CvMap::nextLandmass
_TEXT	ENDS
PUBLIC	?calculateLandmasses@CvMap@@QAEXXZ		; CvMap::calculateLandmasses
EXTRN	?setLandmass@CvPlot@@QAEXH@Z:PROC		; CvPlot::setLandmass
EXTRN	?JoinLandmass@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; JoinLandmass
EXTRN	?LandmassValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; LandmassValid
; Function compile flags: /Ogtpy
;	COMDAT ?calculateLandmasses@CvMap@@QAEXXZ
_TEXT	SEGMENT
tv271 = -8						; size = 4
_iI$236837 = -4						; size = 4
?calculateLandmasses@CvMap@@QAEXXZ PROC			; CvMap::calculateLandmasses, COMDAT
; _this$ = ecx

; 2375 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 2376 : 	CvPlot* pLoopPlot;
; 2377 : 	CvLandmass* pLandmass;
; 2378 : 	int iLandmassID;
; 2379 : 
; 2380 : 	CvAStar& thePathfinder = GC.getAreaFinder();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAreaFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getAreaFinder
	mov	ebx, eax

; 2381 : 
; 2382 : 	// change the area pathfinder to use these funcs instead
; 2383 : 	thePathfinder.SetValidFunc(LandmassValid);
; 2384 : 	thePathfinder.SetNotifyListFunc(JoinLandmass);
; 2385 : 
; 2386 : #ifdef AUI_WARNING_FIXES
; 2387 : 	for (uint iI = 0; iI < numPlots(); iI++)
; 2388 : #else
; 2389 : 	for(int iI = 0; iI < numPlots(); iI++)

	xor	ebp, ebp
	mov	DWORD PTR [ebx+16], OFFSET ?LandmassValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; LandmassValid
	mov	DWORD PTR [ebx+24], OFFSET ?JoinLandmass@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; JoinLandmass
	cmp	DWORD PTR [edi+4028], ebp
	mov	DWORD PTR _iI$236837[esp+24], ebp
	jle	SHORT $LN2@calculateL

; 2376 : 	CvPlot* pLoopPlot;
; 2377 : 	CvLandmass* pLandmass;
; 2378 : 	int iLandmassID;
; 2379 : 
; 2380 : 	CvAStar& thePathfinder = GC.getAreaFinder();

	mov	DWORD PTR tv271[esp+24], ebp
$LL4@calculateL:

; 2390 : #endif
; 2391 : 	{
; 2392 : 		pLoopPlot = plotByIndexUnchecked(iI);

	mov	esi, DWORD PTR [edi+4068]
	add	esi, DWORD PTR tv271[esp+24]

; 2393 : 		if(pLoopPlot->getLandmass() == FFreeList::INVALID_INDEX)

	cmp	DWORD PTR [esi+360], -1
	jne	SHORT $LN3@calculateL

; 2394 : 		{
; 2395 : 			pLandmass = addLandmass();

	lea	ecx, DWORD PTR [edi+4140]
	call	?Add@?$FFreeListTrashArray@VCvLandmass@@@@QAEPAVCvLandmass@@XZ ; FFreeListTrashArray<CvLandmass>::Add

; 2396 : 			pLandmass->init(pLandmass->GetID(), pLoopPlot->isWater());

	cmp	BYTE PTR [esi+5], 3
	mov	DWORD PTR [eax+8], ebp
	sete	cl
	mov	DWORD PTR [eax+16], ebp
	mov	DWORD PTR [eax+20], ebp

; 2397 : 
; 2398 : 			iLandmassID = pLandmass->GetID();

	mov	ebp, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+13], cl

; 2399 : 
; 2400 : 			pLoopPlot->setLandmass(iLandmassID);

	push	ebp
	mov	ecx, esi
	mov	BYTE PTR [eax+12], 0
	call	?setLandmass@CvPlot@@QAEXH@Z		; CvPlot::setLandmass

; 2401 : 
; 2402 : 			thePathfinder.GeneratePath(pLoopPlot->getX(), pLoopPlot->getY(), -1, -1, iLandmassID);

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	0
	push	ebp
	push	-1
	push	-1
	push	eax
	push	ecx
	mov	ecx, ebx
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	xor	ebp, ebp
$LN3@calculateL:
	mov	eax, DWORD PTR _iI$236837[esp+24]
	add	DWORD PTR tv271[esp+24], 484		; 000001e4H
	inc	eax
	cmp	eax, DWORD PTR [edi+4028]
	mov	DWORD PTR _iI$236837[esp+24], eax
	jl	SHORT $LL4@calculateL
$LN2@calculateL:

; 2403 : 		}
; 2404 : 	}
; 2405 : 	thePathfinder.SetValidFunc(AreaValid);

	mov	DWORD PTR [ebx+16], OFFSET ?AreaValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; AreaValid

; 2406 : 	thePathfinder.SetNotifyListFunc(JoinArea);

	mov	DWORD PTR [ebx+24], OFFSET ?JoinArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; JoinArea

; 2407 : 
; 2408 : 	// KWG: Rebuild the yields here.  Yes, this is called during the landmass rebuild process if the landmass' 'lake' field changes, but
; 2409 : 	//      there is a problem with that. The yield bonus for a lake is dependent on the proximity to a plot that is a lake, and not the general landmass
; 2410 : 	//		'lake' flag.  During recalculation, a neighboring plot's 'lake' flag may not be set yet because it is in a landmass that has yet to be calculated
; 2411 : 	//		resulting in the wrong yield being applied to a plot.
; 2412 : 	updateYield();

	xor	esi, esi
	cmp	DWORD PTR [edi+4028], ebp
	jle	SHORT $LN35@calculateL
	npad	1
$LL37@calculateL:
	mov	ecx, DWORD PTR [edi+4068]
	add	ecx, ebp
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
	inc	esi
	add	ebp, 484				; 000001e4H
	cmp	esi, DWORD PTR [edi+4028]
	jl	SHORT $LL37@calculateL
$LN35@calculateL:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2413 : }

	add	esp, 8
	ret	0
?calculateLandmasses@CvMap@@QAEXXZ ENDP			; CvMap::calculateLandmasses
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@PAVCvPlot@@$00@@QAEXXZ	; BaseVector<CvPlot *,1>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?clear@?$BaseVector@PAVCvPlot@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@PAVCvPlot@@$00@@QAEXXZ PROC		; BaseVector<CvPlot *,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@PAVCvPlot@@$00@@QAEXXZ ENDP		; BaseVector<CvPlot *,1>::clear
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ ; FStaticVector<CvPlot *,1000,1,297,1>::FStaticVector<CvPlot *,1000,1,297,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ PROC ; FStaticVector<CvPlot *,1000,1,297,1>::FStaticVector<CvPlot *,1000,1,297,1>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 1000			; 000003e8H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ ENDP ; FStaticVector<CvPlot *,1000,1,297,1>::FStaticVector<CvPlot *,1000,1,297,1>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ ; FStaticVector<CvPlot *,1000,1,297,1>::~FStaticVector<CvPlot *,1000,1,297,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ PROC ; FStaticVector<CvPlot *,1000,1,297,1>::~FStaticVector<CvPlot *,1000,1,297,1>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@3:

; 619  : 	};

	ret	0
??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ ENDP ; FStaticVector<CvPlot *,1000,1,297,1>::~FStaticVector<CvPlot *,1000,1,297,1>
_TEXT	ENDS
PUBLIC	??_7?$FFreeListTrashArray@VCvArea@@@@6B@	; FFreeListTrashArray<CvArea>::`vftable'
PUBLIC	??0?$FFreeListTrashArray@VCvArea@@@@QAE@XZ	; FFreeListTrashArray<CvArea>::FFreeListTrashArray<CvArea>
PUBLIC	??_R4?$FFreeListTrashArray@VCvArea@@@@6B@	; FFreeListTrashArray<CvArea>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$FFreeListTrashArray@VCvArea@@@@@8	; FFreeListTrashArray<CvArea> `RTTI Type Descriptor'
PUBLIC	??_R3?$FFreeListTrashArray@VCvArea@@@@8		; FFreeListTrashArray<CvArea>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$FFreeListTrashArray@VCvArea@@@@8		; FFreeListTrashArray<CvArea>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$FFreeListTrashArray@VCvArea@@@@8 ; FFreeListTrashArray<CvArea>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Init@?$FFreeListTrashArray@VCvArea@@@@UAEXH@Z	; FFreeListTrashArray<CvArea>::Init
PUBLIC	?Uninit@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ	; FFreeListTrashArray<CvArea>::Uninit
PUBLIC	?GetAt@?$FFreeListTrashArray@VCvArea@@@@UBEPBVCvArea@@H@Z ; FFreeListTrashArray<CvArea>::GetAt
PUBLIC	?GetAt@?$FFreeListTrashArray@VCvArea@@@@UAEPAVCvArea@@H@Z ; FFreeListTrashArray<CvArea>::GetAt
PUBLIC	?RemoveAll@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ ; FFreeListTrashArray<CvArea>::RemoveAll
PUBLIC	?GrowArray@?$FFreeListTrashArray@VCvArea@@@@MAEXXZ ; FFreeListTrashArray<CvArea>::GrowArray
EXTRN	??_E?$FFreeListTrashArray@VCvArea@@@@UAEPAXI@Z:PROC ; FFreeListTrashArray<CvArea>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$FFreeListTrashArray@VCvArea@@@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
rdata$r	SEGMENT
??_R1A@?0A@EA@?$FFreeListTrashArray@VCvArea@@@@8 DD FLAT:??_R0?AV?$FFreeListTrashArray@VCvArea@@@@@8 ; FFreeListTrashArray<CvArea>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$FFreeListTrashArray@VCvArea@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$FFreeListTrashArray@VCvArea@@@@8
rdata$r	SEGMENT
??_R2?$FFreeListTrashArray@VCvArea@@@@8 DD FLAT:??_R1A@?0A@EA@?$FFreeListTrashArray@VCvArea@@@@8 ; FFreeListTrashArray<CvArea>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$FFreeListArrayBase@VCvArea@@@@8
rdata$r	ENDS
;	COMDAT ??_R3?$FFreeListTrashArray@VCvArea@@@@8
rdata$r	SEGMENT
??_R3?$FFreeListTrashArray@VCvArea@@@@8 DD 00H		; FFreeListTrashArray<CvArea>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$FFreeListTrashArray@VCvArea@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$FFreeListTrashArray@VCvArea@@@@@8
_DATA	SEGMENT
??_R0?AV?$FFreeListTrashArray@VCvArea@@@@@8 DD FLAT:??_7type_info@@6B@ ; FFreeListTrashArray<CvArea> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$FFreeListTrashArray@VCvArea@@@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$FFreeListTrashArray@VCvArea@@@@6B@
rdata$r	SEGMENT
??_R4?$FFreeListTrashArray@VCvArea@@@@6B@ DD 00H	; FFreeListTrashArray<CvArea>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$FFreeListTrashArray@VCvArea@@@@@8
	DD	FLAT:??_R3?$FFreeListTrashArray@VCvArea@@@@8
rdata$r	ENDS
;	COMDAT ??_7?$FFreeListTrashArray@VCvArea@@@@6B@
CONST	SEGMENT
??_7?$FFreeListTrashArray@VCvArea@@@@6B@ DD FLAT:??_R4?$FFreeListTrashArray@VCvArea@@@@6B@ ; FFreeListTrashArray<CvArea>::`vftable'
	DD	FLAT:??_E?$FFreeListTrashArray@VCvArea@@@@UAEPAXI@Z
	DD	FLAT:?Init@?$FFreeListTrashArray@VCvArea@@@@UAEXH@Z
	DD	FLAT:?Uninit@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ
	DD	FLAT:?GetAt@?$FFreeListTrashArray@VCvArea@@@@UBEPBVCvArea@@H@Z
	DD	FLAT:?GetAt@?$FFreeListTrashArray@VCvArea@@@@UAEPAVCvArea@@H@Z
	DD	FLAT:?RemoveAll@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ
	DD	FLAT:?GrowArray@?$FFreeListTrashArray@VCvArea@@@@MAEXXZ
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
CONST	ENDS
;	COMDAT ??0?$FFreeListTrashArray@VCvArea@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FFreeListTrashArray@VCvArea@@@@QAE@XZ PROC		; FFreeListTrashArray<CvArea>::FFreeListTrashArray<CvArea>, COMDAT
; _this$ = ecx

; 132  : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], -2			; fffffffeH
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], -1
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax], OFFSET ??_7?$FFreeListTrashArray@VCvArea@@@@6B@

; 133  : 	m_iCurrentID = FLTA_MAX_BUCKETS;

	mov	DWORD PTR [eax+20], 8192		; 00002000H

; 134  : 	m_pArray = NULL;

	mov	DWORD PTR [eax+24], ecx

; 135  : }

	ret	0
??0?$FFreeListTrashArray@VCvArea@@@@QAE@XZ ENDP		; FFreeListTrashArray<CvArea>::FFreeListTrashArray<CvArea>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Init@?$FFreeListTrashArray@VCvArea@@@@UAEXH@Z
_TEXT	SEGMENT
_iNumSlots$ = 8						; size = 4
?Init@?$FFreeListTrashArray@VCvArea@@@@UAEXH@Z PROC	; FFreeListTrashArray<CvArea>::Init, COMDAT
; _this$ = ecx

; 147  : {

	push	esi
	push	edi

; 148  : 	int iCount;
; 149  : 	int iI;
; 150  : 
; 151  : 	assert(iNumSlots >= 0);
; 152  : 
; 153  : 	// make sure it's binary...
; 154  : 	if ((iNumSlots > 0) && ((iNumSlots - 1) & iNumSlots) != 0)

	mov	edi, DWORD PTR _iNumSlots$[esp+4]
	mov	esi, ecx
	test	edi, edi
	jle	SHORT $LN7@Init
	lea	eax, DWORD PTR [edi-1]
	test	eax, edi
	je	SHORT $LN7@Init

; 155  : 	{
; 156  : 		// find high bit
; 157  : 		iCount = 0;

	xor	eax, eax

; 158  : 		while (iNumSlots != 1)

	cmp	edi, 1
	je	SHORT $LN5@Init
	npad	6
$LL6@Init:

; 159  : 		{
; 160  : 			iNumSlots >>= 1;

	sar	edi, 1

; 161  : 			iCount++;

	inc	eax
	cmp	edi, 1
	jne	SHORT $LL6@Init
$LN5@Init:

; 162  : 		}
; 163  : 		iNumSlots = (1 << (iCount + 1));

	lea	ecx, DWORD PTR [eax+1]
	mov	edi, 1
	shl	edi, cl
$LN7@Init:

; 164  : 	}
; 165  : 
; 166  : 	assert(((iNumSlots - 1) & iNumSlots) == 0);
; 167  : 	assert((this->m_iNumSlots <= FLTA_MAX_BUCKETS) && "FFreeListTrashArray<T>::init() size too large");
; 168  : 
; 169  : 	Uninit();

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax

; 170  : 
; 171  : 	this->m_iNumSlots = iNumSlots;

	mov	DWORD PTR [esi+16], edi

; 172  : 	this->m_iLastIndex = FFreeList::INVALID_INDEX;

	mov	DWORD PTR [esi+12], -1

; 173  : 	this->m_iFreeListHead = FFreeList::INVALID_INDEX;

	mov	DWORD PTR [esi+4], -1

; 174  : 	this->m_iFreeListCount = 0;

	mov	DWORD PTR [esi+8], 0

; 175  : 	m_iCurrentID = FLTA_MAX_BUCKETS;

	mov	DWORD PTR [esi+20], 8192		; 00002000H

; 176  : 
; 177  : 	if (this->m_iNumSlots > 0)

	test	edi, edi
	jle	SHORT $LN1@Init

; 178  : 	{
; 179  : 		m_pArray = FNEW( FFreeListTrashArrayNode[this->m_iNumSlots], c_eMPoolTypeContainer, 0 );

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+24], eax

; 180  : 
; 181  : 		for (iI = 0; iI < this->m_iNumSlots; iI++)

	xor	eax, eax
	add	esp, 4
	cmp	DWORD PTR [esi+16], eax
	jle	SHORT $LN1@Init
$LL3@Init:

; 182  : 		{
; 183  : 			m_pArray[iI].iNextFreeIndex = FFreeList::INVALID_INDEX;

	mov	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [ecx+eax*8], -1

; 184  : 			m_pArray[iI].pData = NULL;

	mov	edx, DWORD PTR [esi+24]
	mov	DWORD PTR [edx+eax*8+4], 0
	inc	eax
	cmp	eax, DWORD PTR [esi+16]
	jl	SHORT $LL3@Init
$LN1@Init:
	pop	edi
	pop	esi

; 185  : 		}
; 186  : 	}
; 187  : }

	ret	4
?Init@?$FFreeListTrashArray@VCvArea@@@@UAEXH@Z ENDP	; FFreeListTrashArray<CvArea>::Init
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetAt@?$FFreeListTrashArray@VCvArea@@@@UBEPBVCvArea@@H@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?GetAt@?$FFreeListTrashArray@VCvArea@@@@UBEPBVCvArea@@H@Z PROC ; FFreeListTrashArray<CvArea>::GetAt, COMDAT
; _this$ = ecx

; 273  : {

	push	esi

; 274  : 	int iIndex;
; 275  : 
; 276  : 	if ((iID == FFreeList::INVALID_INDEX) || (m_pArray == NULL))

	mov	esi, DWORD PTR _iID$[esp]
	cmp	esi, -1
	je	SHORT $LN4@GetAt
	mov	edx, DWORD PTR [ecx+24]
	test	edx, edx
	je	SHORT $LN4@GetAt

; 279  : 	}
; 280  : 
; 281  : 	iIndex = (iID & FLTA_INDEX_MASK);

	mov	eax, esi
	and	eax, 8191				; 00001fffH

; 282  : 
; 283  : 	assert(iIndex >= 0);
; 284  : 
; 285  : 	if ((iIndex <= this->m_iLastIndex) && 
; 286  : 		(m_pArray[iIndex].pData != NULL))

	cmp	eax, DWORD PTR [ecx+12]
	jg	SHORT $LN4@GetAt
	mov	eax, DWORD PTR [edx+eax*8+4]
	test	eax, eax
	je	SHORT $LN4@GetAt

; 287  : 	{
; 288  : 		if (((iID & FLTA_ID_MASK) == 0) || (m_pArray[iIndex].pData->GetID() == iID))

	test	esi, -8192				; ffffe000H
	je	SHORT $LN6@GetAt
	cmp	DWORD PTR [eax+4], esi

; 289  : 		{
; 290  : 			return m_pArray[iIndex].pData;

	je	SHORT $LN6@GetAt
$LN4@GetAt:

; 277  : 	{
; 278  : 		return NULL;

	xor	eax, eax
$LN6@GetAt:
	pop	esi

; 291  : 		}
; 292  : 	}
; 293  : 
; 294  : 	return NULL;
; 295  : }

	ret	4
?GetAt@?$FFreeListTrashArray@VCvArea@@@@UBEPBVCvArea@@H@Z ENDP ; FFreeListTrashArray<CvArea>::GetAt
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetAt@?$FFreeListTrashArray@VCvArea@@@@UAEPAVCvArea@@H@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?GetAt@?$FFreeListTrashArray@VCvArea@@@@UAEPAVCvArea@@H@Z PROC ; FFreeListTrashArray<CvArea>::GetAt, COMDAT
; _this$ = ecx

; 247  : {

	push	esi

; 248  : 	int iIndex;
; 249  : 
; 250  : 	if ((iID == FFreeList::INVALID_INDEX) || (m_pArray == NULL))

	mov	esi, DWORD PTR _iID$[esp]
	cmp	esi, -1
	je	SHORT $LN4@GetAt@2
	mov	edx, DWORD PTR [ecx+24]
	test	edx, edx
	je	SHORT $LN4@GetAt@2

; 253  : 	}
; 254  : 
; 255  : 	iIndex = (iID & FLTA_INDEX_MASK);

	mov	eax, esi
	and	eax, 8191				; 00001fffH

; 256  : 
; 257  : 	assert(iIndex >= 0);
; 258  : 
; 259  : 	if ((iIndex <= this->m_iLastIndex) && 
; 260  : 		(m_pArray[iIndex].pData != NULL))

	cmp	eax, DWORD PTR [ecx+12]
	jg	SHORT $LN4@GetAt@2
	mov	eax, DWORD PTR [edx+eax*8+4]
	test	eax, eax
	je	SHORT $LN4@GetAt@2

; 261  : 	{
; 262  : 		if (((iID & FLTA_ID_MASK) == 0) || (m_pArray[iIndex].pData->GetID() == iID))

	test	esi, -8192				; ffffe000H
	je	SHORT $LN6@GetAt@2
	cmp	DWORD PTR [eax+4], esi

; 263  : 		{
; 264  : 			return m_pArray[iIndex].pData;

	je	SHORT $LN6@GetAt@2
$LN4@GetAt@2:

; 251  : 	{
; 252  : 		return NULL;

	xor	eax, eax
$LN6@GetAt@2:
	pop	esi

; 265  : 		}
; 266  : 	}
; 267  : 
; 268  : 	return NULL;
; 269  : }

	ret	4
?GetAt@?$FFreeListTrashArray@VCvArea@@@@UAEPAVCvArea@@H@Z ENDP ; FFreeListTrashArray<CvArea>::GetAt
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GrowArray@?$FFreeListTrashArray@VCvArea@@@@MAEXXZ
_TEXT	SEGMENT
?GrowArray@?$FFreeListTrashArray@VCvArea@@@@MAEXXZ PROC	; FFreeListTrashArray<CvArea>::GrowArray, COMDAT
; _this$ = ecx

; 406  : {

	push	esi
	mov	esi, ecx
	push	edi

; 407  : 	FFreeListTrashArrayNode* pOldArray;
; 408  : 	int iOldNumSlots;
; 409  : 	int iI;
; 410  : 
; 411  : 	assert(m_pArray != NULL);
; 412  : 	
; 413  : 	if(!m_pArray) return;

	mov	edi, DWORD PTR [esi+24]
	test	edi, edi
	je	SHORT $LN7@GrowArray
	push	ebp

; 414  : 
; 415  : 	pOldArray = m_pArray;
; 416  : 	iOldNumSlots = this->m_iNumSlots;

	mov	ebp, DWORD PTR [esi+16]

; 417  : 
; 418  : 	this->m_iNumSlots *= FLTA_GROWTH_FACTOR;
; 419  : 	assert((this->m_iNumSlots <= FLTA_MAX_BUCKETS) && "FFreeListTrashArray<T>::growArray() size too large");
; 420  : 	m_pArray = FNEW( FFreeListTrashArrayNode[this->m_iNumSlots], c_eMPoolTypeContainer, 0 );

	xor	ecx, ecx
	lea	eax, DWORD PTR [ebp+ebp]
	mov	DWORD PTR [esi+16], eax
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+24], eax

; 421  : 
; 422  : 	for (iI = 0; iI < this->m_iNumSlots; iI++)

	xor	eax, eax
	add	esp, 4
	cmp	DWORD PTR [esi+16], eax
	jle	SHORT $LN3@GrowArray
	npad	7
$LL5@GrowArray:

; 423  : 	{
; 424  : 		if (iI < iOldNumSlots)

	cmp	eax, ebp

; 425  : 		{
; 426  : 			m_pArray[iI] = pOldArray[iI];

	mov	ecx, DWORD PTR [esi+24]
	jge	SHORT $LN2@GrowArray
	mov	edx, DWORD PTR [edi+eax*8]
	mov	DWORD PTR [ecx+eax*8], edx
	mov	edx, DWORD PTR [edi+eax*8+4]
	mov	DWORD PTR [ecx+eax*8+4], edx

; 427  : 		}
; 428  : 		else

	jmp	SHORT $LN4@GrowArray
$LN2@GrowArray:

; 429  : 		{
; 430  : 			m_pArray[iI].iNextFreeIndex = FFreeList::INVALID_INDEX;

	mov	DWORD PTR [ecx+eax*8], -1

; 431  : 			m_pArray[iI].pData = NULL;

	mov	edx, DWORD PTR [esi+24]
	mov	DWORD PTR [edx+eax*8+4], 0
$LN4@GrowArray:
	inc	eax
	cmp	eax, DWORD PTR [esi+16]
	jl	SHORT $LL5@GrowArray
$LN3@GrowArray:

; 432  : 		}
; 433  : 	}
; 434  : 
; 435  : 	delete [] pOldArray;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	pop	ebp
$LN7@GrowArray:
	pop	edi
	pop	esi

; 436  : }

	ret	0
?GrowArray@?$FFreeListTrashArray@VCvArea@@@@MAEXXZ ENDP	; FFreeListTrashArray<CvArea>::GrowArray
_TEXT	ENDS
PUBLIC	?RemoveAt@?$FFreeListTrashArray@VCvArea@@@@QAE_NH@Z ; FFreeListTrashArray<CvArea>::RemoveAt
; Function compile flags: /Ogtpy
;	COMDAT ?RemoveAt@?$FFreeListTrashArray@VCvArea@@@@QAE_NH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?RemoveAt@?$FFreeListTrashArray@VCvArea@@@@QAE_NH@Z PROC ; FFreeListTrashArray<CvArea>::RemoveAt, COMDAT
; _this$ = ecx

; 321  : {

	push	esi
	mov	esi, ecx

; 322  : 	int iIndex;
; 323  : 
; 324  : 	if ((iID == FFreeList::INVALID_INDEX) || (m_pArray == NULL))

	mov	ecx, DWORD PTR _iID$[esp]
	cmp	ecx, -1
	je	SHORT $LN5@RemoveAt@2
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN5@RemoveAt@2
	push	ebx
	push	edi

; 327  : 	}
; 328  : 
; 329  : 	iIndex = (iID & FLTA_INDEX_MASK);

	mov	edi, ecx
	and	edi, 8191				; 00001fffH

; 330  : 
; 331  : 	assert(iIndex >= 0);
; 332  : 
; 333  : 	if ((iIndex <= this->m_iLastIndex) && 
; 334  : 		(m_pArray[iIndex].pData != NULL))

	cmp	edi, DWORD PTR [esi+12]
	jg	SHORT $LN3@RemoveAt@2
	mov	ebx, DWORD PTR [eax+edi*8+4]
	test	ebx, ebx
	je	SHORT $LN3@RemoveAt@2

; 335  : 	{
; 336  : 		if (((iID & FLTA_ID_MASK) == 0) || (m_pArray[iIndex].pData->GetID() == iID))

	test	ecx, -8192				; ffffe000H
	je	SHORT $LN2@RemoveAt@2
	cmp	DWORD PTR [ebx+4], ecx
	jne	SHORT $LN3@RemoveAt@2
$LN2@RemoveAt@2:

; 337  : 		{
; 338  : 			delete m_pArray[iIndex].pData;

	mov	ecx, ebx
	call	??1CvArea@@QAE@XZ			; CvArea::~CvArea
	push	ebx
	call	??3@YAXPAX@Z				; operator delete

; 339  : 			m_pArray[iIndex].pData = NULL;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+edi*8+4], 0

; 340  : 
; 341  : 			m_pArray[iIndex].iNextFreeIndex = this->m_iFreeListHead;

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+24]
	add	esp, 4
	mov	DWORD PTR [ecx+edi*8], edx

; 342  : 			this->m_iFreeListHead = iIndex;

	mov	DWORD PTR [esi+4], edi
	pop	edi

; 343  : 			this->m_iFreeListCount++;

	mov	eax, 1
	add	DWORD PTR [esi+8], eax
	pop	ebx
	pop	esi

; 354  : }

	ret	4
$LN3@RemoveAt@2:
	pop	edi
	pop	ebx

; 344  : 
; 345  : 			return true;
; 346  : 		}
; 347  : 		else
; 348  : 		{
; 349  : 			assert(false);
; 350  : 		}
; 351  : 	}
; 352  : 
; 353  : 	return false;

	xor	al, al
	pop	esi

; 354  : }

	ret	4
$LN5@RemoveAt@2:

; 325  : 	{
; 326  : 		return false;

	xor	al, al
	pop	esi

; 354  : }

	ret	4
?RemoveAt@?$FFreeListTrashArray@VCvArea@@@@QAE_NH@Z ENDP ; FFreeListTrashArray<CvArea>::RemoveAt
_TEXT	ENDS
PUBLIC	?BeginIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ; FFreeListArrayBase<CvArea>::BeginIter
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
;	COMDAT ?BeginIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z
_TEXT	SEGMENT
_pIterIdx$ = 8						; size = 4
?BeginIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z PROC ; FFreeListArrayBase<CvArea>::BeginIter, COMDAT
; _this$ = ecx

; 119  : {

	push	esi

; 120  : 	*pIterIdx = 0;

	mov	esi, DWORD PTR _pIterIdx$[esp]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [esi], 0

; 121  : 	return NextIter(pIterIdx);

	mov	eax, DWORD PTR [edi+12]
	inc	eax
	test	eax, eax
	jle	SHORT $LN4@BeginIter
$LL6@BeginIter:
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+16]
	push	eax
	mov	ecx, edi
	call	edx
	inc	DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN7@BeginIter
	mov	eax, DWORD PTR [edi+12]
	inc	eax
	cmp	DWORD PTR [esi], eax
	jl	SHORT $LL6@BeginIter
$LN4@BeginIter:
	xor	eax, eax
$LN7@BeginIter:
	pop	edi
	pop	esi

; 122  : }

	ret	4
?BeginIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ENDP ; FFreeListArrayBase<CvArea>::BeginIter
_TEXT	ENDS
PUBLIC	?EndIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ; FFreeListArrayBase<CvArea>::EndIter
; Function compile flags: /Ogtpy
;	COMDAT ?EndIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z
_TEXT	SEGMENT
_pIterIdx$ = 8						; size = 4
?EndIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z PROC ; FFreeListArrayBase<CvArea>::EndIter, COMDAT
; _this$ = ecx

; 143  : {

	push	esi

; 144  : 	*pIterIdx = GetIndexAfterLast()-1;

	mov	esi, DWORD PTR _pIterIdx$[esp]
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], eax

; 145  : 	return PrevIter(pIterIdx);

	test	eax, eax
	jl	SHORT $LN6@EndIter
$LL8@EndIter:
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, edi
	call	edx
	dec	DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN9@EndIter
	cmp	DWORD PTR [esi], eax
	jge	SHORT $LL8@EndIter
$LN6@EndIter:
	xor	eax, eax
$LN9@EndIter:
	pop	edi
	pop	esi

; 146  : }

	ret	4
?EndIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ENDP ; FFreeListArrayBase<CvArea>::EndIter
_TEXT	ENDS
PUBLIC	??_7?$FFreeListTrashArray@VCvLandmass@@@@6B@	; FFreeListTrashArray<CvLandmass>::`vftable'
PUBLIC	??0?$FFreeListTrashArray@VCvLandmass@@@@QAE@XZ	; FFreeListTrashArray<CvLandmass>::FFreeListTrashArray<CvLandmass>
PUBLIC	??_R4?$FFreeListTrashArray@VCvLandmass@@@@6B@	; FFreeListTrashArray<CvLandmass>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$FFreeListTrashArray@VCvLandmass@@@@@8	; FFreeListTrashArray<CvLandmass> `RTTI Type Descriptor'
PUBLIC	??_R3?$FFreeListTrashArray@VCvLandmass@@@@8	; FFreeListTrashArray<CvLandmass>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$FFreeListTrashArray@VCvLandmass@@@@8	; FFreeListTrashArray<CvLandmass>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$FFreeListTrashArray@VCvLandmass@@@@8 ; FFreeListTrashArray<CvLandmass>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Init@?$FFreeListTrashArray@VCvLandmass@@@@UAEXH@Z ; FFreeListTrashArray<CvLandmass>::Init
PUBLIC	?Uninit@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ ; FFreeListTrashArray<CvLandmass>::Uninit
PUBLIC	?GetAt@?$FFreeListTrashArray@VCvLandmass@@@@UBEPBVCvLandmass@@H@Z ; FFreeListTrashArray<CvLandmass>::GetAt
PUBLIC	?GetAt@?$FFreeListTrashArray@VCvLandmass@@@@UAEPAVCvLandmass@@H@Z ; FFreeListTrashArray<CvLandmass>::GetAt
PUBLIC	?RemoveAll@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ ; FFreeListTrashArray<CvLandmass>::RemoveAll
PUBLIC	?GrowArray@?$FFreeListTrashArray@VCvLandmass@@@@MAEXXZ ; FFreeListTrashArray<CvLandmass>::GrowArray
EXTRN	??_E?$FFreeListTrashArray@VCvLandmass@@@@UAEPAXI@Z:PROC ; FFreeListTrashArray<CvLandmass>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$FFreeListTrashArray@VCvLandmass@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$FFreeListTrashArray@VCvLandmass@@@@8 DD FLAT:??_R0?AV?$FFreeListTrashArray@VCvLandmass@@@@@8 ; FFreeListTrashArray<CvLandmass>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$FFreeListTrashArray@VCvLandmass@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$FFreeListTrashArray@VCvLandmass@@@@8
rdata$r	SEGMENT
??_R2?$FFreeListTrashArray@VCvLandmass@@@@8 DD FLAT:??_R1A@?0A@EA@?$FFreeListTrashArray@VCvLandmass@@@@8 ; FFreeListTrashArray<CvLandmass>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$FFreeListArrayBase@VCvLandmass@@@@8
rdata$r	ENDS
;	COMDAT ??_R3?$FFreeListTrashArray@VCvLandmass@@@@8
rdata$r	SEGMENT
??_R3?$FFreeListTrashArray@VCvLandmass@@@@8 DD 00H	; FFreeListTrashArray<CvLandmass>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$FFreeListTrashArray@VCvLandmass@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$FFreeListTrashArray@VCvLandmass@@@@@8
_DATA	SEGMENT
??_R0?AV?$FFreeListTrashArray@VCvLandmass@@@@@8 DD FLAT:??_7type_info@@6B@ ; FFreeListTrashArray<CvLandmass> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$FFreeListTrashArray@VCvLandmass@@@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$FFreeListTrashArray@VCvLandmass@@@@6B@
rdata$r	SEGMENT
??_R4?$FFreeListTrashArray@VCvLandmass@@@@6B@ DD 00H	; FFreeListTrashArray<CvLandmass>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$FFreeListTrashArray@VCvLandmass@@@@@8
	DD	FLAT:??_R3?$FFreeListTrashArray@VCvLandmass@@@@8
rdata$r	ENDS
;	COMDAT ??_7?$FFreeListTrashArray@VCvLandmass@@@@6B@
CONST	SEGMENT
??_7?$FFreeListTrashArray@VCvLandmass@@@@6B@ DD FLAT:??_R4?$FFreeListTrashArray@VCvLandmass@@@@6B@ ; FFreeListTrashArray<CvLandmass>::`vftable'
	DD	FLAT:??_E?$FFreeListTrashArray@VCvLandmass@@@@UAEPAXI@Z
	DD	FLAT:?Init@?$FFreeListTrashArray@VCvLandmass@@@@UAEXH@Z
	DD	FLAT:?Uninit@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ
	DD	FLAT:?GetAt@?$FFreeListTrashArray@VCvLandmass@@@@UBEPBVCvLandmass@@H@Z
	DD	FLAT:?GetAt@?$FFreeListTrashArray@VCvLandmass@@@@UAEPAVCvLandmass@@H@Z
	DD	FLAT:?RemoveAll@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ
	DD	FLAT:?GrowArray@?$FFreeListTrashArray@VCvLandmass@@@@MAEXXZ
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
CONST	ENDS
;	COMDAT ??0?$FFreeListTrashArray@VCvLandmass@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FFreeListTrashArray@VCvLandmass@@@@QAE@XZ PROC	; FFreeListTrashArray<CvLandmass>::FFreeListTrashArray<CvLandmass>, COMDAT
; _this$ = ecx

; 132  : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], -2			; fffffffeH
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], -1
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax], OFFSET ??_7?$FFreeListTrashArray@VCvLandmass@@@@6B@

; 133  : 	m_iCurrentID = FLTA_MAX_BUCKETS;

	mov	DWORD PTR [eax+20], 8192		; 00002000H

; 134  : 	m_pArray = NULL;

	mov	DWORD PTR [eax+24], ecx

; 135  : }

	ret	0
??0?$FFreeListTrashArray@VCvLandmass@@@@QAE@XZ ENDP	; FFreeListTrashArray<CvLandmass>::FFreeListTrashArray<CvLandmass>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Init@?$FFreeListTrashArray@VCvLandmass@@@@UAEXH@Z
_TEXT	SEGMENT
_iNumSlots$ = 8						; size = 4
?Init@?$FFreeListTrashArray@VCvLandmass@@@@UAEXH@Z PROC	; FFreeListTrashArray<CvLandmass>::Init, COMDAT
; _this$ = ecx

; 147  : {

	push	esi
	push	edi

; 148  : 	int iCount;
; 149  : 	int iI;
; 150  : 
; 151  : 	assert(iNumSlots >= 0);
; 152  : 
; 153  : 	// make sure it's binary...
; 154  : 	if ((iNumSlots > 0) && ((iNumSlots - 1) & iNumSlots) != 0)

	mov	edi, DWORD PTR _iNumSlots$[esp+4]
	mov	esi, ecx
	test	edi, edi
	jle	SHORT $LN7@Init@2
	lea	eax, DWORD PTR [edi-1]
	test	eax, edi
	je	SHORT $LN7@Init@2

; 155  : 	{
; 156  : 		// find high bit
; 157  : 		iCount = 0;

	xor	eax, eax

; 158  : 		while (iNumSlots != 1)

	cmp	edi, 1
	je	SHORT $LN5@Init@2
	npad	6
$LL6@Init@2:

; 159  : 		{
; 160  : 			iNumSlots >>= 1;

	sar	edi, 1

; 161  : 			iCount++;

	inc	eax
	cmp	edi, 1
	jne	SHORT $LL6@Init@2
$LN5@Init@2:

; 162  : 		}
; 163  : 		iNumSlots = (1 << (iCount + 1));

	lea	ecx, DWORD PTR [eax+1]
	mov	edi, 1
	shl	edi, cl
$LN7@Init@2:

; 164  : 	}
; 165  : 
; 166  : 	assert(((iNumSlots - 1) & iNumSlots) == 0);
; 167  : 	assert((this->m_iNumSlots <= FLTA_MAX_BUCKETS) && "FFreeListTrashArray<T>::init() size too large");
; 168  : 
; 169  : 	Uninit();

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax

; 170  : 
; 171  : 	this->m_iNumSlots = iNumSlots;

	mov	DWORD PTR [esi+16], edi

; 172  : 	this->m_iLastIndex = FFreeList::INVALID_INDEX;

	mov	DWORD PTR [esi+12], -1

; 173  : 	this->m_iFreeListHead = FFreeList::INVALID_INDEX;

	mov	DWORD PTR [esi+4], -1

; 174  : 	this->m_iFreeListCount = 0;

	mov	DWORD PTR [esi+8], 0

; 175  : 	m_iCurrentID = FLTA_MAX_BUCKETS;

	mov	DWORD PTR [esi+20], 8192		; 00002000H

; 176  : 
; 177  : 	if (this->m_iNumSlots > 0)

	test	edi, edi
	jle	SHORT $LN1@Init@2

; 178  : 	{
; 179  : 		m_pArray = FNEW( FFreeListTrashArrayNode[this->m_iNumSlots], c_eMPoolTypeContainer, 0 );

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+24], eax

; 180  : 
; 181  : 		for (iI = 0; iI < this->m_iNumSlots; iI++)

	xor	eax, eax
	add	esp, 4
	cmp	DWORD PTR [esi+16], eax
	jle	SHORT $LN1@Init@2
$LL3@Init@2:

; 182  : 		{
; 183  : 			m_pArray[iI].iNextFreeIndex = FFreeList::INVALID_INDEX;

	mov	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [ecx+eax*8], -1

; 184  : 			m_pArray[iI].pData = NULL;

	mov	edx, DWORD PTR [esi+24]
	mov	DWORD PTR [edx+eax*8+4], 0
	inc	eax
	cmp	eax, DWORD PTR [esi+16]
	jl	SHORT $LL3@Init@2
$LN1@Init@2:
	pop	edi
	pop	esi

; 185  : 		}
; 186  : 	}
; 187  : }

	ret	4
?Init@?$FFreeListTrashArray@VCvLandmass@@@@UAEXH@Z ENDP	; FFreeListTrashArray<CvLandmass>::Init
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetAt@?$FFreeListTrashArray@VCvLandmass@@@@UBEPBVCvLandmass@@H@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?GetAt@?$FFreeListTrashArray@VCvLandmass@@@@UBEPBVCvLandmass@@H@Z PROC ; FFreeListTrashArray<CvLandmass>::GetAt, COMDAT
; _this$ = ecx

; 273  : {

	push	esi

; 274  : 	int iIndex;
; 275  : 
; 276  : 	if ((iID == FFreeList::INVALID_INDEX) || (m_pArray == NULL))

	mov	esi, DWORD PTR _iID$[esp]
	cmp	esi, -1
	je	SHORT $LN4@GetAt@3
	mov	edx, DWORD PTR [ecx+24]
	test	edx, edx
	je	SHORT $LN4@GetAt@3

; 279  : 	}
; 280  : 
; 281  : 	iIndex = (iID & FLTA_INDEX_MASK);

	mov	eax, esi
	and	eax, 8191				; 00001fffH

; 282  : 
; 283  : 	assert(iIndex >= 0);
; 284  : 
; 285  : 	if ((iIndex <= this->m_iLastIndex) && 
; 286  : 		(m_pArray[iIndex].pData != NULL))

	cmp	eax, DWORD PTR [ecx+12]
	jg	SHORT $LN4@GetAt@3
	mov	eax, DWORD PTR [edx+eax*8+4]
	test	eax, eax
	je	SHORT $LN4@GetAt@3

; 287  : 	{
; 288  : 		if (((iID & FLTA_ID_MASK) == 0) || (m_pArray[iIndex].pData->GetID() == iID))

	test	esi, -8192				; ffffe000H
	je	SHORT $LN6@GetAt@3
	cmp	DWORD PTR [eax+4], esi

; 289  : 		{
; 290  : 			return m_pArray[iIndex].pData;

	je	SHORT $LN6@GetAt@3
$LN4@GetAt@3:

; 277  : 	{
; 278  : 		return NULL;

	xor	eax, eax
$LN6@GetAt@3:
	pop	esi

; 291  : 		}
; 292  : 	}
; 293  : 
; 294  : 	return NULL;
; 295  : }

	ret	4
?GetAt@?$FFreeListTrashArray@VCvLandmass@@@@UBEPBVCvLandmass@@H@Z ENDP ; FFreeListTrashArray<CvLandmass>::GetAt
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetAt@?$FFreeListTrashArray@VCvLandmass@@@@UAEPAVCvLandmass@@H@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?GetAt@?$FFreeListTrashArray@VCvLandmass@@@@UAEPAVCvLandmass@@H@Z PROC ; FFreeListTrashArray<CvLandmass>::GetAt, COMDAT
; _this$ = ecx

; 247  : {

	push	esi

; 248  : 	int iIndex;
; 249  : 
; 250  : 	if ((iID == FFreeList::INVALID_INDEX) || (m_pArray == NULL))

	mov	esi, DWORD PTR _iID$[esp]
	cmp	esi, -1
	je	SHORT $LN4@GetAt@4
	mov	edx, DWORD PTR [ecx+24]
	test	edx, edx
	je	SHORT $LN4@GetAt@4

; 253  : 	}
; 254  : 
; 255  : 	iIndex = (iID & FLTA_INDEX_MASK);

	mov	eax, esi
	and	eax, 8191				; 00001fffH

; 256  : 
; 257  : 	assert(iIndex >= 0);
; 258  : 
; 259  : 	if ((iIndex <= this->m_iLastIndex) && 
; 260  : 		(m_pArray[iIndex].pData != NULL))

	cmp	eax, DWORD PTR [ecx+12]
	jg	SHORT $LN4@GetAt@4
	mov	eax, DWORD PTR [edx+eax*8+4]
	test	eax, eax
	je	SHORT $LN4@GetAt@4

; 261  : 	{
; 262  : 		if (((iID & FLTA_ID_MASK) == 0) || (m_pArray[iIndex].pData->GetID() == iID))

	test	esi, -8192				; ffffe000H
	je	SHORT $LN6@GetAt@4
	cmp	DWORD PTR [eax+4], esi

; 263  : 		{
; 264  : 			return m_pArray[iIndex].pData;

	je	SHORT $LN6@GetAt@4
$LN4@GetAt@4:

; 251  : 	{
; 252  : 		return NULL;

	xor	eax, eax
$LN6@GetAt@4:
	pop	esi

; 265  : 		}
; 266  : 	}
; 267  : 
; 268  : 	return NULL;
; 269  : }

	ret	4
?GetAt@?$FFreeListTrashArray@VCvLandmass@@@@UAEPAVCvLandmass@@H@Z ENDP ; FFreeListTrashArray<CvLandmass>::GetAt
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ PROC ; FFreeListTrashArray<CvLandmass>::RemoveAll, COMDAT
; _this$ = ecx

; 359  : {

	push	esi
	mov	esi, ecx

; 360  : 	int iI;
; 361  : 
; 362  : 	if (m_pArray == NULL)

	cmp	DWORD PTR [esi+24], 0
	je	SHORT $LN2@RemoveAll
	push	edi

; 363  : 	{
; 364  : 		return;
; 365  : 	}
; 366  : 
; 367  : 	this->m_iLastIndex = FFreeList::INVALID_INDEX;
; 368  : 	this->m_iFreeListHead = FFreeList::INVALID_INDEX;
; 369  : 	this->m_iFreeListCount = 0;
; 370  : 
; 371  : 	for (iI = 0; iI < this->m_iNumSlots; iI++)

	xor	edi, edi
	cmp	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+12], -1
	mov	DWORD PTR [esi+4], -1
	mov	DWORD PTR [esi+8], 0
	jle	SHORT $LN12@RemoveAll
	npad	10
$LL4@RemoveAll:

; 372  : 	{
; 373  : 		m_pArray[iI].iNextFreeIndex = FFreeList::INVALID_INDEX;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+edi*8], -1

; 374  : 		if (m_pArray[iI].pData != NULL)

	mov	ecx, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+edi*8+4]
	test	ecx, ecx
	je	SHORT $LN8@RemoveAll

; 375  : 		{
; 376  : 			delete m_pArray[iI].pData;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	1
	call	eax
$LN8@RemoveAll:

; 377  : 		}
; 378  : 		m_pArray[iI].pData = NULL;

	mov	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [ecx+edi*8+4], 0
	inc	edi
	cmp	edi, DWORD PTR [esi+16]
	jl	SHORT $LL4@RemoveAll
$LN12@RemoveAll:
	pop	edi
$LN2@RemoveAll:
	pop	esi

; 379  : 	}
; 380  : }

	ret	0
?RemoveAll@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ ENDP ; FFreeListTrashArray<CvLandmass>::RemoveAll
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GrowArray@?$FFreeListTrashArray@VCvLandmass@@@@MAEXXZ
_TEXT	SEGMENT
?GrowArray@?$FFreeListTrashArray@VCvLandmass@@@@MAEXXZ PROC ; FFreeListTrashArray<CvLandmass>::GrowArray, COMDAT
; _this$ = ecx

; 406  : {

	push	esi
	mov	esi, ecx
	push	edi

; 407  : 	FFreeListTrashArrayNode* pOldArray;
; 408  : 	int iOldNumSlots;
; 409  : 	int iI;
; 410  : 
; 411  : 	assert(m_pArray != NULL);
; 412  : 	
; 413  : 	if(!m_pArray) return;

	mov	edi, DWORD PTR [esi+24]
	test	edi, edi
	je	SHORT $LN7@GrowArray@2
	push	ebp

; 414  : 
; 415  : 	pOldArray = m_pArray;
; 416  : 	iOldNumSlots = this->m_iNumSlots;

	mov	ebp, DWORD PTR [esi+16]

; 417  : 
; 418  : 	this->m_iNumSlots *= FLTA_GROWTH_FACTOR;
; 419  : 	assert((this->m_iNumSlots <= FLTA_MAX_BUCKETS) && "FFreeListTrashArray<T>::growArray() size too large");
; 420  : 	m_pArray = FNEW( FFreeListTrashArrayNode[this->m_iNumSlots], c_eMPoolTypeContainer, 0 );

	xor	ecx, ecx
	lea	eax, DWORD PTR [ebp+ebp]
	mov	DWORD PTR [esi+16], eax
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+24], eax

; 421  : 
; 422  : 	for (iI = 0; iI < this->m_iNumSlots; iI++)

	xor	eax, eax
	add	esp, 4
	cmp	DWORD PTR [esi+16], eax
	jle	SHORT $LN3@GrowArray@2
	npad	7
$LL5@GrowArray@2:

; 423  : 	{
; 424  : 		if (iI < iOldNumSlots)

	cmp	eax, ebp

; 425  : 		{
; 426  : 			m_pArray[iI] = pOldArray[iI];

	mov	ecx, DWORD PTR [esi+24]
	jge	SHORT $LN2@GrowArray@2
	mov	edx, DWORD PTR [edi+eax*8]
	mov	DWORD PTR [ecx+eax*8], edx
	mov	edx, DWORD PTR [edi+eax*8+4]
	mov	DWORD PTR [ecx+eax*8+4], edx

; 427  : 		}
; 428  : 		else

	jmp	SHORT $LN4@GrowArray@2
$LN2@GrowArray@2:

; 429  : 		{
; 430  : 			m_pArray[iI].iNextFreeIndex = FFreeList::INVALID_INDEX;

	mov	DWORD PTR [ecx+eax*8], -1

; 431  : 			m_pArray[iI].pData = NULL;

	mov	edx, DWORD PTR [esi+24]
	mov	DWORD PTR [edx+eax*8+4], 0
$LN4@GrowArray@2:
	inc	eax
	cmp	eax, DWORD PTR [esi+16]
	jl	SHORT $LL5@GrowArray@2
$LN3@GrowArray@2:

; 432  : 		}
; 433  : 	}
; 434  : 
; 435  : 	delete [] pOldArray;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	pop	ebp
$LN7@GrowArray@2:
	pop	edi
	pop	esi

; 436  : }

	ret	0
?GrowArray@?$FFreeListTrashArray@VCvLandmass@@@@MAEXXZ ENDP ; FFreeListTrashArray<CvLandmass>::GrowArray
_TEXT	ENDS
PUBLIC	?BeginIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ; FFreeListArrayBase<CvLandmass>::BeginIter
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
;	COMDAT ?BeginIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z
_TEXT	SEGMENT
_pIterIdx$ = 8						; size = 4
?BeginIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z PROC ; FFreeListArrayBase<CvLandmass>::BeginIter, COMDAT
; _this$ = ecx

; 119  : {

	push	esi

; 120  : 	*pIterIdx = 0;

	mov	esi, DWORD PTR _pIterIdx$[esp]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [esi], 0

; 121  : 	return NextIter(pIterIdx);

	mov	eax, DWORD PTR [edi+12]
	inc	eax
	test	eax, eax
	jle	SHORT $LN4@BeginIter@2
$LL6@BeginIter@2:
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+16]
	push	eax
	mov	ecx, edi
	call	edx
	inc	DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN7@BeginIter@2
	mov	eax, DWORD PTR [edi+12]
	inc	eax
	cmp	DWORD PTR [esi], eax
	jl	SHORT $LL6@BeginIter@2
$LN4@BeginIter@2:
	xor	eax, eax
$LN7@BeginIter@2:
	pop	edi
	pop	esi

; 122  : }

	ret	4
?BeginIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ENDP ; FFreeListArrayBase<CvLandmass>::BeginIter
_TEXT	ENDS
PUBLIC	?EndIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ; FFreeListArrayBase<CvLandmass>::EndIter
; Function compile flags: /Ogtpy
;	COMDAT ?EndIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z
_TEXT	SEGMENT
_pIterIdx$ = 8						; size = 4
?EndIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z PROC ; FFreeListArrayBase<CvLandmass>::EndIter, COMDAT
; _this$ = ecx

; 143  : {

	push	esi

; 144  : 	*pIterIdx = GetIndexAfterLast()-1;

	mov	esi, DWORD PTR _pIterIdx$[esp]
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], eax

; 145  : 	return PrevIter(pIterIdx);

	test	eax, eax
	jl	SHORT $LN6@EndIter@2
$LL8@EndIter@2:
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, edi
	call	edx
	dec	DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN9@EndIter@2
	cmp	DWORD PTR [esi], eax
	jge	SHORT $LL8@EndIter@2
$LN6@EndIter@2:
	xor	eax, eax
$LN9@EndIter@2:
	pop	edi
	pop	esi

; 146  : }

	ret	4
?EndIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ENDP ; FFreeListArrayBase<CvLandmass>::EndIter
_TEXT	ENDS
PUBLIC	??$?5E@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@E@@@Z ; operator>><unsigned char>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5E@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@E@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5E@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@E@@@Z PROC ; operator>><unsigned char>, COMDAT

; 516  : 	int i = 0;
; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	ebx

; 518  : 	ValueType * values = v.getArray();

	mov	ebx, DWORD PTR [eax]
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 519  : 	for(i = 0; i < count; ++i)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN14@operator
	push	ebp
	mov	ebp, DWORD PTR _loadFrom$[esp+12]
$LL3@operator:

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	lea	eax, DWORD PTR [ebx+esi]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAE@Z		; FDataStream::Read
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL3@operator

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, ebp
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 524  : }

	ret	0
$LN14@operator:

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[esp+8]
	pop	edi
	pop	esi
	pop	ebx

; 524  : }

	ret	0
??$?5E@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@E@@@Z ENDP ; operator>><unsigned char>
_TEXT	ENDS
PUBLIC	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
_bValid$237103 = -13					; size = 1
_uiNumEntries$ = -12					; size = 4
_tValue$237106 = -8					; size = 4
_tValue$237111 = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<int>, COMDAT

; 248  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	edi

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	mov	edi, DWORD PTR _kStream$[esp+20]
	lea	eax, DWORD PTR _uiNumEntries$[esp+24]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	xor	ebx, ebx
	cmp	DWORD PTR _uiNumEntries$[esp+24], ebx
	jbe	SHORT $LN5@ReadHashed
	push	ebp
	mov	ebp, DWORD PTR _iArraySize$[esp+24]
	push	esi
$LL7@ReadHashed:

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$237103[esp+32]
	push	ecx
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	esi, eax
	add	esp, 8

; 257  : 		if(iType != -1)

	cmp	esi, -1
	je	SHORT $LN4@ReadHashed

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$237106[esp+32]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	cmp	esi, ebp
	jge	SHORT $LN6@ReadHashed

; 262  : 				paArray[iType] = tValue;

	mov	eax, DWORD PTR _tValue$237106[esp+32]
	mov	ecx, DWORD PTR _paArray$[esp+28]
	mov	DWORD PTR [ecx+esi*4], eax

; 263  : 		}

	jmp	SHORT $LN6@ReadHashed
$LN4@ReadHashed:

; 264  : 		else if(!bValid)

	cmp	BYTE PTR _bValid$237103[esp+32], 0
	jne	SHORT $LN6@ReadHashed

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$237111[esp+32]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
$LN6@ReadHashed:
	inc	ebx
	cmp	ebx, DWORD PTR _uiNumEntries$[esp+32]
	jb	SHORT $LL7@ReadHashed
	pop	esi
	pop	ebp
$LN5@ReadHashed:
	pop	edi
	pop	ebx

; 268  : 		}
; 269  : 	}
; 270  : }

	add	esp, 16					; 00000010H
	ret	0
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<int>
_TEXT	ENDS
PUBLIC	??$?5VCvLandmass@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvLandmass@@@@@Z ; operator>><CvLandmass>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
;	COMDAT ??$?5VCvLandmass@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvLandmass@@@@@Z
_TEXT	SEGMENT
_iCount$ = -4						; size = 4
_iTemp$ = 8						; size = 4
_readFrom$ = 8						; size = 4
_i$ = 12						; size = 4
_writeTo$ = 12						; size = 4
??$?5VCvLandmass@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvLandmass@@@@@Z PROC ; operator>><CvLandmass>, COMDAT

; 602  : {

	push	ecx
	push	ebx
	push	ebp

; 603  : 	int iTemp;
; 604  : 	readFrom >> iTemp;

	mov	ebp, DWORD PTR _readFrom$[esp+8]
	push	esi
	push	edi
	lea	eax, DWORD PTR _iTemp$[esp+16]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 605  : 	writeTo.Init( iTemp );

	mov	edi, DWORD PTR _writeTo$[esp+16]
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR _iTemp$[esp+16]
	mov	edx, DWORD PTR [edx+4]
	push	eax
	mov	ecx, edi
	call	edx

; 606  : 	readFrom >> iTemp;

	lea	eax, DWORD PTR _iTemp$[esp+16]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 607  : 	writeTo.SetLastIndex(iTemp);

	mov	ecx, DWORD PTR _iTemp$[esp+16]

; 608  : 	readFrom >> iTemp;

	lea	edx, DWORD PTR _iTemp$[esp+16]
	mov	DWORD PTR [edi+12], ecx
	push	edx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 609  : 	writeTo.SetFreeListHead(iTemp);

	mov	eax, DWORD PTR _iTemp$[esp+16]

; 610  : 	readFrom >> iTemp;

	lea	ecx, DWORD PTR _iTemp$[esp+16]
	push	ecx
	mov	ecx, ebp
	mov	DWORD PTR [edi+4], eax
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 611  : 	writeTo.SetFreeListCount(iTemp);

	mov	edx, DWORD PTR _iTemp$[esp+16]

; 612  : 	readFrom >> iTemp;

	lea	eax, DWORD PTR _iTemp$[esp+16]
	push	eax
	mov	ecx, ebp
	mov	DWORD PTR [edi+8], edx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 613  : 	writeTo.SetCurrentID(iTemp);

	mov	ecx, DWORD PTR _iTemp$[esp+16]

; 614  : 
; 615  : 	int i;
; 616  : 
; 617  : 	for ( i = 0; i < writeTo.GetNumSlots(); i++ )

	xor	ebx, ebx
	xor	esi, esi
	cmp	DWORD PTR [edi+16], ebx
	mov	DWORD PTR [edi+20], ecx
	jle	SHORT $LN4@operator@2
	npad	4
$LL6@operator@2:

; 618  : 	{
; 619  : 		readFrom >> iTemp;

	lea	edx, DWORD PTR _iTemp$[esp+16]
	push	edx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 620  : 		writeTo.SetNextFreeIndex(i, iTemp);

	cmp	esi, DWORD PTR [edi+16]
	jge	SHORT $LN5@operator@2
	mov	eax, DWORD PTR [edi+24]
	cmp	eax, ebx
	je	SHORT $LN5@operator@2
	mov	ecx, DWORD PTR _iTemp$[esp+16]
	mov	DWORD PTR [eax+esi*8], ecx
$LN5@operator@2:
	inc	esi
	cmp	esi, DWORD PTR [edi+16]
	jl	SHORT $LL6@operator@2
$LN4@operator@2:

; 621  : 	}
; 622  : 
; 623  : 	int iCount;
; 624  : 	readFrom >> iCount;

	lea	edx, DWORD PTR _iCount$[esp+20]
	push	edx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 625  : 
; 626  : 	for ( i = 0; i < iCount; i++ )

	cmp	DWORD PTR _iCount$[esp+20], ebx
	mov	DWORD PTR _i$[esp+16], ebx
	jle	SHORT $LN56@operator@2
	npad	5
$LL3@operator@2:

; 627  : 	{
; 628  : 		T* pData = new T;

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN9@operator@2
	mov	DWORD PTR [eax], OFFSET ??_7CvLandmass@@6B@
	mov	DWORD PTR [eax+4], -1
	mov	DWORD PTR [eax+8], ebx
	mov	BYTE PTR [eax+13], 1
	mov	BYTE PTR [eax+12], bl
	mov	DWORD PTR [eax+16], ebx
	mov	DWORD PTR [eax+20], ebx
	mov	esi, eax
	jmp	SHORT $LN10@operator@2
$LN9@operator@2:
	xor	esi, esi
$LN10@operator@2:

; 629  : 		readFrom >> *pData;

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+4]
	push	ebp
	mov	ecx, esi
	call	edx

; 630  : 		writeTo.Load(pData);

	mov	eax, DWORD PTR [edi+24]
	cmp	eax, ebx
	je	SHORT $LN2@operator@2
	mov	ecx, DWORD PTR [esi+4]
	and	ecx, 8191				; 00001fffH
	mov	DWORD PTR [eax+ecx*8+4], esi
$LN2@operator@2:
	mov	eax, DWORD PTR _i$[esp+16]
	inc	eax
	cmp	eax, DWORD PTR _iCount$[esp+20]
	mov	DWORD PTR _i$[esp+16], eax
	jl	SHORT $LL3@operator@2
$LN56@operator@2:
	pop	edi
	pop	esi

; 631  : 	}
; 632  : 	return readFrom;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 633  : }

	pop	ecx
	ret	0
??$?5VCvLandmass@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvLandmass@@@@@Z ENDP ; operator>><CvLandmass>
_TEXT	ENDS
PUBLIC	??$?6$$CBE@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@$$CBE@@@Z ; operator<<<unsigned char const >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6$$CBE@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@$$CBE@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6$$CBE@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@$$CBE@@@Z PROC ; operator<<<unsigned char const >, COMDAT

; 503  : 	int i = 0;
; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	ebx

; 505  : 	const ValueType * values = v.getArray();

	mov	ebx, DWORD PTR [eax]
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 506  : 	for(i = 0; i < count; ++i)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN14@operator@3
	push	ebp
	mov	ebp, DWORD PTR _saveTo$[esp+12]
$LL3@operator@3:

; 507  : 	{
; 508  : 		saveTo << values[i];

	lea	eax, DWORD PTR [ebx+esi]
	push	eax
	mov	ecx, ebp
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL3@operator@3

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, ebp
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 511  : }

	ret	0
$LN14@operator@3:

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[esp+8]
	pop	edi
	pop	esi
	pop	ebx

; 511  : }

	ret	0
??$?6$$CBE@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@$$CBE@@@Z ENDP ; operator<<<unsigned char const >
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>, COMDAT

; 559  : {

	push	ebx

; 560  : 	kStream << uiArraySize;

	mov	ebx, DWORD PTR _kStream$[esp]
	push	esi
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe
	push	edi
	mov	edi, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	ebx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	push	edi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN3@WriteHashe:
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe
	pop	edi
$LN2@WriteHashe:
	pop	esi
	pop	ebx

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>
_TEXT	ENDS
PUBLIC	??$?6VCvArea@@@@YAAAVFDataStream@@AAV0@ABV?$FFreeListTrashArray@VCvArea@@@@@Z ; operator<<<CvArea>
EXTRN	??6@YAAAVFDataStream@@AAV0@ABVCvArea@@@Z:PROC	; operator<<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
;	COMDAT ??$?6VCvArea@@@@YAAAVFDataStream@@AAV0@ABV?$FFreeListTrashArray@VCvArea@@@@@Z
_TEXT	SEGMENT
_writeTo$ = 8						; size = 4
$T239936 = 12						; size = 4
$T239935 = 12						; size = 4
$T239934 = 12						; size = 4
$T239933 = 12						; size = 4
$T239932 = 12						; size = 4
$T239931 = 12						; size = 4
$T239930 = 12						; size = 4
_readFrom$ = 12						; size = 4
??$?6VCvArea@@@@YAAAVFDataStream@@AAV0@ABV?$FFreeListTrashArray@VCvArea@@@@@Z PROC ; operator<<<CvArea>, COMDAT

; 573  : {

	push	ebx
	push	esi

; 574  : 	writeTo << readFrom.GetNumSlots();

	mov	esi, DWORD PTR _readFrom$[esp+4]
	mov	eax, DWORD PTR [esi+16]
	push	edi
	mov	edi, DWORD PTR _writeTo$[esp+8]
	lea	ecx, DWORD PTR $T239930[esp+8]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T239930[esp+12], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 575  : 	writeTo << readFrom.GetLastIndex();

	mov	edx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR $T239931[esp+8]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T239931[esp+12], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 576  : 	writeTo << readFrom.GetFreeListHead();

	mov	ecx, DWORD PTR [esi+4]
	lea	edx, DWORD PTR $T239932[esp+8]
	mov	DWORD PTR $T239932[esp+8], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 577  : 	writeTo << readFrom.GetFreeListCount();

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR $T239933[esp+8]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T239933[esp+12], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 578  : 	writeTo << readFrom.GetCurrentID();

	mov	edx, DWORD PTR [esi+20]
	lea	eax, DWORD PTR $T239934[esp+8]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T239934[esp+12], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 579  : 
; 580  : 	int i;
; 581  : 
; 582  : 	for ( i = 0; i < readFrom.GetNumSlots(); i++ )

	mov	eax, DWORD PTR [esi+16]
	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN5@operator@4

; 583  : 	{
; 584  : 		writeTo << readFrom.GetNextFreeIndex( i );

	cmp	ebx, eax
	jge	SHORT $LN32@operator@4
$LN56@operator@4:
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN32@operator@4
	mov	eax, DWORD PTR [eax+ebx*8]
	jmp	SHORT $LN34@operator@4
$LN32@operator@4:
	or	eax, -1
$LN34@operator@4:
	lea	ecx, DWORD PTR $T239935[esp+8]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T239935[esp+12], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	mov	eax, DWORD PTR [esi+16]
	inc	ebx
	cmp	ebx, eax
	jl	SHORT $LN56@operator@4
$LN5@operator@4:

; 585  : 	}
; 586  : 
; 587  : 	writeTo << readFrom.GetCount();

	mov	edx, DWORD PTR [esi+12]
	sub	edx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR $T239936[esp+8]
	inc	edx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T239936[esp+12], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 588  : 
; 589  : 	for ( i = 0; i < readFrom.GetIndexAfterLast(); i++ )

	mov	ecx, DWORD PTR [esi+12]
	inc	ecx
	xor	ebx, ebx
	test	ecx, ecx
	jle	SHORT $LN54@operator@4
	npad	1
$LL4@operator@4:

; 590  : 	{
; 591  : 		if ( readFrom[ i ] )

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+12]
	push	ebx
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN3@operator@4

; 592  : 		{
; 593  : 			const T & entry = *(readFrom[i]);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+12]
	push	ebx
	mov	ecx, esi
	call	eax

; 594  : 			writeTo << entry;

	push	eax
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABVCvArea@@@Z ; operator<<
	add	esp, 8
$LN3@operator@4:
	mov	ecx, DWORD PTR [esi+12]
	inc	ebx
	inc	ecx
	cmp	ebx, ecx
	jl	SHORT $LL4@operator@4
$LN54@operator@4:

; 595  : 		}
; 596  : 	}
; 597  : 	return writeTo;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 598  : }

	ret	0
??$?6VCvArea@@@@YAAAVFDataStream@@AAV0@ABV?$FFreeListTrashArray@VCvArea@@@@@Z ENDP ; operator<<<CvArea>
_TEXT	ENDS
PUBLIC	??$?6VCvLandmass@@@@YAAAVFDataStream@@AAV0@ABV?$FFreeListTrashArray@VCvLandmass@@@@@Z ; operator<<<CvLandmass>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6VCvLandmass@@@@YAAAVFDataStream@@AAV0@ABV?$FFreeListTrashArray@VCvLandmass@@@@@Z
_TEXT	SEGMENT
_writeTo$ = 8						; size = 4
$T240022 = 12						; size = 4
$T240021 = 12						; size = 4
$T240020 = 12						; size = 4
$T240019 = 12						; size = 4
$T240018 = 12						; size = 4
$T240017 = 12						; size = 4
$T240016 = 12						; size = 4
_readFrom$ = 12						; size = 4
??$?6VCvLandmass@@@@YAAAVFDataStream@@AAV0@ABV?$FFreeListTrashArray@VCvLandmass@@@@@Z PROC ; operator<<<CvLandmass>, COMDAT

; 573  : {

	push	ebx
	push	esi

; 574  : 	writeTo << readFrom.GetNumSlots();

	mov	esi, DWORD PTR _readFrom$[esp+4]
	mov	eax, DWORD PTR [esi+16]
	push	edi
	mov	edi, DWORD PTR _writeTo$[esp+8]
	lea	ecx, DWORD PTR $T240016[esp+8]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T240016[esp+12], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 575  : 	writeTo << readFrom.GetLastIndex();

	mov	edx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR $T240017[esp+8]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T240017[esp+12], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 576  : 	writeTo << readFrom.GetFreeListHead();

	mov	ecx, DWORD PTR [esi+4]
	lea	edx, DWORD PTR $T240018[esp+8]
	mov	DWORD PTR $T240018[esp+8], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 577  : 	writeTo << readFrom.GetFreeListCount();

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR $T240019[esp+8]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T240019[esp+12], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 578  : 	writeTo << readFrom.GetCurrentID();

	mov	edx, DWORD PTR [esi+20]
	lea	eax, DWORD PTR $T240020[esp+8]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T240020[esp+12], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 579  : 
; 580  : 	int i;
; 581  : 
; 582  : 	for ( i = 0; i < readFrom.GetNumSlots(); i++ )

	mov	eax, DWORD PTR [esi+16]
	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN5@operator@5

; 583  : 	{
; 584  : 		writeTo << readFrom.GetNextFreeIndex( i );

	cmp	ebx, eax
	jge	SHORT $LN32@operator@5
$LN58@operator@5:
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN32@operator@5
	mov	eax, DWORD PTR [eax+ebx*8]
	jmp	SHORT $LN34@operator@5
$LN32@operator@5:
	or	eax, -1
$LN34@operator@5:
	lea	ecx, DWORD PTR $T240021[esp+8]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T240021[esp+12], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	mov	eax, DWORD PTR [esi+16]
	inc	ebx
	cmp	ebx, eax
	jl	SHORT $LN58@operator@5
$LN5@operator@5:

; 585  : 	}
; 586  : 
; 587  : 	writeTo << readFrom.GetCount();

	mov	edx, DWORD PTR [esi+12]
	sub	edx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR $T240022[esp+8]
	inc	edx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T240022[esp+12], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 588  : 
; 589  : 	for ( i = 0; i < readFrom.GetIndexAfterLast(); i++ )

	mov	ecx, DWORD PTR [esi+12]
	inc	ecx
	xor	ebx, ebx
	test	ecx, ecx
	jle	SHORT $LN56@operator@5
	npad	1
$LL4@operator@5:

; 590  : 	{
; 591  : 		if ( readFrom[ i ] )

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+12]
	push	ebx
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN3@operator@5

; 592  : 		{
; 593  : 			const T & entry = *(readFrom[i]);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+12]
	push	ebx
	mov	ecx, esi
	call	eax

; 594  : 			writeTo << entry;

	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+8]
	push	edi
	call	eax
$LN3@operator@5:
	mov	ecx, DWORD PTR [esi+12]
	inc	ebx
	inc	ecx
	cmp	ebx, ecx
	jl	SHORT $LL4@operator@5
$LN56@operator@5:

; 595  : 		}
; 596  : 	}
; 597  : 	return writeTo;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 598  : }

	ret	0
??$?6VCvLandmass@@@@YAAAVFDataStream@@AAV0@ABV?$FFreeListTrashArray@VCvLandmass@@@@@Z ENDP ; operator<<<CvLandmass>
_TEXT	ENDS
PUBLIC	?Load@?$FFreeListTrashArray@VCvArea@@@@QAEXPAVCvArea@@@Z ; FFreeListTrashArray<CvArea>::Load
; Function compile flags: /Ogtpy
;	COMDAT ?Load@?$FFreeListTrashArray@VCvArea@@@@QAEXPAVCvArea@@@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
?Load@?$FFreeListTrashArray@VCvArea@@@@QAEXPAVCvArea@@@Z PROC ; FFreeListTrashArray<CvArea>::Load, COMDAT
; _this$ = ecx

; 386  : 	assert(pData != NULL);
; 387  : 	assert(m_pArray != NULL);
; 388  : 	if (!pData || !m_pArray) return;

	mov	edx, DWORD PTR _pData$[esp-4]
	test	edx, edx
	je	SHORT $LN1@Load@2
	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	je	SHORT $LN1@Load@2

; 389  : 
; 390  : 	assert((pData->GetID() & FLTA_ID_MASK) < m_iCurrentID);
; 391  : 
; 392  : 	int iIndex = (pData->GetID() & FLTA_INDEX_MASK);

	mov	ecx, DWORD PTR [edx+4]
	and	ecx, 8191				; 00001fffH

; 393  : 
; 394  : 	assert(iIndex < FLTA_MAX_BUCKETS);
; 395  : 	assert(iIndex <= this->m_iLastIndex);
; 396  : 	assert(m_pArray[iIndex].pData == NULL);
; 397  : 	assert(m_pArray[iIndex].iNextFreeIndex == FFreeList::INVALID_INDEX);
; 398  : 
; 399  : 	m_pArray[iIndex].pData = pData;

	mov	DWORD PTR [eax+ecx*8+4], edx
$LN1@Load@2:

; 400  : }

	ret	4
?Load@?$FFreeListTrashArray@VCvArea@@@@QAEXPAVCvArea@@@Z ENDP ; FFreeListTrashArray<CvArea>::Load
_TEXT	ENDS
PUBLIC	?getX@CvUnit@@QBEHXZ				; CvUnit::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?getX@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getX@CvUnit@@QBEHXZ PROC				; CvUnit::getX, COMDAT
; _this$ = ecx

; 673  : 		return m_iX.get();

	mov	eax, DWORD PTR [ecx+76]

; 674  : 	}

	ret	0
?getX@CvUnit@@QBEHXZ ENDP				; CvUnit::getX
_TEXT	ENDS
PUBLIC	?getY@CvUnit@@QBEHXZ				; CvUnit::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getY@CvUnit@@QBEHXZ PROC				; CvUnit::getY, COMDAT
; _this$ = ecx

; 678  : 		return m_iY.get();

	mov	eax, DWORD PTR [ecx+88]

; 679  : 	}

	ret	0
?getY@CvUnit@@QBEHXZ ENDP				; CvUnit::getY
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1092 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1093 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?isEverAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isEverAlive
; Function compile flags: /Ogtpy
;	COMDAT ?isEverAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isEverAlive@CvPlayer@@QBE_NXZ PROC			; CvPlayer::isEverAlive, COMDAT
; _this$ = ecx

; 1097 : 		return m_bEverAlive;

	mov	al, BYTE PTR [ecx+2268]

; 1098 : 	}

	ret	0
?isEverAlive@CvPlayer@@QBE_NXZ ENDP			; CvPlayer::isEverAlive
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z	; CvMap::plotCheckInvalid
; Function compile flags: /Ogtpy
;	COMDAT ?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z PROC	; CvMap::plotCheckInvalid, COMDAT
; _this$ = ecx

; 282  : 	{

	push	esi

; 283  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	esi, DWORD PTR _iX$[esp]
	cmp	esi, -2147483647			; 80000001H
	je	SHORT $LN1@plotCheckI
	mov	edx, DWORD PTR _iY$[esp]
	cmp	edx, -2147483647			; 80000001H
	je	SHORT $LN1@plotCheckI

; 286  : 		}
; 287  : 		return &(m_pMapPlots[plotNum(iX, iY)]);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, edx
	add	eax, esi
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	pop	esi

; 288  : 	}

	ret	8
$LN1@plotCheckI:

; 284  : 		{
; 285  : 			return NULL;

	xor	eax, eax
	pop	esi

; 288  : 	}

	ret	8
?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z ENDP	; CvMap::plotCheckInvalid
_TEXT	ENDS
PUBLIC	?plotUnchecked@CvMap@@QBEPAVCvPlot@@HH@Z	; CvMap::plotUnchecked
; Function compile flags: /Ogtpy
;	COMDAT ?plotUnchecked@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotUnchecked@CvMap@@QBEPAVCvPlot@@HH@Z PROC		; CvMap::plotUnchecked, COMDAT
; _this$ = ecx

; 292  : 		return &(m_pMapPlots[plotNum(iX, iY)]);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 293  : 	}

	ret	8
?plotUnchecked@CvMap@@QBEPAVCvPlot@@HH@Z ENDP		; CvMap::plotUnchecked
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
_TEXT	ENDS
;	COMDAT ?Uninit@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ
_TEXT	SEGMENT
?Uninit@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ PROC	; FFreeListTrashArray<CvArea>::Uninit, COMDAT
; _this$ = ecx

; 192  : {

	push	esi
	mov	esi, ecx

; 193  : 	if (m_pArray != NULL)

	cmp	DWORD PTR [esi+24], 0
	je	SHORT $LN4@Uninit

; 194  : 	{
; 195  : 		RemoveAll();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+20]
	call	edx

; 196  : 
; 197  : 		SAFE_DELETE_ARRAY(m_pArray);

	mov	eax, DWORD PTR [esi+24]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+24], 0
$LN4@Uninit:
	pop	esi

; 198  : 	}
; 199  : }

	ret	0
?Uninit@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ ENDP	; FFreeListTrashArray<CvArea>::Uninit
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ PROC	; FFreeListTrashArray<CvArea>::RemoveAll, COMDAT
; _this$ = ecx

; 359  : {

	push	esi
	mov	esi, ecx

; 360  : 	int iI;
; 361  : 
; 362  : 	if (m_pArray == NULL)

	cmp	DWORD PTR [esi+24], 0
	je	SHORT $LN2@RemoveAll@2
	push	edi

; 363  : 	{
; 364  : 		return;
; 365  : 	}
; 366  : 
; 367  : 	this->m_iLastIndex = FFreeList::INVALID_INDEX;

	or	eax, -1

; 368  : 	this->m_iFreeListHead = FFreeList::INVALID_INDEX;
; 369  : 	this->m_iFreeListCount = 0;
; 370  : 
; 371  : 	for (iI = 0; iI < this->m_iNumSlots; iI++)

	xor	edi, edi
	cmp	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], 0
	jle	SHORT $LN16@RemoveAll@2
	push	ebx
$LL15@RemoveAll@2:

; 372  : 	{
; 373  : 		m_pArray[iI].iNextFreeIndex = FFreeList::INVALID_INDEX;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+edi*8], -1

; 374  : 		if (m_pArray[iI].pData != NULL)

	mov	ecx, DWORD PTR [esi+24]
	mov	ebx, DWORD PTR [ecx+edi*8+4]
	test	ebx, ebx
	je	SHORT $LN8@RemoveAll@2

; 375  : 		{
; 376  : 			delete m_pArray[iI].pData;

	mov	ecx, ebx
	call	??1CvArea@@QAE@XZ			; CvArea::~CvArea
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@RemoveAll@2:

; 377  : 		}
; 378  : 		m_pArray[iI].pData = NULL;

	mov	edx, DWORD PTR [esi+24]
	mov	DWORD PTR [edx+edi*8+4], 0
	inc	edi
	cmp	edi, DWORD PTR [esi+16]
	jl	SHORT $LL15@RemoveAll@2
	pop	ebx
$LN16@RemoveAll@2:
	pop	edi
$LN2@RemoveAll@2:
	pop	esi

; 379  : 	}
; 380  : }

	ret	0
?RemoveAll@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ ENDP	; FFreeListTrashArray<CvArea>::RemoveAll
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Uninit@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ
_TEXT	SEGMENT
?Uninit@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ PROC ; FFreeListTrashArray<CvLandmass>::Uninit, COMDAT
; _this$ = ecx

; 192  : {

	push	esi
	mov	esi, ecx

; 193  : 	if (m_pArray != NULL)

	cmp	DWORD PTR [esi+24], 0
	je	SHORT $LN4@Uninit@2

; 194  : 	{
; 195  : 		RemoveAll();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+20]
	call	edx

; 196  : 
; 197  : 		SAFE_DELETE_ARRAY(m_pArray);

	mov	eax, DWORD PTR [esi+24]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+24], 0
$LN4@Uninit@2:
	pop	esi

; 198  : 	}
; 199  : }

	ret	0
?Uninit@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ ENDP ; FFreeListTrashArray<CvLandmass>::Uninit
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 194  : 	if(eDirection == NO_DIRECTION)

	mov	ecx, DWORD PTR _eDirection$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	ecx, -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebx, DWORD PTR _iY$[esp+12]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN99@plotDirect
	test	eax, eax
	jge	SHORT $LN19@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@plotDirect
$LN19@plotDirect:
	cmp	eax, ecx
	jl	SHORT $LN99@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@plotDirect
$LN99@plotDirect:
	mov	esi, eax
$LN21@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN101@plotDirect
	test	ebx, ebx
	jge	SHORT $LN29@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@plotDirect
$LN29@plotDirect:
	cmp	ebx, edi
	jl	SHORT $LN101@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@plotDirect
$LN101@plotDirect:
	mov	edx, ebx
$LN31@plotDirect:
	test	esi, esi
	jl	$LN59@plotDirect
	cmp	esi, ecx
	jge	$LN59@plotDirect
	test	edx, edx
	jl	$LN59@plotDirect
	cmp	edx, edi
	jge	$LN59@plotDirect
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
$LN2@plotDirect:

; 197  : 	}
; 198  : 	else
; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	mov	esi, DWORD PTR _iY$[esp+12]
	test	esi, esi
	jl	SHORT $LN47@plotDirect
	mov	eax, esi
	jmp	SHORT $LN103@plotDirect
$LN47@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN103@plotDirect:

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	mov	edi, DWORD PTR _iX$[esp+12]
	sar	eax, 1
	sub	edx, eax
	add	edi, edx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN55@plotDirect
	mov	eax, esi
	jmp	SHORT $LN104@plotDirect
$LN55@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN104@plotDirect:
	sar	eax, 1
	add	edi, eax

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	cmp	edi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	cmp	esi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN69@plotDirect
	test	edi, edi
	jge	SHORT $LN71@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN69@plotDirect
$LN71@plotDirect:
	cmp	edi, ecx
	jl	SHORT $LN69@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN69@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN100@plotDirect
	test	esi, esi
	jge	SHORT $LN81@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN83@plotDirect
$LN81@plotDirect:
	cmp	esi, ebx
	jl	SHORT $LN100@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN83@plotDirect
$LN100@plotDirect:
	mov	edx, esi
$LN83@plotDirect:
	test	edi, edi
	jl	SHORT $LN59@plotDirect
	cmp	edi, ecx
	jge	SHORT $LN59@plotDirect
	test	edx, edx
	jl	SHORT $LN59@plotDirect
	cmp	edx, ebx
	jge	SHORT $LN59@plotDirect
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

$LN59@plotDirect:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Ogtpy
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jl	SHORT $LN5@plotXY
	mov	eax, ecx
	jmp	SHORT $LN55@plotXY
$LN5@plotXY:
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
$LN55@plotXY:
	push	esi

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	esi, DWORD PTR _iX$[esp]
	sar	eax, 1
	sub	esi, eax

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iDY$[esp]
	add	esi, DWORD PTR _iDX$[esp]
	push	edi
	lea	edi, DWORD PTR [ecx+eax]

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	test	edi, edi
	jl	SHORT $LN9@plotXY
	mov	eax, edi
	jmp	SHORT $LN56@plotXY
$LN9@plotXY:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN56@plotXY:
	sar	eax, 1
	add	esi, eax

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	cmp	esi, -2147483647			; 80000001H
	je	$LN13@plotXY
	cmp	edi, -2147483647			; 80000001H
	je	$LN13@plotXY
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN23@plotXY
	test	esi, esi
	jge	SHORT $LN25@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN23@plotXY
$LN25@plotXY:
	cmp	esi, ecx
	jl	SHORT $LN23@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN23@plotXY:
	cmp	BYTE PTR [ebp+4057], 0
	push	ebx
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN52@plotXY
	test	edi, edi
	jge	SHORT $LN35@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN37@plotXY
$LN35@plotXY:
	cmp	edi, ebx
	jl	SHORT $LN52@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	jmp	SHORT $LN37@plotXY
$LN52@plotXY:
	mov	edx, edi
$LN37@plotXY:
	test	esi, esi
	jl	SHORT $LN17@plotXY
	cmp	esi, ecx
	jge	SHORT $LN17@plotXY
	test	edx, edx
	jl	SHORT $LN17@plotXY
	cmp	edx, ebx
	jge	SHORT $LN17@plotXY
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	ebx
	pop	ebp
	pop	edi
	mov	eax, ecx
	pop	esi

; 224  : }

	ret	0

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN17@plotXY:
	pop	ebx
	pop	ebp
	pop	edi
	xor	eax, eax
	pop	esi

; 224  : }

	ret	0

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN13@plotXY:
	pop	edi
	xor	eax, eax
	pop	esi

; 224  : }

	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
; Function compile flags: /Ogtpy
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iDX$[esp-4]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR _iDY$[esp]
	test	esi, esi
	setge	cl
	cmp	eax, ecx

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	mov	ecx, edx
	jne	SHORT $LN3@plotXYWith
	test	edx, edx
	jge	SHORT $LN7@plotXYWith
	neg	ecx
$LN7@plotXYWith:

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN9@plotXYWith
	neg	eax
$LN9@plotXYWith:

; 245  : 		hexRange = iAbsDX + iAbsDY;

	add	eax, ecx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN14@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	edx, edx
	jge	SHORT $LN11@plotXYWith
	neg	ecx
$LN11@plotXYWith:

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN13@plotXYWith
	neg	eax
$LN13@plotXYWith:

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	cmp	ecx, eax
	jl	SHORT $LN14@plotXYWith
	mov	eax, ecx
$LN14@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	cmp	eax, DWORD PTR _iRange$[esp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	pop	esi

; 261  : }

	ret	0
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	eax, DWORD PTR _iX$[esp]
	push	esi
	push	edx
	mov	edx, DWORD PTR _iY$[esp+8]
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
	pop	esi

; 261  : }

	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
_TEXT	ENDS
PUBLIC	?changeNumTiles@CvLandmass@@QAEXH@Z		; CvLandmass::changeNumTiles
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.cpp
;	COMDAT ?changeNumTiles@CvLandmass@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeNumTiles@CvLandmass@@QAEXH@Z PROC		; CvLandmass::changeNumTiles, COMDAT
; _this$ = ecx

; 85   : {

	push	esi

; 86   : 	if(iChange != 0)

	mov	esi, DWORD PTR _iChange$[esp]
	test	esi, esi
	je	SHORT $LN1@changeNumT

; 87   : 	{
; 88   : 		bool bOldLake = isLake();

	mov	al, BYTE PTR [ecx+13]
	test	al, al
	je	SHORT $LN7@changeNumT
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6508
	jg	SHORT $LN7@changeNumT
	mov	dl, 1
	jmp	SHORT $LN8@changeNumT
$LN7@changeNumT:
	xor	dl, dl
$LN8@changeNumT:

; 89   : 
; 90   : 		m_iNumTiles = (m_iNumTiles + iChange);

	add	DWORD PTR [ecx+8], esi
	mov	ecx, DWORD PTR [ecx+8]

; 91   : 		CvAssert(m_iNumTiles >= 0);
; 92   : 
; 93   : 		if(bOldLake != isLake())

	test	al, al
	je	SHORT $LN13@changeNumT
	cmp	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6508
	jg	SHORT $LN13@changeNumT
	mov	eax, 1
	jmp	SHORT $LN14@changeNumT
$LN13@changeNumT:
	xor	eax, eax
$LN14@changeNumT:
	cmp	dl, al
	je	SHORT $LN1@changeNumT

; 94   : 		{
; 95   : 			GC.getMap().updateYield();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?updateYield@CvMap@@QAEXXZ		; CvMap::updateYield
$LN1@changeNumT:
	pop	esi

; 96   : 		}
; 97   : 	}
; 98   : }

	ret	4
?changeNumTiles@CvLandmass@@QAEXH@Z ENDP		; CvLandmass::changeNumTiles
_TEXT	ENDS
PUBLIC	?reset@CvMap@@QAEXPAUCvMapInitData@@@Z		; CvMap::reset
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	__imp__CoCreateGuid@4:PROC
EXTRN	?getGridHeight@CvWorldInfo@@QBEHXZ:PROC		; CvWorldInfo::getGridHeight
EXTRN	?getGridWidth@CvWorldInfo@@QBEHXZ:PROC		; CvWorldInfo::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?reset@CvMap@@QAEXPAUCvMapInitData@@@Z
_TEXT	SEGMENT
$T240739 = 8						; size = 4
$T240738 = 8						; size = 4
$T240737 = 8						; size = 4
$T240736 = 8						; size = 4
_pInitInfo$ = 8						; size = 4
?reset@CvMap@@QAEXPAUCvMapInitData@@@Z PROC		; CvMap::reset, COMDAT
; _this$ = ecx

; 440  : {

	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 441  : 	//--------------------------------
; 442  : 	// Uninit class
; 443  : 	uninit();

	call	?uninit@CvMap@@QAEXXZ			; CvMap::uninit

; 444  : 
; 445  : 	m_iAIMapHints = 0;

	xor	ebx, ebx
	mov	DWORD PTR [esi+4052], ebx

; 446  : 	//
; 447  : 	// set grid size
; 448  : 	// initially set in terrain cell units
; 449  : 	//
; 450  : 	m_iGridWidth = (CvPreGame::worldSize() != NO_WORLDSIZE) ?  getWorldInfo().getGridWidth(): 0;	//todotw:tcells wide

	call	?worldSize@CvPreGame@@YA?AW4WorldSizeTypes@@XZ ; CvPreGame::worldSize
	cmp	eax, -1
	je	SHORT $LN10@reset
	call	?worldInfo@CvPreGame@@YAABVCvWorldInfo@@XZ ; CvPreGame::worldInfo
	mov	ecx, eax
	call	?getGridWidth@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getGridWidth
	jmp	SHORT $LN11@reset
$LN10@reset:
	xor	eax, eax
$LN11@reset:
	mov	DWORD PTR [esi+4020], eax

; 451  : 	m_iGridHeight = (CvPreGame::worldSize() != NO_WORLDSIZE) ? getWorldInfo().getGridHeight(): 0;

	call	?worldSize@CvPreGame@@YA?AW4WorldSizeTypes@@XZ ; CvPreGame::worldSize
	cmp	eax, -1
	je	SHORT $LN12@reset
	call	?worldInfo@CvPreGame@@YAABVCvWorldInfo@@XZ ; CvPreGame::worldInfo
	mov	ecx, eax
	call	?getGridHeight@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getGridHeight
	jmp	SHORT $LN13@reset
$LN12@reset:
	xor	eax, eax
$LN13@reset:

; 452  : 
; 453  : 	// allow grid size override
; 454  : 	if(pInitInfo)

	mov	edi, DWORD PTR _pInitInfo$[esp+8]
	mov	DWORD PTR [esi+4024], eax
	cmp	edi, ebx
	je	SHORT $LN7@reset

; 455  : 	{
; 456  : 		m_iGridWidth	= pInitInfo->m_iGridW;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi+4020], eax

; 457  : 		m_iGridHeight	= pInitInfo->m_iGridH;

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4024], ecx
$LN7@reset:

; 458  : 	}
; 459  : 
; 460  : 	m_iGridSize = m_iGridHeight * m_iGridWidth;

	mov	edx, DWORD PTR [esi+4020]
	imul	edx, DWORD PTR [esi+4024]
	mov	DWORD PTR [esi+4028], edx

; 461  : 	m_iLandPlots = 0;

	mov	DWORD PTR [esi+4032], ebx

; 462  : 	m_iOwnedPlots = 0;

	mov	DWORD PTR [esi+4036], ebx

; 463  : 	m_iNumNaturalWonders = 0;

	mov	DWORD PTR [esi+4048], ebx

; 464  : 
; 465  : 	if(pInitInfo)

	cmp	edi, ebx
	je	SHORT $LN6@reset

; 466  : 	{
; 467  : 		m_iTopLatitude = pInitInfo->m_iTopLatitude;

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+4040], eax

; 468  : 		m_iBottomLatitude = pInitInfo->m_iBottomLatitude;

	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+4044], ecx
$LN6@reset:

; 469  : 	}
; 470  : 
; 471  : 	m_iTopLatitude = std::min(m_iTopLatitude, 90);

	mov	edx, 90					; 0000005aH
	cmp	DWORD PTR [esi+4040], edx
	lea	eax, DWORD PTR [esi+4040]
	mov	DWORD PTR $T240736[esp+8], edx
	lea	ecx, DWORD PTR $T240736[esp+8]
	jg	SHORT $LN21@reset
	mov	ecx, eax
$LN21@reset:
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 472  : 	m_iTopLatitude = std::max(m_iTopLatitude, -90);

	cmp	ecx, -90				; ffffffa6H
	mov	DWORD PTR $T240737[esp+8], -90		; ffffffa6H
	lea	ecx, DWORD PTR $T240737[esp+8]
	jl	SHORT $LN25@reset
	mov	ecx, eax
$LN25@reset:
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 473  : 	m_iBottomLatitude = std::min(m_iBottomLatitude, 90);

	cmp	DWORD PTR [esi+4044], edx
	lea	eax, DWORD PTR [esi+4044]
	mov	DWORD PTR $T240738[esp+8], edx
	lea	ecx, DWORD PTR $T240738[esp+8]
	jg	SHORT $LN29@reset
	mov	ecx, eax
$LN29@reset:
	mov	edx, DWORD PTR [ecx]

; 474  : 	m_iBottomLatitude = std::max(m_iBottomLatitude, -90);

	cmp	edx, -90				; ffffffa6H
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR $T240739[esp+8], -90		; ffffffa6H
	lea	ecx, DWORD PTR $T240739[esp+8]
	jl	SHORT $LN33@reset
	mov	ecx, eax
$LN33@reset:
	mov	ecx, DWORD PTR [ecx]

; 475  : 
; 476  : 	//
; 477  : 	// set wrapping
; 478  : 	//
; 479  : 	m_bWrapX = true;
; 480  : 	m_bWrapY = false;
; 481  : 
; 482  : 	CoCreateGuid(&m_guid);

	lea	edx, DWORD PTR [esi+4168]
	push	edx
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [esi+4056], 1
	mov	BYTE PTR [esi+4057], bl
	call	DWORD PTR __imp__CoCreateGuid@4

; 483  : 
; 484  : 	if(pInitInfo)

	cmp	edi, ebx
	je	SHORT $LN5@reset

; 485  : 	{
; 486  : 		m_bWrapX = pInitInfo->m_bWrapX;

	mov	al, BYTE PTR [edi+16]
	mov	BYTE PTR [esi+4056], al

; 487  : 		m_bWrapY = pInitInfo->m_bWrapY;

	mov	cl, BYTE PTR [edi+17]
	mov	BYTE PTR [esi+4057], cl
$LN5@reset:

; 488  : 	}
; 489  : 
; 490  : #ifdef AUI_MAP_FIX_CALCULATE_INFLUENCE_DISTANCE_REUSE_PATHFINDER
; 491  : 	m_pLastInfluenceSourcePlot = NULL;
; 492  : #endif
; 493  : 
; 494  : 	int iNumResourceInfos = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	edi, eax

; 495  : 	if(iNumResourceInfos)

	cmp	edi, ebx
	je	SHORT $LN1@reset

; 496  : 	{
; 497  : 		CvAssertMsg((0 < GC.getNumResourceInfos()), "GC.getNumResourceInfos() is not greater than zero but an array is being allocated in CvMap::reset");
; 498  : 		CvAssertMsg(m_paiNumResource==NULL, "mem leak m_paiNumResource");
; 499  : 		m_paiNumResource = FNEW(int[iNumResourceInfos], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+4060], eax

; 500  : 		CvAssertMsg(m_paiNumResourceOnLand==NULL, "mem leak m_paiNumResourceOnLand");
; 501  : 		m_paiNumResourceOnLand = FNEW(int[iNumResourceInfos], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+4064], eax
	add	esp, 8

; 502  : 		for(int iI = 0; iI < iNumResourceInfos; iI++)

	xor	eax, eax
	cmp	edi, ebx
	jle	SHORT $LN1@reset
	npad	12
$LL3@reset:

; 503  : 		{
; 504  : 			m_paiNumResource[iI] = 0;

	mov	ecx, DWORD PTR [esi+4060]
	mov	DWORD PTR [ecx+eax*4], ebx

; 505  : 			m_paiNumResourceOnLand[iI] = 0;

	mov	edx, DWORD PTR [esi+4064]
	mov	DWORD PTR [edx+eax*4], ebx
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL3@reset
$LN1@reset:

; 506  : 		}
; 507  : 	}
; 508  : 
; 509  : 	m_areas.RemoveAll();

	mov	eax, DWORD PTR [esi+4112]
	mov	edx, DWORD PTR [eax+20]
	lea	ecx, DWORD PTR [esi+4112]
	call	edx

; 510  : 	m_landmasses.RemoveAll();

	mov	eax, DWORD PTR [esi+4140]
	mov	edx, DWORD PTR [eax+20]
	lea	ecx, DWORD PTR [esi+4140]
	call	edx

; 511  : 
; 512  : 	m_vDeferredFogPlots.clear();

	mov	DWORD PTR [esi+8], ebx

; 513  : 
; 514  : 	gDLL->DoMapSetup(numPlots());

	mov	edx, DWORD PTR [esi+4028]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR _pInitInfo$[esp-4], edx
	mov	eax, DWORD PTR [eax+20]
	jmp	eax
?reset@CvMap@@QAEXPAUCvMapInitData@@@Z ENDP		; CvMap::reset
_TEXT	ENDS
PUBLIC	?updateDeferredFog@CvMap@@QAEXXZ		; CvMap::updateDeferredFog
; Function compile flags: /Ogtpy
;	COMDAT ?updateDeferredFog@CvMap@@QAEXXZ
_TEXT	SEGMENT
?updateDeferredFog@CvMap@@QAEXXZ PROC			; CvMap::updateDeferredFog, COMDAT
; _this$ = ecx

; 660  : {

	push	esi
	push	edi
	mov	edi, ecx

; 661  : 	for(uint uiI=0; uiI < m_vDeferredFogPlots.size(); uiI++)

	xor	esi, esi
	cmp	DWORD PTR [edi+8], esi
	jbe	SHORT $LN20@updateDefe
	npad	5
$LL3@updateDefe:

; 662  : 	{
; 663  : 		m_vDeferredFogPlots[uiI]->updateFog();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax+esi*4]
	push	0
	call	?updateFog@CvPlot@@QAEX_N@Z		; CvPlot::updateFog
	inc	esi
	cmp	esi, DWORD PTR [edi+8]
	jb	SHORT $LL3@updateDefe

; 664  : 	}
; 665  : 	m_vDeferredFogPlots.clear();

	mov	DWORD PTR [edi+8], 0
	pop	edi
	pop	esi

; 666  : }

	ret	0
$LN20@updateDefe:

; 664  : 	}
; 665  : 	m_vDeferredFogPlots.clear();

	mov	DWORD PTR [edi+8], esi
	pop	edi
	pop	esi

; 666  : }

	ret	0
?updateDeferredFog@CvMap@@QAEXXZ ENDP			; CvMap::updateDeferredFog
_TEXT	ENDS
PUBLIC	?updateWorkingCity@CvMap@@QAEXPAVCvPlot@@H@Z	; CvMap::updateWorkingCity
EXTRN	?updateWorkingCity@CvPlot@@QAEXXZ:PROC		; CvPlot::updateWorkingCity
; Function compile flags: /Ogtpy
;	COMDAT ?updateWorkingCity@CvMap@@QAEXPAVCvPlot@@H@Z
_TEXT	SEGMENT
tv166 = -8						; size = 4
tv162 = -4						; size = 4
_pPlot$ = 8						; size = 4
tv253 = 12						; size = 4
_iRange$ = 12						; size = 4
?updateWorkingCity@CvMap@@QAEXPAVCvPlot@@H@Z PROC	; CvMap::updateWorkingCity, COMDAT
; _this$ = ecx

; 749  : {

	sub	esp, 8

; 750  : 	if(pPlot && iRange > 0)

	cmp	DWORD PTR _pPlot$[esp+4], 0
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx
	je	$LN12@updateWork
	mov	ebp, DWORD PTR _iRange$[esp+20]
	test	ebp, ebp
	jle	$LN12@updateWork

; 751  : 	{
; 752  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 753  : 		int iMaxDX, iDX;
; 754  : 		CvPlot* pLoopPlot;
; 755  : 		for (int iDY = -iRange; iDY <= iRange; iDY++)
; 756  : 		{
; 757  : 			iMaxDX = iRange - MAX(0, iDY);
; 758  : 			for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 759  : 			{
; 760  : 				// No need for range check because loops are set up properly
; 761  : 				pLoopPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);
; 762  : #else
; 763  : 		for(int iX = -iRange; iX <= iRange; iX++)

	mov	esi, ebp
	neg	esi
	mov	edi, esi
	cmp	edi, ebp
	mov	DWORD PTR tv162[esp+24], esi
	jg	$LN1@updateWork
	mov	edx, edi
	neg	edx
	mov	DWORD PTR tv253[esp+20], edx
	npad	6
$LL46@updateWork:

; 764  : 		{
; 765  : 			for(int iY = -iRange; iY <= iRange; iY++)

	cmp	esi, ebp
	jg	SHORT $LN10@updateWork

; 766  : 			{
; 767  : 				CvPlot* pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iX, iY, iRange);

	xor	eax, eax
	test	edi, edi
	setge	al
	mov	ebx, esi
	neg	ebx
	mov	DWORD PTR tv166[esp+24], eax
$LL45@updateWork:
	xor	ecx, ecx
	test	esi, esi
	setge	cl
	cmp	DWORD PTR tv166[esp+24], ecx
	mov	ecx, edi
	jne	SHORT $LN21@updateWork
	test	edi, edi
	jge	SHORT $LN25@updateWork
	mov	ecx, edx
$LN25@updateWork:
	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN27@updateWork
	mov	eax, ebx
$LN27@updateWork:
	add	eax, ecx
	jmp	SHORT $LN32@updateWork
$LN21@updateWork:
	test	edi, edi
	jge	SHORT $LN29@updateWork
	mov	ecx, edx
$LN29@updateWork:
	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN31@updateWork
	mov	eax, ebx
$LN31@updateWork:
	cmp	ecx, eax
	jl	SHORT $LN32@updateWork
	mov	eax, ecx
$LN32@updateWork:
	cmp	eax, ebp
	jg	SHORT $LN7@updateWork
	mov	eax, DWORD PTR _pPlot$[esp+20]
	movsx	edx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	esi
	push	edi
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H

; 768  : #endif
; 769  : 				if(pLoopPlot)

	test	eax, eax
	je	SHORT $LN44@updateWork

; 770  : 				{
; 771  : 					pLoopPlot->updateWorkingCity();

	mov	ecx, eax
	call	?updateWorkingCity@CvPlot@@QAEXXZ	; CvPlot::updateWorkingCity
$LN44@updateWork:
	mov	edx, DWORD PTR tv253[esp+20]
$LN7@updateWork:

; 764  : 		{
; 765  : 			for(int iY = -iRange; iY <= iRange; iY++)

	inc	esi
	dec	ebx
	cmp	esi, ebp
	jle	SHORT $LL45@updateWork
	mov	esi, DWORD PTR tv162[esp+24]
$LN10@updateWork:

; 751  : 	{
; 752  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 753  : 		int iMaxDX, iDX;
; 754  : 		CvPlot* pLoopPlot;
; 755  : 		for (int iDY = -iRange; iDY <= iRange; iDY++)
; 756  : 		{
; 757  : 			iMaxDX = iRange - MAX(0, iDY);
; 758  : 			for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 759  : 			{
; 760  : 				// No need for range check because loops are set up properly
; 761  : 				pLoopPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);
; 762  : #else
; 763  : 		for(int iX = -iRange; iX <= iRange; iX++)

	inc	edi
	dec	edx
	cmp	edi, ebp
	mov	DWORD PTR tv253[esp+20], edx
	jle	$LL46@updateWork
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 785  : 		}
; 786  : 	}
; 787  : }

	add	esp, 8
	ret	8
$LN12@updateWork:

; 772  : 				}
; 773  : 			}
; 774  : 		}
; 775  : 	}
; 776  : 	else
; 777  : 	{
; 778  : #ifdef AUI_WARNING_FIXES
; 779  : 		for (uint iI = 0; iI < numPlots(); iI++)
; 780  : #else
; 781  : 		for(int iI = 0; iI < numPlots(); iI++)

	xor	edi, edi
	cmp	DWORD PTR [esi+4028], edi
	jle	SHORT $LN1@updateWork
	xor	ebx, ebx
$LL3@updateWork:

; 782  : #endif
; 783  : 		{
; 784  : 			plotByIndexUnchecked(iI)->updateWorkingCity();

	mov	ecx, DWORD PTR [esi+4068]
	add	ecx, ebx
	call	?updateWorkingCity@CvPlot@@QAEXXZ	; CvPlot::updateWorkingCity
	inc	edi
	add	ebx, 484				; 000001e4H
	cmp	edi, DWORD PTR [esi+4028]
	jl	SHORT $LL3@updateWork
$LN1@updateWork:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 785  : 		}
; 786  : 	}
; 787  : }

	add	esp, 8
	ret	8
?updateWorkingCity@CvMap@@QAEXPAVCvPlot@@H@Z ENDP	; CvMap::updateWorkingCity
_TEXT	ENDS
PUBLIC	?syncRandPlot@CvMap@@QAEPAVCvPlot@@HHHH@Z	; CvMap::syncRandPlot
EXTRN	?isVisibleToCivTeam@CvPlot@@QBE_NXZ:PROC	; CvPlot::isVisibleToCivTeam
EXTRN	?isAdjacentOwned@CvPlot@@QBE_NXZ:PROC		; CvPlot::isAdjacentOwned
EXTRN	?isOwned@CvPlot@@QBE_NXZ:PROC			; CvPlot::isOwned
EXTRN	?isUnit@CvPlot@@QBE_NXZ:PROC			; CvPlot::isUnit
; Function compile flags: /Ogtpy
;	COMDAT ?syncRandPlot@CvMap@@QAEPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
_bValid$ = -21						; size = 1
tv531 = -20						; size = 4
_iCount$ = -16						; size = 4
_this$ = -12						; size = 4
tv317 = -8						; size = 4
tv541 = -4						; size = 4
_iFlags$ = 8						; size = 4
_iArea$ = 12						; size = 4
_iMinUnitDistance$ = 16					; size = 4
_iTimeout$ = 20						; size = 4
?syncRandPlot@CvMap@@QAEPAVCvPlot@@HHHH@Z PROC		; CvMap::syncRandPlot, COMDAT
; _this$ = ecx

; 846  : {

	sub	esp, 24					; 00000018H

; 847  : 	CvPlot* pPlot;
; 848  : 	CvPlot* pTestPlot;
; 849  : 	CvPlot* pLoopPlot;
; 850  : 	bool bValid;
; 851  : 	int iCount;
; 852  : 	int iDX, iDY;
; 853  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 854  : 	int iMaxDX;
; 855  : #endif
; 856  : 
; 857  : 	pPlot = NULL;

	xor	eax, eax

; 858  : 
; 859  : 	iCount = 0;
; 860  : 
; 861  : 	while(iCount < iTimeout)

	cmp	DWORD PTR _iTimeout$[esp+20], eax
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _this$[esp+28], ebx
	mov	DWORD PTR _iCount$[esp+28], eax
	jle	$LN36@syncRandPl
	push	ebp
	push	esi
	push	edi
	npad	3
$LL37@syncRandPl:

; 862  : 	{
; 863  : 		iCount++;
; 864  : 		pTestPlot = plotCheckInvalid(GC.getGame().getJonRandNum(getGridWidth(), "Rand Plot Width"), GC.getGame().getJonRandNum(getGridHeight(), "Rand Plot Height"));

	mov	eax, DWORD PTR [ebx+4024]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	inc	DWORD PTR _iCount$[esp+40]
	mov	esi, DWORD PTR [ebx+4020]
	push	OFFSET $SG236028
	push	eax
	mov	edi, ecx
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	push	OFFSET $SG236029
	push	esi
	mov	ecx, edi
	mov	ebp, eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@syncRandPl
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@syncRandPl
	mov	ebx, DWORD PTR [ebx+4020]
	imul	ebx, ebp
	add	ebx, eax
	mov	eax, DWORD PTR _this$[esp+40]
	imul	ebx, 484				; 000001e4H
	add	ebx, DWORD PTR [eax+4068]

; 865  : 
; 866  : 		CvAssertMsg(pTestPlot != NULL, "TestPlot is not assigned a valid value");
; 867  : 
; 868  : 		if(!pTestPlot) continue;

	je	$LN98@syncRandPl

; 869  : 
; 870  : 		if((iArea == -1) || (pTestPlot->getArea() == iArea))

	mov	eax, DWORD PTR _iArea$[esp+36]
	cmp	eax, -1
	je	SHORT $LN33@syncRandPl
	cmp	DWORD PTR [ebx+356], eax
	jne	$LN98@syncRandPl
$LN33@syncRandPl:

; 871  : 		{
; 872  : 			bValid = true;
; 873  : 
; 874  : 			if(bValid)
; 875  : 			{
; 876  : 				if(iMinUnitDistance != -1)

	mov	edx, DWORD PTR _iMinUnitDistance$[esp+36]
	mov	BYTE PTR _bValid$[esp+40], 1
	cmp	edx, -1
	je	$LN93@syncRandPl

; 877  : 				{
; 878  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 879  : 					for (iDY = -iMinUnitDistance; iDY <= iMinUnitDistance; iDY++)
; 880  : 					{
; 881  : 						iMaxDX = iMinUnitDistance - MAX(0, iDY);
; 882  : 						for (iDX = -iMinUnitDistance - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 883  : 						{
; 884  : 							// No need for range check because loops are set up properly
; 885  : 							pLoopPlot = plotXY(pTestPlot->getX(), pTestPlot->getY(), iDX, iDY);
; 886  : #else
; 887  : 					for(iDX = -(iMinUnitDistance); iDX <= iMinUnitDistance; iDX++)

	mov	esi, edx
	neg	esi
	mov	edi, esi
	cmp	edi, edx
	mov	DWORD PTR tv541[esp+40], esi
	jg	$LN93@syncRandPl
	mov	eax, edi
	neg	eax
	mov	DWORD PTR tv531[esp+40], eax
	npad	5
$LL30@syncRandPl:

; 888  : 					{
; 889  : 						for(iDY = -(iMinUnitDistance); iDY <= iMinUnitDistance; iDY++)

	cmp	esi, edx
	jg	$LN29@syncRandPl

; 890  : 						{
; 891  : 							pLoopPlot	= plotXYWithRangeCheck(pTestPlot->getX(), pTestPlot->getY(), iDX, iDY, iMinUnitDistance);

	xor	ecx, ecx
	test	edi, edi
	setge	cl
	mov	ebp, esi
	neg	ebp
	mov	DWORD PTR tv317[esp+40], ecx
$LL99@syncRandPl:
	xor	eax, eax
	test	esi, esi
	setge	al
	mov	ecx, edi
	cmp	DWORD PTR tv317[esp+40], eax
	jne	SHORT $LN64@syncRandPl
	test	edi, edi
	jge	SHORT $LN68@syncRandPl
	mov	ecx, DWORD PTR tv531[esp+40]
$LN68@syncRandPl:
	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN70@syncRandPl
	mov	eax, ebp
$LN70@syncRandPl:
	add	eax, ecx
	jmp	SHORT $LN75@syncRandPl
$LN64@syncRandPl:
	test	edi, edi
	jge	SHORT $LN72@syncRandPl
	mov	ecx, DWORD PTR tv531[esp+40]
$LN72@syncRandPl:
	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN74@syncRandPl
	mov	eax, ebp
$LN74@syncRandPl:
	cmp	ecx, eax
	jl	SHORT $LN75@syncRandPl
	mov	eax, ecx
$LN75@syncRandPl:
	cmp	eax, edx
	jg	SHORT $LN26@syncRandPl
	movsx	ecx, WORD PTR [ebx+2]
	movsx	edx, WORD PTR [ebx]
	push	esi
	push	edi
	push	ecx
	push	edx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H

; 892  : #endif
; 893  : 
; 894  : 							if(pLoopPlot != NULL)

	test	eax, eax
	je	SHORT $LN97@syncRandPl

; 895  : 							{
; 896  : 								if(pLoopPlot->isUnit())

	mov	ecx, eax
	call	?isUnit@CvPlot@@QBE_NXZ			; CvPlot::isUnit
	test	al, al
	je	SHORT $LN97@syncRandPl

; 897  : 								{
; 898  : 									bValid = false;

	mov	BYTE PTR _bValid$[esp+40], 0
$LN97@syncRandPl:
	mov	edx, DWORD PTR _iMinUnitDistance$[esp+36]
$LN26@syncRandPl:

; 888  : 					{
; 889  : 						for(iDY = -(iMinUnitDistance); iDY <= iMinUnitDistance; iDY++)

	inc	esi
	dec	ebp
	cmp	esi, edx
	jle	SHORT $LL99@syncRandPl
	mov	esi, DWORD PTR tv541[esp+40]
$LN29@syncRandPl:

; 877  : 				{
; 878  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 879  : 					for (iDY = -iMinUnitDistance; iDY <= iMinUnitDistance; iDY++)
; 880  : 					{
; 881  : 						iMaxDX = iMinUnitDistance - MAX(0, iDY);
; 882  : 						for (iDX = -iMinUnitDistance - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 883  : 						{
; 884  : 							// No need for range check because loops are set up properly
; 885  : 							pLoopPlot = plotXY(pTestPlot->getX(), pTestPlot->getY(), iDX, iDY);
; 886  : #else
; 887  : 					for(iDX = -(iMinUnitDistance); iDX <= iMinUnitDistance; iDX++)

	dec	DWORD PTR tv531[esp+40]
	inc	edi
	cmp	edi, edx
	jle	$LL30@syncRandPl

; 899  : 								}
; 900  : 							}
; 901  : 						}
; 902  : 					}
; 903  : 				}
; 904  : 			}
; 905  : 
; 906  : 			if(bValid)

	cmp	BYTE PTR _bValid$[esp+40], 0
	je	$LN98@syncRandPl
$LN93@syncRandPl:

; 907  : 			{
; 908  : 				if(iFlags & RANDPLOT_LAND)

	mov	al, BYTE PTR _iFlags$[esp+36]
	test	al, 1
	je	SHORT $LN20@syncRandPl

; 909  : 				{
; 910  : 					if(pTestPlot->isWater())

	cmp	BYTE PTR [ebx+5], 3

; 911  : 					{
; 912  : 						bValid = false;
; 913  : 					}
; 914  : 				}
; 915  : 			}
; 916  : 
; 917  : 			if(bValid)

	je	$LN98@syncRandPl
$LN20@syncRandPl:

; 918  : 			{
; 919  : 				if(iFlags & RANDPLOT_UNOWNED)

	test	al, 2
	je	SHORT $LN17@syncRandPl

; 920  : 				{
; 921  : 					if(pTestPlot->isOwned())

	mov	ecx, ebx
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	test	al, al
	jne	SHORT $LN98@syncRandPl
	mov	al, BYTE PTR _iFlags$[esp+36]
$LN17@syncRandPl:

; 922  : 					{
; 923  : 						bValid = false;
; 924  : 					}
; 925  : 				}
; 926  : 			}
; 927  : 
; 928  : 			if(bValid)
; 929  : 			{
; 930  : 				if(iFlags & RANDPLOT_ADJACENT_UNOWNED)

	test	al, 4
	je	SHORT $LN14@syncRandPl

; 931  : 				{
; 932  : 					if(pTestPlot->isAdjacentOwned())

	mov	ecx, ebx
	call	?isAdjacentOwned@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentOwned
	test	al, al
	jne	SHORT $LN98@syncRandPl
	mov	al, BYTE PTR _iFlags$[esp+36]
$LN14@syncRandPl:

; 933  : 					{
; 934  : 						bValid = false;
; 935  : 					}
; 936  : 				}
; 937  : 			}
; 938  : 
; 939  : 			if(bValid)
; 940  : 			{
; 941  : 				if(iFlags & RANDPLOT_ADJACENT_LAND)

	test	al, 8
	je	SHORT $LN11@syncRandPl

; 942  : 				{
; 943  : 					if(!(pTestPlot->isAdjacentToLand()))

	mov	ecx, ebx
	call	?isAdjacentToLand@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentToLand
	test	al, al
	je	SHORT $LN98@syncRandPl
	mov	al, BYTE PTR _iFlags$[esp+36]
$LN11@syncRandPl:

; 944  : 					{
; 945  : 						bValid = false;
; 946  : 					}
; 947  : 				}
; 948  : 			}
; 949  : 
; 950  : 			if(bValid)
; 951  : 			{
; 952  : 				if(iFlags & RANDPLOT_PASSIBLE)

	test	al, 16					; 00000010H
	je	SHORT $LN8@syncRandPl

; 953  : 				{
; 954  : 					if(pTestPlot->isImpassable())

	test	BYTE PTR [ebx+462], 128			; 00000080H

; 955  : 					{
; 956  : 						bValid = false;
; 957  : 					}
; 958  : 				}
; 959  : 			}
; 960  : 
; 961  : 			if(bValid)

	jne	SHORT $LN98@syncRandPl
$LN8@syncRandPl:

; 962  : 			{
; 963  : 				if(iFlags & RANDPLOT_NOT_VISIBLE_TO_CIV)

	test	al, 32					; 00000020H
	je	SHORT $LN5@syncRandPl

; 964  : 				{
; 965  : 					if(pTestPlot->isVisibleToCivTeam())

	mov	ecx, ebx
	call	?isVisibleToCivTeam@CvPlot@@QBE_NXZ	; CvPlot::isVisibleToCivTeam
	test	al, al
	jne	SHORT $LN98@syncRandPl
	mov	al, BYTE PTR _iFlags$[esp+36]
$LN5@syncRandPl:

; 966  : 					{
; 967  : 						bValid = false;
; 968  : 					}
; 969  : 				}
; 970  : 			}
; 971  : 
; 972  : 			if(bValid)
; 973  : 			{
; 974  : 				if(iFlags & RANDPLOT_NOT_CITY)

	test	al, 64					; 00000040H
	je	SHORT $LN90@syncRandPl

; 975  : 				{
; 976  : 					if(pTestPlot->isCity())

	mov	eax, DWORD PTR [ebx+104]
	test	eax, eax
	jl	SHORT $LN90@syncRandPl
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN90@syncRandPl
	mov	ecx, DWORD PTR [ebx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	SHORT $LN90@syncRandPl
$LN98@syncRandPl:
	mov	ebx, DWORD PTR _this$[esp+40]
$LN1@syncRandPl:

; 858  : 
; 859  : 	iCount = 0;
; 860  : 
; 861  : 	while(iCount < iTimeout)

	mov	edx, DWORD PTR _iTimeout$[esp+36]
	cmp	DWORD PTR _iCount$[esp+40], edx
	jl	$LL37@syncRandPl
	pop	edi
	pop	esi

; 977  : 					{
; 978  : 						bValid = false;
; 979  : 					}
; 980  : 				}
; 981  : 			}
; 982  : 
; 983  : 			if(bValid)
; 984  : 			{
; 985  : 				pPlot = pTestPlot;
; 986  : 				break;
; 987  : 			}
; 988  : 		}
; 989  : 	}
; 990  : 
; 991  : 	return pPlot;

	xor	eax, eax
	pop	ebp
$LN36@syncRandPl:
	pop	ebx

; 992  : }

	add	esp, 24					; 00000018H
	ret	16					; 00000010H
$LN90@syncRandPl:
	pop	edi
	pop	esi
	pop	ebp

; 977  : 					{
; 978  : 						bValid = false;
; 979  : 					}
; 980  : 				}
; 981  : 			}
; 982  : 
; 983  : 			if(bValid)
; 984  : 			{
; 985  : 				pPlot = pTestPlot;
; 986  : 				break;
; 987  : 			}
; 988  : 		}
; 989  : 	}
; 990  : 
; 991  : 	return pPlot;

	mov	eax, ebx
	pop	ebx

; 992  : }

	add	esp, 24					; 00000018H
	ret	16					; 00000010H
?syncRandPlot@CvMap@@QAEPAVCvPlot@@HHHH@Z ENDP		; CvMap::syncRandPlot
_TEXT	ENDS
PUBLIC	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ; CvMap::findCity
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?estimateDirection@@YA?AW4DirectionTypes@@HH@Z:PROC ; estimateDirection
EXTRN	?atWar@@YA_NW4TeamTypes@@0@Z:PROC		; atWar
EXTRN	?isCoastal@CvCity@@QBE_NH@Z:PROC		; CvCity::isCoastal
EXTRN	?waterArea@CvCity@@QBEPAVCvArea@@XZ:PROC	; CvCity::waterArea
EXTRN	?area@CvPlot@@QBEPAVCvArea@@XZ:PROC		; CvPlot::area
EXTRN	?area@CvCity@@QBEPAVCvArea@@XZ:PROC		; CvCity::area
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
; Function compile flags: /Ogtpy
;	COMDAT ?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z
_TEXT	SEGMENT
_pCheckPlot$ = -20					; size = 4
_iBestValue$ = -16					; size = 4
tv543 = -12						; size = 4
_pBestCity$ = -8					; size = 4
_iLoop$ = -4						; size = 4
_iX$ = 8						; size = 4
_iI$ = 12						; size = 4
_iY$ = 12						; size = 4
_eOwner$ = 16						; size = 4
_eTeam$ = 20						; size = 4
_bSameArea$ = 24					; size = 1
_bCoastalOnly$ = 28					; size = 1
_eTeamAtWarWith$ = 32					; size = 4
_eDirection$ = 36					; size = 4
_pSkipCity$ = 40					; size = 4
?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z PROC ; CvMap::findCity, COMDAT
; _this$ = ecx

; 997  : 	CvCity* pLoopCity;
; 998  : 	CvCity* pBestCity;
; 999  : 	int iValue;
; 1000 : 	int iBestValue;
; 1001 : 	int iLoop;
; 1002 : 	int iI;
; 1003 : 	CvPlot* pCheckPlot = plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp-4]
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	eax, -2147483647			; 80000001H
	je	$LN128@findCity
	mov	ebp, DWORD PTR _iY$[esp+32]
	cmp	ebp, -2147483647			; 80000001H
	je	SHORT $LN128@findCity
	cmp	BYTE PTR [ecx+4056], 0
	mov	esi, DWORD PTR [ecx+4020]
	je	SHORT $LN130@findCity
	test	eax, eax
	jge	SHORT $LN38@findCity
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN40@findCity
$LN38@findCity:
	cmp	eax, esi
	jl	SHORT $LN130@findCity
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN40@findCity
$LN130@findCity:
	mov	edi, eax
$LN40@findCity:
	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN131@findCity
	test	ebp, ebp
	jge	SHORT $LN48@findCity
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN50@findCity
$LN48@findCity:
	cmp	ebp, ebx
	jl	SHORT $LN131@findCity
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN50@findCity
$LN131@findCity:
	mov	edx, ebp
$LN50@findCity:
	xor	eax, eax
	cmp	edi, eax
	jl	SHORT $LN128@findCity
	cmp	edi, esi
	jge	SHORT $LN128@findCity
	cmp	edx, eax
	jl	SHORT $LN128@findCity
	cmp	edx, ebx
	jge	SHORT $LN128@findCity
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pCheckPlot$[esp+36], esi

; 1004 : 
; 1005 : 	CvAssertMsg(pCheckPlot != NULL, "Passed in an invalid plot to findCity");
; 1006 : 	if (pCheckPlot == NULL)

	cmp	esi, eax
	jne	SHORT $LN23@findCity
$LN128@findCity:
	pop	edi
	pop	esi
	pop	ebp

; 1007 : 		return NULL;

	xor	eax, eax
	pop	ebx

; 1054 : }

	add	esp, 20					; 00000014H
	ret	36					; 00000024H
$LN23@findCity:

; 1008 : 
; 1009 : 	// XXX look for barbarian cities???
; 1010 : 
; 1011 : 	iBestValue = MAXINT;

	xor	edi, edi
	mov	DWORD PTR _iBestValue$[esp+36], 2147483647 ; 7fffffffH

; 1012 : 	pBestCity = NULL;

	mov	DWORD PTR _pBestCity$[esp+36], eax

; 1013 : 
; 1014 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[esp+32], eax
	mov	DWORD PTR tv543[esp+36], edi
	npad	15
$LL22@findCity:

; 1015 : 	{
; 1016 : 		CvPlayer& thisPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 1017 : 		if(thisPlayer.isAlive())

	cmp	BYTE PTR [edi+eax+2256], 0
	lea	ebx, DWORD PTR [edi+eax]
	je	$LN21@findCity

; 1018 : 		{
; 1019 : 			if((eOwner == NO_PLAYER) || (iI == eOwner))

	mov	eax, DWORD PTR _eOwner$[esp+32]
	cmp	eax, -1
	je	SHORT $LN17@findCity
	cmp	DWORD PTR _iI$[esp+32], eax
	jne	$LN21@findCity
$LN17@findCity:

; 1020 : 			{
; 1021 : 				if((eTeam == NO_TEAM) || (thisPlayer.getTeam() == eTeam))

	mov	ecx, DWORD PTR _eTeam$[esp+32]
	cmp	ecx, -1
	je	SHORT $LN15@findCity
	mov	eax, DWORD PTR [ebx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN74@findCity
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN75@findCity
$LN74@findCity:
	or	eax, -1
$LN75@findCity:
	cmp	eax, ecx
	jne	$LN21@findCity
$LN15@findCity:

; 1022 : 				{
; 1023 : 					for(pLoopCity = thisPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = thisPlayer.nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[esp+40]
	push	eax
	mov	ecx, ebx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	$LN21@findCity
	npad	5
$LL135@findCity:

; 1024 : 					{
; 1025 : 						if(!bSameArea || (pLoopCity->area() == pCheckPlot->area()) || (bCoastalOnly && (pLoopCity->waterArea() == pCheckPlot->area())))

	cmp	BYTE PTR _bSameArea$[esp+32], 0
	je	SHORT $LN132@findCity
	mov	ecx, esi
	call	?area@CvCity@@QBEPAVCvArea@@XZ		; CvCity::area
	mov	ecx, DWORD PTR _pCheckPlot$[esp+36]
	mov	edi, eax
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	cmp	edi, eax
	je	SHORT $LN132@findCity
	cmp	BYTE PTR _bCoastalOnly$[esp+32], 0
	je	$LN13@findCity
	mov	ecx, esi
	call	?waterArea@CvCity@@QBEPAVCvArea@@XZ	; CvCity::waterArea
	mov	ecx, DWORD PTR _pCheckPlot$[esp+36]
	mov	edi, eax
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	cmp	edi, eax
	jne	$LN13@findCity
$LN132@findCity:

; 1026 : 						{
; 1027 : 							if(!bCoastalOnly || pLoopCity->isCoastal())

	cmp	BYTE PTR _bCoastalOnly$[esp+32], 0
	je	SHORT $LN136@findCity
	push	-1
	mov	ecx, esi
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	$LN13@findCity
$LN136@findCity:

; 1028 : 							{
; 1029 : 								if((eTeamAtWarWith == NO_TEAM) || atWar(thisPlayer.getTeam(), eTeamAtWarWith))

	mov	eax, DWORD PTR _eTeamAtWarWith$[esp+32]
	cmp	eax, -1
	je	SHORT $LN6@findCity
	push	eax
	mov	ecx, ebx
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al
	je	$LN13@findCity
$LN6@findCity:

; 1030 : 								{
; 1031 : 									if((eDirection == NO_DIRECTION) || (estimateDirection(dxWrap(pLoopCity->getX() - iX), dyWrap(pLoopCity->getY() - iY)) == eDirection))

	cmp	DWORD PTR _eDirection$[esp+32], -1
	je	SHORT $LN4@findCity
	mov	eax, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	edi, DWORD PTR [ecx+4024]
	sub	eax, ebp
	cmp	BYTE PTR [ecx+4057], 0
	je	SHORT $LN91@findCity
	mov	edx, edi
	shr	edx, 1
	cmp	eax, edx
	jle	SHORT $LN93@findCity
	sub	eax, edi
$LN91@findCity:
	mov	edi, eax
$LN95@findCity:
	mov	eax, DWORD PTR [esi+96]
	sub	eax, DWORD PTR _iX$[esp+32]
	cmp	BYTE PTR [ecx+4056], 0
	mov	edx, DWORD PTR [ecx+4020]
	je	SHORT $LN109@findCity
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN111@findCity
	sub	eax, edx
	jmp	SHORT $LN109@findCity
$LN93@findCity:
	neg	edx
	cmp	eax, edx
	jge	SHORT $LN91@findCity
	add	edi, eax
	jmp	SHORT $LN95@findCity
$LN111@findCity:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN109@findCity
	add	eax, edx
$LN109@findCity:
	push	edi
	push	eax
	call	?estimateDirection@@YA?AW4DirectionTypes@@HH@Z ; estimateDirection
	add	esp, 8
	cmp	eax, DWORD PTR _eDirection$[esp+32]
	jne	SHORT $LN13@findCity
$LN4@findCity:

; 1032 : 									{
; 1033 : 										if((pSkipCity == NULL) || (pLoopCity != pSkipCity))

	mov	eax, DWORD PTR _pSkipCity$[esp+32]
	test	eax, eax
	je	SHORT $LN2@findCity
	cmp	esi, eax
	je	SHORT $LN13@findCity
$LN2@findCity:

; 1034 : 										{
; 1035 : 											iValue = plotDistance(iX, iY, pLoopCity->getX(), pLoopCity->getY());

	mov	ecx, DWORD PTR [esi+108]
	mov	edx, DWORD PTR [esi+96]
	mov	eax, DWORD PTR _iX$[esp+32]
	push	ecx
	push	edx
	push	ebp
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 1036 : 
; 1037 : 											if(iValue < iBestValue)

	cmp	eax, DWORD PTR _iBestValue$[esp+36]
	jge	SHORT $LN13@findCity

; 1038 : 											{
; 1039 : 												iBestValue = iValue;

	mov	DWORD PTR _iBestValue$[esp+36], eax

; 1040 : 												pBestCity = pLoopCity;

	mov	DWORD PTR _pBestCity$[esp+36], esi
$LN13@findCity:
	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+40]
	push	ecx
	mov	ecx, ebx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	$LL135@findCity

; 1022 : 				{
; 1023 : 					for(pLoopCity = thisPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = thisPlayer.nextCity(&iLoop))

	mov	edi, DWORD PTR tv543[esp+36]
$LN21@findCity:

; 1013 : 
; 1014 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	inc	DWORD PTR _iI$[esp+32]
	add	edi, 63236				; 0000f704H
	cmp	edi, 4047104				; 003dc100H
	mov	DWORD PTR tv543[esp+36], edi
	jl	$LL22@findCity

; 1041 : 											}
; 1042 : 										}
; 1043 : 									}
; 1044 : 								}
; 1045 : 							}
; 1046 : 						}
; 1047 : 					}
; 1048 : 				}
; 1049 : 			}
; 1050 : 		}
; 1051 : 	}
; 1052 : 
; 1053 : 	return pBestCity;

	mov	eax, DWORD PTR _pBestCity$[esp+36]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1054 : }

	add	esp, 20					; 00000014H
	ret	36					; 00000024H
?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ENDP ; CvMap::findCity
_TEXT	ENDS
PUBLIC	?findUnit@CvMap@@QAEPAVCvUnit@@HHW4PlayerTypes@@_N1@Z ; CvMap::findUnit
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
EXTRN	?ReadyToSelect@CvUnit@@QBE_NXZ:PROC		; CvUnit::ReadyToSelect
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
; Function compile flags: /Ogtpy
;	COMDAT ?findUnit@CvMap@@QAEPAVCvUnit@@HHW4PlayerTypes@@_N1@Z
_TEXT	SEGMENT
_iI$ = -12						; size = 4
_pBestUnit$ = -8					; size = 4
_iLoop$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eOwner$ = 16						; size = 4
_bReadyToSelect$ = 20					; size = 1
_bWorkers$ = 24						; size = 1
?findUnit@CvMap@@QAEPAVCvUnit@@HHW4PlayerTypes@@_N1@Z PROC ; CvMap::findUnit, COMDAT
; _this$ = ecx

; 1059 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp

; 1060 : 	CvUnit* pLoopUnit;
; 1061 : 	CvUnit* pBestUnit;
; 1062 : 	int iValue;
; 1063 : 	int iBestValue;
; 1064 : 	int iLoop;
; 1065 : 	int iI;
; 1066 : 
; 1067 : 	iBestValue = INT_MAX;
; 1068 : 	pBestUnit = NULL;

	xor	ebx, ebx
	push	esi
	push	edi
	mov	ebp, 2147483647				; 7fffffffH
	mov	DWORD PTR _pBestUnit$[esp+28], ebx

; 1069 : 
; 1070 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[esp+28], ebx
	npad	10
$LL36@findUnit:

; 1071 : 	{
; 1072 : 		CvPlayer& thisPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 1073 : 		if(thisPlayer.isAlive())

	cmp	BYTE PTR [ebx+eax+2256], 0
	lea	edi, DWORD PTR [ebx+eax]
	je	$LN13@findUnit

; 1074 : 		{
; 1075 : 			if((eOwner == NO_PLAYER) || (iI == eOwner))

	mov	eax, DWORD PTR _eOwner$[esp+24]
	cmp	eax, -1
	je	SHORT $LN9@findUnit
	cmp	DWORD PTR _iI$[esp+28], eax
	jne	$LN13@findUnit
$LN9@findUnit:

; 1076 : 			{
; 1077 : 				for(pLoopUnit = thisPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = thisPlayer.nextUnit(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+32]
	push	ecx
	mov	ecx, edi
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN13@findUnit
	npad	3
$LL8@findUnit:

; 1078 : 				{
; 1079 : 					if(!bReadyToSelect || pLoopUnit->ReadyToSelect())

	cmp	BYTE PTR _bReadyToSelect$[esp+24], 0
	je	SHORT $LN4@findUnit
	mov	ecx, esi
	call	?ReadyToSelect@CvUnit@@QBE_NXZ		; CvUnit::ReadyToSelect
	test	al, al
	je	SHORT $LN7@findUnit
$LN4@findUnit:

; 1080 : 					{
; 1081 : 						if(!bWorkers || pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER || pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER_SEA)

	cmp	BYTE PTR _bWorkers$[esp+24], 0
	je	SHORT $LN2@findUnit
	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 2
	je	SHORT $LN2@findUnit
	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 17					; 00000011H
	jne	SHORT $LN7@findUnit
$LN2@findUnit:

; 1082 : 						{
; 1083 : 							iValue = plotDistance(iX, iY, pLoopUnit->getX(), pLoopUnit->getY());

	mov	edx, DWORD PTR [esi+88]
	mov	eax, DWORD PTR [esi+76]
	mov	ecx, DWORD PTR _iY$[esp+24]
	push	edx
	mov	edx, DWORD PTR _iX$[esp+28]
	push	eax
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 1084 : 
; 1085 : 							if(iValue < iBestValue)

	cmp	eax, ebp
	jge	SHORT $LN7@findUnit

; 1086 : 							{
; 1087 : 								iBestValue = iValue;

	mov	ebp, eax

; 1088 : 								pBestUnit = pLoopUnit;

	mov	DWORD PTR _pBestUnit$[esp+28], esi
$LN7@findUnit:
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+32]
	push	eax
	mov	ecx, edi
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL8@findUnit
$LN13@findUnit:

; 1069 : 
; 1070 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	inc	DWORD PTR _iI$[esp+28]
	add	ebx, 63236				; 0000f704H
	cmp	ebx, 4047104				; 003dc100H
	jl	$LL36@findUnit

; 1089 : 							}
; 1090 : 						}
; 1091 : 					}
; 1092 : 				}
; 1093 : 			}
; 1094 : 		}
; 1095 : 	}
; 1096 : 
; 1097 : 	return pBestUnit;

	mov	eax, DWORD PTR _pBestUnit$[esp+28]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1098 : }

	add	esp, 12					; 0000000cH
	ret	20					; 00000014H
?findUnit@CvMap@@QAEPAVCvUnit@@HHW4PlayerTypes@@_N1@Z ENDP ; CvMap::findUnit
_TEXT	ENDS
PUBLIC	?findNearestStartPlot@CvMap@@QAEPAVCvPlot@@HHAAW4PlayerTypes@@@Z ; CvMap::findNearestStartPlot
EXTRN	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ:PROC ; CvPlayer::getStartingPlot
; Function compile flags: /Ogtpy
;	COMDAT ?findNearestStartPlot@CvMap@@QAEPAVCvPlot@@HHAAW4PlayerTypes@@@Z
_TEXT	SEGMENT
_pBestStartPlot$ = -4					; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eOwner$ = 16						; size = 4
?findNearestStartPlot@CvMap@@QAEPAVCvPlot@@HHAAW4PlayerTypes@@@Z PROC ; CvMap::findNearestStartPlot, COMDAT
; _this$ = ecx

; 1103 : {

	push	ecx

; 1104 : 	eOwner = NO_PLAYER;

	mov	eax, DWORD PTR _eOwner$[esp]
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1105 : 	int iValue;
; 1106 : 	int iBestValue;
; 1107 : 	int iI;
; 1108 : 	CvPlot* pBestStartPlot = 0;

	xor	edi, edi
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR _pBestStartPlot$[esp+20], edi

; 1109 : 
; 1110 : 	iBestValue = INT_MAX;

	mov	ebp, 2147483647				; 7fffffffH

; 1111 : 
; 1112 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	xor	ebx, ebx
	npad	4
$LL6@findNeares:

; 1113 : 	{
; 1114 : 		CvPlayer& thisPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, edi

; 1115 : 		if(thisPlayer.isEverAlive())

	cmp	BYTE PTR [ecx+2268], 0
	je	SHORT $LN5@findNeares

; 1116 : 		{
; 1117 : 			CvPlot* pStartPlot = thisPlayer.getStartingPlot();

	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	mov	esi, eax

; 1118 : 			if (pStartPlot)

	test	esi, esi
	je	SHORT $LN5@findNeares

; 1119 : 			{
; 1120 : 				iValue = plotDistance(iX, iY, pStartPlot->getX(), pStartPlot->getY());

	movsx	edx, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	mov	ecx, DWORD PTR _iY$[esp+16]
	push	edx
	mov	edx, DWORD PTR _iX$[esp+20]
	push	eax
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 1121 : 				if(iValue < iBestValue)

	cmp	eax, ebp
	jge	SHORT $LN5@findNeares

; 1122 : 				{
; 1123 : 					iBestValue = iValue;

	mov	ebp, eax

; 1124 : 					pBestStartPlot = pStartPlot;
; 1125 : 					eOwner = static_cast<PlayerTypes>(iI);

	mov	eax, DWORD PTR _eOwner$[esp+16]
	mov	DWORD PTR _pBestStartPlot$[esp+20], esi
	mov	DWORD PTR [eax], ebx
$LN5@findNeares:
	add	edi, 63236				; 0000f704H
	inc	ebx
	cmp	edi, 4047104				; 003dc100H
	jl	SHORT $LL6@findNeares

; 1126 : 				}
; 1127 : 			}
; 1128 : 		}
; 1129 : 	}
; 1130 : 	return pBestStartPlot;

	mov	eax, DWORD PTR _pBestStartPlot$[esp+20]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1131 : }

	pop	ecx
	ret	12					; 0000000cH
?findNearestStartPlot@CvMap@@QAEPAVCvPlot@@HHAAW4PlayerTypes@@@Z ENDP ; CvMap::findNearestStartPlot
_TEXT	ENDS
PUBLIC	?findWater@CvMap@@QAE_NPAVCvPlot@@H_N@Z		; CvMap::findWater
EXTRN	?isFreshWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::isFreshWater
; Function compile flags: /Ogtpy
;	COMDAT ?findWater@CvMap@@QAE_NPAVCvPlot@@H_N@Z
_TEXT	SEGMENT
_iPlotY$ = -12						; size = 4
_iPlotX$ = -8						; size = 4
tv167 = -4						; size = 4
tv270 = 8						; size = 4
_pPlot$ = 8						; size = 4
tv171 = 12						; size = 4
_iRange$ = 12						; size = 4
_bFreshWater$ = 16					; size = 1
?findWater@CvMap@@QAE_NPAVCvPlot@@H_N@Z PROC		; CvMap::findWater, COMDAT
; _this$ = ecx

; 1186 : {

	sub	esp, 12					; 0000000cH

; 1187 : 	CvPlot* pLoopPlot;
; 1188 : 	int iDX, iDY;
; 1189 : 	int iPlotX = pPlot->getX();

	mov	eax, DWORD PTR _pPlot$[esp+8]
	movsx	ecx, WORD PTR [eax]

; 1190 : 	int iPlotY = pPlot->getY();

	movsx	edx, WORD PTR [eax+2]
	push	ebx

; 1191 : 
; 1192 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 1193 : 	int iMaxDX;
; 1194 : 	for (iDY = -iRange; iDY <= iRange; iDY++)
; 1195 : 	{
; 1196 : 		iMaxDX = iRange - MAX(0, iDY);
; 1197 : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 1198 : 		{
; 1199 : 			// No need for range check because loops are set up properly
; 1200 : 			pLoopPlot = plotXY(iPlotX, iPlotY, iDX, iDY);
; 1201 : #else
; 1202 : 	for(iDX = -(iRange); iDX <= iRange; iDX++)

	mov	ebx, DWORD PTR _iRange$[esp+12]
	push	ebp
	push	esi
	mov	esi, ebx
	neg	esi
	push	edi
	mov	edi, esi
	cmp	edi, ebx
	mov	DWORD PTR _iPlotX$[esp+28], ecx
	mov	DWORD PTR _iPlotY$[esp+28], edx
	mov	DWORD PTR tv167[esp+28], esi
	jg	$LN9@findWater
	mov	edx, edi
	neg	edx
	mov	DWORD PTR tv270[esp+24], edx
$LL11@findWater:

; 1203 : 	{
; 1204 : 		for(iDY = -(iRange); iDY <= iRange; iDY++)

	cmp	esi, ebx
	jg	$LN10@findWater

; 1205 : 		{
; 1206 : 			pLoopPlot = plotXYWithRangeCheck(iPlotX, iPlotY, iDX, iDY, iRange);

	xor	eax, eax
	test	edi, edi
	setge	al
	mov	ebp, esi
	neg	ebp
	mov	DWORD PTR tv171[esp+24], eax
	npad	1
$LL42@findWater:
	xor	ecx, ecx
	test	esi, esi
	setge	cl
	cmp	DWORD PTR tv171[esp+24], ecx
	mov	ecx, edi
	jne	SHORT $LN20@findWater
	test	edi, edi
	jge	SHORT $LN24@findWater
	mov	ecx, edx
$LN24@findWater:
	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN26@findWater
	mov	eax, ebp
$LN26@findWater:
	add	eax, ecx
	jmp	SHORT $LN31@findWater
$LN20@findWater:
	test	edi, edi
	jge	SHORT $LN28@findWater
	mov	ecx, edx
$LN28@findWater:
	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN30@findWater
	mov	eax, ebp
$LN30@findWater:
	cmp	ecx, eax
	jl	SHORT $LN31@findWater
	mov	eax, ecx
$LN31@findWater:
	cmp	eax, ebx
	jg	SHORT $LN7@findWater
	mov	edx, DWORD PTR _iPlotY$[esp+28]
	mov	eax, DWORD PTR _iPlotX$[esp+28]
	push	esi
	push	edi
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H

; 1207 : #endif
; 1208 : 
; 1209 : 			if(pLoopPlot != NULL)

	test	eax, eax
	je	SHORT $LN41@findWater

; 1210 : 			{
; 1211 : 				if(bFreshWater)

	cmp	BYTE PTR _bFreshWater$[esp+24], 0
	je	SHORT $LN4@findWater

; 1212 : 				{
; 1213 : 					if(pLoopPlot->isFreshWater())

	mov	ecx, eax
	call	?isFreshWater@CvPlot@@QBE_NXZ		; CvPlot::isFreshWater
	test	al, al
	je	SHORT $LN41@findWater
$LN37@findWater:
	pop	edi
	pop	esi
	pop	ebp

; 1214 : 					{
; 1215 : 						return true;

	mov	al, 1
	pop	ebx

; 1230 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
$LN4@findWater:

; 1219 : 				{
; 1220 : 					if(pLoopPlot->isWater())

	cmp	BYTE PTR [eax+5], 3
	je	SHORT $LN37@findWater
$LN41@findWater:

; 1216 : 					}
; 1217 : 				}
; 1218 : 				else

	mov	edx, DWORD PTR tv270[esp+24]
$LN7@findWater:

; 1203 : 	{
; 1204 : 		for(iDY = -(iRange); iDY <= iRange; iDY++)

	inc	esi
	dec	ebp
	cmp	esi, ebx
	jle	SHORT $LL42@findWater
	mov	esi, DWORD PTR tv167[esp+28]
$LN10@findWater:

; 1191 : 
; 1192 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 1193 : 	int iMaxDX;
; 1194 : 	for (iDY = -iRange; iDY <= iRange; iDY++)
; 1195 : 	{
; 1196 : 		iMaxDX = iRange - MAX(0, iDY);
; 1197 : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 1198 : 		{
; 1199 : 			// No need for range check because loops are set up properly
; 1200 : 			pLoopPlot = plotXY(iPlotX, iPlotY, iDX, iDY);
; 1201 : #else
; 1202 : 	for(iDX = -(iRange); iDX <= iRange; iDX++)

	inc	edi
	dec	edx
	cmp	edi, ebx
	mov	DWORD PTR tv270[esp+24], edx
	jle	$LL11@findWater
$LN9@findWater:
	pop	edi
	pop	esi
	pop	ebp

; 1221 : 					{
; 1222 : 						return true;
; 1223 : 					}
; 1224 : 				}
; 1225 : 			}
; 1226 : 		}
; 1227 : 	}
; 1228 : 
; 1229 : 	return false;

	xor	al, al
	pop	ebx

; 1230 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
?findWater@CvMap@@QAE_NPAVCvPlot@@H_N@Z ENDP		; CvMap::findWater
_TEXT	ENDS
PUBLIC	?deleteArea@CvMap@@QAEXH@Z			; CvMap::deleteArea
; Function compile flags: /Ogtpy
;	COMDAT ?deleteArea@CvMap@@QAEXH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?deleteArea@CvMap@@QAEXH@Z PROC				; CvMap::deleteArea, COMDAT
; _this$ = ecx

; 1469 : 	m_areas.RemoveAt(iID);

	add	ecx, 4112				; 00001010H
	jmp	?RemoveAt@?$FFreeListTrashArray@VCvArea@@@@QAE_NH@Z ; FFreeListTrashArray<CvArea>::RemoveAt
?deleteArea@CvMap@@QAEXH@Z ENDP				; CvMap::deleteArea
_TEXT	ENDS
PUBLIC	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z		; CvMap::firstArea
; Function compile flags: /Ogtpy
;	COMDAT ?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z
_TEXT	SEGMENT
_pIterIdx$ = 8						; size = 4
_bRev$ = 12						; size = 1
?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z PROC		; CvMap::firstArea, COMDAT
; _this$ = ecx

; 1476 : 	return !bRev ? m_areas.BeginIter(pIterIdx) : m_areas.EndIter(pIterIdx);

	cmp	BYTE PTR _bRev$[esp-4], 0
	jne	SHORT $LN3@firstArea
	mov	eax, DWORD PTR _pIterIdx$[esp-4]
	push	eax
	add	ecx, 4112				; 00001010H
	call	?BeginIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ; FFreeListArrayBase<CvArea>::BeginIter

; 1477 : }

	ret	8
$LN3@firstArea:

; 1476 : 	return !bRev ? m_areas.BeginIter(pIterIdx) : m_areas.EndIter(pIterIdx);

	mov	eax, DWORD PTR [ecx+4124]
	push	esi
	mov	esi, DWORD PTR _pIterIdx$[esp]
	push	edi
	lea	edi, DWORD PTR [ecx+4112]
	mov	DWORD PTR [esi], eax
	test	eax, eax
	jl	SHORT $LN10@firstArea
$LL12@firstArea:
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+16]
	push	eax
	mov	ecx, edi
	call	edx
	dec	DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@firstArea
	cmp	DWORD PTR [esi], eax
	jge	SHORT $LL12@firstArea
$LN10@firstArea:
	xor	eax, eax
$LN13@firstArea:
	pop	edi
	pop	esi

; 1477 : }

	ret	8
?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z ENDP		; CvMap::firstArea
_TEXT	ENDS
PUBLIC	?Write@CvMap@@QBEXAAVFDataStream@@@Z		; CvMap::Write
EXTRN	?write@CvPlot@@QBEXAAVFDataStream@@@Z:PROC	; CvPlot::write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvMap@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -12					; size = 4
$T241440 = -8						; size = 8
_kStream$ = 8						; size = 4
?Write@CvMap@@QBEXAAVFDataStream@@@Z PROC		; CvMap::Write, COMDAT
; _this$ = ecx

; 1613 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi

; 1614 : 	// Current version number
; 1615 : 	uint uiVersion = 1;
; 1616 : 	kStream << uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+20]
	lea	eax, DWORD PTR _uiVersion$[esp+24]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+28], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 1617 : 
; 1618 : 	kStream << m_iGridWidth;

	lea	ecx, DWORD PTR [esi+4020]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1619 : 	kStream << m_iGridHeight;

	lea	edx, DWORD PTR [esi+4024]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1620 : 	kStream << m_iLandPlots;

	lea	eax, DWORD PTR [esi+4032]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1621 : 	kStream << m_iOwnedPlots;

	lea	ecx, DWORD PTR [esi+4036]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1622 : 	kStream << m_iNumNaturalWonders;

	lea	edx, DWORD PTR [esi+4048]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1623 : 	kStream << m_iTopLatitude;

	lea	eax, DWORD PTR [esi+4040]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1624 : 	kStream << m_iBottomLatitude;

	lea	ecx, DWORD PTR [esi+4044]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1625 : 	kStream << m_bWrapX;

	lea	edx, DWORD PTR [esi+4056]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 1626 : 	kStream << m_bWrapY;

	lea	eax, DWORD PTR [esi+4057]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 1627 : 
; 1628 : 	kStream << m_guid.Data1;

	lea	ecx, DWORD PTR [esi+4168]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABK@Z		; FDataStream::Write

; 1629 : 	kStream << m_guid.Data2;

	lea	edx, DWORD PTR [esi+4172]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABG@Z		; FDataStream::Write

; 1630 : 	kStream << m_guid.Data3;

	lea	eax, DWORD PTR [esi+4174]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABG@Z		; FDataStream::Write

; 1631 : 	kStream << ArrayWrapper<const unsigned char>(8, m_guid.Data4);

	lea	edx, DWORD PTR $T241440[esp+24]
	push	edx
	lea	ecx, DWORD PTR [esi+4176]
	push	edi
	mov	DWORD PTR $T241440[esp+32], ecx
	mov	DWORD PTR $T241440[esp+36], 8
	call	??$?6$$CBE@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@$$CBE@@@Z ; operator<<<unsigned char const >
	add	esp, 8

; 1632 : 
; 1633 : 	CvAssertMsg((0 < GC.getNumResourceInfos()), "GC.getNumResourceInfos() is not greater than zero but an array is being allocated");
; 1634 : 	CvInfosSerializationHelper::WriteHashedDataArray<ResourceTypes>(kStream, m_paiNumResource, GC.getNumResourceInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	push	eax
	mov	eax, DWORD PTR [esi+4060]
	push	eax
	push	edi
	call	??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>
	add	esp, 12					; 0000000cH

; 1635 : 	CvInfosSerializationHelper::WriteHashedDataArray<ResourceTypes>(kStream, m_paiNumResourceOnLand, GC.getNumResourceInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	ecx, DWORD PTR [esi+4064]
	push	eax
	push	ecx
	push	edi
	call	??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>

; 1636 : 
; 1637 : #ifdef AUI_WARNING_FIXES
; 1638 : 	for (uint iI = 0; iI < numPlots(); iI++)
; 1639 : #else
; 1640 : 	int iI;
; 1641 : 	for(iI = 0; iI < numPlots(); iI++)

	xor	ebx, ebx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+4028], ebx
	jle	SHORT $LN1@Write
	push	ebp
	xor	ebp, ebp
	npad	5
$LL3@Write:

; 1642 : #endif
; 1643 : 	{
; 1644 : 		m_pMapPlots[iI].write(kStream);

	mov	ecx, DWORD PTR [esi+4068]
	push	edi
	add	ecx, ebp
	call	?write@CvPlot@@QBEXAAVFDataStream@@@Z	; CvPlot::write
	inc	ebx
	add	ebp, 484				; 000001e4H
	cmp	ebx, DWORD PTR [esi+4028]
	jl	SHORT $LL3@Write
	pop	ebp
$LN1@Write:

; 1645 : 	}
; 1646 : 
; 1647 : 	// call the read of the free list CvArea class allocations
; 1648 : 	kStream << m_areas;

	lea	edx, DWORD PTR [esi+4112]
	push	edx
	push	edi
	call	??$?6VCvArea@@@@YAAAVFDataStream@@AAV0@ABV?$FFreeListTrashArray@VCvArea@@@@@Z ; operator<<<CvArea>

; 1649 : 
; 1650 : 	kStream << m_landmasses;

	lea	eax, DWORD PTR [esi+4140]
	push	eax
	push	edi
	call	??$?6VCvLandmass@@@@YAAAVFDataStream@@AAV0@ABV?$FFreeListTrashArray@VCvLandmass@@@@@Z ; operator<<<CvLandmass>
	add	esp, 16					; 00000010H

; 1651 : 
; 1652 : 	kStream << m_iAIMapHints;

	add	esi, 4052				; 00000fd4H
	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi
	pop	esi
	pop	ebx

; 1653 : 
; 1654 : }

	add	esp, 12					; 0000000cH
	ret	4
?Write@CvMap@@QBEXAAVFDataStream@@@Z ENDP		; CvMap::Write
_TEXT	ENDS
PUBLIC	?DoPlaceNaturalWonders@CvMap@@QAEXXZ		; CvMap::DoPlaceNaturalWonders
EXTRN	?isCoastalLand@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isCoastalLand
EXTRN	?getMapRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getMapRandNum
EXTRN	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z:PROC ; CvPlot::setTerrainType
EXTRN	?getNumTiles@CvArea@@QBEHXZ:PROC		; CvArea::getNumTiles
EXTRN	?isAdjacentToShallowWater@CvPlot@@QBE_NXZ:PROC	; CvPlot::isAdjacentToShallowWater
EXTRN	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z:PROC ; CvPlot::setFeatureType
EXTRN	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z:PROC ; CvPlot::setPlotType
EXTRN	?IsNaturalWonder@CvPlot@@QBE_NXZ:PROC		; CvPlot::IsNaturalWonder
EXTRN	?isStartingPlot@CvPlot@@QBE_NXZ:PROC		; CvPlot::isStartingPlot
EXTRN	?getLatitude@CvPlot@@QBEHXZ:PROC		; CvPlot::getLatitude
EXTRN	?GetNumNaturalWonders@CvArea@@QBEHXZ:PROC	; CvArea::GetNumNaturalWonders
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?GetAreaMinLatitude@CvArea@@QAEHXZ:PROC		; CvArea::GetAreaMinLatitude
EXTRN	?IsMountains@CvArea@@QBE_NXZ:PROC		; CvArea::IsMountains
EXTRN	?isWater@CvArea@@QBE_NXZ:PROC			; CvArea::isWater
EXTRN	?getNumNaturalWonders@CvWorldInfo@@QBEHXZ:PROC	; CvWorldInfo::getNumNaturalWonders
EXTRN	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::IsNaturalWonder
EXTRN	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z:PROC ; CvGlobals::getFeatureInfo
EXTRN	?getNumFeatureInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumFeatureInfos
; Function compile flags: /Ogtpy
;	COMDAT ?DoPlaceNaturalWonders@CvMap@@QAEXXZ
_TEXT	SEGMENT
_iNumNaturalWondersToAdd$ = -56				; size = 4
_featureReef$ = -52					; size = 4
tv1254 = -48						; size = 4
_iHillCount$236682 = -48				; size = 4
_featureLake$ = -44					; size = 4
_featureEverest$ = -40					; size = 4
_iCount$ = -36						; size = 4
_eNWFeature$ = -36					; size = 4
_this$ = -32						; size = 4
_featureVolcano$ = -28					; size = 4
_featureCrater$ = -24					; size = 4
_featureFuji$ = -20					; size = 4
_featureMesa$ = -16					; size = 4
_iMaxNWsOneArea$ = -12					; size = 4
_iNumFeatureInfos$ = -12				; size = 4
_iNumMapPlots$ = -8					; size = 4
tv952 = -4						; size = 4
?DoPlaceNaturalWonders@CvMap@@QAEXXZ PROC		; CvMap::DoPlaceNaturalWonders, COMDAT
; _this$ = ecx

; 1765 : {

	sub	esp, 56					; 00000038H

; 1766 : 	FeatureTypes eNWFeature = NO_FEATURE;

	or	eax, -1
	push	ebp
	push	edi
	mov	edi, ecx

; 1767 : 	FeatureTypes eFeature;
; 1768 : 
; 1769 : 	FeatureTypes featureFuji = NO_FEATURE;
; 1770 : 	FeatureTypes featureEverest = NO_FEATURE;
; 1771 : 	FeatureTypes featureReef = NO_FEATURE;
; 1772 : 	FeatureTypes featureCrater = NO_FEATURE;
; 1773 : 	FeatureTypes featureLake = NO_FEATURE;
; 1774 : 	FeatureTypes featureMesa = NO_FEATURE;
; 1775 : 	FeatureTypes featureVolcano = NO_FEATURE;
; 1776 : 
; 1777 : #ifdef AUI_WARNING_FIXES
; 1778 : 	int nwCount = 0;
; 1779 : 	for (uint iFeatureLoop = 0; iFeatureLoop < GC.getNumFeatureInfos(); iFeatureLoop++)
; 1780 : #else
; 1781 : 	int iNumFeatureInfos = GC.getNumFeatureInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+64], edi
	mov	DWORD PTR _eNWFeature$[esp+64], eax
	mov	DWORD PTR _featureFuji$[esp+64], eax
	mov	DWORD PTR _featureEverest$[esp+64], eax
	mov	DWORD PTR _featureReef$[esp+64], eax
	mov	DWORD PTR _featureCrater$[esp+64], eax
	mov	DWORD PTR _featureLake$[esp+64], eax
	mov	DWORD PTR _featureMesa$[esp+64], eax
	mov	DWORD PTR _featureVolcano$[esp+64], eax
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos

; 1782 : 	int nwCount = 0;
; 1783 : 	for(int iFeatureLoop = 0; iFeatureLoop < iNumFeatureInfos; iFeatureLoop++)

	xor	ebp, ebp
	mov	DWORD PTR _iNumFeatureInfos$[esp+64], eax
	test	eax, eax
	jle	$LN68@DoPlaceNat
	push	ebx
	push	esi
	npad	8
$LL336@DoPlaceNat:

; 1784 : #endif
; 1785 : 	{
; 1786 : 		eFeature = (FeatureTypes) iFeatureLoop;
; 1787 : 		CvFeatureInfo* feature = GC.getFeatureInfo(eFeature);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	esi, eax

; 1788 : 		if(feature && feature->IsNaturalWonder())

	test	esi, esi
	je	$LN93@DoPlaceNat
	mov	ecx, esi
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	test	al, al
	je	$LN93@DoPlaceNat

; 1789 : 		{
; 1790 : 			eNWFeature = eFeature;
; 1791 : 
; 1792 : 			// hackery - this should be more data driven but the engine side isn't
; 1793 : 
; 1794 : 			if(strcmp(feature->GetType(), "FEATURE_EVEREST") == 0)

	lea	ebx, DWORD PTR [esi+176]
	mov	ecx, ebx
	mov	DWORD PTR _eNWFeature$[esp+72], ebp
	mov	esi, OFFSET $SG236590
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	npad	5
$LL303@DoPlaceNat:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN304@DoPlaceNat
	test	cl, cl
	je	SHORT $LN305@DoPlaceNat
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN304@DoPlaceNat
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL303@DoPlaceNat
$LN305@DoPlaceNat:
	xor	eax, eax
	jmp	SHORT $LN306@DoPlaceNat
$LN304@DoPlaceNat:
	sbb	eax, eax
	sbb	eax, -1
$LN306@DoPlaceNat:
	test	eax, eax
	jne	SHORT $LN90@DoPlaceNat

; 1795 : 			{
; 1796 : 				featureEverest = eFeature;

	mov	DWORD PTR _featureEverest$[esp+72], ebp
	jmp	$LN93@DoPlaceNat
$LN90@DoPlaceNat:

; 1797 : 			}
; 1798 : 			else if(strcmp(feature->GetType(), "FEATURE_CRATER") == 0)

	mov	ecx, ebx
	mov	esi, OFFSET $SG236593
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	npad	1
$LL307@DoPlaceNat:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN308@DoPlaceNat
	test	cl, cl
	je	SHORT $LN309@DoPlaceNat
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN308@DoPlaceNat
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL307@DoPlaceNat
$LN309@DoPlaceNat:
	xor	eax, eax
	jmp	SHORT $LN310@DoPlaceNat
$LN308@DoPlaceNat:
	sbb	eax, eax
	sbb	eax, -1
$LN310@DoPlaceNat:
	test	eax, eax
	jne	SHORT $LN88@DoPlaceNat

; 1799 : 			{
; 1800 : 				featureCrater = eFeature;

	mov	DWORD PTR _featureCrater$[esp+72], ebp
	jmp	$LN93@DoPlaceNat
$LN88@DoPlaceNat:

; 1801 : 			}
; 1802 : 			else if(strcmp(feature->GetType(), "FEATURE_TITICACA") == 0)

	mov	ecx, ebx
	mov	esi, OFFSET $SG236596
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	npad	1
$LL311@DoPlaceNat:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN312@DoPlaceNat
	test	cl, cl
	je	SHORT $LN313@DoPlaceNat
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN312@DoPlaceNat
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL311@DoPlaceNat
$LN313@DoPlaceNat:
	xor	eax, eax
	jmp	SHORT $LN314@DoPlaceNat
$LN312@DoPlaceNat:
	sbb	eax, eax
	sbb	eax, -1
$LN314@DoPlaceNat:
	test	eax, eax
	jne	SHORT $LN86@DoPlaceNat

; 1803 : 			{
; 1804 : 				featureLake = eFeature;

	mov	DWORD PTR _featureLake$[esp+72], ebp
	jmp	$LN93@DoPlaceNat
$LN86@DoPlaceNat:

; 1805 : 			}
; 1806 : 			else if(strcmp(feature->GetType(), "FEATURE_FUJI") == 0)

	mov	ecx, ebx
	mov	esi, OFFSET $SG236599
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	npad	1
$LL315@DoPlaceNat:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN316@DoPlaceNat
	test	cl, cl
	je	SHORT $LN317@DoPlaceNat
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN316@DoPlaceNat
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL315@DoPlaceNat
$LN317@DoPlaceNat:
	xor	eax, eax
	jmp	SHORT $LN318@DoPlaceNat
$LN316@DoPlaceNat:
	sbb	eax, eax
	sbb	eax, -1
$LN318@DoPlaceNat:
	test	eax, eax
	jne	SHORT $LN84@DoPlaceNat

; 1807 : 			{
; 1808 : 				featureFuji = eFeature;

	mov	DWORD PTR _featureFuji$[esp+72], ebp
	jmp	$LN93@DoPlaceNat
$LN84@DoPlaceNat:

; 1809 : 			}
; 1810 : 			else if(strcmp(feature->GetType(), "FEATURE_MESA") == 0)

	mov	ecx, ebx
	mov	esi, OFFSET $SG236602
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	npad	1
$LL319@DoPlaceNat:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN320@DoPlaceNat
	test	cl, cl
	je	SHORT $LN321@DoPlaceNat
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN320@DoPlaceNat
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL319@DoPlaceNat
$LN321@DoPlaceNat:
	xor	eax, eax
	jmp	SHORT $LN322@DoPlaceNat
$LN320@DoPlaceNat:
	sbb	eax, eax
	sbb	eax, -1
$LN322@DoPlaceNat:
	test	eax, eax
	jne	SHORT $LN82@DoPlaceNat

; 1811 : 			{
; 1812 : 				featureMesa = eFeature;

	mov	DWORD PTR _featureMesa$[esp+72], ebp
	jmp	SHORT $LN93@DoPlaceNat
$LN82@DoPlaceNat:

; 1813 : 			}
; 1814 : 			else if(strcmp(feature->GetType(), "FEATURE_REEF") == 0)

	mov	ecx, ebx
	mov	esi, OFFSET $SG236605
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	npad	4
$LL323@DoPlaceNat:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN324@DoPlaceNat
	test	cl, cl
	je	SHORT $LN325@DoPlaceNat
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN324@DoPlaceNat
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL323@DoPlaceNat
$LN325@DoPlaceNat:
	xor	eax, eax
	jmp	SHORT $LN326@DoPlaceNat
$LN324@DoPlaceNat:
	sbb	eax, eax
	sbb	eax, -1
$LN326@DoPlaceNat:
	test	eax, eax
	jne	SHORT $LN80@DoPlaceNat

; 1815 : 			{
; 1816 : 				featureReef = eFeature;

	mov	DWORD PTR _featureReef$[esp+72], ebp
	jmp	SHORT $LN93@DoPlaceNat
$LN80@DoPlaceNat:

; 1817 : 			}
; 1818 : 			else if(strcmp(feature->GetType(), "FEATURE_VOLCANO") == 0)

	mov	ecx, ebx
	mov	esi, OFFSET $SG236608
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	npad	4
$LL327@DoPlaceNat:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN328@DoPlaceNat
	test	cl, cl
	je	SHORT $LN329@DoPlaceNat
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN328@DoPlaceNat
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL327@DoPlaceNat
$LN329@DoPlaceNat:
	xor	eax, eax
	jmp	SHORT $LN330@DoPlaceNat
$LN328@DoPlaceNat:
	sbb	eax, eax
	sbb	eax, -1
$LN330@DoPlaceNat:
	test	eax, eax
	jne	SHORT $LN93@DoPlaceNat

; 1819 : 			{
; 1820 : 				featureVolcano = eFeature;

	mov	DWORD PTR _featureVolcano$[esp+72], ebp
$LN93@DoPlaceNat:

; 1782 : 	int nwCount = 0;
; 1783 : 	for(int iFeatureLoop = 0; iFeatureLoop < iNumFeatureInfos; iFeatureLoop++)

	inc	ebp
	cmp	ebp, DWORD PTR _iNumFeatureInfos$[esp+72]
	jl	$LL336@DoPlaceNat

; 1821 : 			}
; 1822 : 
; 1823 : 			nwCount++;
; 1824 : 		}
; 1825 : 	}
; 1826 : 
; 1827 : 	// No Natural Wonder Feature, abort!
; 1828 : 	if(eNWFeature == NO_FEATURE)

	cmp	DWORD PTR _eNWFeature$[esp+72], -1
	je	$LN339@DoPlaceNat

; 1829 : 	{
; 1830 : 		return;
; 1831 : 	}
; 1832 : 
; 1833 : 	int iNumNaturalWondersToAdd = getWorldInfo().getNumNaturalWonders();

	call	?worldInfo@CvPreGame@@YAABVCvWorldInfo@@XZ ; CvPreGame::worldInfo
	mov	ecx, eax
	call	?getNumNaturalWonders@CvWorldInfo@@QBEHXZ ; CvWorldInfo::getNumNaturalWonders

; 1834 : 
; 1835 : 	int iCoastDistance = -1;	// Should be in XML
; 1836 : 	int iAnotherNWDistance = 5;	// Should be in XML
; 1837 : 
; 1838 : 	int iCount = 0;
; 1839 : 
; 1840 : 	int iPlotRand;
; 1841 : 	CvPlot* pRandPlot;
; 1842 : 
; 1843 : 	int iPlotLoopX;
; 1844 : 	int iPlotLoopY;
; 1845 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 1846 : 	int iMaxDX;
; 1847 : #endif
; 1848 : 	CvPlot* pLoopPlot;
; 1849 : 
; 1850 : 	int iNumMapPlots = numPlots();
; 1851 : 
; 1852 : 	// Determine the max number of NWs we can have in a single Area
; 1853 : 	CvArea* pLoopArea;
; 1854 : 	int iLoop;
; 1855 : 	int iNumValidAreas = 0;
; 1856 : 
; 1857 : 	int iMaxLatitudeForNW = 65;
; 1858 : 
; 1859 : 	int iBottomLatitude;
; 1860 : 
; 1861 : 	for(pLoopArea = firstArea(&iLoop); pLoopArea != NULL; pLoopArea = nextArea(&iLoop))

	mov	ecx, DWORD PTR [edi+4124]
	mov	DWORD PTR _iNumNaturalWondersToAdd$[esp+72], eax
	mov	eax, DWORD PTR [edi+4028]
	add	edi, 4112				; 00001010H
	xor	ebp, ebp
	inc	ecx
	xor	esi, esi
	mov	DWORD PTR _iCount$[esp+72], ebp
	mov	DWORD PTR _iNumMapPlots$[esp+72], eax
	test	ecx, ecx
	jle	SHORT $LN122@DoPlaceNat
$LL124@DoPlaceNat:
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+16]
	push	esi
	mov	ecx, edi
	call	eax
	inc	esi
	test	eax, eax
	jne	SHORT $LN125@DoPlaceNat
	mov	ecx, DWORD PTR [edi+12]
	inc	ecx
	cmp	esi, ecx
	jl	SHORT $LL124@DoPlaceNat
$LN122@DoPlaceNat:
	xor	eax, eax
$LN125@DoPlaceNat:
	mov	ebx, eax
	test	eax, eax
	je	SHORT $LN74@DoPlaceNat
$LL76@DoPlaceNat:

; 1862 : 	{
; 1863 : 		if(!pLoopArea->isWater())

	mov	ecx, ebx
	call	?isWater@CvArea@@QBE_NXZ		; CvArea::isWater
	test	al, al
	jne	SHORT $LN75@DoPlaceNat

; 1864 : 		{
; 1865 : 			if(!pLoopArea->IsMountains())

	mov	ecx, ebx
	call	?IsMountains@CvArea@@QBE_NXZ		; CvArea::IsMountains
	test	al, al
	jne	SHORT $LN75@DoPlaceNat

; 1866 : 			{
; 1867 : 				iBottomLatitude = pLoopArea->GetAreaMinLatitude();

	mov	ecx, ebx
	call	?GetAreaMinLatitude@CvArea@@QAEHXZ	; CvArea::GetAreaMinLatitude

; 1868 : 
; 1869 : 				if(iBottomLatitude <= iMaxLatitudeForNW)

	cmp	eax, 65					; 00000041H
	jg	SHORT $LN75@DoPlaceNat

; 1870 : 				{
; 1871 : 					iNumValidAreas++;

	inc	ebp
$LN75@DoPlaceNat:

; 1834 : 
; 1835 : 	int iCoastDistance = -1;	// Should be in XML
; 1836 : 	int iAnotherNWDistance = 5;	// Should be in XML
; 1837 : 
; 1838 : 	int iCount = 0;
; 1839 : 
; 1840 : 	int iPlotRand;
; 1841 : 	CvPlot* pRandPlot;
; 1842 : 
; 1843 : 	int iPlotLoopX;
; 1844 : 	int iPlotLoopY;
; 1845 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 1846 : 	int iMaxDX;
; 1847 : #endif
; 1848 : 	CvPlot* pLoopPlot;
; 1849 : 
; 1850 : 	int iNumMapPlots = numPlots();
; 1851 : 
; 1852 : 	// Determine the max number of NWs we can have in a single Area
; 1853 : 	CvArea* pLoopArea;
; 1854 : 	int iLoop;
; 1855 : 	int iNumValidAreas = 0;
; 1856 : 
; 1857 : 	int iMaxLatitudeForNW = 65;
; 1858 : 
; 1859 : 	int iBottomLatitude;
; 1860 : 
; 1861 : 	for(pLoopArea = firstArea(&iLoop); pLoopArea != NULL; pLoopArea = nextArea(&iLoop))

	mov	edx, DWORD PTR [edi+12]
	inc	edx
	cmp	esi, edx
	jge	SHORT $LN334@DoPlaceNat
$LL146@DoPlaceNat:
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+16]
	push	esi
	mov	ecx, edi
	call	edx
	inc	esi
	test	eax, eax
	jne	SHORT $LN147@DoPlaceNat
	mov	eax, DWORD PTR [edi+12]
	inc	eax
	cmp	esi, eax
	jl	SHORT $LL146@DoPlaceNat
$LN334@DoPlaceNat:
	xor	eax, eax
$LN147@DoPlaceNat:
	mov	ebx, eax
	test	ebx, ebx
	jne	SHORT $LL76@DoPlaceNat
$LN74@DoPlaceNat:

; 1872 : 				}
; 1873 : 			}
; 1874 : 		}
; 1875 : 	}
; 1876 : 
; 1877 : 	int iMaxNWsOneArea = 2;
; 1878 : 
; 1879 : 	// If we have more Natural Wonders than we have Areas then we have to handle things differently - more can be placed in one Area than normal
; 1880 : 	if(iNumNaturalWondersToAdd > iNumValidAreas)

	mov	ecx, DWORD PTR _iNumNaturalWondersToAdd$[esp+72]
	cmp	ecx, ebp
	mov	DWORD PTR _iMaxNWsOneArea$[esp+72], 2
	jle	SHORT $LN270@DoPlaceNat

; 1881 : 	{
; 1882 : 		iMaxNWsOneArea = iNumNaturalWondersToAdd - iNumValidAreas + 1;

	mov	eax, ecx
	sub	eax, ebp
	inc	eax
	mov	DWORD PTR _iMaxNWsOneArea$[esp+72], eax
$LN270@DoPlaceNat:

; 1883 : 	}
; 1884 : 
; 1885 : 	while(iNumNaturalWondersToAdd > 0 && iCount < 10000)

	test	ecx, ecx
	jle	$LN339@DoPlaceNat
$LL331@DoPlaceNat:
	cmp	DWORD PTR _iCount$[esp+72], 10000	; 00002710H
	mov	esi, DWORD PTR _this$[esp+72]
	jge	$LN339@DoPlaceNat

; 1886 : 	{
; 1887 : 		iCount++;
; 1888 : 
; 1889 : 		iPlotRand = GC.getGame().getJonRandNum(iNumMapPlots, "Randomly Placing Natural Wonders");

	mov	ecx, DWORD PTR _iNumMapPlots$[esp+72]
	inc	DWORD PTR _iCount$[esp+72]
	push	OFFSET $SG236636
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 1890 : 
; 1891 : 		pRandPlot = plotByIndex(iPlotRand);

	test	eax, eax
	jl	SHORT $LN161@DoPlaceNat
	cmp	eax, DWORD PTR [esi+4028]
	jge	SHORT $LN161@DoPlaceNat
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [esi+4068]
	mov	esi, eax
	jmp	SHORT $LN162@DoPlaceNat
$LN161@DoPlaceNat:
	xor	esi, esi
$LN162@DoPlaceNat:

; 1892 : 
; 1893 : 		// No Water Tiles
; 1894 : 		if(pRandPlot->isWater())

	cmp	BYTE PTR [esi+5], 3
	je	$LN1@DoPlaceNat

; 1895 : 		{
; 1896 : 			continue;
; 1897 : 		}
; 1898 : 
; 1899 : 		// No River Tiles either (don't want them carved up)
; 1900 : 		if(pRandPlot->isRiver())

	cmp	BYTE PTR [esi+457], 0
	jg	$LN1@DoPlaceNat

; 1901 : 		{
; 1902 : 			continue;
; 1903 : 		}
; 1904 : 
; 1905 : 		// No Tiles with Resources
; 1906 : 		if(pRandPlot->getResourceType() != NO_RESOURCE)

	push	-1
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	jne	$LN1@DoPlaceNat

; 1907 : 		{
; 1908 : 			continue;
; 1909 : 		}
; 1910 : 
; 1911 : 		// No Tiles with Improvements (Goody Huts)
; 1912 : 		if(pRandPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	jne	$LN1@DoPlaceNat

; 1913 : 		{
; 1914 : 			continue;
; 1915 : 		}
; 1916 : 
; 1917 : 		// Can't have too many NWs in one Area
; 1918 : 		if(getArea(pRandPlot->getArea())->GetNumNaturalWonders() >= iMaxNWsOneArea)

	mov	ecx, DWORD PTR _this$[esp+72]
	mov	eax, DWORD PTR [esi+356]
	mov	edx, DWORD PTR [ecx+4112]
	add	ecx, 4112				; 00001010H
	push	eax
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	ecx, eax
	call	?GetNumNaturalWonders@CvArea@@QBEHXZ	; CvArea::GetNumNaturalWonders
	cmp	eax, DWORD PTR _iMaxNWsOneArea$[esp+72]
	jge	$LN1@DoPlaceNat

; 1919 : 		{
; 1920 : 			continue;
; 1921 : 		}
; 1922 : 
; 1923 : 		// Has to be in the central band of the map.  If the latitude is too extreme we might end up on a islelet surrounded by Ice or something
; 1924 : 		if(pRandPlot->getLatitude() > /*65*/ iMaxLatitudeForNW)

	mov	ecx, esi
	call	?getLatitude@CvPlot@@QBEHXZ		; CvPlot::getLatitude
	cmp	eax, 65					; 00000041H
	jg	$LN1@DoPlaceNat

; 1925 : 		{
; 1926 : 			continue;
; 1927 : 		}
; 1928 : 
; 1929 : 		// Can't be a starting Plot for ANY player (including Minors)
; 1930 : 		if(pRandPlot->isStartingPlot())

	mov	ecx, esi
	call	?isStartingPlot@CvPlot@@QBE_NXZ		; CvPlot::isStartingPlot
	test	al, al
	jne	$LN1@DoPlaceNat

; 1931 : 		{
; 1932 : 			continue;
; 1933 : 		}
; 1934 : 
; 1935 : 		bool bValid;
; 1936 : 
; 1937 : 		// Does it have to be close to the coast?
; 1938 : 		if(iCoastDistance != -1)
; 1939 : 		{
; 1940 : 			bValid = false;
; 1941 : 
; 1942 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 1943 : 			for (iPlotLoopY = -iCoastDistance; iPlotLoopY <= iCoastDistance; iPlotLoopY++)
; 1944 : 			{
; 1945 : 				iMaxDX = iCoastDistance - MAX(0, iPlotLoopY);
; 1946 : 				for (iPlotLoopX = -iCoastDistance - MIN(0, iPlotLoopY); iPlotLoopX <= iMaxDX; iPlotLoopX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 1947 : 				{
; 1948 : 					// No need for range check because loops are set up properly
; 1949 : 					pLoopPlot = plotXY(pRandPlot->getX(), pRandPlot->getY(), iPlotLoopX, iPlotLoopY);
; 1950 : #else
; 1951 : 			for(iPlotLoopX = -iCoastDistance; iPlotLoopX <= iCoastDistance; iPlotLoopX++)
; 1952 : 			{
; 1953 : 				for(iPlotLoopY = -iCoastDistance; iPlotLoopY <= iCoastDistance; iPlotLoopY++)
; 1954 : 				{
; 1955 : 					pLoopPlot = plotXYWithRangeCheck(pRandPlot->getX(), pRandPlot->getY(), iPlotLoopX, iPlotLoopY, iCoastDistance);
; 1956 : #endif
; 1957 : 
; 1958 : 					if(pLoopPlot != NULL)
; 1959 : 					{
; 1960 : 						if(pLoopPlot->isWater())
; 1961 : 						{
; 1962 : 							if(!pLoopPlot->isLake())
; 1963 : 							{
; 1964 : 								// Found a Plot within 2 plots of "the Ocean"
; 1965 : 								bValid = true;
; 1966 : 								break;
; 1967 : 							}
; 1968 : 						}
; 1969 : 					}
; 1970 : 				}
; 1971 : 
; 1972 : 				if(bValid)
; 1973 : 				{
; 1974 : 					break;
; 1975 : 				}
; 1976 : 			}
; 1977 : 
; 1978 : 			// Plot not within 2 of Ocean
; 1979 : 			if(!bValid)
; 1980 : 			{
; 1981 : 				continue;
; 1982 : 			}
; 1983 : 		}
; 1984 : 
; 1985 : 		bValid = true;
; 1986 : 
; 1987 : 		// Can't be too close to another Natural Wonder
; 1988 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 1989 : 		for (iPlotLoopY = -iAnotherNWDistance; iPlotLoopY <= iAnotherNWDistance; iPlotLoopY++)
; 1990 : 		{
; 1991 : 			iMaxDX = iAnotherNWDistance - MAX(0, iPlotLoopY);
; 1992 : 			for (iPlotLoopX = -iAnotherNWDistance - MIN(0, iPlotLoopY); iPlotLoopX <= iMaxDX; iPlotLoopX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 1993 : 			{
; 1994 : 				// No need for range check because loops are set up properly
; 1995 : 				pLoopPlot = plotXY(pRandPlot->getX(), pRandPlot->getY(), iPlotLoopX, iPlotLoopY);
; 1996 : #else
; 1997 : 		for(iPlotLoopX = -iAnotherNWDistance; iPlotLoopX <= iAnotherNWDistance; iPlotLoopX++)

	mov	ebx, -5					; fffffffbH
	mov	DWORD PTR tv1254[esp+72], 5
	npad	5
$LL48@DoPlaceNat:

; 2000 : 			{
; 2001 : 				pLoopPlot = plotXYWithRangeCheck(pRandPlot->getX(), pRandPlot->getY(), iPlotLoopX, iPlotLoopY, iAnotherNWDistance);

	xor	ecx, ecx
	test	ebx, ebx
	setge	cl
	mov	edi, -5					; fffffffbH
	lea	ebp, DWORD PTR [edi+10]
	mov	DWORD PTR tv952[esp+72], ecx
$LL45@DoPlaceNat:
	mov	ecx, DWORD PTR tv1254[esp+72]
	xor	edx, edx
	test	edi, edi
	setge	dl
	cmp	DWORD PTR tv952[esp+72], edx
	jne	SHORT $LN200@DoPlaceNat
	test	ecx, ecx
	jg	SHORT $LN203@DoPlaceNat
	mov	ecx, ebx
$LN203@DoPlaceNat:
	mov	eax, edi
	test	edi, edi
	jge	SHORT $LN206@DoPlaceNat
	mov	eax, ebp
$LN206@DoPlaceNat:
	add	eax, ecx
	jmp	SHORT $LN211@DoPlaceNat
$LN200@DoPlaceNat:
	test	ecx, ecx
	jg	SHORT $LN207@DoPlaceNat
	mov	ecx, ebx
$LN207@DoPlaceNat:
	mov	eax, edi
	test	edi, edi
	jge	SHORT $LN210@DoPlaceNat
	mov	eax, ebp
$LN210@DoPlaceNat:
	cmp	ecx, eax
	jl	SHORT $LN211@DoPlaceNat
	mov	eax, ecx
$LN211@DoPlaceNat:
	cmp	eax, 5
	jg	SHORT $LN44@DoPlaceNat
	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	edi
	push	ebx
	push	eax
	push	ecx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H

; 2002 : #endif
; 2003 : 
; 2004 : 				if(pLoopPlot != NULL)

	test	eax, eax
	je	SHORT $LN44@DoPlaceNat

; 2005 : 				{
; 2006 : 					if(pLoopPlot->IsNaturalWonder())

	mov	ecx, eax
	call	?IsNaturalWonder@CvPlot@@QBE_NXZ	; CvPlot::IsNaturalWonder
	test	al, al
	jne	$LN1@DoPlaceNat
$LN44@DoPlaceNat:

; 1998 : 		{
; 1999 : 			for(iPlotLoopY = -iAnotherNWDistance; iPlotLoopY <= iAnotherNWDistance; iPlotLoopY++)

	dec	ebp
	inc	edi
	cmp	ebp, -5					; fffffffbH
	jge	SHORT $LL45@DoPlaceNat
	mov	eax, DWORD PTR tv1254[esp+72]
	dec	eax
	inc	ebx
	cmp	eax, -5					; fffffffbH
	mov	DWORD PTR tv1254[esp+72], eax
	jge	$LL48@DoPlaceNat

; 2007 : 					{
; 2008 : 						// Found a NW too close
; 2009 : 						bValid = false;
; 2010 : 						break;
; 2011 : 					}
; 2012 : 				}
; 2013 : 			}
; 2014 : 
; 2015 : 			if(!bValid)
; 2016 : 			{
; 2017 : 				break;
; 2018 : 			}
; 2019 : 		}
; 2020 : 
; 2021 : 		// Natural Wonder too close
; 2022 : 		if(!bValid)
; 2023 : 		{
; 2024 : 			continue;
; 2025 : 		}
; 2026 : 
; 2027 : 		// see if we can add the volcano
; 2028 : 		if(featureVolcano != NO_FEATURE)

	mov	edi, DWORD PTR _featureVolcano$[esp+72]
	or	ebx, -1
	cmp	edi, ebx
	je	SHORT $LN37@DoPlaceNat

; 2029 : 		{
; 2030 : 			if(!pRandPlot->isAdjacentToLand())

	mov	ecx, esi
	call	?isAdjacentToLand@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentToLand
	test	al, al
	jne	SHORT $LN37@DoPlaceNat

; 2031 : 			{
; 2032 : 				pRandPlot->setPlotType(PLOT_MOUNTAIN);

	push	1
	push	1
	push	1
	push	0
	mov	ecx, esi
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2033 : 				pRandPlot->setFeatureType(featureVolcano);

	push	ebx
	push	edi
	mov	ecx, esi
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 2034 : 				iNumNaturalWondersToAdd--;
; 2035 : 				featureVolcano = NO_FEATURE;	// Prevent this one from being placed again

	mov	DWORD PTR _featureVolcano$[esp+72], ebx

; 2036 : 				continue;

	jmp	$LN341@DoPlaceNat
$LN37@DoPlaceNat:

; 2037 : 			}
; 2038 : 		}
; 2039 : 
; 2040 : 		// see if we can add the reef
; 2041 : 		if(featureReef != NO_FEATURE)

	cmp	DWORD PTR _featureReef$[esp+72], ebx
	je	$LN34@DoPlaceNat

; 2042 : 		{
; 2043 : 			if(!pRandPlot->isMountain() && pRandPlot->isAdjacentToShallowWater())

	cmp	BYTE PTR [esi+5], 0
	je	$LN34@DoPlaceNat
	mov	ecx, esi
	call	?isAdjacentToShallowWater@CvPlot@@QBE_NXZ ; CvPlot::isAdjacentToShallowWater
	test	al, al
	je	$LN34@DoPlaceNat

; 2044 : 			{
; 2045 : 				if(pRandPlot->area()->getNumTiles() == 2)

	mov	ecx, esi
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	cmp	eax, 2
	jne	SHORT $LN34@DoPlaceNat

; 2046 : 				{
; 2047 : 					pRandPlot->setPlotType(PLOT_MOUNTAIN);

	push	1
	push	1
	push	1
	push	0
	mov	ecx, esi
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2048 : 					pRandPlot->setFeatureType(featureReef);

	mov	edx, DWORD PTR _featureReef$[esp+72]
	push	-1
	push	edx
	mov	ecx, esi
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 2049 : 					for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	movsx	ebx, WORD PTR [esi+2]
	movsx	ebp, WORD PTR [esi]
	xor	edi, edi
$LL33@DoPlaceNat:

; 2050 : 					{
; 2051 : 						CvPlot* pAdjacentPlot = plotDirection(pRandPlot->getX(), pRandPlot->getY(), ((DirectionTypes)iI));

	push	edi
	push	ebx
	push	ebp
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 2052 : 						if(pAdjacentPlot != NULL)

	test	esi, esi
	je	SHORT $LN32@DoPlaceNat

; 2053 : 						{
; 2054 : 							if(!(pAdjacentPlot->isWater()))

	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN287@DoPlaceNat
$LN32@DoPlaceNat:

; 2049 : 					for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	edi
	cmp	edi, 6
	jl	SHORT $LL33@DoPlaceNat

; 2058 : 								break;
; 2059 : 							}
; 2060 : 						}
; 2061 : 					}
; 2062 : 					iNumNaturalWondersToAdd--;
; 2063 : 					featureReef = NO_FEATURE;	// Prevent this one from being placed again

	mov	DWORD PTR _featureReef$[esp+72], -1

; 2064 : 					continue;

	jmp	$LN341@DoPlaceNat
$LN287@DoPlaceNat:

; 2055 : 							{
; 2056 : 								pAdjacentPlot->setPlotType(PLOT_MOUNTAIN);

	push	1
	push	1
	push	1
	push	0
	mov	ecx, esi
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2057 : 								pAdjacentPlot->setFeatureType(featureReef);

	mov	eax, DWORD PTR _featureReef$[esp+72]
	push	-1
	push	eax
	mov	ecx, esi
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 2058 : 								break;
; 2059 : 							}
; 2060 : 						}
; 2061 : 					}
; 2062 : 					iNumNaturalWondersToAdd--;
; 2063 : 					featureReef = NO_FEATURE;	// Prevent this one from being placed again

	mov	DWORD PTR _featureReef$[esp+72], -1

; 2064 : 					continue;

	jmp	$LN341@DoPlaceNat
$LN34@DoPlaceNat:

; 2065 : 				}
; 2066 : 			}
; 2067 : 		}
; 2068 : 
; 2069 : 		// see if we can add the lake
; 2070 : 		if(featureLake != NO_FEATURE)

	cmp	DWORD PTR _featureLake$[esp+72], ebx
	je	$LN21@DoPlaceNat

; 2071 : 		{
; 2072 : 			if(pRandPlot->isHills())

	cmp	BYTE PTR [esi+5], 1
	jne	$LN21@DoPlaceNat

; 2073 : 			{
; 2074 : 				int iHillCount = 0;
; 2075 : 				// if we have a couple of hills nearby already
; 2076 : 				for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	movsx	ebx, WORD PTR [esi+2]
	movsx	ebp, WORD PTR [esi]
	xor	edi, edi
	mov	DWORD PTR _iHillCount$236682[esp+72], edi
$LL26@DoPlaceNat:

; 2077 : 				{
; 2078 : 					CvPlot* pAdjacentPlot = plotDirection(pRandPlot->getX(), pRandPlot->getY(), ((DirectionTypes)iI));

	push	edi
	push	ebx
	push	ebp
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 2079 : 					if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN25@DoPlaceNat

; 2080 : 					{
; 2081 : 						if((pAdjacentPlot->isHills()))

	cmp	BYTE PTR [eax+5], 1
	jne	SHORT $LN25@DoPlaceNat

; 2082 : 						{
; 2083 : 							iHillCount++;

	inc	DWORD PTR _iHillCount$236682[esp+72]
$LN25@DoPlaceNat:

; 2073 : 			{
; 2074 : 				int iHillCount = 0;
; 2075 : 				// if we have a couple of hills nearby already
; 2076 : 				for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	edi
	cmp	edi, 6
	jl	SHORT $LL26@DoPlaceNat

; 2084 : 						}
; 2085 : 					}
; 2086 : 				}
; 2087 : 				if(iHillCount > 2)

	cmp	DWORD PTR _iHillCount$236682[esp+72], 2
	jle	SHORT $LN21@DoPlaceNat

; 2088 : 				{
; 2089 : 					// we are stamping the terrain
; 2090 : 					for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	xor	ebx, ebx
	npad	1
$LL20@DoPlaceNat:

; 2091 : 					{
; 2092 : 						CvPlot* pAdjacentPlot = plotDirection(pRandPlot->getX(), pRandPlot->getY(), ((DirectionTypes)iI));

	movsx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [esi]
	push	ebx
	push	ecx
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 2093 : 						if(pAdjacentPlot != NULL)

	test	edi, edi
	je	SHORT $LN19@DoPlaceNat

; 2094 : 						{
; 2095 : 							pAdjacentPlot->setPlotType(PLOT_HILLS);

	push	1
	push	1
	push	1
	push	1
	mov	ecx, edi
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2096 : 							pAdjacentPlot->setTerrainType((TerrainTypes)(GC.getLAND_TERRAIN()));

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8388
	push	1
	push	1
	push	eax
	mov	ecx, edi
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType
$LN19@DoPlaceNat:
	inc	ebx
	cmp	ebx, 6
	jl	SHORT $LL20@DoPlaceNat

; 2097 : 						}
; 2098 : 					}
; 2099 : 					pRandPlot->setPlotType(PLOT_MOUNTAIN);

	push	1
	push	1
	push	1
	push	0
	mov	ecx, esi
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2100 : 					pRandPlot->setFeatureType(featureLake);

	mov	ecx, DWORD PTR _featureLake$[esp+72]
	push	-1
	push	ecx
	mov	ecx, esi
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 2101 : 					iNumNaturalWondersToAdd--;
; 2102 : 					featureLake = NO_FEATURE;	// Prevent this one from being placed again

	mov	DWORD PTR _featureLake$[esp+72], -1

; 2103 : 					continue;

	jmp	$LN341@DoPlaceNat
$LN21@DoPlaceNat:

; 2104 : 				}
; 2105 : 			}
; 2106 : 		}
; 2107 : 
; 2108 : 		// see if we can add Everest
; 2109 : 		if(featureEverest != NO_FEATURE)

	cmp	DWORD PTR _featureEverest$[esp+72], -1
	je	$LN15@DoPlaceNat

; 2110 : 		{
; 2111 : 			if(pRandPlot->isMountain() && GC.getGame().getMapRandNum(100, "Natural Wonder") > 75)

	cmp	BYTE PTR [esi+5], 0
	jne	$LN15@DoPlaceNat
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG236702
	push	100					; 00000064H
	call	?getMapRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getMapRandNum
	cmp	eax, 75					; 0000004bH
	jle	$LN15@DoPlaceNat

; 2112 : 			{
; 2113 : 				// we are stamping the terrain
; 2114 : 				for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	xor	ebx, ebx
	npad	6
$LL14@DoPlaceNat:

; 2115 : 				{
; 2116 : 					CvPlot* pAdjacentPlot = plotDirection(pRandPlot->getX(), pRandPlot->getY(), ((DirectionTypes)iI));

	movsx	edx, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	push	ebx
	push	edx
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 2117 : 					if(pAdjacentPlot != NULL)

	test	edi, edi
	je	SHORT $LN13@DoPlaceNat

; 2118 : 					{
; 2119 : 						if(iI & 1)
; 2120 : 						{
; 2121 : 							pAdjacentPlot->setPlotType(PLOT_MOUNTAIN);

	push	1
	push	1
	mov	ecx, edi
	push	1
	test	bl, 1
	je	SHORT $LN10@DoPlaceNat
	push	0
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2122 : 						}
; 2123 : 						else

	jmp	SHORT $LN13@DoPlaceNat
$LN10@DoPlaceNat:

; 2124 : 						{
; 2125 : 							pAdjacentPlot->setPlotType(PLOT_HILLS);

	push	1
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2126 : 							pAdjacentPlot->setTerrainType((TerrainTypes)(GC.getLAND_TERRAIN()));

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8388
	push	1
	push	1
	push	ecx
	mov	ecx, edi
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType
$LN13@DoPlaceNat:
	inc	ebx
	cmp	ebx, 6
	jl	SHORT $LL14@DoPlaceNat

; 2127 : 						}
; 2128 : 					}
; 2129 : 				}
; 2130 : 				pRandPlot->setPlotType(PLOT_MOUNTAIN);

	push	1
	push	1
	push	1
	push	0
	mov	ecx, esi
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2131 : 				pRandPlot->setFeatureType(featureEverest);

	mov	edx, DWORD PTR _featureEverest$[esp+72]
	push	-1
	push	edx
	mov	ecx, esi
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 2132 : 				iNumNaturalWondersToAdd--;
; 2133 : 				featureEverest = NO_FEATURE;	// Prevent this one from being placed again

	mov	DWORD PTR _featureEverest$[esp+72], -1

; 2134 : 				continue;

	jmp	$LN341@DoPlaceNat
$LN15@DoPlaceNat:

; 2135 : 			}
; 2136 : 		}
; 2137 : 
; 2138 : 		// randomly pick one of the other three - but not if this is a coastal plot, because they look terrible there
; 2139 : 		if(pRandPlot->isCoastalLand())

	or	ebx, -1
	push	ebx
	mov	ecx, esi
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	test	al, al
	jne	$LN1@DoPlaceNat

; 2140 : 		{
; 2141 : 			continue;
; 2142 : 		}
; 2143 : 
; 2144 : 		int iDice = GC.getGame().getMapRandNum(100, "Natural Wonder");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG236715
	push	100					; 00000064H
	call	?getMapRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getMapRandNum

; 2145 : 		if(iDice > 66)

	cmp	eax, 66					; 00000042H
	jle	SHORT $LN7@DoPlaceNat

; 2146 : 		{
; 2147 : 			if(featureCrater != NO_FEATURE)

	mov	edi, DWORD PTR _featureCrater$[esp+72]
	cmp	edi, ebx
	je	SHORT $LN1@DoPlaceNat

; 2148 : 			{
; 2149 : 				pRandPlot->setPlotType(PLOT_MOUNTAIN);

	push	1
	push	1
	push	1
	push	0
	mov	ecx, esi
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2150 : 				pRandPlot->setFeatureType(featureCrater);

	push	ebx
	push	edi
	mov	ecx, esi
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 2151 : 				iNumNaturalWondersToAdd--;
; 2152 : 				featureCrater = NO_FEATURE;	// Prevent this one from being placed again

	mov	DWORD PTR _featureCrater$[esp+72], ebx

; 2153 : 				continue;

	jmp	SHORT $LN341@DoPlaceNat
$LN7@DoPlaceNat:

; 2154 : 			}
; 2155 : 		}
; 2156 : 		else if(iDice > 25)

	cmp	eax, 25					; 00000019H
	jle	SHORT $LN4@DoPlaceNat

; 2157 : 		{
; 2158 : 			if(featureFuji != NO_FEATURE)

	mov	edi, DWORD PTR _featureFuji$[esp+72]
	cmp	edi, ebx
	je	SHORT $LN1@DoPlaceNat

; 2159 : 			{
; 2160 : 				pRandPlot->setPlotType(PLOT_MOUNTAIN);

	push	1
	push	1
	push	1
	push	0
	mov	ecx, esi
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2161 : 				pRandPlot->setFeatureType(featureFuji);

	push	ebx
	push	edi
	mov	ecx, esi
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 2162 : 				iNumNaturalWondersToAdd--;
; 2163 : 				featureFuji = NO_FEATURE;	// Prevent this one from being placed again

	mov	DWORD PTR _featureFuji$[esp+72], ebx

; 2164 : 				continue;

	jmp	SHORT $LN341@DoPlaceNat
$LN4@DoPlaceNat:

; 2165 : 			}
; 2166 : 		}
; 2167 : 		else
; 2168 : 		{
; 2169 : 			if(featureMesa != NO_FEATURE)

	mov	edi, DWORD PTR _featureMesa$[esp+72]
	cmp	edi, ebx
	je	SHORT $LN1@DoPlaceNat

; 2170 : 			{
; 2171 : 				pRandPlot->setPlotType(PLOT_MOUNTAIN);

	push	1
	push	1
	push	1
	push	0
	mov	ecx, esi
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2172 : 				pRandPlot->setFeatureType(featureMesa);

	push	ebx
	push	edi
	mov	ecx, esi
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 2174 : 				featureMesa = NO_FEATURE;	// Prevent this one from being placed again

	mov	DWORD PTR _featureMesa$[esp+72], ebx
$LN341@DoPlaceNat:

; 2173 : 				iNumNaturalWondersToAdd--;

	dec	DWORD PTR _iNumNaturalWondersToAdd$[esp+72]
$LN1@DoPlaceNat:

; 1883 : 	}
; 1884 : 
; 1885 : 	while(iNumNaturalWondersToAdd > 0 && iCount < 10000)

	cmp	DWORD PTR _iNumNaturalWondersToAdd$[esp+72], 0
	jg	$LL331@DoPlaceNat
$LN339@DoPlaceNat:
	pop	esi
	pop	ebx
$LN68@DoPlaceNat:
	pop	edi
	pop	ebp

; 2175 : 				continue;
; 2176 : 			}
; 2177 : 		}
; 2178 : 	}
; 2179 : }

	add	esp, 56					; 00000038H
	ret	0
?DoPlaceNaturalWonders@CvMap@@QAEXXZ ENDP		; CvMap::DoPlaceNaturalWonders
_TEXT	ENDS
PUBLIC	?firstLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z	; CvMap::firstLandmass
; Function compile flags: /Ogtpy
;	COMDAT ?firstLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z
_TEXT	SEGMENT
_pIterIdx$ = 8						; size = 4
_bRev$ = 12						; size = 1
?firstLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z PROC	; CvMap::firstLandmass, COMDAT
; _this$ = ecx

; 2345 : 	return !bRev ? m_landmasses.BeginIter(pIterIdx) : m_landmasses.EndIter(pIterIdx);

	cmp	BYTE PTR _bRev$[esp-4], 0
	jne	SHORT $LN3@firstLandm
	mov	eax, DWORD PTR _pIterIdx$[esp-4]
	push	eax
	add	ecx, 4140				; 0000102cH
	call	?BeginIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ; FFreeListArrayBase<CvLandmass>::BeginIter

; 2346 : }

	ret	8
$LN3@firstLandm:

; 2345 : 	return !bRev ? m_landmasses.BeginIter(pIterIdx) : m_landmasses.EndIter(pIterIdx);

	mov	eax, DWORD PTR [ecx+4152]
	push	esi
	mov	esi, DWORD PTR _pIterIdx$[esp]
	push	edi
	lea	edi, DWORD PTR [ecx+4140]
	mov	DWORD PTR [esi], eax
	test	eax, eax
	jl	SHORT $LN10@firstLandm
$LL12@firstLandm:
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+16]
	push	eax
	mov	ecx, edi
	call	edx
	dec	DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@firstLandm
	cmp	DWORD PTR [esi], eax
	jge	SHORT $LL12@firstLandm
$LN10@firstLandm:
	xor	eax, eax
$LN13@firstLandm:
	pop	edi
	pop	esi

; 2346 : }

	ret	8
?firstLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z ENDP	; CvMap::firstLandmass
_TEXT	ENDS
PUBLIC	?recalculateLandmasses@CvMap@@QAEXXZ		; CvMap::recalculateLandmasses
; Function compile flags: /Ogtpy
;	COMDAT ?recalculateLandmasses@CvMap@@QAEXXZ
_TEXT	SEGMENT
?recalculateLandmasses@CvMap@@QAEXXZ PROC		; CvMap::recalculateLandmasses, COMDAT
; _this$ = ecx

; 2357 : {

	push	ebx
	push	edi
	mov	edi, ecx

; 2358 : #ifdef AUI_WARNING_FIXES
; 2359 : 	for (uint iI = 0; iI < numPlots(); iI++)
; 2360 : #else
; 2361 : 	int iNumPlots = numPlots();

	mov	ebx, DWORD PTR [edi+4028]

; 2362 : 	for(int iI = 0; iI < iNumPlots; iI++)

	test	ebx, ebx
	jle	SHORT $LN1@recalculat
	push	esi
	xor	esi, esi
$LL3@recalculat:

; 2363 : #endif
; 2364 : 	{
; 2365 : 		plotByIndexUnchecked(iI)->setLandmass(FFreeList::INVALID_INDEX);

	mov	ecx, DWORD PTR [edi+4068]
	push	-1
	add	ecx, esi
	call	?setLandmass@CvPlot@@QAEXH@Z		; CvPlot::setLandmass
	add	esi, 484				; 000001e4H
	sub	ebx, 1
	jne	SHORT $LL3@recalculat
	pop	esi
$LN1@recalculat:

; 2366 : 	}
; 2367 : 
; 2368 : 	m_landmasses.RemoveAll();

	mov	eax, DWORD PTR [edi+4140]
	mov	edx, DWORD PTR [eax+20]
	lea	ecx, DWORD PTR [edi+4140]
	call	edx

; 2369 : 
; 2370 : 	calculateLandmasses();

	mov	ecx, edi
	pop	edi
	pop	ebx
	jmp	?calculateLandmasses@CvMap@@QAEXXZ	; CvMap::calculateLandmasses
?recalculateLandmasses@CvMap@@QAEXXZ ENDP		; CvMap::recalculateLandmasses
_TEXT	ENDS
PUBLIC	?Validate@CvMap@@QAEHXZ				; CvMap::Validate
EXTRN	?Validate@CvPlot@@QAEHAAVCvMap@@@Z:PROC		; CvPlot::Validate
EXTRN	?ClearAllCityTradeRoutes@CvGameTrade@@QAEXPAVCvPlot@@@Z:PROC ; CvGameTrade::ClearAllCityTradeRoutes
EXTRN	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ:PROC ; CvGame::GetGameTrade
; Function compile flags: /Ogtpy
;	COMDAT ?Validate@CvMap@@QAEHXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv520 = -12						; size = 4
_pGameTrade$ = -8					; size = 4
_ui$236847 = -4						; size = 4
?Validate@CvMap@@QAEHXZ PROC				; CvMap::Validate, COMDAT
; _this$ = ecx

; 2417 : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx

; 2418 : 	//SS: Patch Trade Connections.
; 2419 : 	//Just after the BNW Launch trade connection data could be corrupted due to razing cities.
; 2420 : 	//This function is used because it's called immediately after serialization.
; 2421 : 	//Iterate through all trade connections.
; 2422 : 	//Clear the connection if the source or dest city does not exist.
; 2423 : 	CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	mov	DWORD PTR _this$[esp+32], ebp
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade

; 2424 : 	if(pGameTrade)

	xor	ecx, ecx
	mov	DWORD PTR _pGameTrade$[esp+32], eax
	cmp	eax, ecx
	je	$LN9@Validate

; 2425 : 	{
; 2426 : 		for (uint ui = 0; ui < pGameTrade->m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$236847[esp+32], ecx
	cmp	DWORD PTR [eax+4], ecx
	jbe	$LN9@Validate
	mov	DWORD PTR tv520[esp+32], ecx
	npad	9
$LL11@Validate:

; 2427 : 		{
; 2428 : 			TradeConnection& connection = pGameTrade->m_aTradeConnections[ui];

	mov	ebp, DWORD PTR [eax]
	add	ebp, DWORD PTR tv520[esp+32]

; 2429 : 			if(connection.m_iID > -1)

	cmp	DWORD PTR [ebp], -1
	jle	$LN10@Validate

; 2430 : 			{
; 2431 : 				CvPlot* pOriginPlot = plot(connection.m_iOriginX, connection.m_iOriginY);

	mov	eax, DWORD PTR [ebp+4]
	mov	ebx, DWORD PTR [ebp+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN120@Validate
	cmp	ebx, -2147483647			; 80000001H
	je	$LN120@Validate
	mov	edx, DWORD PTR _this$[esp+32]
	cmp	BYTE PTR [edx+4056], 0
	mov	ecx, DWORD PTR [edx+4020]
	je	SHORT $LN31@Validate
	test	eax, eax
	jge	SHORT $LN33@Validate
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR _this$[esp+32]
	add	esi, ecx
	jmp	SHORT $LN35@Validate
$LN33@Validate:
	cmp	eax, ecx
	jl	SHORT $LN31@Validate
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR _this$[esp+32]
	jmp	SHORT $LN35@Validate
$LN31@Validate:
	mov	esi, eax
$LN35@Validate:
	cmp	BYTE PTR [edx+4057], 0
	mov	edi, DWORD PTR [edx+4024]
	je	SHORT $LN41@Validate
	test	ebx, ebx
	jge	SHORT $LN43@Validate
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN45@Validate
$LN43@Validate:
	cmp	ebx, edi
	jl	SHORT $LN41@Validate
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN45@Validate
$LN41@Validate:
	mov	edx, ebx
$LN45@Validate:
	test	esi, esi
	jl	SHORT $LN120@Validate
	cmp	esi, ecx
	jge	SHORT $LN120@Validate
	test	edx, edx
	jl	SHORT $LN120@Validate
	cmp	edx, edi
	jge	SHORT $LN120@Validate
	mov	eax, DWORD PTR _this$[esp+32]
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	mov	esi, ecx

; 2432 : 				if(pOriginPlot)

	je	SHORT $LN120@Validate

; 2433 : 				{
; 2434 : 					if(pOriginPlot->getPlotCity() == NULL)

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	$LN118@Validate
	cmp	eax, 64					; 00000040H
	jge	$LN118@Validate
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax

; 2435 : 					{
; 2436 : 						pGameTrade->ClearAllCityTradeRoutes(pOriginPlot);
; 2437 : 						continue;

	je	$LN118@Validate
$LN120@Validate:

; 2438 : 					}
; 2439 : 				}
; 2440 : 
; 2441 : 				CvPlot* pDestPlot = plot(connection.m_iDestX, connection.m_iDestY);

	mov	eax, DWORD PTR [ebp+12]
	mov	ebx, DWORD PTR [ebp+16]
	cmp	eax, -2147483647			; 80000001H
	je	$LN10@Validate
	cmp	ebx, -2147483647			; 80000001H
	je	$LN10@Validate
	mov	edi, DWORD PTR _this$[esp+32]
	cmp	BYTE PTR [edi+4056], 0
	mov	ecx, DWORD PTR [edi+4020]
	je	SHORT $LN74@Validate
	test	eax, eax
	jge	SHORT $LN76@Validate
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN78@Validate
$LN76@Validate:
	cmp	eax, ecx
	jl	SHORT $LN74@Validate
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN78@Validate
$LN74@Validate:
	mov	esi, eax
$LN78@Validate:
	mov	edx, DWORD PTR _this$[esp+32]
	cmp	BYTE PTR [edx+4057], 0
	mov	edi, DWORD PTR [edi+4024]
	je	SHORT $LN84@Validate
	test	ebx, ebx
	jge	SHORT $LN86@Validate
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN88@Validate
$LN86@Validate:
	cmp	ebx, edi
	jl	SHORT $LN84@Validate
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN88@Validate
$LN84@Validate:
	mov	edx, ebx
$LN88@Validate:
	test	esi, esi
	jl	SHORT $LN10@Validate
	cmp	esi, ecx
	jge	SHORT $LN10@Validate
	test	edx, edx
	jl	SHORT $LN10@Validate
	cmp	edx, edi
	jge	SHORT $LN10@Validate
	mov	eax, DWORD PTR _this$[esp+32]
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	mov	esi, ecx

; 2442 : 				if(pDestPlot)

	je	SHORT $LN10@Validate

; 2443 : 				{
; 2444 : 					if(pDestPlot->getPlotCity() == NULL)

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN118@Validate
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN118@Validate
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	jne	SHORT $LN10@Validate
$LN118@Validate:

; 2445 : 					{
; 2446 : 						pGameTrade->ClearAllCityTradeRoutes(pDestPlot);

	mov	ecx, DWORD PTR _pGameTrade$[esp+32]
	push	esi
	call	?ClearAllCityTradeRoutes@CvGameTrade@@QAEXPAVCvPlot@@@Z ; CvGameTrade::ClearAllCityTradeRoutes
$LN10@Validate:
	mov	ecx, DWORD PTR _ui$236847[esp+32]
	mov	eax, DWORD PTR _pGameTrade$[esp+32]
	add	DWORD PTR tv520[esp+32], 444		; 000001bcH
	inc	ecx
	mov	DWORD PTR _ui$236847[esp+32], ecx
	cmp	ecx, DWORD PTR [eax+4]
	jb	$LL11@Validate

; 2425 : 	{
; 2426 : 		for (uint ui = 0; ui < pGameTrade->m_aTradeConnections.size(); ui++)

	mov	ebp, DWORD PTR _this$[esp+32]
$LN9@Validate:

; 2457 : #ifdef AUI_WARNING_FIXES
; 2458 : 	for (uint iI = 0; iI < numPlots(); iI++)
; 2459 : #else
; 2460 : 	for(int iI = 0; iI < numPlots(); iI++)

	xor	esi, esi
	xor	ebx, ebx
	cmp	DWORD PTR [ebp+4028], esi
	jle	SHORT $LN119@Validate

; 2447 : 						continue;
; 2448 : 					}
; 2449 : 				}
; 2450 : 			}
; 2451 : 		}
; 2452 : 	}
; 2453 : 
; 2454 : 
; 2455 : 
; 2456 : 	int iErrors = 0;

	xor	edi, edi
	npad	8
$LL3@Validate:

; 2461 : #endif
; 2462 : 	{
; 2463 : 		CvPlot* pLoopPlot = plotByIndexUnchecked(iI);

	mov	ecx, DWORD PTR [ebp+4068]
	add	ecx, edi

; 2464 : 		iErrors |= pLoopPlot->Validate(*this);

	push	ebp
	call	?Validate@CvPlot@@QAEHAAVCvMap@@@Z	; CvPlot::Validate
	inc	esi
	or	ebx, eax
	add	edi, 484				; 000001e4H
	cmp	esi, DWORD PTR [ebp+4028]
	jl	SHORT $LL3@Validate
$LN119@Validate:
	pop	edi
	pop	esi
	pop	ebp

; 2465 : 	}
; 2466 : 
; 2467 : 	return iErrors;

	mov	eax, ebx
	pop	ebx

; 2468 : }

	add	esp, 16					; 00000010H
	ret	0
?Validate@CvMap@@QAEHXZ ENDP				; CvMap::Validate
_TEXT	ENDS
PUBLIC	??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z ; operator>><CvArea>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAVCvArea@@@Z:PROC	; operator>>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarea.h
xdata$x	SEGMENT
__unwindtable$??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z$0
__ehfuncinfo$??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
xdata$x	ENDS
;	COMDAT ??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z
_TEXT	SEGMENT
_iCount$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_iTemp$ = 8						; size = 4
_readFrom$ = 8						; size = 4
$T242223 = 12						; size = 4
_writeTo$ = 12						; size = 4
??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z PROC ; operator>><CvArea>, COMDAT

; 602  : {

	push	-1
	push	__ehhandler$??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx

; 603  : 	int iTemp;
; 604  : 	readFrom >> iTemp;

	mov	ebx, DWORD PTR _readFrom$[esp+16]
	push	ebp
	push	esi
	push	edi
	lea	eax, DWORD PTR _iTemp$[esp+28]
	push	eax
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 605  : 	writeTo.Init( iTemp );

	mov	esi, DWORD PTR _writeTo$[esp+28]
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR _iTemp$[esp+28]
	mov	edx, DWORD PTR [edx+4]
	push	eax
	mov	ecx, esi
	call	edx

; 606  : 	readFrom >> iTemp;

	lea	eax, DWORD PTR _iTemp$[esp+28]
	push	eax
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 607  : 	writeTo.SetLastIndex(iTemp);

	mov	ecx, DWORD PTR _iTemp$[esp+28]

; 608  : 	readFrom >> iTemp;

	lea	edx, DWORD PTR _iTemp$[esp+28]
	mov	DWORD PTR [esi+12], ecx
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 609  : 	writeTo.SetFreeListHead(iTemp);

	mov	eax, DWORD PTR _iTemp$[esp+28]

; 610  : 	readFrom >> iTemp;

	lea	ecx, DWORD PTR _iTemp$[esp+28]
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR [esi+4], eax
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 611  : 	writeTo.SetFreeListCount(iTemp);

	mov	edx, DWORD PTR _iTemp$[esp+28]

; 612  : 	readFrom >> iTemp;

	lea	eax, DWORD PTR _iTemp$[esp+28]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR [esi+8], edx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 613  : 	writeTo.SetCurrentID(iTemp);
; 614  : 
; 615  : 	int i;
; 616  : 
; 617  : 	for ( i = 0; i < writeTo.GetNumSlots(); i++ )

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR _iTemp$[esp+28]
	xor	edi, edi
	mov	DWORD PTR [esi+20], ecx
	test	eax, eax
	jle	SHORT $LN4@operator@6
$LL6@operator@6:

; 618  : 	{
; 619  : 		readFrom >> iTemp;

	lea	edx, DWORD PTR _iTemp$[esp+28]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 620  : 		writeTo.SetNextFreeIndex(i, iTemp);

	cmp	edi, DWORD PTR [esi+16]
	jge	SHORT $LN5@operator@6
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN5@operator@6
	mov	ecx, DWORD PTR _iTemp$[esp+28]
	mov	DWORD PTR [eax+edi*8], ecx
$LN5@operator@6:
	inc	edi
	cmp	edi, DWORD PTR [esi+16]
	jl	SHORT $LL6@operator@6
$LN4@operator@6:

; 621  : 	}
; 622  : 
; 623  : 	int iCount;
; 624  : 	readFrom >> iCount;

	lea	edx, DWORD PTR _iCount$[esp+32]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 625  : 
; 626  : 	for ( i = 0; i < iCount; i++ )

	xor	ebp, ebp
	cmp	DWORD PTR _iCount$[esp+32], ebp
	jle	SHORT $LN52@operator@6
	npad	6
$LL53@operator@6:

; 627  : 	{
; 628  : 		T* pData = new T;

	push	4232					; 00001088H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T242223[esp+28], eax
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+40], edi
	cmp	eax, edi
	je	SHORT $LN9@operator@6
	mov	ecx, eax
	call	??0CvArea@@QAE@XZ			; CvArea::CvArea
	mov	edi, eax
$LN9@operator@6:

; 629  : 		readFrom >> *pData;

	push	edi
	push	ebx
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	??5@YAAAVFDataStream@@AAV0@AAVCvArea@@@Z ; operator>>
	add	esp, 8

; 630  : 		writeTo.Load(pData);

	test	edi, edi
	je	SHORT $LN2@operator@6
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN2@operator@6
	mov	ecx, DWORD PTR [edi+4]
	and	ecx, 8191				; 00001fffH
	mov	DWORD PTR [eax+ecx*8+4], edi
$LN2@operator@6:
	inc	ebp
	cmp	ebp, DWORD PTR _iCount$[esp+32]
	jl	SHORT $LL53@operator@6
$LN52@operator@6:

; 631  : 	}
; 632  : 	return readFrom;
; 633  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z$0:
	mov	eax, DWORD PTR $T242223[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z ENDP ; operator>><CvArea>
PUBLIC	??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ	; FFreeListTrashArray<CvArea>::~FFreeListTrashArray<CvArea>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
xdata$x	SEGMENT
__unwindtable$??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ$0
__ehfuncinfo$??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
xdata$x	ENDS
;	COMDAT ??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ PROC		; FFreeListTrashArray<CvArea>::~FFreeListTrashArray<CvArea>, COMDAT
; _this$ = ecx

; 140  : {

	push	-1
	push	__ehhandler$??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR [esi], OFFSET ??_7?$FFreeListTrashArray@VCvArea@@@@6B@

; 141  : 	Uninit();

	cmp	DWORD PTR [esi+24], 0
	mov	DWORD PTR __$EHRec$[esp+28], 0
	je	SHORT $LN11@FFreeListT
	call	DWORD PTR ??_7?$FFreeListTrashArray@VCvArea@@@@6B@+20
	mov	eax, DWORD PTR [esi+24]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+24], 0
$LN11@FFreeListT:

; 142  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR [esi], OFFSET ??_7?$FFreeListArrayBase@VCvArea@@@@6B@
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$FFreeListArrayBase@VCvArea@@@@UAE@XZ ; FFreeListArrayBase<CvArea>::~FFreeListArrayBase<CvArea>
__ehhandler$??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ ENDP		; FFreeListTrashArray<CvArea>::~FFreeListTrashArray<CvArea>
PUBLIC	??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ	; FFreeListTrashArray<CvLandmass>::~FFreeListTrashArray<CvLandmass>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
xdata$x	SEGMENT
__unwindtable$??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ$0
__ehfuncinfo$??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
xdata$x	ENDS
;	COMDAT ??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ PROC	; FFreeListTrashArray<CvLandmass>::~FFreeListTrashArray<CvLandmass>, COMDAT
; _this$ = ecx

; 140  : {

	push	-1
	push	__ehhandler$??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR [esi], OFFSET ??_7?$FFreeListTrashArray@VCvLandmass@@@@6B@

; 141  : 	Uninit();

	cmp	DWORD PTR [esi+24], 0
	mov	DWORD PTR __$EHRec$[esp+28], 0
	je	SHORT $LN11@FFreeListT@2
	call	DWORD PTR ??_7?$FFreeListTrashArray@VCvLandmass@@@@6B@+20
	mov	eax, DWORD PTR [esi+24]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+24], 0
$LN11@FFreeListT@2:

; 142  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR [esi], OFFSET ??_7?$FFreeListArrayBase@VCvLandmass@@@@6B@
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$FFreeListArrayBase@VCvLandmass@@@@UAE@XZ ; FFreeListArrayBase<CvLandmass>::~FFreeListArrayBase<CvLandmass>
__ehhandler$??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ ENDP	; FFreeListTrashArray<CvLandmass>::~FFreeListTrashArray<CvLandmass>
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$FFreeListTrashArray@VCvArea@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$FFreeListTrashArray@VCvArea@@@@UAEPAXI@Z PROC	; FFreeListTrashArray<CvArea>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ ; FFreeListTrashArray<CvArea>::~FFreeListTrashArray<CvArea>
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$FFreeListTrashArray@VCvArea@@@@UAEPAXI@Z ENDP	; FFreeListTrashArray<CvArea>::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$FFreeListTrashArray@VCvLandmass@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$FFreeListTrashArray@VCvLandmass@@@@UAEPAXI@Z PROC	; FFreeListTrashArray<CvLandmass>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ ; FFreeListTrashArray<CvLandmass>::~FFreeListTrashArray<CvLandmass>
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@6
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@6:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$FFreeListTrashArray@VCvLandmass@@@@UAEPAXI@Z ENDP	; FFreeListTrashArray<CvLandmass>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7CvMap@@6B@					; CvMap::`vftable'
PUBLIC	??0CvMap@@QAE@XZ				; CvMap::CvMap
PUBLIC	??_R4CvMap@@6B@					; CvMap::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvMap@@@8				; CvMap `RTTI Type Descriptor'
PUBLIC	??_R3CvMap@@8					; CvMap::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvMap@@8					; CvMap::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvMap@@8				; CvMap::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??1CvPlotManager@@QAE@XZ:PROC			; CvPlotManager::~CvPlotManager
EXTRN	??0CvPlotManager@@QAE@XZ:PROC			; CvPlotManager::CvPlotManager
EXTRN	??_ECvMap@@UAEPAXI@Z:PROC			; CvMap::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvMap@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstructs.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvMap@@8 DD FLAT:??_R0?AVCvMap@@@8	; CvMap::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvMap@@8
rdata$r	ENDS
;	COMDAT ??_R2CvMap@@8
rdata$r	SEGMENT
??_R2CvMap@@8 DD FLAT:??_R1A@?0A@EA@CvMap@@8		; CvMap::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvMap@@8
rdata$r	SEGMENT
??_R3CvMap@@8 DD 00H					; CvMap::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvMap@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvMap@@@8
_DATA	SEGMENT
??_R0?AVCvMap@@@8 DD FLAT:??_7type_info@@6B@		; CvMap `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvMap@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvMap@@6B@
rdata$r	SEGMENT
??_R4CvMap@@6B@ DD 00H					; CvMap::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvMap@@@8
	DD	FLAT:??_R3CvMap@@8
rdata$r	ENDS
;	COMDAT ??_7CvMap@@6B@
CONST	SEGMENT
??_7CvMap@@6B@ DD FLAT:??_R4CvMap@@6B@			; CvMap::`vftable'
	DD	FLAT:??_ECvMap@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvMap@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvMap@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvMap@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvMap@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvMap@@QAE@XZ$3
__ehfuncinfo$??0CvMap@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0CvMap@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.cpp
xdata$x	ENDS
;	COMDAT ??0CvMap@@QAE@XZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
_defaultMapData$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
??0CvMap@@QAE@XZ PROC					; CvMap::CvMap, COMDAT
; _this$ = ecx

; 227  : {

	push	-1
	push	__ehhandler$??0CvMap@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvMap@@6B@
	xor	ebx, ebx
	lea	eax, DWORD PTR [esi+16]
	mov	DWORD PTR _this$[esp+44], esi
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], 1000		; 000003e8H
	mov	DWORD PTR [esi+4], eax
	mov	edx, -2					; fffffffeH
	or	ecx, -1
	mov	eax, 8192				; 00002000H
	mov	DWORD PTR __$EHRec$[esp+52], ebx
	mov	DWORD PTR [esi+4116], edx
	mov	DWORD PTR [esi+4120], ebx
	mov	DWORD PTR [esi+4124], ecx
	mov	DWORD PTR [esi+4128], ebx
	mov	DWORD PTR [esi+4112], OFFSET ??_7?$FFreeListTrashArray@VCvArea@@@@6B@
	mov	DWORD PTR [esi+4132], eax
	mov	DWORD PTR [esi+4136], ebx
	mov	DWORD PTR [esi+4144], edx
	mov	DWORD PTR [esi+4148], ebx
	mov	DWORD PTR [esi+4152], ecx
	mov	DWORD PTR [esi+4156], ebx
	mov	DWORD PTR [esi+4140], OFFSET ??_7?$FFreeListTrashArray@VCvLandmass@@@@6B@
	mov	DWORD PTR [esi+4160], eax
	mov	DWORD PTR [esi+4164], ebx
	lea	ecx, DWORD PTR [esi+4184]
	mov	BYTE PTR __$EHRec$[esp+52], 2
	call	??0CvPlotManager@@QAE@XZ		; CvPlotManager::CvPlotManager

; 228  : 	CvMapInitData defaultMapData;

	mov	eax, 1

; 229  : 
; 230  : 	CvAssert(sgCvMapInstanceCount == 0);
; 231  : 	++sgCvMapInstanceCount;

	add	DWORD PTR _sgCvMapInstanceCount, eax
	mov	BYTE PTR _defaultMapData$[esp+60], al

; 232  : 
; 233  : 	m_paiNumResource = NULL;
; 234  : 	m_paiNumResourceOnLand = NULL;
; 235  : 
; 236  : 	m_pMapPlots = NULL;
; 237  : 
; 238  : 
; 239  : 	m_pYields = NULL;
; 240  : 	m_pFoundValue = NULL;
; 241  : 	m_pPlayerCityRadiusCount = NULL;
; 242  : 	m_pVisibilityCount = NULL;
; 243  : 	m_pRevealedOwner = NULL;
; 244  : 	m_pRevealed = NULL;
; 245  : 	m_pRevealedImprovementType = NULL;
; 246  : 	m_pRevealedRouteType = NULL;
; 247  : 	m_pNoSettling = NULL;
; 248  : 	m_pResourceForceReveal = NULL;
; 249  : 
; 250  : 	m_iAIMapHints = 0;
; 251  : 
; 252  : 	reset(&defaultMapData);

	lea	eax, DWORD PTR _defaultMapData$[esp+44]
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+56], 3
	mov	DWORD PTR _defaultMapData$[esp+48], ebx
	mov	DWORD PTR _defaultMapData$[esp+52], ebx
	mov	DWORD PTR _defaultMapData$[esp+56], 90	; 0000005aH
	mov	DWORD PTR _defaultMapData$[esp+60], -90	; ffffffa6H
	mov	BYTE PTR _defaultMapData$[esp+65], bl
	mov	DWORD PTR [esi+4060], ebx
	mov	DWORD PTR [esi+4064], ebx
	mov	DWORD PTR [esi+4068], ebx
	mov	DWORD PTR [esi+4072], ebx
	mov	DWORD PTR [esi+4076], ebx
	mov	DWORD PTR [esi+4080], ebx
	mov	DWORD PTR [esi+4084], ebx
	mov	DWORD PTR [esi+4088], ebx
	mov	DWORD PTR [esi+4092], ebx
	mov	DWORD PTR [esi+4096], ebx
	mov	DWORD PTR [esi+4100], ebx
	mov	DWORD PTR [esi+4104], ebx
	mov	DWORD PTR [esi+4108], ebx
	mov	DWORD PTR [esi+4052], ebx
	call	?reset@CvMap@@QAEXPAUCvMapInitData@@@Z	; CvMap::reset

; 253  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 36					; 00000024H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvMap@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ ; FStaticVector<CvPlot *,1000,1,297,1>::~FStaticVector<CvPlot *,1000,1,297,1>
__unwindfunclet$??0CvMap@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4112				; 00001010H
	jmp	??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ ; FFreeListTrashArray<CvArea>::~FFreeListTrashArray<CvArea>
__unwindfunclet$??0CvMap@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4140				; 0000102cH
	jmp	??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ ; FFreeListTrashArray<CvLandmass>::~FFreeListTrashArray<CvLandmass>
__unwindfunclet$??0CvMap@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4184				; 00001058H
	jmp	??1CvPlotManager@@QAE@XZ		; CvPlotManager::~CvPlotManager
__ehhandler$??0CvMap@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvMap@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvMap@@QAE@XZ ENDP					; CvMap::CvMap
PUBLIC	??1CvMap@@UAE@XZ				; CvMap::~CvMap
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvMap@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvMap@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvMap@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvMap@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvMap@@UAE@XZ$3
__ehfuncinfo$??1CvMap@@UAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1CvMap@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.cpp
xdata$x	ENDS
;	COMDAT ??1CvMap@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvMap@@UAE@XZ PROC					; CvMap::~CvMap, COMDAT
; _this$ = ecx

; 258  : {

	push	-1
	push	__ehhandler$??1CvMap@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvMap@@6B@
	mov	DWORD PTR __$EHRec$[esp+28], 3

; 259  : 	uninit();

	call	?uninit@CvMap@@QAEXXZ			; CvMap::uninit

; 260  : 	--sgCvMapInstanceCount;

	dec	DWORD PTR _sgCvMapInstanceCount

; 261  : }

	lea	ecx, DWORD PTR [esi+4184]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	??1CvPlotManager@@QAE@XZ		; CvPlotManager::~CvPlotManager
	lea	ecx, DWORD PTR [esi+4140]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ ; FFreeListTrashArray<CvLandmass>::~FFreeListTrashArray<CvLandmass>
	lea	ecx, DWORD PTR [esi+4112]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ ; FFreeListTrashArray<CvArea>::~FFreeListTrashArray<CvArea>
	mov	eax, DWORD PTR [esi+4]
	add	esi, 16					; 00000010H
	cmp	eax, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	pop	esi
	je	SHORT $LN9@CvMap
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN9@CvMap:
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvMap@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ ; FStaticVector<CvPlot *,1000,1,297,1>::~FStaticVector<CvPlot *,1000,1,297,1>
__unwindfunclet$??1CvMap@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4112				; 00001010H
	jmp	??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ ; FFreeListTrashArray<CvArea>::~FFreeListTrashArray<CvArea>
__unwindfunclet$??1CvMap@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4140				; 0000102cH
	jmp	??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ ; FFreeListTrashArray<CvLandmass>::~FFreeListTrashArray<CvLandmass>
__unwindfunclet$??1CvMap@@UAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4184				; 00001058H
	jmp	??1CvPlotManager@@QAE@XZ		; CvPlotManager::~CvPlotManager
__ehhandler$??1CvMap@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvMap@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvMap@@UAE@XZ ENDP					; CvMap::~CvMap
PUBLIC	?init@CvMap@@QAEXPAUCvMapInitData@@@Z		; CvMap::init
EXTRN	?init@CvPlot@@QAEXHH@Z:PROC			; CvPlot::init
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?init@CvMap@@QAEXPAUCvMapInitData@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvMap@@QAEXPAUCvMapInitData@@@Z$0
__ehfuncinfo$?init@CvMap@@QAEXPAUCvMapInitData@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?init@CvMap@@QAEXPAUCvMapInitData@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.cpp
xdata$x	ENDS
;	COMDAT ?init@CvMap@@QAEXPAUCvMapInitData@@@Z
_TEXT	SEGMENT
_strMemState$ = -40					; size = 28
__$EHRec$ = -12						; size = 12
_iW$ = 8						; size = 4
_pInitInfo$ = 8						; size = 4
?init@CvMap@@QAEXPAUCvMapInitData@@@Z PROC		; CvMap::init, COMDAT
; _this$ = ecx

; 357  : {

	push	-1
	push	__ehhandler$?init@CvMap@@QAEXPAUCvMapInitData@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx

; 358  : 	int iX, iY;
; 359  : 
; 360  : 	CvString strMemState = CvString::format("CvMap::init begin - world size=%s, climate=%s, sealevel=%s",
; 361  : 	                                        getWorldInfo().GetDescription(),
; 362  : 	                                        getClimateInfo().GetDescription(),
; 363  : 	                                        getSeaLevelInfo().GetDescription());

	call	?seaLevelInfo@CvPreGame@@YAABVCvSeaLevelInfo@@XZ ; CvPreGame::seaLevelInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edi, eax
	call	?climateInfo@CvPreGame@@YAABVCvClimateInfo@@XZ ; CvPreGame::climateInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ebx, eax
	call	?worldInfo@CvPreGame@@YAABVCvWorldInfo@@XZ ; CvPreGame::worldInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	edi
	push	ebx
	push	eax
	lea	eax, DWORD PTR _strMemState$[esp+68]
	push	OFFSET $SG235820
	push	eax
	call	?format@CvString@@SA?AV1@PBDZZ		; CvString::format
	add	esp, 20					; 00000014H

; 364  : 
; 365  : 
; 366  : 	//--------------------------------
; 367  : 	// Init saved data
; 368  : 	reset(pInitInfo);

	mov	ecx, DWORD PTR _pInitInfo$[esp+52]
	push	ecx
	xor	ebx, ebx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+68], ebx
	call	?reset@CvMap@@QAEXPAUCvMapInitData@@@Z	; CvMap::reset

; 369  : 
; 370  : 	//--------------------------------
; 371  : 	// Init containers
; 372  : 	m_areas.Init();

	mov	edx, DWORD PTR [esi+4112]
	mov	eax, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [esi+4112]
	push	8
	call	eax

; 373  : 	m_landmasses.Init();

	mov	edx, DWORD PTR [esi+4140]
	mov	eax, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [esi+4140]
	push	8
	call	eax

; 374  : 
; 375  : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 376  : 	//--------------------------------
; 377  : 	// Init plot data
; 378  : 	InitPlots();
; 379  : #endif
; 380  : 
; 381  : 	//--------------------------------
; 382  : 	// Init non-saved data
; 383  : 	setup();

	mov	ecx, esi
	call	?setup@CvMap@@IAEXXZ			; CvMap::setup

; 384  : 
; 385  : #ifndef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 386  : 	//--------------------------------
; 387  : 	// Init other game data
; 388  : 	InitPlots();

	mov	ecx, esi
	call	?InitPlots@CvMap@@IAEXXZ		; CvMap::InitPlots

; 389  : #endif
; 390  : 
; 391  : 	int iW = getGridWidth();

	mov	eax, DWORD PTR [esi+4020]

; 392  : 	int iH = getGridHeight();
; 393  : 
; 394  : 
; 395  : 	for(iX = 0; iX < iW; iX++)

	cmp	eax, ebx
	mov	ebp, DWORD PTR [esi+4024]
	mov	DWORD PTR _iW$[esp+52], eax
	jle	SHORT $LN4@init
	npad	5
$LL39@init:

; 396  : 	{
; 397  : 		for(iY = 0; iY < iH; iY++)

	xor	edi, edi
	test	ebp, ebp
	jle	SHORT $LN5@init
	npad	10
$LL3@init:

; 398  : 		{
; 399  : 			plotUnchecked(iX, iY)->init(iX, iY);

	mov	ecx, DWORD PTR [esi+4020]
	imul	ecx, edi
	add	ecx, ebx
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [esi+4068]
	push	edi
	push	ebx
	call	?init@CvPlot@@QAEXHH@Z			; CvPlot::init
	inc	edi
	cmp	edi, ebp
	jl	SHORT $LL3@init

; 396  : 	{
; 397  : 		for(iY = 0; iY < iH; iY++)

	mov	eax, DWORD PTR _iW$[esp+52]
$LN5@init:

; 392  : 	int iH = getGridHeight();
; 393  : 
; 394  : 
; 395  : 	for(iX = 0; iX < iW; iX++)

	inc	ebx
	cmp	ebx, eax
	jl	SHORT $LL39@init
$LN4@init:

; 400  : 		}
; 401  : 	}
; 402  : }

	lea	ecx, DWORD PTR _strMemState$[esp+56]
	mov	DWORD PTR __$EHRec$[esp+64], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?init@CvMap@@QAEXPAUCvMapInitData@@@Z$0:
	lea	ecx, DWORD PTR _strMemState$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?init@CvMap@@QAEXPAUCvMapInitData@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?init@CvMap@@QAEXPAUCvMapInitData@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?init@CvMap@@QAEXPAUCvMapInitData@@@Z ENDP		; CvMap::init
PUBLIC	?findBiggestArea@CvMap@@QAEPAVCvArea@@_N@Z	; CvMap::findBiggestArea
; Function compile flags: /Ogtpy
;	COMDAT ?findBiggestArea@CvMap@@QAEPAVCvArea@@_N@Z
_TEXT	SEGMENT
_pBestArea$ = -8					; size = 4
_iLoop$ = -4						; size = 4
_bWater$ = 8						; size = 1
?findBiggestArea@CvMap@@QAEPAVCvArea@@_N@Z PROC		; CvMap::findBiggestArea, COMDAT
; _this$ = ecx

; 1136 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1137 : 	CvArea* pLoopArea;
; 1138 : 	CvArea* pBestArea;
; 1139 : 	int iValue;
; 1140 : 	int iBestValue;
; 1141 : 	int iLoop;
; 1142 : 
; 1143 : 	iBestValue = 0;
; 1144 : 	pBestArea = NULL;
; 1145 : 
; 1146 : 	for(pLoopArea = firstArea(&iLoop); pLoopArea != NULL; pLoopArea = nextArea(&iLoop))

	lea	esi, DWORD PTR [ecx+4112]
	lea	eax, DWORD PTR _iLoop$[esp+24]
	xor	ebp, ebp
	push	eax
	mov	ecx, esi
	xor	ebx, ebx
	mov	DWORD PTR _pBestArea$[esp+28], ebp
	call	?BeginIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ; FFreeListArrayBase<CvArea>::BeginIter
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN51@findBigges
	mov	ebp, DWORD PTR _iLoop$[esp+24]
	npad	5
$LL5@findBigges:

; 1147 : 	{
; 1148 : 		if(pLoopArea->isWater() == bWater)

	mov	ecx, edi
	call	?isWater@CvArea@@QBE_NXZ		; CvArea::isWater
	cmp	al, BYTE PTR _bWater$[esp+20]
	jne	SHORT $LN4@findBigges

; 1149 : 		{
; 1150 : 			iValue = pLoopArea->getNumTiles();

	mov	ecx, edi
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles

; 1151 : 
; 1152 : 			if(iValue > iBestValue)

	cmp	eax, ebx
	jle	SHORT $LN4@findBigges

; 1153 : 			{
; 1154 : 				iBestValue = iValue;

	mov	ebx, eax

; 1155 : 				pBestArea = pLoopArea;

	mov	DWORD PTR _pBestArea$[esp+24], edi
$LN4@findBigges:
	mov	ecx, DWORD PTR [esi+12]
	inc	ecx
	cmp	ebp, ecx
	jge	SHORT $LN52@findBigges

; 1137 : 	CvArea* pLoopArea;
; 1138 : 	CvArea* pBestArea;
; 1139 : 	int iValue;
; 1140 : 	int iBestValue;
; 1141 : 	int iLoop;
; 1142 : 
; 1143 : 	iBestValue = 0;
; 1144 : 	pBestArea = NULL;
; 1145 : 
; 1146 : 	for(pLoopArea = firstArea(&iLoop); pLoopArea != NULL; pLoopArea = nextArea(&iLoop))

$LL29@findBigges:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+16]
	push	ebp
	mov	ecx, esi
	call	eax
	inc	ebp
	test	eax, eax
	jne	SHORT $LN30@findBigges
	mov	ecx, DWORD PTR [esi+12]
	inc	ecx
	cmp	ebp, ecx
	jl	SHORT $LL29@findBigges
$LN52@findBigges:
	xor	eax, eax
$LN30@findBigges:
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL5@findBigges

; 1156 : 			}
; 1157 : 		}
; 1158 : 	}
; 1159 : 
; 1160 : 	return pBestArea;

	mov	eax, DWORD PTR _pBestArea$[esp+24]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1161 : }

	add	esp, 8
	ret	4
$LN51@findBigges:
	pop	edi
	pop	esi

; 1156 : 			}
; 1157 : 		}
; 1158 : 	}
; 1159 : 
; 1160 : 	return pBestArea;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 1161 : }

	add	esp, 8
	ret	4
?findBiggestArea@CvMap@@QAEPAVCvArea@@_N@Z ENDP		; CvMap::findBiggestArea
_TEXT	ENDS
PUBLIC	?getNumLandAreas@CvMap@@QAEHXZ			; CvMap::getNumLandAreas
; Function compile flags: /Ogtpy
;	COMDAT ?getNumLandAreas@CvMap@@QAEHXZ
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
?getNumLandAreas@CvMap@@QAEHXZ PROC			; CvMap::getNumLandAreas, COMDAT
; _this$ = ecx

; 1433 : {

	push	ecx

; 1434 : 	CvArea* pLoopArea;
; 1435 : 	int iNumLandAreas;
; 1436 : 	int iLoop;
; 1437 : 
; 1438 : 	iNumLandAreas = 0;
; 1439 : 
; 1440 : 	for(pLoopArea = GC.getMap().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMap().nextArea(&iLoop))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	lea	eax, DWORD PTR _iLoop$[esp+8]
	push	eax
	add	ecx, 4112				; 00001010H
	xor	ebx, ebx
	call	?BeginIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ; FFreeListArrayBase<CvArea>::BeginIter
	test	eax, eax
	je	SHORT $LN54@getNumLand
	push	esi
	push	edi
	mov	edi, DWORD PTR _iLoop$[esp+16]
$LL4@getNumLand:

; 1441 : 	{
; 1442 : 		if(!(pLoopArea->isWater()))

	mov	ecx, eax
	call	?isWater@CvArea@@QBE_NXZ		; CvArea::isWater
	test	al, al
	jne	SHORT $LN3@getNumLand

; 1443 : 		{
; 1444 : 			iNumLandAreas++;

	inc	ebx
$LN3@getNumLand:

; 1434 : 	CvArea* pLoopArea;
; 1435 : 	int iNumLandAreas;
; 1436 : 	int iLoop;
; 1437 : 
; 1438 : 	iNumLandAreas = 0;
; 1439 : 
; 1440 : 	for(pLoopArea = GC.getMap().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMap().nextArea(&iLoop))

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [esi+4124]
	add	esi, 4112				; 00001010H
	inc	ecx
	cmp	edi, ecx
	jge	SHORT $LN30@getNumLand
$LL32@getNumLand:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+16]
	push	edi
	mov	ecx, esi
	call	eax
	inc	edi
	test	eax, eax
	jne	SHORT $LL4@getNumLand
	mov	ecx, DWORD PTR [esi+12]
	inc	ecx
	cmp	edi, ecx
	jl	SHORT $LL32@getNumLand
$LN30@getNumLand:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LL4@getNumLand
	pop	edi
	pop	esi
$LN54@getNumLand:

; 1445 : 		}
; 1446 : 	}
; 1447 : 
; 1448 : 	return iNumLandAreas;

	mov	eax, ebx
	pop	ebx

; 1449 : }

	pop	ecx
	ret	0
?getNumLandAreas@CvMap@@QAEHXZ ENDP			; CvMap::getNumLandAreas
_TEXT	ENDS
PUBLIC	?recalculateAreas@CvMap@@QAEXXZ			; CvMap::recalculateAreas
; Function compile flags: /Ogtpy
;	COMDAT ?recalculateAreas@CvMap@@QAEXXZ
_TEXT	SEGMENT
?recalculateAreas@CvMap@@QAEXXZ PROC			; CvMap::recalculateAreas, COMDAT
; _this$ = ecx

; 1489 : {

	push	ebx
	push	esi
	mov	esi, ecx

; 1490 : 	int iI;
; 1491 : 
; 1492 : 	int iNumPlots = numPlots();

	mov	ebx, DWORD PTR [esi+4028]
	push	edi

; 1493 : 	for(iI = 0; iI < iNumPlots; iI++)

	test	ebx, ebx
	jle	SHORT $LN1@recalculat@2

; 1490 : 	int iI;
; 1491 : 
; 1492 : 	int iNumPlots = numPlots();

	xor	edi, edi
$LL3@recalculat@2:

; 1494 : 	{
; 1495 : 		plotByIndexUnchecked(iI)->setArea(FFreeList::INVALID_INDEX);

	mov	ecx, DWORD PTR [esi+4068]
	push	-1
	add	ecx, edi
	call	?setArea@CvPlot@@QAEXH@Z		; CvPlot::setArea
	add	edi, 484				; 000001e4H
	sub	ebx, 1
	jne	SHORT $LL3@recalculat@2
$LN1@recalculat@2:

; 1496 : 	}
; 1497 : 
; 1498 : 	m_areas.RemoveAll();

	mov	eax, DWORD PTR [esi+4112]
	mov	edx, DWORD PTR [eax+20]
	lea	ecx, DWORD PTR [esi+4112]
	call	edx

; 1499 : 
; 1500 : 	calculateAreas();

	mov	ecx, esi
	call	?calculateAreas@CvMap@@QAEXXZ		; CvMap::calculateAreas

; 1501 : 
; 1502 : 	recalculateLandmasses();

	mov	ebx, DWORD PTR [esi+4028]
	test	ebx, ebx
	jle	SHORT $LN10@recalculat@2

; 1496 : 	}
; 1497 : 
; 1498 : 	m_areas.RemoveAll();

	xor	edi, edi
	npad	1

; 1501 : 
; 1502 : 	recalculateLandmasses();

$LL12@recalculat@2:
	mov	ecx, DWORD PTR [esi+4068]
	push	-1
	add	ecx, edi
	call	?setLandmass@CvPlot@@QAEXH@Z		; CvPlot::setLandmass
	add	edi, 484				; 000001e4H
	sub	ebx, 1
	jne	SHORT $LL12@recalculat@2
$LN10@recalculat@2:
	mov	eax, DWORD PTR [esi+4140]
	mov	edx, DWORD PTR [eax+20]
	lea	ecx, DWORD PTR [esi+4140]
	call	edx
	pop	edi
	mov	ecx, esi
	pop	esi
	pop	ebx
	jmp	?calculateLandmasses@CvMap@@QAEXXZ	; CvMap::calculateLandmasses
?recalculateAreas@CvMap@@QAEXXZ ENDP			; CvMap::recalculateAreas
_TEXT	ENDS
PUBLIC	?Read@CvMap@@QAEXAAVFDataStream@@@Z		; CvMap::Read
EXTRN	?read@CvPlot@@QAEXAAVFDataStream@@@Z:PROC	; CvPlot::read
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvMap@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -32					; size = 4
_wrapm_guid$ = -28					; size = 8
_defaultMapData$ = -20					; size = 20
_kStream$ = 8						; size = 4
?Read@CvMap@@QAEXAAVFDataStream@@@Z PROC		; CvMap::Read, COMDAT
; _this$ = ecx

; 1547 : {

	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp

; 1548 : 	CvMapInitData defaultMapData;

	xor	eax, eax
	push	esi
	mov	DWORD PTR _defaultMapData$[esp+44], eax
	mov	DWORD PTR _defaultMapData$[esp+48], eax
	mov	BYTE PTR _defaultMapData$[esp+61], al
	push	edi

; 1549 : 
; 1550 : 	// Init data before load
; 1551 : 	reset(&defaultMapData);

	lea	eax, DWORD PTR _defaultMapData$[esp+48]
	push	eax
	mov	esi, ecx
	mov	DWORD PTR _defaultMapData$[esp+60], 90	; 0000005aH
	mov	DWORD PTR _defaultMapData$[esp+64], -90	; ffffffa6H
	mov	BYTE PTR _defaultMapData$[esp+68], 1
	call	?reset@CvMap@@QAEXPAUCvMapInitData@@@Z	; CvMap::reset

; 1552 : 
; 1553 : 	// Version number to maintain backwards compatibility
; 1554 : 	uint uiVersion;
; 1555 : 	kStream >> uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+44]
	lea	ecx, DWORD PTR _uiVersion$[esp+48]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 1556 : 
; 1557 : 	kStream >> m_iGridWidth;

	lea	ebx, DWORD PTR [esi+4020]
	push	ebx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1558 : 	kStream >> m_iGridHeight;

	lea	ebp, DWORD PTR [esi+4024]
	push	ebp
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1559 : 	m_iGridSize = m_iGridHeight * m_iGridWidth;

	mov	edx, DWORD PTR [ebp]
	imul	edx, DWORD PTR [ebx]

; 1560 : 	kStream >> m_iLandPlots;

	lea	eax, DWORD PTR [esi+4032]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR [esi+4028], edx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1561 : 	kStream >> m_iOwnedPlots;

	lea	ecx, DWORD PTR [esi+4036]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1562 : 	kStream >> m_iNumNaturalWonders;

	lea	edx, DWORD PTR [esi+4048]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1563 : 	kStream >> m_iTopLatitude;

	lea	eax, DWORD PTR [esi+4040]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1564 : 	kStream >> m_iBottomLatitude;

	lea	ecx, DWORD PTR [esi+4044]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1565 : 
; 1566 : 	kStream >> m_bWrapX;

	lea	edx, DWORD PTR [esi+4056]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 1567 : 	kStream >> m_bWrapY;

	lea	eax, DWORD PTR [esi+4057]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 1568 : 
; 1569 : 	kStream >> m_guid.Data1;

	lea	ecx, DWORD PTR [esi+4168]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAK@Z		; FDataStream::Read

; 1570 : 	kStream >> m_guid.Data2;

	lea	edx, DWORD PTR [esi+4172]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAG@Z		; FDataStream::Read

; 1571 : 	kStream >> m_guid.Data3;

	lea	eax, DWORD PTR [esi+4174]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAG@Z		; FDataStream::Read

; 1572 : 	ArrayWrapper<unsigned char> wrapm_guid(8, m_guid.Data4);
; 1573 : 	kStream >> wrapm_guid;

	lea	edx, DWORD PTR _wrapm_guid$[esp+48]
	push	edx
	lea	ecx, DWORD PTR [esi+4176]
	push	edi
	mov	DWORD PTR _wrapm_guid$[esp+56], ecx
	mov	DWORD PTR _wrapm_guid$[esp+60], 8
	call	??$?5E@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@E@@@Z ; operator>><unsigned char>
	add	esp, 8

; 1574 : 
; 1575 : 	CvAssertMsg((0 < GC.getNumResourceInfos()), "GC.getNumResourceInfos() is not greater than zero but an array is being allocated");
; 1576 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_paiNumResource, GC.getNumResourceInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	push	eax
	mov	eax, DWORD PTR [esi+4060]
	push	eax
	push	edi
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 1577 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_paiNumResourceOnLand, GC.getNumResourceInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	ecx, DWORD PTR [esi+4064]
	push	eax
	push	ecx
	push	edi
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 1578 : 
; 1579 : 	if(numPlots() > 0)

	cmp	DWORD PTR [esi+4028], 0
	jle	SHORT $LN1@Read

; 1580 : 	{
; 1581 : 		InitPlots();

	mov	ecx, esi
	call	?InitPlots@CvMap@@IAEXXZ		; CvMap::InitPlots

; 1582 : #ifdef AUI_WARNING_FIXES
; 1583 : 		for (uint iI = 0; iI < numPlots(); iI++)
; 1584 : #else
; 1585 : 		int iI;
; 1586 : 		for(iI = 0; iI < numPlots(); iI++)

	xor	ebp, ebp
	cmp	DWORD PTR [esi+4028], ebp
	jle	SHORT $LN1@Read

; 1580 : 	{
; 1581 : 		InitPlots();

	xor	ebx, ebx
	npad	4
$LL3@Read:

; 1587 : #endif
; 1588 : 		{
; 1589 : 			m_pMapPlots[iI].read(kStream);

	mov	ecx, DWORD PTR [esi+4068]
	push	edi
	add	ecx, ebx
	call	?read@CvPlot@@QAEXAAVFDataStream@@@Z	; CvPlot::read
	inc	ebp
	add	ebx, 484				; 000001e4H
	cmp	ebp, DWORD PTR [esi+4028]
	jl	SHORT $LL3@Read
$LN1@Read:

; 1590 : 		}
; 1591 : 	}
; 1592 : 
; 1593 : 	// call the read of the free list CvArea class allocations
; 1594 : 	kStream >> m_areas;

	lea	edx, DWORD PTR [esi+4112]
	push	edx
	push	edi
	call	??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z ; operator>><CvArea>

; 1595 : 
; 1596 : 	kStream >> m_landmasses;

	lea	eax, DWORD PTR [esi+4140]
	push	eax
	push	edi
	call	??$?5VCvLandmass@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvLandmass@@@@@Z ; operator>><CvLandmass>

; 1597 : 
; 1598 : 	m_iAIMapHints = 0;

	lea	eax, DWORD PTR [esi+4052]
	add	esp, 16					; 00000010H

; 1599 : 	kStream >> m_iAIMapHints;

	push	eax
	mov	ecx, edi
	mov	DWORD PTR [eax], 0
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1600 : 
; 1601 : 	setup();

	mov	ecx, esi
	call	?setup@CvMap@@IAEXXZ			; CvMap::setup

; 1602 : 
; 1603 : 	updateAdjacency();

	mov	ecx, esi
	call	?updateAdjacency@CvMap@@QAEXXZ		; CvMap::updateAdjacency

; 1604 : 
; 1605 : 	gDLL->DoMapSetup(numPlots());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi+4028]
	mov	edx, DWORD PTR [edx+20]
	push	eax
	call	edx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1606 : }

	add	esp, 32					; 00000020H
	ret	4
?Read@CvMap@@QAEXAAVFDataStream@@@Z ENDP		; CvMap::Read
_TEXT	ENDS
PUBLIC	?rebuild@CvMap@@QAEXHHHH_N0W4WorldSizeTypes@@W4ClimateTypes@@W4SeaLevelTypes@@@Z ; CvMap::rebuild
EXTRN	?setSeaLevel@CvPreGame@@YAXW4SeaLevelTypes@@@Z:PROC ; CvPreGame::setSeaLevel
EXTRN	?setClimate@CvPreGame@@YAXW4ClimateTypes@@@Z:PROC ; CvPreGame::setClimate
EXTRN	?setWorldSize@CvPreGame@@YAXW4WorldSizeTypes@@_N@Z:PROC ; CvPreGame::setWorldSize
; Function compile flags: /Ogtpy
;	COMDAT ?rebuild@CvMap@@QAEXHHHH_N0W4WorldSizeTypes@@W4ClimateTypes@@W4SeaLevelTypes@@@Z
_TEXT	SEGMENT
_initData$ = -20					; size = 20
_iGridW$ = 8						; size = 4
_iGridH$ = 12						; size = 4
_iTopLatitude$ = 16					; size = 4
_iBottomLatitude$ = 20					; size = 4
_bWrapX$ = 24						; size = 1
_bWrapY$ = 28						; size = 1
_eWorldSize$ = 32					; size = 4
_eClimate$ = 36						; size = 4
_eSeaLevel$ = 40					; size = 4
?rebuild@CvMap@@QAEXHHHH_N0W4WorldSizeTypes@@W4ClimateTypes@@W4SeaLevelTypes@@@Z PROC ; CvMap::rebuild, COMDAT
; _this$ = ecx

; 1662 : {

	sub	esp, 20					; 00000014H

; 1663 : 	CvMapInitData initData(iGridW, iGridH, iTopLatitude, iBottomLatitude, bWrapX, bWrapY);

	mov	eax, DWORD PTR _iGridW$[esp+16]
	mov	edx, DWORD PTR _iTopLatitude$[esp+16]
	push	esi
	mov	DWORD PTR _initData$[esp+24], eax
	mov	eax, DWORD PTR _iBottomLatitude$[esp+20]
	mov	esi, ecx
	mov	ecx, DWORD PTR _iGridH$[esp+20]
	mov	DWORD PTR _initData$[esp+36], eax

; 1664 : 
; 1665 : 	// Set init core data
; 1666 : 	CvPreGame::setWorldSize(eWorldSize, true);

	mov	eax, DWORD PTR _eWorldSize$[esp+20]
	mov	DWORD PTR _initData$[esp+28], ecx
	mov	cl, BYTE PTR _bWrapX$[esp+20]
	mov	DWORD PTR _initData$[esp+32], edx
	mov	dl, BYTE PTR _bWrapY$[esp+20]
	push	1
	push	eax
	mov	BYTE PTR _initData$[esp+48], cl
	mov	BYTE PTR _initData$[esp+49], dl
	call	?setWorldSize@CvPreGame@@YAXW4WorldSizeTypes@@_N@Z ; CvPreGame::setWorldSize

; 1667 : 	CvPreGame::setClimate(eClimate);

	mov	ecx, DWORD PTR _eClimate$[esp+28]
	push	ecx
	call	?setClimate@CvPreGame@@YAXW4ClimateTypes@@@Z ; CvPreGame::setClimate

; 1668 : 	CvPreGame::setSeaLevel(eSeaLevel);

	mov	edx, DWORD PTR _eSeaLevel$[esp+32]
	push	edx
	call	?setSeaLevel@CvPreGame@@YAXW4SeaLevelTypes@@@Z ; CvPreGame::setSeaLevel
	add	esp, 16					; 00000010H

; 1669 : 
; 1670 : 	// Init map
; 1671 : 	init(&initData);

	lea	eax, DWORD PTR _initData$[esp+24]
	push	eax
	mov	ecx, esi
	call	?init@CvMap@@QAEXPAUCvMapInitData@@@Z	; CvMap::init
	pop	esi

; 1672 : }

	add	esp, 20					; 00000014H
	ret	36					; 00000024H
?rebuild@CvMap@@QAEXHHHH_N0W4WorldSizeTypes@@W4ClimateTypes@@W4SeaLevelTypes@@@Z ENDP ; CvMap::rebuild
_TEXT	ENDS
PUBLIC	?DefaultContinentStamper@CvMap@@QAEXXZ		; CvMap::DefaultContinentStamper
EXTRN	?SetContinentType@CvPlot@@QAEXD@Z:PROC		; CvPlot::SetContinentType
EXTRN	?shuffleArray@@YAXPAHHAAVCvRandom@@@Z:PROC	; shuffleArray
EXTRN	?getMapRand@CvGame@@QAEAAVCvRandom@@XZ:PROC	; CvGame::getMapRand
; Function compile flags: /Ogtpy
;	COMDAT ?DefaultContinentStamper@CvMap@@QAEXXZ
_TEXT	SEGMENT
_iLoop$ = -100						; size = 4
_iNumLargeContinents$ = -96				; size = 4
_this$ = -92						; size = 4
_iY$236768 = -88					; size = 4
_iX$236767 = -84					; size = 4
_iNumTiles$236741 = -84					; size = 4
_iLargeContinentsID$ = -80				; size = 16
_iLargeContinentsSize$ = -64				; size = 16
_iLargeContinentsArtStyle$ = -48			; size = 16
_iLargeContinentsY$ = -32				; size = 16
_iLargeContinentsX$ = -16				; size = 16
?DefaultContinentStamper@CvMap@@QAEXXZ PROC		; CvMap::DefaultContinentStamper, COMDAT
; _this$ = ecx

; 2183 : {

	sub	esp, 100				; 00000064H
	push	ebx
	push	ebp
	push	esi

; 2184 : 	const int iNumContinentTypes = 4;
; 2185 : 	const int iMinimumThresholdToBeAContinentIMHO = 10;
; 2186 : 
; 2187 : 	int iNumLargeContinents = 0;
; 2188 : 	int iLargeContinentsID[iNumContinentTypes] = {-1,-1,-1,-1};

	or	esi, -1
	push	edi
	xor	edi, edi
	mov	ebp, ecx
	xor	ebx, ebx
	mov	DWORD PTR _this$[esp+116], ebp
	mov	DWORD PTR _iNumLargeContinents$[esp+116], ebx
	mov	DWORD PTR _iLargeContinentsID$[esp+116], esi
	mov	DWORD PTR _iLargeContinentsID$[esp+120], esi
	mov	DWORD PTR _iLargeContinentsID$[esp+124], esi
	mov	DWORD PTR _iLargeContinentsID$[esp+128], esi

; 2189 : 	int iLargeContinentsSize[iNumContinentTypes] = {0,0,0,0};

	mov	DWORD PTR _iLargeContinentsSize$[esp+116], edi
	mov	DWORD PTR _iLargeContinentsSize$[esp+120], edi
	mov	DWORD PTR _iLargeContinentsSize$[esp+124], edi
	mov	DWORD PTR _iLargeContinentsSize$[esp+128], edi

; 2190 : 	int iLargeContinentsArtStyle[iNumContinentTypes] = {0,0,0,0};

	mov	DWORD PTR _iLargeContinentsArtStyle$[esp+116], edi
	mov	DWORD PTR _iLargeContinentsArtStyle$[esp+120], edi
	mov	DWORD PTR _iLargeContinentsArtStyle$[esp+124], edi
	mov	DWORD PTR _iLargeContinentsArtStyle$[esp+128], edi

; 2191 : 	int iLargeContinentsX[iNumContinentTypes] = {0,0,0,0};

	mov	DWORD PTR _iLargeContinentsX$[esp+116], edi
	mov	DWORD PTR _iLargeContinentsX$[esp+120], edi
	mov	DWORD PTR _iLargeContinentsX$[esp+124], edi
	mov	DWORD PTR _iLargeContinentsX$[esp+128], edi

; 2192 : 	int iLargeContinentsY[iNumContinentTypes] = {0,0,0,0};

	mov	DWORD PTR _iLargeContinentsY$[esp+116], edi
	mov	DWORD PTR _iLargeContinentsY$[esp+120], edi
	mov	DWORD PTR _iLargeContinentsY$[esp+124], edi
	mov	DWORD PTR _iLargeContinentsY$[esp+128], edi

; 2193 : 
; 2194 : 	recalculateLandmasses();

	call	?recalculateLandmasses@CvMap@@QAEXXZ	; CvMap::recalculateLandmasses

; 2195 : 
; 2196 : 	CvLandmass* pLoopMass;
; 2197 : 	int iLoop;
; 2198 : 
; 2199 : 	// find the 4 (because that is how many art styles we have) biggest continents - if there aren't 4, oh well
; 2200 : 	for(pLoopMass = firstLandmass(&iLoop); pLoopMass != NULL; pLoopMass = nextLandmass(&iLoop))

	lea	eax, DWORD PTR _iLoop$[esp+116]
	add	ebp, 4140				; 0000102cH
	push	eax
	mov	ecx, ebp
	call	?BeginIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ; FFreeListArrayBase<CvLandmass>::BeginIter
	cmp	eax, edi
	je	$LN32@DefaultCon
	mov	ebx, DWORD PTR _iLoop$[esp+116]
	npad	5
$LL34@DefaultCon:

; 2201 : 	{
; 2202 : 		if(!pLoopMass->isWater())

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN33@DefaultCon

; 2203 : 		{
; 2204 : 			int iBestContinent;
; 2205 : 			int iNumTiles = pLoopMass->getNumTiles();

	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _iNumTiles$236741[esp+116], ecx

; 2206 : 			for(iBestContinent=0; iBestContinent<iNumContinentTypes; iBestContinent++)

	xor	edx, edx
	npad	1
$LL30@DefaultCon:

; 2207 : 			{
; 2208 : 				if(iNumTiles >= iMinimumThresholdToBeAContinentIMHO && iNumTiles > iLargeContinentsSize[iBestContinent])

	cmp	ecx, 10					; 0000000aH
	jl	SHORT $LN29@DefaultCon
	cmp	ecx, DWORD PTR _iLargeContinentsSize$[esp+edx*4+116]
	jg	SHORT $LN166@DefaultCon
$LN29@DefaultCon:

; 2206 : 			for(iBestContinent=0; iBestContinent<iNumContinentTypes; iBestContinent++)

	inc	edx
	cmp	edx, 4
	jl	SHORT $LL30@DefaultCon

; 2242 : 	}
; 2243 : 
; 2244 : 	// for all landmasses in the game
; 2245 : 	for(pLoopMass = firstLandmass(&iLoop); pLoopMass != NULL; pLoopMass = nextLandmass(&iLoop))

	jmp	SHORT $LN33@DefaultCon
$LN166@DefaultCon:

; 2209 : 				{
; 2210 : 					// push the rest of the tiles down one and store this
; 2211 : 					for(int iloop=iNumContinentTypes-1; iloop>iBestContinent; iloop--)

	cmp	edx, 3
	jge	SHORT $LN24@DefaultCon
	mov	esi, 3

; 2212 : 					{
; 2213 : 						iLargeContinentsID[iloop] = iLargeContinentsID[iloop-1];

	xor	ecx, ecx
	sub	esi, edx
$LL26@DefaultCon:
	mov	edi, DWORD PTR _iLargeContinentsID$[esp+ecx+124]
	mov	DWORD PTR _iLargeContinentsID$[esp+ecx+128], edi

; 2214 : 						iLargeContinentsSize[iloop] = iLargeContinentsSize[iloop-1];

	mov	edi, DWORD PTR _iLargeContinentsSize$[esp+ecx+124]
	mov	DWORD PTR _iLargeContinentsSize$[esp+ecx+128], edi
	sub	ecx, 4
	sub	esi, 1
	jne	SHORT $LL26@DefaultCon
	mov	ecx, DWORD PTR _iNumTiles$236741[esp+116]
	xor	edi, edi
	or	esi, -1
$LN24@DefaultCon:

; 2215 : 					}
; 2216 : 					iLargeContinentsID[iBestContinent] = pLoopMass->GetID();

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _iLargeContinentsID$[esp+edx*4+116], eax

; 2217 : 					iLargeContinentsSize[iBestContinent] = iNumTiles;

	mov	DWORD PTR _iLargeContinentsSize$[esp+edx*4+116], ecx
$LN33@DefaultCon:
	mov	ecx, DWORD PTR [ebp+12]
	inc	ecx
	cmp	ebx, ecx
	jge	SHORT $LN56@DefaultCon

; 2195 : 
; 2196 : 	CvLandmass* pLoopMass;
; 2197 : 	int iLoop;
; 2198 : 
; 2199 : 	// find the 4 (because that is how many art styles we have) biggest continents - if there aren't 4, oh well
; 2200 : 	for(pLoopMass = firstLandmass(&iLoop); pLoopMass != NULL; pLoopMass = nextLandmass(&iLoop))

$LL58@DefaultCon:
	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+16]
	push	ebx
	mov	ecx, ebp
	call	eax
	inc	ebx
	cmp	eax, edi
	jne	SHORT $LL34@DefaultCon
	mov	ecx, DWORD PTR [ebp+12]
	inc	ecx
	cmp	ebx, ecx
	jl	SHORT $LL58@DefaultCon
$LN56@DefaultCon:
	xor	eax, eax
	cmp	eax, edi
	jne	$LL34@DefaultCon
	mov	ebx, DWORD PTR _iNumLargeContinents$[esp+116]
$LN32@DefaultCon:

; 2218 : 					break;
; 2219 : 				}
; 2220 : 			}
; 2221 : 		}
; 2222 : 	}
; 2223 : 
; 2224 : 	// for each of these large continents give them unique art style (randomly)
; 2225 : 	shuffleArray(iLargeContinentsArtStyle, 4, GC.getGame().getMapRand());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getMapRand@CvGame@@QAEAAVCvRandom@@XZ	; CvGame::getMapRand
	push	eax
	lea	edx, DWORD PTR _iLargeContinentsArtStyle$[esp+120]
	push	4
	push	edx
	call	?shuffleArray@@YAXPAHHAAVCvRandom@@@Z	; shuffleArray
	add	esp, 12					; 0000000cH

; 2226 : 	for(int i=0; i < iNumContinentTypes; i++)

	xor	eax, eax
$LL23@DefaultCon:

; 2227 : 	{
; 2228 : 		iLargeContinentsArtStyle[i]++;

	inc	DWORD PTR _iLargeContinentsArtStyle$[esp+eax*4+116]
	inc	eax
	cmp	eax, 4
	jl	SHORT $LL23@DefaultCon

; 2229 : 	}
; 2230 : 
; 2231 : 	for(int i=0; i < iNumContinentTypes; i++)

	xor	eax, eax
$LL20@DefaultCon:

; 2232 : 	{
; 2233 : 		if(iLargeContinentsID[i] != -1)

	cmp	DWORD PTR _iLargeContinentsID$[esp+eax*4+116], esi
	je	SHORT $LN19@DefaultCon

; 2234 : 			iNumLargeContinents++;

	inc	ebx
$LN19@DefaultCon:

; 2229 : 	}
; 2230 : 
; 2231 : 	for(int i=0; i < iNumContinentTypes; i++)

	inc	eax
	cmp	eax, 4
	jl	SHORT $LL20@DefaultCon

; 2235 : 	}
; 2236 : 
; 2237 : 	for(int i=0; i < iNumLargeContinents; i++)

	xor	esi, esi
	cmp	ebx, edi
	mov	DWORD PTR _iNumLargeContinents$[esp+116], ebx
	jle	SHORT $LN14@DefaultCon
	npad	5
$LL16@DefaultCon:

; 2238 : 	{
; 2239 : 		CvLandmass* pLandmass = getLandmass(iLargeContinentsID[i]);

	mov	ecx, DWORD PTR _iLargeContinentsID$[esp+esi*4+116]
	mov	eax, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, ebp
	call	edx
	mov	ebx, eax

; 2240 : 		iLargeContinentsX[i] = pLandmass->GetCentroidX();

	mov	ecx, DWORD PTR [ebx+8]
	cmp	ecx, edi
	jle	SHORT $LN79@DefaultCon
	mov	eax, DWORD PTR [ebx+16]
	cdq
	idiv	ecx
	jmp	SHORT $LN80@DefaultCon
$LN79@DefaultCon:
	or	eax, -1
$LN80@DefaultCon:

; 2241 : 		iLargeContinentsY[i] = pLandmass->GetCentroidY();

	cmp	ecx, edi
	mov	DWORD PTR _iLargeContinentsX$[esp+esi*4+116], eax
	jle	SHORT $LN82@DefaultCon
	mov	eax, DWORD PTR [ebx+20]
	cdq
	idiv	ecx
	jmp	SHORT $LN83@DefaultCon
$LN82@DefaultCon:
	or	eax, -1
$LN83@DefaultCon:
	mov	DWORD PTR _iLargeContinentsY$[esp+esi*4+116], eax
	inc	esi
	cmp	esi, DWORD PTR _iNumLargeContinents$[esp+116]
	jl	SHORT $LL16@DefaultCon
$LN14@DefaultCon:

; 2242 : 	}
; 2243 : 
; 2244 : 	// for all landmasses in the game
; 2245 : 	for(pLoopMass = firstLandmass(&iLoop); pLoopMass != NULL; pLoopMass = nextLandmass(&iLoop))

	mov	eax, DWORD PTR [ebp+12]
	xor	esi, esi
	inc	eax
	mov	DWORD PTR _iLoop$[esp+116], esi
	test	eax, eax
	jle	SHORT $LN92@DefaultCon
	npad	1
$LL94@DefaultCon:
	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+16]
	push	esi
	mov	ecx, ebp
	call	eax
	inc	esi
	cmp	eax, edi
	jne	SHORT $LN169@DefaultCon
	mov	ecx, DWORD PTR [ebp+12]
	inc	ecx
	cmp	esi, ecx
	jl	SHORT $LL94@DefaultCon
	mov	DWORD PTR _iLoop$[esp+116], esi
$LN92@DefaultCon:
	xor	eax, eax
$LN95@DefaultCon:
	mov	ebx, eax
	cmp	eax, edi
	je	$LN11@DefaultCon
$LL13@DefaultCon:

; 2246 : 	{
; 2247 : 		int iX = pLoopMass->GetCentroidX();

	mov	ecx, DWORD PTR [ebx+8]
	cmp	ecx, edi
	jle	SHORT $LN127@DefaultCon
	mov	eax, DWORD PTR [ebx+16]
	cdq
	idiv	ecx
	mov	DWORD PTR _iX$236767[esp+116], eax
	jmp	SHORT $LN128@DefaultCon
$LN169@DefaultCon:

; 2242 : 	}
; 2243 : 
; 2244 : 	// for all landmasses in the game
; 2245 : 	for(pLoopMass = firstLandmass(&iLoop); pLoopMass != NULL; pLoopMass = nextLandmass(&iLoop))

	mov	DWORD PTR _iLoop$[esp+116], esi
	jmp	SHORT $LN95@DefaultCon

; 2246 : 	{
; 2247 : 		int iX = pLoopMass->GetCentroidX();

$LN127@DefaultCon:
	mov	DWORD PTR _iX$236767[esp+116], -1
$LN128@DefaultCon:

; 2248 : 		int iY = pLoopMass->GetCentroidY();

	cmp	ecx, edi
	jle	SHORT $LN130@DefaultCon
	mov	eax, DWORD PTR [ebx+20]
	cdq
	idiv	ecx
	mov	DWORD PTR _iY$236768[esp+116], eax
	jmp	SHORT $LN131@DefaultCon
$LN130@DefaultCon:
	mov	DWORD PTR _iY$236768[esp+116], -1
$LN131@DefaultCon:

; 2249 : 		// if water continent type = 0
; 2250 : 		if(pLoopMass->isWater())

	cmp	BYTE PTR [ebx+13], 0
	je	SHORT $LN10@DefaultCon

; 2251 : 		{
; 2252 : 			pLoopMass->SetContinentType(0);

	mov	BYTE PTR [ebx+12], 0

; 2253 : 		}
; 2254 : 		else // if land

	jmp	SHORT $LN12@DefaultCon
$LN10@DefaultCon:

; 2255 : 		{
; 2256 : 			// continent type = continent type of the closest of the "big four"
; 2257 : 			int iBestPlotDistance = 999999;
; 2258 : 			for(int i=0; i < iNumLargeContinents; i++)

	xor	esi, esi
	cmp	DWORD PTR _iNumLargeContinents$[esp+116], esi
	mov	edi, 999999				; 000f423fH
	jle	SHORT $LN191@DefaultCon
	npad	6
$LL190@DefaultCon:

; 2259 : 			{
; 2260 : 				int iPlotDistance = plotDistance(iX, iY, iLargeContinentsX[i], iLargeContinentsY[i]);

	mov	edx, DWORD PTR _iLargeContinentsY$[esp+esi*4+116]
	mov	eax, DWORD PTR _iLargeContinentsX$[esp+esi*4+116]
	mov	ecx, DWORD PTR _iY$236768[esp+116]
	push	edx
	mov	edx, DWORD PTR _iX$236767[esp+120]
	push	eax
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 2261 : 				if(iPlotDistance < iBestPlotDistance)

	cmp	eax, edi
	jge	SHORT $LN7@DefaultCon

; 2262 : 				{
; 2263 : 					iBestPlotDistance = iPlotDistance;

	mov	edi, eax

; 2264 : 					pLoopMass->SetContinentType(iLargeContinentsArtStyle[i]);

	mov	al, BYTE PTR _iLargeContinentsArtStyle$[esp+esi*4+116]
	mov	BYTE PTR [ebx+12], al
$LN7@DefaultCon:
	inc	esi
	cmp	esi, DWORD PTR _iNumLargeContinents$[esp+116]
	jl	SHORT $LL190@DefaultCon
$LN191@DefaultCon:

; 2255 : 		{
; 2256 : 			// continent type = continent type of the closest of the "big four"
; 2257 : 			int iBestPlotDistance = 999999;
; 2258 : 			for(int i=0; i < iNumLargeContinents; i++)

	mov	esi, DWORD PTR _iLoop$[esp+116]
	xor	edi, edi
$LN12@DefaultCon:
	mov	ecx, DWORD PTR [ebp+12]
	inc	ecx
	cmp	esi, ecx
	jge	SHORT $LN114@DefaultCon
	npad	2

; 2242 : 	}
; 2243 : 
; 2244 : 	// for all landmasses in the game
; 2245 : 	for(pLoopMass = firstLandmass(&iLoop); pLoopMass != NULL; pLoopMass = nextLandmass(&iLoop))

$LL116@DefaultCon:
	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+16]
	push	esi
	mov	ecx, ebp
	call	eax
	inc	esi
	cmp	eax, edi
	jne	SHORT $LN171@DefaultCon
	mov	ecx, DWORD PTR [ebp+12]
	inc	ecx
	cmp	esi, ecx
	jl	SHORT $LL116@DefaultCon
	mov	DWORD PTR _iLoop$[esp+116], esi
$LN114@DefaultCon:
	xor	eax, eax
$LN117@DefaultCon:
	mov	ebx, eax
	cmp	ebx, edi
	jne	$LL13@DefaultCon
$LN11@DefaultCon:

; 2265 : 				}
; 2266 : 			}
; 2267 : 		}
; 2268 : 	}
; 2269 : 
; 2270 : 	// now stamp all plots with the relevant data
; 2271 : #ifdef AUI_WARNING_FIXES
; 2272 : 	for (uint iI = 0; iI < numPlots(); iI++)
; 2273 : #else
; 2274 : 	for(int iI = 0; iI < numPlots(); iI++)

	mov	edx, DWORD PTR _this$[esp+116]
	cmp	DWORD PTR [edx+4028], 0
	jle	SHORT $LN2@DefaultCon
	xor	ebx, ebx
	npad	9
$LL192@DefaultCon:

; 2275 : #endif
; 2276 : 	{
; 2277 : 		CvPlot* pLoopPlot = plotByIndexUnchecked(iI);

	mov	eax, DWORD PTR _this$[esp+116]
	mov	esi, DWORD PTR [eax+4068]

; 2278 : 		CvLandmass* pLandmass = getLandmass(pLoopPlot->getLandmass());

	mov	eax, DWORD PTR [esi+ebx+360]
	mov	edx, DWORD PTR [ebp]
	add	esi, ebx
	push	eax
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, ebp
	call	eax

; 2279 : 		if(pLandmass != NULL)

	test	eax, eax
	je	SHORT $LN3@DefaultCon

; 2280 : 		{
; 2281 : 			pLoopPlot->SetContinentType(pLandmass->GetContinentType());

	movzx	ecx, BYTE PTR [eax+12]
	push	ecx
	mov	ecx, esi
	call	?SetContinentType@CvPlot@@QAEXD@Z	; CvPlot::SetContinentType
$LN3@DefaultCon:
	mov	edx, DWORD PTR _this$[esp+116]
	inc	edi
	add	ebx, 484				; 000001e4H
	cmp	edi, DWORD PTR [edx+4028]
	jl	SHORT $LL192@DefaultCon
$LN2@DefaultCon:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2282 : 		}
; 2283 : 	}
; 2284 : }

	add	esp, 100				; 00000064H
	ret	0
$LN171@DefaultCon:

; 2242 : 	}
; 2243 : 
; 2244 : 	// for all landmasses in the game
; 2245 : 	for(pLoopMass = firstLandmass(&iLoop); pLoopMass != NULL; pLoopMass = nextLandmass(&iLoop))

	mov	DWORD PTR _iLoop$[esp+116], esi
	jmp	SHORT $LN117@DefaultCon
?DefaultContinentStamper@CvMap@@QAEXXZ ENDP		; CvMap::DefaultContinentStamper
_TEXT	ENDS
PUBLIC	?getNumLandLandmasses@CvMap@@QAEHXZ		; CvMap::getNumLandLandmasses
; Function compile flags: /Ogtpy
;	COMDAT ?getNumLandLandmasses@CvMap@@QAEHXZ
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
?getNumLandLandmasses@CvMap@@QAEHXZ PROC		; CvMap::getNumLandLandmasses, COMDAT
; _this$ = ecx

; 2302 : {

	push	ecx

; 2303 : 	CvLandmass* pLoopLandmass;
; 2304 : 	int iNumLandLandmasses;
; 2305 : 	int iLoop;
; 2306 : 
; 2307 : 	iNumLandLandmasses = 0;
; 2308 : 
; 2309 : 	for(pLoopLandmass = GC.getMap().firstLandmass(&iLoop); pLoopLandmass != NULL; pLoopLandmass = GC.getMap().nextLandmass(&iLoop))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	lea	eax, DWORD PTR _iLoop$[esp+8]
	push	eax
	add	ecx, 4140				; 0000102cH
	xor	ebx, ebx
	call	?BeginIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ; FFreeListArrayBase<CvLandmass>::BeginIter
	test	eax, eax
	je	SHORT $LN56@getNumLand@2
	push	esi
	push	edi
	mov	edi, DWORD PTR _iLoop$[esp+16]
$LL4@getNumLand@2:

; 2310 : 	{
; 2311 : 		if(!(pLoopLandmass->isWater()))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN3@getNumLand@2

; 2312 : 		{
; 2313 : 			iNumLandLandmasses++;

	inc	ebx
$LN3@getNumLand@2:

; 2303 : 	CvLandmass* pLoopLandmass;
; 2304 : 	int iNumLandLandmasses;
; 2305 : 	int iLoop;
; 2306 : 
; 2307 : 	iNumLandLandmasses = 0;
; 2308 : 
; 2309 : 	for(pLoopLandmass = GC.getMap().firstLandmass(&iLoop); pLoopLandmass != NULL; pLoopLandmass = GC.getMap().nextLandmass(&iLoop))

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [esi+4152]
	add	esi, 4140				; 0000102cH
	inc	ecx
	cmp	edi, ecx
	jge	SHORT $LN30@getNumLand@2
$LL32@getNumLand@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+16]
	push	edi
	mov	ecx, esi
	call	eax
	inc	edi
	test	eax, eax
	jne	SHORT $LL4@getNumLand@2
	mov	ecx, DWORD PTR [esi+12]
	inc	ecx
	cmp	edi, ecx
	jl	SHORT $LL32@getNumLand@2
$LN30@getNumLand@2:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LL4@getNumLand@2
	pop	edi
	pop	esi
$LN56@getNumLand@2:

; 2314 : 		}
; 2315 : 	}
; 2316 : 
; 2317 : 	return iNumLandLandmasses;

	mov	eax, ebx
	pop	ebx

; 2318 : }

	pop	ecx
	ret	0
?getNumLandLandmasses@CvMap@@QAEHXZ ENDP		; CvMap::getNumLandLandmasses
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvMap@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvMap@@UAEPAXI@Z PROC				; CvMap::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvMap@@UAE@XZ			; CvMap::~CvMap
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@7
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@7:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvMap@@UAEPAXI@Z ENDP				; CvMap::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?setAllPlotTypes@CvMap@@QAEXW4PlotTypes@@@Z	; CvMap::setAllPlotTypes
; Function compile flags: /Ogtpy
;	COMDAT ?setAllPlotTypes@CvMap@@QAEXW4PlotTypes@@@Z
_TEXT	SEGMENT
_ePlotType$ = 8						; size = 4
?setAllPlotTypes@CvMap@@QAEXW4PlotTypes@@@Z PROC	; CvMap::setAllPlotTypes, COMDAT
; _this$ = ecx

; 605  : {

	push	esi
	push	edi
	mov	esi, ecx

; 606  : 
; 607  : #ifdef AUI_WARNING_FIXES
; 608  : 	for (uint i = 0; i < numPlots(); i++)
; 609  : #else
; 610  : 	for(int i=0; i<numPlots(); i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+4028], edi
	jle	SHORT $LN1@setAllPlot
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _ePlotType$[esp+12]
	xor	ebx, ebx
$LL12@setAllPlot:

; 611  : #endif
; 612  : 	{
; 613  : 		plotByIndexUnchecked(i)->setPlotType(ePlotType, false, false);

	mov	ecx, DWORD PTR [esi+4068]
	push	1
	push	0
	push	0
	push	ebp
	add	ecx, ebx
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType
	inc	edi
	add	ebx, 484				; 000001e4H
	cmp	edi, DWORD PTR [esi+4028]
	jl	SHORT $LL12@setAllPlot
	pop	ebp
	pop	ebx
$LN1@setAllPlot:

; 614  : 	}
; 615  : 
; 616  : 	recalculateAreas();

	mov	ecx, esi
	call	?recalculateAreas@CvMap@@QAEXXZ		; CvMap::recalculateAreas
	pop	edi
	pop	esi

; 617  : }

	ret	4
?setAllPlotTypes@CvMap@@QAEXW4PlotTypes@@@Z ENDP	; CvMap::setAllPlotTypes
_TEXT	ENDS
END
