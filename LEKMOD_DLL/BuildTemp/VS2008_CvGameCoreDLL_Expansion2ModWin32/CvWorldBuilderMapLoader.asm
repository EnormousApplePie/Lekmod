; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvWorldBuilderMapLoader.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
PUBLIC	?FileVersion@CvWorldBuilderMap@@2IB		; CvWorldBuilderMap::FileVersion
PUBLIC	?MaxMapSize@CvWorldBuilderMap@@2IB		; CvWorldBuilderMap::MaxMapSize
PUBLIC	?MaxPlayers@CvWorldBuilderMap@@2IB		; CvWorldBuilderMap::MaxPlayers
PUBLIC	?MaxCityStates@CvWorldBuilderMap@@2IB		; CvWorldBuilderMap::MaxCityStates
PUBLIC	?MaxTeams@CvWorldBuilderMap@@2IB		; CvWorldBuilderMap::MaxTeams
PUBLIC	?BarbarianPlayer@CvWorldBuilderMap@@2IB		; CvWorldBuilderMap::BarbarianPlayer
PUBLIC	?InvalidResource@PlotMapData@CvWorldBuilderMap@@2EB ; CvWorldBuilderMap::PlotMapData::InvalidResource
PUBLIC	?InvalidFeature@PlotMapData@CvWorldBuilderMap@@2EB ; CvWorldBuilderMap::PlotMapData::InvalidFeature
PUBLIC	?InvalidNaturalWonder@PlotMapData@CvWorldBuilderMap@@2EB ; CvWorldBuilderMap::PlotMapData::InvalidNaturalWonder
PUBLIC	?InvalidUnitType@OldUnit@CvWorldBuilderMap@@2EB	; CvWorldBuilderMap::OldUnit::InvalidUnitType
PUBLIC	?MaxLength@UnitName@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::UnitName::MaxLength
PUBLIC	?InvalidUnitType@UnitV2@CvWorldBuilderMap@@2EB	; CvWorldBuilderMap::UnitV2::InvalidUnitType
PUBLIC	?MaxPromotionTypes@UnitV2@CvWorldBuilderMap@@2IB ; CvWorldBuilderMap::UnitV2::MaxPromotionTypes
PUBLIC	?MaxHealth@UnitV2@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::UnitV2::MaxHealth
PUBLIC	?InvalidUnitType@Unit@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::Unit::InvalidUnitType
PUBLIC	?MaxPromotionTypes@Unit@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::Unit::MaxPromotionTypes
PUBLIC	?MaxHealth@Unit@CvWorldBuilderMap@@2IB		; CvWorldBuilderMap::Unit::MaxHealth
PUBLIC	?MaxBuildingTypes@OldCity@CvWorldBuilderMap@@2IB ; CvWorldBuilderMap::OldCity::MaxBuildingTypes
PUBLIC	?MaxBuildingTypes@CityV2@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::CityV2::MaxBuildingTypes
PUBLIC	?MaxNameLength@CityV2@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::CityV2::MaxNameLength
PUBLIC	?MaxHealth@CityV2@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::CityV2::MaxHealth
PUBLIC	?MaxBuildingTypes@City@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::City::MaxBuildingTypes
PUBLIC	?MaxNameLength@City@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::City::MaxNameLength
PUBLIC	?MaxHealth@City@CvWorldBuilderMap@@2IB		; CvWorldBuilderMap::City::MaxHealth
PUBLIC	?InvalidCulture@PlotScenarioData@CvWorldBuilderMap@@2EB ; CvWorldBuilderMap::PlotScenarioData::InvalidCulture
PUBLIC	?InvalidImprovement@PlotScenarioData@CvWorldBuilderMap@@2EB ; CvWorldBuilderMap::PlotScenarioData::InvalidImprovement
PUBLIC	?InvalidRoute@PlotScenarioData@CvWorldBuilderMap@@2EB ; CvWorldBuilderMap::PlotScenarioData::InvalidRoute
PUBLIC	?MaxTechs@Team@CvWorldBuilderMap@@2IB		; CvWorldBuilderMap::Team::MaxTechs
PUBLIC	?MaxPolicies@OldPlayer@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::OldPlayer::MaxPolicies
PUBLIC	?InvalidTeam@OldPlayer@CvWorldBuilderMap@@2EB	; CvWorldBuilderMap::OldPlayer::InvalidTeam
PUBLIC	?MaxPolicies@Player@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::Player::MaxPolicies
PUBLIC	?InvalidTeam@Player@CvWorldBuilderMap@@2EB	; CvWorldBuilderMap::Player::InvalidTeam
PUBLIC	?BitCount@?$FRelationshipBitset@$0GA@$00@@0IB	; FRelationshipBitset<96,1>::BitCount
PUBLIC	?ByteCount@?$FRelationshipBitset@$0GA@$00@@0IB	; FRelationshipBitset<96,1>::ByteCount
PUBLIC	?BitCount@?$FRelationshipBitset@$0GA@$0A@@@0IB	; FRelationshipBitset<96,0>::BitCount
PUBLIC	?ByteCount@?$FRelationshipBitset@$0GA@$0A@@@0IB	; FRelationshipBitset<96,0>::ByteCount
PUBLIC	?ByteCount@?$SerializableBitset@$0DAAAAA@@CvWorldBuilderMap@@0IB ; CvWorldBuilderMap::SerializableBitset<3145728>::ByteCount
_BSS	SEGMENT
_sg_wszTempMapName DW 0104H DUP (?)
_BSS	ENDS
CONST	SEGMENT
$SG224580 DB	'Picking Random Unit Direction', 00H
$SG225086 DB	00H
$SG225163 DB	00H
$SG224727 DB	'Setting up players...', 0aH, 00H
$SG225165 DB	00H
$SG224937 DB	'Setting up map...', 0aH, 00H
$SG225194 DB	00H
$SG224971 DB	'Calculating Areas...', 0aH, 00H
$SG225196 DB	00H
$SG225437 DB	00H
$SG224972 DB	'Adding Scenario Elements...', 0aH, 00H
$SG225468 DB	00H
	ORG $+2
$SG225057 DB	'Map Load Success!', 0aH, 00H
	ORG $+1
$SG225131 DB	'MapModData', 00H
	ORG $+1
$SG225140 DB	'Globals', 00H
$SG225167 DB	'Globals', 00H
$SG225199 DB	'Plots', 00H
	ORG $+2
$SG225234 DB	'Plots', 00H
	ORG $+2
$SG225251 DB	'PostProcessMapScript', 00H
	ORG $+3
$SG225263 DB	'PostProcessMap', 00H
	ORG $+1
$SG225345 DB	'Select ID from Worlds where Type = ? LIMIT 1', 00H
	ORG $+3
$SG225353 DB	'Worlds', 00H
	ORG $+1
$SG225453 DB	'MapSize', 00H
$SG225454 DB	'Name', 00H
	ORG $+3
$SG225455 DB	'Description', 00H
$SG225456 DB	'PlayerCount', 00H
$SG225457 DB	'CityStateCount', 00H
	ORG $+1
$SG225458 DB	'MaxTurns', 00H
	ORG $+3
$SG225459 DB	'StartEra', 00H
	ORG $+3
$SG225460 DB	'DefaultSpeed', 00H
	ORG $+3
$SG225462 DB	'VictoryTypes', 00H
	ORG $+3
$SG225508 DB	'CivType', 00H
$SG225509 DB	'Playable', 00H
	ORG $+3
$SG225510 DB	'DefaultHandicap', 00H
$SG225523 DB	'WorldBuilderRandomItems.lua', 00H
$SG225528 DB	'AddGoodies', 00H
	ORG $+1
$SG225533 DB	'AddResourcesForWorldBuilderMap', 00H
	ORG $+1
$SG225544 DB	'WorldBuilderRandomItems.lua', 00H
$SG225546 DB	'AddResourcesForWorldBuilderMap', 00H
	ORG $+1
$SG225557 DB	'WorldBuilderRandomItems.lua', 00H
$SG225559 DB	'AddGoodies', 00H
CONST	ENDS
;	COMDAT ?ByteCount@?$SerializableBitset@$0DAAAAA@@CvWorldBuilderMap@@0IB
CONST	SEGMENT
?ByteCount@?$SerializableBitset@$0DAAAAA@@CvWorldBuilderMap@@0IB DD 060000H ; CvWorldBuilderMap::SerializableBitset<3145728>::ByteCount
CONST	ENDS
;	COMDAT ?ByteCount@?$FRelationshipBitset@$0GA@$0A@@@0IB
CONST	SEGMENT
?ByteCount@?$FRelationshipBitset@$0GA@$0A@@@0IB DD 023aH ; FRelationshipBitset<96,0>::ByteCount
CONST	ENDS
;	COMDAT ?BitCount@?$FRelationshipBitset@$0GA@$0A@@@0IB
CONST	SEGMENT
?BitCount@?$FRelationshipBitset@$0GA@$0A@@@0IB DD 011d0H ; FRelationshipBitset<96,0>::BitCount
CONST	ENDS
;	COMDAT ?ByteCount@?$FRelationshipBitset@$0GA@$00@@0IB
CONST	SEGMENT
?ByteCount@?$FRelationshipBitset@$0GA@$00@@0IB DD 023aH	; FRelationshipBitset<96,1>::ByteCount
CONST	ENDS
;	COMDAT ?BitCount@?$FRelationshipBitset@$0GA@$00@@0IB
CONST	SEGMENT
?BitCount@?$FRelationshipBitset@$0GA@$00@@0IB DD 011d0H	; FRelationshipBitset<96,1>::BitCount
CONST	ENDS
;	COMDAT ?InvalidTeam@Player@CvWorldBuilderMap@@2EB
CONST	SEGMENT
?InvalidTeam@Player@CvWorldBuilderMap@@2EB DB 0ffH	; CvWorldBuilderMap::Player::InvalidTeam
CONST	ENDS
;	COMDAT ?MaxPolicies@Player@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxPolicies@Player@CvWorldBuilderMap@@2IB DD 0100H	; CvWorldBuilderMap::Player::MaxPolicies
CONST	ENDS
;	COMDAT ?InvalidTeam@OldPlayer@CvWorldBuilderMap@@2EB
CONST	SEGMENT
?InvalidTeam@OldPlayer@CvWorldBuilderMap@@2EB DB 0ffH	; CvWorldBuilderMap::OldPlayer::InvalidTeam
CONST	ENDS
;	COMDAT ?MaxPolicies@OldPlayer@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxPolicies@OldPlayer@CvWorldBuilderMap@@2IB DD 0100H	; CvWorldBuilderMap::OldPlayer::MaxPolicies
CONST	ENDS
;	COMDAT ?MaxTechs@Team@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxTechs@Team@CvWorldBuilderMap@@2IB DD 0100H		; CvWorldBuilderMap::Team::MaxTechs
CONST	ENDS
;	COMDAT ?InvalidRoute@PlotScenarioData@CvWorldBuilderMap@@2EB
CONST	SEGMENT
?InvalidRoute@PlotScenarioData@CvWorldBuilderMap@@2EB DB 0ffH ; CvWorldBuilderMap::PlotScenarioData::InvalidRoute
CONST	ENDS
;	COMDAT ?InvalidImprovement@PlotScenarioData@CvWorldBuilderMap@@2EB
CONST	SEGMENT
?InvalidImprovement@PlotScenarioData@CvWorldBuilderMap@@2EB DB 0ffH ; CvWorldBuilderMap::PlotScenarioData::InvalidImprovement
CONST	ENDS
;	COMDAT ?InvalidCulture@PlotScenarioData@CvWorldBuilderMap@@2EB
CONST	SEGMENT
?InvalidCulture@PlotScenarioData@CvWorldBuilderMap@@2EB DB 0ffH ; CvWorldBuilderMap::PlotScenarioData::InvalidCulture
CONST	ENDS
;	COMDAT ?MaxHealth@City@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxHealth@City@CvWorldBuilderMap@@2IB DD 0186a0H	; CvWorldBuilderMap::City::MaxHealth
CONST	ENDS
;	COMDAT ?MaxNameLength@City@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxNameLength@City@CvWorldBuilderMap@@2IB DD 040H	; CvWorldBuilderMap::City::MaxNameLength
CONST	ENDS
;	COMDAT ?MaxBuildingTypes@City@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxBuildingTypes@City@CvWorldBuilderMap@@2IB DD 0200H	; CvWorldBuilderMap::City::MaxBuildingTypes
CONST	ENDS
;	COMDAT ?MaxHealth@CityV2@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxHealth@CityV2@CvWorldBuilderMap@@2IB DD 0186a0H	; CvWorldBuilderMap::CityV2::MaxHealth
CONST	ENDS
;	COMDAT ?MaxNameLength@CityV2@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxNameLength@CityV2@CvWorldBuilderMap@@2IB DD 040H	; CvWorldBuilderMap::CityV2::MaxNameLength
CONST	ENDS
;	COMDAT ?MaxBuildingTypes@CityV2@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxBuildingTypes@CityV2@CvWorldBuilderMap@@2IB DD 0100H ; CvWorldBuilderMap::CityV2::MaxBuildingTypes
CONST	ENDS
;	COMDAT ?MaxBuildingTypes@OldCity@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxBuildingTypes@OldCity@CvWorldBuilderMap@@2IB DD 0100H ; CvWorldBuilderMap::OldCity::MaxBuildingTypes
CONST	ENDS
;	COMDAT ?MaxHealth@Unit@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxHealth@Unit@CvWorldBuilderMap@@2IB DD 0186a0H	; CvWorldBuilderMap::Unit::MaxHealth
CONST	ENDS
;	COMDAT ?MaxPromotionTypes@Unit@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxPromotionTypes@Unit@CvWorldBuilderMap@@2IB DD 0200H	; CvWorldBuilderMap::Unit::MaxPromotionTypes
CONST	ENDS
;	COMDAT ?InvalidUnitType@Unit@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?InvalidUnitType@Unit@CvWorldBuilderMap@@2IB DD 0ffffffffH ; CvWorldBuilderMap::Unit::InvalidUnitType
CONST	ENDS
;	COMDAT ?MaxHealth@UnitV2@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxHealth@UnitV2@CvWorldBuilderMap@@2IB DD 0186a0H	; CvWorldBuilderMap::UnitV2::MaxHealth
CONST	ENDS
;	COMDAT ?MaxPromotionTypes@UnitV2@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxPromotionTypes@UnitV2@CvWorldBuilderMap@@2IB DD 0100H ; CvWorldBuilderMap::UnitV2::MaxPromotionTypes
CONST	ENDS
;	COMDAT ?InvalidUnitType@UnitV2@CvWorldBuilderMap@@2EB
CONST	SEGMENT
?InvalidUnitType@UnitV2@CvWorldBuilderMap@@2EB DB 0ffH	; CvWorldBuilderMap::UnitV2::InvalidUnitType
CONST	ENDS
;	COMDAT ?MaxLength@UnitName@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxLength@UnitName@CvWorldBuilderMap@@2IB DD 040H	; CvWorldBuilderMap::UnitName::MaxLength
CONST	ENDS
;	COMDAT ?InvalidUnitType@OldUnit@CvWorldBuilderMap@@2EB
CONST	SEGMENT
?InvalidUnitType@OldUnit@CvWorldBuilderMap@@2EB DB 0ffH	; CvWorldBuilderMap::OldUnit::InvalidUnitType
CONST	ENDS
;	COMDAT ?InvalidNaturalWonder@PlotMapData@CvWorldBuilderMap@@2EB
CONST	SEGMENT
?InvalidNaturalWonder@PlotMapData@CvWorldBuilderMap@@2EB DB 0ffH ; CvWorldBuilderMap::PlotMapData::InvalidNaturalWonder
CONST	ENDS
;	COMDAT ?InvalidFeature@PlotMapData@CvWorldBuilderMap@@2EB
CONST	SEGMENT
?InvalidFeature@PlotMapData@CvWorldBuilderMap@@2EB DB 0ffH ; CvWorldBuilderMap::PlotMapData::InvalidFeature
CONST	ENDS
;	COMDAT ?InvalidResource@PlotMapData@CvWorldBuilderMap@@2EB
CONST	SEGMENT
?InvalidResource@PlotMapData@CvWorldBuilderMap@@2EB DB 0ffH ; CvWorldBuilderMap::PlotMapData::InvalidResource
CONST	ENDS
;	COMDAT ?BarbarianPlayer@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?BarbarianPlayer@CvWorldBuilderMap@@2IB DD 060H		; CvWorldBuilderMap::BarbarianPlayer
CONST	ENDS
;	COMDAT ?MaxTeams@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxTeams@CvWorldBuilderMap@@2IB DD 060H		; CvWorldBuilderMap::MaxTeams
CONST	ENDS
;	COMDAT ?MaxCityStates@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxCityStates@CvWorldBuilderMap@@2IB DD 040H		; CvWorldBuilderMap::MaxCityStates
CONST	ENDS
;	COMDAT ?MaxPlayers@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxPlayers@CvWorldBuilderMap@@2IB DD 020H		; CvWorldBuilderMap::MaxPlayers
CONST	ENDS
;	COMDAT ?MaxMapSize@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxMapSize@CvWorldBuilderMap@@2IB DD 08000H		; CvWorldBuilderMap::MaxMapSize
CONST	ENDS
;	COMDAT ?FileVersion@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?FileVersion@CvWorldBuilderMap@@2IB DD 0cH		; CvWorldBuilderMap::FileVersion
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?GetWidth@CvWorldBuilderMap@@QBEIXZ		; CvWorldBuilderMap::GetWidth
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvworldbuildermap\include\cvworldbuildermap.h
;	COMDAT ?GetWidth@CvWorldBuilderMap@@QBEIXZ
_TEXT	SEGMENT
?GetWidth@CvWorldBuilderMap@@QBEIXZ PROC		; CvWorldBuilderMap::GetWidth, COMDAT
; _this$ = ecx

; 51   : 	inline uint GetWidth() const { return m_kMapDesc.uiWidth; }

	mov	eax, DWORD PTR [ecx+12228]
	ret	0
?GetWidth@CvWorldBuilderMap@@QBEIXZ ENDP		; CvWorldBuilderMap::GetWidth
_TEXT	ENDS
PUBLIC	?GetHeight@CvWorldBuilderMap@@QBEIXZ		; CvWorldBuilderMap::GetHeight
; Function compile flags: /Ogtpy
;	COMDAT ?GetHeight@CvWorldBuilderMap@@QBEIXZ
_TEXT	SEGMENT
?GetHeight@CvWorldBuilderMap@@QBEIXZ PROC		; CvWorldBuilderMap::GetHeight, COMDAT
; _this$ = ecx

; 52   : 	inline uint GetHeight() const { return m_kMapDesc.uiHeight; }

	mov	eax, DWORD PTR [ecx+12232]
	ret	0
?GetHeight@CvWorldBuilderMap@@QBEIXZ ENDP		; CvWorldBuilderMap::GetHeight
_TEXT	ENDS
PUBLIC	?GetPlotCount@CvWorldBuilderMap@@QBEIXZ		; CvWorldBuilderMap::GetPlotCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlotCount@CvWorldBuilderMap@@QBEIXZ
_TEXT	SEGMENT
?GetPlotCount@CvWorldBuilderMap@@QBEIXZ PROC		; CvWorldBuilderMap::GetPlotCount, COMDAT
; _this$ = ecx

; 53   : 	inline uint GetPlotCount() const { return m_kMapDesc.uiWidth * m_kMapDesc.uiHeight; }

	mov	eax, DWORD PTR [ecx+12232]
	imul	eax, DWORD PTR [ecx+12228]
	ret	0
?GetPlotCount@CvWorldBuilderMap@@QBEIXZ ENDP		; CvWorldBuilderMap::GetPlotCount
_TEXT	ENDS
PUBLIC	?GetTerrainType@PlotMapData@CvWorldBuilderMap@@QBEEXZ ; CvWorldBuilderMap::PlotMapData::GetTerrainType
; Function compile flags: /Ogtpy
;	COMDAT ?GetTerrainType@PlotMapData@CvWorldBuilderMap@@QBEEXZ
_TEXT	SEGMENT
?GetTerrainType@PlotMapData@CvWorldBuilderMap@@QBEEXZ PROC ; CvWorldBuilderMap::PlotMapData::GetTerrainType, COMDAT
; _this$ = ecx

; 60   : 		__forceinline byte GetTerrainType() const { return m_byTerrainType; }

	mov	al, BYTE PTR [ecx]
	ret	0
?GetTerrainType@PlotMapData@CvWorldBuilderMap@@QBEEXZ ENDP ; CvWorldBuilderMap::PlotMapData::GetTerrainType
_TEXT	ENDS
PUBLIC	?SetTerrainType@PlotMapData@CvWorldBuilderMap@@QAEXE@Z ; CvWorldBuilderMap::PlotMapData::SetTerrainType
; Function compile flags: /Ogtpy
;	COMDAT ?SetTerrainType@PlotMapData@CvWorldBuilderMap@@QAEXE@Z
_TEXT	SEGMENT
_byType$ = 8						; size = 1
?SetTerrainType@PlotMapData@CvWorldBuilderMap@@QAEXE@Z PROC ; CvWorldBuilderMap::PlotMapData::SetTerrainType, COMDAT
; _this$ = ecx

; 61   : 		__forceinline void SetTerrainType(byte byType) { m_byTerrainType = byType; }

	mov	al, BYTE PTR _byType$[esp-4]
	mov	BYTE PTR [ecx], al
	ret	4
?SetTerrainType@PlotMapData@CvWorldBuilderMap@@QAEXE@Z ENDP ; CvWorldBuilderMap::PlotMapData::SetTerrainType
_TEXT	ENDS
PUBLIC	?GetContinentType@PlotMapData@CvWorldBuilderMap@@QBEEXZ ; CvWorldBuilderMap::PlotMapData::GetContinentType
; Function compile flags: /Ogtpy
;	COMDAT ?GetContinentType@PlotMapData@CvWorldBuilderMap@@QBEEXZ
_TEXT	SEGMENT
?GetContinentType@PlotMapData@CvWorldBuilderMap@@QBEEXZ PROC ; CvWorldBuilderMap::PlotMapData::GetContinentType, COMDAT
; _this$ = ecx

; 63   : 		__forceinline byte GetContinentType() const { return m_byContinentType; }

	mov	al, BYTE PTR [ecx+5]
	ret	0
?GetContinentType@PlotMapData@CvWorldBuilderMap@@QBEEXZ ENDP ; CvWorldBuilderMap::PlotMapData::GetContinentType
_TEXT	ENDS
PUBLIC	?SetContinentType@PlotMapData@CvWorldBuilderMap@@QAEXE@Z ; CvWorldBuilderMap::PlotMapData::SetContinentType
; Function compile flags: /Ogtpy
;	COMDAT ?SetContinentType@PlotMapData@CvWorldBuilderMap@@QAEXE@Z
_TEXT	SEGMENT
_byType$ = 8						; size = 1
?SetContinentType@PlotMapData@CvWorldBuilderMap@@QAEXE@Z PROC ; CvWorldBuilderMap::PlotMapData::SetContinentType, COMDAT
; _this$ = ecx

; 64   : 		__forceinline void SetContinentType(byte byType) { m_byContinentType = byType; }

	mov	al, BYTE PTR _byType$[esp-4]
	mov	BYTE PTR [ecx+5], al
	ret	4
?SetContinentType@PlotMapData@CvWorldBuilderMap@@QAEXE@Z ENDP ; CvWorldBuilderMap::PlotMapData::SetContinentType
_TEXT	ENDS
PUBLIC	?GetResourceType@PlotMapData@CvWorldBuilderMap@@QBEEXZ ; CvWorldBuilderMap::PlotMapData::GetResourceType
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceType@PlotMapData@CvWorldBuilderMap@@QBEEXZ
_TEXT	SEGMENT
?GetResourceType@PlotMapData@CvWorldBuilderMap@@QBEEXZ PROC ; CvWorldBuilderMap::PlotMapData::GetResourceType, COMDAT
; _this$ = ecx

; 67   : 		__forceinline byte GetResourceType() const { return m_byResourceType; }

	mov	al, BYTE PTR [ecx+1]
	ret	0
?GetResourceType@PlotMapData@CvWorldBuilderMap@@QBEEXZ ENDP ; CvWorldBuilderMap::PlotMapData::GetResourceType
_TEXT	ENDS
PUBLIC	?SetResourceType@PlotMapData@CvWorldBuilderMap@@QAEXE@Z ; CvWorldBuilderMap::PlotMapData::SetResourceType
; Function compile flags: /Ogtpy
;	COMDAT ?SetResourceType@PlotMapData@CvWorldBuilderMap@@QAEXE@Z
_TEXT	SEGMENT
_byType$ = 8						; size = 1
?SetResourceType@PlotMapData@CvWorldBuilderMap@@QAEXE@Z PROC ; CvWorldBuilderMap::PlotMapData::SetResourceType, COMDAT
; _this$ = ecx

; 68   : 		__forceinline void SetResourceType(byte byType) { m_byResourceType = byType; }

	mov	al, BYTE PTR _byType$[esp-4]
	mov	BYTE PTR [ecx+1], al
	ret	4
?SetResourceType@PlotMapData@CvWorldBuilderMap@@QAEXE@Z ENDP ; CvWorldBuilderMap::PlotMapData::SetResourceType
_TEXT	ENDS
PUBLIC	?GetResourceAmount@PlotMapData@CvWorldBuilderMap@@QBEEXZ ; CvWorldBuilderMap::PlotMapData::GetResourceAmount
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceAmount@PlotMapData@CvWorldBuilderMap@@QBEEXZ
_TEXT	SEGMENT
?GetResourceAmount@PlotMapData@CvWorldBuilderMap@@QBEEXZ PROC ; CvWorldBuilderMap::PlotMapData::GetResourceAmount, COMDAT
; _this$ = ecx

; 70   : 		__forceinline byte GetResourceAmount() const { return m_byResourceAmount; }

	mov	al, BYTE PTR [ecx+7]
	ret	0
?GetResourceAmount@PlotMapData@CvWorldBuilderMap@@QBEEXZ ENDP ; CvWorldBuilderMap::PlotMapData::GetResourceAmount
_TEXT	ENDS
PUBLIC	?SetResourceAmount@PlotMapData@CvWorldBuilderMap@@QAEXE@Z ; CvWorldBuilderMap::PlotMapData::SetResourceAmount
; Function compile flags: /Ogtpy
;	COMDAT ?SetResourceAmount@PlotMapData@CvWorldBuilderMap@@QAEXE@Z
_TEXT	SEGMENT
_byAmount$ = 8						; size = 1
?SetResourceAmount@PlotMapData@CvWorldBuilderMap@@QAEXE@Z PROC ; CvWorldBuilderMap::PlotMapData::SetResourceAmount, COMDAT
; _this$ = ecx

; 71   : 		__forceinline void SetResourceAmount(byte byAmount) { m_byResourceAmount = byAmount; }

	mov	al, BYTE PTR _byAmount$[esp-4]
	mov	BYTE PTR [ecx+7], al
	ret	4
?SetResourceAmount@PlotMapData@CvWorldBuilderMap@@QAEXE@Z ENDP ; CvWorldBuilderMap::PlotMapData::SetResourceAmount
_TEXT	ENDS
PUBLIC	?GetFeatureType@PlotMapData@CvWorldBuilderMap@@QBEEXZ ; CvWorldBuilderMap::PlotMapData::GetFeatureType
; Function compile flags: /Ogtpy
;	COMDAT ?GetFeatureType@PlotMapData@CvWorldBuilderMap@@QBEEXZ
_TEXT	SEGMENT
?GetFeatureType@PlotMapData@CvWorldBuilderMap@@QBEEXZ PROC ; CvWorldBuilderMap::PlotMapData::GetFeatureType, COMDAT
; _this$ = ecx

; 74   : 		__forceinline byte GetFeatureType() const { return m_byFeatureType; }

	mov	al, BYTE PTR [ecx+2]
	ret	0
?GetFeatureType@PlotMapData@CvWorldBuilderMap@@QBEEXZ ENDP ; CvWorldBuilderMap::PlotMapData::GetFeatureType
_TEXT	ENDS
PUBLIC	?SetFeatureType@PlotMapData@CvWorldBuilderMap@@QAEXE@Z ; CvWorldBuilderMap::PlotMapData::SetFeatureType
; Function compile flags: /Ogtpy
;	COMDAT ?SetFeatureType@PlotMapData@CvWorldBuilderMap@@QAEXE@Z
_TEXT	SEGMENT
_byType$ = 8						; size = 1
?SetFeatureType@PlotMapData@CvWorldBuilderMap@@QAEXE@Z PROC ; CvWorldBuilderMap::PlotMapData::SetFeatureType, COMDAT
; _this$ = ecx

; 75   : 		__forceinline void SetFeatureType(byte byType) { m_byFeatureType = byType; }

	mov	al, BYTE PTR _byType$[esp-4]
	mov	BYTE PTR [ecx+2], al
	ret	4
?SetFeatureType@PlotMapData@CvWorldBuilderMap@@QAEXE@Z ENDP ; CvWorldBuilderMap::PlotMapData::SetFeatureType
_TEXT	ENDS
PUBLIC	?GetNaturalWonderType@PlotMapData@CvWorldBuilderMap@@QBEEXZ ; CvWorldBuilderMap::PlotMapData::GetNaturalWonderType
; Function compile flags: /Ogtpy
;	COMDAT ?GetNaturalWonderType@PlotMapData@CvWorldBuilderMap@@QBEEXZ
_TEXT	SEGMENT
?GetNaturalWonderType@PlotMapData@CvWorldBuilderMap@@QBEEXZ PROC ; CvWorldBuilderMap::PlotMapData::GetNaturalWonderType, COMDAT
; _this$ = ecx

; 78   : 		__forceinline byte GetNaturalWonderType() const { return m_byNaturalWonderType; }

	mov	al, BYTE PTR [ecx+6]
	ret	0
?GetNaturalWonderType@PlotMapData@CvWorldBuilderMap@@QBEEXZ ENDP ; CvWorldBuilderMap::PlotMapData::GetNaturalWonderType
_TEXT	ENDS
PUBLIC	?SetNaturalWonderType@PlotMapData@CvWorldBuilderMap@@QAEXE@Z ; CvWorldBuilderMap::PlotMapData::SetNaturalWonderType
; Function compile flags: /Ogtpy
;	COMDAT ?SetNaturalWonderType@PlotMapData@CvWorldBuilderMap@@QAEXE@Z
_TEXT	SEGMENT
_byType$ = 8						; size = 1
?SetNaturalWonderType@PlotMapData@CvWorldBuilderMap@@QAEXE@Z PROC ; CvWorldBuilderMap::PlotMapData::SetNaturalWonderType, COMDAT
; _this$ = ecx

; 79   : 		__forceinline void SetNaturalWonderType(byte byType) { m_byNaturalWonderType = byType; }

	mov	al, BYTE PTR _byType$[esp-4]
	mov	BYTE PTR [ecx+6], al
	ret	4
?SetNaturalWonderType@PlotMapData@CvWorldBuilderMap@@QAEXE@Z ENDP ; CvWorldBuilderMap::PlotMapData::SetNaturalWonderType
_TEXT	ENDS
PUBLIC	?GetPlotHeight@PlotMapData@CvWorldBuilderMap@@QBE?AW4PlotHeight@12@XZ ; CvWorldBuilderMap::PlotMapData::GetPlotHeight
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlotHeight@PlotMapData@CvWorldBuilderMap@@QBE?AW4PlotHeight@12@XZ
_TEXT	SEGMENT
?GetPlotHeight@PlotMapData@CvWorldBuilderMap@@QBE?AW4PlotHeight@12@XZ PROC ; CvWorldBuilderMap::PlotMapData::GetPlotHeight, COMDAT
; _this$ = ecx

; 88   : 		__forceinline PlotHeight GetPlotHeight() const { return (PlotHeight)m_byPlotHeight; }

	movzx	eax, BYTE PTR [ecx+4]
	ret	0
?GetPlotHeight@PlotMapData@CvWorldBuilderMap@@QBE?AW4PlotHeight@12@XZ ENDP ; CvWorldBuilderMap::PlotMapData::GetPlotHeight
_TEXT	ENDS
PUBLIC	?SetPlotHeight@PlotMapData@CvWorldBuilderMap@@QAEXW4PlotHeight@12@@Z ; CvWorldBuilderMap::PlotMapData::SetPlotHeight
; Function compile flags: /Ogtpy
;	COMDAT ?SetPlotHeight@PlotMapData@CvWorldBuilderMap@@QAEXW4PlotHeight@12@@Z
_TEXT	SEGMENT
_eHeight$ = 8						; size = 4
?SetPlotHeight@PlotMapData@CvWorldBuilderMap@@QAEXW4PlotHeight@12@@Z PROC ; CvWorldBuilderMap::PlotMapData::SetPlotHeight, COMDAT
; _this$ = ecx

; 89   : 		__forceinline void SetPlotHeight(PlotHeight eHeight) { m_byPlotHeight = (byte)eHeight; }

	mov	al, BYTE PTR _eHeight$[esp-4]
	mov	BYTE PTR [ecx+4], al
	ret	4
?SetPlotHeight@PlotMapData@CvWorldBuilderMap@@QAEXW4PlotHeight@12@@Z ENDP ; CvWorldBuilderMap::PlotMapData::SetPlotHeight
_TEXT	ENDS
PUBLIC	?GetFlag@PlotMapData@CvWorldBuilderMap@@QBE_NW4PlotFlags@12@@Z ; CvWorldBuilderMap::PlotMapData::GetFlag
; Function compile flags: /Ogtpy
;	COMDAT ?GetFlag@PlotMapData@CvWorldBuilderMap@@QBE_NW4PlotFlags@12@@Z
_TEXT	SEGMENT
_eFlag$ = 8						; size = 4
?GetFlag@PlotMapData@CvWorldBuilderMap@@QBE_NW4PlotFlags@12@@Z PROC ; CvWorldBuilderMap::PlotMapData::GetFlag, COMDAT
; _this$ = ecx

; 106  : 		__forceinline bool GetFlag(PlotFlags eFlag) const { return (m_byFlags & eFlag) != 0; }

	mov	al, BYTE PTR _eFlag$[esp-4]
	test	BYTE PTR [ecx+3], al
	mov	eax, 0
	setne	al
	ret	4
?GetFlag@PlotMapData@CvWorldBuilderMap@@QBE_NW4PlotFlags@12@@Z ENDP ; CvWorldBuilderMap::PlotMapData::GetFlag
_TEXT	ENDS
PUBLIC	?SetFlag@PlotMapData@CvWorldBuilderMap@@QAEXW4PlotFlags@12@@Z ; CvWorldBuilderMap::PlotMapData::SetFlag
; Function compile flags: /Ogtpy
;	COMDAT ?SetFlag@PlotMapData@CvWorldBuilderMap@@QAEXW4PlotFlags@12@@Z
_TEXT	SEGMENT
_eFlag$ = 8						; size = 4
?SetFlag@PlotMapData@CvWorldBuilderMap@@QAEXW4PlotFlags@12@@Z PROC ; CvWorldBuilderMap::PlotMapData::SetFlag, COMDAT
; _this$ = ecx

; 107  : 		__forceinline void SetFlag(PlotFlags eFlag) { m_byFlags |= eFlag; }

	mov	al, BYTE PTR _eFlag$[esp-4]
	or	BYTE PTR [ecx+3], al
	ret	4
?SetFlag@PlotMapData@CvWorldBuilderMap@@QAEXW4PlotFlags@12@@Z ENDP ; CvWorldBuilderMap::PlotMapData::SetFlag
_TEXT	ENDS
PUBLIC	?ClearFlag@PlotMapData@CvWorldBuilderMap@@QAEXW4PlotFlags@12@@Z ; CvWorldBuilderMap::PlotMapData::ClearFlag
; Function compile flags: /Ogtpy
;	COMDAT ?ClearFlag@PlotMapData@CvWorldBuilderMap@@QAEXW4PlotFlags@12@@Z
_TEXT	SEGMENT
_eFlag$ = 8						; size = 4
?ClearFlag@PlotMapData@CvWorldBuilderMap@@QAEXW4PlotFlags@12@@Z PROC ; CvWorldBuilderMap::PlotMapData::ClearFlag, COMDAT
; _this$ = ecx

; 108  : 		__forceinline void ClearFlag(PlotFlags eFlag) { m_byFlags &= ~eFlag; } 

	mov	al, BYTE PTR _eFlag$[esp-4]
	not	al
	and	BYTE PTR [ecx+3], al
	ret	4
?ClearFlag@PlotMapData@CvWorldBuilderMap@@QAEXW4PlotFlags@12@@Z ENDP ; CvWorldBuilderMap::PlotMapData::ClearFlag
_TEXT	ENDS
PUBLIC	__real@47c35000
PUBLIC	__real@4f800000
PUBLIC	?GetHealthAsFloat@Unit@CvWorldBuilderMap@@QBE?BMXZ ; CvWorldBuilderMap::Unit::GetHealthAsFloat
EXTRN	__fltused:DWORD
;	COMDAT __real@47c35000
CONST	SEGMENT
__real@47c35000 DD 047c35000r			; 100000
CONST	ENDS
;	COMDAT __real@4f800000
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?GetHealthAsFloat@Unit@CvWorldBuilderMap@@QBE?BMXZ
_TEXT	SEGMENT
tv131 = -4						; size = 4
tv129 = -4						; size = 4
?GetHealthAsFloat@Unit@CvWorldBuilderMap@@QBE?BMXZ PROC	; CvWorldBuilderMap::Unit::GetHealthAsFloat, COMDAT
; _this$ = ecx

; 263  : 		const float GetHealthAsFloat() const { return (float)m_uiHealth / (float)MaxHealth; }

	push	ecx
	mov	eax, DWORD PTR [ecx+8]
	fild	DWORD PTR [ecx+8]
	test	eax, eax
	jge	SHORT $LN3@GetHealthA
	fadd	DWORD PTR __real@4f800000
$LN3@GetHealthA:
	fdiv	DWORD PTR __real@47c35000
	fstp	DWORD PTR tv129[esp+4]
	fld	DWORD PTR tv129[esp+4]
	pop	ecx
	ret	0
?GetHealthAsFloat@Unit@CvWorldBuilderMap@@QBE?BMXZ ENDP	; CvWorldBuilderMap::Unit::GetHealthAsFloat
_TEXT	ENDS
PUBLIC	?GetFlag@Unit@CvWorldBuilderMap@@QBE_NW4Flags@12@@Z ; CvWorldBuilderMap::Unit::GetFlag
; Function compile flags: /Ogtpy
;	COMDAT ?GetFlag@Unit@CvWorldBuilderMap@@QBE_NW4Flags@12@@Z
_TEXT	SEGMENT
_eFlag$ = 8						; size = 4
?GetFlag@Unit@CvWorldBuilderMap@@QBE_NW4Flags@12@@Z PROC ; CvWorldBuilderMap::Unit::GetFlag, COMDAT
; _this$ = ecx

; 265  : 		__forceinline bool GetFlag(Flags eFlag) const { return (m_byFlags & eFlag) != 0; }

	mov	al, BYTE PTR _eFlag$[esp-4]
	test	BYTE PTR [ecx+18], al
	mov	eax, 0
	setne	al
	ret	4
?GetFlag@Unit@CvWorldBuilderMap@@QBE_NW4Flags@12@@Z ENDP ; CvWorldBuilderMap::Unit::GetFlag
_TEXT	ENDS
PUBLIC	?GetHealthAsFloat@City@CvWorldBuilderMap@@QBE?BMXZ ; CvWorldBuilderMap::City::GetHealthAsFloat
; Function compile flags: /Ogtpy
;	COMDAT ?GetHealthAsFloat@City@CvWorldBuilderMap@@QBE?BMXZ
_TEXT	SEGMENT
tv131 = -4						; size = 4
tv129 = -4						; size = 4
?GetHealthAsFloat@City@CvWorldBuilderMap@@QBE?BMXZ PROC	; CvWorldBuilderMap::City::GetHealthAsFloat, COMDAT
; _this$ = ecx

; 355  : 		const float GetHealthAsFloat() const { return (float)m_uiHealth / (float)MaxHealth; }

	push	ecx
	mov	eax, DWORD PTR [ecx+68]
	fild	DWORD PTR [ecx+68]
	test	eax, eax
	jge	SHORT $LN3@GetHealthA@2
	fadd	DWORD PTR __real@4f800000
$LN3@GetHealthA@2:
	fdiv	DWORD PTR __real@47c35000
	fstp	DWORD PTR tv129[esp+4]
	fld	DWORD PTR tv129[esp+4]
	pop	ecx
	ret	0
?GetHealthAsFloat@City@CvWorldBuilderMap@@QBE?BMXZ ENDP	; CvWorldBuilderMap::City::GetHealthAsFloat
_TEXT	ENDS
PUBLIC	?GetFlag@City@CvWorldBuilderMap@@QBE_NW4Flags@12@@Z ; CvWorldBuilderMap::City::GetFlag
; Function compile flags: /Ogtpy
;	COMDAT ?GetFlag@City@CvWorldBuilderMap@@QBE_NW4Flags@12@@Z
_TEXT	SEGMENT
_eFlag$ = 8						; size = 4
?GetFlag@City@CvWorldBuilderMap@@QBE_NW4Flags@12@@Z PROC ; CvWorldBuilderMap::City::GetFlag, COMDAT
; _this$ = ecx

; 357  : 		__forceinline bool GetFlag(Flags eFlag) const { return (m_byFlags & eFlag) != 0; }

	mov	al, BYTE PTR _eFlag$[esp-4]
	test	BYTE PTR [ecx+65], al
	mov	eax, 0
	setne	al
	ret	4
?GetFlag@City@CvWorldBuilderMap@@QBE_NW4Flags@12@@Z ENDP ; CvWorldBuilderMap::City::GetFlag
_TEXT	ENDS
PUBLIC	?GetPlotData@CvWorldBuilderMap@@QAEAAVPlotMapData@1@I@Z ; CvWorldBuilderMap::GetPlotData
EXTRN	?sm_kErrorPlotMapData@CvWorldBuilderMap@@0VPlotMapData@1@A:QWORD ; CvWorldBuilderMap::sm_kErrorPlotMapData
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlotData@CvWorldBuilderMap@@QAEAAVPlotMapData@1@I@Z
_TEXT	SEGMENT
_uiIndex$ = 8						; size = 4
?GetPlotData@CvWorldBuilderMap@@QAEAAVPlotMapData@1@I@Z PROC ; CvWorldBuilderMap::GetPlotData, COMDAT
; _this$ = ecx

; 496  : 		if( uiIndex < m_kMapDesc.uiWidth * m_kMapDesc.uiHeight && uiIndex < MaxMapSize )

	mov	edx, DWORD PTR [ecx+12232]
	imul	edx, DWORD PTR [ecx+12228]
	mov	eax, DWORD PTR _uiIndex$[esp-4]
	cmp	eax, edx
	jae	SHORT $LN2@GetPlotDat
	cmp	eax, 32768				; 00008000H

; 497  : 		{
; 498  : 			return m_akMapData[uiIndex];

	lea	eax, DWORD PTR [ecx+eax*8+12320]
	jb	SHORT $LN1@GetPlotDat
$LN2@GetPlotDat:

; 499  : 		}
; 500  : 		else
; 501  : 		{
; 502  : 			FAssertMsg(false, "Invalid Position");
; 503  : 			return sm_kErrorPlotMapData;

	mov	eax, OFFSET ?sm_kErrorPlotMapData@CvWorldBuilderMap@@0VPlotMapData@1@A ; CvWorldBuilderMap::sm_kErrorPlotMapData
$LN1@GetPlotDat:

; 504  : 		}
; 505  : 	}

	ret	4
?GetPlotData@CvWorldBuilderMap@@QAEAAVPlotMapData@1@I@Z ENDP ; CvWorldBuilderMap::GetPlotData
_TEXT	ENDS
PUBLIC	?GetPlotScenarioData@CvWorldBuilderMap@@QAEAAUPlotScenarioData@1@I@Z ; CvWorldBuilderMap::GetPlotScenarioData
EXTRN	?sm_kErrorPlotScenarioData@CvWorldBuilderMap@@0UPlotScenarioData@1@A:QWORD ; CvWorldBuilderMap::sm_kErrorPlotScenarioData
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlotScenarioData@CvWorldBuilderMap@@QAEAAUPlotScenarioData@1@I@Z
_TEXT	SEGMENT
_uiIndex$ = 8						; size = 4
?GetPlotScenarioData@CvWorldBuilderMap@@QAEAAUPlotScenarioData@1@I@Z PROC ; CvWorldBuilderMap::GetPlotScenarioData, COMDAT
; _this$ = ecx

; 548  : 		if( uiIndex < m_kMapDesc.uiWidth * m_kMapDesc.uiHeight && uiIndex < MaxMapSize )

	mov	edx, DWORD PTR [ecx+12232]
	imul	edx, DWORD PTR [ecx+12228]
	mov	eax, DWORD PTR _uiIndex$[esp-4]
	cmp	eax, edx
	jae	SHORT $LN2@GetPlotSce
	cmp	eax, 32768				; 00008000H

; 549  : 		{
; 550  : 			return m_akScenarioData[uiIndex];

	lea	eax, DWORD PTR [ecx+eax*8+274464]
	jb	SHORT $LN1@GetPlotSce
$LN2@GetPlotSce:

; 551  : 		}
; 552  : 		else
; 553  : 		{
; 554  : 			FAssertMsg(false, "Invalid Position");
; 555  : 			return sm_kErrorPlotScenarioData;

	mov	eax, OFFSET ?sm_kErrorPlotScenarioData@CvWorldBuilderMap@@0UPlotScenarioData@1@A ; CvWorldBuilderMap::sm_kErrorPlotScenarioData
$LN1@GetPlotSce:

; 556  : 		}
; 557  : 	}

	ret	4
?GetPlotScenarioData@CvWorldBuilderMap@@QAEAAUPlotScenarioData@1@I@Z ENDP ; CvWorldBuilderMap::GetPlotScenarioData
_TEXT	ENDS
PUBLIC	?GetPlayerCount@CvWorldBuilderMap@@QBE?BEXZ	; CvWorldBuilderMap::GetPlayerCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayerCount@CvWorldBuilderMap@@QBE?BEXZ
_TEXT	SEGMENT
?GetPlayerCount@CvWorldBuilderMap@@QBE?BEXZ PROC	; CvWorldBuilderMap::GetPlayerCount, COMDAT
; _this$ = ecx

; 559  : 	inline const byte GetPlayerCount() const { return m_kGameDesc.byPlayerCount; }

	mov	al, BYTE PTR [ecx+12316]
	ret	0
?GetPlayerCount@CvWorldBuilderMap@@QBE?BEXZ ENDP	; CvWorldBuilderMap::GetPlayerCount
_TEXT	ENDS
PUBLIC	?GetCityStateCount@CvWorldBuilderMap@@QBE?BEXZ	; CvWorldBuilderMap::GetCityStateCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStateCount@CvWorldBuilderMap@@QBE?BEXZ
_TEXT	SEGMENT
?GetCityStateCount@CvWorldBuilderMap@@QBE?BEXZ PROC	; CvWorldBuilderMap::GetCityStateCount, COMDAT
; _this$ = ecx

; 567  : 	inline const byte GetCityStateCount() const { return m_kGameDesc.byCityStateCount; }

	mov	al, BYTE PTR [ecx+12317]
	ret	0
?GetCityStateCount@CvWorldBuilderMap@@QBE?BEXZ ENDP	; CvWorldBuilderMap::GetCityStateCount
_TEXT	ENDS
PUBLIC	?GetTeamCount@CvWorldBuilderMap@@QBE?BEXZ	; CvWorldBuilderMap::GetTeamCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetTeamCount@CvWorldBuilderMap@@QBE?BEXZ
_TEXT	SEGMENT
?GetTeamCount@CvWorldBuilderMap@@QBE?BEXZ PROC		; CvWorldBuilderMap::GetTeamCount, COMDAT
; _this$ = ecx

; 575  : 	inline const byte GetTeamCount() const { return m_kGameDesc.byTeamCount; }

	mov	al, BYTE PTR [ecx+12318]
	ret	0
?GetTeamCount@CvWorldBuilderMap@@QBE?BEXZ ENDP		; CvWorldBuilderMap::GetTeamCount
_TEXT	ENDS
PUBLIC	?GetPlayer@CvWorldBuilderMap@@QAEAAUPlayer@1@E@Z ; CvWorldBuilderMap::GetPlayer
EXTRN	?sm_kErrorPlayer@CvWorldBuilderMap@@0UPlayer@1@A:BYTE ; CvWorldBuilderMap::sm_kErrorPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayer@CvWorldBuilderMap@@QAEAAUPlayer@1@E@Z
_TEXT	SEGMENT
_byPlayer$ = 8						; size = 1
?GetPlayer@CvWorldBuilderMap@@QAEAAUPlayer@1@E@Z PROC	; CvWorldBuilderMap::GetPlayer, COMDAT
; _this$ = ecx

; 585  : 		if( byPlayer < m_kGameDesc.byPlayerCount && byPlayer < MaxPlayers )

	mov	al, BYTE PTR _byPlayer$[esp-4]
	cmp	al, BYTE PTR [ecx+12316]
	jae	SHORT $LN2@GetPlayer
	cmp	al, 32					; 00000020H
	jae	SHORT $LN2@GetPlayer

; 586  : 		{
; 587  : 			return m_akPlayers[byPlayer];

	movzx	eax, al
	imul	eax, 436				; 000001b4H
	lea	eax, DWORD PTR [eax+ecx+536608]

; 593  : 		}
; 594  : 	}

	ret	4
$LN2@GetPlayer:

; 588  : 		}
; 589  : 		else
; 590  : 		{
; 591  : 			FAssertMsg(false, "Invalid Player");
; 592  : 			return sm_kErrorPlayer;

	mov	eax, OFFSET ?sm_kErrorPlayer@CvWorldBuilderMap@@0UPlayer@1@A ; CvWorldBuilderMap::sm_kErrorPlayer

; 593  : 		}
; 594  : 	}

	ret	4
?GetPlayer@CvWorldBuilderMap@@QAEAAUPlayer@1@E@Z ENDP	; CvWorldBuilderMap::GetPlayer
_TEXT	ENDS
PUBLIC	?GetCityState@CvWorldBuilderMap@@QAEAAUPlayer@1@E@Z ; CvWorldBuilderMap::GetCityState
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityState@CvWorldBuilderMap@@QAEAAUPlayer@1@E@Z
_TEXT	SEGMENT
_byPlayer$ = 8						; size = 1
?GetCityState@CvWorldBuilderMap@@QAEAAUPlayer@1@E@Z PROC ; CvWorldBuilderMap::GetCityState, COMDAT
; _this$ = ecx

; 611  : 		if( byPlayer < m_kGameDesc.byCityStateCount && byPlayer < MaxCityStates )

	mov	al, BYTE PTR _byPlayer$[esp-4]
	cmp	al, BYTE PTR [ecx+12317]
	jae	SHORT $LN2@GetCitySta
	cmp	al, 64					; 00000040H
	jae	SHORT $LN2@GetCitySta

; 612  : 		{
; 613  : 			return m_akCityStates[byPlayer];

	movzx	eax, al
	imul	eax, 436				; 000001b4H
	lea	eax, DWORD PTR [eax+ecx+550560]

; 619  : 		}
; 620  : 	}

	ret	4
$LN2@GetCitySta:

; 614  : 		}
; 615  : 		else
; 616  : 		{
; 617  : 			FAssertMsg(false, "Invalid City State");
; 618  : 			return sm_kErrorPlayer;

	mov	eax, OFFSET ?sm_kErrorPlayer@CvWorldBuilderMap@@0UPlayer@1@A ; CvWorldBuilderMap::sm_kErrorPlayer

; 619  : 		}
; 620  : 	}

	ret	4
?GetCityState@CvWorldBuilderMap@@QAEAAUPlayer@1@E@Z ENDP ; CvWorldBuilderMap::GetCityState
_TEXT	ENDS
PUBLIC	?GetTeam@CvWorldBuilderMap@@QAEAAUTeam@1@E@Z	; CvWorldBuilderMap::GetTeam
EXTRN	?sm_kErrorTeam@CvWorldBuilderMap@@0UTeam@1@A:BYTE ; CvWorldBuilderMap::sm_kErrorTeam
; Function compile flags: /Ogtpy
;	COMDAT ?GetTeam@CvWorldBuilderMap@@QAEAAUTeam@1@E@Z
_TEXT	SEGMENT
_byTeam$ = 8						; size = 1
?GetTeam@CvWorldBuilderMap@@QAEAAUTeam@1@E@Z PROC	; CvWorldBuilderMap::GetTeam, COMDAT
; _this$ = ecx

; 637  : 		if( byTeam < m_kGameDesc.byTeamCount && byTeam < MaxTeams )

	mov	al, BYTE PTR _byTeam$[esp-4]
	cmp	al, BYTE PTR [ecx+12318]
	jae	SHORT $LN2@GetTeam
	cmp	al, 96					; 00000060H
	jae	SHORT $LN2@GetTeam

; 638  : 		{
; 639  : 			return m_akTeams[byTeam];

	movzx	eax, al
	shl	eax, 6
	lea	eax, DWORD PTR [eax+ecx+578464]

; 645  : 		}
; 646  : 	}

	ret	4
$LN2@GetTeam:

; 640  : 		}
; 641  : 		else
; 642  : 		{
; 643  : 			FAssertMsg(false, "Invalid Team");
; 644  : 			return sm_kErrorTeam;

	mov	eax, OFFSET ?sm_kErrorTeam@CvWorldBuilderMap@@0UTeam@1@A ; CvWorldBuilderMap::sm_kErrorTeam

; 645  : 		}
; 646  : 	}

	ret	4
?GetTeam@CvWorldBuilderMap@@QAEAAUTeam@1@E@Z ENDP	; CvWorldBuilderMap::GetTeam
_TEXT	ENDS
PUBLIC	?GetDefaultGameSpeed@CvWorldBuilderMap@@QBEPBDXZ ; CvWorldBuilderMap::GetDefaultGameSpeed
; Function compile flags: /Ogtpy
;	COMDAT ?GetDefaultGameSpeed@CvWorldBuilderMap@@QBEPBDXZ
_TEXT	SEGMENT
?GetDefaultGameSpeed@CvWorldBuilderMap@@QBEPBDXZ PROC	; CvWorldBuilderMap::GetDefaultGameSpeed, COMDAT
; _this$ = ecx

; 681  : 	inline const char *GetDefaultGameSpeed() const { return m_kGameDesc.szDefaultSpeed; }

	lea	eax, DWORD PTR [ecx+12236]
	ret	0
?GetDefaultGameSpeed@CvWorldBuilderMap@@QBEPBDXZ ENDP	; CvWorldBuilderMap::GetDefaultGameSpeed
_TEXT	ENDS
PUBLIC	?GetWorldType@CvWorldBuilderMap@@QBEPBDXZ	; CvWorldBuilderMap::GetWorldType
; Function compile flags: /Ogtpy
;	COMDAT ?GetWorldType@CvWorldBuilderMap@@QBEPBDXZ
_TEXT	SEGMENT
?GetWorldType@CvWorldBuilderMap@@QBEPBDXZ PROC		; CvWorldBuilderMap::GetWorldType, COMDAT
; _this$ = ecx

; 684  : 	inline const char* GetWorldType() const {return m_szWorldType;}

	lea	eax, DWORD PTR [ecx+584608]
	ret	0
?GetWorldType@CvWorldBuilderMap@@QBEPBDXZ ENDP		; CvWorldBuilderMap::GetWorldType
_TEXT	ENDS
PUBLIC	?GetStartYear@CvWorldBuilderMap@@QBEHXZ		; CvWorldBuilderMap::GetStartYear
; Function compile flags: /Ogtpy
;	COMDAT ?GetStartYear@CvWorldBuilderMap@@QBEHXZ
_TEXT	SEGMENT
?GetStartYear@CvWorldBuilderMap@@QBEHXZ PROC		; CvWorldBuilderMap::GetStartYear, COMDAT
; _this$ = ecx

; 687  : 	inline int GetStartYear() const { return m_kGameDesc.iStartYear; }

	mov	eax, DWORD PTR [ecx+12312]
	ret	0
?GetStartYear@CvWorldBuilderMap@@QBEHXZ ENDP		; CvWorldBuilderMap::GetStartYear
_TEXT	ENDS
PUBLIC	?GetMaxTurns@CvWorldBuilderMap@@QBEIXZ		; CvWorldBuilderMap::GetMaxTurns
; Function compile flags: /Ogtpy
;	COMDAT ?GetMaxTurns@CvWorldBuilderMap@@QBEIXZ
_TEXT	SEGMENT
?GetMaxTurns@CvWorldBuilderMap@@QBEIXZ PROC		; CvWorldBuilderMap::GetMaxTurns, COMDAT
; _this$ = ecx

; 690  : 	inline uint GetMaxTurns() const { return m_kGameDesc.uiMaxTurns; }

	mov	eax, DWORD PTR [ecx+12304]
	ret	0
?GetMaxTurns@CvWorldBuilderMap@@QBEIXZ ENDP		; CvWorldBuilderMap::GetMaxTurns
_TEXT	ENDS
PUBLIC	?GetFlag@CvWorldBuilderMap@@QBE_NW4MapFlags@1@@Z ; CvWorldBuilderMap::GetFlag
; Function compile flags: /Ogtpy
;	COMDAT ?GetFlag@CvWorldBuilderMap@@QBE_NW4MapFlags@1@@Z
_TEXT	SEGMENT
_eFlag$ = 8						; size = 4
?GetFlag@CvWorldBuilderMap@@QBE_NW4MapFlags@1@@Z PROC	; CvWorldBuilderMap::GetFlag, COMDAT
; _this$ = ecx

; 726  : 	__forceinline bool GetFlag(MapFlags eFlag) const { return (m_uiFlags & eFlag) != 0; }

	mov	eax, DWORD PTR [ecx+12224]
	and	eax, DWORD PTR _eFlag$[esp-4]
	neg	eax
	sbb	eax, eax
	neg	eax
	ret	4
?GetFlag@CvWorldBuilderMap@@QBE_NW4MapFlags@1@@Z ENDP	; CvWorldBuilderMap::GetFlag
_TEXT	ENDS
PUBLIC	?SetFlag@CvWorldBuilderMap@@QAEXW4MapFlags@1@_N@Z ; CvWorldBuilderMap::SetFlag
; Function compile flags: /Ogtpy
;	COMDAT ?SetFlag@CvWorldBuilderMap@@QAEXW4MapFlags@1@_N@Z
_TEXT	SEGMENT
_eFlag$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetFlag@CvWorldBuilderMap@@QAEXW4MapFlags@1@_N@Z PROC	; CvWorldBuilderMap::SetFlag, COMDAT
; _this$ = ecx

; 731  : 		if( bValue ) m_uiFlags |= eFlag;

	cmp	BYTE PTR _bValue$[esp-4], 0
	je	SHORT $LN2@SetFlag
	mov	eax, DWORD PTR _eFlag$[esp-4]
	or	DWORD PTR [ecx+12224], eax

; 733  : 	}

	ret	8
$LN2@SetFlag:

; 732  : 		else m_uiFlags &= ~eFlag;

	mov	edx, DWORD PTR _eFlag$[esp-4]
	not	edx
	and	DWORD PTR [ecx+12224], edx

; 733  : 	}

	ret	8
?SetFlag@CvWorldBuilderMap@@QAEXW4MapFlags@1@_N@Z ENDP	; CvWorldBuilderMap::SetFlag
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	?GetCurrentMapInfo@CvWorldBuilderMapLoader@@SAABUCvWorldBuilderMapLoaderMapInfo@@XZ ; CvWorldBuilderMapLoader::GetCurrentMapInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
;	COMDAT ?GetCurrentMapInfo@CvWorldBuilderMapLoader@@SAABUCvWorldBuilderMapLoaderMapInfo@@XZ
_TEXT	SEGMENT
?GetCurrentMapInfo@CvWorldBuilderMapLoader@@SAABUCvWorldBuilderMapLoaderMapInfo@@XZ PROC ; CvWorldBuilderMapLoader::GetCurrentMapInfo, COMDAT

; 177  : 	return sg_kMapInfo;

	mov	eax, OFFSET _sg_kMapInfo

; 178  : }

	ret	0
?GetCurrentMapInfo@CvWorldBuilderMapLoader@@SAABUCvWorldBuilderMapLoaderMapInfo@@XZ ENDP ; CvWorldBuilderMapLoader::GetCurrentMapInfo
_TEXT	ENDS
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 129  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@

; 130  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 134  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetPlayerType@@YA?AW4PlayerTypes@@E@Z		; GetPlayerType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
;	COMDAT ?GetPlayerType@@YA?AW4PlayerTypes@@E@Z
_TEXT	SEGMENT
_byCulture$ = 8						; size = 1
?GetPlayerType@@YA?AW4PlayerTypes@@E@Z PROC		; GetPlayerType, COMDAT

; 675  : 	if(byCulture < CvWorldBuilderMap::MaxPlayers)

	mov	al, BYTE PTR _byCulture$[esp-4]
	cmp	al, 32					; 00000020H
	jae	SHORT $LN10@GetPlayerT

; 676  : 	{
; 677  : 		if(byCulture < MAX_MAJOR_CIVS)

	cmp	al, 22					; 00000016H
	jae	SHORT $LN9@GetPlayerT

; 678  : 			return (PlayerTypes)byCulture;

	movzx	eax, al

; 691  : 	{
; 692  : 		return BARBARIAN_PLAYER;
; 693  : 	}
; 694  : 	else
; 695  : 	{
; 696  : 		return NO_PLAYER; // Completely invalid culture type
; 697  : 	}
; 698  : }

	ret	0
$LN9@GetPlayerT:

; 679  : 		else
; 680  : 			return NO_PLAYER; // Player out of range

	or	eax, -1

; 691  : 	{
; 692  : 		return BARBARIAN_PLAYER;
; 693  : 	}
; 694  : 	else
; 695  : 	{
; 696  : 		return NO_PLAYER; // Completely invalid culture type
; 697  : 	}
; 698  : }

	ret	0
$LN10@GetPlayerT:

; 681  : 	}
; 682  : 	else if(byCulture < CvWorldBuilderMap::MaxPlayers + CvWorldBuilderMap::MaxCityStates)

	cmp	al, 96					; 00000060H
	jae	SHORT $LN6@GetPlayerT

; 683  : 	{
; 684  : 		const uint uiCityState = byCulture - CvWorldBuilderMap::MaxPlayers;

	movzx	eax, al
	sub	eax, 32					; 00000020H

; 685  : 		if(uiCityState < MAX_MINOR_CIVS)

	cmp	eax, 41					; 00000029H
	jae	SHORT $LN9@GetPlayerT

; 686  : 			return (PlayerTypes)(uiCityState + MAX_MAJOR_CIVS);

	add	eax, 22					; 00000016H

; 691  : 	{
; 692  : 		return BARBARIAN_PLAYER;
; 693  : 	}
; 694  : 	else
; 695  : 	{
; 696  : 		return NO_PLAYER; // Completely invalid culture type
; 697  : 	}
; 698  : }

	ret	0
$LN6@GetPlayerT:

; 687  : 		else
; 688  : 			return NO_PLAYER; // City State out of range
; 689  : 	}
; 690  : 	else if(byCulture == CvWorldBuilderMap::MaxPlayers + CvWorldBuilderMap::MaxCityStates)

	xor	ecx, ecx
	cmp	al, 96					; 00000060H
	setne	cl
	dec	ecx
	and	ecx, 64					; 00000040H
	dec	ecx
	mov	eax, ecx

; 691  : 	{
; 692  : 		return BARBARIAN_PLAYER;
; 693  : 	}
; 694  : 	else
; 695  : 	{
; 696  : 		return NO_PLAYER; // Completely invalid culture type
; 697  : 	}
; 698  : }

	ret	0
?GetPlayerType@@YA?AW4PlayerTypes@@E@Z ENDP		; GetPlayerType
_TEXT	ENDS
PUBLIC	?LoadModData@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ; CvWorldBuilderMapLoader::LoadModData
EXTRN	_lua_rawseti:PROC
EXTRN	_lua_pushvalue:PROC
EXTRN	?IsFieldDefaultValue@ModDataEntry@@QBE_NI@Z:PROC ; ModDataEntry::IsFieldDefaultValue
EXTRN	?GetPlotDataEntry@CvWorldBuilderMapModData@@QAE?AVModDataEntry@@I@Z:PROC ; CvWorldBuilderMapModData::GetPlotDataEntry
EXTRN	?GetFieldDefaultAsInt@ModType@@QBEHI@Z:PROC	; ModType::GetFieldDefaultAsInt
EXTRN	?GetFieldDefaultAsString@ModType@@QBEPBDI@Z:PROC ; ModType::GetFieldDefaultAsString
EXTRN	?GetFieldDefaultAsFloat@ModType@@QBEMI@Z:PROC	; ModType::GetFieldDefaultAsFloat
EXTRN	?GetFieldDefaultAsBool@ModType@@QBE_NI@Z:PROC	; ModType::GetFieldDefaultAsBool
EXTRN	_lua_pushnil:PROC
EXTRN	_lua_rawset:PROC
EXTRN	?GetMember@ModEnum@@QBEPBDI@Z:PROC		; ModEnum::GetMember
EXTRN	?GetFieldAsInt@ModDataEntry@@QBEHI@Z:PROC	; ModDataEntry::GetFieldAsInt
EXTRN	?GetFieldEnumType@ModType@@QBEPBVModEnum@@I@Z:PROC ; ModType::GetFieldEnumType
EXTRN	?GetFieldAsString@ModDataEntry@@QBEPBDI@Z:PROC	; ModDataEntry::GetFieldAsString
EXTRN	_lua_pushnumber:PROC
EXTRN	?GetFieldAsFloat@ModDataEntry@@QBEMI@Z:PROC	; ModDataEntry::GetFieldAsFloat
EXTRN	_lua_pushboolean:PROC
EXTRN	?GetFieldAsBool@ModDataEntry@@QBE_NI@Z:PROC	; ModDataEntry::GetFieldAsBool
EXTRN	?GetFieldType@ModType@@QBE?AW4FieldType@1@I@Z:PROC ; ModType::GetFieldType
EXTRN	?GetFieldName@ModType@@QBEPBDI@Z:PROC		; ModType::GetFieldName
EXTRN	_lua_createtable:PROC
EXTRN	_lua_pushstring:PROC
EXTRN	?GetMapDataEntry@CvWorldBuilderMapModData@@QAE?AVModDataEntry@@XZ:PROC ; CvWorldBuilderMapModData::GetMapDataEntry
EXTRN	?GetFieldCount@ModType@@QBEIXZ:PROC		; ModType::GetFieldCount
EXTRN	_lua_settop:PROC
EXTRN	_lua_type:PROC
EXTRN	_lua_getfield:PROC
EXTRN	_lua_gettop:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?LoadModData@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bValue$225221 = -45					; size = 1
_uiFieldCount$ = -44					; size = 4
tv619 = -40						; size = 4
_x$225200 = -36						; size = 4
_uiGlobalsCount$ = -36					; size = 4
_iTop$ = -32						; size = 4
_y$225204 = -28						; size = 4
_uiMapHeight$225198 = -24				; size = 4
_uiMapWidth$225197 = -20				; size = 4
_fValue$225184 = -20					; size = 4
_fValue$225153 = -20					; size = 4
_iFieldStart$225171 = -16				; size = 4
_szMember$225230 = -12					; size = 4
_iValue$225227 = -12					; size = 4
_szField$225225 = -12					; size = 4
_fValue$225223 = -12					; size = 4
_kPlot$225208 = -8					; size = 8
_kEntry$225138 = -8					; size = 8
_L$ = 8							; size = 4
?LoadModData@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z PROC ; CvWorldBuilderMapLoader::LoadModData, COMDAT

; 1522 : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi

; 1523 : 	if(L == NULL)

	mov	esi, DWORD PTR _L$[ebp]
	push	edi
	test	esi, esi

; 1524 : 	{
; 1525 : 		FAssertMsg(L, "Seriously, you really need a lua state for this.");
; 1526 : 		return 0;

	je	$LN69@LoadModDat

; 1527 : 	}
; 1528 : 
; 1529 : 	const int iTop = lua_gettop(L);

	push	esi
	call	_lua_gettop

; 1530 : 
; 1531 : 	lua_getglobal(L, "MapModData");

	push	OFFSET $SG225131
	mov	edi, eax
	push	-10002					; ffffd8eeH
	push	esi
	mov	DWORD PTR _iTop$[esp+80], edi
	call	_lua_getfield

; 1532 : 	bool bFoundTable = lua_istable(L, -1);

	push	-1
	push	esi
	call	_lua_type
	add	esp, 24					; 00000018H
	cmp	eax, 5

; 1533 : 
; 1534 : 	FAssertMsg(bFoundTable, "Unable to find mod data table");
; 1535 : 	if(!bFoundTable)

	je	SHORT $LN48@LoadModDat

; 1536 : 	{
; 1537 : 		lua_settop(L, iTop);

	push	edi

; 1742 : 	}
; 1743 : 
; 1744 : 	lua_settop(L, iTop);

	push	esi
	call	_lua_settop
	add	esp, 8

; 1745 : 
; 1746 : 	return 0;

	xor	eax, eax

; 1747 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@LoadModDat:

; 1538 : 		return 0;
; 1539 : 	}
; 1540 : 
; 1541 : 	const int iModDataTable = iTop + 1;
; 1542 : 
; 1543 : 	ModType& kGlobalsDataType = sg_kSave.m_kModData.m_kMapModData;
; 1544 : 	const uint uiGlobalsCount = kGlobalsDataType.GetFieldCount();

	mov	ecx, OFFSET _sg_kSave+2888
	inc	edi
	call	?GetFieldCount@ModType@@QBEIXZ		; ModType::GetFieldCount
	mov	ebx, eax
	mov	DWORD PTR _uiGlobalsCount$[esp+64], ebx

; 1545 : 	if(uiGlobalsCount > 0)

	test	ebx, ebx
	jbe	$LN47@LoadModDat

; 1546 : 	{
; 1547 : 		ModDataEntry kEntry = sg_kSave.m_kModData.GetMapDataEntry();

	lea	eax, DWORD PTR _kEntry$225138[esp+64]
	push	eax
	mov	ecx, OFFSET _sg_kSave+2888
	call	?GetMapDataEntry@CvWorldBuilderMapModData@@QAE?AVModDataEntry@@XZ ; CvWorldBuilderMapModData::GetMapDataEntry

; 1548 : 
; 1549 : 		lua_pushstring(L, "Globals");

	push	OFFSET $SG225140
	push	esi
	call	_lua_pushstring

; 1550 : 		lua_createtable(L, 0, uiGlobalsCount);

	push	ebx
	push	0
	push	esi
	call	_lua_createtable
	add	esp, 20					; 00000014H

; 1551 : 		for(uint uiField = 0; uiField < uiGlobalsCount; ++uiField)

	xor	edi, edi
	test	ebx, ebx
	jbe	$LN44@LoadModDat
	npad	1
$LL46@LoadModDat:

; 1552 : 		{
; 1553 : 			const char* szFieldName = kGlobalsDataType.GetFieldName(uiField);

	push	edi
	mov	ecx, OFFSET _sg_kSave+2888
	call	?GetFieldName@ModType@@QBEPBDI@Z	; ModType::GetFieldName

; 1554 : 			lua_pushstring(L, szFieldName);

	push	eax
	push	esi
	call	_lua_pushstring
	add	esp, 8

; 1555 : 
; 1556 : 			switch(kGlobalsDataType.GetFieldType(uiField))

	push	edi
	mov	ecx, OFFSET _sg_kSave+2888
	call	?GetFieldType@ModType@@QBE?AW4FieldType@1@I@Z ; ModType::GetFieldType
	cmp	eax, 3
	ja	$LN35@LoadModDat
	jmp	DWORD PTR $LN77@LoadModDat[eax*4]
$LN41@LoadModDat:

; 1557 : 			{
; 1558 : 			case ModType::TYPE_BOOL:
; 1559 : 			{
; 1560 : 				const bool bValue = kEntry.GetFieldAsBool(uiField);

	push	edi
	lea	ecx, DWORD PTR _kEntry$225138[esp+68]
	call	?GetFieldAsBool@ModDataEntry@@QBE_NI@Z	; ModDataEntry::GetFieldAsBool

; 1561 : 				lua_pushboolean(L, bValue);

	movzx	ecx, al
	push	ecx
	push	esi
	call	_lua_pushboolean

; 1562 : 			}
; 1563 : 			break;

	jmp	SHORT $LN71@LoadModDat
$LN40@LoadModDat:

; 1564 : 
; 1565 : 			case ModType::TYPE_FLOAT:
; 1566 : 			{
; 1567 : 				const float fValue = kEntry.GetFieldAsFloat(uiField);

	push	edi
	lea	ecx, DWORD PTR _kEntry$225138[esp+68]
	call	?GetFieldAsFloat@ModDataEntry@@QBEMI@Z	; ModDataEntry::GetFieldAsFloat
	fstp	DWORD PTR _fValue$225153[esp+64]

; 1568 : 				lua_pushnumber(L, fValue);

	fld	DWORD PTR _fValue$225153[esp+64]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	esi
	call	_lua_pushnumber
	add	esp, 12					; 0000000cH

; 1569 : 			}
; 1570 : 			break;

	jmp	SHORT $LN35@LoadModDat
$LN39@LoadModDat:

; 1571 : 
; 1572 : 			case ModType::TYPE_STRING:
; 1573 : 			{
; 1574 : 				const char* szField = kEntry.GetFieldAsString(uiField);

	push	edi
	lea	ecx, DWORD PTR _kEntry$225138[esp+68]
	call	?GetFieldAsString@ModDataEntry@@QBEPBDI@Z ; ModDataEntry::GetFieldAsString

; 1575 : 				lua_pushstring(L, szField);

	push	eax
	push	esi
	call	_lua_pushstring

; 1576 : 			}
; 1577 : 			break;

	jmp	SHORT $LN71@LoadModDat
$LN38@LoadModDat:

; 1578 : 
; 1579 : 			case ModType::TYPE_ENUM:
; 1580 : 			{
; 1581 : 				const ModEnum* pkEnum = sg_kSave.m_kModData.m_kPlotModData.GetFieldEnumType(uiField);

	push	edi
	mov	ecx, OFFSET _sg_kSave+3436
	call	?GetFieldEnumType@ModType@@QBEPBVModEnum@@I@Z ; ModType::GetFieldEnumType
	mov	ebx, eax

; 1582 : 				if(pkEnum != NULL)

	test	ebx, ebx
	je	SHORT $LN37@LoadModDat

; 1583 : 				{
; 1584 : 					int iValue = kEntry.GetFieldAsInt(uiField);

	push	edi
	lea	ecx, DWORD PTR _kEntry$225138[esp+68]
	call	?GetFieldAsInt@ModDataEntry@@QBEHI@Z	; ModDataEntry::GetFieldAsInt

; 1585 : 					const char* szMember = pkEnum->GetMember((uint)iValue);

	push	eax
	mov	ecx, ebx
	call	?GetMember@ModEnum@@QBEPBDI@Z		; ModEnum::GetMember

; 1586 : 					if(szMember == NULL) szMember = "";

	test	eax, eax
	jne	SHORT $LN36@LoadModDat
	mov	eax, OFFSET $SG225163
$LN36@LoadModDat:

; 1587 : 					lua_pushstring(L, szMember);

	push	eax

; 1588 : 				}
; 1589 : 				else

	jmp	SHORT $LN72@LoadModDat
$LN37@LoadModDat:

; 1590 : 				{
; 1591 : 					lua_pushstring(L, "");

	push	OFFSET $SG225165
$LN72@LoadModDat:
	push	esi
	call	_lua_pushstring
	mov	ebx, DWORD PTR _uiGlobalsCount$[esp+72]
$LN71@LoadModDat:
	add	esp, 8
$LN35@LoadModDat:

; 1592 : 				}
; 1593 : 			}
; 1594 : 			}
; 1595 : 
; 1596 : 			lua_rawset(L, -3);

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset
	inc	edi
	add	esp, 8
	cmp	edi, ebx
	jb	$LL46@LoadModDat
$LN44@LoadModDat:

; 1597 : 		}
; 1598 : 
; 1599 : 		lua_rawset(L, iModDataTable);

	mov	edi, DWORD PTR _iTop$[esp+64]
	inc	edi
	push	edi
	push	esi
	call	_lua_rawset
	add	esp, 8

; 1600 : 	}
; 1601 : 	else

	jmp	SHORT $LN34@LoadModDat
$LN47@LoadModDat:

; 1602 : 	{
; 1603 : 		lua_pushstring(L, "Globals");

	push	OFFSET $SG225167
	push	esi
	call	_lua_pushstring

; 1604 : 		lua_pushnil(L);

	push	esi
	call	_lua_pushnil

; 1605 : 		lua_rawset(L, iModDataTable);

	push	edi
	push	esi
	call	_lua_rawset
	add	esp, 20					; 00000014H
$LN34@LoadModDat:

; 1606 : 	}
; 1607 : 
; 1608 : 	ModType& kPlotDataType = sg_kSave.m_kModData.m_kPlotModData;
; 1609 : 	const uint uiFieldCount = kPlotDataType.GetFieldCount();

	mov	ecx, OFFSET _sg_kSave+3436
	call	?GetFieldCount@ModType@@QBEIXZ		; ModType::GetFieldCount
	mov	ebx, eax
	mov	DWORD PTR _uiFieldCount$[esp+64], ebx

; 1610 : 	if(uiFieldCount > 0)

	test	ebx, ebx
	jbe	$LN33@LoadModDat

; 1611 : 	{
; 1612 : 		const int iFieldStart = lua_gettop(L) + 1;

	push	esi
	call	_lua_gettop
	inc	eax
	add	esp, 4

; 1613 : 		for(uint uiField = 0; uiField < uiFieldCount; ++uiField)

	xor	edi, edi
	mov	DWORD PTR _iFieldStart$225171[esp+64], eax
	test	ebx, ebx
	jbe	$LN30@LoadModDat
	npad	3
$LL32@LoadModDat:

; 1614 : 		{
; 1615 : 			const char* szFieldName = kPlotDataType.GetFieldName(uiField);

	push	edi
	mov	ecx, OFFSET _sg_kSave+3436
	call	?GetFieldName@ModType@@QBEPBDI@Z	; ModType::GetFieldName

; 1616 : 			lua_pushstring(L, szFieldName);

	push	eax
	push	esi
	call	_lua_pushstring
	add	esp, 8

; 1617 : 
; 1618 : 			switch(kPlotDataType.GetFieldType(uiField))

	push	edi
	mov	ecx, OFFSET _sg_kSave+3436
	call	?GetFieldType@ModType@@QBE?AW4FieldType@1@I@Z ; ModType::GetFieldType
	cmp	eax, 3
	ja	$LN31@LoadModDat
	jmp	DWORD PTR $LN78@LoadModDat[eax*4]
$LN27@LoadModDat:

; 1619 : 			{
; 1620 : 			case ModType::TYPE_BOOL:
; 1621 : 			{
; 1622 : 				const bool bValue = kPlotDataType.GetFieldDefaultAsBool(uiField);

	push	edi
	mov	ecx, OFFSET _sg_kSave+3436
	call	?GetFieldDefaultAsBool@ModType@@QBE_NI@Z ; ModType::GetFieldDefaultAsBool

; 1623 : 				lua_pushboolean(L, bValue);

	movzx	edx, al
	push	edx
	push	esi
	call	_lua_pushboolean

; 1624 : 			}
; 1625 : 			break;

	jmp	SHORT $LN73@LoadModDat
$LN26@LoadModDat:

; 1626 : 
; 1627 : 			case ModType::TYPE_FLOAT:
; 1628 : 			{
; 1629 : 				const float fValue = kPlotDataType.GetFieldDefaultAsFloat(uiField);

	push	edi
	mov	ecx, OFFSET _sg_kSave+3436
	call	?GetFieldDefaultAsFloat@ModType@@QBEMI@Z ; ModType::GetFieldDefaultAsFloat
	fstp	DWORD PTR _fValue$225184[esp+64]

; 1630 : 				lua_pushnumber(L, fValue);

	fld	DWORD PTR _fValue$225184[esp+64]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	esi
	call	_lua_pushnumber
	add	esp, 12					; 0000000cH

; 1631 : 			}
; 1632 : 			break;

	jmp	SHORT $LN31@LoadModDat
$LN25@LoadModDat:

; 1633 : 
; 1634 : 			case ModType::TYPE_STRING:
; 1635 : 			{
; 1636 : 				const char* szField = kPlotDataType.GetFieldDefaultAsString(uiField);

	push	edi
	mov	ecx, OFFSET _sg_kSave+3436
	call	?GetFieldDefaultAsString@ModType@@QBEPBDI@Z ; ModType::GetFieldDefaultAsString

; 1637 : 				lua_pushstring(L, szField);

	push	eax

; 1638 : 			}
; 1639 : 			break;

	jmp	SHORT $LN74@LoadModDat
$LN24@LoadModDat:

; 1640 : 
; 1641 : 			case ModType::TYPE_ENUM:
; 1642 : 			{
; 1643 : 				int iValue = kPlotDataType.GetFieldDefaultAsInt(uiField);

	push	edi
	mov	ecx, OFFSET _sg_kSave+3436
	call	?GetFieldDefaultAsInt@ModType@@QBEHI@Z	; ModType::GetFieldDefaultAsInt

; 1644 : 				const ModEnum* pkEnum = sg_kSave.m_kModData.m_kPlotModData.GetFieldEnumType(uiField);

	push	edi
	mov	ecx, OFFSET _sg_kSave+3436
	mov	ebx, eax
	call	?GetFieldEnumType@ModType@@QBEPBVModEnum@@I@Z ; ModType::GetFieldEnumType

; 1645 : 				if(pkEnum != NULL)

	test	eax, eax
	je	SHORT $LN23@LoadModDat

; 1646 : 				{
; 1647 : 					const char* szMember = pkEnum->GetMember((uint)iValue);

	push	ebx
	mov	ecx, eax
	call	?GetMember@ModEnum@@QBEPBDI@Z		; ModEnum::GetMember

; 1648 : 					if(szMember == NULL) szMember = "";

	test	eax, eax
	jne	SHORT $LN22@LoadModDat
	mov	eax, OFFSET $SG225194
$LN22@LoadModDat:

; 1649 : 					lua_pushstring(L, szMember);

	push	eax

; 1650 : 				}
; 1651 : 				else

	jmp	SHORT $LN74@LoadModDat
$LN23@LoadModDat:

; 1652 : 				{
; 1653 : 					lua_pushstring(L, "");

	push	OFFSET $SG225196
$LN74@LoadModDat:
	push	esi
	call	_lua_pushstring
$LN73@LoadModDat:
	add	esp, 8
$LN31@LoadModDat:

; 1613 : 		for(uint uiField = 0; uiField < uiFieldCount; ++uiField)

	inc	edi
	cmp	edi, DWORD PTR _uiFieldCount$[esp+64]
	jb	$LL32@LoadModDat
$LN30@LoadModDat:

; 1654 : 				}
; 1655 : 			}
; 1656 : 			}
; 1657 : 		}
; 1658 : 
; 1659 : 		const uint uiMapWidth = sg_kSave.GetWidth();

	mov	ebx, DWORD PTR _sg_kSave+12228

; 1660 : 		const uint uiMapHeight = sg_kSave.GetHeight();

	mov	edi, DWORD PTR _sg_kSave+12232

; 1661 : 
; 1662 : 		lua_pushstring(L, "Plots");

	push	OFFSET $SG225199
	push	esi
	mov	DWORD PTR _uiMapWidth$225197[esp+72], ebx
	mov	DWORD PTR _uiMapHeight$225198[esp+72], edi
	call	_lua_pushstring

; 1663 : 		lua_createtable(L, uiMapWidth, 1);

	push	1
	push	ebx
	push	esi
	call	_lua_createtable
	add	esp, 20					; 00000014H

; 1664 : 		for(uint x = 0; x < uiMapWidth; ++x)

	mov	DWORD PTR _x$225200[esp+64], 0
	test	ebx, ebx
	jbe	$LN18@LoadModDat
$LN20@LoadModDat:

; 1665 : 		{
; 1666 : 			lua_createtable(L, uiMapHeight, 1);

	push	1
	push	edi
	push	esi
	call	_lua_createtable

; 1667 : 			for(uint y = 0; y < uiMapHeight; ++y)

	xor	ebx, ebx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _y$225204[esp+64], ebx
	test	edi, edi
	jbe	$LN15@LoadModDat
	mov	eax, DWORD PTR _x$225200[esp+64]
	mov	DWORD PTR tv619[esp+64], eax
$LN17@LoadModDat:

; 1668 : 			{
; 1669 : 				lua_createtable(L, 0, uiFieldCount);

	mov	ecx, DWORD PTR _uiFieldCount$[esp+64]
	push	ecx
	push	0
	push	esi
	call	_lua_createtable

; 1670 : 				ModDataEntry kPlot = sg_kSave.m_kModData.GetPlotDataEntry(x + y * uiMapWidth);

	mov	edx, DWORD PTR tv619[esp+76]
	add	esp, 12					; 0000000cH
	push	edx
	lea	eax, DWORD PTR _kPlot$225208[esp+68]
	push	eax
	mov	ecx, OFFSET _sg_kSave+2888
	call	?GetPlotDataEntry@CvWorldBuilderMapModData@@QAE?AVModDataEntry@@I@Z ; CvWorldBuilderMapModData::GetPlotDataEntry

; 1671 : 				for(uint uiField = 0; uiField < uiFieldCount; ++uiField)

	xor	edi, edi
	cmp	DWORD PTR _uiFieldCount$[esp+64], edi
	jbe	$LN12@LoadModDat

; 1668 : 			{
; 1669 : 				lua_createtable(L, 0, uiFieldCount);

	mov	ebx, DWORD PTR _iFieldStart$225171[esp+64]
$LL14@LoadModDat:

; 1672 : 				{
; 1673 : 					if(kPlot.IsFieldDefaultValue(uiField))

	push	edi
	lea	ecx, DWORD PTR _kPlot$225208[esp+68]
	call	?IsFieldDefaultValue@ModDataEntry@@QBE_NI@Z ; ModDataEntry::IsFieldDefaultValue
	test	al, al
	je	SHORT $LN11@LoadModDat

; 1674 : 					{
; 1675 : 						lua_pushvalue(L, iFieldStart + 2 * uiField);

	push	ebx
	push	esi
	call	_lua_pushvalue

; 1676 : 						lua_pushvalue(L, iFieldStart + 2 * uiField + 1);

	lea	ecx, DWORD PTR [ebx+1]
	push	ecx
	push	esi
	call	_lua_pushvalue

; 1677 : 						lua_rawset(L, -3);
; 1678 : 					}
; 1679 : 					else

	jmp	$LN75@LoadModDat
$LN11@LoadModDat:

; 1680 : 					{
; 1681 : 						switch(sg_kSave.m_kModData.m_kPlotModData.GetFieldType(uiField))

	push	edi
	mov	ecx, OFFSET _sg_kSave+3436
	call	?GetFieldType@ModType@@QBE?AW4FieldType@1@I@Z ; ModType::GetFieldType
	cmp	eax, 3
	ja	$LN13@LoadModDat
	jmp	DWORD PTR $LN79@LoadModDat[eax*4]
$LN7@LoadModDat:

; 1682 : 						{
; 1683 : 						case ModType::TYPE_BOOL:
; 1684 : 						{
; 1685 : 							const bool bValue = kPlot.GetFieldAsBool(uiField);

	push	edi
	lea	ecx, DWORD PTR _kPlot$225208[esp+68]
	call	?GetFieldAsBool@ModDataEntry@@QBE_NI@Z	; ModDataEntry::GetFieldAsBool

; 1686 : 							lua_pushvalue(L, iFieldStart + 2 * uiField);

	push	ebx
	push	esi
	mov	BYTE PTR _bValue$225221[esp+72], al
	call	_lua_pushvalue

; 1687 : 							lua_pushboolean(L, bValue);

	movzx	edx, BYTE PTR _bValue$225221[esp+72]
	push	edx
	push	esi
	call	_lua_pushboolean

; 1688 : 							lua_rawset(L, -3);
; 1689 : 						}
; 1690 : 						break;

	jmp	$LN75@LoadModDat
$LN6@LoadModDat:

; 1691 : 
; 1692 : 						case ModType::TYPE_FLOAT:
; 1693 : 						{
; 1694 : 							const float fValue = kPlot.GetFieldAsFloat(uiField);

	push	edi
	lea	ecx, DWORD PTR _kPlot$225208[esp+68]
	call	?GetFieldAsFloat@ModDataEntry@@QBEMI@Z	; ModDataEntry::GetFieldAsFloat
	fstp	DWORD PTR _fValue$225223[esp+64]

; 1695 : 							lua_pushvalue(L, iFieldStart + 2 * uiField);

	push	ebx
	push	esi
	call	_lua_pushvalue

; 1696 : 							lua_pushnumber(L, fValue);

	fld	DWORD PTR _fValue$225223[esp+72]
	fstp	QWORD PTR [esp]
	push	esi
	call	_lua_pushnumber

; 1697 : 							lua_rawset(L, -3);

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset
	add	esp, 20					; 00000014H

; 1698 : 						}
; 1699 : 						break;

	jmp	SHORT $LN13@LoadModDat
$LN5@LoadModDat:

; 1700 : 
; 1701 : 						case ModType::TYPE_STRING:
; 1702 : 						{
; 1703 : 							const char* szField = kPlot.GetFieldAsString(uiField);

	push	edi
	lea	ecx, DWORD PTR _kPlot$225208[esp+68]
	call	?GetFieldAsString@ModDataEntry@@QBEPBDI@Z ; ModDataEntry::GetFieldAsString

; 1704 : 							lua_pushvalue(L, iFieldStart + 2 * uiField);

	push	ebx
	push	esi
	mov	DWORD PTR _szField$225225[esp+72], eax
	call	_lua_pushvalue

; 1705 : 							lua_pushstring(L, szField);

	mov	eax, DWORD PTR _szField$225225[esp+72]
	push	eax

; 1706 : 							lua_rawset(L, -3);
; 1707 : 						}
; 1708 : 						break;

	jmp	SHORT $LN76@LoadModDat
$LN4@LoadModDat:

; 1709 : 
; 1710 : 						case ModType::TYPE_ENUM:
; 1711 : 						{
; 1712 : 							int iValue = kPlot.GetFieldAsInt(uiField);

	push	edi
	lea	ecx, DWORD PTR _kPlot$225208[esp+68]
	call	?GetFieldAsInt@ModDataEntry@@QBEHI@Z	; ModDataEntry::GetFieldAsInt

; 1713 : 							const ModEnum* pkEnum = kPlotDataType.GetFieldEnumType(uiField);

	push	edi
	mov	ecx, OFFSET _sg_kSave+3436
	mov	DWORD PTR _iValue$225227[esp+68], eax
	call	?GetFieldEnumType@ModType@@QBEPBVModEnum@@I@Z ; ModType::GetFieldEnumType

; 1714 : 							if(pkEnum != NULL)

	test	eax, eax
	je	SHORT $LN13@LoadModDat

; 1715 : 							{
; 1716 : 								const char* szMember = pkEnum->GetMember((uint)iValue);

	mov	ecx, DWORD PTR _iValue$225227[esp+64]
	push	ecx
	mov	ecx, eax
	call	?GetMember@ModEnum@@QBEPBDI@Z		; ModEnum::GetMember
	mov	DWORD PTR _szMember$225230[esp+64], eax

; 1717 : 								if(szMember != NULL)

	test	eax, eax
	je	SHORT $LN13@LoadModDat

; 1718 : 								{
; 1719 : 									lua_pushvalue(L, iFieldStart + 2 * uiField);

	push	ebx
	push	esi
	call	_lua_pushvalue

; 1720 : 									lua_pushstring(L, szMember);

	mov	edx, DWORD PTR _szMember$225230[esp+72]
	push	edx
$LN76@LoadModDat:
	push	esi
	call	_lua_pushstring
$LN75@LoadModDat:

; 1721 : 									lua_rawset(L, -3);

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset
	add	esp, 24					; 00000018H
$LN13@LoadModDat:
	inc	edi
	add	ebx, 2
	cmp	edi, DWORD PTR _uiFieldCount$[esp+64]
	jb	$LL14@LoadModDat

; 1671 : 				for(uint uiField = 0; uiField < uiFieldCount; ++uiField)

	mov	ebx, DWORD PTR _y$225204[esp+64]
$LN12@LoadModDat:

; 1722 : 								}
; 1723 : 							}
; 1724 : 						}
; 1725 : 						}
; 1726 : 					}
; 1727 : 				}
; 1728 : 
; 1729 : 				lua_rawseti(L, -2, y);

	push	ebx
	push	-2					; fffffffeH
	push	esi
	call	_lua_rawseti
	mov	eax, DWORD PTR _uiMapWidth$225197[esp+76]
	add	DWORD PTR tv619[esp+76], eax
	inc	ebx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _y$225204[esp+64], ebx
	cmp	ebx, DWORD PTR _uiMapHeight$225198[esp+64]
	jb	$LN17@LoadModDat

; 1667 : 			for(uint y = 0; y < uiMapHeight; ++y)

	mov	edi, DWORD PTR _uiMapHeight$225198[esp+64]
$LN15@LoadModDat:

; 1730 : 			}
; 1731 : 
; 1732 : 			lua_rawseti(L, -2, x);

	mov	ebx, DWORD PTR _x$225200[esp+64]
	push	ebx
	push	-2					; fffffffeH
	push	esi
	call	_lua_rawseti
	inc	ebx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _x$225200[esp+64], ebx
	cmp	ebx, DWORD PTR _uiMapWidth$225197[esp+64]
	jb	$LN20@LoadModDat
$LN18@LoadModDat:

; 1733 : 		}
; 1734 : 
; 1735 : 		lua_rawset(L, iModDataTable);

	mov	eax, DWORD PTR _iTop$[esp+64]
	inc	eax
	push	eax
	push	esi
	call	_lua_rawset
	add	esp, 8

; 1736 : 	}
; 1737 : 	else

	jmp	SHORT $LN1@LoadModDat
$LN33@LoadModDat:

; 1738 : 	{
; 1739 : 		lua_pushstring(L, "Plots");

	push	OFFSET $SG225234
	push	esi
	call	_lua_pushstring

; 1740 : 		lua_pushnil(L);

	push	esi
	call	_lua_pushnil

; 1741 : 		lua_rawset(L, iModDataTable);

	push	edi
	push	esi
	call	_lua_rawset
	add	esp, 20					; 00000014H
$LN1@LoadModDat:

; 1742 : 	}
; 1743 : 
; 1744 : 	lua_settop(L, iTop);

	mov	ecx, DWORD PTR _iTop$[esp+64]
	push	ecx
	push	esi
	call	_lua_settop
	add	esp, 8
$LN69@LoadModDat:

; 1747 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN77@LoadModDat:
	DD	$LN41@LoadModDat
	DD	$LN40@LoadModDat
	DD	$LN39@LoadModDat
	DD	$LN38@LoadModDat
$LN78@LoadModDat:
	DD	$LN27@LoadModDat
	DD	$LN26@LoadModDat
	DD	$LN25@LoadModDat
	DD	$LN24@LoadModDat
$LN79@LoadModDat:
	DD	$LN7@LoadModDat
	DD	$LN6@LoadModDat
	DD	$LN5@LoadModDat
	DD	$LN4@LoadModDat
?LoadModData@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ENDP ; CvWorldBuilderMapLoader::LoadModData
_TEXT	ENDS
PUBLIC	?ClearResources@CvWorldBuilderMapLoader@@SAXXZ	; CvWorldBuilderMapLoader::ClearResources
; Function compile flags: /Ogtpy
;	COMDAT ?ClearResources@CvWorldBuilderMapLoader@@SAXXZ
_TEXT	SEGMENT
?ClearResources@CvWorldBuilderMapLoader@@SAXXZ PROC	; CvWorldBuilderMapLoader::ClearResources, COMDAT

; 1893 : 	const uint uiPlotCount = sg_kSave.GetPlotCount();

	mov	ecx, DWORD PTR _sg_kSave+12228
	mov	edx, ecx
	imul	edx, DWORD PTR _sg_kSave+12232

; 1894 : 	for(uint i = 0; i < uiPlotCount; ++i)

	xor	eax, eax
	test	edx, edx
	jbe	SHORT $LN1@ClearResou
	push	esi
	mov	esi, OFFSET _sg_kSave+12320
	jmp	SHORT $LN3@ClearResou
	npad	3
$LL16@ClearResou:

; 1893 : 	const uint uiPlotCount = sg_kSave.GetPlotCount();

	mov	ecx, DWORD PTR _sg_kSave+12228
$LN3@ClearResou:

; 1895 : 	{
; 1896 : 		CvWorldBuilderMap::PlotMapData& kPlot = sg_kSave.GetPlotData(i);

	imul	ecx, DWORD PTR _sg_kSave+12232
	cmp	eax, ecx
	jae	SHORT $LN9@ClearResou
	mov	ecx, esi
	cmp	eax, 32768				; 00008000H
	jb	SHORT $LN8@ClearResou
$LN9@ClearResou:
	mov	ecx, OFFSET ?sm_kErrorPlotMapData@CvWorldBuilderMap@@0VPlotMapData@1@A ; CvWorldBuilderMap::sm_kErrorPlotMapData
$LN8@ClearResou:
	inc	eax
	add	esi, 8

; 1897 : 		kPlot.SetResourceType(CvWorldBuilderMap::PlotMapData::InvalidResource);

	mov	BYTE PTR [ecx+1], 255			; 000000ffH
	cmp	eax, edx
	jb	SHORT $LL16@ClearResou
	pop	esi
$LN1@ClearResou:

; 1898 : 	}
; 1899 : }

	ret	0
?ClearResources@CvWorldBuilderMapLoader@@SAXXZ ENDP	; CvWorldBuilderMapLoader::ClearResources
_TEXT	ENDS
PUBLIC	?ClearGoodies@CvWorldBuilderMapLoader@@SAXXZ	; CvWorldBuilderMapLoader::ClearGoodies
EXTRN	?IsGoody@CvImprovementEntry@@QBE_NXZ:PROC	; CvImprovementEntry::IsGoody
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?ClearGoodies@CvWorldBuilderMapLoader@@SAXXZ
_TEXT	SEGMENT
?ClearGoodies@CvWorldBuilderMapLoader@@SAXXZ PROC	; CvWorldBuilderMapLoader::ClearGoodies, COMDAT

; 1902 : {

	push	ebp

; 1903 : 	const uint uiPlotCount = sg_kSave.GetPlotCount();

	mov	ebp, DWORD PTR _sg_kSave+12228
	imul	ebp, DWORD PTR _sg_kSave+12232
	push	edi

; 1904 : 	for(uint i = 0; i < uiPlotCount; ++i)

	xor	edi, edi
	test	ebp, ebp
	jbe	SHORT $LN4@ClearGoodi
	push	ebx
	push	esi
	mov	ebx, OFFSET _sg_kSave+274464
	npad	4
$LL18@ClearGoodi:

; 1905 : 	{
; 1906 : 		CvWorldBuilderMap::PlotScenarioData& kPlot = sg_kSave.GetPlotScenarioData(i);

	mov	eax, DWORD PTR _sg_kSave+12228
	imul	eax, DWORD PTR _sg_kSave+12232
	cmp	edi, eax
	jae	SHORT $LN12@ClearGoodi
	mov	esi, ebx
	cmp	edi, 32768				; 00008000H
	jb	SHORT $LN11@ClearGoodi
$LN12@ClearGoodi:
	mov	esi, OFFSET ?sm_kErrorPlotScenarioData@CvWorldBuilderMap@@0UPlotScenarioData@1@A ; CvWorldBuilderMap::sm_kErrorPlotScenarioData
$LN11@ClearGoodi:

; 1907 : 		if(kPlot.m_byImprovement != CvWorldBuilderMap::PlotScenarioData::InvalidImprovement)

	mov	al, BYTE PTR [esi+5]
	cmp	al, 255					; 000000ffH
	je	SHORT $LN5@ClearGoodi

; 1908 : 		{
; 1909 : 			ImprovementTypes eType = (ImprovementTypes)kPlot.m_byImprovement;

	movzx	eax, al

; 1910 : 			const CvImprovementEntry* pkImprovement = GC.getImprovementInfo(eType);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo

; 1911 : 			if(pkImprovement == NULL || pkImprovement->IsGoody())

	test	eax, eax
	je	SHORT $LN1@ClearGoodi
	mov	ecx, eax
	call	?IsGoody@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsGoody
	test	al, al
	je	SHORT $LN5@ClearGoodi
$LN1@ClearGoodi:

; 1912 : 				kPlot.m_byImprovement = CvWorldBuilderMap::PlotScenarioData::InvalidImprovement;

	mov	BYTE PTR [esi+5], 255			; 000000ffH
$LN5@ClearGoodi:

; 1904 : 	for(uint i = 0; i < uiPlotCount; ++i)

	inc	edi
	add	ebx, 8
	cmp	edi, ebp
	jb	SHORT $LL18@ClearGoodi
	pop	esi
	pop	ebx
$LN4@ClearGoodi:
	pop	edi
	pop	ebp

; 1913 : 		}
; 1914 : 	}
; 1915 : }

	ret	0
?ClearGoodies@CvWorldBuilderMapLoader@@SAXXZ ENDP	; CvWorldBuilderMapLoader::ClearGoodies
_TEXT	ENDS
PUBLIC	?ResetPlayerSlots@CvWorldBuilderMapLoader@@SAXXZ ; CvWorldBuilderMapLoader::ResetPlayerSlots
_BSS	SEGMENT
_sg_auiPlayerSlots DD 03fH DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT ?ResetPlayerSlots@CvWorldBuilderMapLoader@@SAXXZ
_TEXT	SEGMENT
?ResetPlayerSlots@CvWorldBuilderMapLoader@@SAXXZ PROC	; CvWorldBuilderMapLoader::ResetPlayerSlots, COMDAT

; 1965 : 	for(uint i = 0; i < MAX_CIV_PLAYERS; ++i)

	xor	eax, eax
$LL3@ResetPlaye:

; 1966 : 		sg_auiPlayerSlots[i] = i;

	mov	DWORD PTR _sg_auiPlayerSlots[eax*4], eax
	inc	eax
	cmp	eax, 63					; 0000003fH
	jb	SHORT $LL3@ResetPlaye

; 1967 : }

	ret	0
?ResetPlayerSlots@CvWorldBuilderMapLoader@@SAXXZ ENDP	; CvWorldBuilderMapLoader::ResetPlayerSlots
_TEXT	ENDS
PUBLIC	?MapPlayerToSlot@CvWorldBuilderMapLoader@@SAXIW4PlayerTypes@@@Z ; CvWorldBuilderMapLoader::MapPlayerToSlot
; Function compile flags: /Ogtpy
;	COMDAT ?MapPlayerToSlot@CvWorldBuilderMapLoader@@SAXIW4PlayerTypes@@@Z
_TEXT	SEGMENT
_uiPlayer$ = 8						; size = 4
_ePlayerSlot$ = 12					; size = 4
?MapPlayerToSlot@CvWorldBuilderMapLoader@@SAXIW4PlayerTypes@@@Z PROC ; CvWorldBuilderMapLoader::MapPlayerToSlot, COMDAT

; 1971 : 	if(uiPlayer < MAX_CIV_PLAYERS && ePlayerSlot >= 0 && ePlayerSlot < MAX_CIV_PLAYERS)

	mov	ecx, DWORD PTR _uiPlayer$[esp-4]
	cmp	ecx, 63					; 0000003fH
	jae	SHORT $LN1@MapPlayerT
	push	esi
	mov	esi, DWORD PTR _ePlayerSlot$[esp]
	cmp	esi, 62					; 0000003eH
	ja	SHORT $LN13@MapPlayerT
	push	edi

; 1972 : 	{
; 1973 : 		const uint uiCurrent = sg_auiPlayerSlots[ePlayerSlot];

	mov	edi, DWORD PTR _sg_auiPlayerSlots[esi*4]

; 1974 : 		if(uiCurrent != uiPlayer)

	cmp	edi, ecx
	je	SHORT $LN14@MapPlayerT

; 1975 : 		{
; 1976 : 			PlayerTypes eOldSlot = NO_PLAYER;

	or	edx, -1

; 1977 : 			for(uint i = 0; i < MAX_CIV_PLAYERS; ++i)

	xor	eax, eax
$LL5@MapPlayerT:

; 1978 : 			{
; 1979 : 				if(sg_auiPlayerSlots[i] == uiPlayer)

	cmp	DWORD PTR _sg_auiPlayerSlots[eax*4], ecx
	je	SHORT $LN11@MapPlayerT
	inc	eax
	cmp	eax, 63					; 0000003fH
	jb	SHORT $LL5@MapPlayerT
	jmp	SHORT $LN3@MapPlayerT
$LN11@MapPlayerT:

; 1980 : 				{
; 1981 : 					eOldSlot = (PlayerTypes)i;

	mov	edx, eax
$LN3@MapPlayerT:

; 1982 : 					break;
; 1983 : 				}
; 1984 : 			}
; 1985 : 
; 1986 : 			sg_auiPlayerSlots[ePlayerSlot] = uiPlayer;

	mov	DWORD PTR _sg_auiPlayerSlots[esi*4], ecx

; 1987 : 
; 1988 : 			FAssertMsg(eOldSlot != NO_PLAYER, "Player list has holes in it!")
; 1989 : 			if(eOldSlot != NO_PLAYER)

	cmp	edx, -1
	je	SHORT $LN14@MapPlayerT

; 1990 : 				sg_auiPlayerSlots[eOldSlot] = uiCurrent;

	mov	DWORD PTR _sg_auiPlayerSlots[edx*4], edi
$LN14@MapPlayerT:
	pop	edi
$LN13@MapPlayerT:
	pop	esi
$LN1@MapPlayerT:

; 1991 : 		}
; 1992 : 	}
; 1993 : }

	ret	0
?MapPlayerToSlot@CvWorldBuilderMapLoader@@SAXIW4PlayerTypes@@@Z ENDP ; CvWorldBuilderMapLoader::MapPlayerToSlot
_TEXT	ENDS
PUBLIC	?GetMapPlayerSlot@CvWorldBuilderMapLoader@@SA?AW4PlayerTypes@@I@Z ; CvWorldBuilderMapLoader::GetMapPlayerSlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetMapPlayerSlot@CvWorldBuilderMapLoader@@SA?AW4PlayerTypes@@I@Z
_TEXT	SEGMENT
_uiPlayer$ = 8						; size = 4
?GetMapPlayerSlot@CvWorldBuilderMapLoader@@SA?AW4PlayerTypes@@I@Z PROC ; CvWorldBuilderMapLoader::GetMapPlayerSlot, COMDAT

; 1997 : 	for(int i = 0; i < MAX_CIV_PLAYERS; ++i)

	mov	ecx, DWORD PTR _uiPlayer$[esp-4]
	xor	eax, eax
$LL4@GetMapPlay:

; 1998 : 	{
; 1999 : 		if(sg_auiPlayerSlots[i] == uiPlayer)

	cmp	DWORD PTR _sg_auiPlayerSlots[eax*4], ecx
	je	SHORT $LN5@GetMapPlay
	inc	eax
	cmp	eax, 63					; 0000003fH
	jl	SHORT $LL4@GetMapPlay

; 2000 : 			return static_cast<PlayerTypes>(i);
; 2001 : 	}
; 2002 : 
; 2003 : 	return NO_PLAYER;

	or	eax, -1
$LN5@GetMapPlay:

; 2004 : }

	ret	0
?GetMapPlayerSlot@CvWorldBuilderMapLoader@@SA?AW4PlayerTypes@@I@Z ENDP ; CvWorldBuilderMapLoader::GetMapPlayerSlot
_TEXT	ENDS
PUBLIC	?GetMapPlayerCount@CvWorldBuilderMapLoader@@SAHXZ ; CvWorldBuilderMapLoader::GetMapPlayerCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetMapPlayerCount@CvWorldBuilderMapLoader@@SAHXZ
_TEXT	SEGMENT
?GetMapPlayerCount@CvWorldBuilderMapLoader@@SAHXZ PROC	; CvWorldBuilderMapLoader::GetMapPlayerCount, COMDAT

; 2008 : 	return MAX_CIV_PLAYERS;

	mov	eax, 63					; 0000003fH

; 2009 : }

	ret	0
?GetMapPlayerCount@CvWorldBuilderMapLoader@@SAHXZ ENDP	; CvWorldBuilderMapLoader::GetMapPlayerCount
_TEXT	ENDS
PUBLIC	?PreviewPlayableCivCount@CvWorldBuilderMapLoader@@SAIPB_W@Z ; CvWorldBuilderMapLoader::PreviewPlayableCivCount
EXTRN	?PreviewPlayableCivCount@CvWorldBuilderMap@@SAIPB_W@Z:PROC ; CvWorldBuilderMap::PreviewPlayableCivCount
; Function compile flags: /Ogtpy
;	COMDAT ?PreviewPlayableCivCount@CvWorldBuilderMapLoader@@SAIPB_W@Z
_TEXT	SEGMENT
_wszFilename$ = 8					; size = 4
?PreviewPlayableCivCount@CvWorldBuilderMapLoader@@SAIPB_W@Z PROC ; CvWorldBuilderMapLoader::PreviewPlayableCivCount, COMDAT

; 2017 : 	return CvWorldBuilderMap::PreviewPlayableCivCount(wszFilename);

	jmp	?PreviewPlayableCivCount@CvWorldBuilderMap@@SAIPB_W@Z ; CvWorldBuilderMap::PreviewPlayableCivCount
?PreviewPlayableCivCount@CvWorldBuilderMapLoader@@SAIPB_W@Z ENDP ; CvWorldBuilderMapLoader::PreviewPlayableCivCount
_TEXT	ENDS
PUBLIC	?CheckTempMap@@YA_NPB_W@Z			; CheckTempMap
; Function compile flags: /Ogtpy
;	COMDAT ?CheckTempMap@@YA_NPB_W@Z
_TEXT	SEGMENT
_wszFilename$ = 8					; size = 4
?CheckTempMap@@YA_NPB_W@Z PROC				; CheckTempMap, COMDAT

; 2025 : 	FAssert(wszFilename);
; 2026 : 
; 2027 : 	if(wszFilename && *wszFilename)

	mov	eax, DWORD PTR _wszFilename$[esp-4]
	test	eax, eax
	je	SHORT $LN1@CheckTempM
	cmp	WORD PTR [eax], 0
	je	SHORT $LN1@CheckTempM

; 2028 : 	{
; 2029 : 		return wcscmp(wszFilename, sg_wszTempMapName) == 0;

	mov	ecx, OFFSET _sg_wszTempMapName
$LL4@CheckTempM:
	mov	dx, WORD PTR [eax]
	cmp	dx, WORD PTR [ecx]
	jne	SHORT $LN5@CheckTempM
	test	dx, dx
	je	SHORT $LN6@CheckTempM
	mov	dx, WORD PTR [eax+2]
	cmp	dx, WORD PTR [ecx+2]
	jne	SHORT $LN5@CheckTempM
	add	eax, 4
	add	ecx, 4
	test	dx, dx
	jne	SHORT $LL4@CheckTempM
$LN6@CheckTempM:
	xor	eax, eax
	xor	ecx, ecx
	test	eax, eax
	sete	cl
	mov	al, cl

; 2033 : }

	ret	0
$LN5@CheckTempM:

; 2028 : 	{
; 2029 : 		return wcscmp(wszFilename, sg_wszTempMapName) == 0;

	sbb	eax, eax
	sbb	eax, -1
	xor	ecx, ecx
	test	eax, eax
	sete	cl
	mov	al, cl

; 2033 : }

	ret	0
$LN1@CheckTempM:

; 2030 : 	}
; 2031 : 
; 2032 : 	return false;

	xor	al, al

; 2033 : }

	ret	0
?CheckTempMap@@YA_NPB_W@Z ENDP				; CheckTempMap
_TEXT	ENDS
PUBLIC	?TempMapLoaded@@YAXPB_W@Z			; TempMapLoaded
EXTRN	__imp__wcscpy_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?TempMapLoaded@@YAXPB_W@Z
_TEXT	SEGMENT
_wszFilename$ = 8					; size = 4
?TempMapLoaded@@YAXPB_W@Z PROC				; TempMapLoaded, COMDAT

; 2037 : 	wcscpy_s(sg_wszTempMapName, MAX_PATH, wszFilename);

	mov	eax, DWORD PTR _wszFilename$[esp-4]
	push	eax
	push	260					; 00000104H
	push	OFFSET _sg_wszTempMapName
	call	DWORD PTR __imp__wcscpy_s
	add	esp, 12					; 0000000cH

; 2038 : }

	ret	0
?TempMapLoaded@@YAXPB_W@Z ENDP				; TempMapLoaded
_TEXT	ENDS
PUBLIC	??A?$CvWorldBuilderMapElementAllocator@UUnitName@CvWorldBuilderMap@@$03@@QAEPAUUnitName@CvWorldBuilderMap@@VHandle@0@@Z ; CvWorldBuilderMapElementAllocator<CvWorldBuilderMap::UnitName,4>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvworldbuildermap\include\cvworldbuildermapelementallocator.h
;	COMDAT ??A?$CvWorldBuilderMapElementAllocator@UUnitName@CvWorldBuilderMap@@$03@@QAEPAUUnitName@CvWorldBuilderMap@@VHandle@0@@Z
_TEXT	SEGMENT
_h$ = 8							; size = 2
??A?$CvWorldBuilderMapElementAllocator@UUnitName@CvWorldBuilderMap@@$03@@QAEPAUUnitName@CvWorldBuilderMap@@VHandle@0@@Z PROC ; CvWorldBuilderMapElementAllocator<CvWorldBuilderMap::UnitName,4>::operator[], COMDAT
; _this$ = ecx

; 118  : 		if( h.m_wIndex < m_uiSize ) return (T*)&(m_aData[h.m_wIndex]);

	movzx	eax, WORD PTR _h$[esp-4]
	cmp	eax, DWORD PTR [ecx+8]
	jae	SHORT $LN2@operator
	shl	eax, 6
	add	eax, DWORD PTR [ecx]

; 120  : 	}

	ret	4
$LN2@operator:

; 119  : 		else return NULL;

	xor	eax, eax

; 120  : 	}

	ret	4
??A?$CvWorldBuilderMapElementAllocator@UUnitName@CvWorldBuilderMap@@$03@@QAEPAUUnitName@CvWorldBuilderMap@@VHandle@0@@Z ENDP ; CvWorldBuilderMapElementAllocator<CvWorldBuilderMap::UnitName,4>::operator[]
_TEXT	ENDS
PUBLIC	?Valid@Handle@?$CvWorldBuilderMapElementAllocator@UUnitName@CvWorldBuilderMap@@$03@@QBE?B_NXZ ; CvWorldBuilderMapElementAllocator<CvWorldBuilderMap::UnitName,4>::Handle::Valid
; Function compile flags: /Ogtpy
;	COMDAT ?Valid@Handle@?$CvWorldBuilderMapElementAllocator@UUnitName@CvWorldBuilderMap@@$03@@QBE?B_NXZ
_TEXT	SEGMENT
?Valid@Handle@?$CvWorldBuilderMapElementAllocator@UUnitName@CvWorldBuilderMap@@$03@@QBE?B_NXZ PROC ; CvWorldBuilderMapElementAllocator<CvWorldBuilderMap::UnitName,4>::Handle::Valid, COMDAT
; _this$ = ecx

; 45   : 		inline const bool Valid() const { return m_wIndex != word(-1); }

	mov	eax, 65535				; 0000ffffH
	cmp	WORD PTR [ecx], ax
	setne	al
	ret	0
?Valid@Handle@?$CvWorldBuilderMapElementAllocator@UUnitName@CvWorldBuilderMap@@$03@@QBE?B_NXZ ENDP ; CvWorldBuilderMapElementAllocator<CvWorldBuilderMap::UnitName,4>::Handle::Valid
_TEXT	ENDS
PUBLIC	??A?$CvWorldBuilderMapElementAllocator@UUnit@CvWorldBuilderMap@@$0BA@@@QAEPAUUnit@CvWorldBuilderMap@@VHandle@0@@Z ; CvWorldBuilderMapElementAllocator<CvWorldBuilderMap::Unit,16>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$CvWorldBuilderMapElementAllocator@UUnit@CvWorldBuilderMap@@$0BA@@@QAEPAUUnit@CvWorldBuilderMap@@VHandle@0@@Z
_TEXT	SEGMENT
_h$ = 8							; size = 2
??A?$CvWorldBuilderMapElementAllocator@UUnit@CvWorldBuilderMap@@$0BA@@@QAEPAUUnit@CvWorldBuilderMap@@VHandle@0@@Z PROC ; CvWorldBuilderMapElementAllocator<CvWorldBuilderMap::Unit,16>::operator[], COMDAT
; _this$ = ecx

; 118  : 		if( h.m_wIndex < m_uiSize ) return (T*)&(m_aData[h.m_wIndex]);

	movzx	eax, WORD PTR _h$[esp-4]
	cmp	eax, DWORD PTR [ecx+8]
	jae	SHORT $LN2@operator@2
	imul	eax, 84					; 00000054H
	add	eax, DWORD PTR [ecx]

; 120  : 	}

	ret	4
$LN2@operator@2:

; 119  : 		else return NULL;

	xor	eax, eax

; 120  : 	}

	ret	4
??A?$CvWorldBuilderMapElementAllocator@UUnit@CvWorldBuilderMap@@$0BA@@@QAEPAUUnit@CvWorldBuilderMap@@VHandle@0@@Z ENDP ; CvWorldBuilderMapElementAllocator<CvWorldBuilderMap::Unit,16>::operator[]
_TEXT	ENDS
PUBLIC	??A?$CvWorldBuilderMapElementAllocator@UCity@CvWorldBuilderMap@@$07@@QAEPAUCity@CvWorldBuilderMap@@VHandle@0@@Z ; CvWorldBuilderMapElementAllocator<CvWorldBuilderMap::City,8>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$CvWorldBuilderMapElementAllocator@UCity@CvWorldBuilderMap@@$07@@QAEPAUCity@CvWorldBuilderMap@@VHandle@0@@Z
_TEXT	SEGMENT
_h$ = 8							; size = 2
??A?$CvWorldBuilderMapElementAllocator@UCity@CvWorldBuilderMap@@$07@@QAEPAUCity@CvWorldBuilderMap@@VHandle@0@@Z PROC ; CvWorldBuilderMapElementAllocator<CvWorldBuilderMap::City,8>::operator[], COMDAT
; _this$ = ecx

; 118  : 		if( h.m_wIndex < m_uiSize ) return (T*)&(m_aData[h.m_wIndex]);

	movzx	eax, WORD PTR _h$[esp-4]
	cmp	eax, DWORD PTR [ecx+8]
	jae	SHORT $LN2@operator@3
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR [ecx]

; 120  : 	}

	ret	4
$LN2@operator@3:

; 119  : 		else return NULL;

	xor	eax, eax

; 120  : 	}

	ret	4
??A?$CvWorldBuilderMapElementAllocator@UCity@CvWorldBuilderMap@@$07@@QAEPAUCity@CvWorldBuilderMap@@VHandle@0@@Z ENDP ; CvWorldBuilderMapElementAllocator<CvWorldBuilderMap::City,8>::operator[]
_TEXT	ENDS
PUBLIC	?Get@?$SerializableBitset@$0DAAAAA@@CvWorldBuilderMap@@QBE?B_NI@Z ; CvWorldBuilderMap::SerializableBitset<3145728>::Get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvworldbuildermap\include\cvworldbuildermap.h
;	COMDAT ?Get@?$SerializableBitset@$0DAAAAA@@CvWorldBuilderMap@@QBE?B_NI@Z
_TEXT	SEGMENT
_uiBitIndex$ = 8					; size = 4
?Get@?$SerializableBitset@$0DAAAAA@@CvWorldBuilderMap@@QBE?B_NI@Z PROC ; CvWorldBuilderMap::SerializableBitset<3145728>::Get, COMDAT
; _this$ = ecx

; 806  : 		{

	push	esi
	mov	esi, ecx

; 807  : 			FAssertMsg(uiBitIndex < TBits, "Out of range");
; 808  : 			const uint uiByte = uiBitIndex / 8;

	mov	ecx, DWORD PTR _uiBitIndex$[esp]
	mov	eax, ecx
	shr	eax, 3

; 809  : 			const uint uiBit = uiBitIndex % 8;
; 810  : 			const byte byMask = (1 << uiBit);
; 811  : 
; 812  : 			if( uiByte < ByteCount )

	cmp	eax, 393216				; 00060000H
	jae	SHORT $LN2@Get
	and	ecx, 7
	mov	dl, 1
	shl	dl, cl

; 813  : 				return (m_Mem[uiByte] & byMask) != 0;

	test	dl, BYTE PTR [eax+esi]
	pop	esi
	setne	al

; 816  : 		}

	ret	4
$LN2@Get:

; 814  : 			else
; 815  : 				return false;

	xor	al, al
	pop	esi

; 816  : 		}

	ret	4
?Get@?$SerializableBitset@$0DAAAAA@@CvWorldBuilderMap@@QBE?B_NI@Z ENDP ; CvWorldBuilderMap::SerializableBitset<3145728>::Get
_TEXT	ENDS
PUBLIC	??A?$BaseVector@PAVCvPlayer@@$0A@@@QAEAAPAVCvPlayer@@I@Z ; BaseVector<CvPlayer *,0>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@PAVCvPlayer@@$0A@@@QAEAAPAVCvPlayer@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@PAVCvPlayer@@$0A@@@QAEAAPAVCvPlayer@@I@Z PROC ; BaseVector<CvPlayer *,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@PAVCvPlayer@@$0A@@@QAEAAPAVCvPlayer@@I@Z ENDP ; BaseVector<CvPlayer *,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@PAVCvPlayer@@$0A@@@QBEIXZ	; BaseVector<CvPlayer *,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@PAVCvPlayer@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@PAVCvPlayer@@$0A@@@QBEIXZ PROC	; BaseVector<CvPlayer *,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@PAVCvPlayer@@$0A@@@QBEIXZ ENDP	; BaseVector<CvPlayer *,0>::size
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvWorldBuilderMapTypeDesc::String> >::~_Container_base_aux_alloc_empty<std::allocator<CvWorldBuilderMapTypeDesc::String> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvWorldBuilderMapTypeDesc::String> >::~_Container_base_aux_alloc_empty<std::allocator<CvWorldBuilderMapTypeDesc::String> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvWorldBuilderMapTypeDesc::String> >::~_Container_base_aux_alloc_empty<std::allocator<CvWorldBuilderMapTypeDesc::String> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@QAEXPAVString@CvWorldBuilderMapTypeDesc@@I@Z ; std::allocator<CvWorldBuilderMapTypeDesc::String>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@QAEXPAVString@CvWorldBuilderMapTypeDesc@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@QAEXPAVString@CvWorldBuilderMapTypeDesc@@I@Z PROC ; std::allocator<CvWorldBuilderMapTypeDesc::String>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@QAEXPAVString@CvWorldBuilderMapTypeDesc@@I@Z ENDP ; std::allocator<CvWorldBuilderMapTypeDesc::String>::deallocate
_TEXT	ENDS
PUBLIC	??1?$BaseVector@PAVCvPlayer@@$0A@@@QAE@XZ	; BaseVector<CvPlayer *,0>::~BaseVector<CvPlayer *,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@PAVCvPlayer@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@PAVCvPlayer@@$0A@@@QAE@XZ PROC		; BaseVector<CvPlayer *,0>::~BaseVector<CvPlayer *,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@PAVCvPlayer@@$0A@@@QAE@XZ ENDP		; BaseVector<CvPlayer *,0>::~BaseVector<CvPlayer *,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@PAVCvPlayer@@$0A@@@IAE@XZ	; BaseVector<CvPlayer *,0>::BaseVector<CvPlayer *,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@PAVCvPlayer@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@PAVCvPlayer@@$0A@@@IAE@XZ PROC		; BaseVector<CvPlayer *,0>::BaseVector<CvPlayer *,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@PAVCvPlayer@@$0A@@@IAE@XZ ENDP		; BaseVector<CvPlayer *,0>::BaseVector<CvPlayer *,0>
_TEXT	ENDS
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??_C@_0BL@HMFHJKFH@invalid?5bitset?$DMN?$DO?5position?$AA@ ; `string'
PUBLIC	?_Xran@?$bitset@$0BAA@@std@@ABEXXZ		; std::bitset<256>::_Xran
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BL@HMFHJKFH@invalid?5bitset?$DMN?$DO?5position?$AA@
CONST	SEGMENT
??_C@_0BL@HMFHJKFH@invalid?5bitset?$DMN?$DO?5position?$AA@ DB 'invalid bi'
	DB	'tset<N> position', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xran@?$bitset@$0BAA@@std@@ABEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xran@?$bitset@$0BAA@@std@@ABEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xran@?$bitset@$0BAA@@std@@ABEXXZ$2
__ehfuncinfo$?_Xran@?$bitset@$0BAA@@std@@ABEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xran@?$bitset@$0BAA@@std@@ABEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\bitset
xdata$x	ENDS
;	COMDAT ?_Xran@?$bitset@$0BAA@@std@@ABEXXZ
_TEXT	SEGMENT
$T227283 = -80						; size = 28
$T227282 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xran@?$bitset@$0BAA@@std@@ABEXXZ PROC			; std::bitset<256>::_Xran, COMDAT
; _this$ = ecx

; 420  : 		{	// report bit index out of range

	push	-1
	push	__ehhandler$?_Xran@?$bitset@$0BAA@@std@@ABEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 421  : 		_THROW(out_of_range, "invalid bitset<N> position");

	push	OFFSET ??_C@_0BL@HMFHJKFH@invalid?5bitset?$DMN?$DO?5position?$AA@
	lea	ecx, DWORD PTR $T227283[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T227282[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T227283[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T227282[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T227282[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T227282[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T227282[esp+88], OFFSET ??_7out_of_range@std@@6B@
	call	__CxxThrowException@8
$LN13@Xran:
$LN12@Xran:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xran@?$bitset@$0BAA@@std@@ABEXXZ$0:
	lea	ecx, DWORD PTR $T227283[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xran@?$bitset@$0BAA@@std@@ABEXXZ$2:
	lea	ecx, DWORD PTR $T227282[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xran@?$bitset@$0BAA@@std@@ABEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xran@?$bitset@$0BAA@@std@@ABEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xran@?$bitset@$0BAA@@std@@ABEXXZ ENDP			; std::bitset<256>::_Xran
PUBLIC	?_Xran@?$bitset@$0CAA@@std@@ABEXXZ		; std::bitset<512>::_Xran
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xran@?$bitset@$0CAA@@std@@ABEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xran@?$bitset@$0CAA@@std@@ABEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xran@?$bitset@$0CAA@@std@@ABEXXZ$2
__ehfuncinfo$?_Xran@?$bitset@$0CAA@@std@@ABEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xran@?$bitset@$0CAA@@std@@ABEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\bitset
xdata$x	ENDS
;	COMDAT ?_Xran@?$bitset@$0CAA@@std@@ABEXXZ
_TEXT	SEGMENT
$T227309 = -80						; size = 28
$T227308 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xran@?$bitset@$0CAA@@std@@ABEXXZ PROC			; std::bitset<512>::_Xran, COMDAT
; _this$ = ecx

; 420  : 		{	// report bit index out of range

	push	-1
	push	__ehhandler$?_Xran@?$bitset@$0CAA@@std@@ABEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 421  : 		_THROW(out_of_range, "invalid bitset<N> position");

	push	OFFSET ??_C@_0BL@HMFHJKFH@invalid?5bitset?$DMN?$DO?5position?$AA@
	lea	ecx, DWORD PTR $T227309[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T227308[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T227309[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T227308[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T227308[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T227308[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T227308[esp+88], OFFSET ??_7out_of_range@std@@6B@
	call	__CxxThrowException@8
$LN13@Xran@2:
$LN12@Xran@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xran@?$bitset@$0CAA@@std@@ABEXXZ$0:
	lea	ecx, DWORD PTR $T227309[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xran@?$bitset@$0CAA@@std@@ABEXXZ$2:
	lea	ecx, DWORD PTR $T227308[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xran@?$bitset@$0CAA@@std@@ABEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xran@?$bitset@$0CAA@@std@@ABEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xran@?$bitset@$0CAA@@std@@ABEXXZ ENDP			; std::bitset<512>::_Xran
PUBLIC	?GetTotalBitCount@?$FRelationshipBitset@$0GA@$00@@CA?BII@Z ; FRelationshipBitset<96,1>::GetTotalBitCount
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvworldbuildermap\include\frelationshipbitset.h
;	COMDAT ?GetTotalBitCount@?$FRelationshipBitset@$0GA@$00@@CA?BII@Z
_TEXT	SEGMENT
_uiElementCount$ = 8					; size = 4
?GetTotalBitCount@?$FRelationshipBitset@$0GA@$00@@CA?BII@Z PROC ; FRelationshipBitset<96,1>::GetTotalBitCount, COMDAT

; 92   : 		// BitCount = ((n - 1) / 2) * n where n is the team count
; 93   : 		return ((uiElementCount - 1) * uiElementCount) / 2;

	mov	ecx, DWORD PTR _uiElementCount$[esp-4]
	lea	eax, DWORD PTR [ecx-1]
	imul	eax, ecx
	shr	eax, 1

; 94   : 	}

	ret	0
?GetTotalBitCount@?$FRelationshipBitset@$0GA@$00@@CA?BII@Z ENDP ; FRelationshipBitset<96,1>::GetTotalBitCount
_TEXT	ENDS
PUBLIC	?GetTotalBitCount@?$FRelationshipBitset@$0GA@$0A@@@CA?BII@Z ; FRelationshipBitset<96,0>::GetTotalBitCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetTotalBitCount@?$FRelationshipBitset@$0GA@$0A@@@CA?BII@Z
_TEXT	SEGMENT
_uiElementCount$ = 8					; size = 4
?GetTotalBitCount@?$FRelationshipBitset@$0GA@$0A@@@CA?BII@Z PROC ; FRelationshipBitset<96,0>::GetTotalBitCount, COMDAT

; 92   : 		// BitCount = ((n - 1) / 2) * n where n is the team count
; 93   : 		return ((uiElementCount - 1) * uiElementCount) / 2;

	mov	ecx, DWORD PTR _uiElementCount$[esp-4]
	lea	eax, DWORD PTR [ecx-1]
	imul	eax, ecx
	shr	eax, 1

; 94   : 	}

	ret	0
?GetTotalBitCount@?$FRelationshipBitset@$0GA@$0A@@@CA?BII@Z ENDP ; FRelationshipBitset<96,0>::GetTotalBitCount
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@PAVCvPlayer@@$0A@@@IAEXPAPAVCvPlayer@@I@Z ; BaseVector<CvPlayer *,0>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@PAVCvPlayer@@$0A@@@IAEXPAPAVCvPlayer@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@PAVCvPlayer@@$0A@@@IAEXPAPAVCvPlayer@@I@Z PROC ; BaseVector<CvPlayer *,0>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@PAVCvPlayer@@$0A@@@IAEXPAPAVCvPlayer@@I@Z ENDP ; BaseVector<CvPlayer *,0>::Destroy
_TEXT	ENDS
PUBLIC	??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ ; `string'
PUBLIC	?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@SAPAXIIII@Z ; BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator::AllocAligned
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
CONST	SEGMENT
??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ DB 'c:\users\eno'
	DB	'rmousapplepie\documents\github\lekmod\lekmod_dll\fireplace\in'
	DB	'clude\fireworks\FFastVector.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@SAPAXIIII@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_nAlign$ = 12						; size = 4
_nAllocPool$ = 16					; size = 4
_nAllocSubID$ = 20					; size = 4
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@SAPAXIIII@Z PROC ; BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator::AllocAligned, COMDAT

; 85   : 			return FMALLOCALIGNED( nBytes, nAlign, nAllocPool, nAllocSubID );

	mov	DWORD PTR _nAllocSubID$[esp-4], 85	; 00000055H
	mov	DWORD PTR _nAllocPool$[esp-4], OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	jmp	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@SAPAXIIII@Z ENDP ; BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator::AllocAligned
_TEXT	ENDS
PUBLIC	?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@SAXPAX@Z ; BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator::FreeAligned
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
;	COMDAT ?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@SAXPAX@Z
_TEXT	SEGMENT
_pBlock$ = 8						; size = 4
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@SAXPAX@Z PROC ; BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator::FreeAligned, COMDAT

; 90   : 			FFREEALIGNED( pBlock );

	jmp	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@SAXPAX@Z ENDP ; BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator::FreeAligned
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@PAVString@CvWorldBuilderMapTypeDesc@@@Z ; std::_Vector_const_iterator<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Vector_const_iterator<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@PAVString@CvWorldBuilderMapTypeDesc@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@PAVString@CvWorldBuilderMapTypeDesc@@@Z PROC ; std::_Vector_const_iterator<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Vector_const_iterator<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@PAVString@CvWorldBuilderMapTypeDesc@@@Z ENDP ; std::_Vector_const_iterator<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Vector_const_iterator<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::operator==
_TEXT	ENDS
PUBLIC	??$min@E@std@@YAABEABE0@Z			; std::min<unsigned char>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$min@E@std@@YAABEABE0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@E@std@@YAABEABE0@Z PROC				; std::min<unsigned char>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	dl, BYTE PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	dl, BYTE PTR [ecx]
	jb	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@E@std@@YAABEABE0@Z ENDP				; std::min<unsigned char>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVString@CvWorldBuilderMapTypeDesc@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVString@CvWorldBuilderMapTypeDesc@@0@Z ; std::_Iter_random<CvWorldBuilderMapTypeDesc::String *,CvWorldBuilderMapTypeDesc::String *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVString@CvWorldBuilderMapTypeDesc@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVString@CvWorldBuilderMapTypeDesc@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVString@CvWorldBuilderMapTypeDesc@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVString@CvWorldBuilderMapTypeDesc@@0@Z PROC ; std::_Iter_random<CvWorldBuilderMapTypeDesc::String *,CvWorldBuilderMapTypeDesc::String *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVString@CvWorldBuilderMapTypeDesc@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVString@CvWorldBuilderMapTypeDesc@@0@Z ENDP ; std::_Iter_random<CvWorldBuilderMapTypeDesc::String *,CvWorldBuilderMapTypeDesc::String *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVString@CvWorldBuilderMapTypeDesc@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVString@CvWorldBuilderMapTypeDesc@@0@Z ; std::_Ptr_cat<CvWorldBuilderMapTypeDesc::String *,CvWorldBuilderMapTypeDesc::String *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVString@CvWorldBuilderMapTypeDesc@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVString@CvWorldBuilderMapTypeDesc@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVString@CvWorldBuilderMapTypeDesc@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVString@CvWorldBuilderMapTypeDesc@@0@Z PROC ; std::_Ptr_cat<CvWorldBuilderMapTypeDesc::String *,CvWorldBuilderMapTypeDesc::String *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVString@CvWorldBuilderMapTypeDesc@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVString@CvWorldBuilderMapTypeDesc@@0@Z ENDP ; std::_Ptr_cat<CvWorldBuilderMapTypeDesc::String *,CvWorldBuilderMapTypeDesc::String *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVString@CvWorldBuilderMapTypeDesc@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAVString@CvWorldBuilderMapTypeDesc@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvWorldBuilderMapTypeDesc::String *,CvWorldBuilderMapTypeDesc::String *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVString@CvWorldBuilderMapTypeDesc@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAVString@CvWorldBuilderMapTypeDesc@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVString@CvWorldBuilderMapTypeDesc@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAVString@CvWorldBuilderMapTypeDesc@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvWorldBuilderMapTypeDesc::String *,CvWorldBuilderMapTypeDesc::String *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt
	push	esi
$LL3@Copy_opt:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt
	pop	esi
$LN1@Copy_opt:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAVString@CvWorldBuilderMapTypeDesc@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAVString@CvWorldBuilderMapTypeDesc@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvWorldBuilderMapTypeDesc::String *,CvWorldBuilderMapTypeDesc::String *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy@VString@CvWorldBuilderMapTypeDesc@@@std@@YAXPAVString@CvWorldBuilderMapTypeDesc@@@Z ; std::_Destroy<CvWorldBuilderMapTypeDesc::String>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@VString@CvWorldBuilderMapTypeDesc@@@std@@YAXPAVString@CvWorldBuilderMapTypeDesc@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VString@CvWorldBuilderMapTypeDesc@@@std@@YAXPAVString@CvWorldBuilderMapTypeDesc@@@Z PROC ; std::_Destroy<CvWorldBuilderMapTypeDesc::String>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@VString@CvWorldBuilderMapTypeDesc@@@std@@YAXPAVString@CvWorldBuilderMapTypeDesc@@@Z ENDP ; std::_Destroy<CvWorldBuilderMapTypeDesc::String>
_TEXT	ENDS
PUBLIC	?SafeStrlen@FStringW@@SAHPB_W@Z			; FStringW::SafeStrlen
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstringw.inl
;	COMDAT ?SafeStrlen@FStringW@@SAHPB_W@Z
_TEXT	SEGMENT
_lpsz$ = 8						; size = 4
?SafeStrlen@FStringW@@SAHPB_W@Z PROC			; FStringW::SafeStrlen, COMDAT

; 941  : 	return ( lpsz ? ( int )wcslen( lpsz ) : 0 );

	mov	eax, DWORD PTR _lpsz$[esp-4]
	test	eax, eax
	je	SHORT $LN3@SafeStrlen
	lea	edx, DWORD PTR [eax+2]
	npad	5
$LL5@SafeStrlen:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL5@SafeStrlen
	sub	eax, edx
	sar	eax, 1

; 942  : }

	ret	0
$LN3@SafeStrlen:

; 941  : 	return ( lpsz ? ( int )wcslen( lpsz ) : 0 );

	xor	eax, eax

; 942  : }

	ret	0
?SafeStrlen@FStringW@@SAHPB_W@Z ENDP			; FStringW::SafeStrlen
_TEXT	ENDS
PUBLIC	?StringData@FStringWData@FStringW@@QAEPA_WXZ	; FStringW::FStringWData::StringData
; Function compile flags: /Ogtpy
;	COMDAT ?StringData@FStringWData@FStringW@@QAEPA_WXZ
_TEXT	SEGMENT
?StringData@FStringWData@FStringW@@QAEPA_WXZ PROC	; FStringW::FStringWData::StringData, COMDAT
; _this$ = ecx

; 979  : 	return ( ( LPWSTR )( this + 1 ) );

	lea	eax, DWORD PTR [ecx+12]

; 980  : }

	ret	0
?StringData@FStringWData@FStringW@@QAEPA_WXZ ENDP	; FStringW::FStringWData::StringData
_TEXT	ENDS
PUBLIC	?GetData@FStringW@@IBEPAUFStringWData@1@XZ	; FStringW::GetData
; Function compile flags: /Ogtpy
;	COMDAT ?GetData@FStringW@@IBEPAUFStringWData@1@XZ
_TEXT	SEGMENT
?GetData@FStringW@@IBEPAUFStringWData@1@XZ PROC		; FStringW::GetData, COMDAT
; _this$ = ecx

; 989  : 	assert( m_pszString != NULL );
; 990  : 
; 991  : 	return ( ( ( FStringWData* )m_pszString ) - 1 );

	mov	eax, DWORD PTR [ecx]
	sub	eax, 12					; 0000000cH

; 992  : }

	ret	0
?GetData@FStringW@@IBEPAUFStringWData@1@XZ ENDP		; FStringW::GetData
_TEXT	ENDS
PUBLIC	?Init@FStringW@@IAEXXZ				; FStringW::Init
EXTRN	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ:PROC ; FStringW_GetStringInitData
; Function compile flags: /Ogtpy
;	COMDAT ?Init@FStringW@@IAEXXZ
_TEXT	SEGMENT
?Init@FStringW@@IAEXXZ PROC				; FStringW::Init, COMDAT
; _this$ = ecx

; 996  : {

	push	esi
	mov	esi, ecx

; 997  : #ifdef		_NDS
; 998  : 	static int strEmpty[] = { FIXED, 0 };	// Empty string
; 999  : 
; 1000 : 	m_pszString = (LPWSTR)&strEmpty[1];
; 1001 : #else	//	_NDS
; 1002 : 	m_pszString = FStringW_GetStringInitData()->StringData();

	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [esi], eax
	pop	esi

; 1003 : #endif	//	_NDS
; 1004 : }

	ret	0
?Init@FStringW@@IAEXXZ ENDP				; FStringW::Init
_TEXT	ENDS
PUBLIC	?Release@FStringW@@IAEXPAUFStringWData@1@@Z	; FStringW::Release
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
;	COMDAT ?Release@FStringW@@IAEXPAUFStringWData@1@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Release@FStringW@@IAEXPAUFStringWData@1@@Z PROC	; FStringW::Release, COMDAT
; _this$ = ecx

; 1016 : {

	push	esi

; 1017 : 	FSTRING_CHECK_BUFFER;
; 1018 : 	if ( pkData && ( pkData != FStringW_GetStringInitData() ) && !pkData->m_bFixed )

	mov	esi, DWORD PTR _pkData$[esp]
	test	esi, esi
	je	SHORT $LN1@Release
	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData
	cmp	esi, eax
	je	SHORT $LN1@Release
	cmp	WORD PTR [esi+10], 0
	jne	SHORT $LN1@Release

; 1019 : 	{
; 1020 : #ifdef		ENABLE_FSTRING_STATS
; 1021 : 		extern uint g_uiFStringBytesCurrent;
; 1022 : 		g_uiFStringBytesCurrent -= sizeof ( FStringWData ) + ( sizeof ( char ) * pkData->m_iAllocLength + 1 );
; 1023 : #endif	//	ENABLE_FSTRING_STATS
; 1024 : 
; 1025 : 		// Free any memory associated with the string
; 1026 : 		delete [] ( byte* )pkData;

	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@Release:
	pop	esi

; 1027 : 	}
; 1028 : }

	ret	4
?Release@FStringW@@IAEXPAUFStringWData@1@@Z ENDP	; FStringW::Release
_TEXT	ENDS
PUBLIC	?GetCString@FStringA@@QBEPBDXZ			; FStringA::GetCString
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstringa.inl
;	COMDAT ?GetCString@FStringA@@QBEPBDXZ
_TEXT	SEGMENT
?GetCString@FStringA@@QBEPBDXZ PROC			; FStringA::GetCString, COMDAT
; _this$ = ecx

; 1015 : 	FSTRING_CHECK_BUFFER;
; 1016 : 	return ( m_pszString );

	mov	eax, DWORD PTR [ecx]

; 1017 : }

	ret	0
?GetCString@FStringA@@QBEPBDXZ ENDP			; FStringA::GetCString
_TEXT	ENDS
PUBLIC	?SafeStrlen@FStringA@@SAHPBD@Z			; FStringA::SafeStrlen
; Function compile flags: /Ogtpy
;	COMDAT ?SafeStrlen@FStringA@@SAHPBD@Z
_TEXT	SEGMENT
_lpsz$ = 8						; size = 4
?SafeStrlen@FStringA@@SAHPBD@Z PROC			; FStringA::SafeStrlen, COMDAT

; 1030 : 	return ( lpsz ? ( int )strlen( lpsz ) : 0 );

	mov	eax, DWORD PTR _lpsz$[esp-4]
	test	eax, eax
	je	SHORT $LN3@SafeStrlen@2
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL5@SafeStrlen@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL5@SafeStrlen@2
	sub	eax, edx

; 1031 : }

	ret	0
$LN3@SafeStrlen@2:

; 1030 : 	return ( lpsz ? ( int )strlen( lpsz ) : 0 );

	xor	eax, eax

; 1031 : }

	ret	0
?SafeStrlen@FStringA@@SAHPBD@Z ENDP			; FStringA::SafeStrlen
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??0CvWorldBuilderMapLoaderMapInfo@@QAE@XZ	; CvWorldBuilderMapLoaderMapInfo::CvWorldBuilderMapLoaderMapInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstructs.h
;	COMDAT ??0CvWorldBuilderMapLoaderMapInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvWorldBuilderMapLoaderMapInfo@@QAE@XZ PROC		; CvWorldBuilderMapLoaderMapInfo::CvWorldBuilderMapLoaderMapInfo, COMDAT
; _this$ = ecx

; 170  : 	{

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	BYTE PTR [eax+24], cl
	mov	BYTE PTR [eax+25], cl

; 171  : 
; 172  : 	}

	ret	0
??0CvWorldBuilderMapLoaderMapInfo@@QAE@XZ ENDP		; CvWorldBuilderMapLoaderMapInfo::CvWorldBuilderMapLoaderMapInfo
_TEXT	ENDS
PUBLIC	?GetID@CvBaseInfo@@QBEHXZ			; CvBaseInfo::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetID@CvBaseInfo@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvBaseInfo@@QBEHXZ PROC				; CvBaseInfo::GetID, COMDAT
; _this$ = ecx

; 54   : 		return m_iID;

	mov	eax, DWORD PTR [ecx+4]

; 55   : 	}

	ret	0
?GetID@CvBaseInfo@@QBEHXZ ENDP				; CvBaseInfo::GetID
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getSHALLOW_WATER_TERRAIN@CvGlobals@@QAEHXZ	; CvGlobals::getSHALLOW_WATER_TERRAIN
; Function compile flags: /Ogtpy
;	COMDAT ?getSHALLOW_WATER_TERRAIN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getSHALLOW_WATER_TERRAIN@CvGlobals@@QAEHXZ PROC	; CvGlobals::getSHALLOW_WATER_TERRAIN, COMDAT
; _this$ = ecx

; 7179 : 		return m_iSHALLOW_WATER_TERRAIN;

	mov	eax, DWORD PTR [ecx+8396]

; 7180 : 	}

	ret	0
?getSHALLOW_WATER_TERRAIN@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getSHALLOW_WATER_TERRAIN
_TEXT	ENDS
PUBLIC	?getSTANDARD_HANDICAP@CvGlobals@@QAEHXZ		; CvGlobals::getSTANDARD_HANDICAP
; Function compile flags: /Ogtpy
;	COMDAT ?getSTANDARD_HANDICAP@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getSTANDARD_HANDICAP@CvGlobals@@QAEHXZ PROC		; CvGlobals::getSTANDARD_HANDICAP, COMDAT
; _this$ = ecx

; 7235 : 		return m_iSTANDARD_HANDICAP;

	mov	eax, DWORD PTR [ecx+8452]

; 7236 : 	}

	ret	0
?getSTANDARD_HANDICAP@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getSTANDARD_HANDICAP
_TEXT	ENDS
PUBLIC	?getSTANDARD_GAMESPEED@CvGlobals@@QAEHXZ	; CvGlobals::getSTANDARD_GAMESPEED
; Function compile flags: /Ogtpy
;	COMDAT ?getSTANDARD_GAMESPEED@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getSTANDARD_GAMESPEED@CvGlobals@@QAEHXZ PROC		; CvGlobals::getSTANDARD_GAMESPEED, COMDAT
; _this$ = ecx

; 7247 : 		return m_iSTANDARD_GAMESPEED;

	mov	eax, DWORD PTR [ecx+8464]

; 7248 : 	}

	ret	0
?getSTANDARD_GAMESPEED@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getSTANDARD_GAMESPEED
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ ; CvGlobals::GetGameDatabase
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ
_TEXT	SEGMENT
?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ PROC ; CvGlobals::GetGameDatabase, COMDAT
; _this$ = ecx

; 9745 : 	return m_pGameDatabase;

	mov	eax, DWORD PTR [ecx+912]

; 9746 : }

	ret	0
?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ ENDP ; CvGlobals::GetGameDatabase
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ	; CvPlot::getPlotType
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ
_TEXT	SEGMENT
?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ PROC		; CvPlot::getPlotType, COMDAT
; _this$ = ecx

; 405  : 		return (PlotTypes)m_ePlotType;

	movsx	eax, BYTE PTR [ecx+5]

; 406  : 	}

	ret	0
?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ ENDP		; CvPlot::getPlotType
_TEXT	ENDS
PUBLIC	?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ	; CvPlot::getTerrainType
; Function compile flags: /Ogtpy
;	COMDAT ?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ
_TEXT	SEGMENT
?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ PROC	; CvPlot::getTerrainType, COMDAT
; _this$ = ecx

; 431  : 		return (TerrainTypes)m_eTerrainType;

	movsx	eax, BYTE PTR [ecx+6]

; 432  : 	}

	ret	0
?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ ENDP	; CvPlot::getTerrainType
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@getPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 537  : 	}

	ret	0
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax

; 537  : 	}

	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?numPlots@CvMap@@QBEHXZ				; CvMap::numPlots
; Function compile flags: /Ogtpy
;	COMDAT ?numPlots@CvMap@@QBEHXZ
_TEXT	SEGMENT
?numPlots@CvMap@@QBEHXZ PROC				; CvMap::numPlots, COMDAT
; _this$ = ecx

; 170  : 		return m_iGridSize;

	mov	eax, DWORD PTR [ecx+4028]

; 171  : 	}

	ret	0
?numPlots@CvMap@@QBEHXZ ENDP				; CvMap::numPlots
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z		; CvMap::plotByIndex
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z PROC		; CvMap::plotByIndex, COMDAT
; _this$ = ecx

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	mov	eax, DWORD PTR _iIndex$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@plotByInde
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN3@plotByInde
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 264  : 	}

	ret	4
$LN3@plotByInde:

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	xor	eax, eax

; 264  : 	}

	ret	4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z ENDP		; CvMap::plotByIndex
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ		; FAutoVariable<int,CvUnit>::operator int const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ		; FAutoVariable<char,CvPlot>::operator char const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ
_TEXT	SEGMENT
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ PROC		; FAutoVariable<char,CvPlot>::operator char const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ ENDP		; FAutoVariable<char,CvPlot>::operator char const &
_TEXT	ENDS
PUBLIC	?GetVisibility@CvWorldBuilderMap@@QBE?B_NIII@Z	; CvWorldBuilderMap::GetVisibility
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvworldbuildermap\include\cvworldbuildermap.h
;	COMDAT ?GetVisibility@CvWorldBuilderMap@@QBE?B_NIII@Z
_TEXT	SEGMENT
_uiX$ = 8						; size = 4
_uiY$ = 12						; size = 4
_uiTeam$ = 16						; size = 4
?GetVisibility@CvWorldBuilderMap@@QBE?B_NIII@Z PROC	; CvWorldBuilderMap::GetVisibility, COMDAT
; _this$ = ecx

; 665  : 	{

	push	esi
	mov	esi, ecx

; 666  : 		FAssertMsg(uiX < m_kMapDesc.uiWidth && uiY < m_kMapDesc.uiHeight, "Invalid Position");
; 667  : 		FAssertMsg(uiTeam < m_kGameDesc.byTeamCount, "Invalid Team");
; 668  : 		const uint uiMapSize = m_kMapDesc.uiWidth * m_kMapDesc.uiHeight;
; 669  : 		return m_kVisibility.Get(uiX + uiY * m_kMapDesc.uiWidth + uiTeam * uiMapSize);

	mov	ecx, DWORD PTR [esi+12232]
	imul	ecx, DWORD PTR _uiTeam$[esp]
	add	ecx, DWORD PTR _uiY$[esp]
	imul	ecx, DWORD PTR [esi+12228]
	add	ecx, DWORD PTR _uiX$[esp]
	mov	eax, ecx
	shr	eax, 3
	cmp	eax, 393216				; 00060000H
	jae	SHORT $LN4@GetVisibil
	and	ecx, 7
	mov	dl, 1
	shl	dl, cl
	test	dl, BYTE PTR [eax+esi+584672]
	pop	esi
	setne	al

; 670  : 	}

	ret	12					; 0000000cH

; 666  : 		FAssertMsg(uiX < m_kMapDesc.uiWidth && uiY < m_kMapDesc.uiHeight, "Invalid Position");
; 667  : 		FAssertMsg(uiTeam < m_kGameDesc.byTeamCount, "Invalid Team");
; 668  : 		const uint uiMapSize = m_kMapDesc.uiWidth * m_kMapDesc.uiHeight;
; 669  : 		return m_kVisibility.Get(uiX + uiY * m_kMapDesc.uiWidth + uiTeam * uiMapSize);

$LN4@GetVisibil:
	xor	al, al
	pop	esi

; 670  : 	}

	ret	12					; 0000000cH
?GetVisibility@CvWorldBuilderMap@@QBE?B_NIII@Z ENDP	; CvWorldBuilderMap::GetVisibility
_TEXT	ENDS
PUBLIC	?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ ; CvWorldBuilderMapLoader::SetupGameOptions
EXTRN	?setGameSpeed@CvPreGame@@YAXABVCvString@@@Z:PROC ; CvPreGame::setGameSpeed
EXTRN	?setStartYear@CvGame@@QAEXH@Z:PROC		; CvGame::setStartYear
EXTRN	?setMaxTurns@CvPreGame@@YAXH@Z:PROC		; CvPreGame::setMaxTurns
EXTRN	?setVictoryValid@CvGame@@QAEXW4VictoryTypes@@_N@Z:PROC ; CvGame::setVictoryValid
EXTRN	?getVictoryInfo@CvGlobals@@QAEPAVCvVictoryInfo@@W4VictoryTypes@@@Z:PROC ; CvGlobals::getVictoryInfo
EXTRN	?getNumVictoryInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumVictoryInfos
EXTRN	?setOption@CvGame@@QAEXPBD_N@Z:PROC		; CvGame::setOption
EXTRN	?Contains@CvWorldBuilderMapTypeGroup@@QBE_NPBD@Z:PROC ; CvWorldBuilderMapTypeGroup::Contains
EXTRN	?getGameOptionInfo@CvGlobals@@QAEPAVCvGameOptionInfo@@W4GameOptionTypes@@@Z:PROC ; CvGlobals::getGameOptionInfo
EXTRN	?getNumGameOptionInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumGameOptionInfos
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ$0
__ehfuncinfo$?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
xdata$x	ENDS
;	COMDAT ?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ
_TEXT	SEGMENT
_bValid$224285 = -44					; size = 1
_bEnabled$224274 = -44					; size = 1
$T227550 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ PROC	; CvWorldBuilderMapLoader::SetupGameOptions, COMDAT

; 275  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi

; 276  : 	const int iGameOptionCount = GC.getNumGameOptionInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumGameOptionInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumGameOptionInfos
	mov	ebx, eax

; 277  : 	for(int i = 0; i < iGameOptionCount; ++i)

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN6@SetupGameO
	npad	3
$LL8@SetupGameO:

; 278  : 	{
; 279  : 		const GameOptionTypes eOption = (GameOptionTypes)i;
; 280  : 		const CvGameOptionInfo* pkOption = GC.getGameOptionInfo(eOption);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getGameOptionInfo@CvGlobals@@QAEPAVCvGameOptionInfo@@W4GameOptionTypes@@@Z ; CvGlobals::getGameOptionInfo

; 281  : 		if(pkOption != NULL)

	test	eax, eax
	je	SHORT $LN7@SetupGameO

; 282  : 		{
; 283  : 			const char* szOption = pkOption->GetType();

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edi, eax

; 284  : 			const bool bEnabled = sg_kSave.m_kGameOptions.Contains(szOption);

	push	edi
	mov	ecx, OFFSET _sg_kSave+4024
	call	?Contains@CvWorldBuilderMapTypeGroup@@QBE_NPBD@Z ; CvWorldBuilderMapTypeGroup::Contains

; 285  : 			GC.getGame().setOption(szOption, bEnabled);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	BYTE PTR _bEnabled$224274[esp+56], al
	mov	eax, DWORD PTR _bEnabled$224274[esp+56]
	push	eax
	push	edi
	call	?setOption@CvGame@@QAEXPBD_N@Z		; CvGame::setOption
$LN7@SetupGameO:
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL8@SetupGameO
$LN6@SetupGameO:

; 286  : 		}
; 287  : 	}
; 288  : 
; 289  : 	const int iVictoryTypeCount = GC.getNumVictoryInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	mov	edi, eax

; 290  : 	for(int i = 0; i < iVictoryTypeCount; ++i)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN2@SetupGameO
$LL4@SetupGameO:

; 291  : 	{
; 292  : 		const VictoryTypes eVictoryType = (VictoryTypes)i;
; 293  : 		const CvVictoryInfo* pkVictoryType = GC.getVictoryInfo(eVictoryType);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getVictoryInfo@CvGlobals@@QAEPAVCvVictoryInfo@@W4VictoryTypes@@@Z ; CvGlobals::getVictoryInfo

; 294  : 		if(pkVictoryType != NULL)

	test	eax, eax
	je	SHORT $LN3@SetupGameO

; 295  : 		{
; 296  : 			const char* szVictoryType = pkVictoryType->GetType();

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 297  : 			const bool bValid = sg_kSave.m_kVictoryTypes.Contains(szVictoryType);

	push	eax
	mov	ecx, OFFSET _sg_kSave+4016
	call	?Contains@CvWorldBuilderMapTypeGroup@@QBE_NPBD@Z ; CvWorldBuilderMapTypeGroup::Contains
	mov	BYTE PTR _bValid$224285[esp+56], al

; 298  : 			GC.getGame().setVictoryValid(eVictoryType, bValid);

	mov	ecx, DWORD PTR _bValid$224285[esp+56]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	call	?setVictoryValid@CvGame@@QAEXW4VictoryTypes@@_N@Z ; CvGame::setVictoryValid
$LN3@SetupGameO:
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL4@SetupGameO
$LN2@SetupGameO:

; 299  : 		}
; 300  : 	}
; 301  : 
; 302  : 	CvPreGame::setMaxTurns(sg_kSave.GetMaxTurns());

	mov	edx, DWORD PTR _sg_kSave+12304
	push	edx
	call	?setMaxTurns@CvPreGame@@YAXH@Z		; CvPreGame::setMaxTurns

; 303  : 
; 304  : 	GC.getGame().setStartYear(sg_kSave.GetStartYear());

	mov	eax, DWORD PTR _sg_kSave+12312
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	add	esp, 4
	push	eax
	call	?setStartYear@CvGame@@QAEXH@Z		; CvGame::setStartYear

; 305  : 	CvPreGame::setGameSpeed(sg_kSave.GetDefaultGameSpeed());

	push	OFFSET _sg_kSave+12236
	lea	ecx, DWORD PTR $T227550[esp+60]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T227550[esp+56]
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+68], 0
	call	?setGameSpeed@CvPreGame@@YAXABVCvString@@@Z ; CvPreGame::setGameSpeed
	add	esp, 4
	lea	ecx, DWORD PTR $T227550[esp+56]
	mov	DWORD PTR __$EHRec$[esp+64], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 306  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ$0:
	lea	ecx, DWORD PTR $T227550[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ ENDP	; CvWorldBuilderMapLoader::SetupGameOptions
PUBLIC	?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ	; CvWorldBuilderMapLoader::SetupPlayers
EXTRN	?setMinorCivType@CvPreGame@@YAXW4PlayerTypes@@W4MinorCivTypes@@@Z:PROC ; CvPreGame::setMinorCivType
EXTRN	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z:PROC ; CvGlobals::getMinorCivInfo
EXTRN	?getNumMinorCivInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumMinorCivInfos
EXTRN	?setNumMinorCivs@CvPreGame@@YAXH@Z:PROC		; CvPreGame::setNumMinorCivs
EXTRN	?mapNoPlayers@CvPreGame@@YA_NXZ:PROC		; CvPreGame::mapNoPlayers
EXTRN	?resetPlayer@CvPreGame@@YAXW4PlayerTypes@@@Z:PROC ; CvPreGame::resetPlayer
EXTRN	?setCivilizationDescription@CvPreGame@@YAXW4PlayerTypes@@ABVCvString@@@Z:PROC ; CvPreGame::setCivilizationDescription
EXTRN	?setCivilizationShortDescription@CvPreGame@@YAXW4PlayerTypes@@ABVCvString@@@Z:PROC ; CvPreGame::setCivilizationShortDescription
EXTRN	?setLeaderName@CvPreGame@@YAXW4PlayerTypes@@ABVCvString@@@Z:PROC ; CvPreGame::setLeaderName
EXTRN	?setMinorCiv@CvPreGame@@YAXW4PlayerTypes@@_N@Z:PROC ; CvPreGame::setMinorCiv
EXTRN	?setTeamType@CvPreGame@@YAXW4PlayerTypes@@W4TeamTypes@@@Z:PROC ; CvPreGame::setTeamType
EXTRN	?setHandicap@CvPreGame@@YAXW4PlayerTypes@@W4HandicapTypes@@@Z:PROC ; CvPreGame::setHandicap
EXTRN	?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z:PROC ; CvGlobals::getHandicapInfo
EXTRN	?getNumHandicapInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumHandicapInfos
EXTRN	?overrideScenarioHandicap@CvPreGame@@YA_NXZ:PROC ; CvPreGame::overrideScenarioHandicap
EXTRN	?setPlayerColor@CvPreGame@@YAXW4PlayerTypes@@W4PlayerColorTypes@@@Z:PROC ; CvPreGame::setPlayerColor
EXTRN	?GetPlayerColorInfo@CvGlobals@@QAEPAVCvPlayerColorInfo@@W4PlayerColorTypes@@@Z:PROC ; CvGlobals::GetPlayerColorInfo
EXTRN	?GetNumPlayerColorInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::GetNumPlayerColorInfos
EXTRN	?setCivilization@CvPreGame@@YAXW4PlayerTypes@@W4CivilizationTypes@@@Z:PROC ; CvPreGame::setCivilization
EXTRN	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z:PROC ; CvGlobals::getCivilizationInfo
EXTRN	?getNumCivilizationInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumCivilizationInfos
EXTRN	?setSlotStatus@CvPreGame@@YAXW4PlayerTypes@@W4SlotStatus@@@Z:PROC ; CvPreGame::setSlotStatus
EXTRN	?slotStatus@CvPreGame@@YA?AW4SlotStatus@@W4PlayerTypes@@@Z:PROC ; CvPreGame::slotStatus
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
xdata$x	SEGMENT
__unwindtable$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ$2
__ehfuncinfo$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
xdata$x	ENDS
;	COMDAT ?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ
_TEXT	SEGMENT
$T227613 = -50						; size = 1
$T227607 = -50						; size = 1
$T227612 = -49						; size = 1
$T227608 = -49						; size = 1
tv204 = -48						; size = 4
tv192 = -48						; size = 4
_i$224361 = -48						; size = 4
_i$224298 = -48						; size = 4
_uiCityStateCount$ = -44				; size = 4
_uiPlayerCount$ = -44					; size = 4
$T227611 = -40						; size = 28
$T227610 = -40						; size = 28
$T227609 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ PROC	; CvWorldBuilderMapLoader::SetupPlayers, COMDAT

; 309  : {

	push	-1
	push	__ehhandler$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H

; 310  : #ifdef AUI_WARNING_FIXES
; 311  : 	const byte uiPlayerCount = MIN(sg_kSave.GetPlayerCount(), (byte)MAX_CIV_PLAYERS);
; 312  : 	for (byte i = 0; i < uiPlayerCount; ++i)
; 313  : #else
; 314  : 	const uint uiPlayerCount = std::min(sg_kSave.GetPlayerCount(), (byte)MAX_CIV_PLAYERS);

	mov	al, BYTE PTR _sg_kSave+12316
	mov	BYTE PTR $T227608[esp+52], al
	cmp	al, 63					; 0000003fH
	mov	BYTE PTR $T227607[esp+52], 63		; 0000003fH
	lea	eax, DWORD PTR $T227607[esp+52]
	ja	SHORT $LN56@SetupPlaye
	lea	eax, DWORD PTR $T227608[esp+52]
$LN56@SetupPlaye:
	movzx	eax, BYTE PTR [eax]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	DWORD PTR _uiPlayerCount$[esp+68], eax

; 315  : 	for(uint i = 0; i < uiPlayerCount; ++i)

	mov	DWORD PTR _i$224298[esp+68], 0
	test	eax, eax
	jbe	$LN43@SetupPlaye
	npad	3
$LL157@SetupPlaye:

; 316  : #endif
; 317  : 	{
; 318  : 		const PlayerTypes ePlayer = (PlayerTypes)i;
; 319  : 		const SlotStatus eStatus = CvPreGame::slotStatus(ePlayer);

	mov	eax, DWORD PTR _i$224298[esp+68]
	push	eax
	call	?slotStatus@CvPreGame@@YA?AW4SlotStatus@@W4PlayerTypes@@@Z ; CvPreGame::slotStatus
	mov	ebx, eax
	add	esp, 4

; 320  : 		if(eStatus != SS_TAKEN && eStatus != SS_COMPUTER)

	cmp	ebx, 3
	je	SHORT $LN42@SetupPlaye
	cmp	ebx, 1
	je	SHORT $LN42@SetupPlaye

; 321  : 			CvPreGame::setSlotStatus(ePlayer, SS_COMPUTER);

	mov	ecx, DWORD PTR _i$224298[esp+68]
	push	1
	push	ecx
	call	?setSlotStatus@CvPreGame@@YAXW4PlayerTypes@@W4SlotStatus@@@Z ; CvPreGame::setSlotStatus
	add	esp, 8
$LN42@SetupPlaye:

; 322  : 
; 323  : 		const CvWorldBuilderMap::Player& kPlayer = sg_kSave.GetPlayer(i);

	mov	al, BYTE PTR _i$224298[esp+68]
	cmp	al, BYTE PTR _sg_kSave+12316
	jae	SHORT $LN58@SetupPlaye
	cmp	al, 32					; 00000020H
	jae	SHORT $LN58@SetupPlaye
	movzx	ebp, al
	imul	ebp, 436				; 000001b4H
	add	ebp, OFFSET _sg_kSave+536608
	jmp	SHORT $LN57@SetupPlaye
$LN58@SetupPlaye:
	mov	ebp, OFFSET ?sm_kErrorPlayer@CvWorldBuilderMap@@0UPlayer@1@A ; CvWorldBuilderMap::sm_kErrorPlayer
$LN57@SetupPlaye:

; 324  : 
; 325  : 		CivilizationTypes eCivType = NO_CIVILIZATION;
; 326  : #ifdef AUI_WARNING_FIXES
; 327  : 		for (uint iCiv = 0; iCiv < GC.getNumCivilizationInfos(); ++iCiv)
; 328  : #else
; 329  : 		for(int iCiv = 0; iCiv < GC.getNumCivilizationInfos(); ++iCiv)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	or	edi, -1
	xor	esi, esi
	call	?getNumCivilizationInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumCivilizationInfos
	test	eax, eax
	jle	SHORT $LN39@SetupPlaye
$LL41@SetupPlaye:

; 330  : #endif
; 331  : 		{
; 332  : 			CvCivilizationInfo* pkCivilization = GC.getCivilizationInfo((CivilizationTypes)iCiv);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo

; 333  : 			if(pkCivilization != NULL && strcmp(kPlayer.m_szCivType, pkCivilization->GetType()) == 0)

	test	eax, eax
	je	SHORT $LN40@SetupPlaye
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR [ebp+160]
$LL131@SetupPlaye:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN132@SetupPlaye
	test	dl, dl
	je	SHORT $LN133@SetupPlaye
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN132@SetupPlaye
	add	ecx, 2
	add	eax, 2
	test	dl, dl
	jne	SHORT $LL131@SetupPlaye
$LN133@SetupPlaye:
	xor	eax, eax
	jmp	SHORT $LN134@SetupPlaye
$LN132@SetupPlaye:
	sbb	eax, eax
	sbb	eax, -1
$LN134@SetupPlaye:
	test	eax, eax
	je	SHORT $LN116@SetupPlaye
$LN40@SetupPlaye:

; 324  : 
; 325  : 		CivilizationTypes eCivType = NO_CIVILIZATION;
; 326  : #ifdef AUI_WARNING_FIXES
; 327  : 		for (uint iCiv = 0; iCiv < GC.getNumCivilizationInfos(); ++iCiv)
; 328  : #else
; 329  : 		for(int iCiv = 0; iCiv < GC.getNumCivilizationInfos(); ++iCiv)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumCivilizationInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumCivilizationInfos
	cmp	esi, eax
	jl	SHORT $LL41@SetupPlaye

; 478  : 			if(pkHandicap != NULL && strcmp(kPlayer.m_szHandicap, pkHandicap->GetType()) == 0)

	jmp	SHORT $LN39@SetupPlaye
$LN116@SetupPlaye:

; 334  : 			{
; 335  : 				eCivType = (CivilizationTypes)iCiv;

	mov	edi, esi
$LN39@SetupPlaye:

; 336  : 				break;
; 337  : 			}
; 338  : 		}
; 339  : 
; 340  : 		CvPreGame::setCivilization(ePlayer, eCivType);

	mov	edx, DWORD PTR _i$224298[esp+68]
	push	edi
	push	edx
	call	?setCivilization@CvPreGame@@YAXW4PlayerTypes@@W4CivilizationTypes@@@Z ; CvPreGame::setCivilization
	add	esp, 8

; 341  : 
; 342  : 		PlayerColorTypes eColorType = NO_PLAYERCOLOR;
; 343  : #ifdef AUI_WARNING_FIXES
; 344  : 		for (uint iColor = 0; iColor < GC.GetNumPlayerColorInfos(); ++iColor)
; 345  : #else
; 346  : 		for(int iColor = 0; iColor < GC.GetNumPlayerColorInfos(); ++iColor)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	or	edi, -1
	xor	esi, esi
	call	?GetNumPlayerColorInfos@CvGlobals@@QAEHXZ ; CvGlobals::GetNumPlayerColorInfos
	test	eax, eax
	jle	SHORT $LN35@SetupPlaye
	npad	1
$LL37@SetupPlaye:

; 347  : #endif
; 348  : 		{
; 349  : 			CvPlayerColorInfo* pkColor = GC.GetPlayerColorInfo((PlayerColorTypes)iColor);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetPlayerColorInfo@CvGlobals@@QAEPAVCvPlayerColorInfo@@W4PlayerColorTypes@@@Z ; CvGlobals::GetPlayerColorInfo

; 350  : 			if(pkColor != NULL && strcmp(kPlayer.m_szTeamColor, pkColor->GetType()) == 0)

	test	eax, eax
	je	SHORT $LN36@SetupPlaye
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR [ebp+224]
$LL135@SetupPlaye:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN136@SetupPlaye
	test	dl, dl
	je	SHORT $LN137@SetupPlaye
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN136@SetupPlaye
	add	ecx, 2
	add	eax, 2
	test	dl, dl
	jne	SHORT $LL135@SetupPlaye
$LN137@SetupPlaye:
	xor	eax, eax
	jmp	SHORT $LN138@SetupPlaye
$LN136@SetupPlaye:
	sbb	eax, eax
	sbb	eax, -1
$LN138@SetupPlaye:
	test	eax, eax
	je	SHORT $LN117@SetupPlaye
$LN36@SetupPlaye:

; 341  : 
; 342  : 		PlayerColorTypes eColorType = NO_PLAYERCOLOR;
; 343  : #ifdef AUI_WARNING_FIXES
; 344  : 		for (uint iColor = 0; iColor < GC.GetNumPlayerColorInfos(); ++iColor)
; 345  : #else
; 346  : 		for(int iColor = 0; iColor < GC.GetNumPlayerColorInfos(); ++iColor)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?GetNumPlayerColorInfos@CvGlobals@@QAEHXZ ; CvGlobals::GetNumPlayerColorInfos
	cmp	esi, eax
	jl	SHORT $LL37@SetupPlaye

; 478  : 			if(pkHandicap != NULL && strcmp(kPlayer.m_szHandicap, pkHandicap->GetType()) == 0)

	jmp	SHORT $LN35@SetupPlaye
$LN117@SetupPlaye:

; 351  : 			{
; 352  : 				eColorType = (PlayerColorTypes)iColor;

	mov	edi, esi
$LN35@SetupPlaye:

; 353  : 				break;
; 354  : 			}
; 355  : 		}
; 356  : 
; 357  : 		CvPreGame::setPlayerColor(ePlayer, eColorType);

	mov	eax, DWORD PTR _i$224298[esp+68]
	push	edi
	push	eax
	call	?setPlayerColor@CvPreGame@@YAXW4PlayerTypes@@W4PlayerColorTypes@@@Z ; CvPreGame::setPlayerColor
	add	esp, 8

; 358  : 
; 359  : 		if(!(eStatus == SS_TAKEN && CvPreGame::overrideScenarioHandicap()))

	cmp	ebx, 3
	jne	SHORT $LN32@SetupPlaye
	call	?overrideScenarioHandicap@CvPreGame@@YA_NXZ ; CvPreGame::overrideScenarioHandicap
	test	al, al
	jne	$LN159@SetupPlaye
$LN32@SetupPlaye:

; 360  : 		{
; 361  : 			HandicapTypes eHandicap = NO_HANDICAP;

	or	ebx, -1

; 362  : #ifdef AUI_WARNING_FIXES
; 363  : 			for (uint iHandicap = 0; iHandicap < GC.getNumHandicapInfos(); ++iHandicap)
; 364  : #else
; 365  : 			for(int iHandicap = 0; iHandicap < GC.getNumHandicapInfos(); ++iHandicap)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, ebx
	xor	esi, esi
	call	?getNumHandicapInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumHandicapInfos
	test	eax, eax
	jle	SHORT $LN158@SetupPlaye
$LL31@SetupPlaye:

; 366  : #endif
; 367  : 			{
; 368  : 				CvHandicapInfo* pkHandicap = GC.getHandicapInfo((HandicapTypes)iHandicap);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z ; CvGlobals::getHandicapInfo

; 369  : 				if(pkHandicap != NULL && strcmp(kPlayer.m_szHandicap, pkHandicap->GetType()) == 0)

	test	eax, eax
	je	SHORT $LN30@SetupPlaye
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR [ebp+352]
$LL139@SetupPlaye:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN140@SetupPlaye
	test	dl, dl
	je	SHORT $LN141@SetupPlaye
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN140@SetupPlaye
	add	ecx, 2
	add	eax, 2
	test	dl, dl
	jne	SHORT $LL139@SetupPlaye
$LN141@SetupPlaye:
	xor	eax, eax
	jmp	SHORT $LN142@SetupPlaye
$LN140@SetupPlaye:
	sbb	eax, eax
	sbb	eax, ebx
$LN142@SetupPlaye:
	test	eax, eax
	je	SHORT $LN118@SetupPlaye
$LN30@SetupPlaye:

; 362  : #ifdef AUI_WARNING_FIXES
; 363  : 			for (uint iHandicap = 0; iHandicap < GC.getNumHandicapInfos(); ++iHandicap)
; 364  : #else
; 365  : 			for(int iHandicap = 0; iHandicap < GC.getNumHandicapInfos(); ++iHandicap)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumHandicapInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumHandicapInfos
	cmp	esi, eax
	jl	SHORT $LL31@SetupPlaye

; 372  : 					break;
; 373  : 				}
; 374  : 			}
; 375  : 
; 376  : 			CvPreGame::setHandicap(ePlayer, eHandicap);

	push	edi
	mov	edi, DWORD PTR _i$224298[esp+72]
	push	edi
	call	?setHandicap@CvPreGame@@YAXW4PlayerTypes@@W4HandicapTypes@@@Z ; CvPreGame::setHandicap
	add	esp, 8
	jmp	SHORT $LN33@SetupPlaye
$LN118@SetupPlaye:

; 370  : 				{
; 371  : 					eHandicap = (HandicapTypes)iHandicap;

	mov	edi, esi
$LN158@SetupPlaye:

; 372  : 					break;
; 373  : 				}
; 374  : 			}
; 375  : 
; 376  : 			CvPreGame::setHandicap(ePlayer, eHandicap);

	push	edi
	mov	edi, DWORD PTR _i$224298[esp+72]
	push	edi
	call	?setHandicap@CvPreGame@@YAXW4PlayerTypes@@W4HandicapTypes@@@Z ; CvPreGame::setHandicap
	add	esp, 8
	jmp	SHORT $LN33@SetupPlaye
$LN159@SetupPlaye:
	mov	edi, DWORD PTR _i$224298[esp+68]
	or	ebx, -1
$LN33@SetupPlaye:

; 377  : 		}
; 378  : 
; 379  : 		CvPreGame::setTeamType(ePlayer, (TeamTypes)kPlayer.m_byTeam);

	movzx	ecx, BYTE PTR [ebp+432]
	push	ecx
	push	edi
	call	?setTeamType@CvPreGame@@YAXW4PlayerTypes@@W4TeamTypes@@@Z ; CvPreGame::setTeamType

; 380  : 		CvPreGame::setMinorCiv(ePlayer, false);

	push	0
	push	edi
	call	?setMinorCiv@CvPreGame@@YAXW4PlayerTypes@@_N@Z ; CvPreGame::setMinorCiv

; 381  : 
; 382  : #ifdef AUI_WARNING_FIXES
; 383  : 		if (kPlayer.m_szLeaderName[0] != '\0')
; 384  : #else
; 385  : 		if(strlen(kPlayer.m_szLeaderName) > 0)

	lea	edx, DWORD PTR [ebp+32]
	mov	eax, edx
	add	esp, 16					; 00000010H
	lea	esi, DWORD PTR [eax+1]
$LL143@SetupPlaye:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL143@SetupPlaye
	sub	eax, esi
	je	SHORT $LN160@SetupPlaye

; 386  : #endif
; 387  : 			CvPreGame::setLeaderName(ePlayer, kPlayer.m_szLeaderName);

	test	edx, edx
	jne	SHORT $LN70@SetupPlaye
	mov	edx, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN70@SetupPlaye:
	push	edx
	lea	ecx, DWORD PTR $T227609[esp+72]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR $T227609[esp+68]
	push	edx
	push	edi
	mov	DWORD PTR __$EHRec$[esp+84], 0
	call	?setLeaderName@CvPreGame@@YAXW4PlayerTypes@@ABVCvString@@@Z ; CvPreGame::setLeaderName
	add	esp, 8
	lea	ecx, DWORD PTR $T227609[esp+68]
	mov	DWORD PTR __$EHRec$[esp+76], ebx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN160@SetupPlaye:

; 388  : 
; 389  : #ifdef AUI_WARNING_FIXES
; 390  : 		if (kPlayer.m_szCivName[0] != '\0')
; 391  : #else
; 392  : 		if(strlen(kPlayer.m_szCivName) > 0)

	lea	esi, DWORD PTR [ebp+96]
	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
	npad	1
$LL144@SetupPlaye:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL144@SetupPlaye
	sub	eax, edx
	je	SHORT $LN44@SetupPlaye

; 393  : #endif
; 394  : 		{
; 395  : 			CvPreGame::setCivilizationShortDescription(ePlayer, kPlayer.m_szCivName);

	mov	eax, esi
	test	esi, esi
	jne	SHORT $LN78@SetupPlaye
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN78@SetupPlaye:
	push	eax
	lea	ecx, DWORD PTR $T227610[esp+72]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR $T227610[esp+68]
	push	eax
	push	edi
	mov	DWORD PTR __$EHRec$[esp+84], 1
	call	?setCivilizationShortDescription@CvPreGame@@YAXW4PlayerTypes@@ABVCvString@@@Z ; CvPreGame::setCivilizationShortDescription
	add	esp, 8
	lea	ecx, DWORD PTR $T227610[esp+68]
	mov	DWORD PTR __$EHRec$[esp+76], ebx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 396  : 			CvPreGame::setCivilizationDescription(ePlayer, kPlayer.m_szCivName);

	test	esi, esi
	jne	SHORT $LN86@SetupPlaye
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN86@SetupPlaye:
	push	esi
	lea	ecx, DWORD PTR $T227611[esp+72]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T227611[esp+68]
	push	ecx
	push	edi
	mov	DWORD PTR __$EHRec$[esp+84], 2
	call	?setCivilizationDescription@CvPreGame@@YAXW4PlayerTypes@@ABVCvString@@@Z ; CvPreGame::setCivilizationDescription
	add	esp, 8
	lea	ecx, DWORD PTR $T227611[esp+68]
	mov	DWORD PTR __$EHRec$[esp+76], ebx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN44@SetupPlaye:
	inc	edi
	mov	DWORD PTR _i$224298[esp+68], edi
	cmp	edi, DWORD PTR _uiPlayerCount$[esp+68]
	jb	$LL157@SetupPlaye
$LN43@SetupPlaye:

; 397  : 		}
; 398  : 	}
; 399  : 
; 400  : 	// If this is a map with defined player slots then close any slots out of this defined range
; 401  : 	// that are being filled by computer players.  Hopefully there aren't any human players there.
; 402  : 	const uint uiPlayerSlotCount = sg_kMapInfo.uiMajorCivStartingPositions + sg_kMapInfo.uiPlayers;

	mov	edx, DWORD PTR _sg_kMapInfo+16
	mov	eax, DWORD PTR _sg_kMapInfo+8
	lea	esi, DWORD PTR [eax+edx]

; 403  : 	if(uiPlayerSlotCount > 0)

	test	esi, esi
	jbe	SHORT $LN161@SetupPlaye

; 404  : 	{
; 405  : 		for(uint i = uiPlayerSlotCount; i < MAX_MAJOR_CIVS; ++i)

	cmp	esi, 22					; 00000016H
	jae	SHORT $LN161@SetupPlaye
$LL24@SetupPlaye:

; 406  : 		{
; 407  : 			const PlayerTypes ePlayer = (PlayerTypes)i;
; 408  : 			const SlotStatus eStatus = CvPreGame::slotStatus(ePlayer);

	push	esi
	call	?slotStatus@CvPreGame@@YA?AW4SlotStatus@@W4PlayerTypes@@@Z ; CvPreGame::slotStatus
	add	esp, 4

; 409  : 			if(eStatus == SS_COMPUTER)

	cmp	eax, 1
	jne	SHORT $LN23@SetupPlaye

; 410  : 				CvPreGame::resetPlayer(ePlayer);	// Do a full reset, which will also close the slot.  A reset is better so that the player data does not get initialized later.

	push	esi
	call	?resetPlayer@CvPreGame@@YAXW4PlayerTypes@@@Z ; CvPreGame::resetPlayer
	add	esp, 4
$LN23@SetupPlaye:
	inc	esi
	cmp	esi, 22					; 00000016H
	jb	SHORT $LL24@SetupPlaye
$LN161@SetupPlaye:

; 411  : 		}
; 412  : 	}
; 413  : 
; 414  : #ifdef AUI_WARNING_FIXES
; 415  : 	const byte uiCityStateCount = MIN(sg_kSave.GetCityStateCount(), (byte)MAX_MINOR_CIVS);
; 416  : #else
; 417  : 	const uint uiCityStateCount = std::min(sg_kSave.GetCityStateCount(), (byte)MAX_MINOR_CIVS);

	mov	al, BYTE PTR _sg_kSave+12317
	mov	BYTE PTR $T227613[esp+68], al
	cmp	al, 41					; 00000029H
	mov	BYTE PTR $T227612[esp+68], 41		; 00000029H
	lea	eax, DWORD PTR $T227612[esp+68]
	ja	SHORT $LN96@SetupPlaye
	lea	eax, DWORD PTR $T227613[esp+68]
$LN96@SetupPlaye:
	movzx	esi, BYTE PTR [eax]
	mov	DWORD PTR _uiCityStateCount$[esp+68], esi

; 418  : #endif
; 419  : 
; 420  : 	if(uiCityStateCount > 0)

	test	esi, esi
	jbe	SHORT $LN20@SetupPlaye

; 421  : 		CvPreGame::setNumMinorCivs(uiCityStateCount);

	push	esi
	jmp	SHORT $LN165@SetupPlaye
$LN20@SetupPlaye:

; 422  : 	else if(sg_kMapInfo.uiMinorCivStartingPositions > 0)

	mov	eax, DWORD PTR _sg_kMapInfo+20
	test	eax, eax
	jbe	SHORT $LN18@SetupPlaye

; 423  : 		CvPreGame::setNumMinorCivs(sg_kMapInfo.uiMinorCivStartingPositions);

	push	eax
	jmp	SHORT $LN165@SetupPlaye
$LN18@SetupPlaye:

; 424  : 	else if(!CvPreGame::mapNoPlayers())

	call	?mapNoPlayers@CvPreGame@@YA_NXZ		; CvPreGame::mapNoPlayers
	test	al, al
	jne	SHORT $LN16@SetupPlaye

; 425  : 		CvPreGame::setNumMinorCivs(0);

	push	0
$LN165@SetupPlaye:
	call	?setNumMinorCivs@CvPreGame@@YAXH@Z	; CvPreGame::setNumMinorCivs
	add	esp, 4
$LN16@SetupPlaye:

; 426  : 
; 427  : #ifdef AUI_WARNING_FIXES
; 428  : 	for (byte i = 0; i < uiCityStateCount; ++i)
; 429  : #else
; 430  : 	for(uint i = 0; i < uiCityStateCount; ++i)

	xor	eax, eax
	mov	DWORD PTR _i$224361[esp+68], eax
	test	esi, esi
	jbe	$LN13@SetupPlaye
	jmp	SHORT $LN15@SetupPlaye
	npad	9
$LL163@SetupPlaye:
	mov	eax, DWORD PTR _i$224361[esp+68]
$LN15@SetupPlaye:

; 431  : #endif
; 432  : 	{
; 433  : 		const PlayerTypes ePlayer = (PlayerTypes)(i + MAX_MAJOR_CIVS);

	lea	ebx, DWORD PTR [eax+22]

; 434  : 		const CvWorldBuilderMap::Player& kPlayer = sg_kSave.GetCityState(i);

	cmp	al, BYTE PTR _sg_kSave+12317
	jae	SHORT $LN98@SetupPlaye
	cmp	al, 64					; 00000040H
	jae	SHORT $LN98@SetupPlaye
	movzx	ebp, al
	imul	ebp, 436				; 000001b4H
	add	ebp, OFFSET _sg_kSave+550560
	jmp	SHORT $LN97@SetupPlaye
$LN98@SetupPlaye:
	mov	ebp, OFFSET ?sm_kErrorPlayer@CvWorldBuilderMap@@0UPlayer@1@A ; CvWorldBuilderMap::sm_kErrorPlayer
$LN97@SetupPlaye:

; 435  : 
; 436  : 		MinorCivTypes eCivType = NO_MINORCIV;
; 437  : #ifdef AUI_WARNING_FIXES
; 438  : 		for (uint iCiv = 0; iCiv < GC.getNumMinorCivInfos(); ++iCiv)
; 439  : #else
; 440  : 		for(int iCiv = 0; iCiv < GC.getNumMinorCivInfos(); ++iCiv)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	or	edi, -1
	xor	esi, esi
	call	?getNumMinorCivInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumMinorCivInfos
	test	eax, eax
	jle	SHORT $LN10@SetupPlaye
	npad	4
$LL12@SetupPlaye:

; 441  : #endif
; 442  : 		{
; 443  : 			CvMinorCivInfo* pkCivilization = GC.getMinorCivInfo((MinorCivTypes)iCiv);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo

; 444  : 			if(pkCivilization != NULL && strcmp(kPlayer.m_szCivType, pkCivilization->GetType()) == 0)

	test	eax, eax
	je	SHORT $LN11@SetupPlaye
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR [ebp+160]
$LL145@SetupPlaye:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN146@SetupPlaye
	test	dl, dl
	je	SHORT $LN147@SetupPlaye
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN146@SetupPlaye
	add	ecx, 2
	add	eax, 2
	test	dl, dl
	jne	SHORT $LL145@SetupPlaye
$LN147@SetupPlaye:
	xor	eax, eax
	jmp	SHORT $LN148@SetupPlaye
$LN146@SetupPlaye:
	sbb	eax, eax
	sbb	eax, -1
$LN148@SetupPlaye:
	test	eax, eax
	je	SHORT $LN119@SetupPlaye
$LN11@SetupPlaye:

; 435  : 
; 436  : 		MinorCivTypes eCivType = NO_MINORCIV;
; 437  : #ifdef AUI_WARNING_FIXES
; 438  : 		for (uint iCiv = 0; iCiv < GC.getNumMinorCivInfos(); ++iCiv)
; 439  : #else
; 440  : 		for(int iCiv = 0; iCiv < GC.getNumMinorCivInfos(); ++iCiv)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumMinorCivInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumMinorCivInfos
	cmp	esi, eax
	jl	SHORT $LL12@SetupPlaye

; 478  : 			if(pkHandicap != NULL && strcmp(kPlayer.m_szHandicap, pkHandicap->GetType()) == 0)

	jmp	SHORT $LN10@SetupPlaye
$LN119@SetupPlaye:

; 445  : 			{
; 446  : 				eCivType = (MinorCivTypes)iCiv;

	mov	edi, esi
$LN10@SetupPlaye:

; 447  : 				break;
; 448  : 			}
; 449  : 		}
; 450  : 
; 451  : 		CvPreGame::setMinorCivType(ePlayer, eCivType);

	push	edi
	push	ebx
	call	?setMinorCivType@CvPreGame@@YAXW4PlayerTypes@@W4MinorCivTypes@@@Z ; CvPreGame::setMinorCivType
	add	esp, 8

; 452  : 
; 453  : 		PlayerColorTypes eColorType = NO_PLAYERCOLOR;
; 454  : #ifdef AUI_WARNING_FIXES
; 455  : 		for (uint iColor = 0; iColor < GC.GetNumPlayerColorInfos(); ++iColor)
; 456  : #else
; 457  : 		for(int iColor = 0; iColor < GC.GetNumPlayerColorInfos(); ++iColor)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	or	edi, -1
	xor	esi, esi
	call	?GetNumPlayerColorInfos@CvGlobals@@QAEHXZ ; CvGlobals::GetNumPlayerColorInfos
	test	eax, eax
	jle	SHORT $LN6@SetupPlaye
	npad	6
$LL8@SetupPlaye:

; 458  : #endif
; 459  : 		{
; 460  : 			CvPlayerColorInfo* pkColor = GC.GetPlayerColorInfo((PlayerColorTypes)iColor);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetPlayerColorInfo@CvGlobals@@QAEPAVCvPlayerColorInfo@@W4PlayerColorTypes@@@Z ; CvGlobals::GetPlayerColorInfo

; 461  : 			if(pkColor != NULL && strcmp(kPlayer.m_szTeamColor, pkColor->GetType()) == 0)

	test	eax, eax
	je	SHORT $LN7@SetupPlaye
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR [ebp+224]
$LL149@SetupPlaye:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN150@SetupPlaye
	test	dl, dl
	je	SHORT $LN151@SetupPlaye
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN150@SetupPlaye
	add	ecx, 2
	add	eax, 2
	test	dl, dl
	jne	SHORT $LL149@SetupPlaye
$LN151@SetupPlaye:
	xor	eax, eax
	jmp	SHORT $LN152@SetupPlaye
$LN150@SetupPlaye:
	sbb	eax, eax
	sbb	eax, -1
$LN152@SetupPlaye:
	test	eax, eax
	je	SHORT $LN120@SetupPlaye
$LN7@SetupPlaye:

; 452  : 
; 453  : 		PlayerColorTypes eColorType = NO_PLAYERCOLOR;
; 454  : #ifdef AUI_WARNING_FIXES
; 455  : 		for (uint iColor = 0; iColor < GC.GetNumPlayerColorInfos(); ++iColor)
; 456  : #else
; 457  : 		for(int iColor = 0; iColor < GC.GetNumPlayerColorInfos(); ++iColor)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?GetNumPlayerColorInfos@CvGlobals@@QAEHXZ ; CvGlobals::GetNumPlayerColorInfos
	cmp	esi, eax
	jl	SHORT $LL8@SetupPlaye

; 478  : 			if(pkHandicap != NULL && strcmp(kPlayer.m_szHandicap, pkHandicap->GetType()) == 0)

	jmp	SHORT $LN6@SetupPlaye
$LN120@SetupPlaye:

; 462  : 			{
; 463  : 				eColorType = (PlayerColorTypes)iColor;

	mov	edi, esi
$LN6@SetupPlaye:

; 464  : 				break;
; 465  : 			}
; 466  : 		}
; 467  : 
; 468  : 		CvPreGame::setPlayerColor(ePlayer, eColorType);

	push	edi
	push	ebx
	call	?setPlayerColor@CvPreGame@@YAXW4PlayerTypes@@W4PlayerColorTypes@@@Z ; CvPreGame::setPlayerColor
	add	esp, 8

; 469  : 
; 470  : 		HandicapTypes eHandicap = NO_HANDICAP;
; 471  : #ifdef AUI_WARNING_FIXES
; 472  : 		for (uint iHandicap = 0; iHandicap < GC.getNumHandicapInfos(); ++iHandicap)
; 473  : #else
; 474  : 		for(int iHandicap = 0; iHandicap < GC.getNumHandicapInfos(); ++iHandicap)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	or	edi, -1
	xor	esi, esi
	call	?getNumHandicapInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumHandicapInfos
	test	eax, eax
	jle	SHORT $LN2@SetupPlaye
	npad	6
$LL4@SetupPlaye:

; 475  : #endif
; 476  : 		{
; 477  : 			CvHandicapInfo* pkHandicap = GC.getHandicapInfo((HandicapTypes)iHandicap);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z ; CvGlobals::getHandicapInfo

; 478  : 			if(pkHandicap != NULL && strcmp(kPlayer.m_szHandicap, pkHandicap->GetType()) == 0)

	test	eax, eax
	je	SHORT $LN3@SetupPlaye
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR [ebp+352]
$LL153@SetupPlaye:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN154@SetupPlaye
	test	dl, dl
	je	SHORT $LN155@SetupPlaye
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN154@SetupPlaye
	add	ecx, 2
	add	eax, 2
	test	dl, dl
	jne	SHORT $LL153@SetupPlaye
$LN155@SetupPlaye:
	xor	eax, eax
	jmp	SHORT $LN156@SetupPlaye
$LN154@SetupPlaye:
	sbb	eax, eax
	sbb	eax, -1
$LN156@SetupPlaye:
	test	eax, eax
	je	SHORT $LN121@SetupPlaye
$LN3@SetupPlaye:

; 469  : 
; 470  : 		HandicapTypes eHandicap = NO_HANDICAP;
; 471  : #ifdef AUI_WARNING_FIXES
; 472  : 		for (uint iHandicap = 0; iHandicap < GC.getNumHandicapInfos(); ++iHandicap)
; 473  : #else
; 474  : 		for(int iHandicap = 0; iHandicap < GC.getNumHandicapInfos(); ++iHandicap)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumHandicapInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumHandicapInfos
	cmp	esi, eax
	jl	SHORT $LL4@SetupPlaye

; 478  : 			if(pkHandicap != NULL && strcmp(kPlayer.m_szHandicap, pkHandicap->GetType()) == 0)

	jmp	SHORT $LN2@SetupPlaye
$LN121@SetupPlaye:

; 479  : 			{
; 480  : 				eHandicap = (HandicapTypes)iHandicap;

	mov	edi, esi
$LN2@SetupPlaye:

; 481  : 				break;
; 482  : 			}
; 483  : 		}
; 484  : 
; 485  : 		CvPreGame::setHandicap(ePlayer, eHandicap);

	push	edi
	push	ebx
	call	?setHandicap@CvPreGame@@YAXW4PlayerTypes@@W4HandicapTypes@@@Z ; CvPreGame::setHandicap

; 486  : 
; 487  : 		CvPreGame::setSlotStatus(ePlayer, SS_COMPUTER);

	push	1
	push	ebx
	call	?setSlotStatus@CvPreGame@@YAXW4PlayerTypes@@W4SlotStatus@@@Z ; CvPreGame::setSlotStatus

; 488  : 		CvPreGame::setTeamType(ePlayer, (TeamTypes)kPlayer.m_byTeam);

	movzx	ecx, BYTE PTR [ebp+432]
	push	ecx
	push	ebx
	call	?setTeamType@CvPreGame@@YAXW4PlayerTypes@@W4TeamTypes@@@Z ; CvPreGame::setTeamType

; 489  : 		CvPreGame::setMinorCiv(ePlayer, true);

	push	1
	push	ebx
	call	?setMinorCiv@CvPreGame@@YAXW4PlayerTypes@@_N@Z ; CvPreGame::setMinorCiv
	mov	eax, DWORD PTR _i$224361[esp+100]
	inc	eax
	add	esp, 32					; 00000020H
	mov	DWORD PTR _i$224361[esp+68], eax
	cmp	eax, DWORD PTR _uiCityStateCount$[esp+68]
	jb	$LL163@SetupPlaye
$LN13@SetupPlaye:

; 490  : 	}
; 491  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ$0:
	lea	ecx, DWORD PTR $T227609[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ$1:
	lea	ecx, DWORD PTR $T227610[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ$2:
	lea	ecx, DWORD PTR $T227611[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ ENDP	; CvWorldBuilderMapLoader::SetupPlayers
PUBLIC	?RunPostProcessScript@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ; CvWorldBuilderMapLoader::RunPostProcessScript
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?RunPostProcessScript@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z
_TEXT	SEGMENT
_uiGlobalsCount$ = -1060				; size = 4
_iTop$ = -1056						; size = 4
tv93 = -1052						; size = 4
_kEntry$225243 = -1048					; size = 8
_szMapScriptPath$225258 = -1040				; size = 1040
_L$ = 8							; size = 4
?RunPostProcessScript@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z PROC ; CvWorldBuilderMapLoader::RunPostProcessScript, COMDAT

; 1752 : {

	sub	esp, 1060				; 00000424H
	push	ebp

; 1753 : 	if(L == NULL)

	mov	ebp, DWORD PTR _L$[esp+1060]
	test	ebp, ebp

; 1754 : 	{
; 1755 : 		FAssertMsg(L, "Seriously, you really need a lua state for this.");
; 1756 : 		return 0;

	je	$LN32@RunPostPro
	push	esi

; 1757 : 	}
; 1758 : 
; 1759 : 	const int iTop = lua_gettop(L);

	push	ebp
	call	_lua_gettop
	add	esp, 4

; 1760 : 
; 1761 : 	ModType& kGlobalsDataType = sg_kSave.m_kModData.m_kMapModData;
; 1762 : 	const uint uiGlobalsCount = kGlobalsDataType.GetFieldCount();

	mov	ecx, OFFSET _sg_kSave+2888
	mov	DWORD PTR _iTop$[esp+1068], eax
	call	?GetFieldCount@ModType@@QBEIXZ		; ModType::GetFieldCount
	mov	esi, eax
	mov	DWORD PTR _uiGlobalsCount$[esp+1068], esi

; 1763 : 	if(uiGlobalsCount > 0)

	test	esi, esi
	jbe	$LN10@RunPostPro
	push	ebx

; 1764 : 	{
; 1765 : 		ModDataEntry kEntry = sg_kSave.m_kModData.GetMapDataEntry();

	lea	eax, DWORD PTR _kEntry$225243[esp+1072]
	push	eax
	mov	ecx, OFFSET _sg_kSave+2888
	call	?GetMapDataEntry@CvWorldBuilderMapModData@@QAE?AVModDataEntry@@XZ ; CvWorldBuilderMapModData::GetMapDataEntry

; 1766 : 		for(uint uiField = 0; uiField < uiGlobalsCount; ++uiField)

	xor	ebx, ebx
	test	esi, esi
	jbe	$LN30@RunPostPro
	push	edi
	npad	9
$LL29@RunPostPro:

; 1767 : 		{
; 1768 : 			const char* szFieldName = kGlobalsDataType.GetFieldName(uiField);

	push	ebx
	mov	ecx, OFFSET _sg_kSave+2888
	call	?GetFieldName@ModType@@QBEPBDI@Z	; ModType::GetFieldName

; 1769 : 			if(szFieldName != NULL && strcmp(szFieldName, "PostProcessMapScript") == 0)

	test	eax, eax
	je	$LN11@RunPostPro
	mov	ecx, OFFSET $SG225251
$LL23@RunPostPro:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN24@RunPostPro
	test	dl, dl
	je	SHORT $LN25@RunPostPro
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN24@RunPostPro
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL23@RunPostPro
$LN25@RunPostPro:
	xor	eax, eax
	jmp	SHORT $LN26@RunPostPro
$LN24@RunPostPro:
	sbb	eax, eax
	sbb	eax, -1
$LN26@RunPostPro:
	test	eax, eax
	jne	$LN11@RunPostPro

; 1770 : 			{
; 1771 : 				if(kGlobalsDataType.GetFieldType(uiField) == ModType::TYPE_STRING)

	push	ebx
	mov	ecx, OFFSET _sg_kSave+2888
	call	?GetFieldType@ModType@@QBE?AW4FieldType@1@I@Z ; ModType::GetFieldType
	cmp	eax, 2
	jne	$LN11@RunPostPro

; 1772 : 				{
; 1773 : 					const char* szLua = kEntry.GetFieldAsString(uiField);

	push	ebx
	lea	ecx, DWORD PTR _kEntry$225243[esp+1080]
	call	?GetFieldAsString@ModDataEntry@@QBEPBDI@Z ; ModDataEntry::GetFieldAsString
	mov	edi, eax

; 1774 : #ifdef AUI_WARNING_FIXES
; 1775 : 					if (szLua == NULL || szLua[0] == '\0')
; 1776 : #else
; 1777 : 					if(szLua == NULL || strlen(szLua) == 0)

	test	edi, edi
	je	SHORT $LN6@RunPostPro
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL27@RunPostPro:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL27@RunPostPro
	sub	eax, edx
	jne	SHORT $LN7@RunPostPro
$LN6@RunPostPro:

; 1778 : #endif
; 1779 : 					{
; 1780 : 						szLua = kGlobalsDataType.GetFieldDefaultAsString(uiField);

	push	ebx
	mov	ecx, OFFSET _sg_kSave+2888
	call	?GetFieldDefaultAsString@ModType@@QBEPBDI@Z ; ModType::GetFieldDefaultAsString
	mov	edi, eax
$LN7@RunPostPro:

; 1781 : 					}
; 1782 : 					
; 1783 : 					ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	esi, eax

; 1784 : 					if(pkScriptSystem != NULL)

	test	esi, esi
	je	SHORT $LN11@RunPostPro

; 1785 : 					{
; 1786 : 						//1040 == _MAX_PATH * 4
; 1787 : 						char szMapScriptPath[1040] = {0};

	push	1039					; 0000040fH
	lea	ecx, DWORD PTR _szMapScriptPath$225258[esp+1081]
	push	0
	push	ecx
	mov	BYTE PTR _szMapScriptPath$225258[esp+1088], 0
	call	_memset

; 1788 : 						const bool bResult = gDLL->GetEvaluatedMapScriptPath(szLua, szMapScriptPath, 1040);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+1036]
	add	esp, 12					; 0000000cH
	push	1040					; 00000410H
	lea	ecx, DWORD PTR _szMapScriptPath$225258[esp+1080]
	push	ecx
	push	edi
	push	eax
	call	edx

; 1789 : 						if(!bResult)
; 1790 : 						{
; 1791 : 							FAssertMsg(0, "Failed to find \"PostProcessMap\" in Post Process Map Script.");
; 1792 : 						}
; 1793 : 
; 1794 : 						const bool bLoadedMapGenerator = pkScriptSystem->LoadFile(L, szMapScriptPath);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+8]
	lea	ecx, DWORD PTR _szMapScriptPath$225258[esp+1076]
	push	ecx
	push	ebp
	mov	ecx, esi
	call	edx

; 1795 : 						FAssertMsg(bLoadedMapGenerator, "Failed to load Post Process Map Script.");
; 1796 : 						if(bLoadedMapGenerator)

	test	al, al
	je	SHORT $LN11@RunPostPro

; 1797 : 						{
; 1798 : 							lua_getglobal(L, "PostProcessMap");

	push	OFFSET $SG225263
	push	-10002					; ffffd8eeH
	push	ebp
	call	_lua_getfield

; 1799 : 							if(lua_isfunction(L, -1))

	push	-1
	push	ebp
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 6
	jne	SHORT $LN11@RunPostPro

; 1800 : 								pkScriptSystem->CallFunction(L, 0, 0);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+28]
	push	0
	push	0
	push	ebp
	mov	ecx, esi
	call	edx
$LN11@RunPostPro:
	inc	ebx
	cmp	ebx, DWORD PTR _uiGlobalsCount$[esp+1076]
	jb	$LL29@RunPostPro
	pop	edi
$LN30@RunPostPro:
	pop	ebx
$LN10@RunPostPro:

; 1801 : 							else
; 1802 : 								FAssertMsg(0, "Failed to find \"PostProcessMap\" in Post Process Map Script.");
; 1803 : 						}
; 1804 : 					}
; 1805 : 				}
; 1806 : 			}
; 1807 : 		}
; 1808 : 	}
; 1809 : 
; 1810 : 	lua_settop(L, iTop);

	mov	eax, DWORD PTR _iTop$[esp+1068]
	push	eax
	push	ebp
	call	_lua_settop
	add	esp, 8
	pop	esi
$LN32@RunPostPro:

; 1811 : 
; 1812 : 	return 0;

	xor	eax, eax
	pop	ebp

; 1813 : }

	add	esp, 1060				; 00000424H
	ret	0
?RunPostProcessScript@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ENDP ; CvWorldBuilderMapLoader::RunPostProcessScript
_TEXT	ENDS
PUBLIC	?ValidateTerrain@CvWorldBuilderMapLoader@@SAXXZ	; CvWorldBuilderMapLoader::ValidateTerrain
EXTRN	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z:PROC ; CvPlot::setTerrainType
EXTRN	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z:PROC ; CvGlobals::getTerrainInfo
EXTRN	?getNumTerrainInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumTerrainInfos
; Function compile flags: /Ogtpy
;	COMDAT ?ValidateTerrain@CvWorldBuilderMapLoader@@SAXXZ
_TEXT	SEGMENT
_eValidTerrain$ = -12					; size = 4
_kMap$ = -8						; size = 4
_iNumTerrainTypes$ = -4					; size = 4
?ValidateTerrain@CvWorldBuilderMapLoader@@SAXXZ PROC	; CvWorldBuilderMapLoader::ValidateTerrain, COMDAT

; 1817 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp

; 1818 : 	CvMap& kMap = GC.getMap();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	esi
	push	edi

; 1819 : 
; 1820 : 	TerrainTypes eValidTerrain = NO_TERRAIN;
; 1821 : 	const int iNumTerrainTypes = GC.getNumTerrainInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _kMap$[esp+28], ebp
	mov	DWORD PTR _eValidTerrain$[esp+28], -1
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	mov	edi, eax

; 1822 : 	for(int i = 0; i < iNumTerrainTypes; ++i)

	xor	esi, esi
	mov	DWORD PTR _iNumTerrainTypes$[esp+28], edi
	test	edi, edi
	jle	SHORT $LN10@ValidateTe
	npad	1
$LL12@ValidateTe:

; 1823 : 	{
; 1824 : 		const TerrainTypes eTerrain = (TerrainTypes)i;
; 1825 : 		const CvTerrainInfo* pkTerrain = GC.getTerrainInfo(eTerrain);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo

; 1826 : 		if(pkTerrain != NULL)

	test	eax, eax
	jne	SHORT $LN31@ValidateTe
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL12@ValidateTe
	jmp	SHORT $LN10@ValidateTe
$LN31@ValidateTe:

; 1827 : 		{
; 1828 : 			eValidTerrain = eTerrain;

	mov	DWORD PTR _eValidTerrain$[esp+28], esi
$LN10@ValidateTe:

; 1829 : 			break;
; 1830 : 		}
; 1831 : 	}
; 1832 : 
; 1833 : 	FAssertMsg(eValidTerrain != NO_TERRAIN, "Could not find ANY valid terrain types!");
; 1834 : 
; 1835 : 	const int iPlotCount = kMap.getGridWidth() * kMap.getGridHeight();

	mov	ebx, DWORD PTR [ebp+4024]
	imul	ebx, DWORD PTR [ebp+4020]

; 1836 : 	for(int i = 0; i < iPlotCount; ++i)

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN6@ValidateTe

; 1829 : 			break;
; 1830 : 		}
; 1831 : 	}
; 1832 : 
; 1833 : 	FAssertMsg(eValidTerrain != NO_TERRAIN, "Could not find ANY valid terrain types!");
; 1834 : 
; 1835 : 	const int iPlotCount = kMap.getGridWidth() * kMap.getGridHeight();

	xor	ebp, ebp
	npad	1
$LL8@ValidateTe:

; 1837 : 	{
; 1838 : 		CvPlot* pkPlot = kMap.plotByIndex(i);

	test	edi, edi
	jl	SHORT $LN7@ValidateTe
	mov	eax, DWORD PTR _kMap$[esp+28]
	cmp	edi, DWORD PTR [eax+4028]
	jge	SHORT $LN7@ValidateTe
	mov	esi, DWORD PTR [eax+4068]
	add	esi, ebp

; 1839 : 		if(pkPlot != NULL)

	je	SHORT $LN7@ValidateTe

; 1840 : 		{
; 1841 : 			const TerrainTypes eTerrainType = pkPlot->getTerrainType();

	movsx	eax, BYTE PTR [esi+6]

; 1842 : 			if(eTerrainType < 0 || eTerrainType >= iNumTerrainTypes)

	test	eax, eax
	jl	SHORT $LN3@ValidateTe
	cmp	eax, DWORD PTR _iNumTerrainTypes$[esp+28]
	jge	SHORT $LN3@ValidateTe

; 1845 : 			}
; 1846 : 			else
; 1847 : 			{
; 1848 : 				const CvTerrainInfo* pkTerrain = GC.getTerrainInfo(eTerrainType);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo

; 1849 : 				if(pkTerrain == NULL)

	test	eax, eax
	jne	SHORT $LN7@ValidateTe

; 1850 : 					pkPlot->setTerrainType(eValidTerrain);

	mov	eax, DWORD PTR _eValidTerrain$[esp+28]
	push	1
	push	1
	push	eax
	jmp	SHORT $LN34@ValidateTe
$LN3@ValidateTe:

; 1843 : 			{
; 1844 : 				pkPlot->setTerrainType(eValidTerrain);

	mov	ecx, DWORD PTR _eValidTerrain$[esp+28]
	push	1
	push	1
	push	ecx
$LN34@ValidateTe:
	mov	ecx, esi
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType
$LN7@ValidateTe:
	inc	edi
	add	ebp, 484				; 000001e4H
	cmp	edi, ebx
	jl	SHORT $LL8@ValidateTe
$LN6@ValidateTe:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1851 : 			}
; 1852 : 		}
; 1853 : 	}
; 1854 : }

	add	esp, 12					; 0000000cH
	ret	0
?ValidateTerrain@CvWorldBuilderMapLoader@@SAXXZ ENDP	; CvWorldBuilderMapLoader::ValidateTerrain
_TEXT	ENDS
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+232]
	mov	DWORD PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	?GetMapPlayers@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ; CvWorldBuilderMapLoader::GetMapPlayers
EXTRN	_lua_pushinteger:PROC
EXTRN	?Load@CvWorldBuilderMap@@QAE_NPB_WABVCvWorldBuilderMapTypeDesc@@_N@Z:PROC ; CvWorldBuilderMap::Load
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	_luaL_checklstring:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GetMapPlayers@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z
_TEXT	SEGMENT
_kPlayer$225488 = -544					; size = 4
_uiPlayer$225484 = -540					; size = 4
_iHandicapCount$225483 = -536				; size = 4
_eCivType$225489 = -532					; size = 4
_iCivCount$225482 = -528				; size = 4
_uiPlayerCount$225481 = -524				; size = 4
_wszMapFile$ = -520					; size = 520
_L$ = 8							; size = 4
?GetMapPlayers@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z PROC ; CvWorldBuilderMapLoader::GetMapPlayers, COMDAT

; 2166 : {

	sub	esp, 544				; 00000220H
	push	esi

; 2167 : 	if(L == NULL)

	mov	esi, DWORD PTR _L$[esp+544]
	test	esi, esi
	jne	SHORT $LN15@GetMapPlay@2

; 2168 : 	{
; 2169 : 		FAssertMsg(L, "Seriously, you really need a lua state for this.");
; 2170 : 		return 0;

	xor	eax, eax
	pop	esi

; 2246 : }

	add	esp, 544				; 00000220H
	ret	0
$LN15@GetMapPlay@2:
	push	edi

; 2171 : 	}
; 2172 : 
; 2173 : 	const char* szUTF8MapFile = luaL_checkstring(L, 1);

	push	0
	push	1
	push	esi
	call	_luaL_checklstring
	mov	edi, eax

; 2174 : 
; 2175 : 	wchar_t wszMapFile[MAX_PATH] = {0};

	xor	eax, eax
	push	518					; 00000206H
	push	eax
	lea	ecx, DWORD PTR _wszMapFile$[esp+574]
	push	ecx
	mov	WORD PTR _wszMapFile$[esp+576], ax
	call	_memset
	add	esp, 24					; 00000018H

; 2176 : 	MultiByteToWideChar(CP_UTF8, 0, szUTF8MapFile, -1, wszMapFile, MAX_PATH);

	push	260					; 00000104H
	lea	edx, DWORD PTR _wszMapFile$[esp+556]
	push	edx
	push	-1
	push	edi
	push	0
	push	65001					; 0000fde9H
	call	DWORD PTR __imp__MultiByteToWideChar@24

; 2177 : 
; 2178 : 	if(CheckTempMap(wszMapFile) || sg_kTempMap.Load(wszMapFile, sg_kMapTypeDesc))

	lea	eax, DWORD PTR _wszMapFile$[esp+552]
	push	eax
	call	?CheckTempMap@@YA_NPB_W@Z		; CheckTempMap
	add	esp, 4
	test	al, al
	jne	SHORT $LN13@GetMapPlay@2
	push	1
	push	OFFSET _sg_kMapTypeDesc
	lea	ecx, DWORD PTR _wszMapFile$[esp+560]
	push	ecx
	mov	ecx, OFFSET _sg_kTempMap
	call	?Load@CvWorldBuilderMap@@QAE_NPB_WABVCvWorldBuilderMapTypeDesc@@_N@Z ; CvWorldBuilderMap::Load
	test	al, al
	jne	SHORT $LN13@GetMapPlay@2

; 2238 : 		}
; 2239 : 	}
; 2240 : 	else
; 2241 : 	{
; 2242 : 		lua_pushnil(L);

	push	esi
	call	_lua_pushnil
	add	esp, 4
	pop	edi

; 2243 : 	}
; 2244 : 
; 2245 : 	return 1;

	mov	eax, 1
	pop	esi

; 2246 : }

	add	esp, 544				; 00000220H
	ret	0
$LN13@GetMapPlay@2:

; 2179 : 	{
; 2180 : 		TempMapLoaded(wszMapFile);

	lea	edx, DWORD PTR _wszMapFile$[esp+552]
	push	edx
	push	260					; 00000104H
	push	OFFSET _sg_wszTempMapName
	call	DWORD PTR __imp__wcscpy_s

; 2181 : 
; 2182 : #ifdef AUI_WARNING_FIXES
; 2183 : 		const byte uiPlayerCount = sg_kTempMap.GetPlayerCount();
; 2184 : #else
; 2185 : 		const uint uiPlayerCount = sg_kTempMap.GetPlayerCount();

	movzx	edi, BYTE PTR _sg_kTempMap+12316
	add	esp, 12					; 0000000cH

; 2186 : #endif
; 2187 : 		const int iCivCount = GC.getNumCivilizationInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _uiPlayerCount$225481[esp+552], edi
	call	?getNumCivilizationInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumCivilizationInfos

; 2188 : 		const int iHandicapCount = GC.getNumHandicapInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iCivCount$225482[esp+552], eax
	call	?getNumHandicapInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumHandicapInfos

; 2189 : 
; 2190 : 		lua_createtable(L, uiPlayerCount, 0);

	push	0
	push	edi
	push	esi
	mov	DWORD PTR _iHandicapCount$225483[esp+564], eax
	call	_lua_createtable

; 2191 : #ifdef AUI_WARNING_FIXES
; 2192 : 		for (byte uiPlayer = 0; uiPlayer < uiPlayerCount; ++uiPlayer)
; 2193 : #else
; 2194 : 		for(uint uiPlayer = 0; uiPlayer < uiPlayerCount; ++uiPlayer)

	xor	eax, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _uiPlayer$225484[esp+552], eax
	test	edi, edi
	jbe	$LN10@GetMapPlay@2
	push	ebx
	push	ebp
	jmp	SHORT $LN12@GetMapPlay@2
	npad	4
$LL48@GetMapPlay@2:
	mov	eax, DWORD PTR _uiPlayer$225484[esp+560]
$LN12@GetMapPlay@2:

; 2195 : #endif
; 2196 : 		{
; 2197 : 			const CvWorldBuilderMap::Player& kPlayer = sg_kTempMap.GetPlayer(uiPlayer);

	cmp	al, BYTE PTR _sg_kTempMap+12316
	jae	SHORT $LN23@GetMapPlay@2
	cmp	al, 32					; 00000020H
	jae	SHORT $LN23@GetMapPlay@2
	movzx	edi, al
	imul	edi, 436				; 000001b4H
	add	edi, OFFSET _sg_kTempMap+536608
	mov	DWORD PTR _kPlayer$225488[esp+560], edi
	jmp	SHORT $LN22@GetMapPlay@2
$LN23@GetMapPlay@2:
	mov	DWORD PTR _kPlayer$225488[esp+560], OFFSET ?sm_kErrorPlayer@CvWorldBuilderMap@@0UPlayer@1@A ; CvWorldBuilderMap::sm_kErrorPlayer
	mov	edi, DWORD PTR _kPlayer$225488[esp+560]
$LN22@GetMapPlay@2:

; 2198 : 
; 2199 : 			CivilizationTypes eCivType = NO_CIVILIZATION;
; 2200 : 			for(int iCiv = 0; iCiv < iCivCount; ++iCiv)

	xor	ebp, ebp
	cmp	DWORD PTR _iCivCount$225482[esp+560], ebp
	mov	DWORD PTR _eCivType$225489[esp+560], -1
	jle	SHORT $LN7@GetMapPlay@2
$LL9@GetMapPlay@2:

; 2201 : 			{
; 2202 : 				const CivilizationTypes eCurrentCiv = (CivilizationTypes)iCiv;
; 2203 : 				const CvCivilizationInfo* pkCiv = GC.getCivilizationInfo(eCurrentCiv);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo

; 2204 : 				if(pkCiv != NULL && strcmp(pkCiv->GetType(), kPlayer.m_szCivType) == 0)

	test	eax, eax
	je	SHORT $LN8@GetMapPlay@2
	lea	ecx, DWORD PTR [eax+176]
	add	edi, 160				; 000000a0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LL40@GetMapPlay@2:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edi]
	jne	SHORT $LN41@GetMapPlay@2
	test	cl, cl
	je	SHORT $LN42@GetMapPlay@2
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edi+1]
	jne	SHORT $LN41@GetMapPlay@2
	add	eax, 2
	add	edi, 2
	test	cl, cl
	jne	SHORT $LL40@GetMapPlay@2
$LN42@GetMapPlay@2:
	xor	eax, eax
	jmp	SHORT $LN43@GetMapPlay@2
$LN41@GetMapPlay@2:
	sbb	eax, eax
	sbb	eax, -1
$LN43@GetMapPlay@2:
	mov	edi, DWORD PTR _kPlayer$225488[esp+560]
	test	eax, eax
	je	SHORT $LN35@GetMapPlay@2
$LN8@GetMapPlay@2:

; 2198 : 
; 2199 : 			CivilizationTypes eCivType = NO_CIVILIZATION;
; 2200 : 			for(int iCiv = 0; iCiv < iCivCount; ++iCiv)

	inc	ebp
	cmp	ebp, DWORD PTR _iCivCount$225482[esp+560]
	jl	SHORT $LL9@GetMapPlay@2

; 2216 : 				if(pkHandicap != NULL && strcmp(pkHandicap->GetType(), kPlayer.m_szHandicap) == 0)

	jmp	SHORT $LN7@GetMapPlay@2
$LN35@GetMapPlay@2:

; 2205 : 				{
; 2206 : 					eCivType = eCurrentCiv;

	mov	DWORD PTR _eCivType$225489[esp+560], ebp
$LN7@GetMapPlay@2:

; 2207 : 					break;
; 2208 : 				}
; 2209 : 			}
; 2210 : 
; 2211 : 			HandicapTypes eHandicapType = (HandicapTypes)GC.getSTANDARD_HANDICAP();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8452

; 2212 : 			for(int iHandicap = 0; iHandicap < iHandicapCount; ++iHandicap)

	xor	ebp, ebp
	cmp	DWORD PTR _iHandicapCount$225483[esp+560], ebp
	jle	SHORT $LN3@GetMapPlay@2
	npad	6
$LL5@GetMapPlay@2:

; 2213 : 			{
; 2214 : 				const HandicapTypes eCurrentHandicap = (HandicapTypes)iHandicap;
; 2215 : 				const CvHandicapInfo* pkHandicap = GC.getHandicapInfo(eCurrentHandicap);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z ; CvGlobals::getHandicapInfo

; 2216 : 				if(pkHandicap != NULL && strcmp(pkHandicap->GetType(), kPlayer.m_szHandicap) == 0)

	test	eax, eax
	je	SHORT $LN4@GetMapPlay@2
	lea	ecx, DWORD PTR [eax+176]
	add	edi, 352				; 00000160H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LL44@GetMapPlay@2:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edi]
	jne	SHORT $LN45@GetMapPlay@2
	test	cl, cl
	je	SHORT $LN46@GetMapPlay@2
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edi+1]
	jne	SHORT $LN45@GetMapPlay@2
	add	eax, 2
	add	edi, 2
	test	cl, cl
	jne	SHORT $LL44@GetMapPlay@2
$LN46@GetMapPlay@2:
	xor	eax, eax
	jmp	SHORT $LN47@GetMapPlay@2
$LN45@GetMapPlay@2:
	sbb	eax, eax
	sbb	eax, -1
$LN47@GetMapPlay@2:
	mov	edi, DWORD PTR _kPlayer$225488[esp+560]
	test	eax, eax
	je	SHORT $LN36@GetMapPlay@2
$LN4@GetMapPlay@2:

; 2212 : 			for(int iHandicap = 0; iHandicap < iHandicapCount; ++iHandicap)

	inc	ebp
	cmp	ebp, DWORD PTR _iHandicapCount$225483[esp+560]
	jl	SHORT $LL5@GetMapPlay@2

; 2216 : 				if(pkHandicap != NULL && strcmp(pkHandicap->GetType(), kPlayer.m_szHandicap) == 0)

	jmp	SHORT $LN3@GetMapPlay@2
$LN36@GetMapPlay@2:

; 2217 : 				{
; 2218 : 					eHandicapType = eCurrentHandicap;

	mov	ebx, ebp
$LN3@GetMapPlay@2:

; 2219 : 					break;
; 2220 : 				}
; 2221 : 			}
; 2222 : 
; 2223 : 			lua_createtable(L, 0, 2);

	push	2
	push	0
	push	esi
	call	_lua_createtable

; 2224 : 
; 2225 : 			lua_pushstring(L, "CivType");

	push	OFFSET $SG225508
	push	esi
	call	_lua_pushstring

; 2226 : 			lua_pushinteger(L, eCivType);

	mov	eax, DWORD PTR _eCivType$225489[esp+580]
	push	eax
	push	esi
	call	_lua_pushinteger

; 2227 : 			lua_rawset(L, -3);

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 2228 : 
; 2229 : 			lua_pushstring(L, "Playable");

	push	OFFSET $SG225509
	push	esi
	call	_lua_pushstring

; 2230 : 			lua_pushboolean(L, kPlayer.m_bPlayable);

	movzx	ecx, BYTE PTR [edi+433]
	push	ecx
	push	esi
	call	_lua_pushboolean

; 2231 : 			lua_rawset(L, -3);

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 2232 : 
; 2233 : 			lua_pushstring(L, "DefaultHandicap");

	push	OFFSET $SG225510
	push	esi
	call	_lua_pushstring
	add	esp, 68					; 00000044H

; 2234 : 			lua_pushinteger(L, eHandicapType);

	push	ebx
	push	esi
	call	_lua_pushinteger

; 2235 : 			lua_rawset(L, -3);

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 2236 : 
; 2237 : 			lua_rawseti(L, -2, uiPlayer + 1);

	mov	edi, DWORD PTR _uiPlayer$225484[esp+576]
	inc	edi
	push	edi
	push	-2					; fffffffeH
	push	esi
	call	_lua_rawseti
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _uiPlayer$225484[esp+560], edi
	cmp	edi, DWORD PTR _uiPlayerCount$225481[esp+560]
	jb	$LL48@GetMapPlay@2
	pop	ebp
	pop	ebx
$LN10@GetMapPlay@2:
	pop	edi

; 2243 : 	}
; 2244 : 
; 2245 : 	return 1;

	mov	eax, 1
	pop	esi

; 2246 : }

	add	esp, 544				; 00000220H
	ret	0
?GetMapPlayers@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ENDP ; CvWorldBuilderMapLoader::GetMapPlayers
_TEXT	ENDS
PUBLIC	?AddRandomItems@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ; CvWorldBuilderMapLoader::AddRandomItems
EXTRN	?loadWBScenario@CvPreGame@@YA_NXZ:PROC		; CvPreGame::loadWBScenario
; Function compile flags: /Ogtpy
;	COMDAT ?AddRandomItems@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bRandomGoodies$ = 8					; size = 1
_L$ = 8							; size = 4
?AddRandomItems@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z PROC ; CvWorldBuilderMapLoader::AddRandomItems, COMDAT

; 2249 : {

	push	esi

; 2250 : 	if(L == NULL)

	mov	esi, DWORD PTR _L$[esp]
	test	esi, esi

; 2251 : 	{
; 2252 : 		FAssertMsg(L, "Seriously, you really need a lua state for this.");
; 2253 : 		return 0;

	je	$LN25@AddRandomI
	push	ebx
	push	ebp
	push	edi

; 2254 : 	}
; 2255 : 
; 2256 : 	const int iTop = lua_gettop(L);

	push	esi
	call	_lua_gettop
	mov	ebp, eax

; 2257 : 
; 2258 : 	const bool bRandomGoodies =
; 2259 : 	    sg_kSave.GetFlag(CvWorldBuilderMap::FLAG_RANDOM_GOODIES) ||
; 2260 : 	    (sg_kSave.GetFlag(CvWorldBuilderMap::FLAG_OLD_GOODIE_RULES) && !CvPreGame::loadWBScenario());

	mov	eax, DWORD PTR _sg_kSave+12224
	mov	ecx, eax
	shr	ecx, 2
	add	esp, 4
	test	cl, 1
	jne	SHORT $LN24@AddRandomI
	shr	eax, 3
	test	al, 1
	je	SHORT $LN13@AddRandomI
	call	?loadWBScenario@CvPreGame@@YA_NXZ	; CvPreGame::loadWBScenario
	test	al, al
	je	SHORT $LN24@AddRandomI
$LN13@AddRandomI:
	mov	BYTE PTR _bRandomGoodies$[esp+12], 0
	jmp	SHORT $LN15@AddRandomI
$LN24@AddRandomI:
	mov	BYTE PTR _bRandomGoodies$[esp+12], 1
$LN15@AddRandomI:

; 2261 : 
; 2262 : 	const bool bRandomResources = sg_kSave.GetFlag(CvWorldBuilderMap::FLAG_RANDOM_RECOURCES);
; 2263 : 
; 2264 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	ebx, DWORD PTR _sg_kSave+12224
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	shr	ebx, 1
	and	bl, 1
	call	eax
	mov	edi, eax

; 2265 : 	if(pkScriptSystem != NULL && (bRandomResources || bRandomGoodies))

	test	edi, edi
	je	$LN2@AddRandomI
	test	bl, bl
	jne	SHORT $LN8@AddRandomI
	cmp	BYTE PTR _bRandomGoodies$[esp+12], bl
	je	SHORT $LN2@AddRandomI
$LN8@AddRandomI:

; 2266 : 	{
; 2267 : 		const char* szLuaFile = "WorldBuilderRandomItems.lua";
; 2268 : 		const bool bLoadedMapGenerator = pkScriptSystem->LoadFile(L, szLuaFile);

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+8]
	push	OFFSET $SG225523
	push	esi
	mov	ecx, edi
	call	eax

; 2269 : 		FAssertMsg1(bLoadedMapGenerator, "Failed to load %s", szLuaFile);
; 2270 : 		if(bLoadedMapGenerator)

	test	al, al
	je	SHORT $LN2@AddRandomI

; 2271 : 		{
; 2272 : 			if(bRandomGoodies)

	cmp	BYTE PTR _bRandomGoodies$[esp+12], 0
	je	SHORT $LN5@AddRandomI

; 2273 : 			{
; 2274 : 				const char* szGoodiesFunction = "AddGoodies";
; 2275 : 				lua_getglobal(L, szGoodiesFunction);

	push	OFFSET $SG225528
	push	-10002					; ffffd8eeH
	push	esi
	call	_lua_getfield

; 2276 : 				if(lua_isfunction(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 6
	jne	SHORT $LN5@AddRandomI

; 2277 : 					pkScriptSystem->CallFunction(L, 0, 0);

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+28]
	push	0
	push	0
	push	esi
	mov	ecx, edi
	call	eax
$LN5@AddRandomI:

; 2278 : 				else
; 2279 : 					FAssertMsg2(0, "Failed to find \"%s\" in %s", szGoodiesFunction, szLuaFile);
; 2280 : 			}
; 2281 : 
; 2282 : 			if(bRandomResources)

	test	bl, bl
	je	SHORT $LN2@AddRandomI

; 2283 : 			{
; 2284 : 				const char* szResourcesFunction = "AddResourcesForWorldBuilderMap";
; 2285 : 				lua_getglobal(L, szResourcesFunction);

	push	OFFSET $SG225533
	push	-10002					; ffffd8eeH
	push	esi
	call	_lua_getfield

; 2286 : 				if(lua_isfunction(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 6
	jne	SHORT $LN2@AddRandomI

; 2287 : 					pkScriptSystem->CallFunction(L, 0, 0);

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+28]
	push	0
	push	0
	push	esi
	mov	ecx, edi
	call	eax
$LN2@AddRandomI:

; 2288 : 				else
; 2289 : 					FAssertMsg2(0, "Failed to find \"%s\" in %s", szResourcesFunction, szLuaFile);
; 2290 : 			}
; 2291 : 		}
; 2292 : 	}
; 2293 : 
; 2294 : 	lua_settop(L, iTop);

	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	pop	edi
	pop	ebp
	pop	ebx
$LN25@AddRandomI:

; 2295 : 
; 2296 : 	return 0;

	xor	eax, eax
	pop	esi

; 2297 : }

	ret	0
?AddRandomItems@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ENDP ; CvWorldBuilderMapLoader::AddRandomItems
_TEXT	ENDS
PUBLIC	?ScatterResources@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ; CvWorldBuilderMapLoader::ScatterResources
; Function compile flags: /Ogtpy
;	COMDAT ?ScatterResources@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?ScatterResources@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z PROC ; CvWorldBuilderMapLoader::ScatterResources, COMDAT

; 2300 : {

	push	edi

; 2301 : 	if(L == NULL)

	mov	edi, DWORD PTR _L$[esp]
	test	edi, edi

; 2302 : 	{
; 2303 : 		FAssertMsg(L, "Seriously, you really need a lua state for this.");
; 2304 : 		return 0;

	je	SHORT $LN10@ScatterRes
	push	ebx
	push	esi

; 2305 : 	}
; 2306 : 
; 2307 : 	const int iTop = lua_gettop(L);

	push	edi
	call	_lua_gettop

; 2308 : 
; 2309 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	ebx, eax
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	add	esp, 4
	call	edx
	mov	esi, eax

; 2310 : 	if(pkScriptSystem != NULL)

	test	esi, esi
	je	SHORT $LN2@ScatterRes

; 2311 : 	{
; 2312 : 		const bool bLoadedMapGenerator = pkScriptSystem->LoadFile(L, "WorldBuilderRandomItems.lua");

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+8]
	push	OFFSET $SG225544
	push	edi
	mov	ecx, esi
	call	edx

; 2313 : 		FAssertMsg(bLoadedMapGenerator, "Failed to load WorldBuilderRandomItems.lua");
; 2314 : 		if(bLoadedMapGenerator)

	test	al, al
	je	SHORT $LN2@ScatterRes

; 2315 : 		{
; 2316 : 			lua_getglobal(L, "AddResourcesForWorldBuilderMap");

	push	OFFSET $SG225546
	push	-10002					; ffffd8eeH
	push	edi
	call	_lua_getfield

; 2317 : 			if(lua_isfunction(L, -1))

	push	-1
	push	edi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 6
	jne	SHORT $LN2@ScatterRes

; 2318 : 				pkScriptSystem->CallFunction(L, 0, 0);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+28]
	push	0
	push	0
	push	edi
	mov	ecx, esi
	call	edx
$LN2@ScatterRes:

; 2319 : 			else
; 2320 : 				FAssertMsg(0, "Failed to find \"AddResourcesForWorldBuilderMap\" in WorldBuilderRandomItems.lua");
; 2321 : 		}
; 2322 : 	}
; 2323 : 
; 2324 : 	lua_settop(L, iTop);

	push	ebx
	push	edi
	call	_lua_settop
	add	esp, 8
	pop	esi
	pop	ebx
$LN10@ScatterRes:

; 2325 : 
; 2326 : 	return 0;

	xor	eax, eax
	pop	edi

; 2327 : }

	ret	0
?ScatterResources@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ENDP ; CvWorldBuilderMapLoader::ScatterResources
_TEXT	ENDS
PUBLIC	?ScatterGoodies@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ; CvWorldBuilderMapLoader::ScatterGoodies
; Function compile flags: /Ogtpy
;	COMDAT ?ScatterGoodies@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?ScatterGoodies@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z PROC ; CvWorldBuilderMapLoader::ScatterGoodies, COMDAT

; 2330 : {

	push	edi

; 2331 : 	if(L == NULL)

	mov	edi, DWORD PTR _L$[esp]
	test	edi, edi

; 2332 : 	{
; 2333 : 		FAssertMsg(L, "Seriously, you really need a lua state for this.");
; 2334 : 		return 0;

	je	SHORT $LN10@ScatterGoo
	push	ebx
	push	esi

; 2335 : 	}
; 2336 : 
; 2337 : 	const int iTop = lua_gettop(L);

	push	edi
	call	_lua_gettop

; 2338 : 
; 2339 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	ebx, eax
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	add	esp, 4
	call	edx
	mov	esi, eax

; 2340 : 	if(pkScriptSystem != NULL)

	test	esi, esi
	je	SHORT $LN2@ScatterGoo

; 2341 : 	{
; 2342 : 		const bool bLoadedMapGenerator = pkScriptSystem->LoadFile(L, "WorldBuilderRandomItems.lua");

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+8]
	push	OFFSET $SG225557
	push	edi
	mov	ecx, esi
	call	edx

; 2343 : 		FAssertMsg(bLoadedMapGenerator, "Failed to load WorldBuilderRandomItems.lua");
; 2344 : 		if(bLoadedMapGenerator)

	test	al, al
	je	SHORT $LN2@ScatterGoo

; 2345 : 		{
; 2346 : 			lua_getglobal(L, "AddGoodies");

	push	OFFSET $SG225559
	push	-10002					; ffffd8eeH
	push	edi
	call	_lua_getfield

; 2347 : 			if(lua_isfunction(L, -1))

	push	-1
	push	edi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 6
	jne	SHORT $LN2@ScatterGoo

; 2348 : 				pkScriptSystem->CallFunction(L, 0, 0);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+28]
	push	0
	push	0
	push	edi
	mov	ecx, esi
	call	edx
$LN2@ScatterGoo:

; 2349 : 			else
; 2350 : 				FAssertMsg(0, "Failed to find \"AddGoodies\" in WorldBuilderRandomItems.lua");
; 2351 : 		}
; 2352 : 	}
; 2353 : 
; 2354 : 	lua_settop(L, iTop);

	push	ebx
	push	edi
	call	_lua_settop
	add	esp, 8
	pop	esi
	pop	ebx
$LN10@ScatterGoo:

; 2355 : 
; 2356 : 	return 0;

	xor	eax, eax
	pop	edi

; 2357 : }

	ret	0
?ScatterGoodies@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ENDP ; CvWorldBuilderMapLoader::ScatterGoodies
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::~_Vector_val<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::~_Vector_val<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::~_Vector_val<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >
_TEXT	ENDS
PUBLIC	?test@?$bitset@$0BAA@@std@@QBE_NI@Z		; std::bitset<256>::test
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\bitset
;	COMDAT ?test@?$bitset@$0BAA@@std@@QBE_NI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
?test@?$bitset@$0BAA@@std@@QBE_NI@Z PROC		; std::bitset<256>::test, COMDAT
; _this$ = ecx

; 354  : 		if (_Bits <= _Pos)

	mov	edx, DWORD PTR __Pos$[esp-4]
	push	esi
	mov	esi, ecx
	cmp	edx, 256				; 00000100H
	jb	SHORT $LN1@test

; 355  : 			_Xran();	// _Pos off end

	call	?_Xran@?$bitset@$0BAA@@std@@ABEXXZ	; std::bitset<256>::_Xran
$LN5@test:
$LN1@test:

; 356  : 		return ((_Array[_Pos / _Bitsperword]
; 357  : 			& ((_Ty)1 << _Pos % _Bitsperword)) != 0);

	mov	ecx, edx
	and	ecx, 31					; 0000001fH
	mov	eax, 1
	shl	eax, cl
	shr	edx, 5
	and	eax, DWORD PTR [esi+edx*4]
	pop	esi
	neg	eax
	sbb	eax, eax
	neg	eax

; 358  : 		}

	ret	4
$LN4@test:
?test@?$bitset@$0BAA@@std@@QBE_NI@Z ENDP		; std::bitset<256>::test
_TEXT	ENDS
PUBLIC	??0FStringW@@QAE@XZ				; FStringW::FStringW
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstringw.inl
;	COMDAT ??0FStringW@@QAE@XZ
_TEXT	SEGMENT
??0FStringW@@QAE@XZ PROC				; FStringW::FStringW, COMDAT
; _this$ = ecx

; 85   : {

	push	esi
	mov	esi, ecx

; 86   : 	Init();

	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [esi], eax

; 87   : }

	mov	eax, esi
	pop	esi
	ret	0
??0FStringW@@QAE@XZ ENDP				; FStringW::FStringW
_TEXT	ENDS
PUBLIC	?test@?$bitset@$0CAA@@std@@QBE_NI@Z		; std::bitset<512>::test
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\bitset
;	COMDAT ?test@?$bitset@$0CAA@@std@@QBE_NI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
?test@?$bitset@$0CAA@@std@@QBE_NI@Z PROC		; std::bitset<512>::test, COMDAT
; _this$ = ecx

; 354  : 		if (_Bits <= _Pos)

	mov	edx, DWORD PTR __Pos$[esp-4]
	push	esi
	mov	esi, ecx
	cmp	edx, 512				; 00000200H
	jb	SHORT $LN1@test@2

; 355  : 			_Xran();	// _Pos off end

	call	?_Xran@?$bitset@$0CAA@@std@@ABEXXZ	; std::bitset<512>::_Xran
$LN5@test@2:
$LN1@test@2:

; 356  : 		return ((_Array[_Pos / _Bitsperword]
; 357  : 			& ((_Ty)1 << _Pos % _Bitsperword)) != 0);

	mov	ecx, edx
	and	ecx, 31					; 0000001fH
	mov	eax, 1
	shl	eax, cl
	shr	edx, 5
	and	eax, DWORD PTR [esi+edx*4]
	pop	esi
	neg	eax
	sbb	eax, eax
	neg	eax

; 358  : 		}

	ret	4
$LN4@test@2:
?test@?$bitset@$0CAA@@std@@QBE_NI@Z ENDP		; std::bitset<512>::test
_TEXT	ENDS
PUBLIC	?GetBitIndex@?$FRelationshipBitset@$0GA@$00@@CA?BIII@Z ; FRelationshipBitset<96,1>::GetBitIndex
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvworldbuildermap\include\frelationshipbitset.h
;	COMDAT ?GetBitIndex@?$FRelationshipBitset@$0GA@$00@@CA?BIII@Z
_TEXT	SEGMENT
_uiFirst$ = 8						; size = 4
_uiSecond$ = 12						; size = 4
?GetBitIndex@?$FRelationshipBitset@$0GA@$00@@CA?BIII@Z PROC ; FRelationshipBitset<96,1>::GetBitIndex, COMDAT

; 98   : 		FAssertMsg(uiFirst != uiSecond, "There are no self relations in this bitset");
; 99   : 
; 100  : 		uint uiLarge, uiSmall;
; 101  : 		if( uiFirst > uiSecond )

	mov	eax, DWORD PTR _uiFirst$[esp-4]
	mov	edx, DWORD PTR _uiSecond$[esp-4]
	cmp	eax, edx
	jbe	SHORT $LN2@GetBitInde

; 102  : 		{
; 103  : 			uiLarge = uiFirst;

	mov	ecx, eax

; 110  : 		}
; 111  : 
; 112  : 		FAssertMsg(uiLarge < TElementCount, "Out of range!");
; 113  : 
; 114  : 		// uiStart represents the start of the bitfield for the large index
; 115  : 		const uint uiStart = GetTotalBitCount(uiLarge); // Get the bitcount leading up to this

	lea	eax, DWORD PTR [ecx-1]
	imul	eax, ecx
	shr	eax, 1

; 116  : 		return uiStart + uiSmall;

	add	eax, edx

; 117  : 	}

	ret	0
$LN2@GetBitInde:

; 104  : 			uiSmall = uiSecond;
; 105  : 		}
; 106  : 		else
; 107  : 		{
; 108  : 			uiLarge = uiSecond;

	mov	ecx, edx

; 109  : 			uiSmall = uiFirst;

	mov	edx, eax

; 110  : 		}
; 111  : 
; 112  : 		FAssertMsg(uiLarge < TElementCount, "Out of range!");
; 113  : 
; 114  : 		// uiStart represents the start of the bitfield for the large index
; 115  : 		const uint uiStart = GetTotalBitCount(uiLarge); // Get the bitcount leading up to this

	lea	eax, DWORD PTR [ecx-1]
	imul	eax, ecx
	shr	eax, 1

; 116  : 		return uiStart + uiSmall;

	add	eax, edx

; 117  : 	}

	ret	0
?GetBitIndex@?$FRelationshipBitset@$0GA@$00@@CA?BIII@Z ENDP ; FRelationshipBitset<96,1>::GetBitIndex
_TEXT	ENDS
PUBLIC	?GetBitIndex@?$FRelationshipBitset@$0GA@$0A@@@CA?BIII@Z ; FRelationshipBitset<96,0>::GetBitIndex
; Function compile flags: /Ogtpy
;	COMDAT ?GetBitIndex@?$FRelationshipBitset@$0GA@$0A@@@CA?BIII@Z
_TEXT	SEGMENT
_uiFirst$ = 8						; size = 4
_uiSecond$ = 12						; size = 4
?GetBitIndex@?$FRelationshipBitset@$0GA@$0A@@@CA?BIII@Z PROC ; FRelationshipBitset<96,0>::GetBitIndex, COMDAT

; 98   : 		FAssertMsg(uiFirst != uiSecond, "There are no self relations in this bitset");
; 99   : 
; 100  : 		uint uiLarge, uiSmall;
; 101  : 		if( uiFirst > uiSecond )

	mov	eax, DWORD PTR _uiFirst$[esp-4]
	mov	edx, DWORD PTR _uiSecond$[esp-4]
	cmp	eax, edx
	jbe	SHORT $LN2@GetBitInde@2

; 102  : 		{
; 103  : 			uiLarge = uiFirst;

	mov	ecx, eax

; 110  : 		}
; 111  : 
; 112  : 		FAssertMsg(uiLarge < TElementCount, "Out of range!");
; 113  : 
; 114  : 		// uiStart represents the start of the bitfield for the large index
; 115  : 		const uint uiStart = GetTotalBitCount(uiLarge); // Get the bitcount leading up to this

	lea	eax, DWORD PTR [ecx-1]
	imul	eax, ecx
	shr	eax, 1

; 116  : 		return uiStart + uiSmall;

	add	eax, edx

; 117  : 	}

	ret	0
$LN2@GetBitInde@2:

; 104  : 			uiSmall = uiSecond;
; 105  : 		}
; 106  : 		else
; 107  : 		{
; 108  : 			uiLarge = uiSecond;

	mov	ecx, edx

; 109  : 			uiSmall = uiFirst;

	mov	edx, eax

; 110  : 		}
; 111  : 
; 112  : 		FAssertMsg(uiLarge < TElementCount, "Out of range!");
; 113  : 
; 114  : 		// uiStart represents the start of the bitfield for the large index
; 115  : 		const uint uiStart = GetTotalBitCount(uiLarge); // Get the bitcount leading up to this

	lea	eax, DWORD PTR [ecx-1]
	imul	eax, ecx
	shr	eax, 1

; 116  : 		return uiStart + uiSmall;

	add	eax, edx

; 117  : 	}

	ret	0
?GetBitIndex@?$FRelationshipBitset@$0GA@$0A@@@CA?BIII@Z ENDP ; FRelationshipBitset<96,0>::GetBitIndex
_TEXT	ENDS
PUBLIC	??4FStringW@@QAEABV0@PB_W@Z			; FStringW::operator=
EXTRN	?Copy@FStringW@@QAEXHPB_WH@Z:PROC		; FStringW::Copy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstringw.inl
;	COMDAT ??4FStringW@@QAEABV0@PB_W@Z
_TEXT	SEGMENT
_lpszSource$ = 8					; size = 4
??4FStringW@@QAEABV0@PB_W@Z PROC			; FStringW::operator=, COMDAT
; _this$ = ecx

; 174  : 	Copy( SafeStrlen( lpszSource ), lpszSource );

	mov	edx, DWORD PTR _lpszSource$[esp-4]
	push	esi
	mov	esi, ecx
	test	edx, edx
	je	SHORT $LN5@operator@4
	mov	eax, edx
	push	edi
	lea	edi, DWORD PTR [eax+2]
$LL7@operator@4:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL7@operator@4
	sub	eax, edi
	pop	edi
	push	0
	sar	eax, 1
	push	edx
	push	eax
	mov	ecx, esi
	call	?Copy@FStringW@@QAEXHPB_WH@Z		; FStringW::Copy

; 175  : 
; 176  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 177  : }

	ret	4

; 174  : 	Copy( SafeStrlen( lpszSource ), lpszSource );

$LN5@operator@4:
	xor	eax, eax
	push	eax
	push	edx
	push	eax
	mov	ecx, esi
	call	?Copy@FStringW@@QAEXHPB_WH@Z		; FStringW::Copy

; 175  : 
; 176  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 177  : }

	ret	4
??4FStringW@@QAEABV0@PB_W@Z ENDP			; FStringW::operator=
_TEXT	ENDS
PUBLIC	?Alloc@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@IAEPAPAVCvPlayer@@I@Z ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@IAEPAPAVCvPlayer@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@IAEPAPAVCvPlayer@@I@Z PROC ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::Alloc, COMDAT
; _this$ = ecx

; 503  : 	T* Alloc( unsigned int uiSize ){

	push	esi

; 504  : 		if( uiSize > 0 ){

	mov	esi, DWORD PTR _uiSize$[esp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	jbe	SHORT $LN1@Alloc

; 505  :             
; 506  :             T* pRet = (T*)FAST_VEC_ALLOC::AllocAligned( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [esi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 507  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [edi+8], esi
	pop	edi
	pop	esi

; 511  : 	};

	ret	4
$LN1@Alloc:
	pop	edi

; 508  : 			return pRet;
; 509  : 		}
; 510  : 		return NULL;

	xor	eax, eax
	pop	esi

; 511  : 	};

	ret	4
?Alloc@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@IAEPAPAVCvPlayer@@I@Z ENDP ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::Alloc
_TEXT	ENDS
PUBLIC	?Free@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@IAEXPAPAVCvPlayer@@I@Z ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@IAEXPAPAVCvPlayer@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@IAEXPAPAVCvPlayer@@I@Z PROC ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::Free, COMDAT
; _this$ = ecx

; 516  : 		if( !bPODType) 
; 517  :             Destroy(pVal, uiNumElements);
; 518  : 
; 519  : 		FAST_VEC_ALLOC::FreeAligned( (void*)pVal );

	mov	eax, DWORD PTR _pVal$[esp-4]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 520  : 	};

	ret	8
?Free@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@IAEXPAPAVCvPlayer@@I@Z ENDP ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::Free
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@PAVString@CvWorldBuilderMapTypeDesc@@@Z ; std::_Vector_iterator<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Vector_iterator<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@PAVString@CvWorldBuilderMapTypeDesc@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@PAVString@CvWorldBuilderMapTypeDesc@@@Z PROC ; std::_Vector_iterator<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Vector_iterator<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@PAVString@CvWorldBuilderMapTypeDesc@@@Z ENDP ; std::_Vector_iterator<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Vector_iterator<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::operator!=
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVString@CvWorldBuilderMapTypeDesc@@PAV12@@stdext@@YAPAVString@CvWorldBuilderMapTypeDesc@@PAV12@00@Z ; stdext::unchecked_copy<CvWorldBuilderMapTypeDesc::String *,CvWorldBuilderMapTypeDesc::String *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVString@CvWorldBuilderMapTypeDesc@@PAV12@@stdext@@YAPAVString@CvWorldBuilderMapTypeDesc@@PAV12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVString@CvWorldBuilderMapTypeDesc@@PAV12@@stdext@@YAPAVString@CvWorldBuilderMapTypeDesc@@PAV12@00@Z PROC ; stdext::unchecked_copy<CvWorldBuilderMapTypeDesc::String *,CvWorldBuilderMapTypeDesc::String *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_
	push	esi
$LL9@unchecked_:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_
	pop	esi
$LN7@unchecked_:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAVString@CvWorldBuilderMapTypeDesc@@PAV12@@stdext@@YAPAVString@CvWorldBuilderMapTypeDesc@@PAV12@00@Z ENDP ; stdext::unchecked_copy<CvWorldBuilderMapTypeDesc::String *,CvWorldBuilderMapTypeDesc::String *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@QAEXPAVString@CvWorldBuilderMapTypeDesc@@@Z ; std::allocator<CvWorldBuilderMapTypeDesc::String>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@QAEXPAVString@CvWorldBuilderMapTypeDesc@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@QAEXPAVString@CvWorldBuilderMapTypeDesc@@@Z PROC ; std::allocator<CvWorldBuilderMapTypeDesc::String>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@QAEXPAVString@CvWorldBuilderMapTypeDesc@@@Z ENDP ; std::allocator<CvWorldBuilderMapTypeDesc::String>::destroy
_TEXT	ENDS
PUBLIC	?Release@FStringW@@QAEXXZ			; FStringW::Release
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstringw.inl
;	COMDAT ?Release@FStringW@@QAEXXZ
_TEXT	SEGMENT
?Release@FStringW@@QAEXXZ PROC				; FStringW::Release, COMDAT
; _this$ = ecx

; 1008 : {

	push	esi
	push	edi
	mov	edi, ecx

; 1009 : 	Release( GetData() );

	mov	esi, DWORD PTR [edi]
	sub	esi, 12					; 0000000cH
	je	SHORT $LN5@Release@2
	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData
	cmp	esi, eax
	je	SHORT $LN5@Release@2
	cmp	WORD PTR [esi+10], 0
	jne	SHORT $LN5@Release@2
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@Release@2:

; 1010 : 	Init();

	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi

; 1011 : }

	ret	0
?Release@FStringW@@QAEXXZ ENDP				; FStringW::Release
_TEXT	ENDS
PUBLIC	?SetFixedBuffer@FStringW@@QAEXPAUFStringWData@1@@Z ; FStringW::SetFixedBuffer
; Function compile flags: /Ogtpy
;	COMDAT ?SetFixedBuffer@FStringW@@QAEXPAUFStringWData@1@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?SetFixedBuffer@FStringW@@QAEXPAUFStringWData@1@@Z PROC	; FStringW::SetFixedBuffer, COMDAT
; _this$ = ecx

; 1033 : {

	push	ebx

; 1034 : 	assert( pkData != NULL );
; 1035 : 	if(!pkData) return;

	mov	ebx, DWORD PTR _pkData$[esp]
	push	edi
	mov	edi, ecx
	test	ebx, ebx
	je	SHORT $LN2@SetFixedBu
	push	esi

; 1036 : 	assert( pkData->m_bFixed == 1 );
; 1037 : 	assert( pkData->m_iAllocLength > 0 );
; 1038 : 	Release();

	mov	esi, DWORD PTR [edi]
	sub	esi, 12					; 0000000cH
	je	SHORT $LN8@SetFixedBu
	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData
	cmp	esi, eax
	je	SHORT $LN8@SetFixedBu
	cmp	WORD PTR [esi+10], 0
	jne	SHORT $LN8@SetFixedBu
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN8@SetFixedBu:
	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData

; 1039 : 	m_pszString = pkData->StringData();

	add	ebx, 12					; 0000000cH
	mov	DWORD PTR [edi], ebx
	pop	esi
$LN2@SetFixedBu:
	pop	edi
	pop	ebx

; 1040 : }

	ret	4
?SetFixedBuffer@FStringW@@QAEXPAUFStringWData@1@@Z ENDP	; FStringW::SetFixedBuffer
_TEXT	ENDS
PUBLIC	??4FStringA@@QAEABV0@PBD@Z			; FStringA::operator=
EXTRN	?Copy@FStringA@@QAEXHPBDH@Z:PROC		; FStringA::Copy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstringa.inl
;	COMDAT ??4FStringA@@QAEABV0@PBD@Z
_TEXT	SEGMENT
_lpszSource$ = 8					; size = 4
??4FStringA@@QAEABV0@PBD@Z PROC				; FStringA::operator=, COMDAT
; _this$ = ecx

; 181  : 	Copy( SafeStrlen( lpszSource ), lpszSource );

	mov	edx, DWORD PTR _lpszSource$[esp-4]
	push	esi
	mov	esi, ecx
	test	edx, edx
	je	SHORT $LN5@operator@5
	mov	eax, edx
	push	edi
	lea	edi, DWORD PTR [eax+1]
$LL7@operator@5:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL7@operator@5
	sub	eax, edi
	pop	edi
	push	0
	push	edx
	push	eax
	mov	ecx, esi
	call	?Copy@FStringA@@QAEXHPBDH@Z		; FStringA::Copy

; 182  : 
; 183  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 184  : }

	ret	4

; 181  : 	Copy( SafeStrlen( lpszSource ), lpszSource );

$LN5@operator@5:
	xor	eax, eax
	push	eax
	push	edx
	push	eax
	mov	ecx, esi
	call	?Copy@FStringA@@QAEXHPBDH@Z		; FStringA::Copy

; 182  : 
; 183  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 184  : }

	ret	4
??4FStringA@@QAEABV0@PBD@Z ENDP				; FStringA::operator=
_TEXT	ENDS
PUBLIC	??BFStringA@@QBEPBDXZ				; FStringA::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BFStringA@@QBEPBDXZ
_TEXT	SEGMENT
??BFStringA@@QBEPBDXZ PROC				; FStringA::operator char const *, COMDAT
; _this$ = ecx

; 570  : 	return ( GetCString() );

	mov	eax, DWORD PTR [ecx]

; 571  : }

	ret	0
??BFStringA@@QBEPBDXZ ENDP				; FStringA::operator char const *
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	?GetID@CvUnit@@QBEHXZ				; CvUnit::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?GetID@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvUnit@@QBEHXZ PROC				; CvUnit::GetID, COMDAT
; _this$ = ecx

; 662  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+100]

; 663  : 	}

	ret	0
?GetID@CvUnit@@QBEHXZ ENDP				; CvUnit::GetID
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?GetID@CvCity@@QBEHXZ				; CvCity::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?GetID@CvCity@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvCity@@QBEHXZ PROC				; CvCity::GetID, COMDAT
; _this$ = ecx

; 331  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+120]

; 332  : 	}

	ret	0
?GetID@CvCity@@QBEHXZ ENDP				; CvCity::GetID
_TEXT	ENDS
PUBLIC	?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ	; CvCity::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ PROC		; CvCity::getOwner, COMDAT
; _this$ = ecx

; 604  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+84]

; 605  : 	}

	ret	0
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ENDP		; CvCity::getOwner
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1092 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1093 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ	; CvPlot::getFeatureType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ
_TEXT	SEGMENT
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ PROC	; CvPlot::getFeatureType, COMDAT
; _this$ = ecx

; 435  : #ifdef AUI_WARNING_FIXES
; 436  : 		int f = m_eFeatureType;
; 437  : #else
; 438  : 		char f = m_eFeatureType;
; 439  : #endif
; 440  : 		return (FeatureTypes)f;

	movsx	eax, BYTE PTR [ecx+432]

; 441  : 	}

	ret	0
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ ENDP	; CvPlot::getFeatureType
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?GetCity@@YAPBVCvCity@@W4PlayerTypes@@PBVCvPlot@@@Z ; GetCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
;	COMDAT ?GetCity@@YAPBVCvCity@@W4PlayerTypes@@PBVCvPlot@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_pkPlot$ = 12						; size = 4
?GetCity@@YAPBVCvCity@@W4PlayerTypes@@PBVCvPlot@@@Z PROC ; GetCity, COMDAT

; 865  : 	if(pkPlot != NULL)

	mov	ecx, DWORD PTR _pkPlot$[esp-4]
	test	ecx, ecx
	je	SHORT $LN1@GetCity

; 866  : 	{
; 867  : 		const CvCity* pkCity = pkPlot->getPlotCity();

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@GetCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@GetCity
	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 868  : 		if(pkCity != NULL && pkCity->getOwner() == ePlayer)

	test	eax, eax
	je	SHORT $LN1@GetCity
	mov	edx, DWORD PTR [eax+84]
	cmp	edx, DWORD PTR _ePlayer$[esp-4]

; 869  : 			return pkCity;

	je	SHORT $LN3@GetCity
$LN1@GetCity:

; 870  : 	}
; 871  : 
; 872  : 	return NULL;

	xor	eax, eax
$LN3@GetCity:

; 873  : }

	ret	0
?GetCity@@YAPBVCvCity@@W4PlayerTypes@@PBVCvPlot@@@Z ENDP ; GetCity
_TEXT	ENDS
PUBLIC	?FindClosestCity@@YAPBVCvCity@@W4PlayerTypes@@ABVCvPlot@@@Z ; FindClosestCity
; Function compile flags: /Ogtpy
;	COMDAT ?FindClosestCity@@YAPBVCvCity@@W4PlayerTypes@@ABVCvPlot@@@Z
_TEXT	SEGMENT
_kMap$ = -44						; size = 4
_iDist$224629 = -40					; size = 4
_iMapWidth$ = -36					; size = 4
_iPlot$224699 = -32					; size = 4
_iRow$224661 = -32					; size = 4
_iPlotY$ = -28						; size = 4
_iPlotX$ = -24						; size = 4
_iMapHeight$ = -20					; size = 4
tv2043 = -16						; size = 4
_iRowOffset$224660 = -16				; size = 4
tv2037 = -12						; size = 4
tv1381 = -12						; size = 4
tv1545 = -8						; size = 4
tv1383 = -8						; size = 4
tv1540 = -4						; size = 4
_ePlayer$ = 8						; size = 4
_bWorldWrap$ = 12					; size = 1
_kPlot$ = 12						; size = 4
?FindClosestCity@@YAPBVCvCity@@W4PlayerTypes@@ABVCvPlot@@@Z PROC ; FindClosestCity, COMDAT

; 876  : {

	sub	esp, 44					; 0000002cH
	push	esi

; 877  : 	{
; 878  : 		const CvCity* pkPlotCity = GetCity(ePlayer, &kPlot);

	mov	esi, DWORD PTR _kPlot$[esp+44]
	test	esi, esi
	je	SHORT $LN63@FindCloses
	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN63@FindCloses
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN63@FindCloses
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	je	SHORT $LN63@FindCloses
	mov	edx, DWORD PTR [eax+84]
	cmp	edx, DWORD PTR _ePlayer$[esp+44]

; 879  : 		if(pkPlotCity != NULL)
; 880  : 			return pkPlotCity;

	je	$LN64@FindCloses
$LN63@FindCloses:

; 881  : 	}
; 882  : 
; 883  : 	const CvMap& kMap = GC.getMap();
; 884  : 
; 885  : 	const int iPlotX = kPlot.getX();

	movsx	eax, WORD PTR [esi]
	push	ebx

; 886  : 	const int iPlotY = kPlot.getY();

	movsx	ebx, WORD PTR [esi+2]
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 887  : 
; 888  : 	const int iMapHeight = kMap.getGridHeight();

	mov	ecx, DWORD PTR [ebp+4024]

; 889  : 	const int iMapWidth  = kMap.getGridWidth();

	mov	edx, DWORD PTR [ebp+4020]
	mov	DWORD PTR _iPlotX$[esp+56], eax

; 890  : 
; 891  : 	const bool bWorldWrap = kMap.isWrapX();

	mov	al, BYTE PTR [ebp+4056]
	mov	DWORD PTR _iMapHeight$[esp+56], ecx

; 892  : 
; 893  : 	// Do a search radiating from the search plot
; 894  : 	for(int iDist = 1; iDist < iMapHeight || iDist < iMapWidth; ++iDist)

	mov	ecx, 1
	push	edi
	mov	DWORD PTR _kMap$[esp+60], ebp
	mov	DWORD PTR _iPlotY$[esp+60], ebx
	mov	DWORD PTR _iMapWidth$[esp+60], edx
	mov	BYTE PTR _bWorldWrap$[esp+56], al
	mov	DWORD PTR _iDist$224629[esp+60], ecx
$LL62@FindCloses:
	cmp	ecx, DWORD PTR _iMapHeight$[esp+60]
	jl	SHORT $LN59@FindCloses
	cmp	ecx, DWORD PTR _iMapWidth$[esp+60]
	jge	$LN60@FindCloses
$LN59@FindCloses:

; 895  : 	{
; 896  : 		// Center Row
; 897  : 		if(iPlotX - iDist >= 0)

	mov	eax, DWORD PTR _iPlotX$[esp+60]
	sub	eax, ecx

; 898  : 		{
; 899  : 			const CvPlot* pkTestPlot = kMap.plot(iPlotX - iDist, iPlotY);

	jns	SHORT $LN689@FindCloses

; 900  : 			const CvCity* pkCity = GetCity(ePlayer, pkTestPlot);
; 901  : 			if(pkCity) return pkCity;
; 902  : 		}
; 903  : 		else if(bWorldWrap)

	cmp	BYTE PTR _bWorldWrap$[esp+56], 0
	je	$LN660@FindCloses

; 904  : 		{
; 905  : 			int iX = iPlotX - iDist;

	mov	ecx, DWORD PTR _iMapWidth$[esp+60]
	npad	6
$LL54@FindCloses:

; 906  : 			while(iX < 0) iX += iMapWidth;

	add	eax, ecx
	js	SHORT $LL54@FindCloses
$LN689@FindCloses:

; 907  : 
; 908  : 			const CvPlot* pkTestPlot = kMap.plot(iX, iPlotY);

	cmp	eax, -2147483647			; 80000001H
	je	$LN660@FindCloses
	cmp	ebx, -2147483647			; 80000001H
	je	$LN660@FindCloses
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN152@FindCloses
	cmp	eax, ecx
	jl	SHORT $LN152@FindCloses
	cdq
	idiv	ecx
	mov	edi, edx
	jmp	SHORT $LN156@FindCloses
$LN152@FindCloses:
	mov	edi, eax
$LN156@FindCloses:
	cmp	BYTE PTR [ebp+4057], 0
	mov	esi, DWORD PTR [ebp+4024]
	je	SHORT $LN162@FindCloses
	test	ebx, ebx
	jge	SHORT $LN164@FindCloses
	mov	eax, ebx
	cdq
	idiv	esi
	add	edx, esi
	jmp	SHORT $LN166@FindCloses
$LN164@FindCloses:
	cmp	ebx, esi
	jl	SHORT $LN162@FindCloses
	mov	eax, ebx
	cdq
	idiv	esi
	jmp	SHORT $LN166@FindCloses
$LN162@FindCloses:
	mov	edx, ebx
$LN166@FindCloses:
	test	edi, edi
	jl	SHORT $LN660@FindCloses
	cmp	edi, ecx
	jge	SHORT $LN660@FindCloses
	test	edx, edx
	jl	SHORT $LN660@FindCloses
	cmp	edx, esi
	jge	SHORT $LN660@FindCloses
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]

; 909  : 			const CvCity* pkCity = GetCity(ePlayer, pkTestPlot);

	test	ecx, ecx
	je	SHORT $LN660@FindCloses
	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN660@FindCloses
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN660@FindCloses
	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	je	SHORT $LN660@FindCloses
	mov	edx, DWORD PTR _ePlayer$[esp+56]
	cmp	DWORD PTR [eax+84], edx
	je	$LN664@FindCloses
$LN660@FindCloses:

; 910  : 			if(pkCity) return pkCity;
; 911  : 		}
; 912  : 
; 913  : 		if(iPlotX + iDist < iMapWidth)

	mov	eax, DWORD PTR _iDist$224629[esp+60]
	mov	ecx, DWORD PTR _iPlotX$[esp+60]
	add	eax, ecx
	cmp	eax, DWORD PTR _iMapWidth$[esp+60]

; 914  : 		{
; 915  : 			const CvPlot* pkTestPlot = kMap.plot(iPlotX + iDist, iPlotY);

	jl	SHORT $LN690@FindCloses

; 916  : 			const CvCity* pkCity = GetCity(ePlayer, pkTestPlot);
; 917  : 			if(pkCity) return pkCity;
; 918  : 		}
; 919  : 		else if(bWorldWrap)

	cmp	BYTE PTR _bWorldWrap$[esp+56], 0
	je	$LN663@FindCloses

; 920  : 		{
; 921  : 			int iX = iPlotX + iDist;

	mov	ecx, DWORD PTR _iMapWidth$[esp+60]
$LL47@FindCloses:

; 922  : 			while(iX >= iMapWidth) iX -= iMapWidth;

	sub	eax, ecx
	cmp	eax, ecx
	jge	SHORT $LL47@FindCloses
$LN690@FindCloses:

; 923  : 
; 924  : 			const CvPlot* pkTestPlot = kMap.plot(iX, iPlotY);

	cmp	eax, -2147483647			; 80000001H
	je	$LN663@FindCloses
	cmp	ebx, -2147483647			; 80000001H
	je	$LN663@FindCloses
	cmp	BYTE PTR [ebp+4056], 0
	mov	edi, DWORD PTR [ebp+4020]
	je	SHORT $LN254@FindCloses
	test	eax, eax
	jge	SHORT $LN256@FindCloses
	cdq
	idiv	edi
	mov	ecx, edx
	add	ecx, edi
	jmp	SHORT $LN258@FindCloses
$LN256@FindCloses:
	cmp	eax, edi
	jl	SHORT $LN254@FindCloses
	cdq
	idiv	edi
	mov	ecx, edx
	jmp	SHORT $LN258@FindCloses
$LN254@FindCloses:
	mov	ecx, eax
$LN258@FindCloses:
	cmp	BYTE PTR [ebp+4057], 0
	mov	esi, DWORD PTR [ebp+4024]
	je	SHORT $LN662@FindCloses
	test	ebx, ebx
	jge	SHORT $LN266@FindCloses
	mov	eax, ebx
	cdq
	idiv	esi
	add	edx, esi
	jmp	SHORT $LN268@FindCloses
$LN266@FindCloses:
	cmp	ebx, esi
	jl	SHORT $LN662@FindCloses
	mov	eax, ebx
	cdq
	idiv	esi
	jmp	SHORT $LN268@FindCloses
$LN662@FindCloses:
	mov	edx, ebx
$LN268@FindCloses:
	test	ecx, ecx
	jl	SHORT $LN663@FindCloses
	cmp	ecx, edi
	jge	SHORT $LN663@FindCloses
	test	edx, edx
	jl	SHORT $LN663@FindCloses
	cmp	edx, esi
	jge	SHORT $LN663@FindCloses
	imul	edx, edi
	add	edx, ecx
	imul	edx, 484				; 000001e4H
	add	edx, DWORD PTR [ebp+4068]

; 925  : 			const CvCity* pkCity = GetCity(ePlayer, pkTestPlot);

	test	edx, edx
	je	SHORT $LN663@FindCloses
	mov	eax, DWORD PTR [edx+104]
	test	eax, eax
	jl	SHORT $LN663@FindCloses
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN663@FindCloses
	mov	edx, DWORD PTR [edx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	je	SHORT $LN663@FindCloses
	mov	ecx, DWORD PTR _ePlayer$[esp+56]
	cmp	DWORD PTR [eax+84], ecx
	je	$LN664@FindCloses
$LN663@FindCloses:

; 926  : 			if(pkCity) return pkCity;
; 927  : 		}
; 928  : 
; 929  : 		// Top and Bottom Rows
; 930  : 		const int iRowOffset = (iPlotY % 2 == 0)? 0 : 1;

	mov	eax, ebx
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN667@FindCloses
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN667@FindCloses:
	neg	eax
	sbb	eax, eax
	neg	eax
	mov	DWORD PTR _iRowOffset$224660[esp+60], eax

; 931  : 		for(int iRow = 1; iRow < iDist; ++iRow)

	mov	eax, 1
	cmp	DWORD PTR _iDist$224629[esp+60], eax
	mov	DWORD PTR _iRow$224661[esp+60], eax
	jle	$LN42@FindCloses
	mov	ecx, eax
	jmp	SHORT $LN44@FindCloses
	npad	1
$LL652@FindCloses:
	mov	ecx, DWORD PTR _iRow$224661[esp+60]
$LN44@FindCloses:

; 932  : 		{
; 933  : 			const int iRowWidth = (iDist * 2) - (iRow - 1);

	mov	eax, DWORD PTR _iDist$224629[esp+60]

; 934  : 
; 935  : 			{
; 936  : 				// Left-most plot in the current row
; 937  : 				int iX = iPlotX - (iRowWidth / 2);

	mov	esi, DWORD PTR _iPlotX$[esp+60]
	add	eax, eax
	sub	eax, ecx
	inc	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv1381[esp+60], eax
	sub	esi, eax

; 938  : 				if(iRow % 2 == 1) iX += iRowOffset;

	mov	eax, ecx
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN668@FindCloses
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN668@FindCloses:
	mov	DWORD PTR tv1383[esp+60], eax
	cmp	eax, 1
	jne	SHORT $LN41@FindCloses
	add	esi, DWORD PTR _iRowOffset$224660[esp+60]
$LN41@FindCloses:

; 939  : 
; 940  : 				if(iX < 0)

	test	esi, esi
	jge	SHORT $LN626@FindCloses

; 941  : 				{
; 942  : 					if(bWorldWrap)

	cmp	BYTE PTR _bWorldWrap$[esp+56], 0
	je	$LN656@FindCloses
	mov	eax, DWORD PTR _iMapWidth$[esp+60]
	npad	6
$LL38@FindCloses:

; 943  : 						do
; 944  : 						{
; 945  : 							iX += iMapWidth;

	add	esi, eax

; 946  : 						}
; 947  : 						while(iX < 0);

	js	SHORT $LL38@FindCloses
	mov	ecx, DWORD PTR _iRow$224661[esp+60]
$LN626@FindCloses:

; 948  : 				}
; 949  : 
; 950  : 				if(iX >= 0)
; 951  : 				{
; 952  : 					if(iPlotY - iRow >= 0)

	mov	ebx, DWORD PTR _iPlotY$[esp+60]
	sub	ebx, ecx
	js	$LN333@FindCloses

; 953  : 					{
; 954  : 						const CvPlot* pkTestPlot = kMap.plot(iX, iPlotY - iRow);

	cmp	esi, -2147483647			; 80000001H
	je	$LN333@FindCloses
	cmp	ebx, -2147483647			; 80000001H
	je	$LN333@FindCloses
	mov	eax, DWORD PTR _kMap$[esp+60]
	cmp	BYTE PTR [eax+4056], 0
	mov	edi, DWORD PTR [eax+4020]
	je	SHORT $LN305@FindCloses
	test	esi, esi
	jge	SHORT $LN307@FindCloses
	mov	eax, esi
	cdq
	idiv	edi
	mov	ecx, edx
	add	ecx, edi
	jmp	SHORT $LN309@FindCloses
$LN307@FindCloses:
	cmp	esi, edi
	jl	SHORT $LN305@FindCloses
	mov	eax, esi
	cdq
	idiv	edi
	mov	ecx, edx
	jmp	SHORT $LN309@FindCloses
$LN305@FindCloses:
	mov	ecx, esi
$LN309@FindCloses:
	mov	eax, DWORD PTR _kMap$[esp+60]
	cmp	BYTE PTR [eax+4057], 0
	mov	ebp, DWORD PTR [eax+4024]
	je	SHORT $LN315@FindCloses
	cmp	ebx, ebp
	jl	SHORT $LN315@FindCloses
	mov	eax, ebx
	cdq
	idiv	ebp
	jmp	SHORT $LN319@FindCloses
$LN315@FindCloses:
	mov	edx, ebx
$LN319@FindCloses:
	test	ecx, ecx
	jl	SHORT $LN333@FindCloses
	cmp	ecx, edi
	jge	SHORT $LN333@FindCloses
	test	edx, edx
	jl	SHORT $LN333@FindCloses
	cmp	edx, ebp
	jge	SHORT $LN333@FindCloses
	mov	eax, DWORD PTR _kMap$[esp+60]
	imul	edx, edi
	add	edx, ecx
	imul	edx, 484				; 000001e4H
	add	edx, DWORD PTR [eax+4068]

; 955  : 						const CvCity* pkCity = GetCity(ePlayer, pkTestPlot);

	test	edx, edx
	je	SHORT $LN333@FindCloses
	mov	eax, DWORD PTR [edx+104]
	test	eax, eax
	jl	SHORT $LN333@FindCloses
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN333@FindCloses
	mov	ecx, DWORD PTR [edx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	je	SHORT $LN333@FindCloses
	mov	edx, DWORD PTR _ePlayer$[esp+56]
	cmp	DWORD PTR [eax+84], edx
	je	$LN664@FindCloses
$LN333@FindCloses:

; 956  : 						if(pkCity) return pkCity;
; 957  : 					}
; 958  : 
; 959  : 					if(iPlotY + iRow < iMapHeight)

	mov	eax, DWORD PTR _iRow$224661[esp+60]
	mov	ecx, DWORD PTR _iPlotY$[esp+60]
	add	ecx, eax
	cmp	ecx, DWORD PTR _iMapHeight$[esp+60]
	jge	$LN656@FindCloses

; 960  : 					{
; 961  : 						const CvPlot* pkTestPlot = kMap.plot(iX, iPlotY + iRow);

	cmp	esi, -2147483647			; 80000001H
	je	$LN656@FindCloses
	cmp	ecx, -2147483647			; 80000001H
	je	$LN656@FindCloses
	mov	ebx, DWORD PTR _kMap$[esp+60]
	cmp	BYTE PTR [ebx+4056], 0
	mov	ebp, DWORD PTR [ebx+4020]
	je	SHORT $LN655@FindCloses
	test	esi, esi
	jge	SHORT $LN358@FindCloses
	mov	eax, esi
	cdq
	idiv	ebp
	mov	esi, edx
	add	esi, ebp
	jmp	SHORT $LN655@FindCloses
$LN358@FindCloses:
	cmp	esi, ebp
	jl	SHORT $LN655@FindCloses
	mov	eax, esi
	cdq
	idiv	ebp
	mov	esi, edx
$LN655@FindCloses:
	cmp	BYTE PTR [ebx+4057], 0
	mov	edi, DWORD PTR [ebx+4024]
	je	SHORT $LN658@FindCloses
	test	ecx, ecx
	jge	SHORT $LN368@FindCloses
	mov	eax, ecx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN370@FindCloses
$LN368@FindCloses:
	cmp	ecx, edi
	jl	SHORT $LN658@FindCloses
	mov	eax, ecx
	cdq
	idiv	edi
	jmp	SHORT $LN370@FindCloses
$LN658@FindCloses:
	mov	edx, ecx
$LN370@FindCloses:
	test	esi, esi
	jl	SHORT $LN656@FindCloses
	cmp	esi, ebp
	jge	SHORT $LN656@FindCloses
	test	edx, edx
	jl	SHORT $LN656@FindCloses
	cmp	edx, edi
	jge	SHORT $LN656@FindCloses
	imul	edx, ebp
	add	edx, esi
	imul	edx, 484				; 000001e4H
	add	edx, DWORD PTR [ebx+4068]

; 962  : 						const CvCity* pkCity = GetCity(ePlayer, pkTestPlot);

	test	edx, edx
	je	SHORT $LN656@FindCloses
	mov	eax, DWORD PTR [edx+104]
	test	eax, eax
	jl	SHORT $LN656@FindCloses
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN656@FindCloses
	mov	edx, DWORD PTR [edx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	je	SHORT $LN656@FindCloses
	mov	ecx, DWORD PTR _ePlayer$[esp+56]
	cmp	DWORD PTR [eax+84], ecx
	je	$LN664@FindCloses
$LN656@FindCloses:

; 963  : 						if(pkCity) return pkCity;
; 964  : 					}
; 965  : 				}
; 966  : 			}
; 967  : 
; 968  : 			{
; 969  : 				// Right-most plot in the current row
; 970  : 				int iX = iPlotX + (iRowWidth / 2) - 1;
; 971  : 				if(iRow % 2 == 1) iX += iRowOffset;

	cmp	DWORD PTR tv1383[esp+60], 1
	mov	edx, DWORD PTR tv1381[esp+60]
	mov	eax, DWORD PTR _iPlotX$[esp+60]
	lea	esi, DWORD PTR [edx+eax-1]
	jne	SHORT $LN30@FindCloses
	add	esi, DWORD PTR _iRowOffset$224660[esp+60]
$LN30@FindCloses:

; 972  : 
; 973  : 				if(iX >= iMapWidth)

	cmp	esi, DWORD PTR _iMapWidth$[esp+60]
	jl	SHORT $LN625@FindCloses

; 974  : 				{
; 975  : 					if(bWorldWrap)

	cmp	BYTE PTR _bWorldWrap$[esp+56], 0
	je	$LN43@FindCloses
	mov	eax, DWORD PTR _iMapWidth$[esp+60]
$LL27@FindCloses:

; 976  : 						do
; 977  : 						{
; 978  : 							iX -= iMapWidth;

	sub	esi, eax

; 979  : 						}
; 980  : 						while(iX >= iMapWidth);

	cmp	esi, eax
	jge	SHORT $LL27@FindCloses
$LN625@FindCloses:

; 981  : 				}
; 982  : 
; 983  : 				if(iX < iMapWidth)
; 984  : 				{
; 985  : 					if(iPlotY - iRow >= 0)

	mov	ebx, DWORD PTR _iPlotY$[esp+60]
	sub	ebx, DWORD PTR _iRow$224661[esp+60]
	js	$LN435@FindCloses

; 986  : 					{
; 987  : 						const CvPlot* pkTestPlot = kMap.plot(iX, iPlotY - iRow);

	cmp	esi, -2147483647			; 80000001H
	je	$LN435@FindCloses
	cmp	ebx, -2147483647			; 80000001H
	je	$LN435@FindCloses
	mov	eax, DWORD PTR _kMap$[esp+60]
	cmp	BYTE PTR [eax+4056], 0
	mov	edi, DWORD PTR [eax+4020]
	je	SHORT $LN407@FindCloses
	test	esi, esi
	jge	SHORT $LN409@FindCloses
	mov	eax, esi
	cdq
	idiv	edi
	mov	ecx, edx
	add	ecx, edi
	jmp	SHORT $LN411@FindCloses
$LN409@FindCloses:
	cmp	esi, edi
	jl	SHORT $LN407@FindCloses
	mov	eax, esi
	cdq
	idiv	edi
	mov	ecx, edx
	jmp	SHORT $LN411@FindCloses
$LN407@FindCloses:
	mov	ecx, esi
$LN411@FindCloses:
	mov	eax, DWORD PTR _kMap$[esp+60]
	cmp	BYTE PTR [eax+4057], 0
	mov	ebp, DWORD PTR [eax+4024]
	je	SHORT $LN417@FindCloses
	cmp	ebx, ebp
	jl	SHORT $LN417@FindCloses
	mov	eax, ebx
	cdq
	idiv	ebp
	jmp	SHORT $LN421@FindCloses
$LN417@FindCloses:
	mov	edx, ebx
$LN421@FindCloses:
	test	ecx, ecx
	jl	SHORT $LN435@FindCloses
	cmp	ecx, edi
	jge	SHORT $LN435@FindCloses
	test	edx, edx
	jl	SHORT $LN435@FindCloses
	cmp	edx, ebp
	jge	SHORT $LN435@FindCloses
	imul	edx, edi
	add	edx, ecx
	mov	ecx, DWORD PTR _kMap$[esp+60]
	imul	edx, 484				; 000001e4H
	add	edx, DWORD PTR [ecx+4068]

; 988  : 						const CvCity* pkCity = GetCity(ePlayer, pkTestPlot);

	test	edx, edx
	je	SHORT $LN435@FindCloses
	mov	eax, DWORD PTR [edx+104]
	test	eax, eax
	jl	SHORT $LN435@FindCloses
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN435@FindCloses
	mov	edx, DWORD PTR [edx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	je	SHORT $LN435@FindCloses
	mov	ecx, DWORD PTR _ePlayer$[esp+56]
	cmp	DWORD PTR [eax+84], ecx
	je	$LN664@FindCloses
$LN435@FindCloses:

; 989  : 						if(pkCity) return pkCity;
; 990  : 					}
; 991  : 
; 992  : 					if(iPlotY + iRow < iMapHeight)

	mov	edx, DWORD PTR _iRow$224661[esp+60]
	mov	eax, DWORD PTR _iPlotY$[esp+60]
	lea	ecx, DWORD PTR [edx+eax]
	cmp	ecx, DWORD PTR _iMapHeight$[esp+60]
	jge	$LN43@FindCloses

; 993  : 					{
; 994  : 						const CvPlot* pkTestPlot = kMap.plot(iX, iPlotY + iRow);

	cmp	esi, -2147483647			; 80000001H
	je	$LN43@FindCloses
	cmp	ecx, -2147483647			; 80000001H
	je	$LN43@FindCloses
	mov	ebx, DWORD PTR _kMap$[esp+60]
	cmp	BYTE PTR [ebx+4056], 0
	mov	ebp, DWORD PTR [ebx+4020]
	je	SHORT $LN653@FindCloses
	test	esi, esi
	jge	SHORT $LN460@FindCloses
	mov	eax, esi
	cdq
	idiv	ebp
	mov	esi, edx
	add	esi, ebp
	jmp	SHORT $LN653@FindCloses
$LN460@FindCloses:
	cmp	esi, ebp
	jl	SHORT $LN653@FindCloses
	mov	eax, esi
	cdq
	idiv	ebp
	mov	esi, edx
$LN653@FindCloses:
	cmp	BYTE PTR [ebx+4057], 0
	mov	edi, DWORD PTR [ebx+4024]
	je	SHORT $LN659@FindCloses
	test	ecx, ecx
	jge	SHORT $LN470@FindCloses
	mov	eax, ecx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN472@FindCloses
$LN470@FindCloses:
	cmp	ecx, edi
	jl	SHORT $LN659@FindCloses
	mov	eax, ecx
	cdq
	idiv	edi
	jmp	SHORT $LN472@FindCloses
$LN659@FindCloses:
	mov	edx, ecx
$LN472@FindCloses:
	test	esi, esi
	jl	SHORT $LN43@FindCloses
	cmp	esi, ebp
	jge	SHORT $LN43@FindCloses
	test	edx, edx
	jl	SHORT $LN43@FindCloses
	cmp	edx, edi
	jge	SHORT $LN43@FindCloses
	imul	edx, ebp
	add	edx, esi
	imul	edx, 484				; 000001e4H
	add	edx, DWORD PTR [ebx+4068]

; 995  : 						const CvCity* pkCity = GetCity(ePlayer, pkTestPlot);

	test	edx, edx
	je	SHORT $LN43@FindCloses
	mov	eax, DWORD PTR [edx+104]
	test	eax, eax
	jl	SHORT $LN43@FindCloses
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN43@FindCloses
	mov	ecx, DWORD PTR [edx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	je	SHORT $LN43@FindCloses
	mov	edx, DWORD PTR _ePlayer$[esp+56]
	cmp	DWORD PTR [eax+84], edx
	je	$LN664@FindCloses
$LN43@FindCloses:

; 931  : 		for(int iRow = 1; iRow < iDist; ++iRow)

	mov	eax, DWORD PTR _iRow$224661[esp+60]
	inc	eax
	cmp	eax, DWORD PTR _iDist$224629[esp+60]
	mov	DWORD PTR _iRow$224661[esp+60], eax
	jl	$LL652@FindCloses
$LN42@FindCloses:

; 996  : 						if(pkCity) return pkCity;
; 997  : 					}
; 998  : 				}
; 999  : 			}
; 1000 : 		}
; 1001 : 
; 1002 : 		// Top-most and Bottom-most rows
; 1003 : 		{
; 1004 : 			const int iRowWidth = iDist + 1;

	mov	eax, DWORD PTR _iDist$224629[esp+60]
	inc	eax
	mov	DWORD PTR tv1540[esp+60], eax

; 1005 : 			for(int iPlot = 0; iPlot < iRowWidth; ++iPlot)

	mov	DWORD PTR _iPlot$224699[esp+60], 0
	test	eax, eax
	jle	$LN61@FindCloses
	mov	ecx, DWORD PTR _iDist$224629[esp+60]
	and	ecx, -2147483647			; 80000001H
	jns	SHORT $LN669@FindCloses
	dec	ecx
	or	ecx, -2					; fffffffeH
	inc	ecx
$LN669@FindCloses:
	mov	edi, DWORD PTR _iPlotX$[esp+60]
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iRowOffset$224660[esp+60]
	sar	eax, 1
	mov	esi, edi
	sub	esi, eax
	sub	edx, eax
	add	edx, edi
	mov	DWORD PTR tv1545[esp+60], ecx
	mov	DWORD PTR tv2037[esp+60], esi
	mov	DWORD PTR tv2043[esp+60], edx
	jmp	SHORT $LN670@FindCloses
	npad	9
$LL649@FindCloses:

; 996  : 						if(pkCity) return pkCity;
; 997  : 					}
; 998  : 				}
; 999  : 			}
; 1000 : 		}
; 1001 : 
; 1002 : 		// Top-most and Bottom-most rows
; 1003 : 		{
; 1004 : 			const int iRowWidth = iDist + 1;

	mov	ecx, DWORD PTR tv1545[esp+60]
$LN670@FindCloses:
	mov	eax, DWORD PTR _iMapWidth$[esp+60]

; 1006 : 			{
; 1007 : 				int iX = iPlotX + iPlot - (iRowWidth / 2);
; 1008 : 				if(iDist % 2 == 1) iX += iRowOffset;

	cmp	ecx, 1
	jne	SHORT $LN16@FindCloses
	mov	esi, DWORD PTR tv2043[esp+60]
$LN16@FindCloses:

; 1009 : 
; 1010 : 				if(iX < 0)

	test	esi, esi
	jge	SHORT $LN15@FindCloses

; 1011 : 				{
; 1012 : 					if(!bWorldWrap)

	cmp	BYTE PTR _bWorldWrap$[esp+56], 0
	je	$LN18@FindCloses
$LL13@FindCloses:

; 1013 : 						continue;
; 1014 : 
; 1015 : 					do
; 1016 : 					{
; 1017 : 						iX += iMapWidth;

	add	esi, eax

; 1018 : 					}
; 1019 : 					while(iX < 0);

	js	SHORT $LL13@FindCloses

; 1020 : 				}
; 1021 : 				else if(iX >= iMapWidth)

	jmp	SHORT $LN5@FindCloses
$LN15@FindCloses:
	cmp	esi, eax
	jl	SHORT $LN5@FindCloses

; 1022 : 				{
; 1023 : 					if(!bWorldWrap)

	cmp	BYTE PTR _bWorldWrap$[esp+56], 0
	je	$LN18@FindCloses
$LL7@FindCloses:

; 1024 : 						continue;
; 1025 : 
; 1026 : 					do
; 1027 : 					{
; 1028 : 						iX -= iMapWidth;

	sub	esi, eax

; 1029 : 					}
; 1030 : 					while(iX >= iMapWidth);

	cmp	esi, eax
	jge	SHORT $LL7@FindCloses
$LN5@FindCloses:

; 1031 : 				}
; 1032 : 
; 1033 : 				if(iPlotY - iDist >= 0)

	mov	ebx, DWORD PTR _iPlotY$[esp+60]
	sub	ebx, DWORD PTR _iDist$224629[esp+60]
	js	$LN537@FindCloses

; 1034 : 				{
; 1035 : 					const CvPlot* pkTestPlot = kMap.plot(iX, iPlotY - iDist);

	cmp	esi, -2147483647			; 80000001H
	je	$LN537@FindCloses
	cmp	ebx, -2147483647			; 80000001H
	je	$LN537@FindCloses
	mov	eax, DWORD PTR _kMap$[esp+60]
	cmp	BYTE PTR [eax+4056], 0
	mov	edi, DWORD PTR [eax+4020]
	je	SHORT $LN509@FindCloses
	test	esi, esi
	jge	SHORT $LN511@FindCloses
	mov	eax, esi
	cdq
	idiv	edi
	mov	ecx, edx
	add	ecx, edi
	jmp	SHORT $LN513@FindCloses
$LN511@FindCloses:
	cmp	esi, edi
	jl	SHORT $LN509@FindCloses
	mov	eax, esi
	cdq
	idiv	edi
	mov	ecx, edx
	jmp	SHORT $LN513@FindCloses
$LN509@FindCloses:
	mov	ecx, esi
$LN513@FindCloses:
	mov	eax, DWORD PTR _kMap$[esp+60]
	cmp	BYTE PTR [eax+4057], 0
	mov	ebp, DWORD PTR [eax+4024]
	je	SHORT $LN519@FindCloses
	cmp	ebx, ebp
	jl	SHORT $LN519@FindCloses
	mov	eax, ebx
	cdq
	idiv	ebp
	jmp	SHORT $LN523@FindCloses
$LN519@FindCloses:
	mov	edx, ebx
$LN523@FindCloses:
	test	ecx, ecx
	jl	SHORT $LN537@FindCloses
	cmp	ecx, edi
	jge	SHORT $LN537@FindCloses
	test	edx, edx
	jl	SHORT $LN537@FindCloses
	cmp	edx, ebp
	jge	SHORT $LN537@FindCloses
	mov	eax, DWORD PTR _kMap$[esp+60]
	imul	edx, edi
	add	edx, ecx
	imul	edx, 484				; 000001e4H
	add	edx, DWORD PTR [eax+4068]

; 1036 : 					const CvCity* pkCity = GetCity(ePlayer, pkTestPlot);

	test	edx, edx
	je	SHORT $LN537@FindCloses
	mov	eax, DWORD PTR [edx+104]
	test	eax, eax
	jl	SHORT $LN537@FindCloses
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN537@FindCloses
	mov	ecx, DWORD PTR [edx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	je	SHORT $LN537@FindCloses
	mov	edx, DWORD PTR _ePlayer$[esp+56]
	cmp	DWORD PTR [eax+84], edx
	je	$LN664@FindCloses
$LN537@FindCloses:

; 1037 : 					if(pkCity) return pkCity;
; 1038 : 				}
; 1039 : 
; 1040 : 				if(iPlotY + iDist < iMapHeight)

	mov	eax, DWORD PTR _iDist$224629[esp+60]
	mov	ecx, DWORD PTR _iPlotY$[esp+60]
	add	ecx, eax
	cmp	ecx, DWORD PTR _iMapHeight$[esp+60]
	jge	$LN18@FindCloses

; 1041 : 				{
; 1042 : 					const CvPlot* pkTestPlot = kMap.plot(iX, iPlotY + iDist);

	cmp	esi, -2147483647			; 80000001H
	je	$LN18@FindCloses
	cmp	ecx, -2147483647			; 80000001H
	je	$LN18@FindCloses
	mov	ebx, DWORD PTR _kMap$[esp+60]
	cmp	BYTE PTR [ebx+4056], 0
	mov	ebp, DWORD PTR [ebx+4020]
	je	SHORT $LN650@FindCloses
	test	esi, esi
	jge	SHORT $LN562@FindCloses
	mov	eax, esi
	cdq
	idiv	ebp
	mov	esi, edx
	add	esi, ebp
	jmp	SHORT $LN650@FindCloses
$LN562@FindCloses:
	cmp	esi, ebp
	jl	SHORT $LN650@FindCloses
	mov	eax, esi
	cdq
	idiv	ebp
	mov	esi, edx
$LN650@FindCloses:
	cmp	BYTE PTR [ebx+4057], 0
	mov	edi, DWORD PTR [ebx+4024]
	je	SHORT $LN657@FindCloses
	test	ecx, ecx
	jge	SHORT $LN572@FindCloses
	mov	eax, ecx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN574@FindCloses
$LN572@FindCloses:
	cmp	ecx, edi
	jl	SHORT $LN657@FindCloses
	mov	eax, ecx
	cdq
	idiv	edi
	jmp	SHORT $LN574@FindCloses
$LN657@FindCloses:
	mov	edx, ecx
$LN574@FindCloses:
	test	esi, esi
	jl	SHORT $LN18@FindCloses
	cmp	esi, ebp
	jge	SHORT $LN18@FindCloses
	test	edx, edx
	jl	SHORT $LN18@FindCloses
	cmp	edx, edi
	jge	SHORT $LN18@FindCloses
	imul	edx, ebp
	add	edx, esi
	imul	edx, 484				; 000001e4H
	mov	eax, ebx
	add	edx, DWORD PTR [eax+4068]

; 1043 : 					const CvCity* pkCity = GetCity(ePlayer, pkTestPlot);

	test	edx, edx
	je	SHORT $LN18@FindCloses
	mov	eax, DWORD PTR [edx+104]
	test	eax, eax
	jl	SHORT $LN18@FindCloses
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN18@FindCloses
	mov	ecx, DWORD PTR [edx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	je	SHORT $LN18@FindCloses
	mov	edx, DWORD PTR _ePlayer$[esp+56]
	cmp	DWORD PTR [eax+84], edx
	je	SHORT $LN664@FindCloses
$LN18@FindCloses:

; 1005 : 			for(int iPlot = 0; iPlot < iRowWidth; ++iPlot)

	mov	ecx, DWORD PTR _iPlot$224699[esp+60]
	mov	esi, DWORD PTR tv2037[esp+60]
	mov	eax, DWORD PTR tv1540[esp+60]
	inc	DWORD PTR tv2043[esp+60]
	inc	ecx
	inc	esi
	cmp	ecx, eax
	mov	DWORD PTR _iPlot$224699[esp+60], ecx
	mov	DWORD PTR tv2037[esp+60], esi
	jl	$LL649@FindCloses
$LN61@FindCloses:

; 892  : 
; 893  : 	// Do a search radiating from the search plot
; 894  : 	for(int iDist = 1; iDist < iMapHeight || iDist < iMapWidth; ++iDist)

	mov	ebp, DWORD PTR _kMap$[esp+60]
	mov	ebx, DWORD PTR _iPlotY$[esp+60]
	mov	DWORD PTR _iDist$224629[esp+60], eax
	mov	ecx, eax
	jmp	$LL62@FindCloses
$LN60@FindCloses:

; 1044 : 					if(pkCity) return pkCity;
; 1045 : 				}
; 1046 : 			}
; 1047 : 		}
; 1048 : 	}
; 1049 : 
; 1050 : 	return NULL;

	xor	eax, eax
$LN664@FindCloses:
	pop	edi
	pop	ebp
	pop	ebx
$LN64@FindCloses:
	pop	esi

; 1051 : }

	add	esp, 44					; 0000002cH
	ret	0
?FindClosestCity@@YAPBVCvCity@@W4PlayerTypes@@ABVCvPlot@@@Z ENDP ; FindClosestCity
_TEXT	ENDS
PUBLIC	?ValidateCoast@CvWorldBuilderMapLoader@@SAXXZ	; CvWorldBuilderMapLoader::ValidateCoast
EXTRN	?isAdjacentToLand@CvPlot@@QBE_NXZ:PROC		; CvPlot::isAdjacentToLand
EXTRN	?isWater@CvTerrainInfo@@QBE_NXZ:PROC		; CvTerrainInfo::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?ValidateCoast@CvWorldBuilderMapLoader@@SAXXZ
_TEXT	SEGMENT
_y$225300 = -20						; size = 4
_eCoast$ = -16						; size = 4
_iNumTerrainTypes$ = -12				; size = 4
_iMapWidth$ = -8					; size = 4
_iMapHeight$ = -4					; size = 4
?ValidateCoast@CvWorldBuilderMapLoader@@SAXXZ PROC	; CvWorldBuilderMapLoader::ValidateCoast, COMDAT

; 1857 : {

	sub	esp, 20					; 00000014H
	push	ebp

; 1858 : 	//FTimer kTimer;
; 1859 : 	//kTimer.Start();
; 1860 : 
; 1861 : 	CvMap& kMap = GC.getMap();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	esi

; 1862 : 	const int iMapWidth = kMap.getGridWidth();

	mov	esi, DWORD PTR [ebp+4020]
	push	edi

; 1863 : 	const int iMapHeight = kMap.getGridHeight();

	mov	edi, DWORD PTR [ebp+4024]

; 1864 : 	const int iNumTerrainTypes = GC.getNumTerrainInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iMapWidth$[esp+32], esi
	mov	DWORD PTR _iMapHeight$[esp+32], edi
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	mov	DWORD PTR _iNumTerrainTypes$[esp+32], eax

; 1865 : 	const TerrainTypes eCoast = (TerrainTypes)GC.getSHALLOW_WATER_TERRAIN();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8396
	mov	DWORD PTR _eCoast$[esp+32], eax

; 1866 : 
; 1867 : 	for(int y = 0; y < iMapHeight; ++y)

	xor	eax, eax
	mov	DWORD PTR _y$225300[esp+32], eax
	test	edi, edi
	jle	$LN7@ValidateCo
	push	ebx
$LL70@ValidateCo:

; 1868 : 		for(int x = 0; x < iMapWidth; ++x)

	xor	ebx, ebx
	test	esi, esi
	jle	$LN8@ValidateCo
$LL69@ValidateCo:

; 1869 : 		{
; 1870 : 			CvPlot* pkPlot = kMap.plot(x, y);

	cmp	ebx, -2147483647			; 80000001H
	je	$LN5@ValidateCo
	cmp	eax, -2147483647			; 80000001H
	je	$LN5@ValidateCo
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN30@ValidateCo
	test	ebx, ebx
	jge	SHORT $LN32@ValidateCo
	mov	eax, ebx
	cdq
	idiv	ecx
	mov	eax, DWORD PTR _y$225300[esp+36]
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN34@ValidateCo
$LN32@ValidateCo:
	cmp	ebx, ecx
	jl	SHORT $LN30@ValidateCo
	mov	eax, ebx
	cdq
	idiv	ecx
	mov	eax, DWORD PTR _y$225300[esp+36]
	mov	esi, edx
	jmp	SHORT $LN34@ValidateCo
$LN30@ValidateCo:
	mov	esi, ebx
$LN34@ValidateCo:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN40@ValidateCo
	test	eax, eax
	jge	SHORT $LN42@ValidateCo
	cdq
	idiv	edi
	mov	eax, DWORD PTR _y$225300[esp+36]
	add	edx, edi
	jmp	SHORT $LN44@ValidateCo
$LN42@ValidateCo:
	cmp	eax, edi
	jl	SHORT $LN40@ValidateCo
	cdq
	idiv	edi
	mov	eax, DWORD PTR _y$225300[esp+36]
	jmp	SHORT $LN44@ValidateCo
$LN40@ValidateCo:
	mov	edx, eax
$LN44@ValidateCo:
	test	esi, esi
	jl	SHORT $LN5@ValidateCo
	cmp	esi, ecx
	jge	SHORT $LN5@ValidateCo
	test	edx, edx
	jl	SHORT $LN5@ValidateCo
	cmp	edx, edi
	jge	SHORT $LN5@ValidateCo
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	mov	esi, ecx

; 1871 : 			if(pkPlot != NULL)

	je	SHORT $LN5@ValidateCo

; 1872 : 			{
; 1873 : 				const TerrainTypes eTerrainType = pkPlot->getTerrainType();

	movsx	eax, BYTE PTR [esi+6]

; 1874 : 				if(eTerrainType >= 0 && eTerrainType < iNumTerrainTypes && eTerrainType != eCoast)

	test	eax, eax
	jl	SHORT $LN65@ValidateCo
	cmp	eax, DWORD PTR _iNumTerrainTypes$[esp+36]
	jge	SHORT $LN65@ValidateCo
	cmp	eax, DWORD PTR _eCoast$[esp+36]
	je	SHORT $LN65@ValidateCo

; 1875 : 				{
; 1876 : 					const CvTerrainInfo* pkTerrain = GC.getTerrainInfo(eTerrainType);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo

; 1877 : 					if(pkTerrain != NULL && pkTerrain->isWater() && pkPlot->isAdjacentToLand())

	test	eax, eax
	je	SHORT $LN65@ValidateCo
	mov	ecx, eax
	call	?isWater@CvTerrainInfo@@QBE_NXZ		; CvTerrainInfo::isWater
	test	al, al
	je	SHORT $LN65@ValidateCo
	mov	ecx, esi
	call	?isAdjacentToLand@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentToLand
	test	al, al
	je	SHORT $LN65@ValidateCo

; 1878 : 					{
; 1879 : 						pkPlot->setTerrainType(eCoast);

	mov	ecx, DWORD PTR _eCoast$[esp+36]
	push	1
	push	1
	push	ecx
	mov	ecx, esi
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType
$LN65@ValidateCo:
	mov	eax, DWORD PTR _y$225300[esp+36]
$LN5@ValidateCo:

; 1868 : 		for(int x = 0; x < iMapWidth; ++x)

	mov	esi, DWORD PTR _iMapWidth$[esp+36]
	inc	ebx
	cmp	ebx, esi
	jl	$LL69@ValidateCo
	mov	edi, DWORD PTR _iMapHeight$[esp+36]
$LN8@ValidateCo:

; 1866 : 
; 1867 : 	for(int y = 0; y < iMapHeight; ++y)

	inc	eax
	cmp	eax, edi
	mov	DWORD PTR _y$225300[esp+36], eax
	jl	$LL70@ValidateCo
	pop	ebx
$LN7@ValidateCo:
	pop	edi
	pop	esi
	pop	ebp

; 1880 : 					}
; 1881 : 				}
; 1882 : 			}
; 1883 : 		}
; 1884 : 
; 1885 : 	//kTimer.Stop();
; 1886 : 	//FStringFixedBuffer(sMsg, 64);
; 1887 : 	//sMsg.Format("CvWorldBuilderMapLoader::ValidateCoast() took %fs\n", kTimer.m_fTimer);
; 1888 : 	//OutputDebugStr(sMsg);
; 1889 : }

	add	esp, 20					; 00000014H
	ret	0
?ValidateCoast@CvWorldBuilderMapLoader@@SAXXZ ENDP	; CvWorldBuilderMapLoader::ValidateCoast
_TEXT	ENDS
PUBLIC	??1CvWorldInfo@@QAE@XZ				; CvWorldInfo::~CvWorldInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvWorldInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvWorldInfo@@QAE@XZ PROC				; CvWorldInfo::~CvWorldInfo, COMDAT
; _this$ = ecx
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvWorldInfo@@QAE@XZ ENDP				; CvWorldInfo::~CvWorldInfo
_TEXT	ENDS
PUBLIC	??A?$bitset@$0BAA@@std@@QBE_NI@Z		; std::bitset<256>::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\bitset
;	COMDAT ??A?$bitset@$0BAA@@std@@QBE_NI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$bitset@$0BAA@@std@@QBE_NI@Z PROC			; std::bitset<256>::operator[], COMDAT
; _this$ = ecx

; 82   : 		return (test(_Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	mov	edx, ecx
	cmp	eax, 256				; 00000100H
	jb	SHORT $LN3@operator@6
	call	?_Xran@?$bitset@$0BAA@@std@@ABEXXZ	; std::bitset<256>::_Xran
$LN8@operator@6:
$LN3@operator@6:
	mov	ecx, eax
	push	esi
	and	ecx, 31					; 0000001fH
	mov	esi, 1
	shl	esi, cl
	shr	eax, 5
	test	esi, DWORD PTR [edx+eax*4]
	pop	esi
	setne	al

; 83   : 		}

	ret	4
$LN7@operator@6:
??A?$bitset@$0BAA@@std@@QBE_NI@Z ENDP			; std::bitset<256>::operator[]
_TEXT	ENDS
PUBLIC	??A?$bitset@$0CAA@@std@@QBE_NI@Z		; std::bitset<512>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$bitset@$0CAA@@std@@QBE_NI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$bitset@$0CAA@@std@@QBE_NI@Z PROC			; std::bitset<512>::operator[], COMDAT
; _this$ = ecx

; 82   : 		return (test(_Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	mov	edx, ecx
	cmp	eax, 512				; 00000200H
	jb	SHORT $LN3@operator@7
	call	?_Xran@?$bitset@$0CAA@@std@@ABEXXZ	; std::bitset<512>::_Xran
$LN8@operator@7:
$LN3@operator@7:
	mov	ecx, eax
	push	esi
	and	ecx, 31					; 0000001fH
	mov	esi, 1
	shl	esi, cl
	shr	eax, 5
	test	esi, DWORD PTR [edx+eax*4]
	pop	esi
	setne	al

; 83   : 		}

	ret	4
$LN7@operator@7:
??A?$bitset@$0CAA@@std@@QBE_NI@Z ENDP			; std::bitset<512>::operator[]
_TEXT	ENDS
PUBLIC	?Get@?$FRelationshipBitset@$0GA@$00@@QBE?B_NII@Z ; FRelationshipBitset<96,1>::Get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvworldbuildermap\include\frelationshipbitset.h
;	COMDAT ?Get@?$FRelationshipBitset@$0GA@$00@@QBE?B_NII@Z
_TEXT	SEGMENT
_uiFirst$ = 8						; size = 4
_uiSecond$ = 12						; size = 4
?Get@?$FRelationshipBitset@$0GA@$00@@QBE?B_NII@Z PROC	; FRelationshipBitset<96,1>::Get, COMDAT
; _this$ = ecx

; 38   : 		if( uiFirst == uiSecond )

	mov	eax, DWORD PTR _uiFirst$[esp-4]
	mov	edx, DWORD PTR _uiSecond$[esp-4]
	push	esi
	mov	esi, ecx
	cmp	eax, edx
	jne	SHORT $LN11@Get@2

; 39   : 		{
; 40   : 			return TSelfRelation;

	mov	al, 1
	pop	esi

; 49   : 		}
; 50   : 	}

	ret	8
$LN11@Get@2:

; 41   : 		}
; 42   : 		else
; 43   : 		{
; 44   : 			const uint uiBitIndex = GetBitIndex(uiFirst, uiSecond);

	jbe	SHORT $LN6@Get@2
	mov	ecx, eax
	jmp	SHORT $LN5@Get@2
$LN6@Get@2:
	mov	ecx, edx
	mov	edx, eax
$LN5@Get@2:
	lea	eax, DWORD PTR [ecx-1]
	imul	eax, ecx
	shr	eax, 1
	add	eax, edx

; 45   : 			const uint uiByte = uiBitIndex / 8;
; 46   : 			const uint uiBit = uiBitIndex % 8;

	mov	ecx, eax
	and	ecx, 7

; 47   : 			const byte byMask = (1 << uiBit);

	mov	dl, 1
	shl	dl, cl
	shr	eax, 3

; 48   : 			return (m_Mem[uiByte] & byMask) != 0;

	test	dl, BYTE PTR [eax+esi]
	pop	esi
	setne	al

; 49   : 		}
; 50   : 	}

	ret	8
?Get@?$FRelationshipBitset@$0GA@$00@@QBE?B_NII@Z ENDP	; FRelationshipBitset<96,1>::Get
_TEXT	ENDS
PUBLIC	?Get@?$FRelationshipBitset@$0GA@$0A@@@QBE?B_NII@Z ; FRelationshipBitset<96,0>::Get
; Function compile flags: /Ogtpy
;	COMDAT ?Get@?$FRelationshipBitset@$0GA@$0A@@@QBE?B_NII@Z
_TEXT	SEGMENT
_uiFirst$ = 8						; size = 4
_uiSecond$ = 12						; size = 4
?Get@?$FRelationshipBitset@$0GA@$0A@@@QBE?B_NII@Z PROC	; FRelationshipBitset<96,0>::Get, COMDAT
; _this$ = ecx

; 38   : 		if( uiFirst == uiSecond )

	mov	eax, DWORD PTR _uiFirst$[esp-4]
	mov	edx, DWORD PTR _uiSecond$[esp-4]
	push	esi
	mov	esi, ecx
	cmp	eax, edx
	jne	SHORT $LN11@Get@3

; 39   : 		{
; 40   : 			return TSelfRelation;

	xor	al, al
	pop	esi

; 49   : 		}
; 50   : 	}

	ret	8
$LN11@Get@3:

; 41   : 		}
; 42   : 		else
; 43   : 		{
; 44   : 			const uint uiBitIndex = GetBitIndex(uiFirst, uiSecond);

	jbe	SHORT $LN6@Get@3
	mov	ecx, eax
	jmp	SHORT $LN5@Get@3
$LN6@Get@3:
	mov	ecx, edx
	mov	edx, eax
$LN5@Get@3:
	lea	eax, DWORD PTR [ecx-1]
	imul	eax, ecx
	shr	eax, 1
	add	eax, edx

; 45   : 			const uint uiByte = uiBitIndex / 8;
; 46   : 			const uint uiBit = uiBitIndex % 8;

	mov	ecx, eax
	and	ecx, 7

; 47   : 			const byte byMask = (1 << uiBit);

	mov	dl, 1
	shl	dl, cl
	shr	eax, 3

; 48   : 			return (m_Mem[uiByte] & byMask) != 0;

	test	dl, BYTE PTR [eax+esi]
	pop	esi
	setne	al

; 49   : 		}
; 50   : 	}

	ret	8
?Get@?$FRelationshipBitset@$0GA@$0A@@@QBE?B_NII@Z ENDP	; FRelationshipBitset<96,0>::Get
_TEXT	ENDS
PUBLIC	??0?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@I@Z ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@I@Z
_TEXT	SEGMENT
_uiStartingMaxSize$ = 8					; size = 4
??0?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@I@Z PROC ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 309  : 	FFastVector(unsigned int uiStartingMaxSize = 0)

	push	esi
	xor	eax, eax
	push	edi

; 310  : 	{
; 311  : #ifdef BREAK_ON_REPEATED_RESIZE
; 312  : 		m_nResizeTimes = 0;
; 313  : #endif
; 314  : 		m_pData = Alloc(uiStartingMaxSize);

	mov	edi, DWORD PTR _uiStartingMaxSize$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	cmp	edi, eax
	jbe	SHORT $LN5@FFastVecto
	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
$LN5@FFastVecto:
	mov	DWORD PTR [esi], eax
	pop	edi

; 315  : 	};

	mov	eax, esi
	pop	esi
	ret	4
??0?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@I@Z ENDP ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ PROC ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 317  : 		Free(m_pData, m_uiCurrSize);

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 318  : 	};

	ret	0
??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ ENDP ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	?begin@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@XZ ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@XZ PROC ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@XZ ENDP ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@XZ ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@XZ PROC ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@XZ ENDP ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::end
_TEXT	ENDS
PUBLIC	??1FStringW@@QAE@XZ				; FStringW::~FStringW
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstringw.inl
;	COMDAT ??1FStringW@@QAE@XZ
_TEXT	SEGMENT
??1FStringW@@QAE@XZ PROC				; FStringW::~FStringW, COMDAT
; _this$ = ecx

; 151  : {

	push	esi
	push	edi
	mov	edi, ecx

; 152  : 	Release();

	mov	esi, DWORD PTR [edi]
	sub	esi, 12					; 0000000cH
	je	SHORT $LN7@FStringW
	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData
	cmp	esi, eax
	je	SHORT $LN7@FStringW
	cmp	WORD PTR [esi+10], 0
	jne	SHORT $LN7@FStringW
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN7@FStringW:
	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi

; 153  : }

	ret	0
??1FStringW@@QAE@XZ ENDP				; FStringW::~FStringW
_TEXT	ENDS
PUBLIC	?GrowSize@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@IAEXI@Z ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@IAEXI@Z PROC ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR [esi+8]
	push	edi
	mov	ebp, eax

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	test	eax, eax
	jne	SHORT $LN34@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN34@GrowSize:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+12]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN9@GrowSize
	npad	1
$LL10@GrowSize:

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN37@GrowSize

; 433  : 				break;
; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL10@GrowSize

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN9@GrowSize
$LN37@GrowSize:

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN9@GrowSize:

; 438  : 		}
; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	jbe	SHORT $LN7@GrowSize
	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	ebx, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi

; 441  : 		if (pTemp)

	test	ebx, ebx
	je	SHORT $LN7@GrowSize

; 442  : 		{
; 443  : 			if( bPODType ){
; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 445  : 			}else{
; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	eax, eax
	cmp	DWORD PTR [esi+4], eax
	jbe	SHORT $LN2@GrowSize
	mov	ecx, ebx
$LL4@GrowSize:

; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);

	test	ecx, ecx
	je	SHORT $LN3@GrowSize
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx], edx
$LN3@GrowSize:
	inc	eax
	add	ecx, 4
	cmp	eax, DWORD PTR [esi+4]
	jb	SHORT $LL4@GrowSize
$LN2@GrowSize:

; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	pop	edi

; 450  : 			m_pData = pTemp;

	mov	DWORD PTR [esi], ebx
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
$LN7@GrowSize:
	pop	edi

; 451  : 		}
; 452  : 		else
; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	DWORD PTR [esi+8], ebp
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
?GrowSize@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@IAEXI@Z ENDP ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::GrowSize
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QBE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@@Z ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QBE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QBE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@@Z PROC ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QBE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@@Z ENDP ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Make_iter
_TEXT	ENDS
PUBLIC	??0?$FStringWFixedBuffer@$0BAE@@FStringW@@QAE@AAV1@@Z ; FStringW::FStringWFixedBuffer<260>::FStringWFixedBuffer<260>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstringw.inl
;	COMDAT ??0?$FStringWFixedBuffer@$0BAE@@FStringW@@QAE@AAV1@@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
??0?$FStringWFixedBuffer@$0BAE@@FStringW@@QAE@AAV1@@Z PROC ; FStringW::FStringWFixedBuffer<260>::FStringWFixedBuffer<260>, COMDAT
; _this$ = ecx

; 58   : {

	push	ebx
	push	ebp

; 59   : 	assert( nLENGTH > 0 );
; 60   : 	m_kStringData.m_bLocked = 0;
; 61   : 	m_kStringData.m_bFixed = 1;
; 62   : 	m_kStringData.m_iAllocLength = nLENGTH;
; 63   : 	m_kStringData.m_iDataLength = 0;
; 64   : 	m_szStringBuffer[ 0 ] = 0;
; 65   : 	str.SetFixedBuffer( &m_kStringData );

	mov	ebp, DWORD PTR _str$[esp+4]
	push	esi
	mov	esi, ecx
	xor	eax, eax
	xor	edx, edx
	mov	ecx, 1
	lea	ebx, DWORD PTR [esi+12]
	push	edi
	mov	WORD PTR [esi+8], ax
	mov	WORD PTR [esi+10], cx
	mov	DWORD PTR [esi], 260			; 00000104H
	mov	DWORD PTR [esi+4], eax
	mov	WORD PTR [ebx], dx
	mov	edi, DWORD PTR [ebp]
	sub	edi, 12					; 0000000cH
	je	SHORT $LN10@FStringWFi
	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData
	cmp	edi, eax
	je	SHORT $LN10@FStringWFi
	cmp	WORD PTR [edi+10], 0
	jne	SHORT $LN10@FStringWFi
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN10@FStringWFi:
	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData
	pop	edi

; 66   : }

	mov	eax, esi
	pop	esi
	mov	DWORD PTR [ebp], ebx
	pop	ebp
	pop	ebx
	ret	4
??0?$FStringWFixedBuffer@$0BAE@@FStringW@@QAE@AAV1@@Z ENDP ; FStringW::FStringWFixedBuffer<260>::FStringWFixedBuffer<260>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@YAXPAVString@CvWorldBuilderMapTypeDesc@@0AAV?$allocator@VString@CvWorldBuilderMapTypeDesc@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvWorldBuilderMapTypeDesc::String> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@YAXPAVString@CvWorldBuilderMapTypeDesc@@0AAV?$allocator@VString@CvWorldBuilderMapTypeDesc@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@YAXPAVString@CvWorldBuilderMapTypeDesc@@0AAV?$allocator@VString@CvWorldBuilderMapTypeDesc@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvWorldBuilderMapTypeDesc::String> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@YAXPAVString@CvWorldBuilderMapTypeDesc@@0AAV?$allocator@VString@CvWorldBuilderMapTypeDesc@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvWorldBuilderMapTypeDesc::String> >
_TEXT	ENDS
PUBLIC	?SetPlayerInitialItems@@YAXAAVCvPlayer@@ABUPlayer@CvWorldBuilderMap@@@Z ; SetPlayerInitialItems
EXTRN	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z:PROC ; CvTeam::setHasTech
EXTRN	?GetEra@CvTechEntry@@QBEHXZ:PROC		; CvTechEntry::GetEra
EXTRN	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z:PROC ; CvGlobals::getTechInfo
EXTRN	?getNumTechInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumTechInfos
EXTRN	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z:PROC ; CvGlobals::getEraInfo
EXTRN	?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z:PROC ; CvPlayerPolicies::SetPolicyBranchUnlocked
EXTRN	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z:PROC ; CvPlayerPolicies::IsPolicyBranchUnlocked
EXTRN	?getNumEraInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumEraInfos
EXTRN	?setHasPolicy@CvPlayer@@QAEXW4PolicyTypes@@_N@Z:PROC ; CvPlayer::setHasPolicy
EXTRN	?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ:PROC	; CvPolicyBranchEntry::GetFreePolicy
EXTRN	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z:PROC ; CvGlobals::getPolicyBranchInfo
EXTRN	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPolicyBranchInfos
EXTRN	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ:PROC	; CvPolicyEntry::GetPolicyBranchType
EXTRN	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z:PROC ; CvGlobals::getPolicyInfo
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
EXTRN	?getNumPolicyInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPolicyInfos
EXTRN	?setJONSCulture@CvPlayer@@QAEXH@Z:PROC		; CvPlayer::setJONSCulture
EXTRN	?SetGold@CvTreasury@@QAEXH@Z:PROC		; CvTreasury::SetGold
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
;	COMDAT ?SetPlayerInitialItems@@YAXAAVCvPlayer@@ABUPlayer@CvWorldBuilderMap@@@Z
_TEXT	SEGMENT
_kTeam$224433 = -4					; size = 4
_iPolicyCount$ = -4					; size = 4
_kGameplayPlayer$ = 8					; size = 4
_kSavedPlayer$ = 12					; size = 4
?SetPlayerInitialItems@@YAXAAVCvPlayer@@ABUPlayer@CvWorldBuilderMap@@@Z PROC ; SetPlayerInitialItems, COMDAT

; 494  : {

	push	ecx
	push	ebx

; 495  : 	CvTreasury* pkTreasury = kGameplayPlayer.GetTreasury();

	mov	ebx, DWORD PTR _kGameplayPlayer$[esp+4]
	push	ebp
	push	esi
	push	edi
	mov	ecx, ebx
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury

; 496  : 	FAssertMsg(pkTreasury, "Unable to set gold amount.  Treasury Missing!");
; 497  : 	if(pkTreasury != NULL)

	test	eax, eax
	je	SHORT $LN67@SetPlayerI

; 498  : 		pkTreasury->SetGold(kSavedPlayer.m_uiGold);

	mov	ecx, DWORD PTR _kSavedPlayer$[esp+16]
	mov	edx, DWORD PTR [ecx+420]
	push	edx
	mov	ecx, eax
	call	?SetGold@CvTreasury@@QAEXH@Z		; CvTreasury::SetGold
$LN67@SetPlayerI:

; 499  : 
; 500  : 	kGameplayPlayer.setJONSCulture(kSavedPlayer.m_uiCulture);

	mov	esi, DWORD PTR _kSavedPlayer$[esp+16]
	mov	eax, DWORD PTR [esi+416]
	push	eax
	mov	ecx, ebx
	call	?setJONSCulture@CvPlayer@@QAEXH@Z	; CvPlayer::setJONSCulture

; 501  : 
; 502  : #ifdef AUI_WARNING_FIXES
; 503  : 	for (uint iPolicy = 0; iPolicy < GC.getNumPolicyInfos(); ++iPolicy)
; 504  : #else
; 505  : 	const int iPolicyCount = GC.getNumPolicyInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos

; 506  : 	for(int iPolicy = 0; iPolicy < iPolicyCount; ++iPolicy)

	xor	edi, edi
	mov	DWORD PTR _iPolicyCount$[esp+20], eax
	test	eax, eax
	jle	$LN21@SetPlayerI
$LL23@SetPlayerI:

; 507  : #endif
; 508  : 	{
; 509  : 		const PolicyTypes ePolicy = (PolicyTypes)iPolicy;
; 510  : 		if(kSavedPlayer.m_kPolicies[iPolicy])

	cmp	edi, 256				; 00000100H
	jae	$LN56@SetPlayerI
	mov	ecx, edi
	and	ecx, 31					; 0000001fH
	mov	edx, 1
	shl	edx, cl
	mov	ecx, edi
	shr	ecx, 5
	test	edx, DWORD PTR [esi+ecx*4]
	je	SHORT $LN22@SetPlayerI

; 511  : 		{
; 512  : 			// Check the policy branch
; 513  : 			CvPlayerPolicies* pkPlayerPolicies = kGameplayPlayer.GetPlayerPolicies();

	mov	ecx, ebx
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies

; 514  : 			const CvPolicyEntry* pkPolicy = GC.getPolicyInfo(ePolicy);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebp, eax
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo

; 515  : 			if(pkPolicy != NULL && pkPlayerPolicies != NULL)

	test	eax, eax
	je	SHORT $LN70@SetPlayerI
	test	ebp, ebp
	je	SHORT $LN70@SetPlayerI

; 516  : 			{
; 517  : 				PolicyBranchTypes ePolicyBranch = (PolicyBranchTypes)pkPolicy->GetPolicyBranchType();

	mov	ecx, eax
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	mov	esi, eax

; 518  : 
; 519  : 				// NO_POLICY_BRANCH_TYPE means that this is probably a free policy.
; 520  : 				// We'll have to look through the policy branches to find a matching one.
; 521  : 				if(ePolicyBranch == NO_POLICY_BRANCH_TYPE)

	cmp	esi, -1
	jne	$LN62@SetPlayerI

; 522  : 				{
; 523  : 					const int iPolicyBranchCount = GC.getNumPolicyBranchInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos
	mov	ebx, eax

; 524  : 					for(int iPolicyBranch = 0; iPolicyBranch < iPolicyBranchCount; ++iPolicyBranch)

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN68@SetPlayerI
$LL17@SetPlayerI:

; 525  : 					{
; 526  : 						const PolicyBranchTypes eCurrentBranch = (PolicyBranchTypes)iPolicyBranch;
; 527  : 						const CvPolicyBranchEntry* pkBranch = GC.getPolicyBranchInfo(eCurrentBranch);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo

; 528  : 						if(pkBranch != NULL && pkBranch->GetFreePolicy() == ePolicy)

	test	eax, eax
	je	SHORT $LN16@SetPlayerI
	mov	ecx, eax
	call	?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFreePolicy
	cmp	eax, edi
	je	SHORT $LN55@SetPlayerI
$LN16@SetPlayerI:

; 524  : 					for(int iPolicyBranch = 0; iPolicyBranch < iPolicyBranchCount; ++iPolicyBranch)

	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL17@SetPlayerI
$LN68@SetPlayerI:

; 548  : 							kGameplayPlayer.setHasPolicy(eFreePolicy, true);

	mov	ebx, DWORD PTR _kGameplayPlayer$[esp+16]
$LN70@SetPlayerI:

; 549  : 					}
; 550  : 				}
; 551  : 			}
; 552  : 
; 553  : 			// Finally, unlock the policy
; 554  : 			kGameplayPlayer.setHasPolicy(ePolicy, true);

	push	1
	push	edi
	mov	ecx, ebx
	call	?setHasPolicy@CvPlayer@@QAEXW4PolicyTypes@@_N@Z ; CvPlayer::setHasPolicy
	mov	esi, DWORD PTR _kSavedPlayer$[esp+16]
	mov	eax, DWORD PTR _iPolicyCount$[esp+20]
$LN22@SetPlayerI:
	inc	edi
	cmp	edi, eax
	jl	$LL23@SetPlayerI
$LN21@SetPlayerI:

; 555  : 		}
; 556  : 	}
; 557  : 
; 558  : 	const TeamTypes eTeam = kGameplayPlayer.getTeam();

	mov	eax, DWORD PTR [ebx+44]
	cmp	eax, 63					; 0000003fH
	ja	$LN2@SetPlayerI
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]

; 559  : 	if(eTeam != NO_TEAM)

	cmp	eax, -1
	je	$LN2@SetPlayerI

; 560  : 	{
; 561  : 		CvTeam& kTeam = GET_TEAM(eTeam);

	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 562  : 
; 563  : 		int iStartingEra = 0;
; 564  : #ifdef AUI_WARNING_FIXES
; 565  : 		for (uint iEra = 0; iEra < GC.getNumEraInfos(); ++iEra)
; 566  : #else
; 567  : 		const int iEraCount = GC.getNumEraInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _kTeam$224433[esp+20], eax
	call	?getNumEraInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumEraInfos
	mov	edi, eax

; 568  : 		for(int iEra = 0; iEra < iEraCount; ++iEra)

	xor	ebp, ebp
	test	edi, edi
	jle	$LN2@SetPlayerI
	jmp	SHORT $LN9@SetPlayerI
$LN55@SetPlayerI:

; 529  : 						{
; 530  : 							ePolicyBranch = eCurrentBranch;
; 531  : 							break;
; 532  : 						}
; 533  : 					}
; 534  : 				}
; 535  : 
; 536  : 				// Unlock the policy branch if it hasn't been unlocked yet
; 537  : 				if(ePolicyBranch != NO_POLICY_BRANCH_TYPE &&
; 538  : 				        !pkPlayerPolicies->IsPolicyBranchUnlocked(ePolicyBranch))

	cmp	esi, -1
	je	SHORT $LN68@SetPlayerI
	mov	ebx, DWORD PTR _kGameplayPlayer$[esp+16]
$LN62@SetPlayerI:
	push	esi
	mov	ecx, ebp
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	test	al, al
	jne	SHORT $LN70@SetPlayerI

; 539  : 				{
; 540  : 					pkPlayerPolicies->SetPolicyBranchUnlocked(ePolicyBranch, true, false);

	push	0
	push	1
	push	esi
	mov	ecx, ebp
	call	?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z ; CvPlayerPolicies::SetPolicyBranchUnlocked

; 541  : 
; 542  : 					// Also, unlock the free policy for the branch
; 543  : 					const CvPolicyBranchEntry* pkBranch = GC.getPolicyBranchInfo(ePolicyBranch);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo

; 544  : 					if(pkBranch != NULL)

	test	eax, eax
	je	$LN70@SetPlayerI

; 545  : 					{
; 546  : 						PolicyTypes eFreePolicy = (PolicyTypes)pkBranch->GetFreePolicy();

	mov	ecx, eax
	call	?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFreePolicy

; 547  : 						if(eFreePolicy != NO_POLICY)

	cmp	eax, -1
	je	$LN70@SetPlayerI

; 548  : 							kGameplayPlayer.setHasPolicy(eFreePolicy, true);

	push	1
	push	eax
	mov	ecx, ebx
	call	?setHasPolicy@CvPlayer@@QAEXW4PolicyTypes@@_N@Z ; CvPlayer::setHasPolicy
	jmp	$LN70@SetPlayerI
$LN56@SetPlayerI:

; 507  : #endif
; 508  : 	{
; 509  : 		const PolicyTypes ePolicy = (PolicyTypes)iPolicy;
; 510  : 		if(kSavedPlayer.m_kPolicies[iPolicy])

	mov	ecx, esi
	call	?_Xran@?$bitset@$0BAA@@std@@ABEXXZ	; std::bitset<256>::_Xran
$LN73@SetPlayerI:
$LL71@SetPlayerI:

; 568  : 		for(int iEra = 0; iEra < iEraCount; ++iEra)

	mov	esi, DWORD PTR _kSavedPlayer$[esp+16]
$LN9@SetPlayerI:

; 569  : #endif
; 570  : 		{
; 571  : 			const EraTypes eEra = (EraTypes)iEra;
; 572  : 			const CvEraInfo* pkEra = GC.getEraInfo(eEra);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo

; 573  : 			if(pkEra != NULL && strcmp(pkEra->GetType(), kSavedPlayer.m_szEra) == 0)

	test	eax, eax
	je	SHORT $LN8@SetPlayerI
	lea	ecx, DWORD PTR [eax+176]
	add	esi, 288				; 00000120H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LL63@SetPlayerI:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN64@SetPlayerI
	test	cl, cl
	je	SHORT $LN65@SetPlayerI
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN64@SetPlayerI
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL63@SetPlayerI
$LN65@SetPlayerI:
	xor	eax, eax
	jmp	SHORT $LN66@SetPlayerI
$LN64@SetPlayerI:
	sbb	eax, eax
	sbb	eax, -1
$LN66@SetPlayerI:
	test	eax, eax
	je	SHORT $LN57@SetPlayerI
$LN8@SetPlayerI:

; 568  : 		for(int iEra = 0; iEra < iEraCount; ++iEra)

	inc	ebp
	cmp	ebp, edi
	jl	SHORT $LL71@SetPlayerI
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 593  : 			}
; 594  : 		}
; 595  : 	}
; 596  : }

	pop	ecx
	ret	0
$LN57@SetPlayerI:

; 574  : 			{
; 575  : 				iStartingEra = iEra;
; 576  : 				break;
; 577  : 			}
; 578  : 		}
; 579  : 
; 580  : 		if(iStartingEra > 0)

	test	ebp, ebp
	jle	SHORT $LN2@SetPlayerI

; 581  : 		{
; 582  : #ifdef AUI_WARNING_FIXES
; 583  : 			for (uint iTech = 0; iTech < GC.getNumTechInfos(); ++iTech)
; 584  : #else
; 585  : 			const int iTechCount = GC.getNumTechInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	mov	edi, eax

; 586  : 			for(int iTech = 0; iTech < iTechCount; ++iTech)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN2@SetPlayerI
$LL4@SetPlayerI:

; 587  : #endif
; 588  : 			{
; 589  : 				const TechTypes eTech = (TechTypes)iTech;
; 590  : 				const CvTechEntry* pkTech = GC.getTechInfo(eTech);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo

; 591  : 				if(pkTech != NULL && pkTech->GetEra() < iStartingEra)

	test	eax, eax
	je	SHORT $LN3@SetPlayerI
	mov	ecx, eax
	call	?GetEra@CvTechEntry@@QBEHXZ		; CvTechEntry::GetEra
	cmp	eax, ebp
	jge	SHORT $LN3@SetPlayerI

; 592  : 					kTeam.setHasTech(eTech, true, kGameplayPlayer.GetID(), false, false);

	mov	edx, DWORD PTR [ebx+44]
	mov	ecx, DWORD PTR _kTeam$224433[esp+20]
	push	0
	push	0
	push	edx
	push	1
	push	esi
	call	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ; CvTeam::setHasTech
$LN3@SetPlayerI:
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL4@SetPlayerI
$LN2@SetPlayerI:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 593  : 			}
; 594  : 		}
; 595  : 	}
; 596  : }

	pop	ecx
	ret	0
$LN72@SetPlayerI:
?SetPlayerInitialItems@@YAXAAVCvPlayer@@ABUPlayer@CvWorldBuilderMap@@@Z ENDP ; SetPlayerInitialItems
_TEXT	ENDS
PUBLIC	?SetTeamInitialItems@@YAXAAVCvTeam@@ABUTeam@CvWorldBuilderMap@@@Z ; SetTeamInitialItems
; Function compile flags: /Ogtpy
;	COMDAT ?SetTeamInitialItems@@YAXAAVCvTeam@@ABUTeam@CvWorldBuilderMap@@@Z
_TEXT	SEGMENT
_kGameplayTeam$ = 8					; size = 4
_kSavedTeam$ = 12					; size = 4
?SetTeamInitialItems@@YAXAAVCvTeam@@ABUTeam@CvWorldBuilderMap@@@Z PROC ; SetTeamInitialItems, COMDAT

; 599  : {

	push	ebp
	push	esi

; 600  : #ifdef AUI_WARNING_FIXES
; 601  : 	for (uint iTech = 0; iTech < GC.getNumTechInfos(); ++iTech)
; 602  : #else
; 603  : 	const int iTechCount = GC.getNumTechInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	mov	ebp, eax

; 604  : 	for(int iTech = 0; iTech < iTechCount; ++iTech)

	xor	esi, esi
	test	ebp, ebp
	jle	SHORT $LN2@SetTeamIni
	push	ebx
	mov	ebx, DWORD PTR _kSavedTeam$[esp+8]
	push	edi

; 605  : #endif
; 606  : 	{
; 607  : 		const TechTypes eTech = (TechTypes)iTech;
; 608  : 		if(kSavedTeam.m_kTechs[iTech])

	mov	edi, DWORD PTR _kGameplayTeam$[esp+12]
	add	ebx, 32					; 00000020H
$LL17@SetTeamIni:
	cmp	esi, 256				; 00000100H
	jae	SHORT $LN15@SetTeamIni
	mov	ecx, esi
	and	ecx, 31					; 0000001fH
	mov	eax, 1
	shl	eax, cl
	mov	ecx, esi
	shr	ecx, 5
	test	eax, DWORD PTR [ebx+ecx*4]
	je	SHORT $LN3@SetTeamIni

; 609  : 			kGameplayTeam.setHasTech(eTech, true, NO_PLAYER, false, false);

	push	0
	push	0
	push	-1
	push	1
	push	esi
	mov	ecx, edi
	call	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ; CvTeam::setHasTech
$LN3@SetTeamIni:
	inc	esi
	cmp	esi, ebp
	jl	SHORT $LL17@SetTeamIni
	pop	edi
	pop	ebx
$LN2@SetTeamIni:
	pop	esi
	pop	ebp

; 610  : 	}
; 611  : }

	ret	0
$LN15@SetTeamIni:
	mov	ecx, ebx
	call	?_Xran@?$bitset@$0BAA@@std@@ABEXXZ	; std::bitset<256>::_Xran
$LN21@SetTeamIni:
$LN20@SetTeamIni:
	int	3
?SetTeamInitialItems@@YAXAAVCvTeam@@ABUTeam@CvWorldBuilderMap@@@Z ENDP ; SetTeamInitialItems
_TEXT	ENDS
PUBLIC	?SetInitialItems@CvWorldBuilderMapLoader@@SAX_N@Z ; CvWorldBuilderMapLoader::SetInitialItems
EXTRN	?DoUpdateHappiness@CvPlayer@@QAEXXZ:PROC	; CvPlayer::DoUpdateHappiness
EXTRN	?DoGold@CvTreasury@@QAEXXZ:PROC			; CvTreasury::DoGold
EXTRN	?DoUpdateCityConnectionGold@CvTreasury@@QAEXXZ:PROC ; CvTreasury::DoUpdateCityConnectionGold
EXTRN	?Update@CvCityConnections@@QAEXXZ:PROC		; CvCityConnections::Update
EXTRN	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ:PROC ; CvPlayer::GetCityConnections
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?DoTurn@CvCityCitizens@@QAEXXZ:PROC		; CvCityCitizens::DoTurn
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
; Function compile flags: /Ogtpy
;	COMDAT ?SetInitialItems@CvWorldBuilderMapLoader@@SAX_N@Z
_TEXT	SEGMENT
$T230383 = -6						; size = 1
$T230381 = -6						; size = 1
$T230378 = -6						; size = 1
$T230382 = -5						; size = 1
$T230380 = -5						; size = 1
$T230379 = -5						; size = 1
_iLoop$224492 = -4					; size = 4
_bFirstCall$ = 8					; size = 1
?SetInitialItems@CvWorldBuilderMapLoader@@SAX_N@Z PROC	; CvWorldBuilderMapLoader::SetInitialItems, COMDAT

; 614  : {

	sub	esp, 8

; 615  : #ifdef AUI_WARNING_FIXES
; 616  : 	const byte uiTeamCount = MIN(sg_kSave.GetTeamCount(), (byte)MAX_TEAMS);
; 617  : 	for (byte i = 0; i < uiTeamCount; ++i)
; 618  : #else
; 619  : 	const uint uiTeamCount = std::min(sg_kSave.GetTeamCount(), (byte)MAX_TEAMS);

	mov	cl, BYTE PTR _sg_kSave+12318
	mov	BYTE PTR $T230378[esp+8], 64		; 00000040H
	mov	BYTE PTR $T230379[esp+8], cl
	lea	eax, DWORD PTR $T230378[esp+8]
	cmp	cl, 64					; 00000040H
	ja	SHORT $LN21@SetInitial
	lea	eax, DWORD PTR $T230379[esp+8]
$LN21@SetInitial:
	push	ebx
	push	esi
	push	edi
	movzx	edi, BYTE PTR [eax]

; 620  : 	for(uint i = 0; i < uiTeamCount; ++i)

	xor	ebx, ebx
	test	edi, edi
	jbe	SHORT $LN11@SetInitial

; 615  : #ifdef AUI_WARNING_FIXES
; 616  : 	const byte uiTeamCount = MIN(sg_kSave.GetTeamCount(), (byte)MAX_TEAMS);
; 617  : 	for (byte i = 0; i < uiTeamCount; ++i)
; 618  : #else
; 619  : 	const uint uiTeamCount = std::min(sg_kSave.GetTeamCount(), (byte)MAX_TEAMS);

	xor	esi, esi
	jmp	SHORT $LN13@SetInitial
	npad	1
$LL60@SetInitial:
	mov	cl, BYTE PTR _sg_kSave+12318
$LN13@SetInitial:

; 621  : #endif
; 622  : 	{
; 623  : 		const TeamTypes eTeam = (TeamTypes)i;
; 624  : 		SetTeamInitialItems(GET_TEAM(eTeam), sg_kSave.GetTeam(i));

	cmp	bl, cl
	jae	SHORT $LN23@SetInitial
	cmp	bl, 96					; 00000060H
	jae	SHORT $LN23@SetInitial
	movzx	eax, bl
	shl	eax, 6
	add	eax, OFFSET _sg_kSave+578464
	jmp	SHORT $LN22@SetInitial
$LN23@SetInitial:
	mov	eax, OFFSET ?sm_kErrorTeam@CvWorldBuilderMap@@0UTeam@1@A ; CvWorldBuilderMap::sm_kErrorTeam
$LN22@SetInitial:
	push	eax
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [esi+eax]
	push	ecx
	call	?SetTeamInitialItems@@YAXAAVCvTeam@@ABUTeam@CvWorldBuilderMap@@@Z ; SetTeamInitialItems
	inc	ebx
	add	esp, 8
	add	esi, 2980				; 00000ba4H
	cmp	ebx, edi
	jb	SHORT $LL60@SetInitial
$LN11@SetInitial:

; 625  : 	}
; 626  : 
; 627  : #ifdef AUI_WARNING_FIXES
; 628  : 	const byte uiPlayerCount = MIN(sg_kSave.GetPlayerCount(), (byte)MAX_CIV_PLAYERS);
; 629  : 	for (byte i = 0; i < uiPlayerCount; ++i)
; 630  : #else
; 631  : 	const uint uiPlayerCount = std::min(sg_kSave.GetPlayerCount(), (byte)MAX_CIV_PLAYERS);

	mov	cl, BYTE PTR _sg_kSave+12316
	mov	BYTE PTR $T230380[esp+20], 63		; 0000003fH
	mov	BYTE PTR $T230381[esp+20], cl
	lea	eax, DWORD PTR $T230380[esp+20]
	cmp	cl, 63					; 0000003fH
	ja	SHORT $LN33@SetInitial
	lea	eax, DWORD PTR $T230381[esp+20]
$LN33@SetInitial:
	push	ebp
	movzx	ebp, BYTE PTR [eax]

; 632  : 	for(uint i = 0; i < uiPlayerCount; ++i)

	xor	ebx, ebx
	test	ebp, ebp
	jbe	$LN8@SetInitial

; 625  : 	}
; 626  : 
; 627  : #ifdef AUI_WARNING_FIXES
; 628  : 	const byte uiPlayerCount = MIN(sg_kSave.GetPlayerCount(), (byte)MAX_CIV_PLAYERS);
; 629  : 	for (byte i = 0; i < uiPlayerCount; ++i)
; 630  : #else
; 631  : 	const uint uiPlayerCount = std::min(sg_kSave.GetPlayerCount(), (byte)MAX_CIV_PLAYERS);

	xor	edi, edi
	jmp	SHORT $LN10@SetInitial
	npad	4
$LL61@SetInitial:
	mov	cl, BYTE PTR _sg_kSave+12316
$LN10@SetInitial:

; 633  : #endif
; 634  : 	{
; 635  : 		const PlayerTypes ePlayer = (PlayerTypes)i;
; 636  : 		CvPlayer& kPlayer = GET_PLAYER(ePlayer);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	esi, DWORD PTR [edi+edx]

; 637  : 		SetPlayerInitialItems(kPlayer, sg_kSave.GetPlayer(i));

	cmp	bl, cl
	jae	SHORT $LN37@SetInitial
	cmp	bl, 32					; 00000020H
	jae	SHORT $LN37@SetInitial
	movzx	eax, bl
	imul	eax, 436				; 000001b4H
	add	eax, OFFSET _sg_kSave+536608
	jmp	SHORT $LN36@SetInitial
$LN37@SetInitial:
	mov	eax, OFFSET ?sm_kErrorPlayer@CvWorldBuilderMap@@0UPlayer@1@A ; CvWorldBuilderMap::sm_kErrorPlayer
$LN36@SetInitial:
	push	eax
	push	esi
	call	?SetPlayerInitialItems@@YAXAAVCvPlayer@@ABUPlayer@CvWorldBuilderMap@@@Z ; SetPlayerInitialItems
	add	esp, 8

; 638  : 
; 639  : 		if(!bFirstCall)

	cmp	BYTE PTR _bFirstCall$[esp+20], 0
	jne	SHORT $LN9@SetInitial

; 640  : 		{
; 641  : 			// Assign all citizens
; 642  : 			CvCity* pLoopCity;
; 643  : 			int iLoop;
; 644  : 			for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$224492[esp+28]
	push	eax
	mov	ecx, esi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN4@SetInitial
$LL6@SetInitial:

; 645  : 			{
; 646  : 				pLoopCity->GetCityCitizens()->DoTurn();

	mov	ecx, eax
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?DoTurn@CvCityCitizens@@QAEXXZ		; CvCityCitizens::DoTurn
	push	0
	lea	ecx, DWORD PTR _iLoop$224492[esp+28]
	push	ecx
	mov	ecx, esi
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL6@SetInitial
$LN4@SetInitial:

; 647  : 			}
; 648  : 
; 649  : 			// Update player data
; 650  : 			kPlayer.GetCityConnections()->Update();

	mov	ecx, esi
	call	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ ; CvPlayer::GetCityConnections
	mov	ecx, eax
	call	?Update@CvCityConnections@@QAEXXZ	; CvCityConnections::Update

; 651  : 			kPlayer.GetTreasury()->DoUpdateCityConnectionGold();

	mov	ecx, esi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?DoUpdateCityConnectionGold@CvTreasury@@QAEXXZ ; CvTreasury::DoUpdateCityConnectionGold

; 652  : 			kPlayer.GetTreasury()->DoGold();

	mov	ecx, esi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?DoGold@CvTreasury@@QAEXXZ		; CvTreasury::DoGold

; 653  : 			kPlayer.DoUpdateHappiness();

	mov	ecx, esi
	call	?DoUpdateHappiness@CvPlayer@@QAEXXZ	; CvPlayer::DoUpdateHappiness
$LN9@SetInitial:
	inc	ebx
	add	edi, 63236				; 0000f704H
	cmp	ebx, ebp
	jb	$LL61@SetInitial
$LN8@SetInitial:

; 654  : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 655  : 			kPlayer.doSelfConsistencyCheckAllCities();
; 656  : #endif
; 657  : 		}
; 658  : 	}
; 659  : 
; 660  : #ifdef AUI_WARNING_FIXES
; 661  : 	const byte uiCityStateCount = MIN(sg_kSave.GetCityStateCount(), (byte)MAX_MINOR_CIVS);
; 662  : 	for (byte i = 0; i < uiCityStateCount; ++i)
; 663  : #else
; 664  : 	const uint uiCityStateCount = std::min(sg_kSave.GetCityStateCount(), (byte)MAX_MINOR_CIVS);

	mov	cl, BYTE PTR _sg_kSave+12317
	mov	BYTE PTR $T230382[esp+24], 41		; 00000029H
	mov	BYTE PTR $T230383[esp+24], cl
	pop	ebp
	lea	eax, DWORD PTR $T230382[esp+20]
	cmp	cl, 41					; 00000029H
	ja	SHORT $LN45@SetInitial
	lea	eax, DWORD PTR $T230383[esp+20]
$LN45@SetInitial:
	movzx	edi, BYTE PTR [eax]

; 665  : 	for(uint i = 0; i < uiCityStateCount; ++i)

	xor	ebx, ebx
	test	edi, edi
	jbe	SHORT $LN1@SetInitial

; 654  : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 655  : 			kPlayer.doSelfConsistencyCheckAllCities();
; 656  : #endif
; 657  : 		}
; 658  : 	}
; 659  : 
; 660  : #ifdef AUI_WARNING_FIXES
; 661  : 	const byte uiCityStateCount = MIN(sg_kSave.GetCityStateCount(), (byte)MAX_MINOR_CIVS);
; 662  : 	for (byte i = 0; i < uiCityStateCount; ++i)
; 663  : #else
; 664  : 	const uint uiCityStateCount = std::min(sg_kSave.GetCityStateCount(), (byte)MAX_MINOR_CIVS);

	mov	esi, 1391192				; 00153a58H
	jmp	SHORT $LN3@SetInitial
	npad	3
$LL62@SetInitial:
	mov	cl, BYTE PTR _sg_kSave+12317
$LN3@SetInitial:

; 666  : #endif
; 667  : 	{
; 668  : 		const PlayerTypes ePlayer = (PlayerTypes)(i + MAX_MAJOR_CIVS);
; 669  : 		SetPlayerInitialItems(GET_PLAYER(ePlayer), sg_kSave.GetCityState(i));

	cmp	bl, cl
	jae	SHORT $LN47@SetInitial
	cmp	bl, 64					; 00000040H
	jae	SHORT $LN47@SetInitial
	movzx	eax, bl
	imul	eax, 436				; 000001b4H
	add	eax, OFFSET _sg_kSave+550560
	jmp	SHORT $LN46@SetInitial
$LN47@SetInitial:
	mov	eax, OFFSET ?sm_kErrorPlayer@CvWorldBuilderMap@@0UPlayer@1@A ; CvWorldBuilderMap::sm_kErrorPlayer
$LN46@SetInitial:
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	lea	eax, DWORD PTR [esi+edx]
	push	eax
	call	?SetPlayerInitialItems@@YAXAAVCvPlayer@@ABUPlayer@CvWorldBuilderMap@@@Z ; SetPlayerInitialItems
	inc	ebx
	add	esp, 8
	add	esi, 63236				; 0000f704H
	cmp	ebx, edi
	jb	SHORT $LL62@SetInitial
$LN1@SetInitial:
	pop	edi
	pop	esi
	pop	ebx

; 670  : 	}
; 671  : }

	add	esp, 8
	ret	0
?SetInitialItems@CvWorldBuilderMapLoader@@SAX_N@Z ENDP	; CvWorldBuilderMapLoader::SetInitialItems
_TEXT	ENDS
PUBLIC	?SetupCity@@YAXABUCity@CvWorldBuilderMap@@HH@Z	; SetupCity
EXTRN	?DoUpdateNextPolicyCost@CvPlayer@@QAEXXZ:PROC	; CvPlayer::DoUpdateNextPolicyCost
EXTRN	?SetNumRealBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z:PROC ; CvCityBuildings::SetNumRealBuilding
EXTRN	?getNumBuildingInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildingInfos
EXTRN	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ:PROC ; CvCity::GetCityBuildings
EXTRN	?setDamage@CvCity@@QAEXH_N@Z:PROC		; CvCity::setDamage
EXTRN	?GetMaxHitPoints@CvCity@@QBEHXZ:PROC		; CvCity::GetMaxHitPoints
EXTRN	?SetPuppet@CvCity@@QAEX_N@Z:PROC		; CvCity::SetPuppet
EXTRN	?SetOccupied@CvCity@@QAEX_N@Z:PROC		; CvCity::SetOccupied
EXTRN	?setPopulation@CvCity@@QAEXH_N@Z:PROC		; CvCity::setPopulation
EXTRN	?setName@CvCity@@QAEXPBD_N@Z:PROC		; CvCity::setName
EXTRN	?initCity@CvPlayer@@QAEPAVCvCity@@HH_N0@Z:PROC	; CvPlayer::initCity
EXTRN	__ftol2_sse_excpt:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?SetupCity@@YAXABUCity@CvWorldBuilderMap@@HH@Z
_TEXT	SEGMENT
tv359 = -8						; size = 4
$T230491 = -8						; size = 4
_kPlayer$224530 = -4					; size = 4
_fHitPoints$224538 = 8					; size = 4
_iMaxHitPoints$224537 = 8				; size = 4
_kSavedCity$ = 8					; size = 4
_iPlotX$ = 12						; size = 4
_iPlotY$ = 16						; size = 4
?SetupCity@@YAXABUCity@CvWorldBuilderMap@@HH@Z PROC	; SetupCity, COMDAT

; 701  : {

	sub	esp, 8
	push	ebp

; 702  : 	const PlayerTypes ePlayer = GetPlayerType(kSavedCity.m_byOwner);

	mov	ebp, DWORD PTR _kSavedCity$[esp+8]
	mov	al, BYTE PTR [ebp+64]
	cmp	al, 32					; 00000020H
	jae	SHORT $LN24@SetupCity
	cmp	al, 22					; 00000016H
	jae	$LN11@SetupCity
	movzx	eax, al
$LN15@SetupCity:

; 703  : 	if(ePlayer != NO_PLAYER)

	cmp	eax, -1
	je	$LN11@SetupCity
$LN45@SetupCity:

; 704  : 	{
; 705  : 		CvPlayer& kPlayer = GET_PLAYER(ePlayer);
; 706  : 		CvCity* pkGameplayCity = kPlayer.initCity(iPlotX, iPlotY);

	mov	ecx, DWORD PTR _iPlotY$[esp+8]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR _iPlotX$[esp+8]
	push	esi
	push	1
	push	1
	push	ecx
	push	edx
	mov	ecx, eax
	mov	DWORD PTR _kPlayer$224530[esp+32], eax
	call	?initCity@CvPlayer@@QAEPAVCvCity@@HH_N0@Z ; CvPlayer::initCity
	mov	esi, eax

; 707  : 		if(pkGameplayCity != NULL)

	test	esi, esi
	je	$LN47@SetupCity

; 708  : 		{
; 709  : 			pkGameplayCity->setName(kSavedCity.m_szName);

	push	0
	push	ebp
	mov	ecx, esi
	call	?setName@CvCity@@QAEXPBD_N@Z		; CvCity::setName

; 710  : 			pkGameplayCity->setPopulation(kSavedCity.m_wPopulation);

	movzx	eax, WORD PTR [ebp+66]
	push	1
	push	eax
	mov	ecx, esi
	call	?setPopulation@CvCity@@QAEXH_N@Z	; CvCity::setPopulation

; 711  : 
; 712  : 			if(kSavedCity.GetFlag(CvWorldBuilderMap::City::CITY_PUPPET_STATE))

	mov	al, BYTE PTR [ebp+65]
	test	al, 2
	je	SHORT $LN10@SetupCity

; 713  : 			{
; 714  : 				pkGameplayCity->SetOccupied(true);

	push	1
	mov	ecx, esi
	call	?SetOccupied@CvCity@@QAEX_N@Z		; CvCity::SetOccupied

; 715  : 				pkGameplayCity->SetPuppet(true);

	push	1
	mov	ecx, esi
	call	?SetPuppet@CvCity@@QAEX_N@Z		; CvCity::SetPuppet
	jmp	SHORT $LN8@SetupCity

; 702  : 	const PlayerTypes ePlayer = GetPlayerType(kSavedCity.m_byOwner);

$LN24@SetupCity:
	cmp	al, 96					; 00000060H
	jae	SHORT $LN53@SetupCity
	movzx	eax, al
	sub	eax, 32					; 00000020H
	cmp	eax, 41					; 00000029H
	jae	$LN11@SetupCity
	add	eax, 22					; 00000016H
	jmp	$LN15@SetupCity
$LN53@SetupCity:
	jne	$LN11@SetupCity
	mov	eax, 63					; 0000003fH
	jmp	$LN45@SetupCity
$LN10@SetupCity:

; 716  : 			}
; 717  : 			else if(kSavedCity.GetFlag(CvWorldBuilderMap::City::CITY_OCCUPIED))

	test	al, 4
	je	SHORT $LN8@SetupCity

; 718  : 			{
; 719  : 				pkGameplayCity->SetOccupied(true);

	push	1
	mov	ecx, esi
	call	?SetOccupied@CvCity@@QAEX_N@Z		; CvCity::SetOccupied
$LN8@SetupCity:

; 720  : 			}
; 721  : 
; 722  : 			if(kSavedCity.m_uiHealth != kSavedCity.MaxHealth)

	cmp	DWORD PTR [ebp+68], 100000		; 000186a0H
	push	ebx
	push	edi
	je	SHORT $LN7@SetupCity

; 723  : 			{
; 724  : 				const int iMaxHitPoints = pkGameplayCity->GetMaxHitPoints();

	mov	ecx, esi
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints

; 725  : 
; 726  : 				// TODO: Oh no!  It's floating point math!  This may be an issue for multi-player.
; 727  : 				const float fHitPoints = kSavedCity.GetHealthAsFloat() * (float)iMaxHitPoints;

	mov	ebx, DWORD PTR [ebp+68]
	mov	ecx, ebx
	mov	edi, eax
	mov	DWORD PTR tv359[esp+24], ecx
	fild	DWORD PTR tv359[esp+24]
	mov	DWORD PTR _iMaxHitPoints$224537[esp+20], edi
	test	ecx, ecx
	jge	SHORT $LN51@SetupCity
	fadd	DWORD PTR __real@4f800000
$LN51@SetupCity:
	fdiv	DWORD PTR __real@47c35000
	fstp	DWORD PTR $T230491[esp+24]
	fild	DWORD PTR _iMaxHitPoints$224537[esp+20]
	fmul	DWORD PTR $T230491[esp+24]
	fstp	DWORD PTR _fHitPoints$224538[esp+20]

; 728  : 
; 729  : 				// Don't allow the city to be killed by a precision error
; 730  : 				int iHitPoints = (int)fHitPoints;

	fld	DWORD PTR _fHitPoints$224538[esp+20]
	call	__ftol2_sse_excpt

; 731  : 				if(iHitPoints == 0 && kSavedCity.m_uiHealth != 0)

	test	eax, eax
	jne	SHORT $LN6@SetupCity
	test	ebx, ebx
	je	SHORT $LN6@SetupCity

; 732  : 					iHitPoints = 1;

	mov	eax, 1
$LN6@SetupCity:

; 733  : 
; 734  : 				pkGameplayCity->setDamage(iMaxHitPoints - iHitPoints);

	push	0
	sub	edi, eax
	push	edi
	mov	ecx, esi
	call	?setDamage@CvCity@@QAEXH_N@Z		; CvCity::setDamage
$LN7@SetupCity:

; 735  : 			}
; 736  : 
; 737  : 			CvCityBuildings* pkCityBuildings = pkGameplayCity->GetCityBuildings();

	mov	ecx, esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ebx, eax

; 738  : 			if(pkCityBuildings != NULL)

	test	ebx, ebx
	je	SHORT $LN46@SetupCity

; 739  : 			{
; 740  : 				const int iBuildingTypeCount = GC.getNumBuildingInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	mov	edi, eax

; 741  : 				for(int iBuilding = 0; iBuilding < iBuildingTypeCount; ++iBuilding)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN46@SetupCity
	add	ebp, 72					; 00000048H
$LL4@SetupCity:

; 742  : 				{
; 743  : 					const BuildingTypes eBuildingType = (BuildingTypes)iBuilding;
; 744  : 					if(kSavedCity.m_kBuildings[iBuilding])

	cmp	esi, 512				; 00000200H
	jae	SHORT $LN43@SetupCity
	mov	ecx, esi
	and	ecx, 31					; 0000001fH
	mov	edx, 1
	shl	edx, cl
	mov	eax, esi
	shr	eax, 5
	test	edx, DWORD PTR [ebp+eax*4]
	je	SHORT $LN3@SetupCity

; 745  : 						pkCityBuildings->SetNumRealBuilding(eBuildingType, 1);

	push	1
	push	esi
	mov	ecx, ebx
	call	?SetNumRealBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetNumRealBuilding
$LN3@SetupCity:
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL4@SetupCity
$LN46@SetupCity:

; 746  : 				}
; 747  : 			}
; 748  : 			kPlayer.DoUpdateNextPolicyCost();

	mov	ecx, DWORD PTR _kPlayer$224530[esp+24]
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 749  : 		}
; 750  : 	}
; 751  : }

	add	esp, 8

; 746  : 				}
; 747  : 			}
; 748  : 			kPlayer.DoUpdateNextPolicyCost();

	jmp	?DoUpdateNextPolicyCost@CvPlayer@@QAEXXZ ; CvPlayer::DoUpdateNextPolicyCost
$LN43@SetupCity:

; 742  : 				{
; 743  : 					const BuildingTypes eBuildingType = (BuildingTypes)iBuilding;
; 744  : 					if(kSavedCity.m_kBuildings[iBuilding])

	mov	ecx, ebp
	call	?_Xran@?$bitset@$0CAA@@std@@ABEXXZ	; std::bitset<512>::_Xran
$LN54@SetupCity:
$LN47@SetupCity:
	pop	esi
$LN11@SetupCity:
	pop	ebp

; 749  : 		}
; 750  : 	}
; 751  : }

	add	esp, 8
	ret	0
$LN52@SetupCity:
?SetupCity@@YAXABUCity@CvWorldBuilderMap@@HH@Z ENDP	; SetupCity
_TEXT	ENDS
PUBLIC	?SetupUnit@@YAXABUUnit@CvWorldBuilderMap@@HH@Z	; SetupUnit
EXTRN	?setName@CvUnit@@QAEXVCvString@@@Z:PROC		; CvUnit::setName
EXTRN	?getNumPromotionInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPromotionInfos
EXTRN	?setExperience@CvUnit@@QAEXHH@Z:PROC		; CvUnit::setExperience
EXTRN	?setDamage@CvUnit@@QAEHHW4PlayerTypes@@MPBVCvString@@@Z:PROC ; CvUnit::setDamage
EXTRN	?GetMaxHitPoints@CvUnit@@QBEHXZ:PROC		; CvUnit::GetMaxHitPoints
EXTRN	?setMoves@CvUnit@@QAEXH@Z:PROC			; CvUnit::setMoves
EXTRN	?maxMoves@CvUnit@@QBEHXZ:PROC			; CvUnit::maxMoves
EXTRN	?setEmbarked@CvUnit@@QAEX_N@Z:PROC		; CvUnit::setEmbarked
EXTRN	?setHasPromotion@CvUnit@@QAEXW4PromotionTypes@@_N@Z:PROC ; CvUnit::setHasPromotion
EXTRN	?GetEmbarkationPromotion@CvPlayer@@QBE?AW4PromotionTypes@@XZ:PROC ; CvPlayer::GetEmbarkationPromotion
EXTRN	?getMISSION_SLEEP@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_SLEEP
EXTRN	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_FORTIFY
EXTRN	?isFortifyable@CvUnit@@QBE_N_N@Z:PROC		; CvUnit::isFortifyable
EXTRN	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z:PROC ; CvPlayer::initUnit
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetDefaultUnitAIType
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
; Function compile flags: /Ogtpy
;	COMDAT ?SetupUnit@@YAXABUUnit@CvWorldBuilderMap@@HH@Z
_TEXT	SEGMENT
$T230576 = -8						; size = 4
$T230563 = -8						; size = 4
_iMaxHitPoints$224591 = -8				; size = 4
tv547 = -4						; size = 4
$T230583 = -4						; size = 4
_fHitPoints$224592 = -4					; size = 4
$T230596 = 8						; size = 4
$T230524 = 8						; size = 4
_kSavedUnit$ = 8					; size = 4
_iPlotX$ = 12						; size = 4
_iPlotY$ = 16						; size = 4
?SetupUnit@@YAXABUUnit@CvWorldBuilderMap@@HH@Z PROC	; SetupUnit, COMDAT

; 754  : {

	sub	esp, 8
	push	ebx
	push	ebp

; 755  : 	const PlayerTypes ePlayer = GetPlayerType(kSavedUnit.m_byOwner);

	mov	ebp, DWORD PTR _kSavedUnit$[esp+12]
	mov	al, BYTE PTR [ebp+16]
	push	esi
	push	edi
	cmp	al, 32					; 00000020H
	jae	SHORT $LN39@SetupUnit
	cmp	al, 22					; 00000016H
	jae	SHORT $LN38@SetupUnit
	movzx	esi, al
	jmp	SHORT $LN31@SetupUnit
$LN38@SetupUnit:
	or	esi, -1
	jmp	SHORT $LN31@SetupUnit
$LN39@SetupUnit:
	cmp	al, 96					; 00000060H
	jae	SHORT $LN35@SetupUnit
	movzx	eax, al
	sub	eax, 32					; 00000020H
	cmp	eax, 41					; 00000029H
	jae	SHORT $LN38@SetupUnit
	lea	esi, DWORD PTR [eax+22]
	jmp	SHORT $LN31@SetupUnit
$LN35@SetupUnit:
	xor	ecx, ecx
	cmp	al, 96					; 00000060H
	setne	cl
	dec	ecx
	and	ecx, 64					; 00000040H
	dec	ecx
	mov	esi, ecx
$LN31@SetupUnit:

; 756  : 	UnitTypes eUnitType = (UnitTypes)kSavedUnit.m_byUnitType;

	mov	ebx, DWORD PTR [ebp+12]

; 757  : 	// Test to see if m_byUnitType is still a byte, if so, if it is 255, then it is really -1 and we must reflect this in the eUnitType
; 758  : 	// The World Builder map format should be changed so the serialization of the unit type is an int.  We are already close to
; 759  : 	// maxing out the byte range as it stands now.
; 760  : 	if (sizeof(kSavedUnit.m_byUnitType) == 1 && kSavedUnit.m_byUnitType == 255)
; 761  : 	{
; 762  : 		eUnitType = NO_UNIT;
; 763  : 	}
; 764  : 
; 765  : 	UnitAITypes eAIType = NO_UNITAI;
; 766  : 	const CvUnitEntry* pkUnitType = GC.getUnitInfo(eUnitType);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo

; 767  : 	FAssert(pkUnitType); // We should probably be concerned if this unit type isn't valid
; 768  : 	if(pkUnitType != NULL)

	test	eax, eax
	je	$LN25@SetupUnit

; 769  : 		eAIType = (UnitAITypes)pkUnitType->GetDefaultUnitAIType();

	mov	ecx, eax
	call	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetDefaultUnitAIType
	mov	edi, eax

; 770  : 	else
; 771  : 		return;	// The unit type is invalid, we really can't go any further.
; 772  : 
; 773  : 	DirectionTypes eFacing = NO_DIRECTION;
; 774  : 	switch(kSavedUnit.m_byDirection)

	movzx	eax, BYTE PTR [ebp+17]
	dec	eax
	cmp	eax, 5
	ja	SHORT $LN15@SetupUnit
	jmp	DWORD PTR $LN89@SetupUnit[eax*4]
$LN21@SetupUnit:

; 775  : 	{
; 776  : 	case CvWorldBuilderMap::Unit::DIRECTION_EAST:
; 777  : 		eFacing = DIRECTION_EAST;

	mov	eax, 1

; 778  : 		break;

	jmp	SHORT $LN22@SetupUnit
$LN20@SetupUnit:

; 779  : 
; 780  : 	case CvWorldBuilderMap::Unit::DIRECTION_NORTHEAST:
; 781  : 		eFacing = DIRECTION_NORTHEAST;

	xor	eax, eax

; 782  : 		break;

	jmp	SHORT $LN22@SetupUnit
$LN19@SetupUnit:

; 783  : 
; 784  : 	case CvWorldBuilderMap::Unit::DIRECTION_NORTHWEST:
; 785  : 		eFacing = DIRECTION_NORTHWEST;

	mov	eax, 5

; 786  : 		break;

	jmp	SHORT $LN22@SetupUnit
$LN18@SetupUnit:

; 787  : 
; 788  : 	case CvWorldBuilderMap::Unit::DIRECTION_SOUTHEAST:
; 789  : 		eFacing = DIRECTION_SOUTHEAST;

	mov	eax, 2

; 790  : 		break;

	jmp	SHORT $LN22@SetupUnit
$LN17@SetupUnit:

; 791  : 
; 792  : 	case CvWorldBuilderMap::Unit::DIRECTION_SOUTHWEST:
; 793  : 		eFacing = DIRECTION_SOUTHWEST;

	mov	eax, 3

; 794  : 		break;

	jmp	SHORT $LN22@SetupUnit
$LN16@SetupUnit:

; 795  : 
; 796  : 	case CvWorldBuilderMap::Unit::DIRECTION_WEST:
; 797  : 		eFacing = DIRECTION_WEST;

	mov	eax, 4

; 798  : 		break;

	jmp	SHORT $LN22@SetupUnit
$LN15@SetupUnit:

; 799  : 
; 800  : 	default:
; 801  : 		eFacing = (DirectionTypes)GC.getGame().getJonRandNum(NUM_DIRECTION_TYPES, "Picking Random Unit Direction");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG224580
	push	6
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
$LN22@SetupUnit:

; 802  : 	}
; 803  : 
; 804  : 	if(ePlayer != NO_PLAYER)

	cmp	esi, -1
	je	$LN25@SetupUnit

; 805  : 	{
; 806  : 		CvPlayer& kPlayer = GET_PLAYER(ePlayer);
; 807  : 		CvUnit* pkGameplayUnit = kPlayer.initUnit(eUnitType, iPlotX, iPlotY, eAIType, eFacing, false);

	mov	edx, DWORD PTR _iPlotY$[esp+20]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	0
	push	1
	push	0
	push	eax
	mov	eax, DWORD PTR _iPlotX$[esp+40]
	push	edi
	push	edx
	push	eax
	mov	ebp, esi
	push	ebx
	mov	ecx, ebp
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
	mov	esi, eax

; 808  : 		if(pkGameplayUnit != NULL)

	test	esi, esi
	je	$LN25@SetupUnit

; 809  : 		{
; 810  : 			if(kSavedUnit.GetFlag(CvWorldBuilderMap::Unit::UNIT_FORTIFIED))

	mov	ebx, DWORD PTR _kSavedUnit$[esp+20]
	test	BYTE PTR [ebx+18], 1
	je	SHORT $LN10@SetupUnit

; 811  : 			{
; 812  : 				if(pkGameplayUnit->isFortifyable(true))

	push	1
	mov	ecx, esi
	call	?isFortifyable@CvUnit@@QBE_N_N@Z	; CvUnit::isFortifyable

; 813  : 					gDLL->sendPushMission(pkGameplayUnit->GetID(), CvTypes::getMISSION_FORTIFY(), 0, 0, 0, false);

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edi, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi+100]
	push	0
	push	0
	add	edi, 152				; 00000098H
	push	0
	mov	DWORD PTR $T230563[esp+36], ecx
	push	0
	test	al, al
	je	SHORT $LN11@SetupUnit
	call	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FORTIFY

; 814  : 				else

	jmp	SHORT $LN88@SetupUnit
$LN11@SetupUnit:

; 815  : 					gDLL->sendPushMission(pkGameplayUnit->GetID(), CvTypes::getMISSION_SLEEP(), 0, 0, 0, false);

	call	?getMISSION_SLEEP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SLEEP
$LN88@SetupUnit:
	mov	edx, DWORD PTR $T230576[esp+40]
	push	eax
	mov	eax, DWORD PTR [edi]
	push	edx
	mov	ecx, ebx
	call	eax
	mov	ebx, DWORD PTR _kSavedUnit$[esp+20]
$LN10@SetupUnit:

; 816  : 			}
; 817  : 
; 818  : 			if(kSavedUnit.GetFlag(CvWorldBuilderMap::Unit::UNIT_EMBARKED))

	test	BYTE PTR [ebx+18], 2
	je	SHORT $LN85@SetupUnit

; 819  : 			{
; 820  : 				const PromotionTypes ePromotionEmbarkation = kPlayer.GetEmbarkationPromotion();

	mov	ecx, ebp
	call	?GetEmbarkationPromotion@CvPlayer@@QBE?AW4PromotionTypes@@XZ ; CvPlayer::GetEmbarkationPromotion

; 821  : 				pkGameplayUnit->setHasPromotion(ePromotionEmbarkation, true);

	push	1
	push	eax
	mov	ecx, esi
	call	?setHasPromotion@CvUnit@@QAEXW4PromotionTypes@@_N@Z ; CvUnit::setHasPromotion

; 822  : 				pkGameplayUnit->setEmbarked(true);

	push	1
	mov	ecx, esi
	call	?setEmbarked@CvUnit@@QAEX_N@Z		; CvUnit::setEmbarked

; 823  : 				pkGameplayUnit->setMoves(pkGameplayUnit->maxMoves());

	mov	ecx, esi
	call	?maxMoves@CvUnit@@QBEHXZ		; CvUnit::maxMoves
	push	eax
	mov	ecx, esi
	call	?setMoves@CvUnit@@QAEXH@Z		; CvUnit::setMoves
$LN85@SetupUnit:

; 824  : 			}
; 825  : 
; 826  : 			if(kSavedUnit.m_uiHealth != kSavedUnit.MaxHealth)

	cmp	DWORD PTR [ebx+8], 100000		; 000186a0H
	je	SHORT $LN8@SetupUnit

; 827  : 			{
; 828  : 				const int iMaxHitPoints = pkGameplayUnit->GetMaxHitPoints();

	mov	ecx, esi
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints

; 829  : 
; 830  : 				// TODO: Oh no!  It's floating point math!  This may be an issue for multi-player.
; 831  : 				const float fHitPoints = kSavedUnit.GetHealthAsFloat() * (float)iMaxHitPoints;

	mov	ebx, DWORD PTR [ebx+8]
	mov	ecx, ebx
	mov	edi, eax
	mov	DWORD PTR tv547[esp+24], ecx
	fild	DWORD PTR tv547[esp+24]
	mov	DWORD PTR _iMaxHitPoints$224591[esp+24], edi
	test	ecx, ecx
	jge	SHORT $LN86@SetupUnit
	fadd	DWORD PTR __real@4f800000
$LN86@SetupUnit:
	fdiv	DWORD PTR __real@47c35000
	fstp	DWORD PTR $T230583[esp+24]
	fild	DWORD PTR _iMaxHitPoints$224591[esp+24]
	fmul	DWORD PTR $T230583[esp+24]
	fstp	DWORD PTR _fHitPoints$224592[esp+24]

; 832  : 
; 833  : 				// Don't allow the unit to be killed by a precision error
; 834  : 				int iHitPoints = (int)fHitPoints;

	fld	DWORD PTR _fHitPoints$224592[esp+24]
	call	__ftol2_sse_excpt

; 835  : 				if(iHitPoints == 0 && kSavedUnit.m_uiHealth != 0)

	test	eax, eax
	jne	SHORT $LN7@SetupUnit
	test	ebx, ebx
	je	SHORT $LN7@SetupUnit

; 836  : 					iHitPoints = 1;

	mov	eax, 1
$LN7@SetupUnit:

; 837  : 
; 838  : 				pkGameplayUnit->setDamage(iMaxHitPoints - iHitPoints);

	push	0
	push	ecx
	mov	DWORD PTR [esp], 0
	push	-1
	sub	edi, eax
	push	edi
	mov	ecx, esi
	call	?setDamage@CvUnit@@QAEHHW4PlayerTypes@@MPBVCvString@@@Z ; CvUnit::setDamage
	mov	ebx, DWORD PTR _kSavedUnit$[esp+20]
$LN8@SetupUnit:

; 839  : 			}
; 840  : 
; 841  : 			pkGameplayUnit->setExperience((int)kSavedUnit.m_uiExperience);

	mov	edx, DWORD PTR [ebx+4]
	push	-1
	push	edx
	mov	ecx, esi
	call	?setExperience@CvUnit@@QAEXHH@Z		; CvUnit::setExperience

; 842  : 
; 843  : 			const int iPromotionTypeCount = GC.getNumPromotionInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	mov	ebp, eax

; 844  : 			for(int iPromotion = 0; iPromotion < iPromotionTypeCount; ++iPromotion)

	xor	edi, edi
	test	ebp, ebp
	jle	SHORT $LN4@SetupUnit
	lea	eax, DWORD PTR [ebx+20]

; 849  : 			}
; 850  : 
; 851  : 			if(kSavedUnit.m_hCustomName.Valid())

	mov	DWORD PTR $T230596[esp+20], eax
$LL6@SetupUnit:

; 845  : 			{
; 846  : 				const PromotionTypes ePromotionType = (PromotionTypes)iPromotion;
; 847  : 				if(kSavedUnit.m_kPromotions[iPromotion])

	cmp	edi, 512				; 00000200H
	jae	SHORT $LN83@SetupUnit
	mov	ecx, edi
	and	ecx, 31					; 0000001fH
	mov	edx, 1
	shl	edx, cl
	mov	ecx, edi
	shr	ecx, 5
	test	edx, DWORD PTR [eax+ecx*4]
	je	SHORT $LN5@SetupUnit

; 848  : 					pkGameplayUnit->setHasPromotion(ePromotionType, true);

	push	1
	push	edi
	mov	ecx, esi
	call	?setHasPromotion@CvUnit@@QAEXW4PromotionTypes@@_N@Z ; CvUnit::setHasPromotion
	mov	eax, DWORD PTR $T230596[esp+20]
$LN5@SetupUnit:
	inc	edi
	cmp	edi, ebp
	jl	SHORT $LL6@SetupUnit
$LN4@SetupUnit:

; 849  : 			}
; 850  : 
; 851  : 			if(kSavedUnit.m_hCustomName.Valid())

	movzx	eax, WORD PTR [ebx+2]
	mov	edx, 65535				; 0000ffffH
	cmp	ax, dx
	je	SHORT $LN25@SetupUnit

; 852  : 			{
; 853  : 				CvWorldBuilderMap::UnitName* pkUnitName = sg_kSave.m_kUnitNames[kSavedUnit.m_hCustomName];

	movzx	eax, ax
	cmp	eax, DWORD PTR _sg_kSave+2872
	jae	SHORT $LN25@SetupUnit
	shl	eax, 6
	add	eax, DWORD PTR _sg_kSave+2864

; 854  : 				if(pkUnitName != NULL)

	test	eax, eax
	je	SHORT $LN25@SetupUnit

; 855  : 				{
; 856  : 					pkGameplayUnit->setName(pkUnitName->m_szText);

	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T230524[esp+48], esp
	mov	ecx, esp
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, esi
	call	?setName@CvUnit@@QAEXVCvString@@@Z	; CvUnit::setName
$LN25@SetupUnit:

; 857  : 				}
; 858  : 			}
; 859  : 		}
; 860  : 	}
; 861  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
$LN83@SetupUnit:

; 845  : 			{
; 846  : 				const PromotionTypes ePromotionType = (PromotionTypes)iPromotion;
; 847  : 				if(kSavedUnit.m_kPromotions[iPromotion])

	mov	ecx, eax
	call	?_Xran@?$bitset@$0CAA@@std@@ABEXXZ	; std::bitset<512>::_Xran
$LN90@SetupUnit:
$LN87@SetupUnit:
	npad	3
$LN89@SetupUnit:

; 857  : 				}
; 858  : 			}
; 859  : 		}
; 860  : 	}
; 861  : }

	DD	$LN20@SetupUnit
	DD	$LN21@SetupUnit
	DD	$LN18@SetupUnit
	DD	$LN17@SetupUnit
	DD	$LN16@SetupUnit
	DD	$LN19@SetupUnit
?SetupUnit@@YAXABUUnit@CvWorldBuilderMap@@HH@Z ENDP	; SetupUnit
_TEXT	ENDS
PUBLIC	?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z ; CvWorldBuilderMapLoader::GetWorldSizeType
EXTRN	?getGridHeight@CvWorldInfo@@QBEHXZ:PROC		; CvWorldInfo::getGridHeight
EXTRN	?getGridWidth@CvWorldInfo@@QBEHXZ:PROC		; CvWorldInfo::getGridWidth
EXTRN	?CacheResult@CvBaseInfo@@QAE_NAAVResults@Database@@@Z:PROC ; CvBaseInfo::CacheResult
EXTRN	??0CvWorldInfo@@QAE@XZ:PROC			; CvWorldInfo::CvWorldInfo
EXTRN	__imp_?SelectAll@Connection@Database@@QAE_NAAVResults@2@PBD@Z:PROC
EXTRN	__imp_??1Results@Database@@UAE@XZ:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHH@Z:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBD_N@Z:PROC
EXTRN	__imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z:PROC
EXTRN	__imp_??0Results@Database@@QAE@PBD@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z$2
__ehfuncinfo$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z
_TEXT	SEGMENT
_eWorldSize$ = -484					; size = 4
_kWorldSize$225344 = -480				; size = 64
_kWorldSizes$225352 = -416				; size = 64
_kInfo$225357 = -352					; size = 340
__$EHRec$ = -12						; size = 12
_kMap$ = 8						; size = 4
?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z PROC ; CvWorldBuilderMapLoader::GetWorldSizeType, COMDAT

; 1923 : {

	push	-1
	push	__ehhandler$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 472				; 000001d8H
	push	ebx

; 1924 : 	WorldSizeTypes eWorldSize = NO_WORLDSIZE;
; 1925 : 	const char* szWorldType = kMap.GetWorldType();
; 1926 : 	if(szWorldType != NULL)

	mov	ebx, DWORD PTR __imp_??0Results@Database@@QAE@PBD@Z
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _kMap$[esp+496]
	or	ebp, -1
	lea	esi, DWORD PTR [edi+584608]
	mov	DWORD PTR _eWorldSize$[esp+500], ebp
	test	esi, esi
	je	SHORT $LN31@GetWorldSi

; 1927 : 	{
; 1928 : 		Database::Results kWorldSize;

	push	0
	lea	ecx, DWORD PTR _kWorldSize$225344[esp+504]
	call	ebx

; 1929 : 		DB.Execute(kWorldSize, "Select ID from Worlds where Type = ? LIMIT 1");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	push	ebp
	push	OFFSET $SG225345
	lea	eax, DWORD PTR _kWorldSize$225344[esp+508]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+520], 0
	call	DWORD PTR __imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z

; 1930 : 
; 1931 : 		kWorldSize.Bind(1, szWorldType);

	push	1
	push	esi
	push	1
	lea	ecx, DWORD PTR _kWorldSize$225344[esp+512]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 1932 : 		if(kWorldSize.Step())

	lea	ecx, DWORD PTR _kWorldSize$225344[esp+500]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN5@GetWorldSi

; 1933 : 		{
; 1934 : 			eWorldSize = (WorldSizeTypes)kWorldSize.GetInt(0);

	push	0
	lea	ecx, DWORD PTR _kWorldSize$225344[esp+504]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _eWorldSize$[esp+500], eax
	mov	ebp, eax
$LN5@GetWorldSi:

; 1935 : 		}
; 1936 : 	}

	lea	ecx, DWORD PTR _kWorldSize$225344[esp+500]
	mov	DWORD PTR __$EHRec$[esp+508], -1
	call	DWORD PTR __imp_??1Results@Database@@UAE@XZ

; 1937 : 
; 1938 : 	if(eWorldSize == NO_WORLDSIZE)

	cmp	ebp, -1
	jne	$LN30@GetWorldSi
$LN31@GetWorldSi:

; 1939 : 	{
; 1940 : 		const int iArea = (int)(kMap.GetWidth() * kMap.GetHeight());

	mov	ecx, DWORD PTR [edi+12228]
	mov	eax, DWORD PTR [edi+12232]
	imul	eax, ecx

; 1941 : 		int iSmallestAreaDifference = 64000; // Arbitrarily large at start
; 1942 : 
; 1943 : 		Database::Results kWorldSizes;

	push	0
	lea	ecx, DWORD PTR _kWorldSizes$225352[esp+504]
	mov	ebp, eax
	mov	edi, 64000				; 0000fa00H
	call	ebx

; 1944 : 		DB.SelectAll(kWorldSizes, "Worlds");

	push	OFFSET $SG225353
	lea	ecx, DWORD PTR _kWorldSizes$225352[esp+504]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	mov	DWORD PTR __$EHRec$[esp+516], 1
	call	DWORD PTR __imp_?SelectAll@Connection@Database@@QAE_NAAVResults@2@PBD@Z

; 1945 : 		while(kWorldSizes.Step())

	lea	ecx, DWORD PTR _kWorldSizes$225352[esp+500]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	$LN2@GetWorldSi
	mov	bl, 2
	npad	9
$LL3@GetWorldSi:

; 1946 : 		{
; 1947 : 			CvWorldInfo kInfo;

	lea	ecx, DWORD PTR _kInfo$225357[esp+500]
	call	??0CvWorldInfo@@QAE@XZ			; CvWorldInfo::CvWorldInfo

; 1948 : 			kInfo.CacheResult(kWorldSizes);

	lea	edx, DWORD PTR _kWorldSizes$225352[esp+500]
	push	edx
	lea	ecx, DWORD PTR _kInfo$225357[esp+504]
	mov	BYTE PTR __$EHRec$[esp+512], bl
	call	?CacheResult@CvBaseInfo@@QAE_NAAVResults@Database@@@Z ; CvBaseInfo::CacheResult

; 1949 : 
; 1950 : 			int iSizeTypeArea = kInfo.getGridWidth() * kInfo.getGridHeight();

	lea	ecx, DWORD PTR _kInfo$225357[esp+500]
	call	?getGridWidth@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getGridWidth
	lea	ecx, DWORD PTR _kInfo$225357[esp+500]
	mov	esi, eax
	call	?getGridHeight@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getGridHeight
	imul	esi, eax

; 1951 : 			int iAreaDifference = abs(iArea - iSizeTypeArea);

	mov	eax, ebp
	sub	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx

; 1952 : 			if(iAreaDifference < iSmallestAreaDifference)

	cmp	eax, edi
	jge	SHORT $LN22@GetWorldSi

; 1953 : 			{
; 1954 : 				iSmallestAreaDifference = iAreaDifference;

	mov	edi, eax

; 1955 : 				eWorldSize = (WorldSizeTypes)kInfo.GetID();

	mov	eax, DWORD PTR _kInfo$225357[esp+504]
	mov	DWORD PTR _eWorldSize$[esp+500], eax
$LN22@GetWorldSi:

; 1956 : 			}
; 1957 : 		}

	lea	ecx, DWORD PTR _kInfo$225357[esp+500]
	mov	BYTE PTR __$EHRec$[esp+508], 1
	call	??1CvBaseInfo@@QAE@XZ
	lea	ecx, DWORD PTR _kWorldSizes$225352[esp+500]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL3@GetWorldSi
$LN2@GetWorldSi:

; 1958 : 	}

	lea	ecx, DWORD PTR _kWorldSizes$225352[esp+500]
	mov	DWORD PTR __$EHRec$[esp+508], -1
	call	DWORD PTR __imp_??1Results@Database@@UAE@XZ

; 1959 : 
; 1960 : 	return eWorldSize;

	mov	eax, DWORD PTR _eWorldSize$[esp+500]
	jmp	SHORT $LN4@GetWorldSi
$LN30@GetWorldSi:
	mov	eax, ebp
$LN4@GetWorldSi:

; 1961 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+500]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 484				; 000001e4H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z$0:
	lea	ecx, DWORD PTR _kWorldSize$225344[ebp]
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__unwindfunclet$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z$1:
	lea	ecx, DWORD PTR _kWorldSizes$225352[ebp]
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__unwindfunclet$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z$2:
	lea	ecx, DWORD PTR _kInfo$225357[ebp]
	jmp	??1CvWorldInfo@@QAE@XZ
__ehhandler$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z ENDP ; CvWorldBuilderMapLoader::GetWorldSizeType
PUBLIC	__real@41f0000000000000
PUBLIC	?GetMapPreview@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ; CvWorldBuilderMapLoader::GetMapPreview
EXTRN	?GetText@CvBaseInfo@@QBEPBDXZ:PROC		; CvBaseInfo::GetText
EXTRN	?getGameSpeedInfo@CvGlobals@@QAEPAVCvGameSpeedInfo@@W4GameSpeedTypes@@@Z:PROC ; CvGlobals::getGameSpeedInfo
EXTRN	?getNumGameSpeedInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumGameSpeedInfos
;	COMDAT __real@41f0000000000000
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
CONST	ENDS
;	COMDAT ?GetMapPreview@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z
_TEXT	SEGMENT
tv395 = -540						; size = 4
tv392 = -540						; size = 4
tv387 = -540						; size = 4
_eWorldSize$225423 = -540				; size = 4
_kPlayer$225442 = -536					; size = 4
_szStartEra$225436 = -532				; size = 4
_i$225438 = -528					; size = 4
_eDefaultSpeed$225425 = -524				; size = 4
_wszMapFile$ = -520					; size = 520
_L$ = 8							; size = 4
?GetMapPreview@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z PROC ; CvWorldBuilderMapLoader::GetMapPreview, COMDAT

; 2041 : {

	sub	esp, 540				; 0000021cH
	push	esi

; 2042 : 	if(L == NULL)

	mov	esi, DWORD PTR _L$[esp+540]
	test	esi, esi
	jne	SHORT $LN21@GetMapPrev

; 2043 : 	{
; 2044 : 		FAssertMsg(L, "Seriously, you really need a lua state for this.");
; 2045 : 		return 0;

	xor	eax, eax
	pop	esi

; 2163 : }

	add	esp, 540				; 0000021cH
	ret	0
$LN21@GetMapPrev:
	push	edi

; 2046 : 	}
; 2047 : 
; 2048 : 	const char* szUTF8MapFile = luaL_checkstring(L, 1);

	push	0
	push	1
	push	esi
	call	_luaL_checklstring
	mov	edi, eax

; 2049 : 
; 2050 : 	wchar_t wszMapFile[MAX_PATH] = {0};

	xor	eax, eax
	push	518					; 00000206H
	push	eax
	lea	ecx, DWORD PTR _wszMapFile$[esp+570]
	push	ecx
	mov	WORD PTR _wszMapFile$[esp+572], ax
	call	_memset
	add	esp, 24					; 00000018H

; 2051 : 	MultiByteToWideChar(CP_UTF8, 0, szUTF8MapFile, -1, wszMapFile, MAX_PATH);

	push	260					; 00000104H
	lea	edx, DWORD PTR _wszMapFile$[esp+552]
	push	edx
	push	-1
	push	edi
	push	0
	push	65001					; 0000fde9H
	call	DWORD PTR __imp__MultiByteToWideChar@24

; 2052 : 
; 2053 : 	if(CheckTempMap(wszMapFile) || sg_kTempMap.Load(wszMapFile, sg_kMapTypeDesc))

	lea	eax, DWORD PTR _wszMapFile$[esp+548]
	push	eax
	call	?CheckTempMap@@YA_NPB_W@Z		; CheckTempMap
	add	esp, 4
	test	al, al
	jne	SHORT $LN19@GetMapPrev
	push	1
	push	OFFSET _sg_kMapTypeDesc
	lea	ecx, DWORD PTR _wszMapFile$[esp+556]
	push	ecx
	mov	ecx, OFFSET _sg_kTempMap
	call	?Load@CvWorldBuilderMap@@QAE_NPB_WABVCvWorldBuilderMapTypeDesc@@_N@Z ; CvWorldBuilderMap::Load
	test	al, al
	jne	SHORT $LN19@GetMapPrev

; 2156 : 	}
; 2157 : 	else
; 2158 : 	{
; 2159 : 		lua_pushnil(L);

	push	esi
	call	_lua_pushnil
	add	esp, 4
	pop	edi

; 2160 : 	}
; 2161 : 
; 2162 : 	return 1;

	mov	eax, 1
	pop	esi

; 2163 : }

	add	esp, 540				; 0000021cH
	ret	0
$LN19@GetMapPrev:
	push	ebx
	push	ebp

; 2054 : 	{
; 2055 : 		TempMapLoaded(wszMapFile);

	lea	edx, DWORD PTR _wszMapFile$[esp+556]
	push	edx
	push	260					; 00000104H
	push	OFFSET _sg_wszTempMapName
	call	DWORD PTR __imp__wcscpy_s

; 2056 : 
; 2057 : 		WorldSizeTypes eWorldSize = GetWorldSizeType(sg_kTempMap);

	push	OFFSET _sg_kTempMap
	call	?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z ; CvWorldBuilderMapLoader::GetWorldSizeType
	mov	DWORD PTR _eWorldSize$225423[esp+572], eax

; 2058 : 
; 2059 : 		const char* szDefaultSpeed = sg_kTempMap.GetDefaultGameSpeed();
; 2060 : 		GameSpeedTypes eDefaultSpeed = (GameSpeedTypes)GC.getSTANDARD_GAMESPEED();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8464
	add	esp, 16					; 00000010H

; 2061 : #ifdef AUI_WARNING_FIXES
; 2062 : 		for (uint i = 0; i < GC.getNumGameSpeedInfos(); ++i)
; 2063 : #else
; 2064 : 		const int iSpeedCount = GC.getNumGameSpeedInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eDefaultSpeed$225425[esp+556], eax
	call	?getNumGameSpeedInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumGameSpeedInfos
	mov	ebp, eax

; 2065 : 		for(int i = 0; i < iSpeedCount; ++i)

	xor	ebx, ebx
	test	ebp, ebp
	jle	SHORT $LN16@GetMapPrev
$LL79@GetMapPrev:

; 2066 : #endif
; 2067 : 		{
; 2068 : 			const GameSpeedTypes eSpeed = (GameSpeedTypes)i;
; 2069 : 			const CvGameSpeedInfo* pkSpeed = GC.getGameSpeedInfo(eSpeed);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getGameSpeedInfo@CvGlobals@@QAEPAVCvGameSpeedInfo@@W4GameSpeedTypes@@@Z ; CvGlobals::getGameSpeedInfo

; 2070 : 			if(pkSpeed != NULL && strcmp(pkSpeed->GetType(), szDefaultSpeed) == 0)

	test	eax, eax
	je	SHORT $LN17@GetMapPrev
	lea	ecx, DWORD PTR [eax+176]
	mov	edi, OFFSET _sg_kTempMap+12236
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LL67@GetMapPrev:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edi]
	jne	SHORT $LN68@GetMapPrev
	test	cl, cl
	je	SHORT $LN69@GetMapPrev
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edi+1]
	jne	SHORT $LN68@GetMapPrev
	add	eax, 2
	add	edi, 2
	test	cl, cl
	jne	SHORT $LL67@GetMapPrev
$LN69@GetMapPrev:
	xor	eax, eax
	jmp	SHORT $LN70@GetMapPrev
$LN68@GetMapPrev:
	sbb	eax, eax
	sbb	eax, -1
$LN70@GetMapPrev:
	test	eax, eax
	je	SHORT $LN60@GetMapPrev
$LN17@GetMapPrev:

; 2065 : 		for(int i = 0; i < iSpeedCount; ++i)

	inc	ebx
	cmp	ebx, ebp
	jl	SHORT $LL79@GetMapPrev

; 2098 : 						bFound = true;
; 2099 : 						break;
; 2100 : 					}
; 2101 : 				}
; 2102 : 
; 2103 : 				if(bFound)

	jmp	SHORT $LN16@GetMapPrev
$LN60@GetMapPrev:

; 2071 : 			{
; 2072 : 				eDefaultSpeed = eSpeed;

	mov	DWORD PTR _eDefaultSpeed$225425[esp+556], ebx
$LN16@GetMapPrev:

; 2073 : 				break;
; 2074 : 			}
; 2075 : 		}
; 2076 : 
; 2077 : 		const char* szStartEra = "";
; 2078 : #ifdef AUI_WARNING_FIXES
; 2079 : 		for (byte i = 0; i < sg_kTempMap.GetPlayerCount(); ++i)
; 2080 : #else
; 2081 : 		for(int i = 0; i < sg_kTempMap.GetPlayerCount(); ++i)

	mov	al, BYTE PTR _sg_kTempMap+12316
	xor	ecx, ecx
	mov	DWORD PTR _szStartEra$225436[esp+556], OFFSET $SG225437
	mov	DWORD PTR _i$225438[esp+556], ecx
	test	al, al
	jbe	$LN78@GetMapPrev
$LL14@GetMapPrev:

; 2082 : #endif
; 2083 : 		{
; 2084 : 			const CvWorldBuilderMap::Player& kPlayer = sg_kTempMap.GetPlayer(i);

	cmp	cl, al
	jae	SHORT $LN35@GetMapPrev
	cmp	cl, 32					; 00000020H
	jae	SHORT $LN35@GetMapPrev
	movzx	edi, cl
	imul	edi, 436				; 000001b4H
	add	edi, OFFSET _sg_kTempMap+536608
	mov	DWORD PTR _kPlayer$225442[esp+556], edi
	jmp	SHORT $LN34@GetMapPrev
$LN35@GetMapPrev:
	mov	DWORD PTR _kPlayer$225442[esp+556], OFFSET ?sm_kErrorPlayer@CvWorldBuilderMap@@0UPlayer@1@A ; CvWorldBuilderMap::sm_kErrorPlayer
	mov	edi, DWORD PTR _kPlayer$225442[esp+556]
$LN34@GetMapPrev:

; 2085 : 			if(kPlayer.m_bPlayable)

	cmp	BYTE PTR [edi+433], 0
	je	SHORT $LN13@GetMapPrev

; 2086 : 			{
; 2087 : 				bool bFound = false;
; 2088 : #ifdef AUI_WARNING_FIXES
; 2089 : 				for (uint iEra = 0; iEra < GC.getNumEraInfos(); ++iEra)
; 2090 : #else
; 2091 : 				for(int iEra = 0; iEra < GC.getNumEraInfos(); ++iEra)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebx, ebx
	call	?getNumEraInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumEraInfos
	test	eax, eax
	jle	SHORT $LN77@GetMapPrev
$LL76@GetMapPrev:

; 2092 : #endif
; 2093 : 				{
; 2094 : 					CvEraInfo* pkEraInfo = GC.getEraInfo((EraTypes)iEra);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	mov	ebp, eax

; 2095 : 					if(pkEraInfo != NULL && strcmp(pkEraInfo->GetType(), kPlayer.m_szEra) == 0)

	test	ebp, ebp
	je	SHORT $LN9@GetMapPrev
	lea	ecx, DWORD PTR [ebp+176]
	add	edi, 288				; 00000120H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LL71@GetMapPrev:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edi]
	jne	SHORT $LN72@GetMapPrev
	test	cl, cl
	je	SHORT $LN73@GetMapPrev
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edi+1]
	jne	SHORT $LN72@GetMapPrev
	add	eax, 2
	add	edi, 2
	test	cl, cl
	jne	SHORT $LL71@GetMapPrev
$LN73@GetMapPrev:
	xor	eax, eax
	jmp	SHORT $LN74@GetMapPrev
$LN72@GetMapPrev:
	sbb	eax, eax
	sbb	eax, -1
$LN74@GetMapPrev:
	test	eax, eax
	je	SHORT $LN61@GetMapPrev
	mov	edi, DWORD PTR _kPlayer$225442[esp+556]
$LN9@GetMapPrev:

; 2086 : 			{
; 2087 : 				bool bFound = false;
; 2088 : #ifdef AUI_WARNING_FIXES
; 2089 : 				for (uint iEra = 0; iEra < GC.getNumEraInfos(); ++iEra)
; 2090 : #else
; 2091 : 				for(int iEra = 0; iEra < GC.getNumEraInfos(); ++iEra)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumEraInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumEraInfos
	cmp	ebx, eax
	jl	SHORT $LL76@GetMapPrev
$LN77@GetMapPrev:
	mov	al, BYTE PTR _sg_kTempMap+12316
	mov	ecx, DWORD PTR _i$225438[esp+556]
$LN13@GetMapPrev:
	movzx	edx, al
	inc	ecx
	cmp	ecx, edx
	mov	DWORD PTR _i$225438[esp+556], ecx
	jl	$LL14@GetMapPrev

; 2073 : 				break;
; 2074 : 			}
; 2075 : 		}
; 2076 : 
; 2077 : 		const char* szStartEra = "";
; 2078 : #ifdef AUI_WARNING_FIXES
; 2079 : 		for (byte i = 0; i < sg_kTempMap.GetPlayerCount(); ++i)
; 2080 : #else
; 2081 : 		for(int i = 0; i < sg_kTempMap.GetPlayerCount(); ++i)

	jmp	SHORT $LN78@GetMapPrev
$LN61@GetMapPrev:

; 2096 : 					{
; 2097 : 						szStartEra = pkEraInfo->GetText();

	mov	ecx, ebp
	call	?GetText@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetText
	mov	DWORD PTR _szStartEra$225436[esp+556], eax
$LN78@GetMapPrev:

; 2104 : 					break;
; 2105 : 			}
; 2106 : 		}
; 2107 : 
; 2108 : 		lua_createtable(L, 0, 8);

	push	8
	push	0
	push	esi
	call	_lua_createtable

; 2109 : 
; 2110 : 		lua_pushstring(L, "MapSize");

	push	OFFSET $SG225453
	push	esi
	call	_lua_pushstring

; 2111 : 		lua_pushinteger(L, eWorldSize);

	mov	eax, DWORD PTR _eWorldSize$225423[esp+576]
	push	eax
	push	esi
	call	_lua_pushinteger

; 2112 : 		lua_rawset(L, -3);

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 2113 : 
; 2114 : 		lua_pushstring(L, "Name");

	push	OFFSET $SG225454
	push	esi
	call	_lua_pushstring

; 2115 : 		lua_pushstring(L, sg_kTempMap.m_sMapName);

	mov	ecx, DWORD PTR _sg_kTempMap+4008
	push	ecx
	push	esi
	call	_lua_pushstring

; 2116 : 		lua_rawset(L, -3);

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 2117 : 
; 2118 : 		lua_pushstring(L, "Description");

	push	OFFSET $SG225455
	push	esi
	call	_lua_pushstring

; 2119 : 		lua_pushstring(L, sg_kTempMap.m_sMapDescription);

	mov	edx, DWORD PTR _sg_kTempMap+4012
	add	esp, 68					; 00000044H
	push	edx
	push	esi
	call	_lua_pushstring

; 2120 : 		lua_rawset(L, -3);

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 2121 : 
; 2122 : 		lua_pushstring(L, "PlayerCount");

	push	OFFSET $SG225456
	push	esi
	call	_lua_pushstring

; 2123 : 		lua_pushnumber(L, sg_kTempMap.GetPlayerCount());

	movzx	eax, BYTE PTR _sg_kTempMap+12316
	mov	DWORD PTR tv395[esp+580], eax
	add	esp, 16					; 00000010H
	fild	DWORD PTR tv395[esp+564]
	fstp	QWORD PTR [esp]
	push	esi
	call	_lua_pushnumber

; 2124 : 		lua_rawset(L, -3);

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 2125 : 
; 2126 : 		lua_pushstring(L, "CityStateCount");

	push	OFFSET $SG225457
	push	esi
	call	_lua_pushstring

; 2127 : 		lua_pushnumber(L, sg_kTempMap.GetCityStateCount());

	movzx	ecx, BYTE PTR _sg_kTempMap+12317
	mov	DWORD PTR tv392[esp+584], ecx
	add	esp, 20					; 00000014H
	fild	DWORD PTR tv392[esp+564]
	fstp	QWORD PTR [esp]
	push	esi
	call	_lua_pushnumber

; 2128 : 		lua_rawset(L, -3);

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 2129 : 
; 2130 : 		lua_pushstring(L, "MaxTurns");

	push	OFFSET $SG225458
	push	esi
	call	_lua_pushstring

; 2131 : 		lua_pushnumber(L, sg_kTempMap.GetMaxTurns());

	fild	DWORD PTR _sg_kTempMap+12304
	mov	edx, DWORD PTR _sg_kTempMap+12304
	test	edx, edx
	jge	SHORT $LN80@GetMapPrev
	fadd	QWORD PTR __real@41f0000000000000
$LN80@GetMapPrev:
	add	esp, 20					; 00000014H
	fstp	QWORD PTR [esp]
	push	esi
	call	_lua_pushnumber

; 2132 : 		lua_rawset(L, -3);

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 2133 : 
; 2134 : 		lua_pushstring(L, "StartEra");

	push	OFFSET $SG225459
	push	esi
	call	_lua_pushstring

; 2135 : 		lua_pushstring(L, szStartEra);

	mov	eax, DWORD PTR _szStartEra$225436[esp+584]
	push	eax
	push	esi
	call	_lua_pushstring

; 2136 : 		lua_rawset(L, -3);

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 2137 : 
; 2138 : 		lua_pushstring(L, "DefaultSpeed");

	push	OFFSET $SG225460
	push	esi
	call	_lua_pushstring

; 2139 : 		lua_pushinteger(L, eDefaultSpeed);

	mov	ecx, DWORD PTR _eDefaultSpeed$225425[esp+608]
	push	ecx
	push	esi
	call	_lua_pushinteger

; 2140 : 		lua_rawset(L, -3);

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset
	add	esp, 68					; 00000044H

; 2141 : 
; 2142 : 		const int iVictoryTypes = GC.getNumVictoryInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos

; 2143 : 		lua_pushstring(L, "VictoryTypes");

	push	OFFSET $SG225462
	push	esi
	mov	ebx, eax
	call	_lua_pushstring

; 2144 : 		lua_createtable(L, iVictoryTypes, 0);

	push	0
	push	ebx
	push	esi
	call	_lua_createtable
	add	esp, 20					; 00000014H

; 2145 : 		for(int i = 0; i < iVictoryTypes; ++i)

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN3@GetMapPrev
	npad	3
$LL5@GetMapPrev:

; 2146 : 		{
; 2147 : 			const char* szVictoryType = "";
; 2148 : 			const CvVictoryInfo* pkInfo = GC.getVictoryInfo((VictoryTypes)i);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebp, OFFSET $SG225468
	call	?getVictoryInfo@CvGlobals@@QAEPAVCvVictoryInfo@@W4VictoryTypes@@@Z ; CvGlobals::getVictoryInfo

; 2149 : 			if(pkInfo != NULL)

	test	eax, eax
	je	SHORT $LN2@GetMapPrev

; 2150 : 				szVictoryType = pkInfo->GetType();

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ebp, eax
$LN2@GetMapPrev:

; 2151 : 
; 2152 : 			lua_pushstring(L, szVictoryType);

	push	ebp
	push	esi
	call	_lua_pushstring

; 2153 : 			lua_rawseti(L, -2, i + 1);

	inc	edi
	push	edi
	push	-2					; fffffffeH
	push	esi
	call	_lua_rawseti
	add	esp, 20					; 00000014H
	cmp	edi, ebx
	jl	SHORT $LL5@GetMapPrev
$LN3@GetMapPrev:

; 2154 : 		}
; 2155 : 		lua_rawset(L, -3);

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset
	add	esp, 8
	pop	ebp
	pop	ebx
	pop	edi

; 2160 : 	}
; 2161 : 
; 2162 : 	return 1;

	mov	eax, 1
	pop	esi

; 2163 : }

	add	esp, 540				; 0000021cH
	ret	0
?GetMapPreview@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ENDP ; CvWorldBuilderMapLoader::GetMapPreview
_TEXT	ENDS
PUBLIC	?push_back@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAEIABQAVCvPlayer@@@Z ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAEIABQAVCvPlayer@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAEIABQAVCvPlayer@@@Z PROC ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::push_back, COMDAT
; _this$ = ecx

; 376  : 	{

	push	esi
	mov	esi, ecx

; 377  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 378  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@IAEXI@Z ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::GrowSize
$LN1@push_back:

; 379  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back:

; 380  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 381  : 	};

	ret	4
?push_back@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAEIABQAVCvPlayer@@@Z ENDP ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::push_back
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@YAXPAVString@CvWorldBuilderMapTypeDesc@@0AAV?$allocator@VString@CvWorldBuilderMapTypeDesc@@@0@@Z ; std::_Destroy_range<std::allocator<CvWorldBuilderMapTypeDesc::String> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@YAXPAVString@CvWorldBuilderMapTypeDesc@@0AAV?$allocator@VString@CvWorldBuilderMapTypeDesc@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@YAXPAVString@CvWorldBuilderMapTypeDesc@@0AAV?$allocator@VString@CvWorldBuilderMapTypeDesc@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvWorldBuilderMapTypeDesc::String> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@YAXPAVString@CvWorldBuilderMapTypeDesc@@0AAV?$allocator@VString@CvWorldBuilderMapTypeDesc@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvWorldBuilderMapTypeDesc::String> >
_TEXT	ENDS
PUBLIC	?InitMap@CvWorldBuilderMapLoader@@SA_NXZ	; CvWorldBuilderMapLoader::InitMap
EXTRN	?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z:PROC ; CvPlot::setOwner
EXTRN	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z:PROC ; CvPlot::setRevealed
EXTRN	?SetPlayerResponsibleForRoute@CvPlot@@QAEXW4PlayerTypes@@@Z:PROC ; CvPlot::SetPlayerResponsibleForRoute
EXTRN	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z:PROC ; CvTreasury::ChangeBaseImprovementGoldMaintenance
EXTRN	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ:PROC	; CvRouteInfo::GetGoldMaintenance
EXTRN	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::MustPayMaintenanceHere
EXTRN	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z:PROC ; CvGlobals::getRouteInfo
EXTRN	?isOwned@CvPlot@@QBE_NXZ:PROC			; CvPlot::isOwned
EXTRN	?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z:PROC	; CvPlot::setRouteType
EXTRN	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::setImprovementType
EXTRN	?SetFriendshipWithMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z:PROC ; CvMinorCivAI::SetFriendshipWithMajor
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
EXTRN	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC ; CvTeam::SetHasDefensivePact
EXTRN	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC ; CvTeam::SetAllowsOpenBordersToTeam
EXTRN	?setPermanentWarPeace@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC ; CvTeam::setPermanentWarPeace
EXTRN	?setAtWar@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC	; CvTeam::setAtWar
EXTRN	?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC	; CvTeam::meet
EXTRN	?Init@CvTacticalAnalysisMap@@QAEXH@Z:PROC	; CvTacticalAnalysisMap::Init
EXTRN	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ:PROC ; CvGame::GetTacticalAnalysisMap
EXTRN	?recalculateAreas@CvMap@@QAEXXZ:PROC		; CvMap::recalculateAreas
EXTRN	?SetContinentType@CvPlot@@QAEXD@Z:PROC		; CvPlot::SetContinentType
EXTRN	?setNEOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z:PROC ; CvPlot::setNEOfRiver
EXTRN	?setNWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z:PROC ; CvPlot::setNWOfRiver
EXTRN	?setWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z:PROC ; CvPlot::setWOfRiver
EXTRN	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z:PROC ; CvPlot::setFeatureType
EXTRN	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z:PROC ; CvPlot::setResourceType
EXTRN	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z:PROC ; CvPlot::setPlotType
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ:PROC ; CvPlayer::getStartingPlot
EXTRN	?setStartingPlot@CvPlayer@@QAEXPAVCvPlot@@@Z:PROC ; CvPlayer::setStartingPlot
EXTRN	__imp__OutputDebugStringA@4:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?InitMap@CvWorldBuilderMapLoader@@SA_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InitMap@CvWorldBuilderMapLoader@@SA_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?InitMap@CvWorldBuilderMapLoader@@SA_NXZ$1
__ehfuncinfo$?InitMap@CvWorldBuilderMapLoader@@SA_NXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?InitMap@CvWorldBuilderMapLoader@@SA_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
xdata$x	ENDS
;	COMDAT ?InitMap@CvWorldBuilderMapLoader@@SA_NXZ
_TEXT	SEGMENT
$T230779 = -78						; size = 1
$T230777 = -78						; size = 1
$T230774 = -78						; size = 1
$T230778 = -77						; size = 1
$T230776 = -77						; size = 1
$T230775 = -77						; size = 1
_kMap$ = -76						; size = 4
_uiTeamCount$ = -72					; size = 4
_i$225009 = -68						; size = 4
_uiMajorCivsPlaced$ = -68				; size = 4
tv2595 = -64						; size = 4
_kPlotData$225013 = -64					; size = 4
_uiMinorCivsPlaced$ = -64				; size = 4
tv2699 = -60						; size = 4
tv2564 = -60						; size = 4
tv2510 = -56						; size = 4
tv2479 = -56						; size = 4
_uiPlotCount$ = -56					; size = 4
tv2677 = -52						; size = 4
tv2585 = -52						; size = 4
tv2537 = -52						; size = 4
_iPlotY$225017 = -52					; size = 4
_iPlotX$225016 = -48					; size = 4
_uiCityStateCount$ = -48				; size = 4
_kGameplayPlayer$224738 = -48				; size = 4
tv2715 = -44						; size = 4
tv2686 = -44						; size = 4
tv1781 = -44						; size = 4
$T231251 = -44						; size = 1
_uiCityState$224992 = -44				; size = 4
_i$224746 = -44						; size = 4
_i$224732 = -44						; size = 4
tv2727 = -40						; size = 4
_uiPlayerCount$ = -40					; size = 4
_kMinorCivs$ = -36					; size = 12
_kMajorCivs$ = -24					; size = 12
__$EHRec$ = -12						; size = 12
?InitMap@CvWorldBuilderMapLoader@@SA_NXZ PROC		; CvWorldBuilderMapLoader::InitMap, COMDAT

; 1054 : {

	push	-1
	push	__ehhandler$?InitMap@CvWorldBuilderMapLoader@@SA_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	ebp

; 1055 : 	CvMap& kMap = GC.getMap();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	esi
	push	edi

; 1056 : 
; 1057 : 	FAssertMsg(
; 1058 : 	    sg_kSave.GetWidth() == kMap.getGridWidth() &&
; 1059 : 	    sg_kSave.GetHeight() == kMap.getGridHeight(),
; 1060 : 	    "Save wrong size");
; 1061 : 
; 1062 : 	OutputDebugStringA("Setting up players...\n");

	push	OFFSET $SG224727
	mov	DWORD PTR _kMap$[esp+100], ebp
	call	DWORD PTR __imp__OutputDebugStringA@4

; 1063 : 
; 1064 : #ifdef AUI_WARNING_FIXES
; 1065 : 	const byte uiPlayerCount = MIN(sg_kSave.GetPlayerCount(), (byte)MAX_CIV_PLAYERS);
; 1066 : 	for (byte i = 0; i < uiPlayerCount; ++i)
; 1067 : #else
; 1068 : 	const uint uiPlayerCount = std::min(sg_kSave.GetPlayerCount(), (byte)MAX_CIV_PLAYERS);

	mov	dl, BYTE PTR _sg_kSave+12316
	mov	BYTE PTR $T230774[esp+96], 63		; 0000003fH
	mov	BYTE PTR $T230775[esp+96], dl
	lea	eax, DWORD PTR $T230774[esp+96]
	cmp	dl, 63					; 0000003fH
	ja	SHORT $LN96@InitMap
	lea	eax, DWORD PTR $T230775[esp+96]
$LN96@InitMap:
	movzx	esi, BYTE PTR [eax]

; 1069 : 	for(uint i = 0; i < uiPlayerCount; ++i)

	xor	ecx, ecx
	mov	DWORD PTR _uiPlayerCount$[esp+96], esi
	mov	DWORD PTR _i$224732[esp+96], ecx
	cmp	esi, ecx
	jbe	$LN531@InitMap

; 1063 : 
; 1064 : #ifdef AUI_WARNING_FIXES
; 1065 : 	const byte uiPlayerCount = MIN(sg_kSave.GetPlayerCount(), (byte)MAX_CIV_PLAYERS);
; 1066 : 	for (byte i = 0; i < uiPlayerCount; ++i)
; 1067 : #else
; 1068 : 	const uint uiPlayerCount = std::min(sg_kSave.GetPlayerCount(), (byte)MAX_CIV_PLAYERS);

	mov	DWORD PTR tv2479[esp+96], ecx
	jmp	SHORT $LN84@InitMap
	npad	8
$LL549@InitMap:
	mov	dl, BYTE PTR _sg_kSave+12316
$LN84@InitMap:

; 1070 : #endif
; 1071 : 	{
; 1072 : 		const PlayerTypes ePlayer = (PlayerTypes)i;
; 1073 : 		CvPlayer& kGameplayPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edi, DWORD PTR tv2479[esp+96]
	add	edi, eax
	mov	DWORD PTR _kGameplayPlayer$224738[esp+96], edi

; 1074 : 		const CvWorldBuilderMap::Player& kSavedPlayer = sg_kSave.GetPlayer(i);

	cmp	cl, dl
	jae	SHORT $LN100@InitMap
	cmp	cl, 32					; 00000020H
	jae	SHORT $LN100@InitMap
	movzx	edx, cl
	imul	edx, 436				; 000001b4H
	add	edx, OFFSET _sg_kSave+536608
	jmp	SHORT $LN99@InitMap
$LN100@InitMap:
	mov	edx, OFFSET ?sm_kErrorPlayer@CvWorldBuilderMap@@0UPlayer@1@A ; CvWorldBuilderMap::sm_kErrorPlayer
$LN99@InitMap:

; 1075 : 
; 1076 : 		if(kSavedPlayer.m_uiStartX < sg_kSave.GetWidth() &&
; 1077 : 		        kSavedPlayer.m_uiStartY < sg_kSave.GetHeight())

	mov	eax, DWORD PTR [edx+424]
	cmp	eax, DWORD PTR _sg_kSave+12228
	jae	$LN83@InitMap
	mov	ebx, DWORD PTR [edx+428]
	cmp	ebx, DWORD PTR _sg_kSave+12232
	jae	$LN83@InitMap

; 1078 : 		{
; 1079 : 			CvPlot* pkStartingPlot = kMap.plot(kSavedPlayer.m_uiStartX, kSavedPlayer.m_uiStartY);

	cmp	eax, -2147483647			; 80000001H
	je	$LN107@InitMap
	cmp	ebx, -2147483647			; 80000001H
	je	SHORT $LN107@InitMap
	mov	cl, BYTE PTR [ebp+4056]
	mov	esi, DWORD PTR [ebp+4020]
	test	cl, cl
	je	SHORT $LN117@InitMap
	test	eax, eax
	jge	SHORT $LN119@InitMap
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN121@InitMap
$LN119@InitMap:
	cmp	eax, esi
	jl	SHORT $LN117@InitMap
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN121@InitMap
$LN117@InitMap:
	mov	edi, eax
$LN121@InitMap:
	mov	al, BYTE PTR [ebp+4057]
	mov	ecx, DWORD PTR [ebp+4024]
	test	al, al
	je	SHORT $LN127@InitMap
	test	ebx, ebx
	jge	SHORT $LN129@InitMap
	mov	eax, ebx
	cdq
	idiv	ecx
	add	edx, ecx
	jmp	SHORT $LN131@InitMap
$LN129@InitMap:
	cmp	ebx, ecx
	jl	SHORT $LN127@InitMap
	mov	eax, ebx
	cdq
	idiv	ecx
	jmp	SHORT $LN131@InitMap
$LN127@InitMap:
	mov	edx, ebx
$LN131@InitMap:
	test	edi, edi
	jl	SHORT $LN107@InitMap
	cmp	edi, esi
	jge	SHORT $LN107@InitMap
	test	edx, edx
	jl	SHORT $LN107@InitMap
	cmp	edx, ecx
	jge	SHORT $LN107@InitMap
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ebp+4068]
	jmp	SHORT $LN109@InitMap
$LN107@InitMap:
	xor	esi, esi
$LN109@InitMap:

; 1080 : 			kGameplayPlayer.setStartingPlot(pkStartingPlot);

	mov	ecx, DWORD PTR _kGameplayPlayer$224738[esp+96]
	push	esi
	call	?setStartingPlot@CvPlayer@@QAEXPAVCvPlot@@@Z ; CvPlayer::setStartingPlot
	mov	ecx, DWORD PTR _i$224732[esp+96]
	mov	esi, DWORD PTR _uiPlayerCount$[esp+96]
$LN83@InitMap:
	add	DWORD PTR tv2479[esp+96], 63236		; 0000f704H
	inc	ecx
	mov	DWORD PTR _i$224732[esp+96], ecx
	cmp	ecx, esi
	jb	$LL549@InitMap
$LN531@InitMap:

; 1081 : 		}
; 1082 : 	}
; 1083 : 
; 1084 : #ifdef AUI_WARNING_FIXES
; 1085 : 	const byte uiCityStateCount = MIN(sg_kSave.GetCityStateCount(), (byte)MAX_MINOR_CIVS);
; 1086 : 	for (byte i = 0; i < uiCityStateCount; ++i)
; 1087 : #else
; 1088 : 	const uint uiCityStateCount = std::min(sg_kSave.GetCityStateCount(), (byte)MAX_MINOR_CIVS);

	mov	dl, BYTE PTR _sg_kSave+12317
	mov	BYTE PTR $T230776[esp+96], 41		; 00000029H
	mov	BYTE PTR $T230777[esp+96], dl
	lea	eax, DWORD PTR $T230776[esp+96]
	cmp	dl, 41					; 00000029H
	ja	SHORT $LN150@InitMap
	lea	eax, DWORD PTR $T230777[esp+96]
$LN150@InitMap:
	movzx	eax, BYTE PTR [eax]

; 1089 : 	for(uint i = 0; i < uiCityStateCount; ++i)

	xor	ecx, ecx
	mov	DWORD PTR _uiCityStateCount$[esp+96], eax
	mov	DWORD PTR _i$224746[esp+96], ecx
	test	eax, eax
	jbe	$LN78@InitMap

; 1081 : 		}
; 1082 : 	}
; 1083 : 
; 1084 : #ifdef AUI_WARNING_FIXES
; 1085 : 	const byte uiCityStateCount = MIN(sg_kSave.GetCityStateCount(), (byte)MAX_MINOR_CIVS);
; 1086 : 	for (byte i = 0; i < uiCityStateCount; ++i)
; 1087 : #else
; 1088 : 	const uint uiCityStateCount = std::min(sg_kSave.GetCityStateCount(), (byte)MAX_MINOR_CIVS);

	mov	DWORD PTR tv2510[esp+96], 1391192	; 00153a58H
	jmp	SHORT $LN80@InitMap
	npad	10
$LL550@InitMap:
	mov	dl, BYTE PTR _sg_kSave+12317
$LN80@InitMap:

; 1090 : #endif
; 1091 : 	{
; 1092 : 		const PlayerTypes ePlayer = (PlayerTypes)(i + MAX_MAJOR_CIVS);
; 1093 : 		CvPlayer& kGameplayPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, DWORD PTR tv2510[esp+96]
	lea	ebp, DWORD PTR [esi+eax]

; 1094 : 		const CvWorldBuilderMap::Player& kSavedPlayer = sg_kSave.GetCityState(i);

	cmp	cl, dl
	jae	SHORT $LN154@InitMap
	cmp	cl, 64					; 00000040H
	jae	SHORT $LN154@InitMap
	movzx	edx, cl
	imul	edx, 436				; 000001b4H
	add	edx, OFFSET _sg_kSave+550560
	jmp	SHORT $LN153@InitMap
$LN154@InitMap:
	mov	edx, OFFSET ?sm_kErrorPlayer@CvWorldBuilderMap@@0UPlayer@1@A ; CvWorldBuilderMap::sm_kErrorPlayer
$LN153@InitMap:

; 1095 : 
; 1096 : 		if(kSavedPlayer.m_uiStartX < sg_kSave.GetWidth() &&
; 1097 : 		        kSavedPlayer.m_uiStartY < sg_kSave.GetHeight())

	mov	eax, DWORD PTR [edx+424]
	cmp	eax, DWORD PTR _sg_kSave+12228
	jae	$LN79@InitMap
	mov	ebx, DWORD PTR [edx+428]
	cmp	ebx, DWORD PTR _sg_kSave+12232
	jae	$LN79@InitMap

; 1098 : 		{
; 1099 : 			CvPlot* pkStartingPlot = kMap.plot(kSavedPlayer.m_uiStartX, kSavedPlayer.m_uiStartY);

	cmp	eax, -2147483647			; 80000001H
	je	$LN161@InitMap
	cmp	ebx, -2147483647			; 80000001H
	je	$LN161@InitMap
	mov	edx, DWORD PTR _kMap$[esp+96]
	mov	cl, BYTE PTR [edx+4056]
	mov	esi, DWORD PTR [edx+4020]
	test	cl, cl
	je	SHORT $LN171@InitMap
	test	eax, eax
	jge	SHORT $LN173@InitMap
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN175@InitMap
$LN173@InitMap:
	cmp	eax, esi
	jl	SHORT $LN171@InitMap
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN175@InitMap
$LN171@InitMap:
	mov	edi, eax
$LN175@InitMap:
	mov	ecx, DWORD PTR _kMap$[esp+96]
	mov	al, BYTE PTR [ecx+4057]
	mov	ecx, DWORD PTR [ecx+4024]
	test	al, al
	je	SHORT $LN181@InitMap
	test	ebx, ebx
	jge	SHORT $LN183@InitMap
	mov	eax, ebx
	cdq
	idiv	ecx
	add	edx, ecx
	jmp	SHORT $LN185@InitMap
$LN183@InitMap:
	cmp	ebx, ecx
	jl	SHORT $LN181@InitMap
	mov	eax, ebx
	cdq
	idiv	ecx
	jmp	SHORT $LN185@InitMap
$LN181@InitMap:
	mov	edx, ebx
$LN185@InitMap:
	test	edi, edi
	jl	SHORT $LN161@InitMap
	cmp	edi, esi
	jge	SHORT $LN161@InitMap
	test	edx, edx
	jl	SHORT $LN161@InitMap
	cmp	edx, ecx
	jge	SHORT $LN161@InitMap
	mov	ecx, DWORD PTR _kMap$[esp+96]
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	jmp	SHORT $LN163@InitMap
$LN161@InitMap:
	xor	esi, esi
$LN163@InitMap:

; 1100 : 			kGameplayPlayer.setStartingPlot(pkStartingPlot);

	push	esi
	mov	ecx, ebp
	call	?setStartingPlot@CvPlayer@@QAEXPAVCvPlot@@@Z ; CvPlayer::setStartingPlot
	mov	ecx, DWORD PTR _i$224746[esp+96]
$LN79@InitMap:
	add	DWORD PTR tv2510[esp+96], 63236		; 0000f704H
	inc	ecx
	mov	DWORD PTR _i$224746[esp+96], ecx
	cmp	ecx, DWORD PTR _uiCityStateCount$[esp+96]
	jb	$LL550@InitMap
$LN78@InitMap:

; 1101 : 		}
; 1102 : 	}
; 1103 : 
; 1104 : #ifdef NQM_FAST_COMP
; 1105 : 	const uint uiTeamCount = MIN(sg_kSave.GetTeamCount(), (byte)MAX_TEAMS);
; 1106 : #else
; 1107 : 	const uint uiTeamCount = std::min(sg_kSave.GetTeamCount(), (byte)MAX_TEAMS);

	mov	al, BYTE PTR _sg_kSave+12318
	mov	BYTE PTR $T230779[esp+96], al
	cmp	al, 64					; 00000040H
	mov	BYTE PTR $T230778[esp+96], 64		; 00000040H
	lea	eax, DWORD PTR $T230778[esp+96]
	ja	SHORT $LN204@InitMap
	lea	eax, DWORD PTR $T230779[esp+96]
$LN204@InitMap:
	movzx	edx, BYTE PTR [eax]

; 1108 : #endif
; 1109 : 
; 1110 : 	// HACK: Call SetInitialItems early.  It has to be called later too :_(
; 1111 : 	// This is because of what is essentially a circular dependency.  Techs
; 1112 : 	// need to be initialized before units are created (for the embarkation
; 1113 : 	// promotion among other things).  However, units must be created before
; 1114 : 	// CvGame sets up the initial player state otherwise a scenario player may
; 1115 : 	// be given starting units they don't need and shouldn't have.  Unfortunately
; 1116 : 	// this also does stuff like reset starting techs.  Therefore SetInitialItems
; 1117 : 	// must be called AGAIN to put the player state back to where it should be.
; 1118 : 	// This second call is done from CvInitMgr::GameCoreNew.  You may be tempted to
; 1119 : 	// remove this hack but be very careful if you do and test thoroughly with scenario saves.
; 1120 : 	SetInitialItems(true);

	push	1
	mov	DWORD PTR _uiTeamCount$[esp+100], edx
	call	?SetInitialItems@CvWorldBuilderMapLoader@@SAX_N@Z ; CvWorldBuilderMapLoader::SetInitialItems

; 1121 : 
; 1122 : 	FFastVector<CvPlayer*> kMajorCivs;

	xor	edi, edi
	xor	ebx, ebx
	add	esp, 4
	mov	DWORD PTR _kMajorCivs$[esp+100], edi
	mov	DWORD PTR _kMajorCivs$[esp+104], ebx
	mov	DWORD PTR _kMajorCivs$[esp+96], edi

; 1123 : 	FFastVector<CvPlayer*> kMinorCivs;

	xor	ebp, ebp
	mov	DWORD PTR __$EHRec$[esp+104], edi
	mov	DWORD PTR _kMinorCivs$[esp+100], edi
	mov	DWORD PTR _kMinorCivs$[esp+104], ebp
	mov	DWORD PTR _kMinorCivs$[esp+96], edi
	mov	BYTE PTR __$EHRec$[esp+104], 1
	npad	10
$LL76@InitMap:

; 1125 : 	{
; 1126 : 		PlayerTypes ePlayer = PlayerTypes(i);
; 1127 : 		CvPlayer& kPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 1128 : 		if(kPlayer.isAlive() && kPlayer.getStartingPlot() == NULL)

	cmp	BYTE PTR [edi+eax+2256], 0
	lea	esi, DWORD PTR [edi+eax]
	je	SHORT $LN75@InitMap
	mov	ecx, esi
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	test	eax, eax
	jne	SHORT $LN75@InitMap

; 1129 : 		{
; 1130 : 			if(kPlayer.isMinorCiv())

	mov	ecx, esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN72@InitMap

; 1131 : 				kMinorCivs.push_back(&kPlayer);

	cmp	DWORD PTR _kMinorCivs$[esp+100], ebp
	jne	SHORT $LN229@InitMap
	push	ebp
	lea	ecx, DWORD PTR _kMinorCivs$[esp+100]
	call	?GrowSize@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@IAEXI@Z ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::GrowSize
	mov	ebp, DWORD PTR _kMinorCivs$[esp+104]
$LN229@InitMap:
	mov	ecx, DWORD PTR _kMinorCivs$[esp+96]
	mov	edx, DWORD PTR _kMinorCivs$[esp+100]
	lea	eax, DWORD PTR [ecx+edx*4]
	test	eax, eax
	je	SHORT $LN232@InitMap
	mov	DWORD PTR [eax], esi
$LN232@InitMap:
	inc	DWORD PTR _kMinorCivs$[esp+100]

; 1132 : 			else

	jmp	SHORT $LN75@InitMap
$LN72@InitMap:

; 1133 : 				kMajorCivs.push_back(&kPlayer);

	cmp	DWORD PTR _kMajorCivs$[esp+100], ebx
	jne	SHORT $LN236@InitMap
	push	ebx
	lea	ecx, DWORD PTR _kMajorCivs$[esp+100]
	call	?GrowSize@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@IAEXI@Z ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::GrowSize
	mov	ebx, DWORD PTR _kMajorCivs$[esp+104]
$LN236@InitMap:
	mov	eax, DWORD PTR _kMajorCivs$[esp+96]
	mov	ecx, DWORD PTR _kMajorCivs$[esp+100]
	lea	eax, DWORD PTR [eax+ecx*4]
	test	eax, eax
	je	SHORT $LN239@InitMap
	mov	DWORD PTR [eax], esi
$LN239@InitMap:
	inc	DWORD PTR _kMajorCivs$[esp+100]
$LN75@InitMap:

; 1124 : 	for(uint i = 0; i < MAX_CIV_PLAYERS; ++i)

	add	edi, 63236				; 0000f704H
	cmp	edi, 3983868				; 003cc9fcH
	jb	$LL76@InitMap

; 1134 : 		}
; 1135 : 	}
; 1136 : 
; 1137 : 	uint uiMajorCivsPlaced = 0;

	xor	ebx, ebx

; 1138 : 	uint uiMinorCivsPlaced = 0;
; 1139 : 
; 1140 : 	OutputDebugStringA("Setting up map...\n");

	push	OFFSET $SG224937
	mov	DWORD PTR _uiMajorCivsPlaced$[esp+100], ebx
	mov	DWORD PTR _uiMinorCivsPlaced$[esp+100], ebx
	call	DWORD PTR __imp__OutputDebugStringA@4

; 1141 : 	uint uiPlotCount = sg_kSave.GetWidth() * sg_kSave.GetHeight();

	mov	ebp, DWORD PTR _sg_kSave+12232
	imul	ebp, DWORD PTR _sg_kSave+12228
	mov	DWORD PTR _uiPlotCount$[esp+96], ebp

; 1142 : 	for(uint i = 0; i < uiPlotCount; ++i)

	cmp	ebp, ebx
	jbe	$LN68@InitMap
	mov	DWORD PTR tv2537[esp+96], ebx
	mov	DWORD PTR tv2564[esp+96], OFFSET _sg_kSave+12320
	npad	8
$LL548@InitMap:

; 1143 : 	{
; 1144 : 		const CvWorldBuilderMap::PlotMapData& kPlotData = sg_kSave.GetPlotData(i);

	mov	edx, DWORD PTR _sg_kSave+12232
	imul	edx, DWORD PTR _sg_kSave+12228
	cmp	ebx, edx
	jae	SHORT $LN248@InitMap
	mov	edi, DWORD PTR tv2564[esp+96]
	cmp	ebx, 32768				; 00008000H
	jb	SHORT $LN247@InitMap
$LN248@InitMap:
	mov	edi, OFFSET ?sm_kErrorPlotMapData@CvWorldBuilderMap@@0VPlotMapData@1@A ; CvWorldBuilderMap::sm_kErrorPlotMapData
$LN247@InitMap:

; 1145 : 		CvPlot* pkPlot = kMap.plotByIndex(i);

	test	ebx, ebx
	jl	$LN69@InitMap
	mov	eax, DWORD PTR _kMap$[esp+96]
	cmp	ebx, DWORD PTR [eax+4028]
	jge	$LN69@InitMap
	mov	ecx, eax
	mov	esi, DWORD PTR [ecx+4068]
	add	esi, DWORD PTR tv2537[esp+96]

; 1146 : 		FAssertMsg(pkPlot, "Missing CvPlot for this location");
; 1147 : 		if(pkPlot == NULL) continue;

	je	$LN69@InitMap

; 1148 : 
; 1149 : 		pkPlot->setTerrainType((TerrainTypes)kPlotData.GetTerrainType(), false, false);

	mov	al, BYTE PTR [edi]
	push	0
	movzx	edx, al
	push	0
	push	edx
	mov	ecx, esi
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType

; 1150 : 
; 1151 : 		CvWorldBuilderMap::PlotMapData::PlotHeight ePlotHeight = kPlotData.GetPlotHeight();

	movzx	eax, BYTE PTR [edi+4]

; 1152 : 		if(ePlotHeight != CvWorldBuilderMap::PlotMapData::FLAT_TERRAIN)

	test	eax, eax
	je	SHORT $LN546@InitMap

; 1153 : 		{
; 1154 : 			if(ePlotHeight == CvWorldBuilderMap::PlotMapData::HILLS)
; 1155 : 				pkPlot->setPlotType(PLOT_HILLS);

	push	1
	push	1
	mov	ecx, esi
	push	1
	cmp	eax, 1
	jne	SHORT $LN65@InitMap
	push	eax

; 1156 : 			else

	jmp	SHORT $LN553@InitMap
$LN65@InitMap:

; 1157 : 				pkPlot->setPlotType(PLOT_MOUNTAIN);

	push	0
$LN553@InitMap:
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType
$LN546@InitMap:

; 1158 : 		}
; 1159 : 
; 1160 : 		if(kPlotData.GetResourceType() != CvWorldBuilderMap::PlotMapData::InvalidResource)

	mov	cl, BYTE PTR [edi+1]
	cmp	cl, 255					; 000000ffH
	je	SHORT $LN63@InitMap

; 1161 : 		{
; 1162 : 			int iResourceAmount = kPlotData.GetResourceAmount();

	movzx	eax, BYTE PTR [edi+7]

; 1163 : 			if(iResourceAmount <= 0)

	test	eax, eax
	jg	SHORT $LN62@InitMap

; 1164 : 				iResourceAmount = 1;

	mov	eax, 1
$LN62@InitMap:

; 1165 : 
; 1166 : 			pkPlot->setResourceType((ResourceTypes)kPlotData.GetResourceType(), iResourceAmount);

	push	0
	push	eax
	movzx	eax, cl
	push	eax
	mov	ecx, esi
	call	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z ; CvPlot::setResourceType
$LN63@InitMap:

; 1167 : 		}
; 1168 : 
; 1169 : 		if(kPlotData.GetFeatureType() != CvWorldBuilderMap::PlotMapData::InvalidFeature)

	mov	al, BYTE PTR [edi+2]
	cmp	al, 255					; 000000ffH
	je	SHORT $LN61@InitMap

; 1170 : 			pkPlot->setFeatureType((FeatureTypes)kPlotData.GetFeatureType());

	movzx	ecx, al
	push	-1
	push	ecx
	mov	ecx, esi
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType
$LN61@InitMap:

; 1171 : 
; 1172 : 		if(kPlotData.GetFlag(CvWorldBuilderMap::PlotMapData::W_OF_RIVER))

	mov	al, BYTE PTR [edi+3]
	test	al, 1
	je	SHORT $LN58@InitMap

; 1173 : 		{
; 1174 : 			if(kPlotData.GetFlag(CvWorldBuilderMap::PlotMapData::RIVER_FLOW_S))
; 1175 : 				pkPlot->setWOfRiver(true, FLOWDIRECTION_SOUTH);

	mov	ecx, esi
	test	al, 8
	je	SHORT $LN59@InitMap
	push	3

; 1176 : 			else

	jmp	SHORT $LN554@InitMap
$LN59@InitMap:

; 1177 : 				pkPlot->setWOfRiver(true, FLOWDIRECTION_NORTH);

	push	0
$LN554@InitMap:
	push	1
	call	?setWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setWOfRiver
$LN58@InitMap:

; 1178 : 		}
; 1179 : 
; 1180 : 		if(kPlotData.GetFlag(CvWorldBuilderMap::PlotMapData::NW_OF_RIVER))

	mov	al, BYTE PTR [edi+3]
	test	al, 2
	je	SHORT $LN55@InitMap

; 1181 : 		{
; 1182 : 			if(kPlotData.GetFlag(CvWorldBuilderMap::PlotMapData::RIVER_FLOW_NE))
; 1183 : 				pkPlot->setNWOfRiver(true, FLOWDIRECTION_NORTHEAST);

	mov	ecx, esi
	test	al, 16					; 00000010H
	je	SHORT $LN56@InitMap
	push	1

; 1184 : 			else

	jmp	SHORT $LN555@InitMap
$LN56@InitMap:

; 1185 : 				pkPlot->setNWOfRiver(true, FLOWDIRECTION_SOUTHWEST);

	push	4
$LN555@InitMap:
	push	1
	call	?setNWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setNWOfRiver
$LN55@InitMap:

; 1186 : 		}
; 1187 : 
; 1188 : 		if(kPlotData.GetFlag(CvWorldBuilderMap::PlotMapData::NE_OF_RIVER))

	mov	al, BYTE PTR [edi+3]
	test	al, 4
	je	SHORT $LN52@InitMap

; 1189 : 		{
; 1190 : 			if(kPlotData.GetFlag(CvWorldBuilderMap::PlotMapData::RIVER_FLOW_NW))
; 1191 : 				pkPlot->setNEOfRiver(true, FLOWDIRECTION_NORTHWEST);

	mov	ecx, esi
	test	al, 32					; 00000020H
	je	SHORT $LN53@InitMap
	push	5

; 1192 : 			else

	jmp	SHORT $LN556@InitMap
$LN53@InitMap:

; 1193 : 				pkPlot->setNEOfRiver(true, FLOWDIRECTION_SOUTHEAST);

	push	2
$LN556@InitMap:
	push	1
	call	?setNEOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setNEOfRiver
$LN52@InitMap:

; 1194 : 		}
; 1195 : 
; 1196 : 		if(kPlotData.GetFlag(CvWorldBuilderMap::PlotMapData::START_POS_MAJOR))

	mov	al, BYTE PTR [edi+3]
	test	al, 64					; 00000040H
	je	SHORT $LN51@InitMap

; 1197 : 		{
; 1198 : 			if(uiMajorCivsPlaced < kMajorCivs.size())

	mov	edx, DWORD PTR _uiMajorCivsPlaced$[esp+96]
	cmp	edx, DWORD PTR _kMajorCivs$[esp+100]
	jae	SHORT $LN47@InitMap

; 1199 : 			{
; 1200 : 				kMajorCivs[uiMajorCivsPlaced]->setStartingPlot(pkPlot);

	mov	eax, DWORD PTR _kMajorCivs$[esp+96]
	mov	ecx, edx
	mov	ecx, DWORD PTR [eax+ecx*4]
	push	esi
	call	?setStartingPlot@CvPlayer@@QAEXPAVCvPlot@@@Z ; CvPlayer::setStartingPlot

; 1201 : 				uiMajorCivsPlaced++;

	inc	DWORD PTR _uiMajorCivsPlaced$[esp+96]

; 1202 : 			}
; 1203 : 		}

	jmp	SHORT $LN47@InitMap
$LN51@InitMap:

; 1204 : 		else if(kPlotData.GetFlag(CvWorldBuilderMap::PlotMapData::START_POS_MINOR))

	test	al, al
	jns	SHORT $LN47@InitMap

; 1205 : 		{
; 1206 : 			if(uiMinorCivsPlaced < kMinorCivs.size())

	mov	edx, DWORD PTR _uiMinorCivsPlaced$[esp+96]
	cmp	edx, DWORD PTR _kMinorCivs$[esp+100]
	jae	SHORT $LN47@InitMap

; 1207 : 			{
; 1208 : 				kMinorCivs[uiMinorCivsPlaced]->setStartingPlot(pkPlot);

	mov	eax, DWORD PTR _kMinorCivs$[esp+96]
	mov	ecx, edx
	mov	ecx, DWORD PTR [eax+ecx*4]
	push	esi
	call	?setStartingPlot@CvPlayer@@QAEXPAVCvPlot@@@Z ; CvPlayer::setStartingPlot

; 1209 : 				uiMinorCivsPlaced++;

	inc	DWORD PTR _uiMinorCivsPlaced$[esp+96]
$LN47@InitMap:

; 1210 : 			}
; 1211 : 		}
; 1212 : 
; 1213 : 		pkPlot->SetContinentType(kPlotData.GetContinentType());

	mov	dl, BYTE PTR [edi+5]
	mov	BYTE PTR $T231251[esp+96], dl
	mov	eax, DWORD PTR $T231251[esp+96]
	push	eax
	mov	ecx, esi
	call	?SetContinentType@CvPlot@@QAEXD@Z	; CvPlot::SetContinentType
$LN69@InitMap:
	add	DWORD PTR tv2564[esp+96], 8
	add	DWORD PTR tv2537[esp+96], 484		; 000001e4H
	inc	ebx
	cmp	ebx, ebp
	jb	$LL548@InitMap
$LN68@InitMap:

; 1214 : 	}
; 1215 : 
; 1216 : 	OutputDebugStringA("Calculating Areas...\n");

	mov	esi, DWORD PTR __imp__OutputDebugStringA@4
	push	OFFSET $SG224971
	call	esi

; 1217 : 
; 1218 : 	kMap.recalculateAreas();

	mov	ecx, DWORD PTR _kMap$[esp+96]
	call	?recalculateAreas@CvMap@@QAEXXZ		; CvMap::recalculateAreas

; 1219 : 
; 1220 : 	OutputDebugStringA("Adding Scenario Elements...\n");

	push	OFFSET $SG224972
	call	esi

; 1221 : 
; 1222 : 	GC.getGame().GetTacticalAnalysisMap()->Init(GC.getMap().numPlots());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	eax, DWORD PTR [ecx+4028]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap
	mov	ecx, eax
	call	?Init@CvTacticalAnalysisMap@@QAEXH@Z	; CvTacticalAnalysisMap::Init

; 1223 : 
; 1224 : 	// Init Diplomacy
; 1225 : 	for(uint uiTeam1 = 0; uiTeam1 < uiTeamCount; ++uiTeam1)

	xor	edi, edi
	cmp	DWORD PTR _uiTeamCount$[esp+96], edi
	jbe	$LN547@InitMap

; 1214 : 	}
; 1215 : 
; 1216 : 	OutputDebugStringA("Calculating Areas...\n");

	mov	DWORD PTR tv2595[esp+96], edi
	npad	3
$LL46@InitMap:

; 1226 : 	{
; 1227 : 		for(uint uiTeam2 = uiTeam1 + 1; uiTeam2 < uiTeamCount; ++uiTeam2)

	lea	esi, DWORD PTR [edi+1]
	mov	DWORD PTR tv1781[esp+96], esi
	cmp	esi, DWORD PTR _uiTeamCount$[esp+96]
	jae	$LN45@InitMap
	mov	edx, DWORD PTR tv2595[esp+96]
	add	edx, 2980				; 00000ba4H
	mov	DWORD PTR tv2585[esp+96], edx
	npad	1
$LL43@InitMap:

; 1228 : 		{
; 1229 : 			const TeamTypes eTeam1 = (TeamTypes)uiTeam1;
; 1230 : 			const TeamTypes eTeam2 = (TeamTypes)uiTeam2;
; 1231 : 			CvTeam& kTeam1 = GET_TEAM(eTeam1);

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, DWORD PTR tv2595[esp+96]

; 1232 : 			CvTeam& kTeam2 = GET_TEAM(eTeam2);

	mov	edx, DWORD PTR tv2585[esp+96]
	lea	ebx, DWORD PTR [ecx+eax]
	lea	ebp, DWORD PTR [edx+eax]

; 1233 : 
; 1234 : 			if(sg_kSave.m_kTeamsInContact.Get(uiTeam1, uiTeam2))

	cmp	edi, esi
	je	SHORT $LN521@InitMap
	jbe	SHORT $LN312@InitMap
	mov	ecx, edi
	mov	edx, esi
	jmp	SHORT $LN311@InitMap
$LN312@InitMap:
	mov	ecx, esi
	mov	edx, edi
$LN311@InitMap:
	lea	eax, DWORD PTR [ecx-1]
	imul	eax, ecx
	shr	eax, 1
	add	eax, edx
	mov	edx, eax
	and	eax, 7
	mov	ecx, eax
	mov	al, 1
	shl	al, cl
	shr	edx, 3
	test	BYTE PTR _sg_kSave[edx], al
	setne	al
	test	al, al
	je	SHORT $LN40@InitMap
$LN521@InitMap:

; 1235 : 				kTeam1.meet(eTeam2, true);

	push	1
	push	esi
	mov	ecx, ebx
	call	?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::meet
$LN40@InitMap:

; 1236 : 
; 1237 : 			if(sg_kSave.m_kTeamsAtWar.Get(uiTeam1, uiTeam2))

	cmp	edi, esi
	je	$LN522@InitMap
	jbe	SHORT $LN322@InitMap
	mov	ecx, edi
	mov	edx, esi
	jmp	SHORT $LN321@InitMap
$LN322@InitMap:
	mov	ecx, esi
	mov	edx, edi
$LN321@InitMap:
	lea	eax, DWORD PTR [ecx-1]
	imul	eax, ecx
	shr	eax, 1
	add	eax, edx
	mov	edx, eax
	and	eax, 7
	mov	ecx, eax
	mov	al, 1
	shl	al, cl
	shr	edx, 3
	test	BYTE PTR _sg_kSave[edx+570], al
	setne	al
	test	al, al
	je	SHORT $LN328@InitMap

; 1238 : 			{
; 1239 : 				kTeam1.setAtWar(eTeam2, true);

	push	1
	push	esi
	mov	ecx, ebx
	call	?setAtWar@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::setAtWar

; 1240 : 				kTeam2.setAtWar(eTeam1, true);

	push	1
	push	edi
	mov	ecx, ebp
	call	?setAtWar@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::setAtWar

; 1241 : 			}
; 1242 : 
; 1243 : 			if(sg_kSave.m_kTeamsAtPermanentWarOrPeace.Get(uiTeam1, uiTeam2))

$LN328@InitMap:
	cmp	edi, esi
	jbe	SHORT $LN332@InitMap
	mov	ecx, edi
	mov	edx, esi
	jmp	SHORT $LN331@InitMap
$LN332@InitMap:
	mov	ecx, esi
	mov	edx, edi
$LN331@InitMap:
	lea	eax, DWORD PTR [ecx-1]
	imul	eax, ecx
	shr	eax, 1
	add	eax, edx
	mov	edx, eax
	and	eax, 7
	mov	ecx, eax
	mov	al, 1
	shl	al, cl
	shr	edx, 3
	test	BYTE PTR _sg_kSave[edx+1140], al
	setne	al
	test	al, al
	je	SHORT $LN38@InitMap
$LN522@InitMap:

; 1244 : 			{
; 1245 : 				kTeam1.setPermanentWarPeace(eTeam2, true);

	push	1
	push	esi
	mov	ecx, ebx
	call	?setPermanentWarPeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setPermanentWarPeace

; 1246 : 				kTeam2.setPermanentWarPeace(eTeam1, true);

	push	1
	push	edi
	mov	ecx, ebp
	call	?setPermanentWarPeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setPermanentWarPeace
$LN38@InitMap:

; 1247 : 			}
; 1248 : 
; 1249 : 			if(sg_kSave.m_kTeamsSharingOpenBorders.Get(uiTeam1, uiTeam2))

	cmp	edi, esi
	je	SHORT $LN523@InitMap
	jbe	SHORT $LN342@InitMap
	mov	ecx, edi
	mov	edx, esi
	jmp	SHORT $LN341@InitMap
$LN342@InitMap:
	mov	ecx, esi
	mov	edx, edi
$LN341@InitMap:
	lea	eax, DWORD PTR [ecx-1]
	imul	eax, ecx
	shr	eax, 1
	add	eax, edx
	mov	edx, eax
	and	eax, 7
	mov	ecx, eax
	mov	al, 1
	shl	al, cl
	shr	edx, 3
	test	BYTE PTR _sg_kSave[edx+1710], al
	setne	al
	test	al, al
	je	SHORT $LN37@InitMap
$LN523@InitMap:

; 1250 : 			{
; 1251 : 				kTeam1.SetAllowsOpenBordersToTeam(eTeam2, true);

	push	1
	push	esi
	mov	ecx, ebx
	call	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetAllowsOpenBordersToTeam

; 1252 : 				kTeam2.SetAllowsOpenBordersToTeam(eTeam1, true);

	push	1
	push	edi
	mov	ecx, ebp
	call	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetAllowsOpenBordersToTeam
$LN37@InitMap:

; 1253 : 			}
; 1254 : 
; 1255 : 			if(sg_kSave.m_kTeamsSharingDefensivePacts.Get(uiTeam1, uiTeam2))

	cmp	edi, esi
	je	SHORT $LN524@InitMap
	jbe	SHORT $LN352@InitMap
	mov	ecx, edi
	mov	edx, esi
	jmp	SHORT $LN351@InitMap
$LN352@InitMap:
	mov	ecx, esi
	mov	edx, edi
$LN351@InitMap:
	lea	eax, DWORD PTR [ecx-1]
	imul	eax, ecx
	shr	eax, 1
	add	eax, edx
	mov	edx, eax
	and	eax, 7
	mov	ecx, eax
	mov	al, 1
	shl	al, cl
	shr	edx, 3
	test	BYTE PTR _sg_kSave[edx+2280], al
	setne	al
	test	al, al
	je	SHORT $LN42@InitMap
$LN524@InitMap:

; 1256 : 			{
; 1257 : 				kTeam1.SetHasDefensivePact(eTeam2, true);

	push	1
	push	esi
	mov	ecx, ebx
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact

; 1258 : 				kTeam2.SetHasDefensivePact(eTeam1, true);

	push	1
	push	edi
	mov	ecx, ebp
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact
$LN42@InitMap:
	add	DWORD PTR tv2585[esp+96], 2980		; 00000ba4H
	inc	esi
	cmp	esi, DWORD PTR _uiTeamCount$[esp+96]
	jb	$LL43@InitMap
$LN45@InitMap:

; 1223 : 
; 1224 : 	// Init Diplomacy
; 1225 : 	for(uint uiTeam1 = 0; uiTeam1 < uiTeamCount; ++uiTeam1)

	mov	edi, DWORD PTR tv1781[esp+96]
	add	DWORD PTR tv2595[esp+96], 2980		; 00000ba4H
	cmp	edi, DWORD PTR _uiTeamCount$[esp+96]
	jb	$LL46@InitMap
$LN547@InitMap:

; 1259 : 			}
; 1260 : 		}
; 1261 : 	}
; 1262 : 
; 1263 : 	// Init City State Relationships
; 1264 : 	for(uint uiCityState = 0; uiCityState < uiCityStateCount; ++uiCityState)

	xor	eax, eax
	mov	DWORD PTR _uiCityState$224992[esp+96], eax
	cmp	DWORD PTR _uiCityStateCount$[esp+96], eax
	jbe	$LN33@InitMap
	mov	ebp, DWORD PTR _uiPlayerCount$[esp+96]
	mov	DWORD PTR tv2677[esp+96], OFFSET _sg_kSave+4032
	npad	3
$LL35@InitMap:

; 1265 : 	{
; 1266 : 		const PlayerTypes eCityStatePlayer = GetPlayerType((byte)(uiCityState + CvWorldBuilderMap::MaxPlayers));

	add	al, 32					; 00000020H
	cmp	al, 32					; 00000020H
	jae	$LN366@InitMap
	cmp	al, 22					; 00000016H
	jae	SHORT $LN34@InitMap
	movzx	eax, al
$LN357@InitMap:

; 1267 : 		if(eCityStatePlayer != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN34@InitMap
$LN525@InitMap:

; 1268 : 		{
; 1269 : 			CvPlayer& kCityState = GET_PLAYER(eCityStatePlayer);

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 1270 : 			CvMinorCivAI* pkAI = kCityState.GetMinorCivAI();

	mov	ecx, eax
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	edi, eax

; 1271 : 			FAssertMsg(pkAI, "Cannot set minor civ influence.  Missing CvMinorCivAI.");
; 1272 : 			if(pkAI != NULL)

	test	edi, edi
	je	SHORT $LN34@InitMap

; 1273 : 			{
; 1274 : 				for(uint uiMajorCiv = 0; uiMajorCiv < uiPlayerCount; ++uiMajorCiv)

	xor	ebx, ebx
	test	ebp, ebp
	jbe	SHORT $LN34@InitMap
	mov	esi, DWORD PTR tv2677[esp+96]
	npad	7
$LL30@InitMap:

; 1275 : 				{
; 1276 : 					const PlayerTypes eMajorCivPlayer = GetPlayerType((byte)uiMajorCiv);

	cmp	bl, 32					; 00000020H
	jae	SHORT $LN380@InitMap
	cmp	bl, 22					; 00000016H
	jae	SHORT $LN29@InitMap
	movzx	eax, bl
$LN371@InitMap:

; 1277 : 					if(eMajorCivPlayer != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN29@InitMap
$LN526@InitMap:

; 1278 : 					{
; 1279 : 						pkAI->SetFriendshipWithMajor(eMajorCivPlayer, sg_kSave.m_aiCityStateInfluence[uiMajorCiv][uiCityState]);

	mov	ecx, DWORD PTR [esi]
	push	0
	push	ecx
	push	eax
	mov	ecx, edi
	call	?SetFriendshipWithMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajor
$LN29@InitMap:
	inc	ebx
	add	esi, 256				; 00000100H
	cmp	ebx, ebp
	jb	SHORT $LL30@InitMap
$LN34@InitMap:

; 1259 : 			}
; 1260 : 		}
; 1261 : 	}
; 1262 : 
; 1263 : 	// Init City State Relationships
; 1264 : 	for(uint uiCityState = 0; uiCityState < uiCityStateCount; ++uiCityState)

	mov	eax, DWORD PTR _uiCityState$224992[esp+96]
	add	DWORD PTR tv2677[esp+96], 4
	inc	eax
	mov	DWORD PTR _uiCityState$224992[esp+96], eax
	cmp	eax, DWORD PTR _uiCityStateCount$[esp+96]
	jb	SHORT $LL35@InitMap
$LN33@InitMap:

; 1280 : 					}
; 1281 : 				}
; 1282 : 			}
; 1283 : 		}
; 1284 : 	}
; 1285 : 
; 1286 : 	// Scenario elements must come after areas have been calculated
; 1287 : 	for(uint i = 0; i < uiPlotCount; ++i)

	xor	ecx, ecx
	mov	DWORD PTR _i$225009[esp+96], ecx
	cmp	DWORD PTR _uiPlotCount$[esp+96], ecx
	jbe	$LN536@InitMap
	mov	DWORD PTR tv2686[esp+96], ecx
	mov	DWORD PTR tv2699[esp+96], OFFSET _sg_kSave+12320
	jmp	SHORT $LN26@InitMap

; 1265 : 	{
; 1266 : 		const PlayerTypes eCityStatePlayer = GetPlayerType((byte)(uiCityState + CvWorldBuilderMap::MaxPlayers));

$LN366@InitMap:
	cmp	al, 96					; 00000060H
	jae	SHORT $LN557@InitMap
	movzx	eax, al
	sub	eax, 32					; 00000020H
	cmp	eax, 41					; 00000029H
	jae	SHORT $LN34@InitMap
	add	eax, 22					; 00000016H
	jmp	$LN357@InitMap
$LN557@InitMap:
	jne	SHORT $LN34@InitMap
	mov	eax, 63					; 0000003fH
	jmp	$LN525@InitMap

; 1275 : 				{
; 1276 : 					const PlayerTypes eMajorCivPlayer = GetPlayerType((byte)uiMajorCiv);

$LN380@InitMap:
	cmp	bl, 96					; 00000060H
	jae	SHORT $LN558@InitMap
	movzx	eax, bl
	sub	eax, 32					; 00000020H
	cmp	eax, 41					; 00000029H
	jae	SHORT $LN29@InitMap
	add	eax, 22					; 00000016H
	jmp	$LN371@InitMap
$LN558@InitMap:
	jne	SHORT $LN29@InitMap
	mov	eax, 63					; 0000003fH
	jmp	$LN526@InitMap
	npad	13
$LL541@InitMap:

; 1280 : 					}
; 1281 : 				}
; 1282 : 			}
; 1283 : 		}
; 1284 : 	}
; 1285 : 
; 1286 : 	// Scenario elements must come after areas have been calculated
; 1287 : 	for(uint i = 0; i < uiPlotCount; ++i)

	mov	ecx, DWORD PTR _i$225009[esp+96]
$LN26@InitMap:

; 1288 : 	{
; 1289 : 		const CvWorldBuilderMap::PlotScenarioData& kPlotData = sg_kSave.GetPlotScenarioData(i);

	mov	eax, DWORD PTR _sg_kSave+12232
	imul	eax, DWORD PTR _sg_kSave+12228
	cmp	ecx, eax
	jae	SHORT $LN384@InitMap
	cmp	ecx, 32768				; 00008000H
	jae	SHORT $LN384@InitMap
	mov	edx, DWORD PTR tv2699[esp+96]
	add	edx, 262144				; 00040000H
	mov	DWORD PTR _kPlotData$225013[esp+96], edx
	jmp	SHORT $LN383@InitMap
$LN384@InitMap:
	mov	DWORD PTR _kPlotData$225013[esp+96], OFFSET ?sm_kErrorPlotScenarioData@CvWorldBuilderMap@@0UPlotScenarioData@1@A ; CvWorldBuilderMap::sm_kErrorPlotScenarioData
$LN383@InitMap:

; 1290 : 		CvPlot* pkPlot = kMap.plotByIndex(i);

	test	ecx, ecx
	jl	$LN25@InitMap
	mov	ecx, DWORD PTR _i$225009[esp+96]
	mov	edx, DWORD PTR _kMap$[esp+96]
	cmp	ecx, DWORD PTR [edx+4028]
	jge	$LN25@InitMap
	mov	ecx, edx
	mov	ebp, DWORD PTR [ecx+4068]
	add	ebp, DWORD PTR tv2686[esp+96]

; 1291 : 		FAssertMsg(pkPlot, "Missing CvPlot for this location");
; 1292 : 		if(pkPlot == NULL) continue;

	je	$LN25@InitMap

; 1293 : 
; 1294 : 		const int iPlotX = pkPlot->getX();
; 1295 : 		const int iPlotY = pkPlot->getY();

	movsx	ecx, WORD PTR [ebp+2]
	movsx	edx, WORD PTR [ebp]
	mov	DWORD PTR _iPlotY$225017[esp+96], ecx

; 1296 : 
; 1297 : 		const byte byNaturalWonder = sg_kSave.GetPlotData(i).GetNaturalWonderType();

	mov	ecx, DWORD PTR _i$225009[esp+96]
	mov	DWORD PTR _iPlotX$225016[esp+96], edx
	cmp	ecx, eax
	jae	SHORT $LN398@InitMap
	mov	eax, DWORD PTR tv2699[esp+96]
	cmp	ecx, 32768				; 00008000H
	jb	SHORT $LN397@InitMap
$LN398@InitMap:
	mov	eax, OFFSET ?sm_kErrorPlotMapData@CvWorldBuilderMap@@0VPlotMapData@1@A ; CvWorldBuilderMap::sm_kErrorPlotMapData
$LN397@InitMap:
	mov	al, BYTE PTR [eax+6]

; 1298 : 		if(byNaturalWonder != CvWorldBuilderMap::PlotMapData::InvalidNaturalWonder)

	cmp	al, 255					; 000000ffH
	je	SHORT $LN542@InitMap

; 1299 : 			pkPlot->setFeatureType((FeatureTypes)byNaturalWonder);

	movzx	edx, al
	push	-1
	push	edx
	mov	ecx, ebp
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType
$LN542@InitMap:

; 1300 : 
; 1301 : 		if(kPlotData.m_byImprovement != CvWorldBuilderMap::PlotScenarioData::InvalidImprovement)

	mov	edi, DWORD PTR _kPlotData$225013[esp+96]
	mov	al, BYTE PTR [edi+5]
	cmp	al, 255					; 000000ffH
	je	SHORT $LN21@InitMap

; 1302 : 			pkPlot->setImprovementType((ImprovementTypes)kPlotData.m_byImprovement);

	movzx	eax, al
	push	-1
	push	eax
	mov	ecx, ebp
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType
$LN21@InitMap:

; 1303 : 
; 1304 : 		if(kPlotData.m_byRoute != CvWorldBuilderMap::PlotScenarioData::InvalidImprovement)

	mov	al, BYTE PTR [edi+6]
	cmp	al, 255					; 000000ffH
	je	$LN533@InitMap

; 1305 : 		{
; 1306 : 			RouteTypes eRoute;
; 1307 : 			if(kPlotData.m_byRoute == 0)

	xor	ebx, ebx
	test	al, al
	setne	bl

; 1308 : 				eRoute = ROUTE_ROAD;
; 1309 : 			else
; 1310 : 				eRoute = ROUTE_RAILROAD;
; 1311 : 
; 1312 : 			pkPlot->setRouteType(eRoute);

	mov	ecx, ebp
	push	ebx
	call	?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z ; CvPlot::setRouteType

; 1313 : 
; 1314 : 			const PlayerTypes eOwner = GetPlayerType(kPlotData.m_byRouteOwner);

	mov	al, BYTE PTR [edi+7]
	cmp	al, 32					; 00000020H
	jae	$LN412@InitMap
	cmp	al, 22					; 00000016H
	jae	SHORT $LN533@InitMap
	movzx	esi, al
$LN403@InitMap:

; 1315 : 			if(eOwner != NO_PLAYER && !pkPlot->isOwned())

	cmp	esi, -1
	je	SHORT $LN533@InitMap
$LN527@InitMap:
	mov	ecx, ebp
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	test	al, al
	jne	SHORT $LN533@InitMap

; 1316 : 			{
; 1317 : 				// Mark the player as responsible for this route and update the treasury
; 1318 : 				CvTreasury* pkTreasury = GET_PLAYER(eOwner).GetTreasury();

	mov	ecx, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury

; 1319 : 				const CvRouteInfo* pkRouteInfo = GC.getRouteInfo(eRoute);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	ebx, eax

; 1320 : 				if(pkTreasury != NULL && pkRouteInfo != NULL)

	test	edi, edi
	je	SHORT $LN543@InitMap
	test	ebx, ebx
	je	SHORT $LN543@InitMap

; 1321 : 				{
; 1322 : 					if(pkPlot->MustPayMaintenanceHere(eOwner))

	push	esi
	mov	ecx, ebp
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	test	al, al
	je	SHORT $LN15@InitMap

; 1323 : 					{
; 1324 : 						pkTreasury->ChangeBaseImprovementGoldMaintenance(pkRouteInfo->GetGoldMaintenance());

	mov	ecx, ebx
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	push	eax
	mov	ecx, edi
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN15@InitMap:

; 1325 : 					}
; 1326 : 					pkPlot->SetPlayerResponsibleForRoute(eOwner);

	push	esi
	mov	ecx, ebp
	call	?SetPlayerResponsibleForRoute@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerResponsibleForRoute
$LN543@InitMap:
	mov	edi, DWORD PTR _kPlotData$225013[esp+96]
$LN533@InitMap:

; 1327 : 				}
; 1328 : 			}
; 1329 : 		}
; 1330 : 
; 1331 : 		const CvWorldBuilderMap::City* pkCity = sg_kSave.m_kCities[kPlotData.m_hCity];

	movzx	eax, WORD PTR [edi]

; 1332 : 		if(pkCity != NULL)
; 1333 : 		{
; 1334 : 			SetupCity(*pkCity, iPlotX, iPlotY);

	mov	ebx, DWORD PTR _iPlotX$225016[esp+96]
	cmp	eax, DWORD PTR _sg_kSave+2884
	jae	SHORT $LN14@InitMap
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _sg_kSave+2876
	test	eax, eax
	je	SHORT $LN14@InitMap
	mov	ecx, DWORD PTR _iPlotY$225017[esp+96]
	push	ecx
	push	ebx
	push	eax
	call	?SetupCity@@YAXABUCity@CvWorldBuilderMap@@HH@Z ; SetupCity
	add	esp, 12					; 0000000cH
$LN14@InitMap:

; 1335 : 		}
; 1336 : 
; 1337 : 		// Note - All calls to SetupUnit for this plot must come after SetupCity for this plot.
; 1338 : 		// This is because of garrisoned units that need the city to be there first.
; 1339 : 		for(const CvWorldBuilderMap::Unit* pkUnit = sg_kSave.m_kUnits[kPlotData.m_hUnitStack];

	movzx	esi, WORD PTR [edi+2]
	cmp	esi, DWORD PTR _sg_kSave+2860
	jae	SHORT $LN534@InitMap
	imul	esi, 84					; 00000054H
	add	esi, DWORD PTR _sg_kSave+2852

; 1340 : 		        pkUnit != NULL;
; 1341 : 		        pkUnit = sg_kSave.m_kUnits[pkUnit->m_hStackedUnit])

	test	esi, esi
	je	SHORT $LN534@InitMap
	mov	edi, DWORD PTR _iPlotY$225017[esp+96]
	npad	1
$LL425@InitMap:

; 1342 : 		{
; 1343 : 			SetupUnit(*pkUnit, iPlotX, iPlotY);

	push	edi
	push	ebx
	push	esi
	call	?SetupUnit@@YAXABUUnit@CvWorldBuilderMap@@HH@Z ; SetupUnit
	movzx	eax, WORD PTR [esi]
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _sg_kSave+2860
	jae	SHORT $LN534@InitMap
	imul	eax, 84					; 00000054H
	add	eax, DWORD PTR _sg_kSave+2852
	mov	esi, eax
	jne	SHORT $LL425@InitMap
$LN534@InitMap:

; 1344 : 		}
; 1345 : 
; 1346 : 		for(uint uiTeam = 0; uiTeam < uiTeamCount; ++uiTeam)

	xor	esi, esi
	cmp	DWORD PTR _uiTeamCount$[esp+96], esi
	jbe	SHORT $LN25@InitMap
	mov	edi, DWORD PTR _sg_kSave+12228
$LL10@InitMap:

; 1347 : 		{
; 1348 : 			if(sg_kSave.GetVisibility(iPlotX, iPlotY, uiTeam))

	mov	ecx, DWORD PTR _sg_kSave+12232
	mov	eax, DWORD PTR _iPlotY$225017[esp+96]
	imul	ecx, edi
	imul	ecx, esi
	imul	eax, edi
	add	ecx, ebx
	add	eax, ecx
	mov	edx, eax
	and	eax, 7
	mov	ecx, eax
	mov	al, 1
	shr	edx, 3
	shl	al, cl
	cmp	edx, 393216				; 00060000H
	jae	SHORT $LN9@InitMap
	test	BYTE PTR _sg_kSave[edx+584672], al
	setne	al
	test	al, al
	je	SHORT $LN9@InitMap

; 1349 : 				pkPlot->setRevealed((TeamTypes)uiTeam, true);

	push	-1
	push	0
	push	1
	push	esi
	mov	ecx, ebp
	call	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ; CvPlot::setRevealed
	mov	edi, DWORD PTR _sg_kSave+12228
$LN9@InitMap:
	inc	esi
	cmp	esi, DWORD PTR _uiTeamCount$[esp+96]
	jb	SHORT $LL10@InitMap
$LN25@InitMap:

; 1280 : 					}
; 1281 : 				}
; 1282 : 			}
; 1283 : 		}
; 1284 : 	}
; 1285 : 
; 1286 : 	// Scenario elements must come after areas have been calculated
; 1287 : 	for(uint i = 0; i < uiPlotCount; ++i)

	mov	eax, DWORD PTR _i$225009[esp+96]
	add	DWORD PTR tv2686[esp+96], 484		; 000001e4H
	add	DWORD PTR tv2699[esp+96], 8
	inc	eax
	mov	DWORD PTR _i$225009[esp+96], eax
	cmp	eax, DWORD PTR _uiPlotCount$[esp+96]
	jb	$LL541@InitMap
$LN536@InitMap:

; 1350 : 		}
; 1351 : 	}
; 1352 : 
; 1353 : 	// Set culture.  This must come after all cities have been added.
; 1354 : 	for(uint i = 0; i < uiPlotCount; ++i)

	xor	ebp, ebp
	cmp	DWORD PTR _uiPlotCount$[esp+96], ebp
	jbe	$LN540@InitMap
	mov	ecx, DWORD PTR _kMap$[esp+96]
	mov	eax, OFFSET _sg_kSave+274464
	mov	DWORD PTR tv2715[esp+96], ebp
	mov	DWORD PTR tv2727[esp+96], eax
	npad	13
$LL551@InitMap:

; 1355 : 	{
; 1356 : 		const CvWorldBuilderMap::PlotScenarioData& kPlotData = sg_kSave.GetPlotScenarioData(i);

	mov	edx, DWORD PTR _sg_kSave+12232
	imul	edx, DWORD PTR _sg_kSave+12228
	cmp	ebp, edx
	jae	SHORT $LN436@InitMap
	cmp	ebp, 32768				; 00008000H
	jb	SHORT $LN435@InitMap
$LN436@InitMap:
	mov	eax, OFFSET ?sm_kErrorPlotScenarioData@CvWorldBuilderMap@@0UPlotScenarioData@1@A ; CvWorldBuilderMap::sm_kErrorPlotScenarioData
$LN435@InitMap:

; 1357 : 		CvPlot* pkPlot = kMap.plotByIndex(i);

	test	ebp, ebp
	jl	SHORT $LN5@InitMap
	cmp	ebp, DWORD PTR [ecx+4028]
	jge	SHORT $LN5@InitMap
	mov	edi, DWORD PTR [ecx+4068]
	add	edi, DWORD PTR tv2715[esp+96]

; 1358 : 		FAssertMsg(pkPlot, "Missing CvPlot for this location");
; 1359 : 		if(pkPlot == NULL) continue;

	je	SHORT $LN5@InitMap

; 1360 : 
; 1361 : 		const PlayerTypes eOwner = GetPlayerType(kPlotData.m_byCulture);

	mov	al, BYTE PTR [eax+4]
	cmp	al, 32					; 00000020H
	jae	$LN454@InitMap
	cmp	al, 22					; 00000016H
	jae	SHORT $LN5@InitMap
	movzx	esi, al
$LN445@InitMap:

; 1362 : 		if(eOwner != NO_PLAYER)

	cmp	esi, -1
	je	SHORT $LN5@InitMap
$LN529@InitMap:

; 1363 : 		{
; 1364 : 			int iCityID = 0;
; 1365 : 			const CvCity* pkCity = FindClosestCity(eOwner, *pkPlot);

	push	edi
	push	esi
	xor	ebx, ebx
	call	?FindClosestCity@@YAPBVCvCity@@W4PlayerTypes@@ABVCvPlot@@@Z ; FindClosestCity
	add	esp, 8

; 1366 : 			if(pkCity) iCityID = pkCity->GetID();

	test	eax, eax
	je	SHORT $LN457@InitMap
	mov	ebx, DWORD PTR [eax+120]
$LN457@InitMap:

; 1367 : 			pkPlot->setOwner(eOwner, iCityID);

	push	1
	push	1
	push	ebx
	push	esi
	mov	ecx, edi
	call	?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z ; CvPlot::setOwner
	mov	ecx, DWORD PTR _kMap$[esp+96]
$LN5@InitMap:
	mov	eax, DWORD PTR tv2727[esp+96]
	add	DWORD PTR tv2715[esp+96], 484		; 000001e4H
	inc	ebp
	add	eax, 8
	mov	DWORD PTR tv2727[esp+96], eax
	cmp	ebp, DWORD PTR _uiPlotCount$[esp+96]
	jb	$LL551@InitMap
$LN540@InitMap:

; 1368 : 		}
; 1369 : 	}
; 1370 : 
; 1371 : 	OutputDebugStringA("Map Load Success!\n");

	push	OFFSET $SG225057
	call	DWORD PTR __imp__OutputDebugStringA@4

; 1372 : 
; 1373 : 	return true;

	mov	eax, DWORD PTR _kMinorCivs$[esp+96]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+108], 0
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	mov	ecx, DWORD PTR _kMajorCivs$[esp+100]
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking

; 1374 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+104]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	0

; 1313 : 
; 1314 : 			const PlayerTypes eOwner = GetPlayerType(kPlotData.m_byRouteOwner);

$LN412@InitMap:
	cmp	al, 96					; 00000060H
	jae	SHORT $LN559@InitMap
	movzx	eax, al
	sub	eax, 32					; 00000020H
	cmp	eax, 41					; 00000029H
	jae	$LN533@InitMap
	lea	esi, DWORD PTR [eax+22]
	jmp	$LN403@InitMap
$LN559@InitMap:
	jne	$LN533@InitMap
	mov	esi, 63					; 0000003fH
	jmp	$LN527@InitMap

; 1360 : 
; 1361 : 		const PlayerTypes eOwner = GetPlayerType(kPlotData.m_byCulture);

$LN454@InitMap:
	cmp	al, 96					; 00000060H
	jae	SHORT $LN560@InitMap
	movzx	eax, al
	sub	eax, 32					; 00000020H
	cmp	eax, 41					; 00000029H
	jae	$LN5@InitMap
	lea	esi, DWORD PTR [eax+22]
	jmp	$LN445@InitMap
$LN560@InitMap:
	jne	$LN5@InitMap
	mov	esi, 63					; 0000003fH
	jmp	$LN529@InitMap
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InitMap@CvWorldBuilderMapLoader@@SA_NXZ$0:
	lea	ecx, DWORD PTR _kMajorCivs$[ebp]
	jmp	??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>
__unwindfunclet$?InitMap@CvWorldBuilderMapLoader@@SA_NXZ$1:
	lea	ecx, DWORD PTR _kMinorCivs$[ebp]
	jmp	??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>
__ehhandler$?InitMap@CvWorldBuilderMapLoader@@SA_NXZ:
	mov	eax, OFFSET __ehfuncinfo$?InitMap@CvWorldBuilderMapLoader@@SA_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?InitMap@CvWorldBuilderMapLoader@@SA_NXZ ENDP		; CvWorldBuilderMapLoader::InitMap
PUBLIC	?GetCurrentWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@XZ ; CvWorldBuilderMapLoader::GetCurrentWorldSizeType
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@XZ
_TEXT	SEGMENT
?GetCurrentWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@XZ PROC ; CvWorldBuilderMapLoader::GetCurrentWorldSizeType, COMDAT

; 1919 : 	return GetWorldSizeType(sg_kSave);

	push	OFFSET _sg_kSave
	call	?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z ; CvWorldBuilderMapLoader::GetWorldSizeType
	add	esp, 4

; 1920 : }

	ret	0
?GetCurrentWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@XZ ENDP ; CvWorldBuilderMapLoader::GetCurrentWorldSizeType
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXPAVString@CvWorldBuilderMapTypeDesc@@0@Z ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXPAVString@CvWorldBuilderMapTypeDesc@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXPAVString@CvWorldBuilderMapTypeDesc@@0@Z PROC ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXPAVString@CvWorldBuilderMapTypeDesc@@0@Z ENDP ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXXZ ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXXZ PROC ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Tidy
_TEXT	ENDS
PUBLIC	??1?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::~vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ PROC ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::~vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::~vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@0@Z ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@0@Z PROC ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase
	push	ebx
	npad	4
$LL28@erase:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	add	edx, 4
	add	esi, 4
	cmp	edx, edi
	jne	SHORT $LL28@erase
	pop	ebx
$LN26@erase:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@0@Z ENDP ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::erase
_TEXT	ENDS
PUBLIC	??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ	; CvWorldBuilderMapTypeDesc::TypeMap::~TypeMap
; Function compile flags: /Ogtpy
;	COMDAT ??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ
_TEXT	SEGMENT
??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ PROC	; CvWorldBuilderMapTypeDesc::TypeMap::~TypeMap, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN9@TypeMap
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@TypeMap:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi
	ret	0
??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ ENDP	; CvWorldBuilderMapTypeDesc::TypeMap::~TypeMap
_TEXT	ENDS
PUBLIC	?clear@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAEXXZ ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAEXXZ PROC ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::clear, COMDAT
; _this$ = ecx

; 1060 : 		erase(begin(), end());

	mov	edx, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, edx
	je	SHORT $LN15@clear
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN40@clear
	push	edi
$LL42@clear:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [esi], edi
	add	eax, 4
	add	esi, 4
	cmp	eax, edx
	jne	SHORT $LL42@clear
	pop	edi
$LN40@clear:
	mov	DWORD PTR [ecx+8], esi
$LN15@clear:
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::clear
_TEXT	ENDS
PUBLIC	?Clear@TypeMap@CvWorldBuilderMapTypeDesc@@QAEXXZ ; CvWorldBuilderMapTypeDesc::TypeMap::Clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvworldbuildermap\include\cvworldbuildermaptypedesc.h
;	COMDAT ?Clear@TypeMap@CvWorldBuilderMapTypeDesc@@QAEXXZ
_TEXT	SEGMENT
?Clear@TypeMap@CvWorldBuilderMapTypeDesc@@QAEXXZ PROC	; CvWorldBuilderMapTypeDesc::TypeMap::Clear, COMDAT
; _this$ = ecx

; 57   : 		void Clear() { asTypes.clear(); };

	mov	edx, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, edx
	je	SHORT $LN17@Clear
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN42@Clear
	push	edi
$LL44@Clear:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [esi], edi
	add	eax, 4
	add	esi, 4
	cmp	eax, edx
	jne	SHORT $LL44@Clear
	pop	edi
$LN42@Clear:
	mov	DWORD PTR [ecx+8], esi
$LN17@Clear:
	pop	esi
	ret	0
?Clear@TypeMap@CvWorldBuilderMapTypeDesc@@QAEXXZ ENDP	; CvWorldBuilderMapTypeDesc::TypeMap::Clear
_TEXT	ENDS
PUBLIC	??1CvWorldBuilderMapTypeDesc@@QAE@XZ		; CvWorldBuilderMapTypeDesc::~CvWorldBuilderMapTypeDesc
; Function compile flags: /Ogtpy
;	COMDAT ??1CvWorldBuilderMapTypeDesc@@QAE@XZ
_TEXT	SEGMENT
??1CvWorldBuilderMapTypeDesc@@QAE@XZ PROC		; CvWorldBuilderMapTypeDesc::~CvWorldBuilderMapTypeDesc, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+148]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN20@CvWorldBui
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN20@CvWorldBui:
	mov	DWORD PTR [esi+148], edi
	mov	DWORD PTR [esi+152], edi
	mov	DWORD PTR [esi+156], edi
	mov	eax, DWORD PTR [esi+132]
	cmp	eax, edi
	je	SHORT $LN29@CvWorldBui
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN29@CvWorldBui:
	mov	DWORD PTR [esi+132], edi
	mov	DWORD PTR [esi+136], edi
	mov	DWORD PTR [esi+140], edi
	mov	eax, DWORD PTR [esi+116]
	cmp	eax, edi
	je	SHORT $LN38@CvWorldBui
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN38@CvWorldBui:
	mov	DWORD PTR [esi+116], edi
	mov	DWORD PTR [esi+120], edi
	mov	DWORD PTR [esi+124], edi
	mov	eax, DWORD PTR [esi+100]
	cmp	eax, edi
	je	SHORT $LN47@CvWorldBui
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN47@CvWorldBui:
	mov	DWORD PTR [esi+100], edi
	mov	DWORD PTR [esi+104], edi
	mov	DWORD PTR [esi+108], edi
	mov	eax, DWORD PTR [esi+84]
	cmp	eax, edi
	je	SHORT $LN56@CvWorldBui
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN56@CvWorldBui:
	mov	DWORD PTR [esi+84], edi
	mov	DWORD PTR [esi+88], edi
	mov	DWORD PTR [esi+92], edi
	mov	eax, DWORD PTR [esi+68]
	cmp	eax, edi
	je	SHORT $LN65@CvWorldBui
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN65@CvWorldBui:
	mov	DWORD PTR [esi+68], edi
	mov	DWORD PTR [esi+72], edi
	mov	DWORD PTR [esi+76], edi
	mov	eax, DWORD PTR [esi+52]
	cmp	eax, edi
	je	SHORT $LN74@CvWorldBui
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN74@CvWorldBui:
	mov	DWORD PTR [esi+52], edi
	mov	DWORD PTR [esi+56], edi
	mov	DWORD PTR [esi+60], edi
	mov	eax, DWORD PTR [esi+36]
	cmp	eax, edi
	je	SHORT $LN83@CvWorldBui
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN83@CvWorldBui:
	mov	DWORD PTR [esi+36], edi
	mov	DWORD PTR [esi+40], edi
	mov	DWORD PTR [esi+44], edi
	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	je	SHORT $LN92@CvWorldBui
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN92@CvWorldBui:
	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+28], edi
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN101@CvWorldBui
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN101@CvWorldBui:
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	pop	edi
	pop	esi
	ret	0
??1CvWorldBuilderMapTypeDesc@@QAE@XZ ENDP		; CvWorldBuilderMapTypeDesc::~CvWorldBuilderMapTypeDesc
_TEXT	ENDS
PUBLIC	?InitTypeDesc@@YAXXZ				; InitTypeDesc
EXTRN	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z:PROC ; CvGlobals::getPromotionInfo
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
EXTRN	?getNumUnitInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumUnitInfos
EXTRN	?getNumImprovementInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumImprovementInfos
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z:PROC ; CvGlobals::getFeatureInfo
EXTRN	?getNumFeatureInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumFeatureInfos
EXTRN	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z:PROC ; CvWorldBuilderMapTypeDesc::TypeMap::Add
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
;	COMDAT ?InitTypeDesc@@YAXXZ
_TEXT	SEGMENT
?InitTypeDesc@@YAXXZ PROC				; InitTypeDesc, COMDAT

; 31   : 	//static bool bFirst = true;
; 32   : 	//if( bFirst ) // Do this every time as mod data may have changed.
; 33   : 	{
; 34   : 		sg_kMapTypeDesc.m_kTerrainTypes.Clear();

	mov	eax, DWORD PTR _sg_kMapTypeDesc+4
	cmp	eax, DWORD PTR _sg_kMapTypeDesc+8
	je	SHORT $LN64@InitTypeDe
	mov	DWORD PTR _sg_kMapTypeDesc+8, eax
$LN64@InitTypeDe:
	push	esi
	push	edi

; 35   : 		const int iTerrainTypeCount = GC.getNumTerrainInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	mov	edi, eax

; 36   : 		for(int i = 0; i < iTerrainTypeCount; ++i)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN43@InitTypeDe
	npad	10
$LL45@InitTypeDe:

; 37   : 		{
; 38   : 			const CvTerrainInfo* pkTerrainInfo = GC.getTerrainInfo((TerrainTypes)i);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo

; 39   : 			if(pkTerrainInfo != NULL)

	test	eax, eax
	je	SHORT $LN42@InitTypeDe

; 40   : 			{
; 41   : 				sg_kMapTypeDesc.m_kTerrainTypes.Add( pkTerrainInfo->GetType() );

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax

; 42   : 			}
; 43   : 			else

	jmp	SHORT $LN518@InitTypeDe
$LN42@InitTypeDe:

; 44   : 			{
; 45   : 				sg_kMapTypeDesc.m_kTerrainTypes.Add( NULL );

	push	0
$LN518@InitTypeDe:
	mov	ecx, OFFSET _sg_kMapTypeDesc
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL45@InitTypeDe
$LN43@InitTypeDe:

; 46   : 			}
; 47   : 		}
; 48   : 
; 49   : 		sg_kMapTypeDesc.m_kFeatures.Clear();

	mov	eax, DWORD PTR _sg_kMapTypeDesc+20
	cmp	eax, DWORD PTR _sg_kMapTypeDesc+24
	je	SHORT $LN112@InitTypeDe
	mov	DWORD PTR _sg_kMapTypeDesc+24, eax
$LN112@InitTypeDe:
	push	ebx

; 50   : 		const int iFeatureCount = GC.getNumFeatureInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	mov	ebx, eax

; 51   : 		for(int i = 0; i < iFeatureCount; ++i)

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN38@InitTypeDe
$LL40@InitTypeDe:

; 52   : 		{
; 53   : 			const CvFeatureInfo* pkFeatureInfo = GC.getFeatureInfo((FeatureTypes)i);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo

; 54   : 			if(pkFeatureInfo != NULL)

	test	eax, eax
	je	SHORT $LN37@InitTypeDe

; 55   : 			{
; 56   : 				sg_kMapTypeDesc.m_kFeatures.Add( pkFeatureInfo->GetType() );

	lea	esi, DWORD PTR [eax+176]
	mov	ecx, esi
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET _sg_kMapTypeDesc+16
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add

; 57   : 				sg_kMapTypeDesc.m_kNaturalWonders.Add( pkFeatureInfo->GetType() );

	mov	ecx, esi
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax

; 58   : 			}
; 59   : 			else

	jmp	SHORT $LN519@InitTypeDe
$LN37@InitTypeDe:

; 60   : 			{
; 61   : 				sg_kMapTypeDesc.m_kFeatures.Add( NULL );

	push	0
	mov	ecx, OFFSET _sg_kMapTypeDesc+16
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add

; 62   : 				sg_kMapTypeDesc.m_kNaturalWonders.Add( NULL );

	push	0
$LN519@InitTypeDe:
	mov	ecx, OFFSET _sg_kMapTypeDesc+32
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add
	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL40@InitTypeDe
$LN38@InitTypeDe:

; 63   : 			}
; 64   : 		}
; 65   : 
; 66   : 		sg_kMapTypeDesc.m_kResources.Clear();

	mov	eax, DWORD PTR _sg_kMapTypeDesc+52
	pop	ebx
	cmp	eax, DWORD PTR _sg_kMapTypeDesc+56
	je	SHORT $LN162@InitTypeDe
	mov	DWORD PTR _sg_kMapTypeDesc+56, eax
$LN162@InitTypeDe:

; 67   : 		const int iResourceCount = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	edi, eax

; 68   : 		for(int i = 0; i < iResourceCount; ++i)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN33@InitTypeDe
	npad	7
$LL35@InitTypeDe:

; 69   : 		{
; 70   : 			const CvResourceInfo* pkResourceInfo = GC.getResourceInfo((ResourceTypes)i);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 71   : 			if(pkResourceInfo != NULL)

	test	eax, eax
	je	SHORT $LN32@InitTypeDe

; 72   : 			{
; 73   : 				sg_kMapTypeDesc.m_kResources.Add( pkResourceInfo->GetType() );

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax

; 74   : 			}
; 75   : 			else

	jmp	SHORT $LN520@InitTypeDe
$LN32@InitTypeDe:

; 76   : 			{
; 77   : 				sg_kMapTypeDesc.m_kResources.Add( NULL );

	push	0
$LN520@InitTypeDe:
	mov	ecx, OFFSET _sg_kMapTypeDesc+48
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL35@InitTypeDe
$LN33@InitTypeDe:

; 78   : 			}
; 79   : 		}
; 80   : 
; 81   : 		sg_kMapTypeDesc.m_kImprovements.Clear();

	mov	eax, DWORD PTR _sg_kMapTypeDesc+68
	cmp	eax, DWORD PTR _sg_kMapTypeDesc+72
	je	SHORT $LN210@InitTypeDe
	mov	DWORD PTR _sg_kMapTypeDesc+72, eax
$LN210@InitTypeDe:

; 82   : 		const int iImprovementCount = GC.getNumImprovementInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	mov	edi, eax

; 83   : 		for(int i = 0; i < iImprovementCount; ++i)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN28@InitTypeDe
$LL30@InitTypeDe:

; 84   : 		{
; 85   : 			const CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo((ImprovementTypes)i);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo

; 86   : 			if(pkImprovementInfo != NULL)

	test	eax, eax
	je	SHORT $LN27@InitTypeDe

; 87   : 			{
; 88   : 				sg_kMapTypeDesc.m_kImprovements.Add( pkImprovementInfo->GetType() );

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax

; 89   : 			}
; 90   : 			else

	jmp	SHORT $LN521@InitTypeDe
$LN27@InitTypeDe:

; 91   : 			{
; 92   : 				sg_kMapTypeDesc.m_kImprovements.Add( NULL );

	push	0
$LN521@InitTypeDe:
	mov	ecx, OFFSET _sg_kMapTypeDesc+64
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL30@InitTypeDe
$LN28@InitTypeDe:

; 93   : 			}
; 94   : 		}
; 95   : 
; 96   : 		sg_kMapTypeDesc.m_kUnits.Clear();

	mov	eax, DWORD PTR _sg_kMapTypeDesc+84
	cmp	eax, DWORD PTR _sg_kMapTypeDesc+88
	je	SHORT $LN258@InitTypeDe
	mov	DWORD PTR _sg_kMapTypeDesc+88, eax
$LN258@InitTypeDe:

; 97   : 		const int iUnitCount = GC.getNumUnitInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitInfos
	mov	edi, eax

; 98   : 		for(int i = 0; i < iUnitCount; ++i)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN23@InitTypeDe
	npad	10
$LL25@InitTypeDe:

; 99   : 		{
; 100  : 			const CvUnitEntry* pkUnitInfo = GC.getUnitInfo((UnitTypes)i);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo

; 101  : 			if(pkUnitInfo != NULL)

	test	eax, eax
	je	SHORT $LN22@InitTypeDe

; 102  : 			{
; 103  : 				sg_kMapTypeDesc.m_kUnits.Add( pkUnitInfo->GetType() );

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax

; 104  : 			}
; 105  : 			else

	jmp	SHORT $LN522@InitTypeDe
$LN22@InitTypeDe:

; 106  : 			{
; 107  : 				sg_kMapTypeDesc.m_kUnits.Add( NULL );

	push	0
$LN522@InitTypeDe:
	mov	ecx, OFFSET _sg_kMapTypeDesc+80
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL25@InitTypeDe
$LN23@InitTypeDe:

; 108  : 			}
; 109  : 		}
; 110  : 
; 111  : 		sg_kMapTypeDesc.m_kTechs.Clear();

	mov	eax, DWORD PTR _sg_kMapTypeDesc+116
	cmp	eax, DWORD PTR _sg_kMapTypeDesc+120
	je	SHORT $LN306@InitTypeDe
	mov	DWORD PTR _sg_kMapTypeDesc+120, eax
$LN306@InitTypeDe:

; 112  : 		const int iTechCount = GC.getNumTechInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	mov	edi, eax

; 113  : 		for(int i = 0; i < iTechCount; ++i)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN18@InitTypeDe
$LL20@InitTypeDe:

; 114  : 		{
; 115  : 			const CvTechEntry* pkTechInfo = GC.getTechInfo((TechTypes)i);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo

; 116  : 			if(pkTechInfo != NULL)

	test	eax, eax
	je	SHORT $LN17@InitTypeDe

; 117  : 			{
; 118  : 				sg_kMapTypeDesc.m_kTechs.Add( pkTechInfo->GetType() );

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax

; 119  : 			}
; 120  : 			else

	jmp	SHORT $LN523@InitTypeDe
$LN17@InitTypeDe:

; 121  : 			{
; 122  : 				sg_kMapTypeDesc.m_kTechs.Add( NULL );

	push	0
$LN523@InitTypeDe:
	mov	ecx, OFFSET _sg_kMapTypeDesc+112
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL20@InitTypeDe
$LN18@InitTypeDe:

; 123  : 			}
; 124  : 		}
; 125  : 
; 126  : 		sg_kMapTypeDesc.m_kPolicies.Clear();

	mov	eax, DWORD PTR _sg_kMapTypeDesc+132
	cmp	eax, DWORD PTR _sg_kMapTypeDesc+136
	je	SHORT $LN354@InitTypeDe
	mov	DWORD PTR _sg_kMapTypeDesc+136, eax
$LN354@InitTypeDe:

; 127  : 		const int iPolicyCount = GC.getNumPolicyInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos
	mov	edi, eax

; 128  : 		for(int i = 0; i < iPolicyCount; ++i)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN13@InitTypeDe
	npad	10
$LL15@InitTypeDe:

; 129  : 		{
; 130  : 			const CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo((PolicyTypes)i);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo

; 131  : 			if(pkPolicyInfo != NULL)

	test	eax, eax
	je	SHORT $LN12@InitTypeDe

; 132  : 			{
; 133  : 				sg_kMapTypeDesc.m_kPolicies.Add( pkPolicyInfo->GetType() );

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax

; 134  : 			}
; 135  : 			else

	jmp	SHORT $LN524@InitTypeDe
$LN12@InitTypeDe:

; 136  : 			{
; 137  : 				sg_kMapTypeDesc.m_kPolicies.Add( NULL );

	push	0
$LN524@InitTypeDe:
	mov	ecx, OFFSET _sg_kMapTypeDesc+128
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL15@InitTypeDe
$LN13@InitTypeDe:

; 138  : 			}
; 139  : 		}
; 140  : 
; 141  : 		sg_kMapTypeDesc.m_kBuildingTypes.Clear();

	mov	eax, DWORD PTR _sg_kMapTypeDesc+100
	cmp	eax, DWORD PTR _sg_kMapTypeDesc+104
	je	SHORT $LN402@InitTypeDe
	mov	DWORD PTR _sg_kMapTypeDesc+104, eax
$LN402@InitTypeDe:

; 142  : 		const int iBuildingCount = GC.getNumBuildingInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	mov	edi, eax

; 143  : 		for(int i = 0; i < iBuildingCount; ++i)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN8@InitTypeDe
$LL10@InitTypeDe:

; 144  : 		{
; 145  : 			const CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo((BuildingTypes)i);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 146  : 			if(pkBuildingInfo != NULL)

	test	eax, eax
	je	SHORT $LN7@InitTypeDe

; 147  : 			{
; 148  : 				sg_kMapTypeDesc.m_kBuildingTypes.Add( pkBuildingInfo->GetType() );

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax

; 149  : 			}
; 150  : 			else

	jmp	SHORT $LN525@InitTypeDe
$LN7@InitTypeDe:

; 151  : 			{
; 152  : 				sg_kMapTypeDesc.m_kBuildingTypes.Add( NULL );

	push	0
$LN525@InitTypeDe:
	mov	ecx, OFFSET _sg_kMapTypeDesc+96
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL10@InitTypeDe
$LN8@InitTypeDe:

; 153  : 			}
; 154  : 		}
; 155  : 
; 156  : 		sg_kMapTypeDesc.m_kUnitPromotions.Clear();

	mov	eax, DWORD PTR _sg_kMapTypeDesc+148
	cmp	eax, DWORD PTR _sg_kMapTypeDesc+152
	je	SHORT $LN450@InitTypeDe
	mov	DWORD PTR _sg_kMapTypeDesc+152, eax
$LN450@InitTypeDe:

; 157  : 		const int iPromotionCount = GC.getNumPromotionInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	mov	edi, eax

; 158  : 		for(int i = 0; i < iPromotionCount; ++i)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN3@InitTypeDe
	npad	10
$LL5@InitTypeDe:

; 159  : 		{
; 160  : 			const CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo((PromotionTypes)i);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo

; 161  : 			if(pkPromotionInfo != NULL)

	test	eax, eax
	je	SHORT $LN2@InitTypeDe

; 162  : 			{
; 163  : 				sg_kMapTypeDesc.m_kUnitPromotions.Add( pkPromotionInfo->GetType() );

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax

; 164  : 			}
; 165  : 			else

	jmp	SHORT $LN526@InitTypeDe
$LN2@InitTypeDe:

; 166  : 			{
; 167  : 				sg_kMapTypeDesc.m_kUnitPromotions.Add( NULL );

	push	0
$LN526@InitTypeDe:
	mov	ecx, OFFSET _sg_kMapTypeDesc+144
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL5@InitTypeDe
$LN3@InitTypeDe:
	pop	edi
	pop	esi

; 168  : 			}
; 169  : 		}
; 170  : 
; 171  : 		//bFirst = false;
; 172  : 	}
; 173  : }

	ret	0
?InitTypeDesc@@YAXXZ ENDP				; InitTypeDesc
_TEXT	ENDS
PUBLIC	?Preload@CvWorldBuilderMapLoader@@SA_NPB_W_N@Z	; CvWorldBuilderMapLoader::Preload
EXTRN	?SwapPlayers@CvWorldBuilderMap@@QAEXEE@Z:PROC	; CvWorldBuilderMap::SwapPlayers
EXTRN	?ClearScenarioData@CvWorldBuilderMap@@QAEX_N@Z:PROC ; CvWorldBuilderMap::ClearScenarioData
; Function compile flags: /Ogtpy
;	COMDAT ?Preload@CvWorldBuilderMapLoader@@SA_NPB_W_N@Z
_TEXT	SEGMENT
_wszFilename$ = 8					; size = 4
_bScenario$ = 12					; size = 1
?Preload@CvWorldBuilderMapLoader@@SA_NPB_W_N@Z PROC	; CvWorldBuilderMapLoader::Preload, COMDAT

; 185  : {

	push	esi

; 186  : 	InitTypeDesc();

	call	?InitTypeDesc@@YAXXZ			; InitTypeDesc

; 187  : 
; 188  : 	// Re-initialize map info
; 189  : 	new(&sg_kMapInfo)CvWorldBuilderMapLoaderMapInfo();
; 190  : 
; 191  : 	if(sg_kSave.Load(wszFilename, sg_kMapTypeDesc))

	mov	eax, DWORD PTR _wszFilename$[esp]
	xor	esi, esi
	push	1
	push	OFFSET _sg_kMapTypeDesc
	push	eax
	mov	ecx, OFFSET _sg_kSave
	mov	DWORD PTR _sg_kMapInfo, esi
	mov	DWORD PTR _sg_kMapInfo+4, esi
	mov	DWORD PTR _sg_kMapInfo+8, esi
	mov	DWORD PTR _sg_kMapInfo+12, esi
	mov	DWORD PTR _sg_kMapInfo+16, esi
	mov	DWORD PTR _sg_kMapInfo+20, esi
	mov	BYTE PTR _sg_kMapInfo+24, 0
	mov	BYTE PTR _sg_kMapInfo+25, 0
	call	?Load@CvWorldBuilderMap@@QAE_NPB_WABVCvWorldBuilderMapTypeDesc@@_N@Z ; CvWorldBuilderMap::Load
	test	al, al
	je	$LN25@Preload
	push	ebx
	push	ebp

; 192  : 	{
; 193  : 		const uint uiPlotCount = sg_kSave.GetPlotCount();

	mov	ebp, DWORD PTR _sg_kSave+12228
	imul	ebp, DWORD PTR _sg_kSave+12232

; 194  : 
; 195  : 		if(!bScenario)

	cmp	BYTE PTR _bScenario$[esp+8], 0
	push	edi
	jne	SHORT $LN73@Preload

; 196  : 		{
; 197  : 			// Clear out all of the scenario data (except improvements)
; 198  : 			sg_kSave.ClearScenarioData(true);

	push	1
	mov	ecx, OFFSET _sg_kSave
	call	?ClearScenarioData@CvWorldBuilderMap@@QAEX_N@Z ; CvWorldBuilderMap::ClearScenarioData

; 199  : 
; 200  : 			// Remove all improvements that aren't goodies
; 201  : 			for(uint i = 0; i < uiPlotCount; ++i)

	xor	edi, edi
	cmp	ebp, esi
	jbe	SHORT $LN73@Preload

; 196  : 		{
; 197  : 			// Clear out all of the scenario data (except improvements)
; 198  : 			sg_kSave.ClearScenarioData(true);

	mov	ebx, OFFSET _sg_kSave+274464
	npad	10
$LL23@Preload:

; 202  : 			{
; 203  : 				CvWorldBuilderMap::PlotScenarioData& kPlot = sg_kSave.GetPlotScenarioData(i);

	mov	ecx, DWORD PTR _sg_kSave+12228
	imul	ecx, DWORD PTR _sg_kSave+12232
	cmp	edi, ecx
	jae	SHORT $LN38@Preload
	mov	esi, ebx
	cmp	edi, 32768				; 00008000H
	jb	SHORT $LN37@Preload
$LN38@Preload:
	mov	esi, OFFSET ?sm_kErrorPlotScenarioData@CvWorldBuilderMap@@0UPlotScenarioData@1@A ; CvWorldBuilderMap::sm_kErrorPlotScenarioData
$LN37@Preload:

; 204  : 				if(kPlot.m_byImprovement != CvWorldBuilderMap::PlotScenarioData::InvalidImprovement)

	mov	al, BYTE PTR [esi+5]
	cmp	al, 255					; 000000ffH
	je	SHORT $LN22@Preload

; 205  : 				{
; 206  : 					ImprovementTypes eType = (ImprovementTypes)kPlot.m_byImprovement;

	movzx	eax, al

; 207  : 					const CvImprovementEntry* pkImprovement = GC.getImprovementInfo(eType);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo

; 208  : 					if(pkImprovement == NULL || !pkImprovement->IsGoody())

	test	eax, eax
	je	SHORT $LN18@Preload
	mov	ecx, eax
	call	?IsGoody@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsGoody
	test	al, al
	jne	SHORT $LN22@Preload
$LN18@Preload:

; 209  : 						kPlot.m_byImprovement = CvWorldBuilderMap::PlotScenarioData::InvalidImprovement;

	mov	BYTE PTR [esi+5], 255			; 000000ffH
$LN22@Preload:

; 199  : 
; 200  : 			// Remove all improvements that aren't goodies
; 201  : 			for(uint i = 0; i < uiPlotCount; ++i)

	inc	edi
	add	ebx, 8
	cmp	edi, ebp
	jb	SHORT $LL23@Preload
	xor	esi, esi
$LN73@Preload:

; 210  : 				}
; 211  : 			}
; 212  : 		}
; 213  : 
; 214  : 		sg_kMapInfo.uiWidth = sg_kSave.GetWidth();
; 215  : 		sg_kMapInfo.uiHeight = sg_kSave.GetHeight();
; 216  : 
; 217  : 		sg_kMapInfo.uiPlayers = sg_kSave.GetPlayerCount();
; 218  : 		sg_kMapInfo.uiCityStates = sg_kSave.GetCityStateCount();

	movzx	eax, BYTE PTR _sg_kSave+12317
	mov	edx, DWORD PTR _sg_kSave+12228
	movzx	edi, BYTE PTR _sg_kSave+12316
	mov	ecx, DWORD PTR _sg_kSave+12232
	mov	DWORD PTR _sg_kMapInfo+12, eax

; 219  : 
; 220  : 		sg_kMapInfo.uiMajorCivStartingPositions = 0;
; 221  : 		sg_kMapInfo.uiMinorCivStartingPositions = 0;
; 222  : 
; 223  : 		sg_kMapInfo.bWorldWrap = sg_kSave.GetFlag(CvWorldBuilderMap::FLAG_WORLD_WRAP);

	mov	eax, DWORD PTR _sg_kSave+12224
	mov	DWORD PTR _sg_kMapInfo, edx
	mov	dl, al

; 224  : 		sg_kMapInfo.bRandomResources = sg_kSave.GetFlag(CvWorldBuilderMap::FLAG_RANDOM_RECOURCES);

	shr	eax, 1
	and	al, 1
	xor	ebx, ebx
	and	dl, 1
	mov	BYTE PTR _sg_kMapInfo+25, al

; 225  : 
; 226  : 		for(uint i = 0; i < uiPlotCount; ++i)

	xor	eax, eax
	mov	DWORD PTR _sg_kMapInfo+4, ecx
	mov	DWORD PTR _sg_kMapInfo+8, edi
	mov	DWORD PTR _sg_kMapInfo+16, esi
	mov	DWORD PTR _sg_kMapInfo+20, ebx
	mov	BYTE PTR _sg_kMapInfo+24, dl
	cmp	ebp, esi
	jbe	SHORT $LN15@Preload
	mov	esi, DWORD PTR _sg_kSave+12228
	imul	esi, ecx
	mov	edx, OFFSET _sg_kSave+12320
	npad	2
$LL17@Preload:

; 227  : 		{
; 228  : 			const CvWorldBuilderMap::PlotMapData& kPlotData = sg_kSave.GetPlotData(i);

	cmp	eax, esi
	jae	SHORT $LN54@Preload
	mov	ecx, edx
	cmp	eax, 32768				; 00008000H
	jb	SHORT $LN53@Preload
$LN54@Preload:
	mov	ecx, OFFSET ?sm_kErrorPlotMapData@CvWorldBuilderMap@@0VPlotMapData@1@A ; CvWorldBuilderMap::sm_kErrorPlotMapData
$LN53@Preload:

; 229  : 			if(kPlotData.GetFlag(CvWorldBuilderMap::PlotMapData::START_POS_MAJOR))

	mov	cl, BYTE PTR [ecx+3]
	test	cl, 64					; 00000040H
	je	SHORT $LN14@Preload

; 230  : 				sg_kMapInfo.uiMajorCivStartingPositions++;

	inc	DWORD PTR _sg_kMapInfo+16
	jmp	SHORT $LN16@Preload
$LN14@Preload:

; 231  : 			else if(kPlotData.GetFlag(CvWorldBuilderMap::PlotMapData::START_POS_MINOR))

	test	cl, cl
	jns	SHORT $LN16@Preload

; 232  : 				sg_kMapInfo.uiMinorCivStartingPositions++;

	inc	ebx
$LN16@Preload:

; 225  : 
; 226  : 		for(uint i = 0; i < uiPlotCount; ++i)

	inc	eax
	add	edx, 8
	cmp	eax, ebp
	jb	SHORT $LL17@Preload

; 232  : 				sg_kMapInfo.uiMinorCivStartingPositions++;

	mov	DWORD PTR _sg_kMapInfo+20, ebx
	xor	esi, esi
$LN15@Preload:

; 233  : 		}
; 234  : 
; 235  : 		const uint uiPlayerCount = sg_kSave.GetPlayerCount();
; 236  : 		if(uiPlayerCount > 0)

	cmp	edi, esi
	jbe	SHORT $LN8@Preload

; 237  : 		{
; 238  : 			for(uint i = 0; i < uiPlayerCount; ++i)

	test	edi, edi
	jbe	SHORT $LN8@Preload
	npad	1
$LL10@Preload:

; 239  : 			{
; 240  : 				const uint uiNew = sg_auiPlayerSlots[i];

	mov	ebx, DWORD PTR _sg_auiPlayerSlots[esi*4]

; 241  : 				if(uiNew != i)

	cmp	ebx, esi
	je	SHORT $LN9@Preload

; 242  : 				{
; 243  : 					if(uiNew < uiPlayerCount)

	cmp	ebx, edi
	jae	SHORT $LN9@Preload

; 244  : 					{
; 245  : #ifdef AUI_WARNING_FIXES
; 246  : 						sg_kSave.SwapPlayers(byte(uiNew), byte(i));
; 247  : #else
; 248  : 						sg_kSave.SwapPlayers(uiNew, i);

	push	esi
	push	ebx
	mov	ecx, OFFSET _sg_kSave
	call	?SwapPlayers@CvWorldBuilderMap@@QAEXEE@Z ; CvWorldBuilderMap::SwapPlayers

; 249  : #endif
; 250  : 
; 251  : 						for(uint j = i + 1; j < uiPlayerCount; ++j)

	lea	eax, DWORD PTR [esi+1]
	cmp	eax, edi
	jae	SHORT $LN9@Preload
$LL5@Preload:

; 252  : 						{
; 253  : 							if(sg_auiPlayerSlots[j] == i)

	cmp	DWORD PTR _sg_auiPlayerSlots[eax*4], esi
	je	SHORT $LN67@Preload
	inc	eax
	cmp	eax, edi
	jb	SHORT $LL5@Preload
	jmp	SHORT $LN9@Preload
$LN67@Preload:

; 254  : 							{
; 255  : 								sg_auiPlayerSlots[j] = uiNew;

	mov	DWORD PTR _sg_auiPlayerSlots[eax*4], ebx
$LN9@Preload:

; 237  : 		{
; 238  : 			for(uint i = 0; i < uiPlayerCount; ++i)

	inc	esi
	cmp	esi, edi
	jb	SHORT $LL10@Preload
$LN8@Preload:
	pop	edi
	pop	ebp
	pop	ebx

; 256  : 								break;
; 257  : 							}
; 258  : 						}
; 259  : 					}
; 260  : 				}
; 261  : 			}
; 262  : 		}
; 263  : 
; 264  : 		//ResetPlayerSlots();
; 265  : 
; 266  : 		return true;

	mov	al, 1
	pop	esi

; 271  : 	}
; 272  : }

	ret	0
$LN25@Preload:

; 267  : 	}
; 268  : 	else
; 269  : 	{
; 270  : 		return false;

	xor	al, al
	pop	esi

; 271  : 	}
; 272  : }

	ret	0
?Preload@CvWorldBuilderMapLoader@@SA_NPB_W_N@Z ENDP	; CvWorldBuilderMapLoader::Preload
_TEXT	ENDS
PUBLIC	?Load@CvWorldBuilderMapLoader@@SA_NPB_W@Z	; CvWorldBuilderMapLoader::Load
; Function compile flags: /Ogtpy
;	COMDAT ?Load@CvWorldBuilderMapLoader@@SA_NPB_W@Z
_TEXT	SEGMENT
_wszFilename$ = 8					; size = 4
?Load@CvWorldBuilderMapLoader@@SA_NPB_W@Z PROC		; CvWorldBuilderMapLoader::Load, COMDAT

; 1382 : 	InitTypeDesc();

	call	?InitTypeDesc@@YAXXZ			; InitTypeDesc

; 1383 : 
; 1384 : 	return sg_kSave.Load(wszFilename, sg_kMapTypeDesc) && InitMap();

	mov	eax, DWORD PTR _wszFilename$[esp-4]
	push	1
	push	OFFSET _sg_kMapTypeDesc
	push	eax
	mov	ecx, OFFSET _sg_kSave
	call	?Load@CvWorldBuilderMap@@QAE_NPB_WABVCvWorldBuilderMapTypeDesc@@_N@Z ; CvWorldBuilderMap::Load
	test	al, al
	je	SHORT $LN3@Load
	call	?InitMap@CvWorldBuilderMapLoader@@SA_NXZ ; CvWorldBuilderMapLoader::InitMap
	test	al, al
	je	SHORT $LN3@Load
	mov	eax, 1

; 1385 : }

	ret	0
$LN3@Load:

; 1383 : 
; 1384 : 	return sg_kSave.Load(wszFilename, sg_kMapTypeDesc) && InitMap();

	xor	eax, eax

; 1385 : }

	ret	0
?Load@CvWorldBuilderMapLoader@@SA_NPB_W@Z ENDP		; CvWorldBuilderMapLoader::Load
_TEXT	ENDS
PUBLIC	?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z	; CvWorldBuilderMapLoader::Save
EXTRN	?Save@CvWorldBuilderMap@@QBE_NPB_WABVCvWorldBuilderMapTypeDesc@@_N@Z:PROC ; CvWorldBuilderMap::Save
EXTRN	?GetContinentType@CvPlot@@QBEDXZ:PROC		; CvPlot::GetContinentType
EXTRN	?getRiverSWFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ:PROC ; CvPlot::getRiverSWFlowDirection
EXTRN	?isNEOfRiver@CvPlot@@QBE_NXZ:PROC		; CvPlot::isNEOfRiver
EXTRN	?getRiverSEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ:PROC ; CvPlot::getRiverSEFlowDirection
EXTRN	?isNWOfRiver@CvPlot@@QBE_NXZ:PROC		; CvPlot::isNWOfRiver
EXTRN	?getRiverEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ:PROC ; CvPlot::getRiverEFlowDirection
EXTRN	?isWOfRiver@CvPlot@@QBE_NXZ:PROC		; CvPlot::isWOfRiver
EXTRN	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::IsNaturalWonder
EXTRN	?getNumResource@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumResource
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?SetWorldType@CvWorldBuilderMap@@QAEXPBD@Z:PROC	; CvWorldBuilderMap::SetWorldType
EXTRN	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ:PROC	; CvMap::getWorldInfo
EXTRN	?CopyToUTF8@FStringW@@QBEXPAVFStringA@@@Z:PROC	; FStringW::CopyToUTF8
EXTRN	?ExtractFileTitle@FStringW@@QBEXAAV1@_W@Z:PROC	; FStringW::ExtractFileTitle
EXTRN	?Resize@CvWorldBuilderMap@@QAEXII@Z:PROC	; CvWorldBuilderMap::Resize
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvworldbuildermap\include\cvworldbuildermap.h
xdata$x	SEGMENT
__unwindtable$?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z$1
__ehfuncinfo$?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
xdata$x	ENDS
;	COMDAT ?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z
_TEXT	SEGMENT
_sFilename$225068 = -1100				; size = 4
_sFileTitle$225083 = -1096				; size = 4
tv638 = -1092						; size = 4
tv650 = -1088						; size = 4
_uiPlotCount$ = -1084					; size = 4
_kMap$ = -1080						; size = 4
_FStringFixedBuffer_sFilename$225082 = -1076		; size = 532
_FStringFixedBuffer_sFileTitle$225084 = -544		; size = 532
__$EHRec$ = -12						; size = 12
_wszFilename$ = 8					; size = 4
_szMapName$ = 12					; size = 4
?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z PROC	; CvWorldBuilderMapLoader::Save, COMDAT

; 1392 : {

	push	-1
	push	__ehhandler$?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 1088				; 00000440H
	push	ebx
	push	ebp
	push	esi

; 1393 : 	InitTypeDesc();

	call	?InitTypeDesc@@YAXXZ			; InitTypeDesc

; 1394 : 
; 1395 : 	CvMap& kMap = GC.getMap();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 1396 : 	sg_kSave.Resize(kMap.getGridWidth(), kMap.getGridHeight());

	mov	eax, DWORD PTR [ebx+4024]
	mov	ecx, DWORD PTR [ebx+4020]
	push	eax
	push	ecx
	mov	ecx, OFFSET _sg_kSave
	mov	DWORD PTR _kMap$[esp+1120], ebx
	call	?Resize@CvWorldBuilderMap@@QAEXII@Z	; CvWorldBuilderMap::Resize

; 1397 : 	sg_kSave.ClearScenarioData();

	xor	ebp, ebp
	push	ebp
	mov	ecx, OFFSET _sg_kSave
	call	?ClearScenarioData@CvWorldBuilderMap@@QAEX_N@Z ; CvWorldBuilderMap::ClearScenarioData

; 1398 : 
; 1399 : 	// Set map name
; 1400 : 	if(szMapName == NULL)

	mov	ecx, DWORD PTR _szMapName$[esp+1108]
	cmp	ecx, ebp
	jne	$LN179@Save

; 1401 : 	{
; 1402 : 		FStringFixedBufferW(sFilename, MAX_PATH);

	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _sFilename$225068[esp+1112], eax
	lea	eax, DWORD PTR _sFilename$225068[esp+1112]
	push	eax
	lea	ecx, DWORD PTR _FStringFixedBuffer_sFilename$225082[esp+1116]
	mov	DWORD PTR __$EHRec$[esp+1124], ebp
	call	??0?$FStringWFixedBuffer@$0BAE@@FStringW@@QAE@AAV1@@Z ; FStringW::FStringWFixedBuffer<260>::FStringWFixedBuffer<260>

; 1403 : 		FStringFixedBufferW(sFileTitle, MAX_PATH);

	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _sFileTitle$225083[esp+1112], eax
	lea	ecx, DWORD PTR _sFileTitle$225083[esp+1112]
	push	ecx
	lea	ecx, DWORD PTR _FStringFixedBuffer_sFileTitle$225084[esp+1116]
	mov	BYTE PTR __$EHRec$[esp+1124], 1
	call	??0?$FStringWFixedBuffer@$0BAE@@FStringW@@QAE@AAV1@@Z ; FStringW::FStringWFixedBuffer<260>::FStringWFixedBuffer<260>

; 1404 : 
; 1405 : 		sFilename = wszFilename;

	mov	esi, DWORD PTR _wszFilename$[esp+1108]
	cmp	esi, ebp
	je	SHORT $LN55@Save
	mov	eax, esi
	lea	edx, DWORD PTR [eax+2]
$LL180@Save:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	cmp	cx, bp
	jne	SHORT $LL180@Save
	sub	eax, edx
	sar	eax, 1
	jmp	SHORT $LN56@Save
$LN55@Save:
	xor	eax, eax
$LN56@Save:
	push	ebp
	push	esi
	push	eax
	lea	ecx, DWORD PTR _sFilename$225068[esp+1124]
	call	?Copy@FStringW@@QAEXHPB_WH@Z		; FStringW::Copy

; 1406 : 		sFilename.ExtractFileTitle(sFileTitle);

	push	92					; 0000005cH
	lea	edx, DWORD PTR _sFileTitle$225083[esp+1116]
	push	edx
	lea	ecx, DWORD PTR _sFilename$225068[esp+1120]
	call	?ExtractFileTitle@FStringW@@QBEXAAV1@_W@Z ; FStringW::ExtractFileTitle

; 1407 : 		sFileTitle.CopyToUTF8(&sg_kSave.m_sMapName);

	push	OFFSET _sg_kSave+4008
	lea	ecx, DWORD PTR _sFileTitle$225083[esp+1116]
	call	?CopyToUTF8@FStringW@@QBEXPAVFStringA@@@Z ; FStringW::CopyToUTF8

; 1408 : 	}

	mov	esi, DWORD PTR _sFileTitle$225083[esp+1112]
	add	esi, -12				; fffffff4H
	mov	BYTE PTR __$EHRec$[esp+1120], 0
	cmp	esi, ebp
	je	SHORT $LN63@Save
	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData
	cmp	esi, eax
	je	SHORT $LN63@Save
	cmp	WORD PTR [esi+10], bp
	jne	SHORT $LN63@Save
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN63@Save:
	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData
	mov	esi, DWORD PTR _sFilename$225068[esp+1112]
	add	eax, 12					; 0000000cH
	add	esi, -12				; fffffff4H
	mov	DWORD PTR _sFileTitle$225083[esp+1112], eax
	mov	DWORD PTR __$EHRec$[esp+1120], -1
	cmp	esi, ebp
	je	SHORT $LN76@Save
	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData
	cmp	esi, eax
	je	SHORT $LN76@Save
	cmp	WORD PTR [esi+10], bp
	jne	SHORT $LN76@Save
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN76@Save:
	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _sFilename$225068[esp+1112], eax

; 1409 : 	else

	jmp	SHORT $LN83@Save
$LN179@Save:

; 1410 : 	{
; 1411 : 		sg_kSave.m_sMapName = szMapName;

	mov	eax, ecx
	lea	esi, DWORD PTR [eax+1]
	npad	4
$LL181@Save:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL181@Save
	push	ebp
	push	ecx
	sub	eax, esi
	push	eax
	mov	ecx, OFFSET _sg_kSave+4008
	call	?Copy@FStringA@@QAEXHPBDH@Z		; FStringA::Copy
$LN83@Save:

; 1412 : 	}
; 1413 : 
; 1414 : 	sg_kSave.m_sMapDescription = "";

	push	ebp
	push	OFFSET $SG225086
	push	ebp
	mov	ecx, OFFSET _sg_kSave+4012
	call	?Copy@FStringA@@QAEXHPBDH@Z		; FStringA::Copy

; 1415 : 
; 1416 : 	sg_kSave.m_uiFlags = 0;
; 1417 : 	sg_kSave.SetFlag(CvWorldBuilderMap::FLAG_WORLD_WRAP, kMap.isWrapX());

	xor	eax, eax
	mov	DWORD PTR _sg_kSave+12224, ebp
	cmp	BYTE PTR [ebx+4056], al

; 1418 : 
; 1419 : 	sg_kSave.SetWorldType(kMap.getWorldInfo().GetType());

	mov	ecx, ebx
	setne	al
	mov	DWORD PTR _sg_kSave+12224, eax
	call	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ; CvMap::getWorldInfo
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET _sg_kSave
	call	?SetWorldType@CvWorldBuilderMap@@QAEXPBD@Z ; CvWorldBuilderMap::SetWorldType

; 1420 : 
; 1421 : 	uint uiPlotCount = sg_kSave.GetWidth() * sg_kSave.GetHeight();

	mov	eax, DWORD PTR _sg_kSave+12232
	imul	eax, DWORD PTR _sg_kSave+12228
	mov	DWORD PTR _uiPlotCount$[esp+1112], eax

; 1422 : 	for(uint i = 0; i < uiPlotCount; ++i)

	cmp	eax, ebp
	jbe	$LN24@Save
	mov	esi, OFFSET _sg_kSave+12320
	mov	DWORD PTR tv638[esp+1112], ebp
	mov	DWORD PTR tv650[esp+1112], esi
	push	edi
$LL184@Save:

; 1423 : 	{
; 1424 : 		CvWorldBuilderMap::PlotMapData& kPlotData = sg_kSave.GetPlotData(i);

	mov	ecx, DWORD PTR _sg_kSave+12232
	imul	ecx, DWORD PTR _sg_kSave+12228
	cmp	ebp, ecx
	jae	SHORT $LN108@Save
	cmp	ebp, 32768				; 00008000H
	jb	SHORT $LN107@Save
$LN108@Save:
	mov	esi, OFFSET ?sm_kErrorPlotMapData@CvWorldBuilderMap@@0VPlotMapData@1@A ; CvWorldBuilderMap::sm_kErrorPlotMapData
$LN107@Save:

; 1425 : 		CvPlot* pkPlot = kMap.plotByIndex(i);

	test	ebp, ebp
	jl	$LN25@Save
	cmp	ebp, DWORD PTR [ebx+4028]
	jge	$LN25@Save
	mov	edi, DWORD PTR [ebx+4068]
	add	edi, DWORD PTR tv638[esp+1116]

; 1426 : 		FAssertMsg(pkPlot, "Missing CvPlot for this location");
; 1427 : 		if(pkPlot == NULL) continue;

	je	$LN25@Save

; 1428 : 
; 1429 : 		kPlotData.SetTerrainType((byte)pkPlot->getTerrainType());

	mov	dl, BYTE PTR [edi+6]
	mov	BYTE PTR [esi], dl

; 1430 : 
; 1431 : 		PlotTypes ePlotType = pkPlot->getPlotType();

	movsx	eax, BYTE PTR [edi+5]

; 1432 : 		if(ePlotType == PLOT_HILLS)

	cmp	eax, 1
	jne	SHORT $LN22@Save

; 1433 : 			kPlotData.SetPlotHeight(CvWorldBuilderMap::PlotMapData::HILLS);

	mov	BYTE PTR [esi+4], al
	jmp	SHORT $LN20@Save
$LN22@Save:

; 1434 : 		else if(ePlotType == PLOT_MOUNTAIN)

	test	eax, eax
	setne	al
	dec	al
	and	al, 2
	mov	BYTE PTR [esi+4], al
$LN20@Save:

; 1435 : 			kPlotData.SetPlotHeight(CvWorldBuilderMap::PlotMapData::MOUNTAINS);
; 1436 : 		else
; 1437 : 			kPlotData.SetPlotHeight(CvWorldBuilderMap::
; 1438 : 			                        PlotMapData::FLAT_TERRAIN);
; 1439 : 
; 1440 : 		ResourceTypes eResourceType = pkPlot->getResourceType();

	push	-1
	mov	ecx, edi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType

; 1441 : 		if(eResourceType == NO_RESOURCE)

	cmp	eax, -1
	jne	SHORT $LN18@Save

; 1442 : 		{
; 1443 : 			kPlotData.SetResourceType(CvWorldBuilderMap::PlotMapData::InvalidResource);

	mov	BYTE PTR [esi+1], 255			; 000000ffH

; 1444 : 		}
; 1445 : 		else

	jmp	SHORT $LN133@Save
$LN18@Save:

; 1446 : 		{
; 1447 : 			kPlotData.SetResourceType((byte)eResourceType);
; 1448 : 			kPlotData.SetResourceAmount((byte)pkPlot->getNumResource());

	mov	ecx, edi
	mov	BYTE PTR [esi+1], al
	call	?getNumResource@CvPlot@@QBEHXZ		; CvPlot::getNumResource
	mov	BYTE PTR [esi+7], al
$LN133@Save:

; 1449 : 		}
; 1450 : 
; 1451 : 		FeatureTypes eFeatureType = pkPlot->getFeatureType();

	movsx	ebx, BYTE PTR [edi+432]

; 1452 : 		if(eFeatureType == NO_FEATURE)

	cmp	ebx, -1
	jne	SHORT $LN16@Save

; 1453 : 		{
; 1454 : 			kPlotData.SetFeatureType(CvWorldBuilderMap::PlotMapData::InvalidFeature);

	mov	BYTE PTR [esi+2], 255			; 000000ffH

; 1455 : 			kPlotData.SetNaturalWonderType(CvWorldBuilderMap::PlotMapData::InvalidNaturalWonder);
; 1456 : 		}
; 1457 : 		else

	jmp	SHORT $LN186@Save
$LN16@Save:

; 1458 : 		{
; 1459 : 			CvFeatureInfo* pkFeatureInfo = GC.getFeatureInfo(eFeatureType);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo

; 1460 : 			if(pkFeatureInfo != NULL && pkFeatureInfo->IsNaturalWonder())

	test	eax, eax
	je	SHORT $LN14@Save
	mov	ecx, eax
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	test	al, al
	je	SHORT $LN14@Save

; 1461 : 			{
; 1462 : 				kPlotData.SetFeatureType(CvWorldBuilderMap::PlotMapData::InvalidFeature);

	mov	BYTE PTR [esi+2], 255			; 000000ffH

; 1463 : 				kPlotData.SetNaturalWonderType((byte)eFeatureType);

	mov	BYTE PTR [esi+6], bl

; 1464 : 			}
; 1465 : 			else

	jmp	SHORT $LN149@Save
$LN14@Save:

; 1466 : 			{
; 1467 : 				kPlotData.SetFeatureType((byte)eFeatureType);

	mov	BYTE PTR [esi+2], bl
$LN186@Save:

; 1468 : 				kPlotData.SetNaturalWonderType(CvWorldBuilderMap::PlotMapData::InvalidNaturalWonder);

	mov	BYTE PTR [esi+6], 255			; 000000ffH
$LN149@Save:

; 1469 : 			}
; 1470 : 		}
; 1471 : 
; 1472 : 		if(pkPlot->isWOfRiver())

	mov	ecx, edi
	call	?isWOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isWOfRiver
	test	al, al
	je	SHORT $LN12@Save

; 1473 : 		{
; 1474 : 			kPlotData.SetFlag(CvWorldBuilderMap::PlotMapData::W_OF_RIVER);

	or	BYTE PTR [esi+3], 1

; 1475 : 			if(pkPlot->getRiverEFlowDirection() == FLOWDIRECTION_SOUTH)

	mov	ecx, edi
	call	?getRiverEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverEFlowDirection
	cmp	eax, 3
	jne	SHORT $LN11@Save

; 1476 : 				kPlotData.SetFlag(CvWorldBuilderMap::PlotMapData::RIVER_FLOW_S);

	or	BYTE PTR [esi+3], 8

; 1477 : 			else

	jmp	SHORT $LN157@Save
$LN11@Save:

; 1478 : 				kPlotData.ClearFlag(CvWorldBuilderMap::PlotMapData::RIVER_FLOW_S);

	and	BYTE PTR [esi+3], 247			; 000000f7H

; 1479 : 		}
; 1480 : 		else

	jmp	SHORT $LN157@Save
$LN12@Save:

; 1481 : 		{
; 1482 : 			kPlotData.ClearFlag(CvWorldBuilderMap::PlotMapData::W_OF_RIVER);

	and	BYTE PTR [esi+3], 254			; 000000feH
$LN157@Save:

; 1483 : 		}
; 1484 : 
; 1485 : 		if(pkPlot->isNWOfRiver())

	mov	ecx, edi
	call	?isNWOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isNWOfRiver
	test	al, al
	je	SHORT $LN8@Save

; 1486 : 		{
; 1487 : 			kPlotData.SetFlag(CvWorldBuilderMap::PlotMapData::NW_OF_RIVER);

	or	BYTE PTR [esi+3], 2

; 1488 : 			if(pkPlot->getRiverSEFlowDirection() == FLOWDIRECTION_NORTHEAST)

	mov	ecx, edi
	call	?getRiverSEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverSEFlowDirection
	cmp	eax, 1
	jne	SHORT $LN7@Save

; 1489 : 				kPlotData.SetFlag(CvWorldBuilderMap::PlotMapData::RIVER_FLOW_NE);

	or	BYTE PTR [esi+3], 16			; 00000010H

; 1490 : 			else

	jmp	SHORT $LN165@Save
$LN7@Save:

; 1491 : 				kPlotData.ClearFlag(CvWorldBuilderMap::PlotMapData::RIVER_FLOW_NE);

	and	BYTE PTR [esi+3], 239			; 000000efH

; 1492 : 		}
; 1493 : 		else

	jmp	SHORT $LN165@Save
$LN8@Save:

; 1494 : 		{
; 1495 : 			kPlotData.ClearFlag(CvWorldBuilderMap::PlotMapData::NW_OF_RIVER);

	and	BYTE PTR [esi+3], 253			; 000000fdH
$LN165@Save:

; 1496 : 		}
; 1497 : 
; 1498 : 		if(pkPlot->isNEOfRiver())

	mov	ecx, edi
	call	?isNEOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isNEOfRiver
	test	al, al
	je	SHORT $LN4@Save

; 1499 : 		{
; 1500 : 			kPlotData.SetFlag(CvWorldBuilderMap::PlotMapData::NE_OF_RIVER);

	or	BYTE PTR [esi+3], 4

; 1501 : 			if(pkPlot->getRiverSWFlowDirection() == FLOWDIRECTION_NORTHWEST)

	mov	ecx, edi
	call	?getRiverSWFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverSWFlowDirection
	cmp	eax, 5
	jne	SHORT $LN3@Save

; 1502 : 				kPlotData.SetFlag(CvWorldBuilderMap::PlotMapData::RIVER_FLOW_NW);

	or	BYTE PTR [esi+3], 32			; 00000020H

; 1503 : 			else

	jmp	SHORT $LN173@Save
$LN3@Save:

; 1504 : 				kPlotData.ClearFlag(CvWorldBuilderMap::PlotMapData::RIVER_FLOW_NW);

	and	BYTE PTR [esi+3], 223			; 000000dfH

; 1505 : 		}
; 1506 : 		else

	jmp	SHORT $LN173@Save
$LN4@Save:

; 1507 : 		{
; 1508 : 			kPlotData.ClearFlag(CvWorldBuilderMap::PlotMapData::NE_OF_RIVER);

	and	BYTE PTR [esi+3], 251			; 000000fbH
$LN173@Save:

; 1509 : 		}
; 1510 : 
; 1511 : #ifdef AUI_WARNING_FIXES
; 1512 : 		kPlotData.SetContinentType((byte)pkPlot->GetContinentType());
; 1513 : #else
; 1514 : 		kPlotData.SetContinentType(pkPlot->GetContinentType());

	mov	ecx, edi
	call	?GetContinentType@CvPlot@@QBEDXZ	; CvPlot::GetContinentType
	mov	ebx, DWORD PTR _kMap$[esp+1116]
	mov	BYTE PTR [esi+5], al
	mov	eax, DWORD PTR _uiPlotCount$[esp+1116]
$LN25@Save:
	mov	esi, DWORD PTR tv650[esp+1116]
	add	DWORD PTR tv638[esp+1116], 484		; 000001e4H
	inc	ebp
	add	esi, 8
	mov	DWORD PTR tv650[esp+1116], esi
	cmp	ebp, eax
	jb	$LL184@Save
	pop	edi
$LN24@Save:

; 1515 : #endif
; 1516 : 	}
; 1517 : 
; 1518 : 	return sg_kSave.Save(wszFilename, sg_kMapTypeDesc, false);

	mov	ecx, DWORD PTR _wszFilename$[esp+1108]
	push	0
	push	OFFSET _sg_kMapTypeDesc
	push	ecx
	mov	ecx, OFFSET _sg_kSave
	call	?Save@CvWorldBuilderMap@@QBE_NPB_WABVCvWorldBuilderMapTypeDesc@@_N@Z ; CvWorldBuilderMap::Save

; 1519 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+1112]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 1100				; 0000044cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z$0:
	lea	ecx, DWORD PTR _sFilename$225068[ebp]
	jmp	??1FStringW@@QAE@XZ			; FStringW::~FStringW
__unwindfunclet$?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z$1:
	lea	ecx, DWORD PTR _sFileTitle$225083[ebp]
	jmp	??1FStringW@@QAE@XZ			; FStringW::~FStringW
__ehhandler$?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z:
	mov	eax, OFFSET __ehfuncinfo$?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z ENDP	; CvWorldBuilderMapLoader::Save
EXTRN	_atexit:PROC
EXTRN	??0CvWorldBuilderMap@@QAE@XZ:PROC		; CvWorldBuilderMap::CvWorldBuilderMap
; Function compile flags: /Ogtpy
;	COMDAT ??__Esg_kSave@@YAXXZ
text$yc	SEGMENT
??__Esg_kSave@@YAXXZ PROC				; `dynamic initializer for 'sg_kSave'', COMDAT

; 24   : static CvWorldBuilderMap sg_kSave;

	mov	ecx, OFFSET _sg_kSave
	call	??0CvWorldBuilderMap@@QAE@XZ		; CvWorldBuilderMap::CvWorldBuilderMap
	push	OFFSET ??__Fsg_kSave@@YAXXZ		; `dynamic atexit destructor for 'sg_kSave''
	call	_atexit
	pop	ecx
	ret	0
??__Esg_kSave@@YAXXZ ENDP				; `dynamic initializer for 'sg_kSave''
text$yc	ENDS
EXTRN	??0CvWorldBuilderMapTypeDesc@@QAE@XZ:PROC	; CvWorldBuilderMapTypeDesc::CvWorldBuilderMapTypeDesc
; Function compile flags: /Ogtpy
;	COMDAT ??__Esg_kMapTypeDesc@@YAXXZ
text$yc	SEGMENT
??__Esg_kMapTypeDesc@@YAXXZ PROC			; `dynamic initializer for 'sg_kMapTypeDesc'', COMDAT

; 26   : static CvWorldBuilderMapTypeDesc sg_kMapTypeDesc;

	mov	ecx, OFFSET _sg_kMapTypeDesc
	call	??0CvWorldBuilderMapTypeDesc@@QAE@XZ	; CvWorldBuilderMapTypeDesc::CvWorldBuilderMapTypeDesc
	push	OFFSET ??__Fsg_kMapTypeDesc@@YAXXZ	; `dynamic atexit destructor for 'sg_kMapTypeDesc''
	call	_atexit
	pop	ecx
	ret	0
??__Esg_kMapTypeDesc@@YAXXZ ENDP			; `dynamic initializer for 'sg_kMapTypeDesc''
; Function compile flags: /Ogtpy
text$yc	ENDS
;	COMDAT ??__Esg_kTempMap@@YAXXZ
text$yc	SEGMENT
??__Esg_kTempMap@@YAXXZ PROC				; `dynamic initializer for 'sg_kTempMap'', COMDAT

; 2020 : static CvWorldBuilderMap sg_kTempMap;

	mov	ecx, OFFSET _sg_kTempMap
	call	??0CvWorldBuilderMap@@QAE@XZ		; CvWorldBuilderMap::CvWorldBuilderMap
	push	OFFSET ??__Fsg_kTempMap@@YAXXZ		; `dynamic atexit destructor for 'sg_kTempMap''
	call	_atexit
	pop	ecx
	ret	0
??__Esg_kTempMap@@YAXXZ ENDP				; `dynamic initializer for 'sg_kTempMap''
text$yc	ENDS
EXTRN	??1CvWorldBuilderMap@@QAE@XZ:PROC		; CvWorldBuilderMap::~CvWorldBuilderMap
; Function compile flags: /Ogtpy
;	COMDAT ??__Fsg_kSave@@YAXXZ
text$yd	SEGMENT
??__Fsg_kSave@@YAXXZ PROC				; `dynamic atexit destructor for 'sg_kSave'', COMDAT
	mov	ecx, OFFSET _sg_kSave
	jmp	??1CvWorldBuilderMap@@QAE@XZ		; CvWorldBuilderMap::~CvWorldBuilderMap
??__Fsg_kSave@@YAXXZ ENDP				; `dynamic atexit destructor for 'sg_kSave''
; Function compile flags: /Ogtpy
text$yd	ENDS
;	COMDAT ??__Fsg_kTempMap@@YAXXZ
text$yd	SEGMENT
??__Fsg_kTempMap@@YAXXZ PROC				; `dynamic atexit destructor for 'sg_kTempMap'', COMDAT
	mov	ecx, OFFSET _sg_kTempMap
	jmp	??1CvWorldBuilderMap@@QAE@XZ		; CvWorldBuilderMap::~CvWorldBuilderMap
??__Fsg_kTempMap@@YAXXZ ENDP				; `dynamic atexit destructor for 'sg_kTempMap''
; Function compile flags: /Ogtpy
text$yd	ENDS
;	COMDAT ??__Fsg_kMapTypeDesc@@YAXXZ
text$yd	SEGMENT
??__Fsg_kMapTypeDesc@@YAXXZ PROC			; `dynamic atexit destructor for 'sg_kMapTypeDesc'', COMDAT
	mov	ecx, OFFSET _sg_kMapTypeDesc
	jmp	??1CvWorldBuilderMapTypeDesc@@QAE@XZ
??__Fsg_kMapTypeDesc@@YAXXZ ENDP			; `dynamic atexit destructor for 'sg_kMapTypeDesc''
text$yd	ENDS
_BSS	SEGMENT
_sg_kTempMap DB	0eebe0H DUP (?)
_sg_kMapTypeDesc DB 0a0H DUP (?)
_sg_kMapInfo DB	01cH DUP (?)
_sg_kSave DB	0eebe0H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_sg_kSave$initializer$ DD FLAT:??__Esg_kSave@@YAXXZ
_sg_kMapTypeDesc$initializer$ DD FLAT:??__Esg_kMapTypeDesc@@YAXXZ
_sg_kTempMap$initializer$ DD FLAT:??__Esg_kTempMap@@YAXXZ
CRT$XCU	ENDS
END
